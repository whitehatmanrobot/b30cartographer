TATE                      /* pointer to state variables */
        int32 lX,                   /* x coordinate */
        int32 lY )                  /* scan index */
{
    int16 **ppsEnd;                 /* ptr to end array top */
    uint32 *pulBegin;               /* pts to first array element */
    uint32 *pulEnd;                 /* pts past last element */
    uint32 *pulLead;                /* leads pulEnd walking backward */
    int16 *psInsert;                /* new data insertion point */
    int16 sX;

    Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
    Assert(lX <= STATE.lBoxRight);
    
    if ((lY >= STATE.lLoScanBand) && (lY < STATE.lHiScanBand))
    {
        lY -= STATE.lLoScanBand;    /* normalize */
        pulBegin = (uint32*)STATE.apsHorizBegin[lY];
        ppsEnd = &STATE.apsHorizEnd[lY];
        pulEnd = (uint32*)*ppsEnd;
        (*ppsEnd) += 2;             /* value & tag */

        Assert(*ppsEnd <= STATE.apsHorizMax[lY]);

        pulLead = pulEnd - 1;
        sX = (int16)lX;

        while((pulLead >= pulBegin) && (*((int16*)pulLead) > sX))
        {
            *pulEnd-- = *pulLead--;  /* make room */
        }
        psInsert = (int16*)pulEnd;
        *psInsert = sX;              /* store new value */
        psInsert++;
        *psInsert = STATE.usScanTag; /* keep tag too */
    }
}


/*********************************************************************/

/*  When all contours have been scanned, fill in the bitmap          */

/*********************************************************************/

FS_PUBLIC int32 fsc_FillBitMap(
		PSTATE                          /* pointer to state variables */
		char *pchBitMap,                /* target memory */
		int32 lHiBand,                  /* top bitmap limit */
		int32 lLoBand,                  /* bottom bitmap limit */
		int32 lRowBytes,                /* bitmap bytes per row */
		int32 lOrgLoBand,               /* original low band row */
		uint16 usScanKind )             /* dropout control value */
{
	int32 lHeight;                      /* of scan band in pixels */
	int32 lIndex;                       /* array index */
	int32 lFirstScan;                   /* first scanline index */

	int16 sXOffset;                     /* bitmap box shift */
	int16 sXStart;                      /* on transition */
	int16 sXStop;                       /* off transition */
	
	uint32 *pulRow;                     /* row beginning pointer */
	uint32 ulBMPLongs;                  /* longs per bitmap */
	int32 lRowLongs;                    /* long words per row */
	int32 lErrCode;
	
	int16 **ppsHOnBegin;                /* for init speed */
	int16 **ppsHOnEnd;
	int16 **ppsHOffBegin;
			
	int16 *psHorizOn;
	int16 *psHorizOff;
	int16 *psHorizOnEnd;
	

/*  printf("%li : %li\n", lHiBand, lLoBand); */
	
	STATE.lHiBitBand = lHiBand;                 /* copy bit band limits */
	STATE.lLoBitBand = lLoBand;
	lHeight = STATE.lHiBitBand - STATE.lLoBitBand;
	
	STATE.lRowBytes = lRowBytes;                /* save bytes per row */
	lRowLongs = lRowBytes >> 2;                 /* long words per row */
	
	ulBMPLongs = (uint32)(lRowLongs * (int32)lHeight);
	pulRow = (uint32*)pchBitMap;                /* start at glyph top */
	lErrCode = fsc_ClearBitMap(ulBMPLongs, pulRow);
	if (lErrCode != NO_ERR) return lErrCode;

	sXOffset = (int16)STATE.lBoxLeft;
	
	lFirstScan = STATE.lHiBitBand - STATE.lLoScanBand - 1;
	ppsHOnBegin = &STATE.apsHOnBegin[lFirstScan];
	ppsHOffBegin = &STATE.apsHOffBegin[lFirstScan];
	ppsHOnEnd = &STATE.apsHOnEnd[lFirstScan];
						
/*  now go through the bitmap from top to bottom */

	for (lIndex = 0; lIndex < lHeight; lIndex++)
	{
		psHorizOn = *ppsHOnBegin;
		ppsHOnBegin--;
		psHorizOff = *ppsHOffBegin;
		ppsHOffBegin--;
		psHorizOnEnd = *ppsHOnEnd;
		ppsHOnEnd--;
				
		Assert(psHorizOnEnd <= psHorizOff);
		Assert(psHorizOnEnd - psHorizOn == STATE.apsHOffEnd[lFirstScan - lIndex] - psHorizOff);

		while (psHorizOn < psHorizOnEnd)
		{
			sXStart = *psHorizOn - sXOffset;
			psHorizOn += STATE.sIxSize;
			sXStop = *psHorizOff - sXOffset;
			psHorizOff += STATE.sIxSize;

			if (sXStart < sXStop)                   /* positive run */
			{
				lErrCode = fsc_BLTHoriz(sXStart, sXStop - 1, pulRow);
			}
			else if (sXStart > sXStop)              /* negative run */
			{
				lErrCode = fsc_BLTHoriz(sXStop, sXStart - 1, pulRow);
			}
			if (lErrCode != NO_ERR) return lErrCode;
		}
		pulRow += lRowLongs;                        /* next row */
	}
	
/* if doing dropout control, do it now */

	if (!(usScanKind & SK_NODROPOUT))               /* if any kind of dropout */
	{
		lErrCode = LookForDropouts(ASTATE pchBitMap, usScanKind);
		if (lErrCode != NO_ERR) return lErrCode;
		
		if (lOrgLoBand != STATE.lLoScanBand)        /* if fast banding & dropout */
		{
			pulRow -= lRowLongs;                    /* back to overscan row */
			pulRow -= lRowLongs;                    /* back to low row */
			lErrCode = fsc_BLTCopy (pulRow, STATE.pulLastRow, lRowLongs);
			if (lErrCode != NO_ERR) return lErrCode;

			STATE.lLastRowIndex = STATE.lLoBitBand + 1; /* save row ID */
		}
	}
	return NO_ERR;
}

/*********************************************************************/

/*      Dropout Control Functions                                    */

/*********************************************************************/
	
FS_PRIVATE int32 LookForDropouts(
		PSTATE                      /* pointer to state variables  */
		char *pchBitMap,
		uint16 usScanKind )         /* dropout control value */
{
	int16 **ppsHOnBegin;            /* for init speed */
	int16 **ppsHOnEnd;
	int16 **ppsHOffBegin;
			
	int16 *psHorizOn;
	int16 *psHorizOff;
	int16 *psHorizOnEnd;
	
	int16 **ppsVOnBegin;            /* for init speed */
	int16 **ppsVOnEnd;
	int16 **ppsVOffEnd;
			
	int16 *psVertOn;
	int16 *psVertOff;
	int16 *psVertOnBegin;

	int32 lHeight;
	int32 lWidth;
	int32 lIndex;                   /* array index */
	int32 lFirstScan;               /* first scanline index */
	
	int32 lErrCode;

/*  Check horizontal scan lines for dropouts  */
	
	lHeight = STATE.lHiBitBand - STATE.lLoBitBand;
	lFirstScan = STATE.lHiBitBand - STATE.lLoScanBand - 1;
	ppsHOnBegin = &STATE.apsHOnBegin[lFirstScan];
	ppsHOffBegin = &STATE.apsHOffBegin[lFirstScan];
	ppsHOnEnd = &STATE.apsHOnEnd[lFirstScan];
		
	for (lIndex = 0; lIndex < lHeight; lIndex++)
	{
		psHorizOn = *ppsHOnBegin;
		ppsHOnBegin--;
		psHorizOff = *ppsHOffBegin;
		ppsHOffBegin--;
		psHorizOnEnd = *ppsHOnEnd;
		ppsHOnEnd--;
		
		while (psHorizOn < psHorizOnEnd)
		{
			if (*psHorizOn == *psHorizOff)  /* zero length run */
			{
				lErrCode = DoHorizDropout(ASTATE psHorizOn, psHorizOff,
										 STATE.lHiBitBand - lIndex - 1,
										 pchBitMap,
										 usScanKind);
				if (lErrCode != NO_ERR) return lErrCode;
			}
			psHorizOn += STATE.sIxSize;
			psHorizOff += STATE.sIxSize;
		}
	}
		
/*  Check vertical scan lines for dropouts  */
	
	lWidth = STATE.lBoxRight - STATE.lBoxLeft;
	ppsVOnBegin = STATE.apsVOnBegin;
	ppsVOnEnd = STATE.apsVOnEnd;
	ppsVOffEnd = STATE.apsVOffEnd;
	
	for (lIndex = 0; lIndex < lWidth; lIndex++)
	{
		psVertOnBegin = *ppsVOnBegin;
		ppsVOnBegin++;
		psVertOn = *ppsVOnEnd - STATE.sIxSize;  /* start at end (glyph top) */
		ppsVOnEnd++;
		psVertOff = *ppsVOffEnd - STATE.sIxSize;
		ppsVOffEnd++;
		
		while (psVertOn >= psVertOnBegin)       /* from top to bottom */
		{
			if (*psVertOn == *psVertOff)        /* zero length run */
			{
				lErrCode = DoVertDropout(ASTATE psVertOn, psVertOff,
										 STATE.lBoxLeft + lIndex,
										 pchBitMap, usScanKind);
				if (lErrCode != NO_ERR) return lErrCode;
			}
			psVertOn -= STATE.sIxSize;
			psVertOff -= STATE.sIxSize;
		}
	}
	return NO_ERR;
}


/*********************************************************************/

FS_PRIVATE int32 DoHorizDropout(
		PSTATE                  /* pointer to state variables */
		int16 *psOn,            /* pointer to on intersection */
		int16 *psOff,           /* pointer to off intersection */
		int32 lYDrop,           /* y coord of dropout */
		char *pchBitMap,        /* target memory */
		uint16 usScanKind )     /* dropout control value */
{
	int32 lXDrop;                                   /* x coord of dropout */
	int32 lCross;                                   /* scanline crossings */
	F26Dot6 fxX1, fxX2;                             /* for smart dropout */
	uint16 usOnTag, usOffTag;                       /* element info */
	int16 sOnPt, sOffPt;                            /* element list index */
	F26Dot6 (*pfnOn)(int32, F26Dot6*, F26Dot6*);    /* on callback */
	F26Dot6 (*pfnOff)(int32, F26Dot6*, F26Dot6*);   /* off callback */

	lXDrop = (int32)*psOn;
	
/*  if stub control on, check for stubs  */

	if (usScanKind & SK_STUBS)
	{
		lCross = HorizCrossings(ASTATE lXDrop, lYDrop + 1);
		lCross += VertCrossings(ASTATE lXDrop - 1, lYDrop + 1);
		lCross += VertCrossings(ASTATE lXDrop, lYDrop + 1);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation above */
		}
		
		lCross = HorizCrossings(ASTATE lXDrop, lYDrop - 1);
		lCross += VertCrossings(ASTATE lXDrop - 1, lYDrop);
		lCross += VertCrossings(ASTATE lXDrop, lYDrop);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation below */
		}
	}

/*  passed stub control, now check pixels left and right  */

	if (lXDrop > STATE.lBoxLeft)                /* if pixel to left */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop - 1, lYDrop) != 0L)
		{
			return NO_ERR;                      /* no dropout needed */
		}
	}
	if (lXDrop < STATE.lBoxRight)               /* if pixel to right */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop) != 0L)
		{
			return NO_ERR;                      /* no dropout needed */
		}
	}

/*  no pixels left or right, now determine bit placement  */

	if (usScanKind & SK_SMART)
	{
		usOnTag = (uint16)*(psOn+1);
		sOnPt = (int16)(usOnTag >> SC_CODESHFT);
		pfnOn = STATE.pfnHCallBack[usOnTag & SC_CODEMASK];
		fxX1 = pfnOn(lYDrop, &STATE.afxXPoints[sOnPt], &STATE.afxYPoints[sOnPt]);
		
		usOffTag = (uint16)*(psOff+1);
		sOffPt = (int16)(usOffTag >> SC_CODESHFT);
		pfnOff = STATE.pfnHCallBack[usOffTag & SC_CODEMASK];
		fxX2 = pfnOff(lYDrop, &STATE.afxXPoints[sOffPt], &STATE.afxYPoints[sOffPt]);
		
		lXDrop = (int32)((fxX1 + fxX2 - 1) >> (SUBSHFT + 1));     /* average */
	}
	else                                        /* simple dropout */
	{
		lXDrop--;                               /* always to the left */
	}
	
	if (lXDrop < STATE.lBoxLeft)                /* confine to bounding box */
	{
		lXDrop = STATE.lBoxLeft;
	}
	if (lXDrop >= STATE.lBoxRight)
	{
		lXDrop = STATE.lBoxRight - 1L;
	}

	return SetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop);  /* turn on dropout pix */
}


/*********************************************************************/

FS_PRIVATE int32 DoVertDropout(
		PSTATE                      /* pointer to state variables */
		int16 *psOn,                /* pointer to on intersection */
		int16 *psOff,               /* pointer to off intersection */
		int32 lXDrop,               /* x coord of dropout */
		char *pchBitMap,            /* target memory descriptor */
		uint16 usScanKind )         /* dropout control value */
{
	int32 lYDrop;                                 /* y coord of dropout */
	int32 lCross;                                 /* scanline crossings */
	F26Dot6 fxY1, fxY2;                           /* for smart dropout */
	uint16 usOnTag, usOffTag;                     /* element info */
	int16 sOnPt, sOffPt;                          /* element list index */
	F26Dot6 (*pfnOn)(int32, F26Dot6*, F26Dot6*);  /* on callback */
	F26Dot6 (*pfnOff)(int32, F26Dot6*, F26Dot6*); /* off callback */
	
	lYDrop = (int32)*psOn;

	if ((lYDrop < STATE.lLoBitBand) || (lYDrop > STATE.lHiBitBand))
	{
		return NO_ERR;                          /* quick return for outside band */
	}

/*  if stub control on, check for stubs  */

	if (usScanKind & SK_STUBS)
	{
		lCross = VertCrossings(ASTATE lXDrop - 1, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop, lYDrop - 1);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation to left */
		}
		
		lCross = VertCrossings(ASTATE lXDrop + 1, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop + 1, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop + 1, lYDrop - 1);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation to right */
		}
	}

/*  passed stub control, now check pixels below and above  */

	if (lYDrop > STATE.lBoxBottom)                  /* if pixel below */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop - 1) != 0L)
		{
			return NO_ERR;                          /* no dropout needed */
		}
	}
	if (lYDrop < STATE.lBoxTop)                     /* if pixel above */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop) != 0L)
		{
			return NO_ERR;                          /* no dropout needed */
		}
	}

/*  no pixels above or below, now determine bit placement  */
	
	if (usScanKind & SK_SMART)
	{
		usOnTag = (uint16)*(psOn+1);
		sOnPt = (int16)(usOnTag >> SC_CODESHFT);
		pfnOn = STATE.pfnVCallBack[usOnTag & SC_CODEMASK];
		fxY1 = pfnOn(lXDrop, &STATE.afxXPoints[sOnPt], &STATE.afxYPoints[sOnPt]);
		
		usOffTag = (uint16)*(psOff+1);
		sOffPt = (int16)(usOffTag >> SC_CODESHFT);
		pfnOff = STATE.pfnVCallBack[usOffTag & SC_CODEMASK];
		fxY2 = pfnOff(lXDrop, &STATE.afxXPoints[sOffPt], &STATE.afxYPoints[sOffPt]);
		
		lYDrop = (int32)((fxY1 + fxY2 - 1) >> (SUBSHFT + 1));     /* average */
	}
	else                                        /* simple dropout */
	{
		lYDrop--;                               /* always below */
	}
	
	if (lYDrop < STATE.lBoxBottom)              /* confine to bounding box */
	{
		lYDrop = STATE.lBoxBottom;
	}
	if (lYDrop >= STATE.lBoxTop)
	{
		lYDrop = STATE.lBoxTop - 1L;
	}
		
	if ((lYDrop >= STATE.lLoBitBand) && (lYDrop < STATE.lHiBitBand))
	{
		return SetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop);  /* turn on dropout pix */
	}
	return NO_ERR;
}


/*********************************************************************/

/*  Count contour crossings of a horizontal scan line segment  */

FS_PRIVATE int32 HorizCrossings(
		PSTATE                          /* pointer to state variables */
		int32 lX,
		int32 lY )
{
	int32 lCrossings;
	int32 lIndex;
	
	int16 *psOn;
	int16 *psOff;
	int16 *psOnEnd;
	int16 sX;
	
	if ((lY < STATE.lLoScanBand) || (lY >= STATE.lHiScanBand))
	{
		return 0;                       /* if outside the scan region */
	}
	
	lCrossings = 0;
	lIndex = lY - STATE.lLoScanBand;
	psOn = STATE.apsHOnBegin[lIndex];
	psOff = STATE.apsHOffBegin[lIndex];
	psOnEnd = STATE.apsHOnEnd[lIndex];
	sX = (int16)lX;
	
	while (psOn < psOnEnd)
	{
		if (*psOn == sX)
		{
			lCrossings++;
		}
		psOn += STATE.sIxSize;
		
		if (*psOff == sX)
		{
			lCrossings++;
		}
		psOff += STATE.sIxSize;
	}
	return lCrossings;
}


/*********************************************************************/

/*  Count contour crossings of a vertical scan line segment  */

FS_PRIVATE int32 VertCrossings(
		PSTATE                          /* pointer to state variables */
		int32 lX,
		int32 lY )
{
	int32 lCrossings;
	int32 lIndex;
	
	int16 *psOn;
	int16 *psOff;
	int16 *psOnEnd;
	int16 sY;
	
	if ((lX < STATE.lBoxLeft) || (lX >= STATE.lBoxRight))
	{
		return 0;                       /* if outside the bitmap */
	}
	
	lCrossings = 0;
	lIndex = lX - STATE.lBoxLeft;
	psOn = STATE.apsVOnBegin[lIndex];
	psOff = STATE.apsVOffBegin[lIndex];
	psOnEnd = STATE.apsVOnEnd[lIndex];
	sY = (int16)lY;
	
	while (psOn < psOnEnd)
	{
		if (*psOn == sY)
		{
			lCrossings++;
		}
		psOn += STATE.sIxSize;
		
		if (*psOff == sY)
		{
			lCrossings++;
		}
		psOff += STATE.sIxSize;
	}
	return lCrossings;
}
		

/****************************************************************************/

/*              Get a pixel using absolute coordinates                      */

/*  When banding with dropout control, this routine uses the last low row   */
/*  of the previous bitmap when possible.                                   */

FS_PRIVATE uint32 GetBitAbs(
		PSTATE                              /* pointer to state variables */
		char *pchBitMap,
		int32 lX,
		int32 lY )
{
	uint32 *pulRow;                         /* bitmap row pointer */

	Assert(lX >= STATE.lBoxLeft);           /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY < STATE.lBoxTop);

	if ((lY < STATE.lHiBitBand) && (lY >= STATE.lLoBitBand))  /* if within the bitmap */
	{
		pulRow = (uint32*)(pchBitMap + ((STATE.lHiBitBand - 1 - lY) * STATE.lRowBytes));
		return fsc_GetBit(lX - STATE.lBoxLeft, pulRow);       /* read the bitmap */
	}
	if (lY == STATE.lLastRowIndex)          /* if saved from last band */
	{
		return fsc_GetBit(lX - STATE.lBoxLeft, STATE.pulLastRow);
	}
	return(0L);                             /* outside bitmap doesn't matter */
}


/*********************************************************************/

/*  Set a pixel using absolute coordinates  */

FS_PRIVATE int32 SetBitAbs(
		PSTATE                              /* pointer to state variables */
		char *pchBitMap,
		int32 lX,
		int32 lY )
{
	uint32 *pulRow;                         /* bitmap row pointer */
	
	Assert(lX >= STATE.lBoxLeft);           /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lLoBitBand);
	Assert(lY < STATE.lHiBitBand);
	
	pulRow = (uint32*)(pchBitMap + ((STATE.lHiBitBand - 1 - lY) * STATE.lRowBytes));
	
	return fsc_SetBit(lX - STATE.lBoxLeft, pulRow);
}


/*********************************************************************/

/*      Gray Scale Pass Through Functions                            */

/*********************************************************************/

FS_PUBLIC int32 fsc_ScanClearBitMap (
		uint32 ulCount,                     /* longs per bmp */
		uint32* pulBitMap                   /* bitmap ptr caste long */
)
{
	return fsc_ClearBitMap(ulCount, pulBitMap);
}


/*********************************************************************/

FS_PUBLIC int32 fsc_ScanCalcGrayRow(
		GrayScaleParam* pGSP                /* pointer to param block */
)
{
	return fsc_CalcGrayRow(pGSP);
}

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scendpt.h ===
/*********************************************************************

	  scendpt.h -- EndPoint Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   3/19/93 deanb    size_t replaced with int32
	  10/28/92 deanb    reentrant params renamed, mem req redone
	  10/09/92 deanb    PSTP added
	   9/25/92 deanb    include scan control type 
	   9/09/92 deanb    GetEndpointElemSize returns size_t 
	   9/08/92 deanb    GetEndpointElemSize added 
	   7/24/92 deanb    ContourSave functions deleted 
	   4/09/92 deanb    New types again 
	   3/20/92 deanb    New types, save contour functions 
	   1/14/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupEndPt ( PSTATE0 );

FS_PUBLIC void fsc_BeginContourEndpoint( 
		PSTATE              /* pointer to state variables */
		F26Dot6,            /* starting point x coordinate */
		F26Dot6             /* starting point y coordinate */
);

FS_PUBLIC int32 fsc_CheckEndPoint( 
		PSTATE              /* pointer to state variables */
		F26Dot6,            /* x coordinate */
		F26Dot6,            /* y coordinate */
		uint16              /* scan control type */
);

FS_PUBLIC int32 fsc_EndContourEndpoint( 
		PSTATE              /* pointer to state variables */
		uint16              /* scan control type */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scendpt.c ===
/*********************************************************************

	  scendpt.c -- New Scan Converter EndPoint Module

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   6/10/93  deanb   assert.h and stdio.h removed
	   3/19/93  deanb   size_t replaced with int32
	  10/28/92  deanb   reentrant params renamed
	  10/09/92  deanb   reentrant
	   9/25/92  deanb   branch on scan kind 
	   9/14/92  deanb   check vert topology written 
	   9/10/92  deanb   first dropout code 
	   8/18/92  deanb   include struc.h, scconst.h 
	   6/18/92  deanb   int x coord for HorizScanAdd 
	   5/08/92  deanb   reordered includes for precompiled headers 
	   4/21/92  deanb   Single HorizScanAdd 
	   4/09/92  deanb   New types 
	   4/06/92  deanb   Check Topology corrected 
	   4/02/92  deanb   Coded 
	   3/23/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */

#include    "scglobal.h"            /* structures & constants */
#include    "scanlist.h"            /* saves scan line intersections */
#include    "scendpt.h"             /* for own function prototypes */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE void CheckHorizTopology( PSTATE F26Dot6, F26Dot6, uint16 );
FS_PRIVATE void CheckVertTopology( PSTATE F26Dot6, F26Dot6, uint16 );

FS_PRIVATE void AddHorizOn( PSTATE uint16 );
FS_PRIVATE void AddHorizOff( PSTATE uint16 );
FS_PRIVATE void AddVertOn( PSTATE uint16 );
FS_PRIVATE void AddVertOff( PSTATE uint16 );

FS_PRIVATE F26Dot6 CalcHorizEpSubpix( int32, F26Dot6*, F26Dot6* );
FS_PRIVATE F26Dot6 CalcVertEpSubpix( int32, F26Dot6*, F26Dot6* );


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/

/*  pass callback routine pointers to scanlist for smart dropout control */

FS_PUBLIC void fsc_SetupEndPt (PSTATE0) 
{
	fsc_SetupCallBacks(ASTATE SC_ENDPTCODE, CalcHorizEpSubpix, CalcVertEpSubpix);
}

/*********************************************************************/

FS_PUBLIC void fsc_BeginContourEndpoint( 
		PSTATE               /* pointer to state variables */
		F26Dot6 fxX,         /* starting point x coordinate */
		F26Dot6 fxY )        /* starting point y coordinate */
{
	STATE.fxX1 = fxX;                   /* last = contour start point */
	STATE.fxY1 = fxY;
	STATE.fxX0 = HUGEFIX;               /* contour begin alert */
}


/*********************************************************************/

FS_PUBLIC int32 fsc_CheckEndPoint( 
		PSTATE               /* pointer to state variables */
		F26Dot6 fxX2,        /* x coordinate */
		F26Dot6 fxY2,        /* y coordinate */
		uint16 usScanKind )  /* dropout control type */
{
	if (ONSCANLINE(STATE.fxY1))             /* if y1 is on scan line */
	{
		if ((STATE.fxX1 == fxX2) && (STATE.fxY1 == fxY2)) /* catch dup'd points */
		{
			return NO_ERR;                  /*   and just ignore them   */
		}
				
		if (STATE.fxX0 == HUGEFIX)          /* if contour begin */
		{
			STATE.fxX2Save = fxX2;          /*   keep for contour end   */
			STATE.fxY2Save = fxY2;          
		}
		else                                /* if mid contour */
		{
			CheckHorizTopology(ASTATE fxX2, fxY2, usScanKind);
		}               
	}
	
	if (!(usScanKind & SK_NODROPOUT))       /* if dropout control on */
	{
		if (ONSCANLINE(STATE.fxX1))         /* if x1 is on scan line */
		{
			if ((STATE.fxX1 == fxX2) && (STATE.fxY1 == fxY2)) /* catch dup'd points */
			{
				return NO_ERR;              /*   and just ignore them   */
			}
				
			if (STATE.fxX0 == HUGEFIX)      /* if contour begin */
			{
				STATE.fxX2Save = fxX2;      /*   keep for contour end   */
				STATE.fxY2Save = fxY2;
			}
			else                            /* if mid contour */
			{
				CheckVertTopology(ASTATE fxX2, fxY2, usScanKind);
			}               
		}
	}

	STATE.fxX0 = STATE.fxX1;                /* old = last */
	STATE.fxY0 = STATE.fxY1;
	STATE.fxX1 = fxX2;                      /* last = current */
	STATE.fxY1 = fxY2;
	
	return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC int32 fsc_EndContourEndpoint( 
		PSTATE                          /* pointer to state variables */
		uint16 usScanKind )             /* dropout control type */
{
	if (ONSCANLINE(STATE.fxY1))             /* if y1 is on scan line */
	{
		CheckHorizTopology(ASTATE STATE.fxX2Save, STATE.fxY2Save, usScanKind);
	}
	
	if (!(usScanKind & SK_NODROPOUT))       /* if dropout control on */
	{
		if (ONSCANLINE(STATE.fxX1))         /* if x1 is on scan line */
		{
			CheckVertTopology(ASTATE STATE.fxX2Save, STATE.fxY2Save, usScanKind);
		}
	}
	return NO_ERR;
}

/*********************************************************************/

/*      Private Functions      */

/*********************************************************************/

/*      Implement the endpoint-on-horiz-scanline case table    */

FS_PRIVATE void CheckHorizTopology(PSTATE F26Dot6 fxX2, F26Dot6 fxY2, uint16 usScanKind)
{

/* printf("(%li, %li)", fxX2, fxY2); */

	if (fxY2 > STATE.fxY1)
	{
		if (STATE.fxY1 > STATE.fxY0)
		{
			AddHorizOn(ASTATE usScanKind);
		}
		else if (STATE.fxY1 < STATE.fxY0)
		{
			AddHorizOn(ASTATE usScanKind);
			AddHorizOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxY1 == STATE.fxY0) */
		{
			if (STATE.fxX1 < STATE.fxX0)
			{
				AddHorizOn(ASTATE usScanKind);
			}
		}
	}
	else if (fxY2 < STATE.fxY1)
	{
		if (STATE.fxY1 > STATE.fxY0)
		{
			AddHorizOn(ASTATE usScanKind);
			AddHorizOff(ASTATE usScanKind);
		}
		else if (STATE.fxY1 < STATE.fxY0)
		{
			AddHorizOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxY1 == STATE.fxY0) */
		{
			if (STATE.fxX1 > STATE.fxX0)
			{
				AddHorizOff(ASTATE usScanKind);
			}
		}
	}
	else                        /* (fxY2 == STATE.fxY1) */
	{
		if (STATE.fxY1 > STATE.fxY0)
		{
			if (fxX2 > STATE.fxX1)
			{
				AddHorizOn(ASTATE usScanKind);
			}
		}
		else if (STATE.fxY1 < STATE.fxY0)
		{
			if (fxX2 < STATE.fxX1)
			{
				AddHorizOff(ASTATE usScanKind);
			}
		}
		else                    /* (STATE.fxY1 == STATE.fxY0) */
		{
			if ((STATE.fxX1 > STATE.fxX0) && (fxX2 < STATE.fxX1))
			{
				AddHorizOff(ASTATE usScanKind);
			}
			else if ((STATE.fxX1 < STATE.fxX0) && (fxX2 > STATE.fxX1))
			{
				AddHorizOn(ASTATE usScanKind);
			}
		}
	}
}


/*********************************************************************/

/*      Implement the endpoint-on-vert-scanline case table      */

FS_PRIVATE void CheckVertTopology(PSTATE F26Dot6 fxX2, F26Dot6 fxY2, uint16 usScanKind)
{
	if (fxX2 < STATE.fxX1)
	{
		if (STATE.fxX1 < STATE.fxX0)
		{
			AddVertOn(ASTATE usScanKind);
		}
		else if (STATE.fxX1 > STATE.fxX0)
		{
			AddVertOn(ASTATE usScanKind);
			AddVertOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxX1 == STATE.fxX0) */
		{
			if (STATE.fxY1 < STATE.fxY0)
			{
				AddVertOn(ASTATE usScanKind);
			}
		}
	}
	else if (fxX2 > STATE.fxX1)
	{
		if (STATE.fxX1 < STATE.fxX0)
		{
			AddVertOn(ASTATE usScanKind);
			AddVertOff(ASTATE usScanKind);
		}
		else if (STATE.fxX1 > STATE.fxX0)
		{
			AddVertOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxX1 == STATE.fxX0) */
		{
			if (STATE.fxY1 > STATE.fxY0)
			{
				AddVertOff(ASTATE usScanKind);
			}
		}
	}
	else                        /* (fxX2 == STATE.fxX1) */
	{
		if (STATE.fxX1 < STATE.fxX0)
		{
			if (fxY2 > STATE.fxY1)
			{
				AddVertOn(ASTATE usScanKind);
			}
		}
		else if (STATE.fxX1 > STATE.fxX0)
		{
			if (fxY2 < STATE.fxY1)
			{
				AddVertOff(ASTATE usScanKind);
			}
		}
		else                    /* (STATE.fxX1 == STATE.fxX0) */
		{
			if ((STATE.fxY1 > STATE.fxY0) && (fxY2 < STATE.fxY1))
			{
				AddVertOff(ASTATE usScanKind);
			}
			else if ((STATE.fxY1 < STATE.fxY0) && (fxY2 > STATE.fxY1))
			{
				AddVertOn(ASTATE usScanKind);
			}
		}
	}
}


/*********************************************************************/
	
FS_PRIVATE void AddHorizOn( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 1, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */
	
	lXScan = (int32)((STATE.fxX1 + SUBHALF - 1) >> SUBSHFT);
	lYScan = (int32)(STATE.fxY1 >> SUBSHFT);
	
	pfnAddHorizScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/
	
FS_PRIVATE void AddHorizOff( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 4, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */

	lXScan = (int32)((STATE.fxX1 + SUBHALF) >> SUBSHFT);
	lYScan = (int32)(STATE.fxY1 >> SUBSHFT);
	
	pfnAddHorizScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/
	
FS_PRIVATE void AddVertOn( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 2, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */

	lYScan = (int32)((STATE.fxY1 + SUBHALF - 1) >> SUBSHFT);
	lXScan = (int32)(STATE.fxX1 >> SUBSHFT);
	
	pfnAddVertScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/
	
FS_PRIVATE void AddVertOff( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 1, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */

	lYScan = (int32)((STATE.fxY1 + SUBHALF) >> SUBSHFT);
	lXScan = (int32)(STATE.fxX1 >> SUBSHFT);
	
	pfnAddVertScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/

/*      Private Callback Functions                                   */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizEpSubpix(int32 lYScan, 
									 F26Dot6 *pfxX, 
									 F26Dot6 *pfxY )
{
	FS_UNUSED_PARAMETER(lYScan);
	FS_UNUSED_PARAMETER(pfxY);

/* printf("HorizEndpt(%li %li)\n", *pfxX, *pfxY); */

	return *pfxX;                           /* exact intersection */
}


/*********************************************************************/

FS_PRIVATE F26Dot6 CalcVertEpSubpix(int32 lXScan, 
									F26Dot6 *pfxX, 
									F26Dot6 *pfxY )
{
	FS_UNUSED_PARAMETER(lXScan);
	FS_UNUSED_PARAMETER(pfxX);

/* printf("VertEndpt (%li %li)\n", *pfxX, *pfxY); */

	return *pfxY;                           /* exact intersection */
}


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scentry.c ===
/*********************************************************************

      scentry.c -- New Scan Converter NewScan Module

      (c) Copyright 1992-1997  Microsoft Corp.  All rights reserved.

      10/14/97  claudebe    accessing unitialized memory
       1/31/95  deanb       added fsc_GetCoords function
       8/04/94  deanb       State initialized to more it out of bss
       8/24/93  deanb       flatcount fix to reversal detection
       8/10/93  deanb       gray scale support routines added
       6/22/93  deanb       all black bounding box, (0,0) for null glyph
       6/11/93  gregh       Removed ONCURVE definition
       6/11/93  deanb       if HiBand <= LoBand do entire bitmap
       6/10/93  deanb       fsc_Initialize added, stdio & assert gone
       4/06/92  deanb       CheckContour removed
       3/19/92  deanb       ScanArrays rather than lists
      12/22/92  deanb       MultDivide -> LongMulDiv; Rectangle -> Rect
      12/21/92  deanb       interface types aligned with rasterizer
      12/11/92  deanb       fserror.h imported, new error codes
      11/30/92  deanb       WorkSpace renamed WorkScan
      11/04/92  deanb       remove duplicate points function added
      10/28/92  deanb       memory requirement calculation reworked
      10/19/92  deanb       bad contours ignored rather than error'd
      10/16/92  deanb       first contour point off curve fix
      10/13/92  deanb       rect.bounds correction
      10/12/92  deanb       reentrant State implemented
      10/08/92  deanb       reworked for split workspace
      10/05/92  deanb       global ListMemory replace with stListSize 
       9/25/92  deanb       scankind included in line/spline/endpoint calls 
       9/10/92  deanb       dropout coding begun 
       9/08/92  deanb       MAXSPLINELENGTH now imported from scspline.h 
       8/18/92  deanb       New i/f for dropout control, contour elems 
       7/28/92  deanb       Recursive calls for up/down & left/right 
       7/23/92  deanb       EvaluateSpline included 
       7/17/92  deanb       Included EvaluateLine 
       7/13/92  deanb       Start/End point made SHORT 
       6/01/92  deanb       fsc_FillBitMap debug switch added 
       5/08/92  deanb       reordered includes for precompiled headers 
       4/27/92  deanb       Splines coded 
       4/09/92  deanb       New types 
       4/06/92  deanb       rectBounds calc corrected 
       3/30/92  deanb       MinMax calc added to MeasureContour 
       3/24/92  deanb       GetWorkspaceSize coded 
       3/23/92  deanb       First cut 
 
**********************************************************************/

/*********************************************************************/

/*        Imports                                                    */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types  */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for LongMulDiv */

#include    "scglobal.h"            /* structures & constants */
#include    "scgray.h"              /* gray scale param block */
#include    "scspline.h"            /* spline evaluation */
#include    "scline.h"              /* line evaluation */
#include    "scendpt.h"             /* for init and contour list */
#include    "scanlist.h"            /* for init and bitmap */
#include    "scmemory.h"            /* for setup mem */
#include    "scentry.h"             /* for own function prototypes */

/*********************************************************************/
                                             
/*      Global state structure                                       */

/*********************************************************************/

#ifndef FSCFG_REENTRANT
    
FS_PUBLIC StateVars   State = {0};  /* global static:  available to all */

#endif

/*********************************************************************/
                                             
/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE int32 FindExtrema(ContourList*, GlyphBitMap*);

FS_PRIVATE int32 EvaluateSpline(PSTATE F26Dot6, F26Dot6, F26Dot6, F26Dot6, F26Dot6, F26Dot6, uint16 );


/*********************************************************************/
                                             
/*      Function Exports                                             */

/*********************************************************************/

/*      Initialization Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_Initialize()
{
    fsc_InitializeScanlist();               /* scanlist calls to bitmap */
}


/*********************************************************************/

/*  Remove duplicated points from contour data                       */

/*  This was previously done in sc_FindExtrema of sc.c,              */
/*  but was pulled out to avoid having fsc_MeasureGlyph              */
/*  make changes to the contour list data structure.                 */

/*********************************************************************/

FS_PUBLIC int32 fsc_RemoveDups( 
        ContourList* pclContour )           /* glyph outline */
{
    uint16 usContour;                       /* contour limit */
    int16 sStartPt, sEndPt;                 /* coutour index limits */
    int16 sPt;                              /* point index */
    int16 s;                                /* index for list collapse */
    F26Dot6 *pfxX1, *pfxY1;                 /* leading point */
    F26Dot6 fxX2, fxY2;                     /* trailing point */

    for (usContour = 0; usContour < pclContour->usContourCount; usContour++)
    {
        sStartPt = pclContour->asStartPoint[usContour];
        sEndPt = pclContour->asEndPoint[usContour];
        
        pfxX1 = &(pclContour->afxXCoord[sStartPt]); 
        pfxY1 = &(pclContour->afxYCoord[sStartPt]); 
                    
        for (sPt = sStartPt; sPt < sEndPt; ++sPt)
        {
            fxX2 = *pfxX1;                          /* check next pair */
            pfxX1++;
            fxY2 = *pfxY1;
            pfxY1++;
            
            if ((*pfxX1 == fxX2) && (*pfxY1 == fxY2))   /* if duplicate */
            {
                for(s = sPt; s > sStartPt; s--)     /* s = index of point to be removed */
                {
                    pclContour->afxXCoord[s] = pclContour->afxXCoord[s - 1];
                    pclContour->afxYCoord[s] = pclContour->afxYCoord[s - 1];
                    pclContour->abyOnCurve[s] = pclContour->abyOnCurve[s - 1];
                }
                sStartPt++;                         /* advance start past dup */
                pclContour->asStartPoint[usContour] = sStartPt;
                pclContour->abyOnCurve[sPt + 1] |= ONCURVE; /* dup'd pt must be on curve */
            }
        }
        
        /* now pfxX1 and pfxY1 point to end point coordinates */

        if (sStartPt != sEndPt)                     /* finished if single point */
        {
            fxX2 = pclContour->afxXCoord[sStartPt];
            fxY2 = pclContour->afxYCoord[sStartPt];
                                
            if ((*pfxX1 == fxX2) && (*pfxY1 == fxY2))   /* if start = end */
            {
                pclContour->asStartPoint[usContour]++;
                pclContour->abyOnCurve[sEndPt] |= ONCURVE;  /* dup'd pt must be on curve */
            }
        }
    }
    return NO_ERR;
}


/*********************************************************************/

/*  Calculate the amount of workspace needed to scan convert         */
/*  a given glyph into a given bitmap.  Get per intersection and     */
/*  per scanline size info from ScanList module.                     */

/*********************************************************************/

 FS_PRIVATE void fsc_CheckYReversal (
        PRevRoot prrRoots,
        F26Dot6 fxY1,
        F26Dot6 fxY2,
        int16 *sDir,
        int16 *sOrgDir,
        int16 *sFlatCount)
{
    if (*sDir == 0)
    {
        if (fxY2 > fxY1)                        /* find first up or down */
        {
            *sDir = 1;
            *sOrgDir = *sDir;                    /* save original ep check */
        }
        else if (fxY2 < fxY1)
        {
            *sDir = -1;
            *sOrgDir = *sDir;                     /* save original ep check */
        }
        else
        {
            (*sFlatCount)++;                       /* countour starts flat */
        }
    }
    else if (*sDir == 1)
    {
        if (fxY2 <= fxY1)                   /* = is for endpoint cases */
        {
            fsc_AddYReversal (prrRoots, fxY1, 1);
            *sDir = -1;
        }
    }
    else    /* if sDir == -1 */
    {
        if (fxY2 >= fxY1)                   /* = is for endpoint cases */
        {
            fsc_AddYReversal (prrRoots, fxY1, -1);
            *sDir = 1;
        }
    }
}

FS_PRIVATE void fsc_CheckYReversalInSpline( 
        PRevRoot prrRoots,
        int16 *sDir,
        int16 *sOrgDir,
        int16 *sFlatCount,
        F26Dot6 fxX1,               /* start point x coordinate */
        F26Dot6 fxY1,               /* start point y coordinate */
        F26Dot6 fxX2,               /* control point x coordinate */
        F26Dot6 fxY2,               /* control point y coordinate */
        F26Dot6 fxX3,               /* ending x coordinate */
        F26Dot6 fxY3               /* ending y coordinate */
)
{
    /* subset of EvaluateSpline, must cut spline the same way in regrads to Y direction reversal */

    F26Dot6 fxDX21, fxDX32;     /* delta x's */
    F26Dot6 fxDY21, fxDY32;     /* delta y's */
    
    F26Dot6 fxDenom;                    /* ratio denominator  */
    F26Dot6 fxX4, fxY4;                 /* first mid point */
    F26Dot6 fxX5, fxY5;                 /* mid mid point */
    F26Dot6 fxX6, fxY6;                 /* second mid point */
    F26Dot6 fxX456, fxY456;             /* for monotonic subdivision */

    fxDX21 = fxX2 - fxX1;                       /* get all four deltas */
    fxDX32 = fxX3 - fxX2;
    fxDY21 = fxY2 - fxY1;
    fxDY32 = fxY3 - fxY2;
  
/*  If spline goes up and down, then subdivide it  */

    if (((fxDY21 > 0L) && (fxDY32 < 0L)) || ((fxDY21 < 0L) && (fxDY32 > 0L)))
    {
        fxDenom = fxDY21 - fxDY32;              /* total y span */
        fxX4 = fxX1 + LongMulDiv(fxDX21, fxDY21, fxDenom);
        fxX6 = fxX2 + LongMulDiv(fxDX32, fxDY21, fxDenom);
        fxX5 = fxX4 + LongMulDiv(fxX6 - fxX4, fxDY21, fxDenom);
        fxY456 = fxY1 + LongMulDiv(fxDY21, fxDY21, fxDenom);
        
        fsc_CheckYReversalInSpline(prrRoots, sDir, sOrgDir, sFlatCount, fxX1, fxY1, fxX4, fxY456, fxX5, fxY456);
        fsc_CheckYReversalInSpline(prrRoots, sDir, sOrgDir, sFlatCount, fxX5, fxY456, fxX6, fxY456, fxX3, fxY3);
        return;
    }
    
/*  If spline goes left and right, then subdivide it  */
    
    if (((fxDX21 > 0L) && (fxDX32 < 0L)) || ((fxDX21 < 0L) && (fxDX32 > 0L)))
    {
        fxDenom = fxDX21 - fxDX32;              /* total x span */
        fxY4 = fxY1 + LongMulDiv(fxDY21, fxDX21, fxDenom);
        fxY6 = fxY2 + LongMulDiv(fxDY32, fxDX21, fxDenom);
        fxY5 = fxY4 + LongMulDiv(fxY6 - fxY4, fxDX21, fxDenom);
        fxX456 = fxX1 + LongMulDiv(fxDX21, fxDX21, fxDenom);

        fsc_CheckYReversalInSpline(prrRoots, sDir, sOrgDir, sFlatCount, fxX1, fxY1, fxX456, fxY4, fxX456, fxY5);
        fsc_CheckYReversalInSpline(prrRoots, sDir, sOrgDir, sFlatCount, fxX456, fxY5, fxX456, fxY6, fxX3, fxY3);
        return;
    }
/*  By now the spline must be monotonic  */

    fsc_CheckYReversal(prrRoots, fxY1, fxY3, sDir, sOrgDir, sFlatCount);

}


FS_PUBLIC int32 fsc_MeasureGlyph( 
        ContourList* pclContour,        /* glyph outline */
        GlyphBitMap* pbmpBitMap,        /* to return bounds */
        WorkScan  * pwsWork,              /* to return values */
        uint16 usScanKind,              /* dropout control value */
        uint16 usRoundXMin,              /* for gray scale alignment */
        int16 sBitmapEmboldeningHorExtra,
        int16 sBitmapEmboldeningVertExtra )
{
    uint16 usCont;                      /* contour index */
    int16 sPt;                          /* point index */
    int16 sStart, sEnd;                 /* start and end point of contours */
    int16 sOrgDir;                      /* original contour direction */
    int16 sDir;                         /* current contour direction */
    int16 sFlatCount;                   /* for contours starting flat */
    int32 lVScanCount;                  /* total vertical scan lines */
    int32 lHScanCount;                  /* total horizontal scan lines */
    int32 lTotalHIx;
    int32 lTotalVIx;
    int32 lElementCount;                /* total element point estimate */
    int32 lDivide;                      /* spline element point counter */
    int32 lErrCode;    
    
    F26Dot6 fxX1, fxX2, fxX3;                 /* x coord endpoints */
    F26Dot6 fxY1, fxY2, fxY3;                 /* y coord endpoints */
    F26Dot6 *pfxXCoord, *pfxYCoord, *pfxXStop;     /* for fast point array access */
    F26Dot6 fxAbsDelta;                 /* for element count check */
    uint8 byF1, byF2;                   /* oncurve flag values */
    uint8 *pbyFlags;                    /* for element count check */

    PRevRoot prrRoots;                  /* reversal list roots structure */

    
    lErrCode = FindExtrema(pclContour, pbmpBitMap); /* calc bounding box */
    if (lErrCode != NO_ERR) return lErrCode;

    pbmpBitMap->rectBounds.left &= -((int32)usRoundXMin);   /* mask off low n bits */

    /* bitmap emboldening by 2% + 1 pixel horizontally, 2% vertically */
    if ((pbmpBitMap->rectBounds.top != pbmpBitMap->rectBounds.bottom) && (pbmpBitMap->rectBounds.left != pbmpBitMap->rectBounds.right))
    {
         // we don't want to increase the size of the bitmap on a empty glyph
        if (sBitmapEmboldeningHorExtra > 0)
        {
            pbmpBitMap->rectBounds.right += sBitmapEmboldeningHorExtra;
        }
        else
        {
            pbmpBitMap->rectBounds.left += sBitmapEmboldeningHorExtra;
        }
        if (sBitmapEmboldeningVertExtra > 0)
        {
            pbmpBitMap->rectBounds.bottom -= (sBitmapEmboldeningVertExtra);
        }
        else
        {
            pbmpBitMap->rectBounds.top -= (sBitmapEmboldeningVertExtra);
        }
    }

    prrRoots = fsc_SetupRevRoots(pwsWork->pchRBuffer, pwsWork->lRMemSize);
    lElementCount = 0;                  /* smart point counter */
    
    for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
    {
        sStart = pclContour->asStartPoint[usCont];
        sEnd = pclContour->asEndPoint[usCont];
        if (sStart == sEnd)
        {
            continue;                               /* for anchor points */
        }

/* check contour Y values for direction reversals */

        /* in order to get correct value here and avoid overflow later, 
           we need to cut splines is subsplines the same way as it's done in fsc_FillGlyph */

        pfxXCoord = &pclContour->afxXCoord[sStart];
        pfxYCoord = &pclContour->afxYCoord[sStart];
        pbyFlags = &pclContour->abyOnCurve[sStart];
        pfxXStop = &pclContour->afxXCoord[sEnd];

        if (pclContour->abyOnCurve[sEnd] & ONCURVE) /* if endpoint oncurve */
        {
            fxX1 = pclContour->afxXCoord[sEnd];
            fxY1 = pclContour->afxYCoord[sEnd];
            fxX2 = *pfxXCoord;
            fxY2 = *pfxYCoord;
            byF1 = *pbyFlags;                /* 1st pt might be off */
            pfxXStop++;                             /* stops at endpoint */
        }
        else                                        /* if endpoint offcurve */
        {
            fxX1 = pclContour->afxXCoord[sEnd - 1];
            fxY1 = pclContour->afxYCoord[sEnd - 1];
            fxX2 = pclContour->afxXCoord[sEnd];
            fxY2 = pclContour->afxYCoord[sEnd];
            if ((pclContour->abyOnCurve[sEnd - 1] & ONCURVE) == 0)
            {
                fxX1 = (fxX1 + fxX2 + 1) >> 1;      /* offcurve midpoint */
                fxY1 = (fxY1 + fxY2 + 1) >> 1;
            }
            byF1 = 0;
            pfxXCoord--;                            /* pre decrement */
            pfxYCoord--;
            pbyFlags--;
        }
/*
    At this point, (x1,y1) is the last oncurve point; (x2,y2) is the next
    point (on or off); and the pointers are ready to be incremented to the
    point following (x2,y2).  
        
    Throughout this loop (x1,y1) is always an oncurve point (it may be the 
    midpoint between two offcurve points).  If (x2,y2) is oncurve, then we 
    have a line; if offcurve, we have a spline, and (x3,y3) will be the 
    next oncurve point.
*/

        sDir = 0;                                   /* starting dir unknown */
        sFlatCount = 0;
        sOrgDir = 1;                        /* default direction if everything is flat */                          

        while (pfxXCoord < pfxXStop)
        {
            if (byF1 & ONCURVE)                /* if next point oncurve */
            {
                fsc_CheckYReversal(prrRoots, fxY1, fxY2, &sDir, &sOrgDir, &sFlatCount);

                fxX1 = fxX2;                        /* next oncurve point */
                fxY1 = fxY2;
                        
                pfxXCoord++;
                pfxYCoord++;
                pbyFlags++;
            }
            else
            {
                pfxXCoord++;                        /* check next point */
                fxX3 = *pfxXCoord;
                pfxYCoord++;
                fxY3 = *pfxYCoord;
                pbyFlags++;
                        
                if (*pbyFlags & ONCURVE)          /* if it's on, use it */
                {
                    pfxXCoord++;
                    pfxYCoord++;
                    pbyFlags++;
                }
                else                                /* if not, calc next on */
                {
                    fxX3 = (fxX2 + fxX3 + 1) >> 1;  /* offcurve midpoint */
                    fxY3 = (fxY2 + fxY3 + 1) >> 1;
                }
                fsc_CheckYReversalInSpline(prrRoots, &sDir, &sOrgDir, &sFlatCount,fxX1, fxY1, fxX2, fxY2, fxX3, fxY3);

                fxX1 = fxX3;                        /* next oncurve point */
                fxY1 = fxY3;
           }

            /* test to avoid reading past the end of memory on the last line */
            if (pfxXCoord != pfxXStop)
            {
                fxX2 = *pfxXCoord;                      /* next contour point */
                fxY2 = *pfxYCoord;
                byF1 = *pbyFlags;
            }
        }
                                
        while (sFlatCount > 0)                      /* if contour started flat */
        {
            if (sDir == 0)                          /* if completely flat */
            {
                sDir = 1;                           /* then pick a direction */
            }
            fsc_AddYReversal (prrRoots, fxY1, sDir); /* add one per point */
            sDir = -sDir;
            sFlatCount--;
        }
        if (sOrgDir != sDir)                        /* if endpoint reverses */
        {
            fsc_AddYReversal (prrRoots, fxY1, sDir); /* then balance up/down */
        }

/* if doing dropout control, check contour X values for direction reversals */

        if (!(usScanKind & SK_NODROPOUT))           /* if any kind of dropout */
        {
            fxX1 = pclContour->afxXCoord[sEnd];     /* start by closing */
            pfxXCoord = &pclContour->afxXCoord[sStart];

            sPt = sStart;
            sDir = 0;                               /* starting dir unknown */
            sFlatCount = 0;
            while ((sDir == 0) && (sPt <= sEnd))
            {
                fxX2 = *pfxXCoord++;
                if (fxX2 > fxX1)                    /* find first up or down */
                {
                    sDir = 1;
                }
                else if (fxX2 < fxX1)
                {
                    sDir = -1;
                }
                else
                {
                    sFlatCount++;                   /* countour starts flat */
                }
                fxX1 = fxX2;
                sPt++;
            }
            sOrgDir = sDir;                         /* save original ep check */

            while (sPt <= sEnd)
            {
                fxX2 = *pfxXCoord++;
                if (sDir == 1)
                {
                    if (fxX2 <= fxX1)               /* = is for endpoint cases */
                    {
                        fsc_AddXReversal (prrRoots, fxX1, 1);
                        sDir = -1;
                    }
                }
                else    /* if sDir == -1 */
                {
                    if (fxX2 >= fxX1)               /* = is for endpoint cases */
                    {
                        fsc_AddXReversal (prrRoots, fxX1, -1);
                        sDir = 1;
                    }
                }
                fxX1 = fxX2;                        /* next segment */
                sPt++;
            }
                                    
            while (sFlatCount > 0)                  /* if contour started flat */
            {
                if (sDir == 0)                      /* if completely flat */
                {
                    sDir = 1;                       /* then pick a direction */
                    sOrgDir = 1;
                }
                fsc_AddXReversal (prrRoots, fxX1, sDir); /* add one per point */
                sDir = -sDir;
                sFlatCount--;
            }
            if (sOrgDir != sDir)                    /* if endpoint reverses */
            {
                fsc_AddXReversal (prrRoots, fxX1, sDir); /* then balance up/down */
            }

            if (usScanKind & SK_SMART)              /* if smart dropout control */
            {                                       /* estimate the elem point count */
                fxX1 = pclContour->afxXCoord[sEnd];
                fxY1 = pclContour->afxYCoord[sEnd];
                byF1 = pclContour->abyOnCurve[sEnd];
                pfxXCoord = &pclContour->afxXCoord[sStart];
                pfxYCoord = &pclContour->afxYCoord[sStart];
                pbyFlags = &pclContour->abyOnCurve[sStart];

                lElementCount += (uint32)(sEnd - sStart) + 2L;  /* 1/pt + 1/contour */

                for (sPt = sStart; sPt <= sEnd; sPt++)
                {
                    fxX2 = *pfxXCoord++;
                    fxY2 = *pfxYCoord++;
                    byF2 = *pbyFlags++;

                    if (((byF1 & byF2) & ONCURVE) == 0) /* if this is a spline */
                    {
                        if (((byF1 | byF2) & ONCURVE) == 0)
                        {
                            lElementCount++;            /* +1 for midpoint */
                        }
                                
                        if (FXABS(fxX2 - fxX1) > FXABS(fxY2 - fxY1))
                        {
                            fxAbsDelta = FXABS(fxX2 - fxX1);
                        }
                        else
                        {
                            fxAbsDelta = FXABS(fxY2 - fxY1);
                        }
                        lDivide = 0;
                        while (fxAbsDelta > (MAXSPLINELENGTH / 2))
                        {
                            lDivide++;
                            lDivide <<= 1;
                            fxAbsDelta >>= 1;
                        }
                        lElementCount += lDivide;   /* for subdivision */
                    }
                    fxX1 = fxX2;
                    fxY1 = fxY2;
                    byF1 = byF2;
                }
            }
        }
    }
    if (!(usScanKind & SK_NODROPOUT) && (usScanKind & SK_SMART))  /* if smart dropout */
    {
        lElementCount += fsc_GetReversalCount(prrRoots) << 1;  /* add in 2 * reversals */
        if (lElementCount > (0xFFFF >> SC_CODESHFT))
        {
            return SMART_DROP_OVERFLOW_ERR;
        }
    }

        
/*  set horiz workspace return values */

    lHScanCount = (int32)(pbmpBitMap->rectBounds.top - pbmpBitMap->rectBounds.bottom);
    lVScanCount = (int32)(pbmpBitMap->rectBounds.right - pbmpBitMap->rectBounds.left);
    
    pbmpBitMap->sRowBytes = (int16)ROWBYTESLONG(lVScanCount);
    pbmpBitMap->lMMemSize = (lHScanCount * (int32)pbmpBitMap->sRowBytes);
    
    lTotalHIx = fsc_GetHIxEstimate(prrRoots);   /* intersection count */
    pwsWork->lHMemSize = fsc_GetScanHMem(usScanKind, lHScanCount, lTotalHIx);

/*  set vertical workspace return values */
    
    if (usScanKind & SK_NODROPOUT)                  /* if no dropout */
    {
        pwsWork->lVMemSize = 0L;
        lTotalVIx = 0;
    }
    else
    {
        lTotalVIx = fsc_GetVIxEstimate(prrRoots);   /* estimate intersection count */
        pwsWork->lVMemSize = fsc_GetScanVMem(usScanKind, lVScanCount, lTotalVIx, lElementCount);
    }
    
    pwsWork->lHInterCount = lTotalHIx;              /* save for SetupScan */
    pwsWork->lVInterCount = lTotalVIx;
    pwsWork->lElementCount = lElementCount;
    pwsWork->lRMemSize = fsc_GetRevMemSize(prrRoots);

#ifdef FSCFG_REENTRANT
    
    pwsWork->lHMemSize += sizeof(StateVars);        /* reentrant state space */

#endif

    return NO_ERR;
} 

/*********************************************************************/

/*  Calculate the amount of workspace needed to scan convert         */
/*  a given band into a given bitmap.  Get per intersection and      */
/*  per scanline size info from ScanList module.                     */

/*********************************************************************/

FS_PUBLIC int32 fsc_MeasureBand( 
        GlyphBitMap* pbmpBitMap,        /* computed by MeasureGlyph */
        WorkScan* pwsWork,              /* to return new values */
        uint16 usBandType,              /* small or fast */
        uint16 usBandWidth,             /* scanline count */
        uint16 usScanKind )             /* dropout control value */
{
    int32 lBandWidth;                   /* max scanline count */
    int32 lTotalHIx;                    /* est of horiz intersections in band */
    int32 lVScanCount;                  /* total vertical scan lines */
    int32 lHScanCount;                  /* total horizontal scan lines */

    lBandWidth = (int32)usBandWidth;
    pbmpBitMap->lMMemSize = (lBandWidth * (int32)pbmpBitMap->sRowBytes);
    
    if (usBandType == FS_BANDINGSMALL) 
    {
        lTotalHIx = fsc_GetHIxBandEst((PRevRoot)pwsWork->pchRBuffer, &pbmpBitMap->rectBounds, lBandWidth);
        pwsWork->lHInterCount = lTotalHIx;  /* save for SetupScan */
        pwsWork->lHMemSize = fsc_GetScanHMem(usScanKind, lBandWidth, lTotalHIx);
        pwsWork->lVMemSize = 0L;            /* force dropout control off */
    }
    else if (usBandType == FS_BANDINGFAST) 
    {
        lTotalHIx = fsc_GetHIxEstimate((PRevRoot)pwsWork->pchRBuffer);  /* intersection count */
        pwsWork->lHInterCount = lTotalHIx;  /* save for SetupScan */
        
        lHScanCount = (int32)(pbmpBitMap->rectBounds.top - pbmpBitMap->rectBounds.bottom);
        pwsWork->lHMemSize = fsc_GetScanHMem(usScanKind, lHScanCount, lTotalHIx);

        if (usScanKind & SK_NODROPOUT)      /* if no dropout */
        {
            pwsWork->lVMemSize = 0L;
        }
        else                                /* if any kind of dropout */
        {
            pbmpBitMap->lMMemSize += (int32)pbmpBitMap->sRowBytes;  /* to save below row */
            
            lVScanCount = (int32)(pbmpBitMap->rectBounds.right - pbmpBitMap->rectBounds.left);
            pwsWork->lVMemSize = fsc_GetScanVMem(usScanKind, lVScanCount, pwsWork->lVInterCount, pwsWork->lElementCount);
            pwsWork->lVMemSize += (int32)pbmpBitMap->sRowBytes;     /* to save above row */
            ALIGN(voidPtr, pwsWork->lVMemSize ); 
        }
    }
    
#ifdef FSCFG_REENTRANT
    
    pwsWork->lHMemSize += sizeof(StateVars);        /* reentrant state space */

#endif
    
    return NO_ERR;
}


/*********************************************************************/

/*  Scan Conversion Routine                                          */
/*  Trace the contour, passing out lines and splines,                */
/*  then call ScanList to fill the bitmap                            */

/*********************************************************************/

FS_PUBLIC int32 fsc_FillGlyph( 
        ContourList* pclContour,        /* glyph outline */
        GlyphBitMap* pgbBitMap,         /* target */
        WorkScan* pwsWork,              /* for scan array */
        uint16 usBandType,              /* old, small, fast or faster */
        uint16 usScanKind )             /* dropout control value */
{
    uint16 usCont;                      /* contour index */
    int16 sStart, sEnd;                 /* start and end point of contours */
    int32 lStateSpace;                  /* HMem used by state structure */
    int32 lErrCode;                     /* function return code */
    F26Dot6 *pfxXCoord;                 /* next x coord ptr */
    F26Dot6 *pfxYCoord;                 /* next y coord ptr */
    uint8 *pbyOnCurve;                  /* next flag ptr */
    F26Dot6 *pfxXStop;                  /* contour trace end condition */
    F26Dot6 fxX1, fxX2, fxX3;           /* x coord endpoints */
    F26Dot6 fxY1, fxY2, fxY3;           /* y coord endpoints */
    uint8 byOnCurve;                    /* point 2 flag variable */
    int32 lHiScanBand;                  /* top scan limit */ 
    int32 lLoScanBand;                  /* bottom scan limit */
    int32 lHiBitBand;                   /* top bitmap limit */
    int32 lLoBitBand;                   /* bottom bitmap limit */
    int32 lOrgLoBand;                   /* save for overscan fill check */
    F26Dot6 fxYHiBand, fxYLoBand;       /* limits in f26.6 */
    boolean bSaveRow;                   /* for dropout over scanning */
    boolean bBandCheck;                 /* eliminate out of band elements */

#ifdef FSCFG_REENTRANT
    
    StateVars *pState;                  /* reentrant State is accessed via pointer */

    pState = (StateVars*)pwsWork->pchHBuffer;  /* and lives in HMem (memoryBase[6]) */ 
    lStateSpace = sizeof(StateVars);

#else
    
    lStateSpace = 0L;                   /* no HMem needed if not reentrant */

#endif
    
    if (pgbBitMap->rectBounds.top <= pgbBitMap->rectBounds.bottom)
    {
        return NO_ERR;                              /* quick out for null glyph */
    }

    if (pgbBitMap->bZeroDimension)                  /* if no height or width */
    {
        usScanKind &= (~SK_STUBS);                  /* force no-stub dropout */
    }

    lHiBitBand = (int32)pgbBitMap->sHiBand, 
    lLoBitBand = (int32)pgbBitMap->sLoBand;
    lOrgLoBand = lLoBitBand;                        /* save for fill call */    
    
    Assert (lHiBitBand > lLoBitBand);               /* should be handled above */
    
    if (!(usScanKind & SK_NODROPOUT))               /* if any kind of dropout */
    {
        lLoBitBand--;                               /* leave room below line */
    }
    if (lHiBitBand > pgbBitMap->rectBounds.top)
    {
        lHiBitBand = pgbBitMap->rectBounds.top;     /* clip to top */
    }
    if (lLoBitBand < pgbBitMap->rectBounds.bottom)
    {
        lLoBitBand = pgbBitMap->rectBounds.bottom;  /* clip to bottom */
    }
    if (usBandType == FS_BANDINGFAST)               /* if fast banding */
    {
        lHiScanBand = pgbBitMap->rectBounds.top;    /* render everything */
        lLoScanBand = pgbBitMap->rectBounds.bottom;
        bSaveRow = TRUE;                            /* keep last row for dropout */
    }
    else                                            /* if old or small banding */
    {
        lHiScanBand = lHiBitBand;                   /* just take the band */
        lLoScanBand = lLoBitBand;
        bSaveRow = FALSE;                           /* last row not needed */
    }
    
/*  if fast banding has already renderend elements, skip to FillBitMap */

    if (usBandType != FS_BANDINGFASTER)             /* if rendering required */
    {
        fsc_SetupMem(ASTATE                         /* init workspace */
                pwsWork->pchHBuffer + lStateSpace, 
                pwsWork->lHMemSize - lStateSpace,
                pwsWork->pchVBuffer, 
                pwsWork->lVMemSize);
        
        fsc_SetupLine(ASTATE0);             /* passes line callback to scanlist */
        fsc_SetupSpline(ASTATE0);           /* passes spline callback to scanlist */
        fsc_SetupEndPt(ASTATE0);            /* passes endpoint callback to scanlist */

/*  Eliminate out of band lines and splines, unless fast banding */

        bBandCheck = ((lHiScanBand < pgbBitMap->rectBounds.top) || (lLoScanBand > pgbBitMap->rectBounds.bottom));

        fxYHiBand = (F26Dot6)((lHiScanBand << SUBSHFT) - SUBHALF);  /* may be too wide */
        fxYLoBand = (F26Dot6)((lLoScanBand << SUBSHFT) + SUBHALF);

        lErrCode = fsc_SetupScan(ASTATE &(pgbBitMap->rectBounds), usScanKind, 
                             lHiScanBand, lLoScanBand, bSaveRow, (int32)pgbBitMap->sRowBytes,
                             pwsWork->lHInterCount, pwsWork->lVInterCount,
                             pwsWork->lElementCount, (PRevRoot)pwsWork->pchRBuffer );

        if (lErrCode != NO_ERR) return lErrCode;
        
        for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
        {
            sStart = pclContour->asStartPoint[usCont];
            sEnd = pclContour->asEndPoint[usCont];

            if (sStart == sEnd)
            {
                continue;                               /* for compatibilty */
            }
/*
    For efficiency in tracing the contour, we start by assigning (x1,y1)
    to the last oncurve point.  This is found by starting with the End
    point and backing up if necessary.  The pfxCoord pointers can then
    be used to trace the entire contour without being reset across the
    Start/End gap. 
*/
            pfxXCoord = &pclContour->afxXCoord[sStart];
            pfxYCoord = &pclContour->afxYCoord[sStart];
            pbyOnCurve = &pclContour->abyOnCurve[sStart];
            pfxXStop = &pclContour->afxXCoord[sEnd];

            if (pclContour->abyOnCurve[sEnd] & ONCURVE) /* if endpoint oncurve */
            {
                fxX1 = pclContour->afxXCoord[sEnd];
                fxY1 = pclContour->afxYCoord[sEnd];
                fxX2 = *pfxXCoord;
                fxY2 = *pfxYCoord;
                byOnCurve = *pbyOnCurve;                /* 1st pt might be off */
                pfxXStop++;                             /* stops at endpoint */
            }
            else                                        /* if endpoint offcurve */
            {
                fxX1 = pclContour->afxXCoord[sEnd - 1];
                fxY1 = pclContour->afxYCoord[sEnd - 1];
                fxX2 = pclContour->afxXCoord[sEnd];
                fxY2 = pclContour->afxYCoord[sEnd];
                if ((pclContour->abyOnCurve[sEnd - 1] & ONCURVE) == 0)
                {
                    fxX1 = (fxX1 + fxX2 + 1) >> 1;      /* offcurve midpoint */
                    fxY1 = (fxY1 + fxY2 + 1) >> 1;
                }
                byOnCurve = 0;
                pfxXCoord--;                            /* pre decrement */
                pfxYCoord--;
                pbyOnCurve--;
            }
            fsc_BeginContourEndpoint(ASTATE fxX1, fxY1);          /* 1st oncurve pt -> ep module */
            fsc_BeginContourScan(ASTATE usScanKind, fxX1, fxY1);  /* to scanlist module too */
/*
    At this point, (x1,y1) is the last oncurve point; (x2,y2) is the next
    point (on or off); and the pointers are ready to be incremented to the
    point following (x2,y2).  
        
    Throughout this loop (x1,y1) is always an oncurve point (it may be the 
    midpoint between two offcurve points).  If (x2,y2) is oncurve, then we 
    have a line; if offcurve, we have a spline, and (x3,y3) will be the 
    next oncurve point.
*/
            if (!bBandCheck)
            {
                while (pfxXCoord < pfxXStop)
                {
                    if (byOnCurve & ONCURVE)                /* if next point oncurve */
                    {
                        lErrCode = fsc_CheckEndPoint(ASTATE fxX2, fxY2, usScanKind);
                        if (lErrCode != NO_ERR) return lErrCode;

                        lErrCode = fsc_CalcLine(ASTATE fxX1, fxY1, fxX2, fxY2, usScanKind);
                        if (lErrCode != NO_ERR) return lErrCode;

                        fxX1 = fxX2;                        /* next oncurve point */
                        fxY1 = fxY2;
                                
                        pfxXCoord++;
                        pfxYCoord++;
                        pbyOnCurve++;
                    }
                    else
                    {
                        pfxXCoord++;                        /* check next point */
                        fxX3 = *pfxXCoord;
                        pfxYCoord++;
                        fxY3 = *pfxYCoord;
                        pbyOnCurve++;
                                
                        if (*pbyOnCurve & ONCURVE)          /* if it's on, use it */
                        {
                            pfxXCoord++;
                            pfxYCoord++;
                            pbyOnCurve++;
                        }
                        else                                /* if not, calc next on */
                        {
                            fxX3 = (fxX2 + fxX3 + 1) >> 1;  /* offcurve midpoint */
                            fxY3 = (fxY2 + fxY3 + 1) >> 1;
                        }
                        lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX2, fxY2, fxX3, fxY3, usScanKind);
                        if (lErrCode != NO_ERR) return lErrCode;

                        fxX1 = fxX3;                        /* next oncurve point */
                        fxY1 = fxY3;
                    }

                    /* test to avoid reading past the end of memory on the last line */
                    if (pfxXCoord != pfxXStop)
                    {
                        fxX2 = *pfxXCoord;                      /* next contour point */
                        fxY2 = *pfxYCoord;
                        byOnCurve = *pbyOnCurve;
                    }
                }
            }
            else    /* if band checking */
            {
                while (pfxXCoord < pfxXStop)
                {
                    if (byOnCurve & ONCURVE)                /* if next point oncurve */
                    {
                        lErrCode = fsc_CheckEndPoint(ASTATE fxX2, fxY2, usScanKind);
                        if (lErrCode != NO_ERR) return lErrCode;

                        if (!(((fxY1 > fxYHiBand) && (fxY2 > fxYHiBand)) ||
                              ((fxY1 < fxYLoBand) && (fxY2 < fxYLoBand))))
                        {
                            lErrCode = fsc_CalcLine(ASTATE fxX1, fxY1, fxX2, fxY2, usScanKind);
                            if (lErrCode != NO_ERR) return lErrCode;
                        }

                        fxX1 = fxX2;                        /* next oncurve point */
                        fxY1 = fxY2;
                                
                        pfxXCoord++;
                        pfxYCoord++;
                        pbyOnCurve++;
                    }
                    else
                    {
                        pfxXCoord++;                        /* check next point */
                        fxX3 = *pfxXCoord;
                        pfxYCoord++;
                        fxY3 = *pfxYCoord;
                        pbyOnCurve++;
                                
                        if (*pbyOnCurve & ONCURVE)          /* if it's on, use it */
                        {
                            pfxXCoord++;
                            pfxYCoord++;
                            pbyOnCurve++;
                        }
                        else                                /* if not, calc next on */
                        {
                            fxX3 = (fxX2 + fxX3 + 1) >> 1;  /* offcurve midpoint */
                            fxY3 = (fxY2 + fxY3 + 1) >> 1;
                        }

                        if (!(((fxY1 > fxYHiBand) && (fxY2 > fxYHiBand) && (fxY3 > fxYHiBand)) ||
                              ((fxY1 < fxYLoBand) && (fxY2 < fxYLoBand) && (fxY3 < fxYLoBand))))
                        {
                            lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX2, fxY2, fxX3, fxY3, usScanKind);
                            if (lErrCode != NO_ERR) return lErrCode;
                        }
                        else    /* if entirely outside of the band */
                        {
                            lErrCode = fsc_CheckEndPoint(ASTATE fxX3, fxY3, usScanKind);
                            if (lErrCode != NO_ERR) return lErrCode;
                        }

                        fxX1 = fxX3;                        /* next oncurve point */
                        fxY1 = fxY3;
                    }

                    /* test to avoid reading past the end of memory on the last line */
                    if (pfxXCoord != pfxXStop)
                    {
                        fxX2 = *pfxXCoord;                      /* next contour point */
                        fxY2 = *pfxYCoord;
                        byOnCurve = *pbyOnCurve;
                    }
                }
            }
            lErrCode = fsc_EndContourEndpoint(ASTATE usScanKind);
            if (lErrCode != NO_ERR) return lErrCode;
        }
    }
    
    lErrCode = fsc_FillBitMap(
            ASTATE 
            pgbBitMap->pchBitMap, 
            lHiBitBand, 
            lLoBitBand,
            (int32)pgbBitMap->sRowBytes, 
            lOrgLoBand,
            usScanKind
    );

    if (lErrCode != NO_ERR) return lErrCode;
    
    return NO_ERR;
}


#ifndef FSCFG_DISABLE_GRAYSCALE

/*********************************************************************/

/*  This routine scales up an outline for gray scale scan conversion */

/*********************************************************************/

FS_PUBLIC int32 fsc_OverScaleOutline( 
        ContourList* pclContour,        /* glyph outline */
        uint16 usOverScale              /* over scale factor */
)
{
    uint16 usCont;                      /* contour index */
    int16 sPt;                          /* point index */
    int16 sStart, sEnd;                 /* start and end point of contours */
    int16 sShift;                       /* for power of two multiply */
    F26Dot6 *pfxXCoord, *pfxYCoord;     /* for fast point array access */
    
    
    switch (usOverScale)                /* look for power of two */
    {
    case 1:
        sShift = 0;
        break;
    case 2:
        sShift = 1;
        break;
    case 4:
        sShift = 2;
        break;
    case 8:
        sShift = 3;
        break;
    default:
        sShift = -1;
        break;
    }

    for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
    {
        sStart = pclContour->asStartPoint[usCont];
        sEnd = pclContour->asEndPoint[usCont];
                
        pfxXCoord = &pclContour->afxXCoord[sStart];
        pfxYCoord = &pclContour->afxYCoord[sStart];
            
        if (sShift >= 0)                    /* if power of two */
        {
            for (sPt = sStart; sPt <= sEnd; sPt++)
            {
                *pfxXCoord <<= sShift;
                pfxXCoord++;
                *pfxYCoord <<= sShift;
                pfxYCoord++;
            }
        }
        else                                /* if not a power of two */
        {
            for (sPt = sStart; sPt <= sEnd; sPt++)
            {
                *pfxXCoord *= (int32)usOverScale;
                pfxXCoord++;
                *pfxYCoord *= (int32)usOverScale;
                pfxYCoord++;
            }
        }
    }
    return NO_ERR;
}


/*********************************************************************/

/*  Gray scale bitmap calculation                                    */
/*  Count over scale pixels into gray scale byte array               */
/*  Be sure that Hi/LoBand are set correctly for both Over & Gray!   */

/*********************************************************************/

#ifdef FSCFG_NEW_GRAY_FILTER // Customize filter for GDI+

/*==============================================================*\

    The following tables help increase the contrast of the
    generated anti-alias glyphs:

\*==============================================================*/

static const int weightTable[36] =
{
    0,  0,  3,  3,  0,  0,
    0,  7, 12, 12,  7,  0,
    3, 12, 18, 18, 12,  3,
    3, 12, 18, 18, 12,  3,
    0,  7, 12, 12,  7,  0,
    0,  0,  3,  3,  0,  0
};

/*==============================================================*\

    The following code generates the scaleTable:

    double divisor = 220.0; // total of the values in the weightTable

    for(i=0;i<256;i++)
    {
        double value = 0.0;

        // Apply the non-linearity to the alpha value...
        value = i / divisor;
        value = (value * 2.0) / (value + 1.0);

        scaleTable[i] = (int)(value * 16);
    }

\*==============================================================*/

static const unsigned char scaleTable[256] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
    0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
    0x09, 0x09, 0x09, 0x09, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 
    0x0A, 0x0A, 0x0A, 0x0A, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 
    0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 
    0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0E, 0x0E, 0x0E, 0x0E, 
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 
    0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
};

/*==============================================================*\

    The following code generates the maskTable:

    int i, j;

    for(j=0;j<6;j++)
    {
        for(i=0;i<64;i++)
        {
            maskTable[j][i] = 
                ((i & 0x20) ? weightTable[(j*6)+0] : 0) +
                ((i & 0x10) ? weightTable[(j*6)+1] : 0) +
                ((i & 0x08) ? weightTable[(j*6)+2] : 0) +
                ((i & 0x04) ? weightTable[(j*6)+3] : 0) +
                ((i & 0x02) ? weightTable[(j*6)+4] : 0) +
                ((i & 0x01) ? weightTable[(j*6)+5] : 0);
        }
    }

\*==============================================================*/

static const unsigned char maskTable[6][64] =
{
    {
        0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 
        0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 
        0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 
        0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06
    },
    {
        0x00, 0x00, 0x07, 0x07, 0x0C, 0x0C, 0x13, 0x13, 0x0C, 0x0C, 0x13, 0x13, 0x18, 0x18, 0x1F, 0x1F, 
        0x07, 0x07, 0x0E, 0x0E, 0x13, 0x13, 0x1A, 0x1A, 0x13, 0x13, 0x1A, 0x1A, 0x1F, 0x1F, 0x26, 0x26, 
        0x00, 0x00, 0x07, 0x07, 0x0C, 0x0C, 0x13, 0x13, 0x0C, 0x0C, 0x13, 0x13, 0x18, 0x18, 0x1F, 0x1F, 
        0x07, 0x07, 0x0E, 0x0E, 0x13, 0x13, 0x1A, 0x1A, 0x13, 0x13, 0x1A, 0x1A, 0x1F, 0x1F, 0x26, 0x26
    },
    {
        0x00, 0x03, 0x0C, 0x0F, 0x12, 0x15, 0x1E, 0x21, 0x12, 0x15, 0x1E, 0x21, 0x24, 0x27, 0x30, 0x33, 
        0x0C, 0x0F, 0x18, 0x1B, 0x1E, 0x21, 0x2A, 0x2D, 0x1E, 0x21, 0x2A, 0x2D, 0x30, 0x33, 0x3C, 0x3F, 
        0x03, 0x06, 0x0F, 0x12, 0x15, 0x18, 0x21, 0x24, 0x15, 0x18, 0x21, 0x24, 0x27, 0x2A, 0x33, 0x36, 
        0x0F, 0x12, 0x1B, 0x1E, 0x21, 0x24, 0x2D, 0x30, 0x21, 0x24, 0x2D, 0x30, 0x33, 0x36, 0x3F, 0x42
    },
    {
        0x00, 0x03, 0x0C, 0x0F, 0x12, 0x15, 0x1E, 0x21, 0x12, 0x15, 0x1E, 0x21, 0x24, 0x27, 0x30, 0x33, 
        0x0C, 0x0F, 0x18, 0x1B, 0x1E, 0x21, 0x2A, 0x2D, 0x1E, 0x21, 0x2A, 0x2D, 0x30, 0x33, 0x3C, 0x3F, 
        0x03, 0x06, 0x0F, 0x12, 0x15, 0x18, 0x21, 0x24, 0x15, 0x18, 0x21, 0x24, 0x27, 0x2A, 0x33, 0x36, 
        0x0F, 0x12, 0x1B, 0x1E, 0x21, 0x24, 0x2D, 0x30, 0x21, 0x24, 0x2D, 0x30, 0x33, 0x36, 0x3F, 0x42
    },
    {
        0x00, 0x00, 0x07, 0x07, 0x0C, 0x0C, 0x13, 0x13, 0x0C, 0x0C, 0x13, 0x13, 0x18, 0x18, 0x1F, 0x1F, 
        0x07, 0x07, 0x0E, 0x0E, 0x13, 0x13, 0x1A, 0x1A, 0x13, 0x13, 0x1A, 0x1A, 0x1F, 0x1F, 0x26, 0x26, 
        0x00, 0x00, 0x07, 0x07, 0x0C, 0x0C, 0x13, 0x13, 0x0C, 0x0C, 0x13, 0x13, 0x18, 0x18, 0x1F, 0x1F, 
        0x07, 0x07, 0x0E, 0x0E, 0x13, 0x13, 0x1A, 0x1A, 0x13, 0x13, 0x1A, 0x1A, 0x1F, 0x1F, 0x26, 0x26
    },
    {
        0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 
        0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 
        0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 
        0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06
    }
};

FS_PUBLIC int32 fsc_CalcGrayMap( 
        GlyphBitMap* pOverGBMap,        /* over scaled source */
        GlyphBitMap* pGrayGBMap,        /* gray scale target */
        uint16 usOverScale              /* over scale factor */
)
{
    // The pOverGBMap structure needs to have weighted sampling
    // applied as well as the overscale factor so that the resulting
    // pGrayGBMap has correct 0-16 values.

    unsigned char *srcRowPtr = NULL;
    unsigned char *dstRowPtr = NULL;
    int srcRow;
    int dstRow;
    int srcRowCount;
    int dstRowCount;
    int srcRowBytes;
    int dstRowBytes;
    int vOffset;
    int hOffset;
    int srcBitOffsetMax;
    int srcRowOffsetMax;
    int col;
    int srcRowOffset = 0;
    unsigned char *dstPtr = NULL;

    // This only handles overscale values of 4!
    Assert (usOverScale == 4);

    // Get the row counts...
    srcRowCount = pOverGBMap->sHiBand - pOverGBMap->sLoBand;
    dstRowCount = pGrayGBMap->sHiBand - pGrayGBMap->sLoBand;

    // Get the row byte counts...
    srcRowBytes = pOverGBMap->sRowBytes;
    dstRowBytes = pGrayGBMap->sRowBytes;

    // Setup our row pointers...
    srcRowPtr = pOverGBMap->pchBitMap;
    dstRowPtr = pGrayGBMap->pchBitMap;

    // Calculate the offsets...
    vOffset = pOverGBMap->sHiBand - (usOverScale * pGrayGBMap->sHiBand);
    hOffset = (pGrayGBMap->rectBounds.left * usOverScale) - pOverGBMap->rectBounds.left;

    // Calculate the limits...
    srcBitOffsetMax = srcRowBytes << 3;
    srcRowOffsetMax = srcRowCount * srcRowBytes;

    // Make sure that we account for the case where srcRowBytes was rounded up to 32 bit
    // quantity! (and the dstRowBytes was not calculated as an exact multiple of this!)
    if (srcBitOffsetMax > (dstRowBytes * 4))
        srcBitOffsetMax = dstRowBytes * 4;

    // Set up our destination pointer...
    dstPtr = dstRowPtr;

    // Loop through the scanlines and calculate the destination values...
    for(dstRow = 0;dstRow<dstRowCount;dstRow++)
    {
        int tblRow;
        int srcBitOffset;

        // The -1 here is so that the 6x6 table is centered
        // properly over the 4x4 grid location.
        srcRowOffset = (vOffset - 1) * srcRowBytes;

        // Clear the destination so we can add into it...
        memset(dstPtr, 0, dstRowBytes);

        for(tblRow = 0;tblRow<6;tblRow++)
        {
            if ((srcRowOffset >= 0) && (srcRowOffset < srcRowOffsetMax))
            {
                const unsigned char *tableRow = maskTable[tblRow];
                unsigned char *srcPtr = srcRowPtr + srcRowOffset;

                // -1 so that this is centered...
                srcBitOffset = hOffset - 1;

                col = 0;

                // Handle start of line clipping...
                while(srcBitOffset < 0)
                {
                    unsigned int index = 0;
                    int offset = srcBitOffset;
                    unsigned int mask = 0x8080 >> (offset & 7);

                    // read the proper number of bits...
                    while(offset < (srcBitOffset + 6))
                    {
                        index <<= 1;

                        if ((offset >= 0) && (srcPtr[(offset >> 3)] & mask))
                            index |= 1;

                        mask >>= 1;
                        offset++;
                    }

                    // index now contains the proper 6-bit value
                    // for the lookup table for this scanline...
                    Assert(col < dstRowBytes);
                    dstPtr[col] += tableRow[index];
                    col++;

                    // move on to the next pixel (overscale is 4 pixels)
                    srcBitOffset += 4;
                }

                // General-case line processing...
                while(srcBitOffset < (srcBitOffsetMax-8))
                {
                    unsigned int index = 0;

                    // Read 6 bits from srcPtr and use them as an index
                    index = srcPtr[(srcBitOffset >> 3)] << 8;
                    index |= srcPtr[(srcBitOffset >> 3) + 1];

                    index >>= 10 - (srcBitOffset&7);
                    index &= 0x3F;

                    // index now contains the proper 6-bit value
                    // for the lookup table for this scanline...
                    Assert(col < dstRowBytes);
                    dstPtr[col] += tableRow[index];
                    col++;

                    // move on to the next pixel (overscale is 4 pixels)
                    srcBitOffset += 4;
                }

                // Handle end of line clipping (only output a pixel if we still have 4
                // or more source pixels remaining! (overscale value is 4)
                while(srcBitOffset < (srcBitOffsetMax-4))
                {
                    unsigned int index = 0;
                    int offset = srcBitOffset;
                    unsigned int mask = 0x8080 >> (offset & 7);

                    // read the proper number of bits...
                    while(offset < (srcBitOffset + 6))
                    {
                        index <<= 1;

                        if ((offset < srcBitOffsetMax) && (srcPtr[(offset >> 3)] & mask))
                            index |= 1;

                        mask >>= 1;
                        offset++;
                    }

                    // index now contains the proper 6-bit value
                    // for the lookup table for this scanline...
                    Assert(col < dstRowBytes);
                    dstPtr[col] += tableRow[index];
                    col++;

                    // move on to the next pixel (overscale is 4 pixels)
                    srcBitOffset += 4;
                }
            }

            srcRowOffset += srcRowBytes;
        }

        for(col=0;col<dstRowBytes;col++)
            dstPtr[col] = scaleTable[dstPtr[col]];

        // Increment the destination pointer...
        dstPtr += dstRowBytes;

        // Increment by our overscale multiplier...
        vOffset += usOverScale;
    }

    return NO_ERR;
}

#else // !FSCFG_NEW_GRAY_FILTER // Customize filter for GDI+

FS_PUBLIC int32 fsc_CalcGrayMap( 
		GlyphBitMap* pOverGBMap,        /* over scaled source */
		GlyphBitMap* pGrayGBMap,        /* gray scale target */
		uint16 usOverScale              /* over scale factor */
)
{
	char        *pchOverRow;            /* over scaled bitmap row pointer */
	char        *pchGrayRow;            /* gray scale bitmap row pointer */

	int16       sVOffset;               /* over scaled rows to skip */
	int16       sRightPix;              /* right edge of used over pix's */
		
	int16       sGrayRow;               /* gray scale row loop counter */
	uint16      usOverRowCount;         /* over scaled row loop counter */
	int16       sTotalRowCount;         /* over scaled whole band counter */
	
	uint32      ulBytes;                /* gray scale count for clear */
	int32       lErrCode;               /* function return code */
	
	GrayScaleParam  GSP;                /* param block for CalcGrayRow */


	Assert ((usOverScale == 1) || (usOverScale == 2) || (usOverScale == 4) || (usOverScale == 8));

	ulBytes = (uint32)pGrayGBMap->sRowBytes * (uint32)(pGrayGBMap->sHiBand - pGrayGBMap->sLoBand);
	Assert(((ulBytes >> 2) << 2) == ulBytes);
	fsc_ScanClearBitMap (ulBytes >> 2, (uint32*)pGrayGBMap->pchBitMap);
	
	GSP.usOverScale = usOverScale;
	GSP.pchOverLo = pOverGBMap->pchBitMap;      /* set pointer limits */
	GSP.pchOverHi = pOverGBMap->pchBitMap + pOverGBMap->lMMemSize;
	GSP.pchGrayLo = pGrayGBMap->pchBitMap;      /* set pointer limits */
	GSP.pchGrayHi = pGrayGBMap->pchBitMap + pGrayGBMap->lMMemSize;

	pchOverRow = pOverGBMap->pchBitMap;
	usOverRowCount = usOverScale;
	sTotalRowCount = pOverGBMap->sHiBand - pOverGBMap->sLoBand;
	sVOffset = pOverGBMap->sHiBand - usOverScale * pGrayGBMap->sHiBand;
	if (sVOffset < 0)                                   /* if mapped above over's bitmap */
	{
		usOverRowCount -= (uint16)(-sVOffset);          /* correct first band count */
	}
	else
	{
		pchOverRow += sVOffset * pOverGBMap->sRowBytes; /* point into bitmap */
		sTotalRowCount -= sVOffset;                     /* adjust for skipped rows */
	}
	
	sRightPix = pGrayGBMap->rectBounds.right * (int16)usOverScale - pOverGBMap->rectBounds.left;
	pchOverRow += (sRightPix - 1) >> 3;
	GSP.usFirstShift = (uint16)(7 - ((sRightPix-1) & 0x0007));

	GSP.sGrayCol = pGrayGBMap->rectBounds.right - pGrayGBMap->rectBounds.left;
	pchGrayRow = pGrayGBMap->pchBitMap + (GSP.sGrayCol - 1);

	for (sGrayRow = pGrayGBMap->sHiBand - 1; sGrayRow >= pGrayGBMap->sLoBand; sGrayRow--)
	{
		GSP.pchGray = pchGrayRow;
		while ((usOverRowCount > 0) && (sTotalRowCount > 0))
		{
			GSP.pchOver = pchOverRow;
			lErrCode = fsc_ScanCalcGrayRow( &GSP );
			if (lErrCode != NO_ERR) return lErrCode;
			
			pchOverRow += pOverGBMap->sRowBytes;
			usOverRowCount--;
			sTotalRowCount--;
		}                               
		pchGrayRow += pGrayGBMap->sRowBytes;
		usOverRowCount = usOverScale;
	}
	return NO_ERR;
}
#endif // !FSCFG_NEW_GRAY_FILTER // Customize filter for GDI+

#else                                   /* if grayscale is disabled */

FS_PUBLIC int32 fsc_OverScaleOutline( 
        ContourList* pclContour,        /* glyph outline */
        uint16 usOverScale              /* over scale factor */
)
{
    FS_UNUSED_PARAMETER(pclContour);
    FS_UNUSED_PARAMETER(usOverScale);
    
    return BAD_GRAY_LEVEL_ERR;
}


FS_PUBLIC int32 fsc_CalcGrayMap( 
        GlyphBitMap* pOverGBMap,        /* over scaled source */
        GlyphBitMap* pGrayGBMap,        /* gray scale target */
        uint16 usOverScale              /* over scale factor */
)
{
    FS_UNUSED_PARAMETER(pOverGBMap);
    FS_UNUSED_PARAMETER(pGrayGBMap);
    FS_UNUSED_PARAMETER(usOverScale);
    
    return BAD_GRAY_LEVEL_ERR;
}

#endif

/*********************************************************************/
                                             
/*      Local Functions                                              */

/*********************************************************************/

/*********************************************************************/

/*  This routine examines a glyph contour by contour and calculates  */
/*  its bounding box.                                                */

/*********************************************************************/

FS_PRIVATE int32 FindExtrema( 
        ContourList* pclContour,        /* glyph outline */
        GlyphBitMap* pbmpBitMap         /* to return bounds */
)
{
    uint16 usCont;                      /* contour index */
    int16 sPt;                          /* point index */
    int16 sStart, sEnd;                 /* start and end point of contours */
    int32 lMaxX, lMinX;                 /* for bounding box left, right */
    int32 lMaxY, lMinY;                 /* for bounding box top, bottom */
    
    F26Dot6 *pfxXCoord, *pfxYCoord;     /* for fast point array access */
    F26Dot6 fxMaxX, fxMinX;             /* for bounding box left, right */
    F26Dot6 fxMaxY, fxMinY;             /* for bounding box top, bottom */
    boolean bFirstContour;              /* set false after min/max set */


    fxMaxX = 0L;                        /* default bounds limits */
    fxMinX = 0L;
    fxMaxY = 0L;
    fxMinY = 0L;
    bFirstContour = TRUE;               /* first time only */
    
    for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
    {
        sStart = pclContour->asStartPoint[usCont];
        sEnd = pclContour->asEndPoint[usCont];
        if (sStart == sEnd)
        {
            continue;                               /* for anchor points */
        }
        
        pfxXCoord = &pclContour->afxXCoord[sStart];
        pfxYCoord = &pclContour->afxYCoord[sStart];
                
        if (bFirstContour)            
        {
            fxMaxX = *pfxXCoord;                    /* init bounds limits */
            fxMinX = *pfxXCoord;
            fxMaxY = *pfxYCoord;
            fxMinY = *pfxYCoord;
            bFirstContour = FALSE;                  /* just once */
        }

        for (sPt = sStart; sPt <= sEnd; sPt++)      /* find the min & max */
        {
            if (*pfxXCoord > fxMaxX)
                fxMaxX = *pfxXCoord;
            if (*pfxXCoord < fxMinX)
                fxMinX = *pfxXCoord;
                    
            if (*pfxYCoord > fxMaxY)
                fxMaxY = *pfxYCoord;
            if (*pfxYCoord < fxMinY)
                fxMinY = *pfxYCoord;

            pfxXCoord++;
            pfxYCoord++;
        }
    }
    
    pbmpBitMap->fxMinX = fxMinX;                    /* save full precision bounds */
    pbmpBitMap->fxMinY = fxMinY;
    pbmpBitMap->fxMaxX = fxMaxX;                    /* save full precision bounds */
    pbmpBitMap->fxMaxY = fxMaxY;

    lMinX = (fxMinX + SUBHALF - 1) >> SUBSHFT;      /* pixel black box */
    lMinY = (fxMinY + SUBHALF - 1) >> SUBSHFT;
    lMaxX = (fxMaxX + SUBHALF) >> SUBSHFT;
    lMaxY = (fxMaxY + SUBHALF) >> SUBSHFT;
            
    if ((F26Dot6)(int16)lMinX != lMinX ||           /* check overflow */
        (F26Dot6)(int16)lMinY != lMinY ||
        (F26Dot6)(int16)lMaxX != lMaxX ||
        (F26Dot6)(int16)lMaxY != lMaxY )
    {
        return POINT_MIGRATION_ERR;
    }

    pbmpBitMap->bZeroDimension = FALSE;             /* assume some size */
    
    if (bFirstContour == FALSE)                     /* if contours present */
    {                                               /* then force a non-zero bitmap */
        if (lMinX == lMaxX)
        {
            lMaxX++;                                /* force 1 pixel wide */
            pbmpBitMap->bZeroDimension = TRUE;      /* flag for filling */
        }
        if (lMinY == lMaxY)
        {
            lMaxY++;                                /* force 1 pixel high */
            pbmpBitMap->bZeroDimension = TRUE;      /* flag for filling */
        }
    }
    
/*  set bitmap structure return values */

    pbmpBitMap->rectBounds.left   = (int16)lMinX;
    pbmpBitMap->rectBounds.right  = (int16)lMaxX;
    pbmpBitMap->rectBounds.bottom = (int16)lMinY;
    pbmpBitMap->rectBounds.top    = (int16)lMaxY;

    return NO_ERR;
}

/*********************************************************************/

/* This recursive routine subdivides splines that are non-monotonic or   */
/* too big into splines that fsc_CalcSpline can handle.  It also         */
/* filters out degenerate (linear) splines, passing off to fsc_CalcLine. */


FS_PRIVATE int32 EvaluateSpline( 
        PSTATE                      /* pointer to state vars */
        F26Dot6 fxX1,               /* start point x coordinate */
        F26Dot6 fxY1,               /* start point y coordinate */
        F26Dot6 fxX2,               /* control point x coordinate */
        F26Dot6 fxY2,               /* control point y coordinate */
        F26Dot6 fxX3,               /* ending x coordinate */
        F26Dot6 fxY3,               /* ending y coordinate */
        uint16 usScanKind           /* scan control type */
)
{
    F26Dot6 fxDX21, fxDX32, fxDX31;     /* delta x's */
    F26Dot6 fxDY21, fxDY32, fxDY31;     /* delta y's */
    
    F26Dot6 fxDenom;                    /* ratio denominator  */
    F26Dot6 fxX4, fxY4;                 /* first mid point */
    F26Dot6 fxX5, fxY5;                 /* mid mid point */
    F26Dot6 fxX6, fxY6;                 /* second mid point */
    F26Dot6 fxX456, fxY456;             /* for monotonic subdivision */
    F26Dot6 fxAbsDX, fxAbsDY;           /* abs of DX31, DY31 */
    
    int32 lErrCode;


    fxDX21 = fxX2 - fxX1;                       /* get all four deltas */
    fxDX32 = fxX3 - fxX2;
    fxDY21 = fxY2 - fxY1;
    fxDY32 = fxY3 - fxY2;
  
/*  If spline goes up and down, then subdivide it  */

    if (((fxDY21 > 0L) && (fxDY32 < 0L)) || ((fxDY21 < 0L) && (fxDY32 > 0L)))
    {
        fxDenom = fxDY21 - fxDY32;              /* total y span */
        fxX4 = fxX1 + LongMulDiv(fxDX21, fxDY21, fxDenom);
        fxX6 = fxX2 + LongMulDiv(fxDX32, fxDY21, fxDenom);
        fxX5 = fxX4 + LongMulDiv(fxX6 - fxX4, fxDY21, fxDenom);
        fxY456 = fxY1 + LongMulDiv(fxDY21, fxDY21, fxDenom);
        
        lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX4, fxY456, fxX5, fxY456, usScanKind);
        if (lErrCode != NO_ERR)  return lErrCode;

        return EvaluateSpline(ASTATE fxX5, fxY456, fxX6, fxY456, fxX3, fxY3, usScanKind);
    }
    
/*  If spline goes left and right, then subdivide it  */
    
    if (((fxDX21 > 0L) && (fxDX32 < 0L)) || ((fxDX21 < 0L) && (fxDX32 > 0L)))
    {
        fxDenom = fxDX21 - fxDX32;              /* total x span */
        fxY4 = fxY1 + LongMulDiv(fxDY21, fxDX21, fxDenom);
        fxY6 = fxY2 + LongMulDiv(fxDY32, fxDX21, fxDenom);
        fxY5 = fxY4 + LongMulDiv(fxY6 - fxY4, fxDX21, fxDenom);
        fxX456 = fxX1 + LongMulDiv(fxDX21, fxDX21, fxDenom);

        lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX456, fxY4, fxX456, fxY5, usScanKind);
        if (lErrCode != NO_ERR)  return lErrCode;

        return EvaluateSpline(ASTATE fxX456, fxY5, fxX456, fxY6, fxX3, fxY3, usScanKind);
    }

/*  By now the spline must be monotonic  */

    fxDX31 = fxX3 - fxX1;                       /* check overall size */
    fxDY31 = fxY3 - fxY1;
    fxAbsDX = FXABS(fxDX31);
    fxAbsDY = FXABS(fxDY31);

/*  If spline is too big to calculate, then subdivide it  */

    if ((fxAbsDX > MAXSPLINELENGTH) || (fxAbsDY > MAXSPLINELENGTH))
    {
        fxX4 = (fxX1 + fxX2) >> 1;              /* first segment mid point */
        fxY4 = (fxY1 + fxY2) >> 1;
        fxX6 = (fxX2 + fxX3) >> 1;              /* second segment mid point */
        fxY6 = (fxY2 + fxY3) >> 1;
        fxX5 = (fxX4 + fxX6) >> 1;              /* mid segment mid point */
        fxY5 = (fxY4 + fxY6) >> 1;

        lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX4, fxY4, fxX5, fxY5, usScanKind);
        if (lErrCode != NO_ERR)  return lErrCode;

        return EvaluateSpline(ASTATE fxX5, fxY5, fxX6, fxY6, fxX3, fxY3, usScanKind);
    }

/*  The spline is now montonic and small enough  */

    lErrCode = fsc_CheckEndPoint(ASTATE fxX3, fxY3, usScanKind);  /* first check endpoint */
    if (lErrCode != NO_ERR)  return lErrCode;

    if (fxDX21 * fxDY32 == fxDY21 * fxDX32)     /* if spline is degenerate (linear) */
    {                                           /* treat as a line */
        return fsc_CalcLine(ASTATE fxX1, fxY1, fxX3, fxY3, usScanKind);
    }
    else        
    {
        return fsc_CalcSpline(ASTATE fxX1, fxY1, fxX2, fxY2, fxX3, fxY3, usScanKind);
    }
}


/*********************************************************************/

/*  Return an array of coordinates for outline points */

FS_PUBLIC int32 fsc_GetCoords(
        ContourList* pclContour,        /* glyph outline */
        uint16 usPointCount,            /* point count */
        uint16* pusPointIndex,          /* point indices */
        PixCoord* ppcCoordinate         /* point coordinates */
)
{
    uint16  usMaxIndex;                 /* last defined point */
    int32  lX;                          /* integer x coord */
    int32  lY;                          /* integer y coord */

    if (pclContour->usContourCount == 0)
    {
        return BAD_POINT_INDEX_ERR;     /* can't have a point without a contour */
    }
     
    usMaxIndex = pclContour->asEndPoint[pclContour->usContourCount - 1] + 2;    /* allow 2 phantoms */

    while (usPointCount > 0)
    {
        if (*pusPointIndex > usMaxIndex)
        {
            return BAD_POINT_INDEX_ERR;     /* beyond the last contour */
        }

        lX = (pclContour->afxXCoord[*pusPointIndex] + SUBHALF) >> SUBSHFT;
        lY = (pclContour->afxYCoord[*pusPointIndex] + SUBHALF) >> SUBSHFT;

        if ( ((int32)(int16)lX != lX) || ((int32)(int16)lY != lY) )
        {
            return POINT_MIGRATION_ERR;    /* catch overflow */
        }

        ppcCoordinate->x = (int16)lX;
        ppcCoordinate->y = (int16)lY;

        pusPointIndex++;
        ppcCoordinate++;
        usPointCount--;                     /* loop through all points */
    }
    return NO_ERR;
}

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scgray.h ===
/*********************************************************************

	  scgray.h -- Gray Scale Parameter Block Definition

	  (c) Copyright 1993  Microsoft Corp.  All rights reserved.

	   8/23/93 deanb    First cut 

**********************************************************************/

#ifndef FSCGRAY_DEFINED
#define FSCGRAY_DEFINED


#include "fscdefs.h"                /* for type definitions */

/*********************************************************************/

/*      Gray scale calculation parameters                            */

/*********************************************************************/

typedef struct
{
	char* pchOver;                  /* pointer to overscaled bitmap */
	char* pchGray;                  /* pointer to gray scale bitmap */
	int16 sGrayCol;                 /* number of gray columns to calc */
	uint16 usOverScale;             /* outline magnification factor */
	uint16 usFirstShift;            /* first byte's shift */
	char* pchOverLo;                /* low limit of overscaled bitmap */
	char* pchOverHi;                /* high limit of overscaled bitmap */
	char* pchGrayLo;                /* low limit of gray scale bitmap */
	char* pchGrayHi;                /* high limit of gray scale bitmap */
}
GrayScaleParam;


/*********************************************************************/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scglobal.h ===
/*********************************************************************

      scglobal.h -- Information shared by all scan converter modules

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       7/09/93 deanb    include fsconfig.h removed (fscdefs does it)
       4/19/93 deanb    banding limits added
       4/12/93 deanb    from old scconst.h + scstate.h

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */

/********************************************************************/

/*      Internal Constant Values                                    */

/********************************************************************/

#define HUGEINT         0x7FFF          /* impossibly large int16 value */
#define HUGEFIX         0x7FFFFFFFL     /* impossibly large fx value */

#define SUBPIX          64L             /* sub pixels per pix */
#define SUBHALF         32L             /* one half of SUBPIX */
#define SUBSHFT         6               /* log base two of SUBPIX */
    
#define ONSCANLINE(y)   ((y) & (SUBPIX - 1L)) == SUBHALF
#define SCANABOVE(y)    ((((y) + SUBHALF) & (-SUBPIX)) + SUBHALF)
#define SCANBELOW(y)    ((((y) - SUBHALF - 1L) & (-SUBPIX)) + SUBHALF)

/*      Math macros      */

#define FXABS(x)  ((x) >= 0L ? (x) : -(x))

/*      Module codes for subpix callbacks   */

#define SC_LINECODE     0
#define SC_SPLINECODE   1
#define SC_ENDPTCODE    2

#define SC_MAXCODES     3               /* number of codes above */
#define SC_CODESHFT     2               /* bits needed to store codes */
#define SC_CODEMASK     0x0003          /* to mask off codes */


/**********************************************************************

    The following structure defines all of the state variables for the 
    scan converter.  This structure is allocated statically for a non-
    reentrant implementation, or as an automatic variable to permit 
    reentrancy.  There are three sets of variables: one for the endpoint 
    module, one for scanlist, and one for memory.  Rules of the game are 
    that each module accesses ONLY its own variables for reading AND 
    writing.  It is possible for one module to read another's variables, 
    BUT IT WOULD BE WRONG.

**********************************************************************/

typedef struct statevar
{

/* endpoint state variables */

    F26Dot6 fxX0, fxY0;             /* point from call before last */
    F26Dot6 fxX1, fxY1;             /* point from previous call */
    F26Dot6 fxX2Save, fxY2Save;     /* for closing the contour */
                 
/* scanlist state variables */

    int32 lBoxLeft;                 /* bounding box xmin */
    int32 lBoxRight;                /* bounding box xmax */
    int32 lBoxTop;                  /* bounding box ymax */
    int32 lBoxBottom;               /* bounding box ymin */
    int32 lRowBytes;                /* bitmap bytes per row */
    int32 lHiScanBand;              /* banding upper scan limit */
    int32 lLoScanBand;              /* banding lower scan limit */
    int32 lHiBitBand;               /* banding upper bitmap limit */
    int32 lLoBitBand;               /* banding lower bitmap limit */
    int32 lLastRowIndex;            /* last row scan line index */
    uint32* pulLastRow;             /* for dropout banding */

    int16 **apsHOnBegin;            /* beginning of on pointers array */
    int16 **apsHOffBegin;           /* beginning of off pointers array */
    int16 **apsHOnEnd;              /* end of on pointers array */
    int16 **apsHOffEnd;             /* end of off pointers array */
    int16 **apsHOffMax;             /* max of off pointers array, to detect overflow */
    int16 **apsHorizBegin;          /* current pointer array */
    int16 **apsHorizEnd;            /* current pointer array */
    int16 **apsHorizMax;            /* current pointer array, to detect overflow */

    int16 **apsVOnBegin;            /* beginning of on pointers array */
    int16 **apsVOffBegin;           /* beginning of off pointers array */
    int16 **apsVOnEnd;              /* end of on pointers array */
    int16 **apsVOffEnd;             /* end of off pointers array */
    int16 **apsVOffMax;             /* max of off pointers array, to detect overflow */
    int16 **apsVertBegin;           /* current pointer array */
    int16 **apsVertEnd;             /* current pointer array */
    int16 **apsVertMax;             /* current pointer array, to detect overflow */
                            
#ifdef FSCFG_REENTRANT              /* needed to avoid circular PSTATE */
    void (*pfnAddHoriz)(struct statevar*, int32, int32);
    void (*pfnAddVert)(struct statevar*, int32, int32);
#else
    void (*pfnAddHoriz)(int32, int32);
    void (*pfnAddVert)(int32, int32);
#endif

    F26Dot6 (*pfnHCallBack[SC_MAXCODES])(int32, F26Dot6*, F26Dot6*);
    F26Dot6 (*pfnVCallBack[SC_MAXCODES])(int32, F26Dot6*, F26Dot6*);
        
    F26Dot6 *afxXPoints;            /* x element control points */
    F26Dot6 *afxYPoints;            /* y element control points */
    int32 lElementPoints;           /* estimate of element points */
    int32 lPoint;                   /* index to element control points */
    uint16 usScanTag;               /* stores point index, element code */
    int16 sIxSize;                  /* int16's per intersection */
    int16 sIxShift;                 /* log2 of size */

/* memory state variables */

    char *pchHNextAvailable;        /* horizontal memory pointer */
    char *pchVNextAvailable;        /* vertical memory pointer */
    char *pchHWorkSpaceEnd;         /* horizontal memory overflow */
    char *pchVWorkSpaceEnd;         /* vertical memory overflow */
}
StateVars;

/********************************************************************/

/*              Reentrancy parameters                               */

/********************************************************************/

#ifdef FSCFG_REENTRANT

#define PSTATE      StateVars *pState,
#define PSTATE0     StateVars *pState
#define ASTATE      pState,
#define ASTATE0     pState
#define STATE       (*pState)

#else 

#define PSTATE
#define PSTATE0     void
#define ASTATE
#define ASTATE0
#define STATE       State

extern  StateVars   State;              /* statically alloc'd in NewScan */

#endif 

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scline.h ===
/*********************************************************************

	  scline.h -- Line Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   3/19/93 deanb    size_t replaced with int32
	  10/28/92 deanb    reentrant params renamed, mem req redone
	  10/09/92 deanb    PSTP added
	   9/25/92 deanb    include scan control type 
	   9/09/92 deanb    GetLineElemSize returns size_t 
	   8/21/92 deanb    GetLineElemSize added 
	   7/23/92 deanb    Back to x2,y2 again 
	   7/17/92 deanb    Changed from longline to line 
	   4/21/92 deanb    Scan lines and on/off added 
	   4/09/92 deanb    New types 
	   4/01/92 deanb    Back to x2,y2 
	   3/20/92 deanb    Reintroduced 
	   1/14/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupLine ( PSTATE0 );

FS_PUBLIC int32 fsc_CalcLine( 
		PSTATE              /* pointer to state variables */
		F26Dot6,            /* point 1  x coordinate */
		F26Dot6,            /* point 1  y coordinate */
		F26Dot6,            /* point 2  y coordinate */
		F26Dot6,            /* point 2  y coordinate */
		uint16              /* scan control type */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scline.c ===
/*********************************************************************

	  scline.c -- New Scan Converter Line Module

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   6/10/93  deanb   assert.h and stdio.h removed
	   3/19/93  deanb   size_t replaced with int32
	  12/22/92  deanb   MultDivide replaced with LongMulDiv
	  10/28/92  deanb   mem requirement reworked
	  10/13/92  deanb   horiz / vert line rework
	  10/09/92  deanb   reentrant
	   9/25/92  deanb   branch on scan kind 
	   9/21/92  deanb   rework horiz & vert lines 
	   9/14/92  deanb   reflection correction with iX/YOffset 
	   9/10/92  deanb   first dropout code 
	   9/08/92  deanb   quickstep deleted 
	   8/18/92  deanb   include struc.h, scconst.h 
	   7/23/92  deanb   Back to x1,y1,x2,y2 input params 
	   7/17/92  deanb   Changed from longline to line 
	   6/18/92  deanb   Cross product line rendering  
	   3/23/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for subpix calc */

#include    "scglobal.h"            /* structures & constants */
#include    "scanlist.h"            /* saves scan line intersections */
#include    "scline.h"              /* for own function prototypes */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizLineSubpix(int32, F26Dot6*, F26Dot6*);
FS_PRIVATE F26Dot6 CalcVertLineSubpix(int32, F26Dot6*, F26Dot6*);


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/
	
/*  pass callback routine pointers to scanlist for smart dropout control */

FS_PUBLIC void fsc_SetupLine (PSTATE0) 
{
	fsc_SetupCallBacks(ASTATE SC_LINECODE, CalcHorizLineSubpix, CalcVertLineSubpix);
}


/*********************************************************************/

FS_PUBLIC int32 fsc_CalcLine( 
		PSTATE                /* pointer to state variables */
		F26Dot6 fxX1,         /* point 1  x coordinate */
		F26Dot6 fxY1,         /* point 1  y coordinate */
		F26Dot6 fxX2,         /* point 2  x coordinate */
		F26Dot6 fxY2,         /* point 2  y coordinate */
		uint16 usScanKind     /* dropout control type */
)
{
	int32 lXScan;                           /* current x pixel index */
	int32 lXSteps;                          /* vert scanline index count */
	int32 lXIncr;                           /* x pixel increment */
	int32 lXOffset;                         /* reflection correction */
	
	int32 lYScan;                           /* current scanline index */
	int32 lYSteps;                          /* horiz scanline index count */
	int32 lYIncr;                           /* y pixel increment */
	int32 lYOffset;                         /* reflection correction */

	F26Dot6 fxXInit, fxYInit;               /* sub steps to first pixel */
	F26Dot6 fxXScan, fxYScan;               /* x,y pixel center coords */
	F26Dot6 fxXX2, fxYY2;                   /* absolute value of DX, DY */
	F26Dot6 fxXTemp, fxYTemp;               /* for horiz/vert line calc */
	
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	int32 lQuadrant;                        /* 1, 2, 3, or 4 */
	int32 lQ;                               /* cross product */
	int32 lDQy, lDQx;                       /* cross product increments */
	int32 i;                                /* loop counter */


/* printf("(%li, %li) - (%li, %li)\n", fxX1, fxY1, fxX2, fxY2); */
	
/*  check y coordinates  */

	if (fxY2 >= fxY1)                           /* if going up or flat */
	{
		lQuadrant = 1;
		lQ = 0L;
		
		fxYScan = SCANABOVE(fxY1);              /* first scanline to cross */
		fxYInit = fxYScan - fxY1;               /* first y step */
		lYScan = (int32)(fxYScan >> SUBSHFT);
		lYSteps = (int32)((SCANBELOW(fxY2)) >> SUBSHFT) - lYScan + 1;
		lYIncr = 1;        
		lYOffset = 0;                           /* no reflection */
		fxYY2 = fxY2 - fxY1;                    /* translate */
	}
	else                                        /* if going down */
	{
		lQuadrant = 4;
		lQ = 1L;                                /* to include pixel centers */
		
		fxYScan = SCANBELOW(fxY1);              /* first scanline to cross */
		fxYInit = fxY1 - fxYScan;               /* first y step */
		lYScan = (int32)(fxYScan >> SUBSHFT);
		lYSteps = lYScan - (int32)((SCANABOVE(fxY2)) >> SUBSHFT) + 1;
		lYIncr = -1;        
		lYOffset = 1;                           /* reflection correction */
		fxYY2 = fxY1 - fxY2;                    /* translate and reflect */
	}
	
	if (fxY2 == fxY1)                           /* if horizontal line */
	{
		if (usScanKind & SK_NODROPOUT)          /* if no dropout control */
		{
			return NO_ERR;                      /* if only horiz scan, done */
		}
		if (fxX2 < fxX1)                        /* if going left  */
		{
			fxYTemp = fxY1 - 1;                 /* to include pix centers */
		}
		else                                    /* if going right */
		{
			fxYTemp = fxY1;          
		}
		lYScan = (int32)(SCANABOVE(fxYTemp) >> SUBSHFT);
		lYSteps = 0;
	}

/*  check x coordinates  */
	
	if (fxX2 >= fxX1)                           /* if going right or vertical */
	{
		fxXScan = SCANABOVE(fxX1);              /* first scanline to cross */
		fxXInit = fxXScan - fxX1;               /* first x step */
		lXScan = (int32)(fxXScan >> SUBSHFT);
		lXSteps = (int32)((SCANBELOW(fxX2)) >> SUBSHFT) - lXScan + 1;
		lXIncr = 1;        
		lXOffset = 0;                           /* no reflection */
		fxXX2 = fxX2 - fxX1;                    /* translate */
	}
	else                                        /* if going left */
	{
		lQ = 1L - lQ;                           /* reverse it */
		lQuadrant = (lQuadrant == 1) ? 2 : 3;   /* negative x choices */

		fxXScan = SCANBELOW(fxX1);              /* first scanline to cross */
		fxXInit = fxX1 - fxXScan;               /* first x step */
		lXScan = (int32)(fxXScan >> SUBSHFT);
		lXSteps = lXScan - (int32)((SCANABOVE(fxX2)) >> SUBSHFT) + 1;
		lXIncr = -1;        
		lXOffset = 1;                           /* reflection correction */
		fxXX2 = fxX1 - fxX2;                    /* translate and reflect */
	}
	
	if (fxX2 == fxX1)                           /* if vertical line       */
	{
		if (fxY2 > fxY1)                        /* if going up  */
		{
			fxXTemp = fxX1 - 1;                 /* to include pix centers */
		}
		else                                    /* if going down */
		{
			fxXTemp = fxX1;          
		}
		lXScan = (int32)(SCANABOVE(fxXTemp) >> SUBSHFT);
		lXSteps = 0;
	}

/*-------------------------------------------------------------------*/
	
	fsc_BeginElement( ASTATE usScanKind, lQuadrant, SC_LINECODE, /* where and what */
					  1, &fxX2, &fxY2,                           /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );       /* what to call */

/*-------------------------------------------------------------------*/

	if (usScanKind & SK_NODROPOUT)              /* if no dropout control */
	{
		if (fxX1 == fxX2)                       /* if vertical line */
		{
			for (i = 0; i < lYSteps; i++)       /*   then blast a column   */
			{
				pfnAddHorizScan(ASTATE lXScan, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
			}
			return NO_ERR;
		}
		
/*  handle general case:  line is neither horizontal nor vertical  */

		lQ += (fxXX2 * fxYInit) - (fxYY2 * fxXInit);  /* cross product init */
		lDQy = fxXX2 << SUBSHFT;
		lDQx = -fxYY2 << SUBSHFT;
																	
		lXScan += lXOffset;

		for (i = 0; i < (lXSteps + lYSteps); i++)
		{
			if (lQ > 0L)                        /* if left of line */
			{
				lXScan += lXIncr;               /* advance x scan + or - */
				lQ += lDQx;           
			}
			else                                /* if right of line */
			{
				pfnAddHorizScan(ASTATE lXScan, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
				lQ += lDQy;
			}
		}
	}
/*-------------------------------------------------------------------*/
	
	else  /* if dropout control */
	{                                           /* handle special case lines  */
		if (fxY1 == fxY2)                       /* if horizontal line */
		{
			for (i = 0; i < lXSteps; i++)       /*   then blast a row   */
			{
				pfnAddVertScan(ASTATE lXScan, lYScan);
				lXScan += lXIncr;               /* advance x scan + or - */
			}
			return NO_ERR;
		}

		if (fxX1 == fxX2)                       /* if vertical line */
		{
			for (i = 0; i < lYSteps; i++)       /*   then blast a column   */
			{
				pfnAddHorizScan(ASTATE lXScan, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
			}
			return NO_ERR;
		}
		
/*  handle general case:  line is neither horizontal nor vertical  */

		lQ += (fxXX2 * fxYInit) - (fxYY2 * fxXInit);  /* cross product init */
		lDQy = fxXX2 << SUBSHFT;
		lDQx = -fxYY2 << SUBSHFT;
																	
		for (i = 0; i < (lXSteps + lYSteps); i++)
		{
			if (lQ > 0L)                        /* if left of line */
			{
				pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
				lXScan += lXIncr;               /* advance x scan + or - */
				lQ += lDQx;           
			}
			else                                /* if right of line */
			{
				pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
				lQ += lDQy;
			}
		}
	}
	return NO_ERR;
}


/*********************************************************************/

/*      Private Callback Functions                                   */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizLineSubpix(int32 lYScan, 
									   F26Dot6 *pfxX, 
									   F26Dot6 *pfxY )
{
	F26Dot6 fxXDrop, fxYDrop;

/* printf("Line (%li, %li) - (%li, %li)", *pfxX, *pfxY, *(pfxX+1), *(pfxY+1)); */

	fxYDrop = ((F26Dot6)lYScan << SUBSHFT) + SUBHALF;
	
	Assert(((fxYDrop > *pfxY) && (fxYDrop < *(pfxY+1))) ||
		   ((fxYDrop < *pfxY) && (fxYDrop > *(pfxY+1))));

	fxXDrop = *pfxX + LongMulDiv(*(pfxX+1) - *pfxX, fxYDrop - *pfxY, *(pfxY+1) - *pfxY);

/* printf("  (%li, %li)\n", fxXDrop, fxYDrop); */

	return fxXDrop;
}


/*********************************************************************/

FS_PRIVATE F26Dot6 CalcVertLineSubpix(int32 lXScan, 
									  F26Dot6 *pfxX, 
									  F26Dot6 *pfxY )
{
	F26Dot6 fxXDrop, fxYDrop;

/* printf("Line (%li, %li) - (%li, %li)", *pfxX, *pfxY, *(pfxX+1), *(pfxY+1)); */

	fxXDrop = ((F26Dot6)lXScan << SUBSHFT) + SUBHALF;
	
	Assert(((fxXDrop > *pfxX) && (fxXDrop < *(pfxX+1))) ||
		   ((fxXDrop < *pfxX) && (fxXDrop > *(pfxX+1))));

	fxYDrop = *pfxY + LongMulDiv(*(pfxY+1) - *pfxY, fxXDrop - *pfxX, *(pfxX+1) - *pfxX);

/* printf("  (%li, %li)\n", fxXDrop, fxYDrop); */

	return fxYDrop;
}


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scentry.h ===
/*********************************************************************

      scentry.h -- NewScan Module Exports

      (c) Copyright 1992-95  Microsoft Corp.  All rights reserved.

       1/23/95  deanb       added fsc_GetCoords helper function
       9/07/93  deanb       F26Dot6 min/max added to gbmp structure
       8/10/93  deanb       expand interface for gray scale
       6/10/93  deanb       fsc_Initialize added
       4/21/93  deanb       banding params for MeasureGlyph
       3/29/93  deanb       reversal memory added to WorkScan
       3/19/93  deanb       size_t replaced with int32
      12/22/92  deanb       Rectangle -> Rect
      12/21/92  deanb       Interface types aligned with rasterizer
      11/30/92  deanb       WorkSpace renamed WorkScan
      11/05/92  deanb       ulPointCount removed from ContourList
      11/04/92  deanb       RemoveDups function added
      10/14/92  deanb       Exported data structures added
       8/18/92  deanb       Scan type param added 
       8/17/92  deanb       Functions renamed to ..Glyph 
       7/24/92  deanb       Polyline functions deleted 
       4/09/92  deanb       New types 
       3/30/92  deanb       WorkspaceSize renamed MeasureContour 
       3/24/92  deanb       BitMap back to WorkspaceSize 
       3/20/92  deanb       Structs moved to fscdefs.h, params trimmed 
       3/17/92  deanb       Add ulPointCount, rework fcn params 
       3/05/92  deanb       Add data structures 
       3/04/92  deanb       Size reports added 
       2/21/92  deanb       First cut 

*********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/********************************************************************/

/*      Exported Data Structures                                    */

/********************************************************************/

typedef struct
{
    uint16 usContourCount;          /* number of contours */
    int16 *asStartPoint;            /* contour startpoint index array */
    int16 *asEndPoint;              /* contour endpoint index array */
    F26Dot6 *afxXCoord;             /* contour x coordinate array */
    F26Dot6 *afxYCoord;             /* contour y coordinate array */
    uint8 *abyOnCurve;              /* on curve / off curve array */
    uint8 *abyFc;					/* contour flags, one byte for every contour */
}
ContourList;

typedef struct
{
    int16 sRowBytes;                /* bit map width in bytes */
    int16 sHiBand;                  /* upper banding limit */
    int16 sLoBand;                  /* lower banding limit */
    Rect rectBounds;                /* bit map border */
    boolean bZeroDimension;         /* flags zero width or height */
    F26Dot6 fxMinX;                 /* full precision x minimum */
    F26Dot6 fxMaxX;                 /* full precision x maximum */
    F26Dot6 fxMinY;                 /* full precision y minimum */
    F26Dot6 fxMaxY;                 /* full precision y maximum */
    int32 lMMemSize;                /* size of bitmap in bytes */
    char *pchBitMap;                /* pixel bit map */
}
GlyphBitMap;

typedef struct
{
    int32 lRMemSize;                /* workspace bytes for reversal lists */
    int32 lHMemSize;                /* workspace bytes needed for horiz scan */
    int32 lVMemSize;                /* additional workspace for vert scan */
    int32 lHInterCount;             /* estimate of horiz scan intersections */
    int32 lVInterCount;             /* estimate of vert scan intersections */
    int32 lElementCount;            /* estimate of element control points */
    char *pchRBuffer;               /* reversal workspace byte pointer */
    char *pchHBuffer;               /* horiz workspace byte pointer */
    char *pchVBuffer;               /* vert workspace byte pointer */
}
WorkScan;

typedef struct
{
    int16 x;                        /* x pixel value */
    int16 y;                        /* y pixel value */
}
PixCoord;

/*********************************************************************/

/*      Function Exports                                             */

/*********************************************************************

  fsc_Initialize

    This routine calls down to the bitmap module to initialize the
    bitmap masks.  It should be called once, before and scan conversion
    is done.  No harm will be done if it is called more than once.

*/

FS_PUBLIC void fsc_Initialize (
        void
);


/*********************************************************************

  fsc_RemoveDups

    This routine examines a glyph contour by contour and removes any
    duplicated points.  Two subtlties here:  1) following a call to
    this routine, the relation of End[i] + 1 = Start[i + 1] may no
    longer hold (in other words, the contours may not be tightly
    packed);  and 2) two duplicate off curve points will become a
    single ON curve point (this makes sense when you remember that
    between any two offs there must be an on).

  Input Values:

    ContourList -   All values set (pointers to contour arrays)

  Returned Values:
    
    ContourList -   Start, X, Y, and OnCurve arrays may be modified

*/

FS_PUBLIC int32 fsc_RemoveDups( 
        ContourList*        /* glyph outline */
);

/*********************************************************************

  fsc_OverScaleOutline(&Clist, inputPtr->param.gray.usOverScale);

    This routine scales up an outline for gray scale scan conversion

  Input Values:

    ContourList -   All values set (pointers to contour arrays)
    
    uint16      -   usOverScale     Multiplier

  Returned Values:
    
    ContourList -   X and Y arrays will be multiplied by usOverScale

*/

FS_PUBLIC int32 fsc_OverScaleOutline( 
        ContourList*,       /* glyph outline */
        uint16              /* over scale factor */
);

/*********************************************************************

  fsc_MeasureGlyph

    This routine examines a glyph contour by contour and calculates 
    its size and the amount of workspace needed to scan convert it.

  Input Values:

    ContourList -   All values set (pointers to contour arrays)

    WorkScan    -   pchRBuffer      Points to MeasureGlyph workspace used to
                                    store contour reversals.
                    lRMemSize       Size of RBuffer in bytes.  This should be
                                    2 * sizeof(Reversal) * NumberOfPoints to
                                    handle the worst case.
    
    uint16      -   usScanKind      Dropout control code

    uint16      -   usRoundXMin     Allows alignment of XMin for gray scale
                                    XMin modulo usRoundXMin will be zero

  Returned Values:

    WorkScan    -   pchRBuffer      Unchanged
                    lRMemSize       Amount of RBuffer actually used.  This will
                                    typically be much less than the worst case.
                    lHMemSize       Amount of horizontal workspace memory required.
                                    (Memory base 6, always used)
                    lVMemSize       Amount of vertical workspace memory required.
                                    (Memory base 7, used for dropout only)
                    lHInterCount    Estimate of horiz scan intersections
                    lVInterCount    Estimate of vert scan intersections
                    lElementCount   Estimate of element control points

    GlyphBitMap -   sRowBytes       Bytes per row in bitmap (padded to 0 mod 4).
                    rectBounds      Worst case black bounding box.
                    lMMemSize       Size of bitmap in bytes
*/

FS_PUBLIC int32 fsc_MeasureGlyph( 
		ContourList* pclContour,        /* glyph outline */
		GlyphBitMap* pbmpBitMap,        /* to return bounds */
		WorkScan* pwsWork,              /* to return values */
		uint16 usScanKind,              /* dropout control value */
		uint16 usRoundXMin,              /* for gray scale alignment */
		int16 sBitmapEmboldeningHorExtra,
		int16 sBitmapEmboldeningVertExtra );
    
/*********************************************************************

  fsc_MeasureBand

    This routine calculates the amount of workspace needed to scan 
    convert a glyph using banding.

  Input Values:

    WorkScan    -   pchRBuffer      Same value as passed into fsc_MeasureGlyph
                    lHMemSize       Size of horizontal memory from MeasureGlyph
                    lVMemSize       Size of vertical memory from MeasureGlyph
                    lHInterCount    Same value as returned from fsc_MeasureGlyph
                    lVInterCount    Same value as returned from fsc_MeasureGlyph
                    lElementCount   Same value as returned from fsc_MeasureGlyph
    
    uint16      -   usBandType      FS_BANDINGSMALL or FS_BANDINGFAST
    
    uint16      -   usBandWidth     Number of scan lines of maximum band

    uint16      -   usScanKind      Dropout control code

  Returned Values:

    WorkScan    -   pchRBuffer      Unchanged
                    lRMemSize       Unchanged
                    lHMemSize       Amount of horizontal workspace memory required.
                                    (Memory base 6, always used)
                    lVMemSize       Amount of vertical workspace memory required.
                                    (Memory base 7, used for dropout only)
                    lHInterCount    Estimate of horiz band intersections
                    lVInterCount    Unchanged
                    lElementCount   Unchanged

    GlyphBitMap -   sRowBytes       Unchanged
                    rectBounds      Unchanged
                    lMMemSize       Size of bitmap in bytes

*/

FS_PUBLIC int32 fsc_MeasureBand( 
        GlyphBitMap*,        /* computed by MeasureGlyph */
        WorkScan*,           /* to return new values */
        uint16,              /* usBandType = small or fast */
        uint16,              /* usBandWidth = scanline count */
        uint16               /* usScanKind = dropout control value */
);


/*********************************************************************

  fsc_FillGlyph

    This routine is responsible for the actual creation of a bitmap
    from the outline.
    
  Input Values:

    ContourList -   All values set (pointers to contour arrays)

    WorkScan    -   pchRBuffer      Same value as passed into fsc_MeasureGlyph
                    pchHBuffer      Pointer to horizontal workspace memory
                    pchVBuffer      Pointer to vertical workspace memory
                    lHMemSize       Size of horizontal memory (for assertion checks)
                    lVMemSize       Size of vertical memory (for assertion checks)
                    lHInterCount    Same value as returned from fsc_MeasureGlyph
                    lVInterCount    Same value as returned from fsc_MeasureGlyph
                    lElementCount   Same value as returned from fsc_MeasureGlyph

    GlyphBitMap -   pchBitMap       Pointer to bit map output buffer
                    sRowBytes       Same value as returned from fsc_MeasureGlyph
                    rectBounds      Same value as returned from fsc_MeasureGlyph
  
    uint16      -   usBandType      Old, Small, or Fast banding code
    
    uint16      -   usScanKind      Dropout control code

  Returned Values:

    GlyphBitMap -   Bit map output buffer filled in.

*/

FS_PUBLIC int32 fsc_FillGlyph( 
        ContourList*,       /* glyph outline */
        GlyphBitMap*,       /* target */
        WorkScan*,          /* for scan array */
        uint16,             /* banding type */
        uint16              /* scan type */
);

/*********************************************************************

  fsc_CalcGrayMap

    This routine calculates a gray scale bitmap from an overscaled bitmap
    
  Input Values:

    GlyphBitMap1 -  pchBitMap       Pointer to over scaled bit map
                    sRowBytes       Same value as returned from fsc_MeasureGlyph
                    rectBounds      Same value as returned from fsc_MeasureGlyph
    
    GlyphBitMap2 -  pchBitMap       Pointer to gray scale bit map output buffer
                    sRowBytes       1 byte per pixel
                    rectBounds      Same value as returned from fsc_MeasureExtrema
    
    uint16       -  usOverScale     Gray scale contour multiplier
  
  Returned Values:

    GlyphBitMap2 -  Gray scale bit map output buffer filled in.

*/

FS_PUBLIC int32 fsc_CalcGrayMap( 
        GlyphBitMap*,       /* over scaled source */
        GlyphBitMap*,       /* gray scale target */
        uint16              /* over scale factor */
);


/*********************************************************************

  fsc_GetCoords

    This routine returns an array of coordinates for outline points
    
  Input Values:

    ContourList -   All values set (pointers to contour arrays)
    
    uint16      -   usPointCount    Number of points to look up

    uint16*     -   pusPointIndex   Array of point indices
  
  Returned Values:

    pxyCoords   -   Array of (x,y) integer (pixel) coordinates

*/

FS_PUBLIC int32 fsc_GetCoords(
        ContourList*,       /* glyph outline */
        uint16,             /* point count */
        uint16*,            /* point indices */
        PixCoord*           /* point coordinates */
);

 /*********************************************************************/

#ifdef FSCFG_SUBPIXEL

/*********************************************************************

  fsc_OverscaleToSubPixel

    This routine is the heart of the RGB striping algorithm
    
  Input Values:

    OverscaledBitmap
  
  Returned Values:

    SubPixelBitMap

*/

FS_PUBLIC void fsc_OverscaleToSubPixel (
    GlyphBitMap * OverscaledBitmap, 
	boolean bgrOrder, 
    GlyphBitMap * SubPixelBitMap
);

 /*********************************************************************/

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scmemory.h ===
/*********************************************************************

      scmemory.h -- Memory Module Exports

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       3/19/93 deanb    size_t replaced with int32
      10/14/92 deanb    New SetupMem parameters
      10/09/92 deanb    PSTP added
      10/08/92 deanb    Horiz/Vert memory alloc's
       9/09/92 deanb    Alloc param int32  
       9/08/92 deanb    Setup with WorkSpace pointer 
       8/21/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupMem( 
        PSTATE              /* pointer to state variables */
        char*,              /* pointer to horiz workspace */
        int32 ,             /* size of horiz workspace */
        char*,              /* pointer to vert workspace */
        int32               /* size of vert workspace */
);

FS_PUBLIC void *fsc_AllocHMem( 
        PSTATE              /* pointer to state variables */
        int32               /* allocate from horiz memory pool */
);

FS_PUBLIC void *fsc_AllocVMem( 
        PSTATE              /* pointer to state variables */
        int32               /* allocate from vert memory pool */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scmemory.c ===
/*********************************************************************

      scmemory.c -- New Scan Converter Memory Managment Module

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       6/10/93  deanb   assert.h and stdio.h removed
      10/28/92  deanb   reentrant params renamed
      10/14/92  deanb   New fsc_SetupMem parameters
      10/09/92  deanb   Reentrant
      10/08/92  deanb   Separate Horiz/Vert memory pools
       9/10/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "scglobal.h"            /* structures & constants */
#include    "scmemory.h"            /* for own function prototypes */


/**********************************************************************

    Workspace memory is divided into two pools, identified here as
    HMem (horizontal memory) and VMem (vertical memory).  HMem is
    always used, and contains horizontal scan array lists.  VMem is 
    used only when dropout control is enabled, and contains the 
    vertical scan array lists and the contour elements used to compute 
    subpixel intersections for smart dropout control.  This division 
    into two pools was done, in part, for backward compatiblity with 
    the Apple rasterizer.  It allows a client to force dropout control
    off by setting the allocated size of VMem to zero.

**********************************************************************/
    
/*********************************************************************/

/*      Export Functions      */

/*********************************************************************/

FS_PUBLIC void fsc_SetupMem( 
        PSTATE                           /* pointer to state variables */
        char* pchHBuffer,                /* pointer to horiz workspace */
        int32 lHMemSize,                 /* size of horiz workspace */
        char* pchVBuffer,                /* pointer to vert workspace */
        int32 lVMemSize )                /* size of vert workspace */
{
    STATE.pchHNextAvailable = pchHBuffer;
    STATE.pchHWorkSpaceEnd = pchHBuffer + lHMemSize;
    
    STATE.pchVNextAvailable = pchVBuffer;
    STATE.pchVWorkSpaceEnd = pchVBuffer + lVMemSize;
}


/********************************************************************/

FS_PUBLIC void *fsc_AllocHMem( 
        PSTATE                         /* pointer to state variables  */
        int32 lSize )                  /* requested size in bytes */
{
    void *pvTemp;
    
/* printf("H: %ui   ", lSize); */

    pvTemp = (void*)STATE.pchHNextAvailable;
    ALIGN(voidPtr, lSize); 
    STATE.pchHNextAvailable += lSize;
    
    Assert(STATE.pchHNextAvailable <= STATE.pchHWorkSpaceEnd);
    return pvTemp;
}

/********************************************************************/

FS_PUBLIC void *fsc_AllocVMem( 
        PSTATE                         /* pointer to state variables */
        int32 lSize )                  /* requested size in bytes */
{
    void *pvTemp;

/* printf("V: %ui   ", lSize); */
    
    pvTemp = (void*)STATE.pchVNextAvailable;
    ALIGN(voidPtr, lSize); 
    STATE.pchVNextAvailable += lSize;
    
    Assert(STATE.pchVNextAvailable <= STATE.pchVWorkSpaceEnd);
    return pvTemp;
}

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scspline.c ===
/*********************************************************************

      scspline.c -- New Scan Converter Spline Module

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       6/10/93  deanb   assert.h and stdio.h removed
       3/19/93  deanb   size_t replaced with int32
      10/28/92  deanb   memory requirements reworked
      10/09/92  deanb   reentrant
       9/28/92  deanb   quick out for nearly vert/horiz splines 
       9/25/92  deanb   branch on scan kind 
       9/22/92  deanb   subpix calculation using subdivision 
       9/14/92  deanb   reflection correction with iX/YOffset 
       9/10/92  deanb   first dropout code 
       9/02/92  deanb   Precision reduction by shifting control points 
       7/24/92  deanb   Initial Q set for perfect symmetry 
       7/23/92  deanb   EvaluateSpline split out and moved to NewScan 
       7/20/92  deanb   removed unreachable case 
       7/16/92  deanb   faster power of 2 
       7/06/92  deanb   Cleanups 
       7/01/92  deanb   Reinstate a single spline routine 
       6/30/92  deanb   Implicit spline rendering 
       3/23/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for power of 2 calc */

#include    "scglobal.h"            /* structures & constants */
#include    "scanlist.h"            /* for direct horizscan add call */
#include    "scspline.h"            /* for own function prototypes */
                
/*********************************************************************/

/*      Constants                                                    */

/*********************************************************************/

#define     QMAXSHIFT      7            /* shift limit q precision */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/
 
FS_PRIVATE F26Dot6 CalcHorizSpSubpix(int32, F26Dot6*, F26Dot6*);
FS_PRIVATE F26Dot6 CalcVertSpSubpix(int32, F26Dot6*, F26Dot6*);


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/
    
/*  pass callback routine pointers to scanlist for smart dropout control */

FS_PUBLIC void fsc_SetupSpline (PSTATE0) 
{
    fsc_SetupCallBacks(ASTATE SC_SPLINECODE, CalcHorizSpSubpix, CalcVertSpSubpix);
}


/*********************************************************************/

FS_PUBLIC int32 fsc_CalcSpline( 
        PSTATE                  /* pointer to state variables */
        F26Dot6 fxX1,           /* start point x coordinate */
        F26Dot6 fxY1,           /* start point y coordinate */
        F26Dot6 fxX2,           /* control point x coordinate */
        F26Dot6 fxY2,           /* control point y coordinate */
        F26Dot6 fxX3,           /* ending x coordinate */
        F26Dot6 fxY3,           /* ending y coordinate */
        uint16 usScanKind )     /* dropout control type */
{
    F26Dot6 fxXInit, fxYInit;           /* initial step values */
    F26Dot6 fxXScan, fxYScan;           /* set to first crossings */
    F26Dot6 fxXX2, fxYY2;               /* translated reflected control point */
    F26Dot6 fxXX3, fxYY3;               /* translated reflected end point */
    
    F26Dot6 afxXControl[2];             /* params for BeginElement call */
    F26Dot6 afxYControl[2];

    void (*pfnAddHorizScan)(PSTATE int32, int32);
    void (*pfnAddVertScan)(PSTATE int32, int32);
    
    int32 lABits;                       /* 1+int(log2(alpha)) */
    int32 lXYBits;                      /* 1+int(log2(max(x3,y3))) */
    int32 lZBits;                       /* 6, 5, 4 log2(subpixels per pix) */
    int32 lZShift;                      /* 0, 1, 2 shift to minipixel */
    F26Dot6 fxZRound;                   /* rounding factor for minipix shift */
    F26Dot6 fxZSubpix;                  /* 64, 32, 16 subpixels per pix */
    int32 lQuadrant;                    /* 1, 2, 3, or 4 */

    F26Dot6 fxAx, fxAy;                 /* parametric 2nd order terms */
    F26Dot6 lAlpha;                     /* cross product measures curvature */

    int32 lR, lT;                       /* quadratic coefficients for xx, yy */
    int32 lS2, lU2, lV2;                /* half coefficients for xy, x, y */
    int32 lRz, lSz, lTz;                /* coeff's times subpix size */
        
    int32 lQ;                           /* cross product value */
    int32 lDQx, lDQy;                   /* first order derivative */
    int32 lDDQx, lDDQy;                 /* second order derivative */

    int32 lYScan;                       /* scan line counter */
    int32 lYStop;                       /* scan line end */
    int32 lYIncr;                       /* scan line direction */
    int32 lYOffset;                     /* reflection correction */
    int32 lXScan;                       /* horiz pix position */
    int32 lXStop;                       /* pix end */
    int32 lXIncr;                       /* pix increment direction */
    int32 lXOffset;                     /* reflection correction */

    static const int32 lZShiftTable[] = { /* for precision adjustment */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /*  0 -  9  */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /* 10 - 19 */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /* 20 - 29 */
        1, 1, 1, 2, 2, 2, 3, 3          /* 30 - 34 */
    };


/* printf("(%li, %li) - (%li, %li) -(%li, %li)\n", fxX1, fxY1, fxX2, fxY2, fxX3, fxY3 ); */


/*  Translate spline point 1 to (0,0) and reflect into the first quadrant  */
    
    if (fxY3 > fxY1)                            /* if going up */
    {
        lQ = 0L;
        lQuadrant = 1;

        fxYScan = SCANABOVE(fxY1);              /* first scanline to cross */
        fxYInit = fxYScan - fxY1;               /* first y step */
        lYScan = (int32)(fxYScan >> SUBSHFT);
        lYStop = (int32)((SCANBELOW(fxY3)) >> SUBSHFT) + 1;
        lYIncr = 1;        
        lYOffset = 0;                           /* no reflection */
        fxYY2 = fxY2 - fxY1;                    /* translate */
        fxYY3 = fxY3 - fxY1;
    }
    else                                        /* if going down */
    {
        lQ = 1L;                                /* to include pixel centers */
        lQuadrant = 4;
        
        fxYScan = SCANBELOW(fxY1);              /* first scanline to cross */
        fxYInit = fxY1 - fxYScan;               /* first y step */
        lYScan = (int32)(fxYScan >> SUBSHFT);
        lYStop = (int32)((SCANABOVE(fxY3)) >> SUBSHFT) - 1;
        lYIncr = -1;        
        lYOffset = 1;                           /* reflection correction */
        fxYY2 = fxY1 - fxY2;                    /* translate and reflect */
        fxYY3 = fxY1 - fxY3;
    }
    
    if (fxX3 > fxX1)                            /* if going right */
    {
        fxXScan = SCANABOVE(fxX1);              /* first scanline to cross */
        fxXInit = fxXScan - fxX1;               /* first x step */
        lXScan = (int32)(fxXScan >> SUBSHFT);
        lXStop = (int32)((SCANBELOW(fxX3)) >> SUBSHFT) + 1;
        lXIncr = 1;        
        lXOffset = 0;                           /* no reflection */
        fxXX2 = fxX2 - fxX1;                    /* translate */
        fxXX3 = fxX3 - fxX1;
    }
    else                                        /* if going left or straight */
    {
        lQ = 1L - lQ;                           /* to include pixel centers */
        lQuadrant = (lQuadrant == 1) ? 2 : 3;   /* negative x choices */

        fxXScan = SCANBELOW(fxX1);              /* first scanline to cross */
        fxXInit = fxX1 - fxXScan;               /* first x step */
        lXScan = (int32)(fxXScan >> SUBSHFT);
        lXStop = (int32)((SCANABOVE(fxX3)) >> SUBSHFT) - 1;
        lXIncr = -1;        
        lXOffset = 1;                           /* reflection correction */
        fxXX2 = fxX1 - fxX2;                    /* translate and reflect */
        fxXX3 = fxX1 - fxX3;
    }

/*-------------------------------------------------------------------*/
    
    afxXControl[0] = fxX2;
    afxYControl[0] = fxY2;
    afxXControl[1] = fxX3;
    afxYControl[1] = fxY3;

    fsc_BeginElement( ASTATE usScanKind, lQuadrant, SC_SPLINECODE,  /* where and what */
                      2, afxXControl, afxYControl,                  /* number of pts */
                      &pfnAddHorizScan, &pfnAddVertScan );          /* what to call */

/*-------------------------------------------------------------------*/

    if (usScanKind & SK_NODROPOUT)              /* if no dropout control */
    {
        if (lYScan == lYStop)                   /* and if no scan crossings */
        {
            return NO_ERR;                      /* then quick exit */
        }
        
        if (lXScan == lXStop)                   /* if nearly vertical */
        {    
            lXScan += lXOffset;
            while (lYScan != lYStop)
            {
                pfnAddHorizScan(ASTATE lXScan, lYScan);
                lYScan += lYIncr;               /* advance y scan + or - */
            }
            return NO_ERR;                      /* quick out */
        }
    }
        
/*-------------------------------------------------------------------*/

    else                                        /* if smart dropout control on */
    {
        if (lXScan == lXStop)                   /* if nearly vertical */
        {    
            lXScan += lXOffset;
            while (lYScan != lYStop)
            {
                pfnAddHorizScan(ASTATE lXScan, lYScan);
                lYScan += lYIncr;               /* advance y scan + or - */
            }
            return NO_ERR;                      /* quick out */
        }

        if (lYScan == lYStop)                   /* if nearly horizontal */
        {
            lYScan += lYOffset;
            while (lXScan != lXStop)
            {
                pfnAddVertScan(ASTATE lXScan, lYScan);
                lXScan += lXIncr;               /* advance x scan + or - */
            }        
            return NO_ERR;                      /* quick out */
        }
    }

/*-------------------------------------------------------------------*/

/*  Now calculate parametric term precision      */

    Assert(fxXX3 <= MAXSPLINELENGTH);
    Assert(fxYY3 <= MAXSPLINELENGTH);

    lAlpha = (fxXX2 * fxYY3 - fxYY2 * fxXX3) << 1;      /* curvature term */
    
    lABits = PowerOf2(lAlpha);
    lXYBits = fxXX3 > fxYY3 ? PowerOf2((int32)fxXX3) : PowerOf2((int32)fxYY3);
    
    Assert(lXYBits <= 12);                      /* max allowed spline bits */
    Assert(lABits <= 25);

    lZShift = lZShiftTable[lABits + lXYBits];   /* look up precision fix */
    lZBits = SUBSHFT - lZShift;

    if (lZShift > 0)                            /* if precision fix is needed */
    {
        fxZRound = 1L << (lZShift - 1);
        
        fxXX2 = (fxXX2 + fxZRound) >> lZShift;  /* shift to 32 or 16 subpix grid */
        fxXX3 = (fxXX3 + fxZRound) >> lZShift;
        fxYY2 = (fxYY2 + fxZRound) >> lZShift;
        fxYY3 = (fxYY3 + fxZRound) >> lZShift;
        
        fxXInit = (fxXInit + fxZRound) >> lZShift;
        fxYInit = (fxYInit + fxZRound) >> lZShift;

        lAlpha = (fxXX2 * fxYY3 - fxYY2 * fxXX3) << 1;  /* recompute curvature */
    }

    Assert (FXABS(lAlpha * fxXX3) < (1L << 29) + (3L << 24));
    Assert (FXABS(lAlpha * fxYY3) < (1L << 29) + (3L << 24));

/*  Calculate terms for Q = Rxx + Sxy + Tyy + Ux + Vy  */

    fxAx = fxXX3 - (fxXX2 << 1);
    fxAy = fxYY3 - (fxYY2 << 1);

    lR = fxAy * fxAy;
    lS2 = -fxAx * fxAy;
    lT = fxAx * fxAx;
    lU2 = fxYY2 * lAlpha;
    lV2 = -fxXX2 * lAlpha;

/*  
    Calculate starting forward difference terms:

    lQ = Q(x,y) = Rxx + Sxy + Tyy + Ux + Vy
    lDQx = Q(x+z, y) - Q(x, y) = R(2xz + zz) + Syz + Uz
    lDQy = Q(x, y+z) - Q(x, y) = T(2yz + zz) + Sxz + Vz 

*/
    fxZSubpix = 1L << lZBits;                   /* adjusted subpix per pix */

    if (lXYBits <= QMAXSHIFT)                   /* if small enough use full Q */
    {
        lQ += (lR * fxXInit + (lS2 << 1) * fxYInit + (lU2 << 1)) * fxXInit + 
              (lT * fxYInit + (lV2 << 1)) * fxYInit;
        lDQx = (lR * ((fxXInit << 1) + fxZSubpix) + (lS2 << 1) * fxYInit + (lU2 << 1)) << lZBits;
        lDQy = (lT * ((fxYInit << 1) + fxZSubpix) + (lS2 << 1) * fxXInit + (lV2 << 1)) << lZBits;
        
        lRz = lR << (lZBits << 1);              /* needed in the loop */
        lSz = (lS2 << 1) << (lZBits << 1);
        lTz = lT << (lZBits << 1);
    }
    else                                        /* if too big take out a 2 * Z */
    {
        lQ += (((lR >> 1) * fxXInit + lS2 * fxYInit + lU2) >> lZBits) * fxXInit + 
              (((lT >> 1) * fxYInit + lV2) >> lZBits) * fxYInit;
        
        lDQx = lR * (fxXInit + (fxZSubpix >> 1)) + lS2 * fxYInit + lU2;
        lDQy = lT * (fxYInit + (fxZSubpix >> 1)) + lS2 * fxXInit + lV2;
        
        lRz = lR << (lZBits - 1);               /* needed in the loop */
        lSz = lS2 << lZBits;
        lTz = lT << (lZBits - 1);
    }
    lDDQx = lRz << 1;                           /* 2nd derivative terms */
    lDDQy = lTz << 1;
                
/*-------------------------------------------------------------------*/

    if (usScanKind & SK_NODROPOUT)              /* if no dropout control */
    {
        lXScan += lXOffset;                     /* pre increment */
        lXStop += lXOffset;                     /* limit too */

/*  Branch to appropriate inner loop  */

        if (lAlpha > 0L)                        /* if curvature up */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQy > lTz))  /* check against dy */
                {
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }                               
                else
                {
                    pfnAddHorizScan(ASTATE lXScan, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
            }
        }
        else                                    /* if curvature down */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQx > lRz))  /* check against dx */
                {
                    pfnAddHorizScan(ASTATE lXScan, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
                else
                {
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }
            }
        }

/* if past bounding box, finish up */

        while (lYScan != lYStop)
        {
            pfnAddHorizScan(ASTATE lXScan, lYScan);
            lYScan += lYIncr;                   /* advance y scan + or - */
        }
    }        

/*-------------------------------------------------------------------*/

    else                                        /* if dropout control on */
    {
        if (lAlpha > 0L)                        /* if curvature up */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQy > lTz))  /* check against dy */
                {
                    pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }                               
                else
                {
                    pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
            }
        }
        else                                    /* if curvature down */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQx > lRz))  /* check against dx */
                {
                    pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
                else
                {
                    pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }
            }
        }

/* if outside the bounding box, finish up */

        while (lXScan != lXStop)
        {
            pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
            lXScan += lXIncr;                   /* advance x scan + or - */
        }        
        
        while (lYScan != lYStop)
        {
            pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
            lYScan += lYIncr;                   /* advance y scan + or - */
        }
    }

/*-------------------------------------------------------------------*/

    return NO_ERR;
}


/*********************************************************************/

/*      Private Callback Functions      */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizSpSubpix(
    int32 lYScan, 
    F26Dot6 *pfxX, 
    F26Dot6 *pfxY )
{
    F26Dot6 fxYDrop;                            /* dropout scan line */
    F26Dot6 fxX1, fxY1;                         /* local control points */
    F26Dot6 fxX2, fxY2;
    F26Dot6 fxX3, fxY3;
    F26Dot6 fxXMid, fxYMid;                     /* spline center point */

/* printf("Spline (%li, %li) - (%li, %li) - (%li, %li)", *pfxX, *pfxY,
        *(pfxX+1), *(pfxY+1), *(pfxX+2), *(pfxY+2));
*/

    fxYDrop = ((F26Dot6)lYScan << SUBSHFT) + SUBHALF;
    
    Assert(((fxYDrop > *pfxY) && (fxYDrop < *(pfxY+2))) ||
           ((fxYDrop < *pfxY) && (fxYDrop > *(pfxY+2))));

    fxX2 = *(pfxX+1);
    fxY2 = *(pfxY+1);
    
    if (*pfxY < *(pfxY+2))                      /* if spline goes up */
    {
        fxX1 = *pfxX;                           /* just copy it */
        fxY1 = *pfxY;
        fxX3 = *(pfxX+2);
        fxY3 = *(pfxY+2);
    }
    else                                        /* if spline goes down */
    {
        fxX1 = *(pfxX+2);                       /* flip it upside down */
        fxY1 = *(pfxY+2);
        fxX3 = *pfxX;
        fxY3 = *pfxY;
    }

    do                                          /* midpoint subdivision */
    {
        fxXMid = (fxX1 + fxX2 + fxX2 + fxX3 + 1) >> 2;
        fxYMid = (fxY1 + fxY2 + fxY2 + fxY3 + 1) >> 2;
        
        if (fxYMid > fxYDrop)
        {
            fxX2 = (fxX1 + fxX2) >> 1;          /* subdivide down */
            fxY2 = (fxY1 + fxY2) >> 1;
            fxX3 = fxXMid;
            fxY3 = fxYMid;
        }
        else if (fxYMid < fxYDrop)
        {
            fxX2 = (fxX2 + fxX3) >> 1;          /* subdivide up */
            fxY2 = (fxY2 + fxY3) >> 1;
            fxX1 = fxXMid;
            fxY1 = fxYMid;
        }
    } 
    while (fxYMid != fxYDrop);

/* printf("  (%li, %li)\n", fxXMid, fxYMid); */

    return fxXMid;
}


/*********************************************************************/

FS_PRIVATE F26Dot6 CalcVertSpSubpix(
    int32 lXScan, 
    F26Dot6 *pfxX, 
    F26Dot6 *pfxY )
{
    F26Dot6 fxXDrop;                            /* dropout scan line */
    F26Dot6 fxX1, fxY1;                         /* local control points */
    F26Dot6 fxX2, fxY2;
    F26Dot6 fxX3, fxY3;
    F26Dot6 fxXMid, fxYMid;                     /* spline center point */

/* printf("Spline (%li, %li) - (%li, %li) - (%li, %li)", *pfxX, *pfxY,
        *(pfxX+1), *(pfxY+1), *(pfxX+2), *(pfxY+2));
*/
    
    fxXDrop = ((F26Dot6)lXScan << SUBSHFT) + SUBHALF;
    
    Assert(((fxXDrop > *pfxX) && (fxXDrop < *(pfxX+2))) ||
           ((fxXDrop < *pfxX) && (fxXDrop > *(pfxX+2))));
    
    fxX2 = *(pfxX+1);
    fxY2 = *(pfxY+1);

    if (*pfxX < *(pfxX+2))                      /* if spline goes right */
    {                                                                  
        fxX1 = *pfxX;                           /* just copy it */
        fxY1 = *pfxY;
        fxX3 = *(pfxX+2);
        fxY3 = *(pfxY+2);
    }
    else                                        /* if spline goes left */
    {                                                                  
        fxX1 = *(pfxX+2);                       /* flip it around */
        fxY1 = *(pfxY+2);
        fxX3 = *pfxX;
        fxY3 = *pfxY;
    }

    do
    {
        fxXMid = (fxX1 + fxX2 + fxX2 + fxX3 + 1) >> 2;
        fxYMid = (fxY1 + fxY2 + fxY2 + fxY3 + 1) >> 2;
        
        if (fxXMid > fxXDrop)
        {
            fxX2 = (fxX1 + fxX2) >> 1;          /* subdivide left */
            fxY2 = (fxY1 + fxY2) >> 1;
            fxX3 = fxXMid;
            fxY3 = fxYMid;
        }
        else if (fxXMid < fxXDrop)
        {
            fxX2 = (fxX2 + fxX3) >> 1;          /* subdivide right */
            fxY2 = (fxY2 + fxY3) >> 1;
            fxX1 = fxXMid;
            fxY1 = fxYMid;
        }
    } 
    while (fxXMid != fxXDrop);

/* printf("  (%li, %li)\n", fxXMid, fxYMid); */
    
    return fxYMid;
}


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\sfnt.h ===
/*
	File:       sfnt.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  c 1988-1990 by Apple Computer, Inc., all rights reserved.
	            (c) 1989-1999 by Microsoft Corporation.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		 <3>    02/21/97    CB      ClaudeBe, add flags for scaled composite offset compatibility
		 <3>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
		 <2>    10/20/90    MR      Remove unneeded tables from sfnt_tableIndex. [rb]
		<12>     7/18/90    MR      platform and specific should always be unsigned
		<11>     7/14/90    MR      removed duplicate definitions of int[8,16,32] etc.
		<10>     7/13/90    MR      Minor type changes, for Ansi-C
		 <9>     6/29/90    RB      revise postscriptinfo struct
		 <7>      6/4/90    MR      Remove MVT
		 <6>      6/1/90    MR      pad postscriptinfo to long word aligned
		 <5>     5/15/90    MR      Add definition of PostScript table
		 <4>      5/3/90    RB      mrr     Added tag for font program 'fpgm'
		 <3>     3/20/90    CL      chucked old change comments from EASE
		 <2>     2/27/90    CL      getting bbs headers
	   <3.1>    11/14/89    CEL     Instructions are legal in components.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.7>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.6>     6/13/89    SJK     Comment
	   <1.5>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.4>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.3>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts

	To Do:
		<3+>     3/20/90    mrr     Added tag for font program 'fpgm'
*/

#pragma pack(1)

#ifndef SFNT_DEFINED
#define SFNT_DEFINED

#include "fscdefs.h" // DO NOT REMOVE
#include "sfnt_en.h"

typedef struct {
	uint32 bc;
	uint32 ad;
} BigDate;

typedef struct {
	sfnt_TableTag   tag;
	uint32          checkSum;
	uint32          offset;
	uint32          length;
} sfnt_DirectoryEntry;

/*
 *  The search fields limits numOffsets to 4096.
 */
typedef struct {
	int32 version;                  /* 0x10000 (1.0) */
	uint16 numOffsets;              /* number of tables */
	uint16 searchRange;             /* (max2 <= numOffsets)*16 */
	uint16 entrySelector;           /* log2 (max2 <= numOffsets) */
	uint16 rangeShift;              /* numOffsets*16-searchRange*/
	sfnt_DirectoryEntry table[1];   /* table[numOffsets] */
} sfnt_OffsetTable;
#define OFFSETTABLESIZE     12  /* not including any entries */

/*
 *  for the flags field
 */
#define Y_POS_SPECS_BASELINE            0x0001
#define X_POS_SPECS_LSB                 0x0002
#define HINTS_USE_POINTSIZE             0x0004
#define USE_INTEGER_SCALING             0x0008
#define INSTRUCTED_ADVANCE_WIDTH        0x0010

/* flags 5-10 defined by Apple */
#define APPLE_VERTICAL_LAYOUT           0x0020
#define APPLE_RESERVED                  0x0040
#define APPLE_LINGUISTIC_LAYOUT         0x0080
#define APPLE_GX_METAMORPHOSIS          0x0100
#define APPLE_STRONG_RIGHT_TO_LEFT      0x0200
#define APPLE_INDIC_EFFECT              0x0400

#define FONT_COMPRESSED                 0x0800
#define FONT_CONVERTED                  0x1000

#define OUTLINE_CORRECT_ORIENTATION     0x4000
#define SFNT_MAGIC 0x5F0F3CF5

#define SHORT_INDEX_TO_LOC_FORMAT       0
#define LONG_INDEX_TO_LOC_FORMAT        1
#define GLYPH_DATA_FORMAT               0

typedef struct {
	Fixed       version;            /* for this table, set to 1.0 */
	Fixed       fontRevision;       /* For Font Manufacturer */
	uint32      checkSumAdjustment;
	uint32      magicNumber;        /* signature, should always be 0x5F0F3CF5  == MAGIC */
	uint16      flags;
	uint16      unitsPerEm;         /* Specifies how many in Font Units we have per EM */

	BigDate     created;
	BigDate     modified;

	/** This is the font wide bounding box in ideal space
 (baselines and metrics are NOT worked into these numbers) **/
	FUnit       xMin;
	FUnit       yMin;
	FUnit       xMax;
	FUnit       yMax;

	uint16      macStyle;               /* macintosh style word */
	uint16      lowestRecPPEM;          /* lowest recommended pixels per Em */

	/* 0: fully mixed directional glyphs, 1: only strongly L->R or T->B glyphs, 
	   -1: only strongly R->L or B->T glyphs, 2: like 1 but also contains neutrals,
	   -2: like -1 but also contains neutrals */
	int16       fontDirectionHint;

	int16       indexToLocFormat;
	int16       glyphDataFormat;
} sfnt_FontHeader;

typedef struct {
	Fixed       version;                /* for this table, set to 1.0 */

	FUnit       yAscender;
	FUnit       yDescender;
	FUnit       yLineGap;       /* Recommended linespacing = ascender - descender + linegap */
	uFUnit      advanceWidthMax;
	FUnit       minLeftSideBearing;
	FUnit       minRightSideBearing;
	FUnit       xMaxExtent; /* Max of (LSBi + (XMAXi - XMINi)), i loops through all glyphs */

	int16       horizontalCaretSlopeNumerator;
	int16       horizontalCaretSlopeDenominator;

	uint16      reserved0;
	uint16      reserved1;
	uint16      reserved2;
	uint16      reserved3;
	uint16      reserved4;

	int16       metricDataFormat;           /* set to 0 for current format */
	uint16      numberOf_LongHorMetrics;    /* if format == 0 */
} sfnt_HorizontalHeader;

typedef struct {
	uint16      advanceWidth;
	int16       leftSideBearing;
} sfnt_HorizontalMetrics;

typedef struct {
	uint16      advanceHeight;
	int16       topSideBearing;
} sfnt_VerticalMetrics;

/*
 *  CVT is just a bunch of int16s
 */
typedef int16 sfnt_ControlValue;

/*
 *  Char2Index structures, including platform IDs
 */
typedef struct {
	uint16  format;
	uint16  length;
	uint16  version;
} sfnt_mappingTable;

typedef struct {
	uint16  platformID;
	uint16  specificID;
	uint32  offset;
} sfnt_platformEntry;

typedef struct {
	uint16  version;
	uint16  numTables;
	sfnt_platformEntry platform[1]; /* platform[numTables] */
} sfnt_char2IndexDirectory;
#define SIZEOFCHAR2INDEXDIR     4

typedef struct {
  uint16  firstCode;
  uint16  entryCount;
  int16   idDelta;
  uint16  idRangeOffset;
} sfnt_subHeader2;

typedef struct {
  uint16            subHeadersKeys [256];
  sfnt_subHeader2   subHeaders [1];
} sfnt_mappingTable2;

typedef struct {
  uint16  segCountX2;
  uint16  searchRange;
  uint16  entrySelector;
  uint16  rangeShift;
  uint16  endCount[1];
} sfnt_mappingTable4;

typedef struct {
  uint16  firstCode;
  uint16  entryCount;
  uint16  glyphIdArray [1];
} sfnt_mappingTable6;

typedef struct {
	uint16 platformID;
	uint16 specificID;
	uint16 languageID;
	uint16 nameID;
	uint16 length;
	uint16 offset;
} sfnt_NameRecord;

typedef struct {
	uint16 format;
	uint16 count;
	uint16 stringOffset;
/*  sfnt_NameRecord[count]  */
} sfnt_NamingTable;

typedef struct {
	Fixed       version;                /* for this table, set to 1.0 */
	uint16      numGlyphs;
	uint16      maxPoints;              /* in an individual glyph */
	uint16      maxContours;            /* in an individual glyph */
	uint16      maxCompositePoints;     /* in an composite glyph */
	uint16      maxCompositeContours;   /* in an composite glyph */
	uint16      maxElements;            /* set to 2, or 1 if no twilightzone points */
	uint16      maxTwilightPoints;      /* max points in element zero */
	uint16      maxStorage;             /* max number of storage locations */
	uint16      maxFunctionDefs;        /* max number of FDEFs in any preprogram */
	uint16      maxInstructionDefs;     /* max number of IDEFs in any preprogram */
	uint16      maxStackElements;       /* max number of stack elements for any individual glyph */
	uint16      maxSizeOfInstructions;  /* max size in bytes for any individual glyph */
	uint16      maxComponentElements;   /* number of glyphs referenced at top level */
	uint16      maxComponentDepth;      /* levels of recursion, 1 for simple components */
} sfnt_maxProfileTable;

typedef struct {
  int16       numberOfContours;
  BBOX        bbox;
  int16       endPoints[1];
} sfnt_PackedSplineFormat;

#define DEVEXTRA    2   /* size + max */
/*
 *  Each record is n+2 bytes, padded to long word alignment.
 *  First byte is ppem, second is maxWidth, rest are widths for each glyph
 */
typedef struct {
	int16               version;
	int16               numRecords;
	int32               recordSize;
	/* Byte widths[numGlyphs+2] * numRecords */
} sfnt_DeviceMetrics;

#ifdef UNNAMED_UNION        /* Anonymous unions are supported */
#define postScriptNameIndices   /* by some C implementations,  */
#endif              /* but they are not portable. */

typedef struct {
	Fixed   version;                /* 1.0 */
	Fixed   italicAngle;
	FUnit   underlinePosition;
	FUnit   underlineThickness;
	uint32  isFixedPitch;
	uint32  minMemType42;
	uint32  maxMemType42;
	uint32  minMemType1;
	uint32  maxMemType1;

	uint16  numberGlyphs;
	union
	{
	  uint16  glyphNameIndex[1];   /* version == 2.0 */
	  int8    glyphNameIndex25[1]; /* version == 2.5 */
	} postScriptNameIndices;
} sfnt_PostScriptInfo;

#ifdef postScriptNameIndices
#undef postScriptNameIndices
#endif 

typedef struct {
	uint16  Version;
	int16   xAvgCharWidth;
	uint16  usWeightClass;
	uint16  usWidthClass;
	int16   fsType;
	int16   ySubscriptXSize;
	int16   ySubscriptYSize;
	int16   ySubscriptXOffset;
	int16   ySubscriptYOffset;
	int16   ySuperScriptXSize;
	int16   ySuperScriptYSize;
	int16   ySuperScriptXOffset;
	int16   ySuperScriptYOffset;
	int16   yStrikeOutSize;
	int16   yStrikeOutPosition;
	int16   sFamilyClass;
	uint8   Panose [10];
	uint32  ulCharRange [4];
	char    achVendID [4];
	uint16  usSelection;
	uint16  usFirstChar;
	uint16  usLastChar;
	int16   sTypoAscender;
	 int16  sTypoDescender;
	int16   sTypoLineGap;
	int16   sWinAscent;
	int16   sWinDescent;
	uint32  ulCodePageRange[2];
} sfnt_OS2;

typedef struct
{
	uint8   bEmY;
	uint8   bEmX;
	uint8   abInc[1];
} sfnt_hdmxRecord;

typedef struct
{
	uint16          Version;
	int16           sNumRecords;
	int32           lSizeRecord;
	sfnt_hdmxRecord HdmxTable;
} sfnt_hdmx;

typedef struct
{
	uint16    Version;
	uint16    usNumGlyphs;
	uint8     ubyPelsHeight;
} sfnt_LTSH;

typedef struct
{
	uint16          rangeMaxPPEM;
	uint16          rangeGaspBehavior;
} sfnt_gaspRange;

typedef struct
{
	uint16          version;
	uint16          numRanges;
	sfnt_gaspRange  gaspRange[1];
} sfnt_gasp;

/* various typedef to access to the sfnt data */

typedef sfnt_OffsetTable          *sfnt_OffsetTablePtr;
typedef sfnt_FontHeader           *sfnt_FontHeaderPtr;
typedef sfnt_HorizontalHeader     *sfnt_HorizontalHeaderPtr;
typedef sfnt_maxProfileTable      *sfnt_maxProfileTablePtr;
typedef sfnt_ControlValue         *sfnt_ControlValuePtr;
typedef sfnt_char2IndexDirectory  *sfnt_char2IndexDirectoryPtr;
typedef sfnt_HorizontalMetrics    *sfnt_HorizontalMetricsPtr;
typedef sfnt_VerticalMetrics      *sfnt_VerticalMetricsPtr;
typedef sfnt_platformEntry        *sfnt_platformEntryPtr;
typedef sfnt_NamingTable          *sfnt_NamingTablePtr;
typedef sfnt_OS2                  *sfnt_OS2Ptr;
typedef sfnt_DirectoryEntry       *sfnt_DirectoryEntryPtr;
typedef sfnt_PostScriptInfo       *sfnt_PostScriptInfoPtr;
typedef sfnt_gasp                 *sfnt_gaspPtr;

/*
 * 'gasp' Table Constants
*/

#define GASP_GRIDFIT    0x0001
#define GASP_DOGRAY     0x0002


/*
 * UNPACKING Constants
*/
/*define ONCURVE                 0x01   defined in FSCDEFS.H    */
#define XSHORT              0x02
#define YSHORT              0x04
#define REPEAT_FLAGS        0x08 /* repeat flag n times */
/* IF XSHORT */
#define SHORT_X_IS_POS      0x10 /* the short vector is positive */
/* ELSE */
#define NEXT_X_IS_ZERO      0x10 /* the relative x coordinate is zero */
/* ENDIF */
/* IF YSHORT */
#define SHORT_Y_IS_POS      0x20 /* the short vector is positive */
/* ELSE */
#define NEXT_Y_IS_ZERO      0x20 /* the relative y coordinate is zero */
/* ENDIF */
/* 0x40 & 0x80              RESERVED
** Set to Zero
**
*/

/*
 * Composite glyph constants
 */
#define COMPONENTCTRCOUNT           -1      /* ctrCount == -1 for composite */
#define ARG_1_AND_2_ARE_WORDS       0x0001  /* if set args are words otherwise they are bytes */
#define ARGS_ARE_XY_VALUES          0x0002  /* if set args are xy values, otherwise they are points */
#define ROUND_XY_TO_GRID            0x0004  /* for the xy values if above is true */
#define WE_HAVE_A_SCALE             0x0008  /* Sx = Sy, otherwise scale == 1.0 */
#define NON_OVERLAPPING             0x0010  /* set to same value for all components */
#define MORE_COMPONENTS             0x0020  /* indicates at least one more glyph after this one */
#define WE_HAVE_AN_X_AND_Y_SCALE    0x0040  /* Sx, Sy */
#define WE_HAVE_A_TWO_BY_TWO        0x0080  /* t00, t01, t10, t11 */
#define WE_HAVE_INSTRUCTIONS        0x0100  /* instructions follow */
#define USE_MY_METRICS              0x0200  /* apply these metrics to parent glyph */
#define OVERLAP_COMPOUND			0x0400  /* used by Apple in GX fonts */
#define SCALED_COMPONENT_OFFSET     0x0800  /* composite designed to have the component offset scaled (designed for Apple) */
#define UNSCALED_COMPONENT_OFFSET   0x1000  /* composite designed not to have the component offset scaled (designed for MS) */

/*
 *  Private enums for tables used by the scaler.  See sfnt_Classify
 */
typedef enum {
	sfnt_fontHeader,
	sfnt_horiHeader,
	sfnt_indexToLoc,
	sfnt_maxProfile,
	sfnt_controlValue,
	sfnt_preProgram,
	sfnt_glyphData,
	sfnt_horizontalMetrics,
	sfnt_charToIndexMap,
	sfnt_fontProgram,
	sfnt_Postscript,
	sfnt_HoriDeviceMetrics,
	sfnt_LinearThreshold,
	sfnt_Names,
	sfnt_OS_2,
	sfnt_GlyphDirectory,
	sfnt_BitmapData,
	sfnt_BitmapLocation,
	sfnt_BitmapScale,
	sfnt_vertHeader,
	sfnt_verticalMetrics,
	sfnt_BeginningOfFont,       /* References the beginning of memory   */
	sfnt_NUMTABLEINDEX
} sfnt_tableIndex;

#endif
#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scspline.h ===
/*********************************************************************

	  scspline.h -- Spline Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   3/19/93 deanb    size_t replaced with int32
	  10/28/92 deanb    reentrant params renamed, mem req redone
	  10/09/92 deanb    PSTATE added
	   9/25/92 deanb    include scan control type 
	   9/09/92 deanb    GetSplineElemSize returns size_t 
	   9/08/92 deanb    MAXSPLINELENGTH added 
	   8/17/92 deanb    PowerOf2 moved to math 
	   7/23/92 deanb    EvaluateSpline replaced with CalcSpline + PowerOf2 
	   4/09/92 deanb    New types again 
	   3/16/92 deanb    New types 
	   1/14/92 deanb    First cut 

*********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupSpline ( PSTATE0 );

FS_PUBLIC int32 fsc_CalcSpline( 
		PSTATE          /* pointer to state varables */
		F26Dot6,        /* start point x coordinate */
		F26Dot6,        /* start point y coordinate */
		F26Dot6,        /* control point x coordinate */
		F26Dot6,        /* control point y coordinate */
		F26Dot6,        /* ending x coordinate */
		F26Dot6,        /* ending y coordinate */
		uint16          /* scan control type */
);

/********************************************************************/

/*              Export Definitions                                  */

/********************************************************************/

#define MAXSPLINELENGTH     3200        /* calculation overflow limit */

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\sfntaccs.c ===
/*
	File:       sfnt.c

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

   Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
			   (c) 1989-1997. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

		<>       02/21/97   CB      ClaudeBe, scaled component in composite glyphs
		<>       12/14/95   CB      add advance height to sfac_ReadGlyphMetrics
	   <17+>     10/9/90    MR,rb   Remove classification of unused tables in sfnt_Classify
		<17>     8/10/90    MR      Pass nil for textLength parameter to MapString2, checked in
									other files to their precious little system will BUILD.  Talk
									about touchy!
		<16>     8/10/90    gbm     rolling out Mike's textLength change, because he hasn't checked
									in all the relevant files, and the build is BROKEN!
		<15>     8/10/90    MR      Add textLength arg to MapString2
		<14>     7/26/90    MR      don't include toolutil.h
		<13>     7/23/90    MR      Change computeindex routines to call functins in MapString.c
		<12>     7/18/90    MR      Add SWAPW macro for INTEL
		<11>     7/13/90    MR      Lots of Ansi-C stuff, change behavior of ComputeMapping to take
									platform and script
		 <9>     6/27/90    MR      Changes for modified format 4: range is now times two, loose pad
									word between first two arrays.  Eric Mader
		 <8>     6/21/90    MR      Add calls to ReleaseSfntFrag
		 <7>      6/5/90    MR      remove vector mapping functions
		 <6>      6/4/90    MR      Remove MVT
		 <5>      5/3/90    RB      simplified decryption.
		 <4>     4/10/90    CL      Fixed mapping table routines for double byte codes.
		 <3>     3/20/90    CL      Joe found bug in mappingtable format 6 Added vector mapping
									functions use pointer-loops in sfnt_UnfoldCurve, changed z from
									int32 to int16
		 <2>     2/27/90    CL      New error code for missing but needed table. (0x1409)  New
									CharToIndexMap Table format.
									Assume subtablenumber zero for old sfnt format.  Fixed
									transformed component bug.
	   <3.2>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Instructions are legal in components. Glyph-length 0
									bug in sfnt.c is fixed. Now it is legal to pass in zero as the
									address of memory when a piece of the sfnt is requested by the
									scaler. If this happens the scaler will simply exit with an
									error code ! Fixed bug with instructions in components.
	   <3.1>     9/27/89    CEL     Removed phantom points.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <y1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
		<3+>     3/20/90    mrr     Fixed mapping table routines for double byte codes.
									Added support for font program.
									Changed count from uint16 to int16 in vector char2index routines.
*/

#define FSCFG_INTERNAL

/** FontScaler's Includes **/

#include "fserror.h"
#include "fscdefs.h"
#include "sfntaccs.h"
#include "sfntoff.h"
/*#include "MapString.h" */

#include "stat.h"                   /* STAT timing card prototypes */

/*  CONSTANTS   */

#define MISSING_GLYPH_INDEX     0
#define MAX_FORMAT0_CHAR_INDEX  256
#define MAX_LINEAR_X2           16
static  const   transMatrix   IdentTransform =
   {{{ONEFIX,      0,      0},
	 {     0, ONEFIX,      0},
	 {     0,      0, ONEFIX}}};

/*  MACROS  */
#define MAX(a, b)   (((a) > (b)) ? (a) : (b))

#define GETSFNTFRAG(ClientInfo,lOffset,lLength) (ClientInfo)->GetSfntFragmentPtr(ClientInfo->lClientID, lOffset, lLength)
#define RELEASESFNTFRAG(ClientInfo,data)        (ClientInfo)->ReleaseSfntFrag((voidPtr)data)

#define SFAC_BINARYITERATION \
	  newP = (uint16 *) ((char *)tableP + (usSearchRange >>= 1)); \
		if (charCode > (uint16) SWAPW (*newP)) tableP = newP;

#define SFAC_GETUNSIGNEDBYTEINC( p ) ((uint8)(*p++))

/* PRIVATE PROTOTYES */

FS_PRIVATE void sfac_Classify (
	 sfac_OffsetLength * TableDirectory,
	 uint8 *                    dir);

FS_PRIVATE uint16 sfac_ComputeUnkownIndex (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex0 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex2 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex4 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex6 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);

FS_PRIVATE ErrorCode sfac_GetGlyphLocation (
	sfac_ClientRec *    ClientInfo,
	uint16              gIndex,
	uint32 *            ulOffset,
	uint32 *            ulLength,
	sfnt_tableIndex*  pGlyphTableIndex);

FS_PRIVATE ErrorCode    sfac_GetDataPtr (
	sfac_ClientRec *    ClientInfo,
	uint32              ulOffset,
	uint32              ulLength,
	sfnt_tableIndex     TableRef,
	boolean             bMustHaveTable,
    const void * *     ppvTablePtr);

FS_PRIVATE ErrorCode sfac_GetGlyphIDs (
   	MappingFunc			pfnGlyphMapping,		/* mapping func char to glyph	*/
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usCharCode,         /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID);        /* Output glyph ID array        */

FS_PRIVATE ErrorCode sfac_GetLongGlyphIDs (
    MappingFunc         pfnGlyphMapping,    /* mapping func char to glyph   */
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
    sfac_ClientRec *    ClientInfo,         /* May be NULL!                 */
    uint16              numGlyphs,          /* maxp->numGlyphs              */
    uint16              usCharCount,        /* Number of chars to convert   */
    uint16              usCharCode,         /* First char code              */
    uint32              ulCharCodeOffset,   /* Offset to be added to *pulCharCode
                                               before converting            */
    uint32 *            pulCharCode,        /* Pointer to char code list    */
    uint32 *            pulGlyphID);         /* Output glyph ID array        */

FS_PRIVATE void	sfac_ComputeBinarySearchParams(
	uint16		usSegCount, 		/* INPUT */
	uint16 *	pusSearchRange,		/* OUTPUT */
	uint16 *	pusEntrySelector,	/* OUTPUT */
	uint16 *	pusRangeShift);		/* OUTPUT */

FS_PRIVATE ErrorCode sfac_ReadGlyphBbox(
	sfac_ClientRec *    ClientInfo,         /* Client Information           */
	uint16              usGlyphIndex,       /* Glyph index to read          */
	BBOX *              pbbox);             /* Glyph Bounding box           */

/*
 * Internal routine (make this an array and do a look up?)
 */
FS_PRIVATE void sfac_Classify (
	 sfac_OffsetLength * TableDirectory,
	 uint8 *                    dir)
{
	int32 Index;

	switch ((uint32)SWAPL(*((sfnt_TableTag *)&dir[SFNT_DIRECTORYENTRY_TAG])))
	{
		case tag_FontHeader:
			Index = (int32)sfnt_fontHeader;
			break;
		case tag_HoriHeader:
			Index = (int32)sfnt_horiHeader;
			break;
		case tag_IndexToLoc:
			Index = (int32)sfnt_indexToLoc;
			break;
		case tag_MaxProfile:
			Index = (int32)sfnt_maxProfile;
			break;
		case tag_ControlValue:
			Index = (int32)sfnt_controlValue;
			break;
		case tag_PreProgram:
			Index = (int32)sfnt_preProgram;
			break;
		case tag_GlyphData:
			Index = (int32)sfnt_glyphData;
			break;
		case tag_HorizontalMetrics:
			Index = (int32)sfnt_horizontalMetrics;
			break;
		case tag_CharToIndexMap:
			Index = (int32)sfnt_charToIndexMap;
			break;
		case tag_FontProgram:
			Index = (int32)sfnt_fontProgram;   /* <4> */
			break;
		case tag_GlyphDirectory:         /* Used for GlyphDirectory Download */
			Index = (int32)sfnt_GlyphDirectory;
			break;
		case tag_HoriDeviceMetrics:
			Index = (int32)sfnt_HoriDeviceMetrics;
			break;
		case tag_LinearThreshold:
			Index = (int32)sfnt_LinearThreshold;
			break;
		case tag_BitmapData:
			Index = (int32)sfnt_BitmapData;
			break;
		case tag_BitmapLocation:
			Index = (int32)sfnt_BitmapLocation;
			break;
		case tag_BitmapScale:
			Index = (int32)sfnt_BitmapScale;
			break;
		case tag_VertHeader:
			Index = (int32)sfnt_vertHeader;
			break;
		case tag_VerticalMetrics:
			Index = (int32)sfnt_verticalMetrics;
			break;
		case tag_OS_2:
			Index = (int32)sfnt_OS_2;
			break;
		default:
			Index = -1;
			break;
	}
	if (Index >= 0)
	{
		  TableDirectory[Index].ulOffset = (uint32) SWAPL (*((uint32 *)&dir[SFNT_DIRECTORYENTRY_TABLEOFFSET]));
		  TableDirectory[Index].ulLength = (uint32) SWAPL (*((uint32 *)&dir[SFNT_DIRECTORYENTRY_TABLELENGTH]));
	}
}


/*
 * Creates mapping for finding offset table     <4>
 */

FS_PUBLIC ErrorCode sfac_DoOffsetTableMap (
	sfac_ClientRec *  ClientInfo)    /* Sfnt Client information */

{
	int32        i;
	uint8 *      sfntDirectory;
	int32        cTables;
	uint8 *      dir;

	STAT_OFF_CALLBACK;                  /* pause STAT timer */

	sfntDirectory = (uint8 *) GETSFNTFRAG (ClientInfo, 0L, (int32)SIZEOF_SFNT_OFFSETTABLE);

	STAT_ON_CALLBACK;                /* restart STAT timer */

	if (sfntDirectory != NULL)
	{
		cTables = (int32) SWAPW (*((uint16 *)&sfntDirectory[SFNT_OFFSETTABLE_NUMOFFSETS]));
		RELEASESFNTFRAG(ClientInfo, sfntDirectory);

		STAT_OFF_CALLBACK;               /* pause STAT timer */

		sfntDirectory = (uint8 *) GETSFNTFRAG (
			ClientInfo,
			0L,
			((int32)SIZEOF_SFNT_OFFSETTABLE + (int32)SIZEOF_SFNT_DIRECTORYENTRY * (int32)(cTables)));

		STAT_ON_CALLBACK;             /* restart STAT timer */


		if (sfntDirectory == NULL)
		{
			return(CLIENT_RETURNED_NULL);
		}
	}
	else
	{
		return(NULL_SFNT_DIR_ERR);
	}

	/* Initialize */

	MEMSET (ClientInfo->TableDirectory, 0, sizeof (ClientInfo->TableDirectory));

	dir = &sfntDirectory[SFNT_OFFSETTABLE_TABLE];

	for (i = 0; i < cTables; i++)
	{
		sfac_Classify (ClientInfo->TableDirectory, dir);
		dir += SIZEOF_SFNT_DIRECTORYENTRY;
	}

	/* Used when glyphs are accessed from the base of memory */

	ClientInfo->TableDirectory[(int32)sfnt_BeginningOfFont].ulOffset = 0U;
	ClientInfo->TableDirectory[(int32)sfnt_BeginningOfFont].ulLength = ~0U;

	RELEASESFNTFRAG(ClientInfo, sfntDirectory);

	return NO_ERR;
}

/*
 * Use this function when only part of the table is needed.
 *
 * n is the table number.
 * offset is within table.
 * length is length of data needed.
 * To get an entire table, pass length = ULONG_MAX     <4>
 */

FS_PRIVATE ErrorCode sfac_GetDataPtr (
	sfac_ClientRec *    ClientInfo,
	uint32              ulOffset,
	uint32              ulLength,
	sfnt_tableIndex     TableRef,
	boolean             bMustHaveTable,
	const void **       ppvTablePtr)
{
	uint32      ulTableLength;

	ulTableLength = SFAC_LENGTH(ClientInfo, TableRef);

	if (ulTableLength > 0)
	{
		if(ulLength == ULONG_MAX)
		{
			ulLength = ulTableLength;
		}

		STAT_OFF_CALLBACK;               /* pause STAT timer */

		*ppvTablePtr = (void *)GETSFNTFRAG (
			ClientInfo,
			(int32)(ulOffset + ClientInfo->TableDirectory[(int32)TableRef].ulOffset),
			(int32)ulLength);

		STAT_ON_CALLBACK;             /* restart STAT timer */

		if (*ppvTablePtr == NULL)
		{
			return CLIENT_RETURNED_NULL; /* Do a gracefull recovery   */
		}
	}
	else
	{
		*ppvTablePtr = (void *)NULL;

		if (bMustHaveTable)
		{
			return MISSING_SFNT_TABLE; /* Do a gracefull recovery  */
		}
	}

	return NO_ERR;
}


/*
 * This, is when we don't know what is going on
 */

FS_PRIVATE uint16 sfac_ComputeUnkownIndex (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	FS_UNUSED_PARAMETER(mapping);
	FS_UNUSED_PARAMETER(charCode);
	FS_UNUSED_PARAMETER(ClientInfo);
	return MISSING_GLYPH_INDEX;
}


/*
 * Byte Table Mapping 256->256          <4>
 */
FS_PRIVATE uint16 sfac_ComputeIndex0 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	FS_UNUSED_PARAMETER(ClientInfo);
	if (charCode < MAX_FORMAT0_CHAR_INDEX)
	{
		return (uint16)mapping[charCode];
	}
	else
	{
		return MISSING_GLYPH_INDEX;
	}
}

/*
 * High byte mapping through table
 *
 * Useful for the national standards for Japanese, Chinese, and Korean characters.
 *
 * Dedicated in spirit and logic to Mark Davis and the International group.
 *
 *  Algorithm: (I think)
 *      First byte indexes into KeyOffset table.  If the offset is 0, keep going, else use second byte.
 *      That offset is from beginning of data into subHeader, which has 4 words per entry.
 *          entry, extent, delta, range
 *
 */

FS_PRIVATE uint16 sfac_ComputeIndex2 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	uint16          usIndex;
	uint16          usMapMe;
	uint16          usHighByte;
	uint16          usGlyph;
	const uint8 *   Table2;
	const uint8 *   subHeader;

	FS_UNUSED_PARAMETER(ClientInfo);
	Table2 = (const uint8 *) mapping;

	usHighByte = (uint16)(charCode >> 8);

	if (((uint16 *)&Table2[SFNT_MAPPINGTABLE2_SUBHEADERSKEYS]) [usHighByte])
	{
		usMapMe = (uint16)(charCode & 0xFF); /* We also need the low byte. */
	}
	else
	{
#ifdef  FSCFG_MICROSOFT_KK
		if(usHighByte != 0)
		{
			usMapMe = usHighByte;
		}
		else
		{
				usMapMe = (uint16)(charCode & 0xFF);
		}
#else
		usMapMe = usHighByte;
#endif
	}

	subHeader = (const uint8 *) ((char *)&Table2[SFNT_MAPPINGTABLE2_SUBHEADERS] +
		(uint16)SWAPW (((uint16 *)&Table2[SFNT_MAPPINGTABLE2_SUBHEADERSKEYS]) [usHighByte]));

	usMapMe -= (uint16)SWAPW (*((uint16 *)&subHeader[SFNT_SUBHEADER2_FIRSTCODE]));    /* Subtract first code. */

	if (usMapMe < (uint16)SWAPW (*((uint16 *)&subHeader[SFNT_SUBHEADER2_ENTRYCOUNT])))
	{  /* See if within range. */

		usGlyph = (uint16)(* ((uint16 *) ((char *) &subHeader[SFNT_SUBHEADER2_IDRANGEOFFSET] +
			(uint16)SWAPW (*((uint16 *)&subHeader[SFNT_SUBHEADER2_IDRANGEOFFSET]))) + usMapMe));

		if (usGlyph != 0) /* Note: usGlyph has not been swapped yet */
		{
			usIndex = (uint16)((int32)(uint32)(uint16)SWAPW(usGlyph) + (int32)SWAPW (*((int16 *)&subHeader[SFNT_SUBHEADER2_IDDELTA])));
		}
		else
		{
			usIndex = MISSING_GLYPH_INDEX;
		}
	}
	else
	{
		usIndex = MISSING_GLYPH_INDEX;
	}

	return usIndex;
}

/*
 * Segment mapping to delta values, Yack.. !
 *
 * In memory of Peter Edberg. Initial code taken from code example supplied by Peter.
 */
FS_PRIVATE uint16 sfac_ComputeIndex4 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	const uint16 *  tableP;
	const uint8 *   Table4;
	uint16          usIdDelta;
	uint16          usOffset;
	uint16          usIndex;
	uint16          usSegCountX2;
	uint16			usSearchRange;
	uint16			usEntrySelector;
	uint16			usRangeShift;
	const uint16 *  newP;    /* temporary pointer for binary iteration   */
	uint16          usStartCount;

	Table4 = (const uint8 *)mapping;

	usSegCountX2 = (uint16) SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_SEGCOUNTX2]));
	tableP = (const uint16 *)&Table4[SFNT_MAPPINGTABLE4_ENDCOUNT];

	/* If there are just a few segments, skip straight to the linear search */

	if (usSegCountX2 >= MAX_LINEAR_X2 && charCode > 0xFF)
	{
		/* start with unrolled binary search */

		/* tableP points at endCount[] */
		if( ClientInfo == NULL )
		{
			sfac_ComputeBinarySearchParams(
				(uint16)(usSegCountX2 / 2),
				&usSearchRange,
				&usEntrySelector,
				&usRangeShift);
		}
		else
		{
			usSearchRange = ClientInfo->usFormat4SearchRange;

			/* Assert(SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_RANGESHIFT])) == ClientInfo->usFormat4RangeShift); */
			usRangeShift = ClientInfo->usFormat4RangeShift;

			/* Assert((uint16)SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_ENTRYSELECTOR])) == ClientInfo->usFormat4EntrySelector); */
			usEntrySelector = ClientInfo->usFormat4EntrySelector;
		}

		if (charCode >= (uint16) SWAPW (* ((uint16 *) ((char *)tableP + usSearchRange))))
		{
			tableP = (uint16 *) ((char *)tableP + usRangeShift); /* range to low shift it up */
		}


		switch( usEntrySelector )
		{
		case 15:
			SFAC_BINARYITERATION;
			/* fall through */
		case 14:
			SFAC_BINARYITERATION;
			/* fall through */
		case 13:
			SFAC_BINARYITERATION;
			/* fall through */
		case 12:
			SFAC_BINARYITERATION;
			/* fall through */
		case 11:
			SFAC_BINARYITERATION;
			/* fall through */
		case 10:
			SFAC_BINARYITERATION;
			/* fall through */
		case 9:
			SFAC_BINARYITERATION;
			/* fall through */
		case 8:
			SFAC_BINARYITERATION;
			/* fall through */
		case 7:
			SFAC_BINARYITERATION;
			/* fall through */
		case 6:
			SFAC_BINARYITERATION;
			/* fall through */
		case 5:
			SFAC_BINARYITERATION;
			/* fall through */
		case 4:
			SFAC_BINARYITERATION;
			/* fall through */
		case 3:
		case 2:   /* drop through */
		case 1:
		case 0:
			break;
		default:
			Assert(FALSE);
			break;
		}
	}

	/*  Now do linear search */

	while(charCode > (uint16) SWAPW(*tableP))
	{
		tableP++;
	}

	tableP++;                  /*  Skip Past reservedPad word    */

	/* End of search, now do mapping */

	tableP = (uint16 *) ((char *)tableP + usSegCountX2); /* point at startCount[] */
	usStartCount = (uint16) SWAPW (*tableP);

	if (charCode >= usStartCount)
	{
		  usOffset = (uint16)(charCode - (uint16) SWAPW (*tableP));
		tableP = (uint16 *) ((char *)tableP + usSegCountX2); /* point to idDelta[] */
		usIdDelta = (uint16) SWAPW (*tableP);
		tableP = (uint16 *) ((char *)tableP + usSegCountX2); /* point to idRangeOffset[] */

		if ((uint16) SWAPW (*tableP) == 0)
		{
				usIndex   = (uint16)(charCode + usIdDelta);
		}
		else
		{
			/* Use glyphIdArray to access index */

			usOffset += usOffset; /* make word offset */
			tableP   = (uint16 *) ((char *)tableP + (uint16) SWAPW (*tableP) + usOffset); /* point to glyphIndexArray[] */

			if((uint16)SWAPW (*tableP) != MISSING_GLYPH_INDEX)
			{
					 usIndex    = (uint16)((uint16) SWAPW (*tableP) + usIdDelta);
			}
			else
			{
				usIndex = MISSING_GLYPH_INDEX;
			}
		}
	}
	else
	{
		usIndex = MISSING_GLYPH_INDEX;
	}

	return usIndex;
}


/*
 * Trimmed Table Mapping
 */

FS_PRIVATE uint16 sfac_ComputeIndex6 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	const uint8 *Table6;

	FS_UNUSED_PARAMETER(ClientInfo);

	Table6 = (const uint8 *) mapping;

	charCode  -= (uint16)SWAPW (*((uint16 *)&Table6[SFNT_MAPPINGTABLE6_FIRSTCODE]));

	if (charCode < (uint16) SWAPW (*((uint16 *)&Table6[SFNT_MAPPINGTABLE6_ENTRYCOUNT])))
	{
		return ((uint16) SWAPW (((uint16 *)&Table6[SFNT_MAPPINGTABLE6_GLYPHIDARRAY]) [charCode]));
	}
	else
	{
		return   MISSING_GLYPH_INDEX;
	}
}


/*
 * Sets up our mapping function pointer.
 */

FS_PUBLIC ErrorCode sfac_ComputeMapping (
	sfac_ClientRec *  ClientInfo,
	uint16            usPlatformID,
	uint16            usSpecificID)

{
	const uint8 *   table;
	const uint8 *   MappingTable;
	const uint8 *   Table4;
	boolean         bFound;
	ErrorCode       Ret;
	const uint8 *	plat;
	uint16			usSegCountX2;

	bFound = FALSE;

	/* the following code allow a client that is only interested by glyph indices to
               call fs_NewSfnt with -1 for PlatformID and SpecificID */
	if(usPlatformID == 0xFFFF)
	{
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		return NO_ERR;
	}


	Ret = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, FALSE, (const void **)&table);

	if(Ret != NO_ERR)
	{
		return Ret;
	}


	if (table == NULL)
	{
		/* If no "cmap" is present, permits access to characters by glyph index */

		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		return NO_ERR;
	}

	/* APPLE Code
	if(*((uint16 *)&table[SFNT_CHAR2INDEXDIRECTORY_VERSION]) != 0)
	{
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		RELEASESFNTFRAG(ClientInfo, table);
		return OUT_OF_RANGE_SUBTABLE;
	}
	*/

	/* mapping */

	plat = (uint8 *) &table[SFNT_CHAR2INDEXDIRECTORY_PLATFORM]; /* <4> */

	while(plat < (uint8 *)&table[SFNT_CHAR2INDEXDIRECTORY_PLATFORM + ((uint16)SWAPW(*((uint16 *)&table[SFNT_CHAR2INDEXDIRECTORY_NUMTABLES])) *
		  SIZEOF_SFNT_PLATFORMENTRY)] && !bFound)
	{
		if (((uint16)SWAPW(*((uint16 *)&plat[SFNT_PLATFORMENTRY_PLATFORMID])) == usPlatformID) &&
			((uint16)SWAPW(*((uint16 *)&plat[SFNT_PLATFORMENTRY_SPECIFICID])) == usSpecificID))
		{
			bFound = TRUE;
			ClientInfo->ulMapOffset = (uint32) SWAPL (*((uint32 *)&plat[SFNT_PLATFORMENTRY_PLATFORMOFFSET]));   /* skip header */
		}
		plat += SIZEOF_SFNT_PLATFORMENTRY;
	}


	if (!bFound)
	{
		ClientInfo->ulMapOffset = 0;
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		RELEASESFNTFRAG(ClientInfo, table);
		return OUT_OF_RANGE_SUBTABLE;
	}
	else
	{
		Assert(Ret == NO_ERR);
		MappingTable = (uint8 *)((uint8 *)table + ClientInfo->ulMapOffset);  /* back up for header */
		ClientInfo->ulMapOffset += (uint32)SIZEOF_SFNT_MAPPINGTABLE;
	}

    ClientInfo->usMappingFormat = (uint16)SWAPW (*((uint16 *)&MappingTable[SFNT_MAPPINGTABLE_FORMAT]));

	switch (ClientInfo->usMappingFormat)
	{
	case 0:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex0;
		break;
	case 2:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex2;
		break;
	case 4:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex4;

		/* Pre-compute several values used for Index 4 lookups */
		/* This becomes necessary because of several font vendors who */
		/* have placed incorrect values in the TrueType font file. */

		Table4 = (uint8 *)((uint8 *)table + ClientInfo->ulMapOffset);
		usSegCountX2 = (uint16) SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_SEGCOUNTX2]));

		sfac_ComputeBinarySearchParams(
			(uint16)(usSegCountX2 / 2),
			&ClientInfo->usFormat4SearchRange,
			&ClientInfo->usFormat4EntrySelector,
			&ClientInfo->usFormat4RangeShift);

		break;
	case 6:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex6;
		break;
	default:
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		Ret = UNKNOWN_CMAP_FORMAT;
		break;
	}
	RELEASESFNTFRAG(ClientInfo, table);

	return Ret;
}

FS_PRIVATE void	sfac_ComputeBinarySearchParams(
	uint16		usSegCount, 		/* INPUT */
	uint16 *	pusSearchRange,		/* OUTPUT */
	uint16 *	pusEntrySelector,	/* OUTPUT */
	uint16 *	pusRangeShift)		/* OUTPUT */
{
	uint16			usLog;
	uint16			usPowerOf2;

	usLog = 0;
	usPowerOf2 = 1;

	while((2 * usPowerOf2) <= usSegCount )
	{
		usPowerOf2 *= 2;
		usLog++;
	}

	*pusSearchRange = 2 * usPowerOf2;
	*pusEntrySelector = usLog;
	*pusRangeShift = (2 * usSegCount) - (2 * usPowerOf2);
}

FS_PUBLIC ErrorCode sfac_GetGlyphIndex(
	sfac_ClientRec *  ClientInfo,
	uint16            usCharacterCode)
{
	 const uint8 *   mappingPtr;
	ErrorCode   error;

	 error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, TRUE, (const void **)&mappingPtr);

	if(error != NO_ERR)
	{
		return error;
	}

	ClientInfo->usGlyphIndex = ClientInfo->GlyphMappingF (mappingPtr + ClientInfo->ulMapOffset, usCharacterCode, ClientInfo);

	RELEASESFNTFRAG(ClientInfo, mappingPtr);

	return NO_ERR;
}

/*  return glyph ID's for a range or for an array of character codes */

FS_PUBLIC ErrorCode sfac_GetMultiGlyphIDs (
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID)         /* Output glyph ID array        */
{
	const uint8 *       mappingPtr;
    const uint8 *       mapOffsetPtr;
	ErrorCode           errCode;

    if ((ClientInfo->usMappingFormat != 0) &&
        (ClientInfo->usMappingFormat != 2) &&
        (ClientInfo->usMappingFormat != 4) &&
        (ClientInfo->usMappingFormat != 6))
    {
        return UNKNOWN_CMAP_FORMAT;
    }

	errCode = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, TRUE, (const void **)&mappingPtr);
    if(errCode != NO_ERR)
	{
		return errCode;
	}
    mapOffsetPtr = mappingPtr + ClientInfo->ulMapOffset;

    errCode = sfac_GetGlyphIDs (
   	    ClientInfo->GlyphMappingF,
        mapOffsetPtr,
        ClientInfo,
        usCharCount,
	    usFirstChar,
	    pusCharCode,
	    pusGlyphID);

	RELEASESFNTFRAG(ClientInfo, mappingPtr);

	return errCode;
}

/*  special version for Win95 doesn't require a font context */

FS_PUBLIC ErrorCode sfac_GetWin95GlyphIDs (
	uint8 *             pbyCmapSubTable,       /* Pointer to cmap sub table    */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID)         /* Output glyph ID array        */
{
   	uint16              usMappingFormat;    /* cmap subtable format code    */
   	MappingFunc			pfnGlyphMapping;	/* mapping func char to glyph   */
    const uint8 *       pbyCmapData;        /* past subtable header         */
 	ErrorCode           errCode;

    usMappingFormat = (uint16)SWAPW (*((uint16 *)&pbyCmapSubTable[SFNT_MAPPINGTABLE_FORMAT]));
	switch (usMappingFormat)
	{
	case 0:
		pfnGlyphMapping = sfac_ComputeIndex0;
		break;
	case 2:
		pfnGlyphMapping = sfac_ComputeIndex2;
        break;
	case 4:
		pfnGlyphMapping = sfac_ComputeIndex4;
        break;
	case 6:
		pfnGlyphMapping = sfac_ComputeIndex6;
		break;
    default:
        return UNKNOWN_CMAP_FORMAT;
    }
    pbyCmapData = pbyCmapSubTable + SIZEOF_SFNT_MAPPINGTABLE;


    errCode = sfac_GetGlyphIDs (
   	    pfnGlyphMapping,
        pbyCmapData,
        NULL,                               /* ClientInfo */
        usCharCount,
	    usFirstChar,
	    pusCharCode,
	    pusGlyphID );

	return errCode;
}

/* special helper function for NT
   - an offset usCharCodeOffset is added to the character codes from pulCharCode 
     before converting the value to glyph index
   - pulCharCode and pulGlyphID are both uint32 *
   - pulCharCode and pulGlyphID can point to the same address        
*/

FS_PUBLIC ErrorCode sfac_GetWinNTGlyphIDs (
    sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
    uint16              numGlyphs,          /* maxp->numGlyphs */
    uint16              usCharCount,        /* Number of chars to convert   */
    uint16              usFirstChar,        /* First char code              */
    uint32              ulCharCodeOffset,   /* Offset to be added to *pulCharCode
                                               before converting            */
    uint32 *            pulCharCode,        /* Pointer to char code list    */
    uint32 *            pulGlyphID)        /* Output glyph ID array        */
{
	const uint8 *       mappingPtr;
    const uint8 *       mapOffsetPtr;
	ErrorCode           errCode;

    if ((ClientInfo->usMappingFormat != 0) &&
        (ClientInfo->usMappingFormat != 2) &&
        (ClientInfo->usMappingFormat != 4) &&
        (ClientInfo->usMappingFormat != 6))
    {
        return UNKNOWN_CMAP_FORMAT;
    }

	errCode = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, TRUE, (const void **)&mappingPtr);
    if(errCode != NO_ERR)
	{
		return errCode;
	}
    mapOffsetPtr = mappingPtr + ClientInfo->ulMapOffset;

    errCode = sfac_GetLongGlyphIDs (
        ClientInfo->GlyphMappingF,
        mapOffsetPtr,
        ClientInfo,
        numGlyphs,
        usCharCount,
        usFirstChar,
        ulCharCodeOffset,
        pulCharCode,
        pulGlyphID);

	RELEASESFNTFRAG(ClientInfo, mappingPtr);

	return errCode;
}

/*      common code for the two get glyph ID helper routines */

FS_PRIVATE ErrorCode sfac_GetGlyphIDs (
   	MappingFunc			pfnGlyphMapping,	/* mapping func char to glyph	*/
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
	sfac_ClientRec *    ClientInfo,         /* May be NULL!                 */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usCharCode,         /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID)         /* Output glyph ID array        */
{
	if (pusCharCode == NULL)                /* Null pointer implies character code range */
    {
        if (((uint32)usCharCode + (uint32)usCharCount) > 0x0000FFFFL)
        {
            return INVALID_CHARCODE_ERR;    /* trap an illegal range */
        }

        while (usCharCount > 0)
        {
        	*pusGlyphID = pfnGlyphMapping (mapOffsetPtr, usCharCode, ClientInfo);
            pusGlyphID++;
            usCharCode++;                   /* next character in range */
            usCharCount--;
        }
    }
    else                                    /* Valid pointer implies character code array */
    {
        while (usCharCount > 0)
        {
            if (*pusCharCode == 0xFFFF)     /* trap illegal char code */
            {
                return INVALID_CHARCODE_ERR;
            }
        	*pusGlyphID = pfnGlyphMapping (mapOffsetPtr, *pusCharCode, ClientInfo);
            pusGlyphID++;
            pusCharCode++;                  /* next character in array */
            usCharCount--;
        }
    }
	return NO_ERR;
}

/*      special for NT */

FS_PRIVATE ErrorCode sfac_GetLongGlyphIDs (
    MappingFunc         pfnGlyphMapping,    /* mapping func char to glyph   */
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
    sfac_ClientRec *    ClientInfo,         /* May be NULL!                 */
    uint16              numGlyphs,          /* maxp->numGlyphs */
    uint16              usCharCount,        /* Number of chars to convert   */
    uint16              usCharCode,         /* First char code              */
    uint32              ulCharCodeOffset,   /* Offset to be added to *pulCharCode
                                               before converting            */
    uint32 *            pulCharCode,        /* Pointer to char code list    */
    uint32 *            pulGlyphID)         /* Output glyph ID array        */
{
	if (pulCharCode == NULL)                /* Null pointer implies character code range */
    {
        if (((uint32)usCharCode + (uint32)usCharCount) > 0x0000FFFFL)
        {
            return INVALID_CHARCODE_ERR;    /* trap an illegal range */
        }

        while (usCharCount > 0)
        {
        	*pulGlyphID = (uint32)pfnGlyphMapping (mapOffsetPtr, usCharCode, ClientInfo);

            if (*pulGlyphID >= numGlyphs)
            {
                *pulGlyphID = 0; /* in case a character is mapped to glyph ID our of range, map it to the missing glyph */
            }
            pulGlyphID++;
            usCharCode++;                   /* next character in range */
            usCharCount--;
        }
    }
    else                                    /* Valid pointer implies character code array */
    {
        while (usCharCount > 0)
        {
			if ((*pulCharCode + ulCharCodeOffset) > 0x0000FFFFL)
            {
                return INVALID_CHARCODE_ERR;   /* trap an illegal range */
            }
			usCharCode = (uint16) (*pulCharCode + ulCharCodeOffset);
        	*pulGlyphID = (uint32)pfnGlyphMapping (mapOffsetPtr, usCharCode, ClientInfo);
            if (*pulGlyphID >= numGlyphs)
            {
                *pulGlyphID = 0; /* in case a character is mapped to glyph ID our of range, map it to the missing glyph */
            }
            pulGlyphID++;
            pulCharCode++;                  /* next character in array */
            usCharCount--;
        }
    }
	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC ErrorCode sfac_LoadCriticalSfntMetrics(
	sfac_ClientRec *        ClientInfo,
	uint16 *                pusEmResolution,
	boolean *               pbIntegerScaling,
	LocalMaxProfile *       pMaxProfile)
{
	ErrorCode       error;
	const uint8 *   fontHead;
	const uint8 *   horiHead;
	const uint8 *   pTempMaxProfile;
	const uint8 *   pTempOS_2;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_fontHeader, TRUE, (const void **)&fontHead);

	if(error != NO_ERR)
	{
		return error;
	}

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_horiHeader, TRUE, (const void **)&horiHead);

	if(error != NO_ERR)
	{
		return error;
	}

	if ((uint32)SWAPL (*((uint32 *)&fontHead[SFNT_FONTHEADER_MAGICNUMBER])) != SFNT_MAGIC)
	{
		return BAD_MAGIC_ERR;
	}

	*pusEmResolution     = (uint16)SWAPW (*((uint16 *)&fontHead[SFNT_FONTHEADER_UNITSPEREM]));
	if(*pusEmResolution < 16 || *pusEmResolution > 16384)
		return BAD_UNITSPEREM_ERR;
		
	*pbIntegerScaling    = (((uint16)SWAPW (*((uint16 *)&fontHead[SFNT_FONTHEADER_FLAGS]))& USE_INTEGER_SCALING) ==
									 USE_INTEGER_SCALING);

	ClientInfo->usNumberOf_LongHorMetrics = (uint16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_NUMBEROF_LONGHORMETRICS]));
	if(ClientInfo->usNumberOf_LongHorMetrics == 0)
		return BAD_NUMLONGHORMETRICS_ERR;

	ClientInfo->sIndexToLocFormat       = SWAPW (*((int16 *)&fontHead[SFNT_FONTHEADER_INDEXTOLOCFORMAT]));

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_OS_2, FALSE, (const void **)&pTempOS_2); /* not a mandatory table */

	if(error != NO_ERR)
	{
		return error;
	}

	if(pTempOS_2 != NULL)
	{
		/* get TypoAscender and TypoDescender from the OS/2 table */
		ClientInfo->sDefaultAscender = (int16)SWAPW (*((uint16 *)&pTempOS_2[SFNT_OS2_STYPOASCENDER]));
		ClientInfo->sDefaultDescender = (int16)SWAPW (*((uint16 *)&pTempOS_2[SFNT_OS2_STYPODESCENDER]));
		RELEASESFNTFRAG(ClientInfo, pTempOS_2);
	} else {
		/* if OS/2 is not there get the values from horizontal header */
		ClientInfo->sDefaultAscender = (int16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_YASCENDER]));
		ClientInfo->sDefaultDescender = (int16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_YDESCENDER]));
	}
	ClientInfo->sWinDescender = (int16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_YDESCENDER]));

	RELEASESFNTFRAG(ClientInfo, horiHead);
	RELEASESFNTFRAG(ClientInfo, fontHead);

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_maxProfile, TRUE, (const void **)&pTempMaxProfile);

	if(error != NO_ERR)
	{
		return error;
	}

	pMaxProfile->version =              (Fixed)SWAPL(*((Fixed *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_VERSION]));
	pMaxProfile->numGlyphs =            (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_NUMGLYPHS]));
	pMaxProfile->maxPoints =            (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXPOINTS]));
	pMaxProfile->maxContours =          (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCONTOURS]));
	pMaxProfile->maxCompositePoints =   (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPOSITEPOINTS]));
	pMaxProfile->maxCompositeContours = (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPOSITECONTOURS]));
	pMaxProfile->maxElements =          (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXELEMENTS]));
	pMaxProfile->maxTwilightPoints =    (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXTWILIGHTPOINTS]));
	pMaxProfile->maxStorage =           (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXSTORAGE]));
	pMaxProfile->maxFunctionDefs =      (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXFUNCTIONDEFS]));
	pMaxProfile->maxInstructionDefs =   (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXINSTRUCTIONDEFS]));
	pMaxProfile->maxStackElements =     (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXSTACKELEMENTS]));
	pMaxProfile->maxSizeOfInstructions =(uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXSIZEOFINSTRUCTIONS]));
	pMaxProfile->maxComponentElements = (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPONENTELEMENTS]));
	pMaxProfile->maxComponentDepth =    (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPONENTDEPTH]));

	RELEASESFNTFRAG(ClientInfo, pTempMaxProfile);

	error = sfac_ReadNumLongVertMetrics(ClientInfo, &ClientInfo->usNumLongVertMetrics,&ClientInfo->bValidNumLongVertMetrics);

	return error;
}



/*
 *
 */

FS_PUBLIC ErrorCode sfac_ReadGlyphHorMetrics (
	sfac_ClientRec *    ClientInfo,
	uint16              glyphIndex,
	uint16 *            pusNonScaledAW,
	int16 *             psNonScaledLSB)
{
	const uint8 *   horizMetricPtr;
	uint16          numberOf_LongHorMetrics;
	ErrorCode       error;
	int16 *         lsb;

	numberOf_LongHorMetrics = ClientInfo->usNumberOf_LongHorMetrics;
	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_horizontalMetrics, TRUE, (const void **)&horizMetricPtr);

	if(error != NO_ERR)
	{
		return error;
	}

	if (glyphIndex < numberOf_LongHorMetrics)
	{
		*pusNonScaledAW     = (uint16)SWAPW (*((uint16 *)&horizMetricPtr[(glyphIndex * SIZEOF_SFNT_HORIZONTALMETRICS) + SFNT_HORIZONTALMETRICS_ADVANCEWIDTH]));
		*psNonScaledLSB     = SWAPW (*((int16 *)&horizMetricPtr[(glyphIndex * SIZEOF_SFNT_HORIZONTALMETRICS) + SFNT_HORIZONTALMETRICS_LEFTSIDEBEARING]));
	}
	else
	{
		lsb = (int16 *) (char *)& horizMetricPtr[numberOf_LongHorMetrics * SIZEOF_SFNT_HORIZONTALMETRICS]; /* first entry after[AW,LSB] array */

		*pusNonScaledAW       = (uint16)SWAPW (*((uint16 *)&horizMetricPtr[((numberOf_LongHorMetrics-1) * SIZEOF_SFNT_HORIZONTALMETRICS) + SFNT_HORIZONTALMETRICS_ADVANCEWIDTH]));
		*psNonScaledLSB      = SWAPW (lsb[glyphIndex - numberOf_LongHorMetrics]);
	}

	RELEASESFNTFRAG(ClientInfo, horizMetricPtr);

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_ReadGlyphVertMetrics (
	sfac_ClientRec *    ClientInfo,
	uint16              glyphIndex,
	uint16 *            pusNonScaledAH,
	int16 *             psNonScaledTSB)
{
	const uint8 *   vertMetricPtr;
	uint16          usNumLongVertMetrics;       /* number of entries with AH */
	ErrorCode       error;
	int16 *         psTSB;
	BBOX            bbox;           


	usNumLongVertMetrics = ClientInfo->usNumLongVertMetrics;
	if(ClientInfo->bValidNumLongVertMetrics)
	{

		error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_verticalMetrics, FALSE, (const void **)&vertMetricPtr);  /* not a mandatory table */

		if(error != NO_ERR)
		{
			return error;
		}
	}

	if (ClientInfo->bValidNumLongVertMetrics && (vertMetricPtr != NULL) )
	{
		if (glyphIndex < usNumLongVertMetrics)
		{
			*pusNonScaledAH     = (uint16)SWAPW (*((uint16 *)&vertMetricPtr[(glyphIndex * SIZEOF_SFNT_VERTICALMETRICS) + SFNT_VERTICALMETRICS_ADVANCEHEIGHT]));
			*psNonScaledTSB     = SWAPW (*((int16 *)&vertMetricPtr[(glyphIndex * SIZEOF_SFNT_VERTICALMETRICS) + SFNT_VERTICALMETRICS_TOPSIDEBEARING]));
		}
		else
		{
			psTSB = (int16 *) (char *)& vertMetricPtr[usNumLongVertMetrics * SIZEOF_SFNT_VERTICALMETRICS]; /* first entry after[AW,TSB] array */

			*pusNonScaledAH       = (uint16)SWAPW (*((uint16 *)&vertMetricPtr[((usNumLongVertMetrics-1) * SIZEOF_SFNT_VERTICALMETRICS) + SFNT_VERTICALMETRICS_ADVANCEHEIGHT]));
			*psNonScaledTSB      = SWAPW (psTSB[glyphIndex - usNumLongVertMetrics]);
		}

		RELEASESFNTFRAG(ClientInfo, vertMetricPtr);
	} else {

		/* We don't have vertical metrics, let's set to default values */

		/* to get the glyph bbox for the defalut value of the vertical metrics */
		error = sfac_ReadGlyphBbox(ClientInfo,ClientInfo->usGlyphIndex, &bbox);

		if(error != NO_ERR)
		{
			return error;
		}		

		/* default if no vertical metrics found */
		*pusNonScaledAH = ClientInfo->sDefaultAscender - ClientInfo->sDefaultDescender;   
		*psNonScaledTSB = ClientInfo->sDefaultAscender - bbox.yMax;
	}

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_ReadGlyphMetrics (
	sfac_ClientRec *    ClientInfo,
	uint16              glyphIndex,
	uint16 *            pusNonScaledAW,
	uint16 *            pusNonScaledAH,
	int16 *             psNonScaledLSB,
	int16 *             psNonScaledTSB,
    int16 *             psNonScaledTopOriginX)
{
	ErrorCode       error;

	error = sfac_ReadGlyphHorMetrics (ClientInfo, glyphIndex, pusNonScaledAW, psNonScaledLSB);

	if(error != NO_ERR)
	{
		return error;
	}

	error = sfac_ReadGlyphVertMetrics (ClientInfo, glyphIndex, pusNonScaledAH, psNonScaledTSB);

    /* for characters whose adwance width equal the box size, we want to have this origin shifted by the descender so that
       the baseline of non sideways glyphs will align correctely. If the advance width is different we want to adjust to keep the optical center 
       of the character aligned */
    * psNonScaledTopOriginX = -ClientInfo->sDefaultDescender -((ClientInfo->sDefaultAscender - ClientInfo->sDefaultDescender - *pusNonScaledAW) /2);

	return error;
}

/*
 *  Read Number of Long Vertical Metrics from vhea table
 */

FS_PUBLIC ErrorCode sfac_ReadNumLongVertMetrics(
	sfac_ClientRec *        ClientInfo,
	uint16 *                pusNumLongVertMetrics,
	boolean *               pbValidNumLongVertMetrics )
{
	ErrorCode       error;
	const uint8 *   vertHead;

	*pbValidNumLongVertMetrics = FALSE;
	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_vertHeader, FALSE, (const void **)&vertHead);

	if(error != NO_ERR)
	{
		return error;
	}		
	
	if(vertHead != NULL)
	{
		*pusNumLongVertMetrics = (uint16)SWAPW (*((uint16 *)&vertHead[SFNT_VERTICALHEADER_NUMBEROF_LONGVERTMETRICS]));
		*pbValidNumLongVertMetrics = TRUE;

		RELEASESFNTFRAG(ClientInfo, vertHead);
	}

	return NO_ERR;
}


FS_PRIVATE ErrorCode sfac_GetGlyphLocation (
	sfac_ClientRec *    ClientInfo,
	uint16              gIndex,
	uint32 *            ulOffset,
	uint32 *            ulLength,
	sfnt_tableIndex*    pGlyphTableIndex)

{
	const void *    indexPtr;
	ErrorCode       error;
	uint16 *        shortIndexToLoc;
	uint32 *        longIndexToLoc;
	uint32 *        offsetPtr;
	uint16 *        lengthPtr;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_GlyphDirectory, FALSE, (const void **)&indexPtr);

	if(error != NO_ERR)
	{
		return error;
	}

	/* If there is a glyph directory, first check for the glyph there.  */

	if (indexPtr != NULL)
	{
		offsetPtr = (uint32 *)((char *)indexPtr+((int32)gIndex*(int32)(sizeof(int32)+sizeof(uint16))));
		lengthPtr = (uint16 *)(char *)(offsetPtr+1);

		*ulOffset = (uint32)SWAPL(*offsetPtr);

		if(*ulOffset == 0L)
		{
			*ulLength =  0L;
		}
		else
		{
			*ulLength =  (uint32) (uint16)SWAPW(*lengthPtr);
		}

		/* sfnt_BeginningOfFont references the beginning of memory  */

		*pGlyphTableIndex = sfnt_BeginningOfFont;

		RELEASESFNTFRAG(ClientInfo, indexPtr);
		return NO_ERR;
	}

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_indexToLoc, TRUE, (const void **)&indexPtr);
	if(error != NO_ERR)
	{
		return error;
	}

	if (ClientInfo->sIndexToLocFormat == SHORT_INDEX_TO_LOC_FORMAT)
	{
		shortIndexToLoc = (uint16 *)indexPtr + gIndex;
		*ulOffset = (uint32) (uint16) (SWAPW (*shortIndexToLoc)) << 1;
		shortIndexToLoc++;
		*ulLength =  (((uint32) (uint16) (SWAPW (*shortIndexToLoc)) << 1) - *ulOffset);
	}
	else
	{
		longIndexToLoc = (uint32 *)indexPtr + gIndex;
		*ulOffset = (uint32) SWAPL (*longIndexToLoc);
		longIndexToLoc++;
		*ulLength = ((uint32)SWAPL (*longIndexToLoc) - *ulOffset);
	}

	*pGlyphTableIndex = sfnt_glyphData;

	RELEASESFNTFRAG(ClientInfo, indexPtr);

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_CopyFontAndPrePrograms(
	sfac_ClientRec *    ClientInfo,    /* Client Information         */
	char *              pFontProgram,  /* pointer to Font Program    */
	char *              pPreProgram)   /* pointer to Pre Program     */
{
	uint32              ulLength;
	const char *        pFragment;
	ErrorCode           error;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_fontProgram, FALSE, (const void **)&pFragment);
	if(error)
	{
		return error;
	}
	ulLength = SFAC_LENGTH (ClientInfo, sfnt_fontProgram);
	if (ulLength)
	{
		MEMCPY (pFontProgram, pFragment, ulLength);
		RELEASESFNTFRAG(ClientInfo, pFragment);
	}

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_preProgram, FALSE, (const void **)&pFragment);
	if(error)
	{
		return error;
	}
	ulLength = SFAC_LENGTH (ClientInfo, sfnt_preProgram);
	if (ulLength)
	{
		MEMCPY (pPreProgram, pFragment, ulLength);
		RELEASESFNTFRAG(ClientInfo, pFragment);
	}

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_CopyCVT(
	sfac_ClientRec *    ClientInfo,    /* Client Information   */
	F26Dot6 *           pCVT)       /* pointer to CVT    */
{
	uint32              ulLength;
	const int16 *       pFragment;
	int32               lNumCVT;
	int32               lCVTCount;
	const int16 *       psSrcCVT;
	F26Dot6 *           pfxDstCVT;
	ErrorCode           error;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_controlValue, FALSE, (const void **)&pFragment);

	if(error)
	{
		return error;
	}

	ulLength = SFAC_LENGTH (ClientInfo, sfnt_controlValue);

	if (ulLength)
	{
		psSrcCVT = pFragment;
		pfxDstCVT = pCVT;

		lNumCVT = ((int32)ulLength / (int32)sizeof( sfnt_ControlValue));

		for(lCVTCount = 0L; lCVTCount < lNumCVT; lCVTCount++)
		{
			pfxDstCVT[lCVTCount] = (F26Dot6)SWAPW(psSrcCVT[lCVTCount]);
		}

		RELEASESFNTFRAG(ClientInfo, pFragment);
	}

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_CopyHdmxEntry(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	boolean *           pbFound,        /* Flag indicating if entry found */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer)       /* Buffer to save glyph sizes */
{
	const uint8 *       pHdmx;
	const uint8 *       pCurrentHdmxRecord;
	uint32              ulHdmxRecordSize;
	uint16              usRecordIndex;
	uint16              usGlyphIndex;
	ErrorCode           error;

	Assert( usFirstGlyph <= usLastGlyph );
	Assert( psBuffer != NULL );

	*pbFound = FALSE;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_HoriDeviceMetrics, FALSE, (const void **)&pHdmx);

	if(error)
	{
		return error;
	}

	/* If no 'hdmx' return success and not found    */

	if( pHdmx == NULL )
	{
		return NO_ERR;
	}

	if((uint16)pHdmx[SFNT_HDMX_VERSION] == 0)   /*  NOTE: No SWAP for zero check    */
	{
		ulHdmxRecordSize = (uint32)SWAPL(*((uint32 *)&pHdmx[SFNT_HDMX_LSIZERECORD]));

		usRecordIndex = 0;
		pCurrentHdmxRecord = &pHdmx[SFNT_HDMX_HDMXTABLE];
		while (  (usRecordIndex < (uint16)SWAPW(*((uint16 *)&pHdmx[SFNT_HDMX_SNUMRECORDS]))) && !*pbFound )
		{
			if( usPixelsPerEm == (uint16)pCurrentHdmxRecord[SFNT_HDMXRECORD_BEMY] )
			{
				*pbFound = TRUE;
			}
			else
			{
				pCurrentHdmxRecord += ulHdmxRecordSize;
			}
			usRecordIndex++;
		}

		if ( *pbFound )
		{
			for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++)
			{
				*psBuffer = (int16)pCurrentHdmxRecord[SFNT_HDMXRECORD_BWIDTHS + usGlyphIndex];
				psBuffer++;
			}
		}
	}

	RELEASESFNTFRAG(ClientInfo, pHdmx);

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_GetLTSHEntries(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer)       /* Buffer to save glyph sizes */
{
	const uint8 *       pLTSH;
	uint16              usGlyphIndex;
	ErrorCode           error;

	MEMSET(psBuffer, FALSE, ((usLastGlyph - usFirstGlyph) + 1) * sizeof(int16));

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_LinearThreshold, FALSE, (const void **)&pLTSH);

	if(error)
	{
		return error;
	}
	
	if( pLTSH == NULL )
	{
		return NO_ERR;
	}

	if((uint16)pLTSH[SFNT_LTSH_VERSION] == 0)   /*  NOTE: No SWAP for zero check    */
	{
		for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++ )
		{
			if( usPixelsPerEm >= (uint16)pLTSH[SFNT_LTSH_UBYPELSHEIGHT + usGlyphIndex] )
			{
				*psBuffer = TRUE;
			}
			else
			{
				*psBuffer = FALSE;
			}
			psBuffer++;
		}
	}

	RELEASESFNTFRAG(ClientInfo, pLTSH);

	return NO_ERR;
}



/***************************** Public  Function ****************************\
* sfac_ReadGlyphHeader
*
* This routine sets up the glyph handle to a glyph, and returns the header
* information in the glyph.
*
* Effects:
*
* Error Returns:
*
* UNKNOWN_COMPOSITE_VERSION
*
* History:
* Wed 26-Aug-1992 09:55:19 -by-  Greg Hitchcock [gregh]
*      Added CodeReview fixes
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadGlyphHeader(
	sfac_ClientRec *    ClientInfo,       /* Client Information         */
	uint16              usGlyphIndex,     /* Glyph index to read        */
	sfac_GHandle *      hGlyph,           /* Return glyph handle        */
	boolean *           pbCompositeGlyph, /* Is glyph a composite?      */
	boolean *           pbHasOutline,     /* Does glyph have outlines?  */
	int16 *             psNumberOfContours, /* Number of contours in glyph */
	BBOX *              pbbox)            /* Glyph Bounding box         */
{
	uint32              ulLength;
	uint32              ulOffset;
	sfnt_tableIndex     glyphTableIndex;
	ErrorCode           error;
	const uint8 *       GlyphHeader;

	hGlyph->pvGlyphBaseAddress = NULL;
	hGlyph->pvGlyphNextAddress = NULL;

	/* Locate the glyph in the font file   */

	error = sfac_GetGlyphLocation(
		ClientInfo,
		usGlyphIndex,
		&ulOffset,
		&ulLength,
		&glyphTableIndex);

	if(error)
	{
		return error;
	}

	if( ulLength == 0 )
	{
		*psNumberOfContours = 1;
		MEMSET(pbbox, 0, sizeof(BBOX));
		*pbHasOutline = FALSE;
		*pbCompositeGlyph = FALSE;
	}
	else
	{
		if (ulLength < SFNT_PACKEDSPLINEFORMAT_ENDPOINTS)
		{
			return GLYF_TABLE_CORRUPTION_ERR;
		}

		error = sfac_GetDataPtr(ClientInfo, ulOffset, ulLength,
				glyphTableIndex, TRUE, (const void **)&hGlyph->pvGlyphBaseAddress);

		if(error)
		{
			return error;
		}

		hGlyph->pvGlyphEndAddress = (uint8 *)hGlyph->pvGlyphBaseAddress + ulLength;

		GlyphHeader = (uint8 *)hGlyph->pvGlyphBaseAddress;
		*psNumberOfContours = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_NUMBEROFCONTOURS]));

		if( *psNumberOfContours < COMPONENTCTRCOUNT )
		{
			return UNKNOWN_COMPOSITE_VERSION;
		}

		if( *psNumberOfContours == COMPONENTCTRCOUNT )
		{
			*pbCompositeGlyph = TRUE;
			*psNumberOfContours = 0;
			*pbHasOutline = FALSE;
		}
		else
		{
			*pbCompositeGlyph = FALSE;
			*pbHasOutline = TRUE;
		}

		pbbox->xMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMIN]));
		pbbox->yMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMIN]));
		pbbox->xMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMAX]));
		pbbox->yMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMAX]));

		if((pbbox->xMin > pbbox->xMax) || (pbbox->yMin > pbbox->yMax))
		{
			return SFNT_DATA_ERR;
		}

		if(pbHasOutline)
		{
			hGlyph->pvGlyphNextAddress = (voidPtr)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_ENDPOINTS];
		}
	}

	return NO_ERR;
}

/***************************** Public  Function ****************************\
* sfac_ReadGlyphBbox
*
*
* Effects:
*         This function release the glyph memory immediately
*
* Error Returns:
*
* SFNT_DATA_ERR
*
* History:
* Wed 20-Dec-1996 18:42:51 -by-  Claude Betrisey [claudebe]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadGlyphBbox(
	sfac_ClientRec *    ClientInfo,       /* Client Information         */
	uint16              usGlyphIndex,     /* Glyph index to read        */
	BBOX *              pbbox)            /* Glyph Bounding box         */
{
	uint32              ulLength;
	uint32              ulOffset;
	sfnt_tableIndex     glyphTableIndex;
	ErrorCode           error;
	const uint8 *       GlyphHeader;


	/* Locate the glyph in the font file   */

	error = sfac_GetGlyphLocation(
		ClientInfo,
		usGlyphIndex,
		&ulOffset,
		&ulLength,
		&glyphTableIndex);

	if(error)
	{
		return error;
	}

	if( ulLength == 0 )
	{
		MEMSET(pbbox, 0, sizeof(BBOX));
	}
	else
	{
		error = sfac_GetDataPtr(ClientInfo, ulOffset, ulLength,
				glyphTableIndex, TRUE, (const void **)&GlyphHeader);

		if(error)
		{
			return error;
		}

		pbbox->xMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMIN]));
		pbbox->yMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMIN]));
		pbbox->xMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMAX]));
		pbbox->yMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMAX]));

		RELEASESFNTFRAG(ClientInfo, GlyphHeader );

		if((pbbox->xMin > pbbox->xMax) || (pbbox->yMin > pbbox->yMax))
		{
			return SFNT_DATA_ERR;
		}


	}

	return NO_ERR;
}

/***************************** Public  Function ****************************\
* sfac_ReadOutlineData
*
*   This routine reads the outline data from the font file. This information
*   includes x and y coordinates, and on-curve indicators as well as start/end
*   points, flags, and instruction data.
*
* Effects:
*   hGlyph
*
* Error Returns:
*   CONTOUR_DATA_ERR
*
* History:
* Wed 26-Aug-1992 09:55:49 -by-  Greg Hitchcock [gregh]
*      Added Code Review fixes
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/


FS_PUBLIC ErrorCode sfac_ReadOutlineData(
	uint8 *             abyOnCurve,             /* Array of on curve indicators per point */
	F26Dot6 *           afxOoy,                 /* Array of ooy points for every point    */
	F26Dot6 *           afxOox,                 /* Array of oox points for every point    */
	sfac_GHandle *      hGlyph,
	LocalMaxProfile *   pMaxProfile,            /* copy of profile                        */
	boolean             bHasOutline,            /* Does glyph have outlines?              */
	int16               sNumberOfContours,      /* Number of contours in glyph            */
	int16 *             asStartPoints,          /* Array of start points for every contour   */
	int16 *             asEndPoints,            /* Array of end points for every contour    */
	uint16 *            pusSizeOfInstructions,  /* Size of instructions in bytes        */
	 uint8 **               pbyInstructions,    /* Pointer to start of glyph instructions    */
     uint32*                pCompositePoints,   /* total number of point for composites, to check for overflow */
     uint32*                pCompositeContours) /* total number of contours for composites, to check for overflow */

{

	uint8 *     pbyCurrentSfntLocation;
	int16 *     psCurrentLocation;
	int16 *     asSfntEndPoints;
	uint8 *     pbySfntFlags;
	uint8       byRepeatFlag;

	int32       lNumPoints;
	int32       lContourIndex;
	int32       lPointCount;
	int32       lPointIndex;
	uint16      usRepeatCount;
	int16       sXValue;
	int16       sYValue;
	uint8 *     pbyFlags;
	F26Dot6 *   pf26OrigX;
	F26Dot6 *   pf26OrigY;

	/* Initialize Fields */

	asStartPoints[0] = 0;
	asEndPoints[0] = 0;

	abyOnCurve[0] = ONCURVE;
	afxOox[0] = 0;
	afxOoy[0] = 0;

	*pbyInstructions = NULL;
	*pusSizeOfInstructions = 0;

	/* If we don't have an outline, exit here   */

	if (!bHasOutline)
	{
		return NO_ERR;
	}

	if (sNumberOfContours <= 0 || sNumberOfContours > (int16)pMaxProfile->maxContours)
	{
		return CONTOUR_DATA_ERR;
	}

    /* Handle the case of outlines   */

	psCurrentLocation = (int16 *)hGlyph->pvGlyphNextAddress;

	asSfntEndPoints = psCurrentLocation;
	psCurrentLocation += sNumberOfContours;

	if ((voidPtr)psCurrentLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}

	*pusSizeOfInstructions = (uint16)SWAPWINC (psCurrentLocation);
	*pbyInstructions = (uint8 *)psCurrentLocation;
	pbySfntFlags = (uint8 *)((char *)psCurrentLocation + *pusSizeOfInstructions);

	if ((voidPtr)pbySfntFlags > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}


    *pCompositeContours += sNumberOfContours;
	if (*pCompositeContours > (uint32)MAX (pMaxProfile->maxContours, pMaxProfile->maxCompositeContours))
	{
		return CONTOUR_DATA_ERR;
	}

	lContourIndex = 0;

	asStartPoints[lContourIndex] = 0;
	asEndPoints[lContourIndex] = SWAPW (asSfntEndPoints[lContourIndex]);
	lNumPoints = (int32)asEndPoints[lContourIndex] + 1;

	for(lContourIndex = 1; lContourIndex < (int32)sNumberOfContours; lContourIndex++)
	{
		asStartPoints[lContourIndex] = (int16)(asEndPoints[lContourIndex - 1] + 1);
		asEndPoints[lContourIndex] = SWAPW (asSfntEndPoints[lContourIndex]);
		if ((lNumPoints > asEndPoints[lContourIndex]) || (lNumPoints > (int32)pMaxProfile->maxPoints) || (lNumPoints <= 0))
		{
			/* array of end points is not in ascending order, or too many points */
			/* or negative, that mean overflow since it's signed int16 instead of unsigned int16, for example 0xcdab */
			return POINTS_DATA_ERR;
		}
		lNumPoints = (int32)asEndPoints[lContourIndex] + 1;
	}

	if (lNumPoints <= 0)
	{
		return POINTS_DATA_ERR;
	}

    *pCompositePoints += lNumPoints;
	if (*pCompositePoints > (uint32)MAX (pMaxProfile->maxPoints, pMaxProfile->maxCompositePoints) )
	{
		return POINTS_DATA_ERR;
	}

	/* Do flags */

	usRepeatCount = 0;

	lPointCount = lNumPoints;
	pbyFlags = abyOnCurve;

	while(lPointCount > 0)
	{
		if(usRepeatCount == 0)
		{
			*pbyFlags = *pbySfntFlags;

			if(*pbyFlags & REPEAT_FLAGS)
			{
				pbySfntFlags++;
				usRepeatCount = (uint16)*pbySfntFlags;
			}
			pbySfntFlags++;
			pbyFlags++;
			lPointCount--;
		}
		else
		{
			byRepeatFlag = pbyFlags[-1];
			lPointCount -= (int32)usRepeatCount;

			if (lPointCount < 0)
			{
				return GLYF_TABLE_CORRUPTION_ERR;
			}

			while(usRepeatCount > 0)
			{
				*pbyFlags = byRepeatFlag;
				pbyFlags++;
				usRepeatCount--;
			}
		}
	}

	pbyCurrentSfntLocation = pbySfntFlags;

	if(usRepeatCount > 0)
	{
		return POINTS_DATA_ERR;
	}

	if ((voidPtr)pbyCurrentSfntLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}
	/* Do X first */

	sXValue = 0;
	pf26OrigX = afxOox;
	pbyFlags = abyOnCurve;

	for(lPointIndex = 0; lPointIndex < lNumPoints; lPointIndex++)
	{
		if(*pbyFlags & XSHORT)
		{
			if(*pbyFlags & SHORT_X_IS_POS)
			{
				sXValue += (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
			else
			{
				sXValue -= (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
		}
		else if (! (*pbyFlags & NEXT_X_IS_ZERO))
		{
			/* This means we have a two byte quantity */

			sXValue += SWAPW(*((int16 *)pbyCurrentSfntLocation));
			pbyCurrentSfntLocation += sizeof(int16);
		}
		*pf26OrigX = (F26Dot6)sXValue;
		pf26OrigX++;
		pbyFlags++;
	}

	if ((voidPtr)pbyCurrentSfntLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}
	/* Now Do Y */

	sYValue = 0;
	pf26OrigY = afxOoy;
	pbyFlags = abyOnCurve;

	for(lPointIndex = 0; lPointIndex < lNumPoints; lPointIndex++)
	{
		if(*pbyFlags & YSHORT)
		{
			if(*pbyFlags & SHORT_Y_IS_POS)
			{
				sYValue += (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
			else
			{
				sYValue -= (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
		}
		else if (! (*pbyFlags & NEXT_Y_IS_ZERO))
		{
			/* This means we have a two byte quantity */

			sYValue += SWAPW(*((int16 *)pbyCurrentSfntLocation));
			pbyCurrentSfntLocation += sizeof(int16);
		}
		*pf26OrigY = (F26Dot6)sYValue;
		pf26OrigY++;

		/* Clear out extraneous bits in OnCurve */

		*pbyFlags &= ONCURVE;
		pbyFlags++;
	}

	if ((voidPtr)pbyCurrentSfntLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}

	hGlyph->pvGlyphNextAddress = (voidPtr)pbyCurrentSfntLocation;

	return NO_ERR;
}

/***************************** Public  Function ****************************\
*
* sfac_ReadComponentData
*
*   This routine reads information from the font file for positioning and
*   scaling a glyph component.
*
* Effects:
*
* Error Returns:
*   none
*
* History:
* Wed 26-Aug-1992 09:56:29 -by-  Greg Hitchcock [gregh]
*      Added Code Review Fixes
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadComponentData(
	sfac_GHandle *          hGlyph,
	sfac_ComponentTypes *   pMultiplexingIndicator, /* Indicator for Anchor vs offsets  */
	boolean *               pbRoundXYToGrid,  /* Round composite offsets to grid     */
	boolean *               pbUseMyMetrics,   /* Use component metrics            */
	boolean *               pbScaleCompositeOffset,   /* Do we scale the composite offset, Apple/MS   */
	boolean *               pbWeHaveInstructions, /* Composite has instructions         */
	uint16 *                pusComponentGlyphIndex, /* Glyph index of component         */
	int16 *                 psXOffset,        /* X Offset of component (if app)      */
	int16 *                 psYOffset,        /* Y Offset of component (if app)      */
	uint16 *                pusAnchorPoint1,  /* Anchor point 1 of component (if app) */
	uint16 *                pusAnchorPoint2,  /* Anchor point 2 of component (if app) */
	transMatrix             *pMulT,           /* Transformation matrix for component */
	boolean *				pbWeHaveAScale,     /* We have a scaling in pMulT					*/
	boolean *               pbLastComponent)   /* Is this the last component?                  */

{
	int16 *     psCurrentLocation;
	uint16      usComponentFlags;
	char *      byteP;

	Fixed       fMultiplier;


	psCurrentLocation = (int16 *)hGlyph->pvGlyphNextAddress;

	/* Initialize values */

	/* Initialize transformation matrix to identity */

	*pMulT = IdentTransform;

	*psXOffset = 0;
	*psYOffset = 0;
	*pusAnchorPoint1 = 0;
	*pusAnchorPoint2 = 0;
	*pbWeHaveAScale = FALSE;

	usComponentFlags = (uint16)SWAPWINC(psCurrentLocation);

	*pbWeHaveInstructions = ((usComponentFlags & WE_HAVE_INSTRUCTIONS) == WE_HAVE_INSTRUCTIONS);
	*pbUseMyMetrics =    ((usComponentFlags & USE_MY_METRICS) == USE_MY_METRICS);
	*pbRoundXYToGrid =      ((usComponentFlags & ROUND_XY_TO_GRID) == ROUND_XY_TO_GRID);

	/* new flags that indicate if the glyph was designed to have the component offset scaled or not
	   Apple does scale the component offset, MS doesn't, those flags are supposed to be clear on old fonts
	   on new fonts, only one of these flags must be set,
	   default is set to false, MS behavior */
	if ((usComponentFlags & SCALED_COMPONENT_OFFSET) == SCALED_COMPONENT_OFFSET)
	{
		*pbScaleCompositeOffset = TRUE;
	}
	if ((usComponentFlags & UNSCALED_COMPONENT_OFFSET) == UNSCALED_COMPONENT_OFFSET)
	{
		*pbScaleCompositeOffset = FALSE;
	}

	*pusComponentGlyphIndex = (uint16)SWAPWINC(psCurrentLocation);

	if (usComponentFlags & ARGS_ARE_XY_VALUES)
	{
		*pMultiplexingIndicator = OffsetPoints;
	}
	else
	{
		*pMultiplexingIndicator = AnchorPoints;
	}


	/*
		!!!APPLEBUG The rasterizer did not handle Word Anchor Points. This
		!!!APPLEBUG has been corrected in our version of the rasterizer, but
		!!!APPLEBUG we need to verify with the Apple source code.  --GregH
	 */

	if (usComponentFlags & ARG_1_AND_2_ARE_WORDS)
	{
		if (usComponentFlags & ARGS_ARE_XY_VALUES)
		{
			*psXOffset    = SWAPWINC (psCurrentLocation);
			*psYOffset    = SWAPWINC (psCurrentLocation);
		}
		else
		{
			*pusAnchorPoint1 = (uint16) SWAPWINC (psCurrentLocation);
			*pusAnchorPoint2 = (uint16) SWAPWINC (psCurrentLocation);
		}
	}
	else
	{
		byteP = (char *)psCurrentLocation;
		if (usComponentFlags & ARGS_ARE_XY_VALUES)
		{
		/* offsets are signed */
			*psXOffset = (int16)(int8)*byteP++;
			*psYOffset = (int16)(int8)*byteP;
		}
		else
		{
		/* anchor points are unsigned */
			*pusAnchorPoint1 = (uint16)(uint8) * byteP++;
			*pusAnchorPoint2 = (uint16)(uint8) * byteP;
		}
		++psCurrentLocation;
	}


	if (usComponentFlags & (WE_HAVE_A_SCALE | WE_HAVE_AN_X_AND_Y_SCALE | WE_HAVE_A_TWO_BY_TWO))
	{

		*pbWeHaveAScale = TRUE;

		if (usComponentFlags & WE_HAVE_A_TWO_BY_TWO)
		{
			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[0][0] = (fMultiplier << 2); /* turn into 16.16 */

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[0][1] = (fMultiplier << 2); /* turn into 16.16 */

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[1][0] = (fMultiplier << 2); /* turn into 16.16 */

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[1][1] = (fMultiplier << 2); /* turn into 16.16 */

		}
		else
		{
			/* If we have a scale factor, build it into the transformation matrix   */

			pMulT->transform[0][1] = 0;
			pMulT->transform[1][0] = 0;

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[0][0] = (fMultiplier <<= 2); /* turn into 16.16 */

			if (usComponentFlags & WE_HAVE_AN_X_AND_Y_SCALE)
			{
				fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
				pMulT->transform[1][1] = (fMultiplier <<= 2); /* turn into 16.16 */
			}
			else
			{
				pMulT->transform[1][1] = pMulT->transform[0][0];
			}
		}
	}
	*pbLastComponent = !((usComponentFlags & MORE_COMPONENTS) == MORE_COMPONENTS);

	hGlyph->pvGlyphNextAddress = (voidPtr)psCurrentLocation;

	if (hGlyph->pvGlyphNextAddress > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}
	return NO_ERR;
}

/***************************** Public  Function ****************************\
*
* sfac_ReadCompositeInstructions
*
*   This routine returns the instructions for the composite
*
* Effects:
*   none
*
* Error Returns:
*   none
*
* History:
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadCompositeInstructions(
	sfac_GHandle * hGlyph,
	uint8 **    pbyInstructions,     /* Pointer to start of glyph instructions */
	uint16 *    pusSizeOfInstructions) /* Size of instructions in bytes           */
{
	int16 *    psCurrentLocation;

	psCurrentLocation = (int16 *)hGlyph->pvGlyphNextAddress;

	*pusSizeOfInstructions = (uint16)SWAPWINC (psCurrentLocation);
	*pbyInstructions = (uint8 *)psCurrentLocation;
	hGlyph->pvGlyphNextAddress = (voidPtr)(*pbyInstructions + *pusSizeOfInstructions);

	if (hGlyph->pvGlyphNextAddress > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}

	return NO_ERR;
}

/***************************** Public  Function ****************************\
*
* sfac_ReleaseGlyph
*
*   This routine releases the glyph handle for the font file
*
* Effects:
*   none
*
* Error Returns:
*   none
*
* History:
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReleaseGlyph(
	sfac_ClientRec *  ClientInfo,
	sfac_GHandle *    hGlyph)
{
	if(hGlyph->pvGlyphNextAddress)
	{
		RELEASESFNTFRAG(ClientInfo,(voidPtr)hGlyph->pvGlyphBaseAddress);

		hGlyph->pvGlyphNextAddress = NULL;
		hGlyph->pvGlyphBaseAddress = NULL;

	}

	return NO_ERR;
}

/***************************************************************************/

/*      Embedded Bitmap (sbit) Access Routines      */

/**********************************************************************/

/*  Local constants  */

#define     SBIT_BLOC_TABLE         1       /* which table are metrics in */
#define     SBIT_BDAT_TABLE         2

#define     SBIT_HORIZ_METRICS      1       /* which kind of metrics */
#define     SBIT_VERT_METRICS       2
#define     SBIT_BIG_METRICS        3

typedef enum {                              /* metrics type */
	flgHorizontal = 0x01,
	flgVertical = 0x02
} bitmapFlags;

FS_PRIVATE boolean FindBlocStrike (         /* helper function prototype */
	const uint8 *pbyBloc,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint32 *pulStrikeOffset );

FS_PRIVATE boolean FindBscaStrike (         /* helper function prototype */
	const uint8 *pbyBsca,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint32 *pulStrikeOffset );

/*  byte size bitmap range masks */

static uint8    achStartMask[] = { 0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01 };
static uint8    achStopMask[] =  { 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF };
					
/**********************************************************************/

FS_PUBLIC ErrorCode sfac_SearchForStrike (
	sfac_ClientRec *pClientInfo,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint16 *pusTableState,
	uint16 *pusSubPpemX,
	uint16 *pusSubPpemY,
	uint32 *pulStrikeOffset )
{
	const uint8 *   pbyBloc;
	const uint8 *   pbyBsca;
	ErrorCode       ReturnCode;
	
	*pusTableState = SBIT_NOT_FOUND;                /* defaults */
	*pulStrikeOffset = 0L;
	*pusSubPpemX = 0;
	*pusSubPpemY = 0;

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		0L,                                         /* table start */
		ULONG_MAX,                                  /* read whole table */
		sfnt_BitmapLocation,                        /* registered tag */
		FALSE,                                      /* doesn't have to be there */
		(const void**)&pbyBloc );                   /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;
	
	if (pbyBloc != NULL)                            /* if bloc exists */
	{
		if (FindBlocStrike (pbyBloc, usPpemX, usPpemY, usOverScale, pusBitDepth, pulStrikeOffset))
		{
			*pusTableState = SBIT_BLOC_FOUND;       /* exact match */
		}
		else                                        /* if bloc and NO match */
		{
			ReturnCode = sfac_GetDataPtr (
				pClientInfo,                        /* callback etc. */
				0L,                                 /* table start */
				ULONG_MAX,                          /* read whole table */
				sfnt_BitmapScale,                   /* registered tag */
				FALSE,                              /* doesn't have to be there */
				(const void**)&pbyBsca );           /* data pointer */
			
			if (ReturnCode != NO_ERR) return ReturnCode;
			
			if (pbyBsca != NULL)                    /* if bsca exists */
			{
				if (FindBscaStrike (pbyBsca, usPpemX, usPpemY, pulStrikeOffset))
				{
					*pusSubPpemX = (uint16)pbyBsca[*pulStrikeOffset + SFNT_BSCA_SUBPPEMX];
					*pusSubPpemY = (uint16)pbyBsca[*pulStrikeOffset + SFNT_BSCA_SUBPPEMY];
					
					if (FindBlocStrike (pbyBloc, *pusSubPpemX, *pusSubPpemY, usOverScale, pusBitDepth, pulStrikeOffset))
					{
						*pusTableState = SBIT_BSCA_FOUND;
					}
				}
				RELEASESFNTFRAG(pClientInfo, pbyBsca );
			}
		}
		RELEASESFNTFRAG(pClientInfo, pbyBloc);
	}
	return NO_ERR;
}

/**********************************************************************/

/*  Find a strike that matches ppemX & Y in the bloc table */

FS_PRIVATE boolean FindBlocStrike (
	const uint8 *pbyBloc,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint32 *pulStrikeOffset )
{
	uint32          ulNumStrikes;
	uint32          ulStrikeOffset;
	uint32          ulColorRefOffset;
	uint16			usPreferedBitDepth, usBestBitDepth, usCurrentBitDepth;
	uint16			usSbitBitDepthMask;
	
	ulNumStrikes = (uint32)SWAPL(*((uint32*)&pbyBloc[SFNT_BLOC_NUMSIZES]));
	ulStrikeOffset = SFNT_BLOC_FIRSTSTRIKE;

	usBestBitDepth = 0;
	
	if (usOverScale == 0)
	{
		usPreferedBitDepth = 1;
		usSbitBitDepthMask = SBIT_BITDEPTH_MASK & 0x0002; /* accept only black/white bitmap */
	} else 
	{
		if (usOverScale == 2)
		{
			usPreferedBitDepth = 2;
		} else if (usOverScale == 4) 
		{
			usPreferedBitDepth = 4;
		} else
		{
			usPreferedBitDepth = 8;
		}
		usSbitBitDepthMask = SBIT_BITDEPTH_MASK & ~0x0002; /* accept only grayscale bitmap */
	} 

	while (ulNumStrikes > 0)
	{
		if ((usPpemX == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMX]) &&
			(usPpemY == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMY]))
		{
			ulColorRefOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_COLORREF]));
			usCurrentBitDepth = pbyBloc[ulStrikeOffset + SFNT_BLOC_BITDEPTH];

			if (((0x01 << usCurrentBitDepth) & usSbitBitDepthMask) && (ulColorRefOffset == 0L))
			{
				if (usCurrentBitDepth == usPreferedBitDepth)
				{
					/* perfect match */
					*pulStrikeOffset = ulStrikeOffset;
					*pusBitDepth = usPreferedBitDepth;
					return TRUE;      
				} else if (usCurrentBitDepth > usPreferedBitDepth)
				{
					/* above is better than below */
					if ((usCurrentBitDepth < usBestBitDepth) || (usBestBitDepth < usPreferedBitDepth))
					{
						/* above and closer */
						*pulStrikeOffset = ulStrikeOffset;
						usBestBitDepth = usCurrentBitDepth;
					}
				} else /* if (usCurrentBitDepth < usPreferedBitDepth) */
				{
					/* we look below the prefered only if we don't have found anything above */
					if ((usBestBitDepth < usPreferedBitDepth) && (usCurrentBitDepth > usBestBitDepth))
					{
						/* below and closer */
						*pulStrikeOffset = ulStrikeOffset;
						usBestBitDepth = usCurrentBitDepth;
					}
				}
			}
		}
		ulNumStrikes--;
		ulStrikeOffset += SIZEOF_BLOC_SIZESUBTABLE;
	}

	if (usBestBitDepth != 0)
	{
		*pusBitDepth = usBestBitDepth;
		return TRUE;                                   /* best match found */
	} 

	return FALSE;                                   /* match not found */
}

/**********************************************************************/

/*  Find a strike that matches ppemX & Y in the bsca table */

FS_PRIVATE boolean FindBscaStrike (
	const uint8 *pbyBsca,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint32 *pulStrikeOffset )
{
	uint32          ulNumStrikes;
	uint32          ulStrikeOffset;
	
	ulNumStrikes = (uint32)SWAPL(*((uint32*)&pbyBsca[SFNT_BSCA_NUMSIZES]));
	ulStrikeOffset = SFNT_BSCA_FIRSTSTRIKE;
								
	while (ulNumStrikes > 0)
	{
		if ((usPpemX == (uint16)pbyBsca[ulStrikeOffset + SFNT_BSCA_PPEMX]) &&
			(usPpemY == (uint16)pbyBsca[ulStrikeOffset + SFNT_BSCA_PPEMY]))
		{
			*pulStrikeOffset = ulStrikeOffset;
			return TRUE;                            /* match found */
		}
		ulNumStrikes--;
		ulStrikeOffset += SIZEOF_BSCA_SIZESUBTABLE;
	}
	return FALSE;                                   /* match not found */
}

/**********************************************************************/

/*  Look for a glyph in a given strike */        

FS_PUBLIC ErrorCode sfac_SearchForBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usGlyphCode,
	uint32 ulStrikeOffset,
	boolean *pbGlyphFound,                   /* return values */
	uint16 *pusMetricsType,
	uint16 *pusMetricsTable,
	uint32 *pulMetricsOffset,
	uint16 *pusBitmapFormat,
	uint32 *pulBitmapOffset,
	uint32 *pulBitmapLength )
{
	const uint8 *   pbyBloc;
	ErrorCode       ReturnCode;

	uint32      ulNumIndexTables;
	uint32      ulIndexArrayTop;
	uint32      ulIndexArrayOffset;
	uint32      ulSubTableOffset;
	uint32      ulGlyphOffset;
	uint32      ulNextGlyphOffset;
	uint32      ulBitmapLength;
	uint32      ulImageDataOffset;
	uint32      ulNumGlyphs;
	uint32      ulTop;                      /* binary search ranges */
	uint32      ulBottom;
	uint32      ulHit;
	uint32      ulHitOffset;

	uint16      usStartGlyph;               /* for whole strike */
	uint16      usEndGlyph;
	uint16      usFirstGlyph;               /* for one sub table */
	uint16      usLastGlyph;
	uint16      usIndexFormat;
	uint16      usImageFormat;
	uint16      usHitCode;
	
	bitmapFlags bmfDirection;               /* horiz or vert */

	
	*pbGlyphFound = FALSE;                              /* default */

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                    /* callback etc. */
		0L,                                             /* table start */
		ULONG_MAX,                                      /* read whole table */
		sfnt_BitmapLocation,                            /* registered tag */
		TRUE,                                           /* better be there now */
		(const void**)&pbyBloc );                       /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;
		
	usStartGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_STARTGLYPH]));
	usEndGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_ENDGLYPH]));

	if ((usStartGlyph > usGlyphCode) || (usEndGlyph < usGlyphCode))
	{
		RELEASESFNTFRAG(pClientInfo, pbyBloc);
		return NO_ERR;                                  /* glyph out of range */
	}

	ulNumIndexTables = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_NUMINDEXTABLES]));
	ulIndexArrayTop = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_INDEXARRAYOFFSET]));
	ulIndexArrayOffset = ulIndexArrayTop;

	while ((ulNumIndexTables > 0) && (*pbGlyphFound == FALSE))
	{
		usFirstGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_FIRSTGLYPH]));
		usLastGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_LASTGLYPH]));
	
		if ((usFirstGlyph <= usGlyphCode) && (usLastGlyph >= usGlyphCode))
		{
			ulSubTableOffset = ulIndexArrayTop +
				(uint32)SWAPL(*((uint32*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_ADDITIONALOFFSET]));
			
			usIndexFormat = (uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_INDEXFORMAT]));
			usImageFormat = (uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IMAGEFORMAT]));
			ulImageDataOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IMAGEOFFSET]));

/* decode the individual index subtable formats */            

			switch(usIndexFormat)                       /* different search req's */
			{
			case 1:
				ulSubTableOffset += SFNT_BLOC_OFFSETARRAY + sizeof(uint32) * (uint32)(usGlyphCode - usFirstGlyph);
				ulGlyphOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset]));
				
				ulSubTableOffset += sizeof(uint32);
				ulNextGlyphOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset]));
				ulBitmapLength = ulNextGlyphOffset - ulGlyphOffset;

				if (ulBitmapLength == 0)
				{
					RELEASESFNTFRAG(pClientInfo, pbyBloc);
					return NO_ERR;                      /* no bitmap data stored */
				}
				ulImageDataOffset += ulGlyphOffset;
				*pulMetricsOffset = ulImageDataOffset;
				*pusMetricsTable = SBIT_BDAT_TABLE;
				break;
			
			case 2:
				ulBitmapLength = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX2IMAGESIZE]));
				ulImageDataOffset += ulBitmapLength * (usGlyphCode - usFirstGlyph);
				*pulBitmapOffset = ulImageDataOffset;
				
				*pulMetricsOffset = ulSubTableOffset + SFNT_BLOC_IDX2METRICS;
				*pusMetricsTable = SBIT_BLOC_TABLE;
				*pusMetricsType = SBIT_BIG_METRICS;
				break;
			
			case 3:
				ulSubTableOffset += SFNT_BLOC_OFFSETARRAY + sizeof(uint16) * (uint32)(usGlyphCode - usFirstGlyph);
				ulGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset]));
				
				ulSubTableOffset += sizeof(uint16);
				ulNextGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset]));
				ulBitmapLength = ulNextGlyphOffset - ulGlyphOffset;

				if (ulBitmapLength == 0)
				{
					RELEASESFNTFRAG(pClientInfo, pbyBloc);
					return NO_ERR;                      /* no bitmap data stored */
				}
				ulImageDataOffset += ulGlyphOffset;
				*pulMetricsOffset = ulImageDataOffset;
				*pusMetricsTable = SBIT_BDAT_TABLE;
				break;
			
			case 4:
				ulNumGlyphs = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX4NUMGLYPHS]));
				ulTop = 0L;
				ulBottom = ulNumGlyphs - 1L;
				ulSubTableOffset += SFNT_BLOC_IDX4OFFSETARRAY;  /* array base */

				ulHit = ulTop;
				ulHitOffset = ulSubTableOffset;
				usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
				if (usHitCode != usGlyphCode)
				{
					ulHit = ulBottom;
					ulHitOffset = ulSubTableOffset + (ulHit * SIZEOF_CODEOFFSETPAIR);
					usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
					while (usHitCode != usGlyphCode)
					{
						if (usHitCode < usGlyphCode)    /* binary search for glyph code */
						{
							ulTop = ulHit;
						}
						else
						{
							ulBottom = ulHit;
						}
						
						if ((ulBottom - ulTop) < 2L)
						{
							RELEASESFNTFRAG(pClientInfo, pbyBloc);
							return NO_ERR;              /* glyph not found */
						}
						
						ulHit = (ulTop + ulBottom) >> 1L;
						ulHitOffset = ulSubTableOffset + (ulHit * SIZEOF_CODEOFFSETPAIR);
						usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
					}
				}
				ulGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4OFFSET]));
				ulNextGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SIZEOF_CODEOFFSETPAIR + SFNT_BLOC_IDX4OFFSET]));
				ulBitmapLength = ulNextGlyphOffset - ulGlyphOffset;
				
				ulImageDataOffset += ulGlyphOffset;
				*pulMetricsOffset = ulImageDataOffset;
				*pusMetricsTable = SBIT_BDAT_TABLE;
				break;
			
			case 5:
				ulBitmapLength = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX5IMAGESIZE]));
				
				*pulMetricsOffset = ulSubTableOffset + SFNT_BLOC_IDX5METRICS;
				*pusMetricsTable = SBIT_BLOC_TABLE;
				*pusMetricsType = SBIT_BIG_METRICS;
				
				ulNumGlyphs = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX5NUMGLYPHS]));
				ulTop = 0L;
				ulBottom = ulNumGlyphs - 1L;
				ulSubTableOffset += SFNT_BLOC_IDX5CODEARRAY;  /* array base */

				ulHit = ulTop;
				ulHitOffset = ulSubTableOffset;
				usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset]));
				if (usHitCode != usGlyphCode)
				{
					ulHit = ulBottom;
					ulHitOffset = ulSubTableOffset + (ulHit * sizeof(uint16));
					usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
					while (usHitCode != usGlyphCode)
					{
						if (usHitCode < usGlyphCode)    /* binary search for glyph code */
						{
							ulTop = ulHit;
						}
						else
						{
							ulBottom = ulHit;
						}
						
						if ((ulBottom - ulTop) < 2L)
						{
							RELEASESFNTFRAG(pClientInfo, pbyBloc);
							return NO_ERR;              /* glyph not found */
						}
						
						ulHit = (ulTop + ulBottom) >> 1L;
						ulHitOffset = ulSubTableOffset + (ulHit * sizeof(uint16));
						usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset]));
					}
				}
				ulImageDataOffset += ulBitmapLength * ulHit;
				*pulBitmapOffset = ulImageDataOffset;
				break;
			
			
			default:
				
				RELEASESFNTFRAG(pClientInfo, pbyBloc);
				return NO_ERR;                          /* unknown format */
			}

/* use the glyph formats to calculate metrics type & data offsets */
				
			*pulBitmapLength = ulBitmapLength;
			*pusBitmapFormat = usImageFormat;           /* save for bitmap decoding */
			bmfDirection = (bitmapFlags)pbyBloc[ulStrikeOffset + SFNT_BLOC_FLAGS];

			switch(usImageFormat)                       /* different metrics sizes */
			{
			case 1:                                     /* small glyph metrics */
			case 2:
				if (bmfDirection == flgHorizontal)
				{
					*pusMetricsType = SBIT_HORIZ_METRICS;
				}
				else
				{
					Assert(bmfDirection == flgVertical);

					*pusMetricsType = SBIT_VERT_METRICS;
				}
				*pulBitmapOffset = ulImageDataOffset + SIZEOF_SBIT_SMALLMETRICS;
				*pbGlyphFound = TRUE;
				break;
			
			case 3:
				break;
			
			case 4:
				break;
			
			case 5:             /* bitmap offset and metrics type set above */
				*pbGlyphFound = TRUE;
				break;
			
			case 6:
			case 7:
			case 9:
				*pusMetricsType = SBIT_BIG_METRICS;
				*pulBitmapOffset = ulImageDataOffset + SIZEOF_SBIT_BIGMETRICS;
				*pbGlyphFound = TRUE;
				break;
			
			case 8:
				if (bmfDirection == flgHorizontal)
				{
					*pusMetricsType = SBIT_HORIZ_METRICS;
				}
				else
				{
					Assert(bmfDirection == flgVertical);

					*pusMetricsType = SBIT_VERT_METRICS;
				}
				*pulBitmapOffset = ulImageDataOffset + SIZEOF_SBIT_SMALLMETRICS + SIZEOF_SBIT_GLYPH8PAD;
				*pbGlyphFound = TRUE;
				break;

			default:
				break;
			}
		}
		ulNumIndexTables--;    
		ulIndexArrayOffset += SIZEOF_BLOC_INDEXARRAY;
	}
	
	RELEASESFNTFRAG(pClientInfo, pbyBloc);
	return NO_ERR;
}


/**********************************************************************/

/* fetch the horizontal metrics */

FS_PUBLIC ErrorCode sfac_GetSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usMetricsType,
	uint16 usMetricsTable,
	uint32 ulMetricsOffset,
	uint16 *pusHeight,
	uint16 *pusWidth,
	int16 *psLSBearingX,
	int16 *psLSBearingY,
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY, /* NEW */
	uint16 *pusAdvanceWidth,
	uint16 *pusAdvanceHeight,  /* NEW */
   	boolean *pbHorMetricsFound, /* NEW */
   	boolean *pbVertMetricsFound ) /* NEW */
{
	const uint8     *pbyTable;
	uint32          ulTableLength;
	sfnt_tableIndex TableIndex;
	ErrorCode       ReturnCode;

	*pbHorMetricsFound = FALSE;                        /* default */
	*pbVertMetricsFound = FALSE;                        /* default */

	if (usMetricsTable == SBIT_BDAT_TABLE)          /* if metrics in bdat */
	{
		TableIndex = sfnt_BitmapData;
	}
	else                                            /* if metrics in bloc */
	{
		TableIndex = sfnt_BitmapLocation;
	}
	if (usMetricsType == SBIT_BIG_METRICS)          /* if both h & v metrics */
	{
		ulTableLength = SIZEOF_SBIT_BIGMETRICS;
	}
	else                                            /* if only h or v metrics */
	{
		ulTableLength = SIZEOF_SBIT_SMALLMETRICS;
	}

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		ulMetricsOffset,                            /* metrics start */
		ulTableLength,                              /* read just metrics */
		TableIndex,                                 /* registered tag */
		TRUE,                                       /* should be there */
		(const void**)&pbyTable );                  /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;

/*  for horizontal metrics, offsets could be different for big & small */

	*pusHeight = (uint16)pbyTable[SFNT_SBIT_HEIGHT];
	*pusWidth = (uint16)pbyTable[SFNT_SBIT_WIDTH];

	if (usMetricsType == SBIT_BIG_METRICS)          /* if both h & v metrics */
	{
    	*psLSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGX]));
    	*psLSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGY]));
    	*pusAdvanceWidth = (uint16)pbyTable[SFNT_SBIT_ADVANCE];
    	*psTopSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_VERTBEARINGX]));
    	*psTopSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_VERTBEARINGY]));
    	*pusAdvanceHeight = (uint16)pbyTable[SFNT_SBIT_VERTADVANCE];
		*pbHorMetricsFound = TRUE;                        
		*pbVertMetricsFound = TRUE;                     
	}
	else if (usMetricsType == SBIT_HORIZ_METRICS)   
	{
    	*psLSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGX]));
    	*psLSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGY]));
    	*pusAdvanceWidth = (uint16)pbyTable[SFNT_SBIT_ADVANCE];
		*pbHorMetricsFound = TRUE;                        
	}
	else /* if (usMetricsType == SBIT_VERT_METRICS) */  
	{
    	*psTopSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGX]));
    	*psTopSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGY]));
    	*pusAdvanceHeight = (uint16)pbyTable[SFNT_SBIT_ADVANCE];
		*pbVertMetricsFound = TRUE;                     
	}

	RELEASESFNTFRAG(pClientInfo, pbyTable);

	return NO_ERR;
}

/**********************************************************************/

/* shave the white space from horizontal metrics for bitmap format 5 */

#define     ROWSIZE     16                      /* 16 bytes = 128 bits max */

FS_PUBLIC ErrorCode sfac_ShaveSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
    uint32 ulBitmapLength,
	uint16 usBitDepth,
	uint16 *pusHeight,
	uint16 *pusWidth,
    uint16 *pusShaveLeft,
    uint16 *pusShaveRight,
    uint16 *pusShaveTop,  /* NEW */
    uint16 *pusShaveBottom,  /* NEW */
	int16 *psLSBearingX,
	int16 *psLSBearingY, /* NEW */
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY) /* NEW */
{
    uint8           abyBitRow[ROWSIZE];         /* or bitmap into one row */
	const uint8     *pbyTable;
	const uint8     *pbyBdat;
    uint8           *pbyBitMap;
    uint8           byMask;
    uint8           byUpMask;
    uint8           byLowMask;
	uint16          usBitData;
	uint16          usFreshBits;
	uint16       	usOutBits;
	uint16       	usRow;
	uint16       	usStopBit;
    uint16          usShaveLeft;
    uint16          usShaveRight;
    uint16          usShaveTop;
    uint16          usShaveBottom;
	uint16          usStart;
	ErrorCode       ReturnCode;
	boolean			bWeGotBlackPixels;				/* used in vertical shaving */
	uint8			byBlackPixelsInCurrentRaw;		/* used in vertical shaving */
	uint8			byTempBuffer;		/* temporary buffer used to detect the first/last row containing black pixels */

    *pusShaveLeft = 0;                          /* defaults */
    *pusShaveRight = 0;
    *pusShaveTop = 0;                          /* defaults */
    *pusShaveBottom = 0;

    if (usBitmapFormat != 5)                    /* if not constant metrics data */
    {
        return NO_ERR;
    }

    if ((*pusWidth * usBitDepth) > (ROWSIZE << 3))
    {
    	return NO_ERR;                          /* punt huge bitmaps */
    }
    
    MEMSET(abyBitRow, 0, ROWSIZE);              /* clear to zeros */

/*      read the bitmap data    */

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                            /* callback etc. */
		ulBitmapOffset,                         /* metrics start */
		ulBitmapLength,                         /* read bitmap data */
		sfnt_BitmapData,                        /* registered tag */
		TRUE,                                   /* should be there */
		(const void**)&pbyTable );              /* data pointer */

	if (ReturnCode != NO_ERR) return ReturnCode;

	pbyBdat = pbyTable;
	usBitData = 0;                              /* up to 16 bits of bdat */
	usFreshBits = 0;                            /* read & unwritten */

	bWeGotBlackPixels = FALSE;					/* used for vertical shaving */
	usShaveTop = 0;
	usShaveBottom = 0;


/*      'or' the bitmap data into a single row    */    
	usRow = *pusHeight;

    while (usRow > 0)
	{
		pbyBitMap = abyBitRow;
		usOutBits = *pusWidth * usBitDepth;
		usStopBit = 8;
		byBlackPixelsInCurrentRaw = 0;

		while (usOutBits > 0)                   /* if more to do */
		{
			if (usFreshBits < 8)                /* if room for fresh data */
			{
				usBitData <<= 8;
                if (ulBitmapLength > 0)         /* prevent read past data end */
                {
                    usBitData |= (uint16)*pbyBdat++;
                    ulBitmapLength--;
                }
				usFreshBits += 8;
			}
			
			if (usStopBit > usOutBits)
			{
				usStopBit = usOutBits;
			}
			byMask = achStopMask[usStopBit];
			
			byTempBuffer = (uint8)((usBitData >> (usFreshBits - 8)) & byMask);

			byBlackPixelsInCurrentRaw |= byTempBuffer;

			*pbyBitMap++ |= byTempBuffer;

			usFreshBits -= usStopBit;
			usOutBits -= usStopBit;
		}
		if (byBlackPixelsInCurrentRaw != 0)
		{
			bWeGotBlackPixels = TRUE;
			usShaveBottom = usRow-1;
		}
		if (!bWeGotBlackPixels) usShaveTop ++;
        usRow--;
	}

	if (usShaveTop == *pusHeight)
	{
		/* the bitmap is completely white */
		usShaveTop = 0;
		usShaveBottom = 0;
	}

	RELEASESFNTFRAG(pClientInfo, pbyTable);

/*      calculate white space on the left    */
    
    pbyBitMap = abyBitRow;
	if (usBitDepth == 1)
	{
		byUpMask = 0x80;
		byLowMask = 0x01;
	} else if (usBitDepth == 2)
	{
		byUpMask = 0xC0;
		byLowMask = 0x03;
	} else if (usBitDepth == 4)
	{
		byUpMask = 0xF0;
		byLowMask = 0x0F;
	} else /* usBitDepth == 8 */
	{
		byUpMask = 0xFF;
		byLowMask = 0xFF;
	}
	byMask = byUpMask;
    usShaveLeft = 0;

    while ((*pbyBitMap & byMask) == 0)
    {
        usShaveLeft++;
        if (usShaveLeft == *pusWidth)
        {
            return NO_ERR;          /* no black found, don't shave */
        }
        byMask >>= usBitDepth;
        if (byMask == 0)
        {
            byMask = byUpMask;
            pbyBitMap++;
        }
    }

/*      calculate white space on the right    */
    
    usStart = (*pusWidth - 1) * usBitDepth;
    pbyBitMap = &abyBitRow[usStart >> 3];
    byMask = byUpMask >> (usStart & 0x0007);
    usShaveRight = 0;
    
    while ((*pbyBitMap & byMask) == 0)
    {
        usShaveRight++;
        if (byMask == byUpMask)
        {
            byMask = byLowMask;
            pbyBitMap--;
        }
        else
        {
            byMask <<= usBitDepth;
        }
    }

/*      correct the width and sidebearing    */

    *pusShaveLeft = usShaveLeft;
    *pusShaveRight = usShaveRight;
    *pusWidth -= usShaveLeft + usShaveRight;
    *psLSBearingX += (int16)usShaveLeft;
    *psTopSBearingX += (int16)usShaveLeft;

	*pusShaveTop = usShaveTop;
    *pusShaveBottom = usShaveBottom;
    *pusHeight -= usShaveTop + usShaveBottom;
    *psLSBearingY -= (int16)usShaveTop;
    *psTopSBearingY -= (int16)usShaveTop;

	return NO_ERR;
}


/**********************************************************************/


/* fetch the bitmap */

/*  Currently supporting the following bdat formats:
	
	1 - Small metrics;  Byte aligned data
	2 - Small metrics;  Bit aligned data
	5 - Const metrics;  Bit aligned data
	6 - Big metrics;    Byte aligned data
	7 - Big metrics;    Bit aligned data
	8 - Small metrics;  Composite data
	9 - Big metrics;    Composite data
*/

FS_PUBLIC ErrorCode sfac_GetSbitBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 usHeight,
	uint16 usWidth,
    uint16 usShaveLeft,                             /* for white space in fmt 5 */
    uint16 usShaveRight,
    uint16 usShaveTop, /* NEW */
    uint16 usShaveBottom,  /* NEW */
	uint16 usXOffset,
	uint16 usYOffset,
	uint16 usDstRowBytes,
	uint16 usBitDepth,
	uint8 *pbyBitMap, 
	uint16 *pusCompCount )
{
	const uint8     *pbyTable;
	const uint8     *pbyBdat;
	uint8           *pbyBitRow;                     /* start of bitmap row */

	uint16          usSrcRowBytes;                  /* bytes per row in bdat */
	ErrorCode       ReturnCode;

	uint16          usBitData;                      /* bdat data read into 16 bits */
	uint16          usOutBits;                      /* num of bits to put to bitmap */
	uint16          usCount;
	uint16          usXOffBytes;
	uint16          usXOffBits;
	uint16          usStartBit;
	uint16          usStopBit;
	int16           sFreshBits;                     /* num of bits read not written */
	uint8           byMask;                         /* for partial bytes */
	
	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		ulBitmapOffset,                             /* metrics start */
		ulBitmapLength,                             /* read bitmap data */
		sfnt_BitmapData,                            /* registered tag */
		TRUE,                                       /* should be there */
		(const void**)&pbyTable );                  /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;

	pbyBdat = pbyTable;
	*pusCompCount = 0;                              /* usual case */
	
	pbyBitRow = pbyBitMap + (usDstRowBytes * usYOffset);
	usXOffBytes = (usXOffset * usBitDepth) >> 3;
	usXOffBits = (usXOffset * usBitDepth) & 0x07;

	switch(usBitmapFormat)
	{
	case 1:                                         /* byte aligned */
	case 6:
		
		usSrcRowBytes = ((usWidth * usBitDepth) + 7) / 8;

		if (usXOffBits == 0)                         /* if byte aligned */
		{
			while (usHeight > 0)
			{
				pbyBitMap = pbyBitRow + usXOffBytes;    /* adjust left */

				for (usCount = 0; usCount < usSrcRowBytes; usCount++)
				{
					*pbyBitMap++ |= *pbyBdat++;
				}
				pbyBitRow += usDstRowBytes;
				usHeight--;
			}
		}
		else                                        /* if offset in x */
		{
			while (usHeight > 0)
			{
				pbyBitMap = pbyBitRow + usXOffBytes;    /* adjust left */
				usBitData = 0;

				for (usCount = 0; usCount < usSrcRowBytes; usCount++)
				{
					usBitData |= (uint16)*pbyBdat++;
					*pbyBitMap++ |= (usBitData >> usXOffBits) & 0x00FF;
					usBitData <<= 8;
				}
				*pbyBitMap |= (usBitData >> usXOffBits) & 0x00FF;
							 
				pbyBitRow += usDstRowBytes;
				usHeight--;
			}
		}
		break;
	
	case 2:                                         /* bit aligned data */
	case 5:
	case 7:
		
		usBitData = 0;                              /* up to 16 bits of bdat */
		sFreshBits = 0;                             /* read & unwritten */
	
		usHeight += usShaveTop;

		while (usHeight > 0)                        /* for each row */
		{
			pbyBitMap = pbyBitRow + usXOffBytes;    /* adjust left */
			usOutBits = usWidth * usBitDepth;
			usStartBit = usXOffBits;
			usStopBit = 8;
			sFreshBits -= (int16)usShaveLeft * usBitDepth;       /* skip the left white bits */

			while (usOutBits > 0)                   /* if more to do */
			{
				while (sFreshBits < 8)              /* if room for fresh data */
				{
					usBitData <<= 8;
					if (ulBitmapLength > 0)         /* prevent read past data end */
					{
						usBitData |= (uint16)*pbyBdat++;
						ulBitmapLength--;
					}
					sFreshBits += 8;
				}
				
				if (usStopBit > usOutBits + usStartBit)
				{
					usStopBit = usStartBit + usOutBits;
				}
				byMask = achStartMask[usStartBit] & achStopMask[usStopBit];
				
				*pbyBitMap++ |= (uint8)((usBitData >> (sFreshBits + (int16)usStartBit - 8)) & byMask);

				sFreshBits -= (int16)(usStopBit - usStartBit);
				usOutBits -= usStopBit - usStartBit;
				usStartBit = 0;
			}
			sFreshBits -= (int16)usShaveRight*usBitDepth;      /* skip the right white bits */

			if (usShaveTop == 0)
			{
				pbyBitRow += usDstRowBytes;             /* next row */
			} else {
				usShaveTop --;
			}
			usHeight--;
		}
		break;
	
	case 3:                                         /* various */
	case 4:
		break;
	
	case 8:                                         /* composites */
	case 9:                                         /* just return count */
		
		*pusCompCount = (uint16)SWAPW(*((uint16*)&pbyBdat[SFNT_BDAT_COMPCOUNT]));
		break;
	
	default:
		Assert(FALSE);
		break;
	}

	RELEASESFNTFRAG(pClientInfo, pbyTable);
	return NO_ERR;
}

/**********************************************************************/

FS_PUBLIC ErrorCode sfac_GetSbitComponentInfo (
	sfac_ClientRec *pClientInfo,
	uint16 usComponent,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 *pusCompGlyphCode,
	uint16 *pusCompXOffset,
	uint16 *pusCompYOffset
)
{
	const uint8 *   pbyBdat;
	ErrorCode       ReturnCode;

	
	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		ulBitmapOffset,                             /* metrics start */
		ulBitmapLength,                             /* read bitmap data */
		sfnt_BitmapData,                            /* registered tag */
		TRUE,                                       /* should be there */
		(const void**)&pbyBdat );                   /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;

	pbyBdat += SFNT_BDAT_FIRSTCOMP + (SIZEOF_SBIT_BDATCOMPONENT * usComponent);
		
	*pusCompGlyphCode = (uint16)SWAPW(*((uint16*)&pbyBdat[SFNT_BDAT_COMPGLYPH]));
	*pusCompXOffset = (uint16)pbyBdat[SFNT_BDAT_COMPXOFF];
	*pusCompYOffset = (uint16)pbyBdat[SFNT_BDAT_COMPYOFF];

	RELEASESFNTFRAG(pClientInfo, pbyBdat);

	return NO_ERR;
}

/**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\stat.h ===
/*********************************************************************/
/*                                                                   */
/*    stat.h -- stat.asm exports                                     */
/*                                                                   */
/*    (c) Copyright 1992  Microsoft Corp.  All rights reserved.      */
/*                                                                   */
/*     4/9/96  claudebe adding profiling with IceCAP                 */
/*     2/26/93 deanb    macros come back                             */
/*     2/22/93 deanb    timing switch moved to fsconfig.h macros     */
/*     2/11/93 deanb    __cdecl's for ms C8                          */
/*    12/22/92 deanb    Apple types                                  */
/*    11/20/92 deanb    Timing switches revised                      */
/*    11/17/92 deanb    First cut                                    */
/*                                                                   */
/*********************************************************************/

/* STAT Card Timing Switches */

#ifdef FSCFG_USESTATCARD         /* compile option for profiling */
  #define STAT_ON               gbTimer = TRUE; StartSample();
  #define STAT_OFF              StopSample(); gbTimer = FALSE;
  #define STAT_ON_CALLBACK      if (gbTimer) StartSample();
  #define STAT_OFF_CALLBACK     if (gbTimer) StopSample();
#elif FSCFG_USEICECAP          /* compile option for profiling with IceCAP */
//#include <ICAPExp.h>
  #define STAT_ON               gbTimer = TRUE; StartCAP();
  #define STAT_OFF              StopCAP(); gbTimer = FALSE;
  #define STAT_ON_CALLBACK      if (gbTimer) ResumeCAP();
  #define STAT_OFF_CALLBACK     if (gbTimer) SuspendCAP();
#else
  #define STAT_ON
  #define STAT_OFF
  #define STAT_ON_CALLBACK
  #define STAT_OFF_CALLBACK
#endif

#if 1

#define STAT_ON_NEWSFNT         STAT_ON
#define STAT_OFF_NEWSFNT        STAT_OFF
#define STAT_ON_NEWTRAN         STAT_ON
#define STAT_OFF_NEWTRAN        STAT_OFF
#define STAT_ON_NEWGLYPH        STAT_ON
#define STAT_OFF_NEWGLYPH       STAT_OFF
#define STAT_ON_GRIDFIT         STAT_ON
#define STAT_OFF_GRIDFIT        STAT_OFF
#define STAT_ON_FINDBMS         STAT_ON
#define STAT_OFF_FINDBMS        STAT_OFF
#define STAT_ON_SCAN            STAT_ON
#define STAT_OFF_SCAN           STAT_OFF
#define STAT_ON_FNTEXEC         
#define STAT_OFF_FNTEXEC        
#define STAT_ON_IUP
#define STAT_OFF_IUP
#define STAT_ON_CALCORIG
#define STAT_OFF_CALCORIG

#else

#define STAT_ON_NEWSFNT
#define STAT_OFF_NEWSFNT
#define STAT_ON_NEWTRAN
#define STAT_OFF_NEWTRAN
#define STAT_ON_NEWGLYPH
#define STAT_OFF_NEWGLYPH
#define STAT_ON_GRIDFIT         STAT_ON         
#define STAT_OFF_GRIDFIT        STAT_OFF         
#define STAT_ON_FINDBMS   
#define STAT_OFF_FINDBMS  
#define STAT_ON_SCAN            
#define STAT_OFF_SCAN           
#define STAT_ON_FNTEXEC
#define STAT_OFF_FNTEXEC
#define STAT_ON_IUP
#define STAT_OFF_IUP
#define STAT_ON_CALCORIG
#define STAT_OFF_CALCORIG

#endif

/*********************************************************************/

/*              Global timing variable                               */

/*********************************************************************/

extern boolean gbTimer;                /* set true when timer running */

/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/


#ifdef FSCFG_USESTATCARD         /* compile option for profiling */

uint16 __cdecl  InitStat( void );

uint16 __cdecl  ConfigElapsed( void );

uint16 __cdecl  ConfigSample( void );

uint16 __cdecl  StartElapsed( void );

uint16 __cdecl  StartSample( void );

uint32 __cdecl  ReadElapsed( void );

uint32 __cdecl  ReadSample( void );

uint16 __cdecl  ReadSample_Count( void );

uint16 __cdecl  StopElapsed( void );

uint16 __cdecl  StopSample( void );

uint16 __cdecl  ResetElapsed( void );

uint16 __cdecl  ResetSample( void );

#endif  /* FSCFG_USESTATCARD */

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\sfntaccs.h ===
/*
	File:       private sfnt.h

	Contains:   xxx put contents here xxx

	Written by: xxx put writers here xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1997. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

		<>       02/21/97   CB      ClaudeBe, scaled component in composite glyphs
		<>       12/14/95   CB      add advance height to sfac_ReadGlyphMetrics
		<3+>     7/17/90    MR      Change return types to in for computemapping and readsfnt
		 <3>     7/14/90    MR      changed SQRT to conditional FIXEDSQRT2
		 <2>     7/13/90    MR      Change parameters to ReadSFNT and ComputeMapping
		<1+>     4/18/90    CL      
		 <1>     3/21/90    EMT     First checked in with Mike Reed's blessing.

	To Do:
*/

#include    "sfnt.h"

/* EXPORTED DATA TYPES */

typedef struct {
  uint32    ulOffset;
  uint32    ulLength;
} sfac_OffsetLength;

typedef struct sfac_ClientRec *sfac_ClientRecPtr;

typedef uint16 (*MappingFunc) (const uint8 *, uint16 , sfac_ClientRecPtr);

typedef struct sfac_ClientRec {
	ClientIDType        lClientID;          /* User ID Number                           */
	GetSFNTFunc         GetSfntFragmentPtr; /* User function to eat sfnt                */
	ReleaseSFNTFunc     ReleaseSfntFrag;    /* User function to relase sfnt             */
	int16               sIndexToLocFormat;  /* Format of loca table                     */
	uint32              ulMapOffset;        /* Offset to platform mapping data          */
	sfac_OffsetLength   TableDirectory[sfnt_NUMTABLEINDEX]; /* Table offsets/lengths    */
	uint16              usNumberOf_LongHorMetrics; /* Number of entries in hmtx table   */
	uint16              usNumLongVertMetrics;      /* number of entries with AH         */
	boolean				bValidNumLongVertMetrics; /* true if 'vhea' table exist         */
    uint16              usMappingFormat;    /* format code (0,2,4,6) for mapping func   */
	MappingFunc			GlyphMappingF;		/* mapping function char to glyph			*/
	uint16              usGlyphIndex;       /* Current glyph index                      */
	uint16				usFormat4SearchRange; /* Format 4 cached SearchRange			*/
	uint16				usFormat4EntrySelector; /* Format 4 cached EntrySelector		*/
	uint16				usFormat4RangeShift;/* Format 4 cached Range Shift				*/
	/* value for sDefaultAscender and sDefaultDescender comes from TypoAscender and     */
	/* TypoDescender from 'OS/2', if the 'OS/2' is missing, alternate values comes from */
	/* the horizontal header Ascender and Descender                                     */
	int16				sDefaultAscender;
	int16				sDefaultDescender;
	int16				sWinDescender;
} sfac_ClientRec;


/* It would be great if we could make this an opaque data type
// But in this case, the ownership of the memory for the data is the
// responsibility of the owner module. (i.e. sfntaccs.c) This adds
// complications to our model (read: it is much easier to allocate the
// data off the stack of the caller) so we won't implement this for now.
*/

/*  Glyph Handle -- Used for access to glyph data in 'glyf' table   */

typedef struct {
	 const void *     pvGlyphBaseAddress; /* Base address of glyph, needed for Release */
	 const void *     pvGlyphNextAddress; /* Current position in glyph                    */
	 const void *     pvGlyphEndAddress; /* End address of glyph, used to catch glyph corruption */
} sfac_GHandle;

/*  ComponentTypes -- Method used for positioning component in composite    */

typedef enum {
	AnchorPoints,
	OffsetPoints,
	Undefined
} sfac_ComponentTypes;

/* MACROS */

#define SFAC_LENGTH(ClientInfo,Table)  ClientInfo->TableDirectory[(int)Table].ulLength

/* PUBLIC PROTOTYPE CALLS */

/*
 * Creates mapping for finding offset table
 */

FS_PUBLIC ErrorCode sfac_DoOffsetTableMap (
	sfac_ClientRec *    ClientInfo);    /* Sfnt Client information  */

FS_PUBLIC ErrorCode sfac_ComputeMapping (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information      */
	uint16              usPlatformID,   /* Platform Id used for mapping */
	uint16              usSpecificID);  /* Specific Id used for mapping */

FS_PUBLIC ErrorCode sfac_GetGlyphIndex(
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16              usCharacterCode);   /* Character code to be mapped  */

FS_PUBLIC ErrorCode sfac_GetMultiGlyphIDs (
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID);        /* Output glyph ID array        */

FS_PUBLIC ErrorCode sfac_GetWin95GlyphIDs (
	uint8 *             pbyCmapSubTable,    /* Pointer to cmap sub table    */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID);        /* Output glyph ID array        */

FS_PUBLIC ErrorCode sfac_GetWinNTGlyphIDs (
    sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
    uint16              numGlyphs,          /* maxp->numGlyphs */
    uint16              usCharCount,        /* Number of chars to convert   */
    uint16              usFirstChar,        /* First char code              */
    uint32              ulCharCodeOffset,   /* Offset to be added to *pulCharCode
                                               before converting            */
    uint32 *            pulCharCode,        /* Pointer to char code list    */
    uint32 *            pulGlyphID);        /* Output glyph ID array        */

FS_PUBLIC ErrorCode sfac_LoadCriticalSfntMetrics(
	 sfac_ClientRec *   ClientInfo,      /* Sfnt Client information     */
	 uint16 *               pusEmResolution,/* Sfnt Em Resolution               */
	 boolean *              pbIntegerScaling,/* Sfnt flag for int scaling   */
	 LocalMaxProfile *  pMaxProfile);    /* Sfnt Max Profile table      */

FS_PUBLIC ErrorCode sfac_ReadGlyphMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information          */
	register uint16     glyphIndex,     /* Glyph number for metrics         */
	uint16 *            pusNonScaledAW, /* Return: Non Scaled Advance Width */
	uint16 *            pusNonScaledAH, /* Return: Non Scaled Advance Height */
	int16 *             psNonScaledLSB,
	int16 *             psNonScaledTSB,
    int16 *             psNonScaledTopOriginX);

FS_PUBLIC ErrorCode sfac_ReadGlyphHorMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information          */
	register uint16     glyphIndex,     /* Glyph number for metrics         */
	uint16 *            pusNonScaledAW, /* Return: Non Scaled Advance Width */
	int16 *             psNonScaledLSB);

FS_PUBLIC ErrorCode sfac_ReadGlyphVertMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information          */
	register uint16     glyphIndex,     /* Glyph number for metrics         */
	uint16 *            pusNonScaledAH, /* Return: Non Scaled Advance Height */
	int16 *             psNonScaledTSB);

FS_PUBLIC ErrorCode sfac_ReadNumLongVertMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information           */
	uint16 *            pusNumLongVertMetrics, /* Entries for which AH exists */
	boolean *           pbValidNumLongVertMetrics ); /* true if 'vhea' table exist  */

FS_PUBLIC ErrorCode sfac_CopyFontAndPrePrograms(
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client Information  */
	char *              pFontProgram,   /* pointer to Font Program  */
	char *              pPreProgram);   /* pointer to Pre Program   */

FS_PUBLIC ErrorCode sfac_CopyCVT(
	sfac_ClientRec *    ClientInfo,     /* Client Information       */
	F26Dot6 *           pCVT);          /* pointer to CVT           */

FS_PUBLIC ErrorCode sfac_CopyHdmxEntry(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	boolean *           bFound,         /* Flag indicating if entry found */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer);      /* Buffer to save glyph sizes */

FS_PUBLIC ErrorCode sfac_GetLTSHEntries(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer);      /* Buffer to save glyph sizes */

FS_PUBLIC ErrorCode sfac_ReadGlyphHeader(
	sfac_ClientRec *    ClientInfo,         /* Client Information           */
	uint16              usGlyphIndex,       /* Glyph index to read          */
	sfac_GHandle *      hGlyph,             /* Return glyph handle          */
	boolean *           pbCompositeGlyph,   /* Is glyph a composite?        */
	boolean *           pbHasOutline,       /* Does glyph have outlines?    */
	int16 *             psNumberOfContours, /* Number of contours in glyph  */
	BBOX *              pbbox);             /* Glyph Bounding box           */

FS_PUBLIC ErrorCode sfac_ReadOutlineData(
	 uint8 *                abyOnCurve,           /* Array of on curve indicators per point  */
	 F26Dot6 *              afxOoy,               /* Array of ooy points for every point         */
	 F26Dot6 *              afxOox,               /* Array of oox points for every point         */
	 sfac_GHandle *     hGlyph,
	 LocalMaxProfile *  maxProfile,       /* MaxProfile Table                                */
	 boolean                bHasOutline,          /* Does glyph have outlines?                   */
	 int16                  sNumberOfContours,  /* Number of contours in glyph               */
	 int16 *                asStartPoints,    /* Array of start points for every contour  */
	 int16 *                asEndPoints,          /* Array of end points for every contour   */
	 uint16 *               pusSizeOfInstructions, /* Size of instructions in bytes          */
	 uint8 **               pbyInstructions,   /* Pointer to start of glyph instructions    */
     uint32*                pCompositePoints,   /* total number of point for composites, to check for overflow */
     uint32*                pCompositeContours);    /* total number of contours for composites, to check for overflow */

FS_PUBLIC ErrorCode sfac_ReadComponentData(
	sfac_GHandle *          hGlyph,
	sfac_ComponentTypes *   pMultiplexingIndicator, /* Indicator for Anchor vs offsets    */
	boolean *               pbRoundXYToGrid,    /* Round composite offsets to grid              */
	boolean *               pbUseMyMetrics,     /* Use component metrics                        */
	boolean *               pbScaleCompositeOffset,   /* Do we scale the composite offset, Apple/MS   */
	boolean *               pbWeHaveInstructions, /* Composite has instructions                 */
	uint16 *                pusComponentGlyphIndex, /* Glyph index of component                 */
	int16 *                 psXOffset,          /* X Offset of component (if app)               */
	int16 *                 psYOffset,          /* Y Offset of component (if app)               */
	uint16 *                pusAnchorPoint1,    /* Anchor point 1 of component (if app)         */
	uint16 *                pusAnchorPoint2,    /* Anchor point 2 of component (if app)         */
	transMatrix             *pMulT,             /* Transformation matrix for component          */
	boolean *				pbWeHaveAScale,     /* We have a scaling in pMulT					*/
	boolean *               pbLastComponent);   /* Is this the last component?                  */

/*  sfac_ReadCompositeInstructions

	Returns pointer to TrueType instructions for composites.

 */

FS_PUBLIC ErrorCode sfac_ReadCompositeInstructions(
	sfac_GHandle *  hGlyph,
	uint8 **        pbyInstructions,    /* Pointer to start of glyph instructions   */
	uint16 *        pusSizeOfInstructions); /* Size of instructions in bytes        */


/*  sfac_ReleaseGlyph

	Called when access to glyph in 'glyf' table is finished.

 */

FS_PUBLIC ErrorCode sfac_ReleaseGlyph(
	sfac_ClientRec *    ClientInfo, /* Sfnt Client Information  */
	sfac_GHandle *      hGlyph);    /* Glyph Handle Information */


/**********************************************************************/

/*      Embedded Bitmap (sbit) Access Routines      */

/**********************************************************************/

#ifndef FSCFG_DISABLE_GRAYSCALE
#define SBIT_BITDEPTH_MASK	0x0116	 /* support sbit with bitDepth of 1, 2, 4 and 8 */
/* SBIT_BITDEPTH_MASK must have the same value as FS_SBIT_BITDEPTH_MASK in fscaler.h */ 
#else

#define SBIT_BITDEPTH_MASK	0x0002	 /* support only sbit with bitDepth of 1 */
/* SBIT_BITDEPTH_MASK must have the same value as FS_SBIT_BITDEPTH_MASK in fscaler.h */ 
#endif


/*      SFNTACCS Export Prototypes for SBIT      */

FS_PUBLIC ErrorCode sfac_SearchForStrike (
	sfac_ClientRec *pClientInfo,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint16 *pusTableState,
	uint16 *pusSubPpemX,
	uint16 *pusSubPpemY,
	uint32 *pulStrikeOffset 
);

FS_PUBLIC ErrorCode sfac_SearchForBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usGlyphCode,
	uint32 ulStrikeOffset,
	boolean *pbGlyphFound,
	uint16 *pusMetricsType,
	uint16 *pusMetricsTable,
	uint32 *pulMetricsOffset,
	uint16 *pusBitmapFormat,
	uint32 *pulBitmapOffset,
	uint32 *pulBitmapLength
);

FS_PUBLIC ErrorCode sfac_GetSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usMetricsType,
	uint16 usMetricsTable,
	uint32 ulMetricsOffset,
	uint16 *pusHeight,
	uint16 *pusWidth,
	int16 *psLSBearingX,
	int16 *psLSBearingY,
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY, /* NEW */
	uint16 *pusAdvanceWidth,
	uint16 *pusAdvanceHeight,  /* NEW */
   	boolean *pbHorMetricsFound, /* NEW */
   	boolean *pbVertMetricsFound /* NEW */
);

FS_PUBLIC ErrorCode sfac_ShaveSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
    uint32 ulBitmapLength,
	uint16 usBitDepth,
	uint16 *pusHeight,
	uint16 *pusWidth,
    uint16 *pusShaveLeft,
    uint16 *pusShaveRight,
    uint16 *pusShaveTop,  /* NEW */
    uint16 *pusShaveBottom,  /* NEW */
	int16 *psLSBearingX,
	int16 *psLSBearingY, /* NEW */
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY /* NEW */
);

FS_PUBLIC ErrorCode sfac_GetSbitBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 usHeight,
	uint16 usWidth,
    uint16 usShaveLeft,
    uint16 usShaveRight,
    uint16 usShaveTop, /* NEW */
    uint16 usShaveBottom,  /* NEW */
	uint16 usXOffset,
	uint16 usYOffset,
	uint16 usRowBytes,
	uint16 usBitDepth,
	uint8 *pbyBitMap, 
	uint16 *pusCompCount
);

FS_PUBLIC ErrorCode sfac_GetSbitComponentInfo (
	sfac_ClientRec *pClientInfo,
	uint16 usComponent,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 *pusCompGlyphCode,
	uint16 *pusCompXOffset,
	uint16 *pusCompYOffset
);


/**********************************************************************/

/*  Results of search for strike's bitmapSizeSubtable   */

#define     SBIT_UN_SEARCHED    0
#define     SBIT_NOT_FOUND      1
#define     SBIT_BLOC_FOUND     2
#define     SBIT_BSCA_FOUND     3

/**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\subpixel.c ===
/*********************************************************************

	  subpixel.c -- sub pixel rendering

	  (c) Copyright 1999-2000  Microsoft Corp.  All rights reserved.

 
**********************************************************************/

/*********************************************************************/

/*        Imports                                                    */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types  */
#include    "scentry.h"             /* for own function prototypes */

#ifdef FSCFG_SUBPIXEL

#ifdef FSCFG_SUBPIXEL_STANDALONE

// this should be considered a temporary solution. currently, the rasterizer is plumbed for 8 bpp output in SubPixel,
// and appears to have John Platt's filter hard-wired in. In the future, we would rather have the overscaled b/w bitmap
// as output, such that we can do any color filtering and gamma correction outside and independent of the rasterizer

// Index values for wRGBColors and awColorIndexTable

#define RED_INDEX	0
#define GREEN_INDEX	1
#define	BLUE_INDEX	2

// The abColorIndexTable datastructure contains one entry for each virtual subpixel.
// We index into this table to determine which color is assigned to that subpixel.
// To create the table, we set the first number of subpixels assigned to red to the red index,
// and likewise for green and blue.

static const uint8 abColorIndexTable[2][RGB_OVERSCALE] = // 2 Tables to indicate color for each subpixel, 0 = RGB striping order, 1 = BGR striping order
	{{RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX,														// R_Subpixels, hard-wired
	  GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,	// G_Subpixels, hard-wired
	  BLUE_INDEX, BLUE_INDEX},																						// B_Subpixels, hard-wired
	 {BLUE_INDEX, BLUE_INDEX,
	  GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,
	  RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX}};

#define PIXEL_ON	1
#define PIXEL_OFF	0
#define CHAR_BIT	8         /* number of bits in a char */

char GetInputPixel( char *pbyInputRowData, uint32 ulWidthIndex )
{
	uint32	ulRowIndex;
	char	byPixelMask;
	
	ulRowIndex = ulWidthIndex / CHAR_BIT;			// Determines which byte to check out
	byPixelMask = 0x80 >> ulWidthIndex % CHAR_BIT; // Determine offset within byte
	return ( (pbyInputRowData[ ulRowIndex ] & byPixelMask)?PIXEL_ON:PIXEL_OFF );
}


FS_PUBLIC void fsc_OverscaleToSubPixel (GlyphBitMap * OverscaledBitmap, boolean bgrOrder, GlyphBitMap * SubPixelBitMap)
{
	char * pbyInputRowData, *pbyOutputRowData;			// Pointer to one scanline of data
	uint32 ulOverscaledBitmapWidth; // Fscaled bitmap widths
	uint32 ulHeightIndex, ulWidthIndex, ulMaxWidthIndex;	// Scanline index and byte pixel index
	char byPixel;						// Contents of one pixel from the rasterizer
	uint16 usRGBColors[ 3 ];				// Contains sum of each color based on number of subpixels
    int16 sBitmapSubPixelStart;     
    uint16 usColorIndex;
    uint32 ulBytes;
	
	// Start processing the bitmap
	// This is the heart of the RGB striping algorithm
	sBitmapSubPixelStart = OverscaledBitmap->rectBounds.left % RGB_OVERSCALE;
    if (sBitmapSubPixelStart < 0)
    {
        sBitmapSubPixelStart += RGB_OVERSCALE;
    }

    ulOverscaledBitmapWidth = OverscaledBitmap->rectBounds.right - OverscaledBitmap->rectBounds.left;
    ulMaxWidthIndex = ulOverscaledBitmapWidth + sBitmapSubPixelStart;

    /* clear the resulting bitmap */
	ulBytes = (uint32)SubPixelBitMap->sRowBytes * (uint32)(SubPixelBitMap->sHiBand - SubPixelBitMap->sLoBand);
	Assert(((ulBytes >> 2) << 2) == ulBytes);

	for ( ulHeightIndex = 0; ulHeightIndex < (uint32)(SubPixelBitMap->sHiBand - SubPixelBitMap->sLoBand); ulHeightIndex++ )
	{
		// Initialize Input to start of current row

		pbyInputRowData = OverscaledBitmap->pchBitMap + (OverscaledBitmap->sRowBytes * ulHeightIndex);
		pbyOutputRowData = SubPixelBitMap->pchBitMap + (SubPixelBitMap->sRowBytes * ulHeightIndex);
				
		// Initialize RGBColors

		usRGBColors[RED_INDEX] = 0;
		usRGBColors[GREEN_INDEX] = 0;
		usRGBColors[BLUE_INDEX] = 0;

		// Walk the scanline from the first subpixel, calculating R,G, & B values

		for( ulWidthIndex = sBitmapSubPixelStart; ulWidthIndex < ulMaxWidthIndex; ulWidthIndex++)
		{
            byPixel = GetInputPixel( pbyInputRowData, ulWidthIndex - sBitmapSubPixelStart );
			FS_ASSERT((byPixel <= 1),"Input Pixel greater than one");
			usRGBColors[abColorIndexTable[bgrOrder][ulWidthIndex % RGB_OVERSCALE]] += byPixel;

			// If we've finished one pixel or the scanline, write out pixel 

			if((( ulWidthIndex % RGB_OVERSCALE ) == (uint32)(RGB_OVERSCALE - 1)) || // Finish one pixel
				ulWidthIndex == ( ulOverscaledBitmapWidth + sBitmapSubPixelStart - 1) ) // Finish row
			{
                /* write out current pixel, 8 bits in range 0 through 179 = (R_Subpixels + 1) * (G_Subpixels + 1) * (B_Subpixels + 1) */

                usColorIndex = usRGBColors[RED_INDEX]   * (G_Subpixels + 1) * (B_Subpixels + 1) +
                               usRGBColors[GREEN_INDEX] * (B_Subpixels + 1) +
                               usRGBColors[BLUE_INDEX];

                        FS_ASSERT((usColorIndex < 256),"Resulting pixel doesn't fit in a byte");

                *pbyOutputRowData = (char) usColorIndex;
                pbyOutputRowData++;
				usRGBColors[RED_INDEX] = 0;
				usRGBColors[GREEN_INDEX] = 0;
				usRGBColors[BLUE_INDEX] = 0;
            }
		}
	}
}

#else // !FSCFG_SUBPIXEL_STANDALONE


#define CHAR_BIT      8         /* number of bits in a char */

unsigned char ajRGBToWeight222[64] = {
    0,1,1,2,4,5,5,6,4,5,5,6,8,9,9,10,
    16,17,17,18,20,21,21,22,20,21,21,22,24,25,25,26,
    16,17,17,18,20,21,21,22,20,21,21,22,24,25,25,26,
    32,33,33,34,36,37,37,38,36,37,37,38,40,41,41,42};

    unsigned char ajRGBToWeightMask[CHAR_BIT] = { 
        0xFC, 0x7E, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01};

FS_PUBLIC void fsc_OverscaleToSubPixel (GlyphBitMap * OverscaledBitmap, boolean bgrOrder, GlyphBitMap * SubPixelBitMap)
{
	char * pbyInputRowData, *pbyOutputRowData;			// Pointer to one scanline of data
	uint32 ulOverscaledBitmapWidth; // Fscaled bitmap widths
	uint32 ulHeightIndex, ulWidthIndex, ulMaxWidthIndex;	// Scanline index and byte pixel index
    int16 sBitmapSubPixelStart;     
    uint16 usColorIndex;

    uint16 usSubPixelIndex;
    int16 uSubPixelRightShift, uSubPixelLeftShift;
    char * pbyInputEndRowData;


	// Start processing the bitmap
	// This is the heart of the RGB striping algorithm
	sBitmapSubPixelStart = OverscaledBitmap->rectBounds.left % RGB_OVERSCALE;
    if (sBitmapSubPixelStart < 0)
    {
        sBitmapSubPixelStart += RGB_OVERSCALE;
    }

    ulOverscaledBitmapWidth = OverscaledBitmap->rectBounds.right - OverscaledBitmap->rectBounds.left;
    ulMaxWidthIndex = (uint32)(SubPixelBitMap->rectBounds.right - SubPixelBitMap->rectBounds.left);

	for ( ulHeightIndex = 0; ulHeightIndex < (uint32)(SubPixelBitMap->sHiBand - SubPixelBitMap->sLoBand); ulHeightIndex++ )
	{
		// Initialize Input to start of current row

		pbyInputRowData = OverscaledBitmap->pchBitMap + (OverscaledBitmap->sRowBytes * ulHeightIndex);
        pbyInputEndRowData = pbyInputRowData + OverscaledBitmap->sRowBytes;
		pbyOutputRowData = SubPixelBitMap->pchBitMap + (SubPixelBitMap->sRowBytes * ulHeightIndex);
				

        /* do the first partial byte : */

        usColorIndex = (unsigned char)(*pbyInputRowData) >> (sBitmapSubPixelStart + (8 - RGB_OVERSCALE));
        usColorIndex = ajRGBToWeight222[usColorIndex];

        *pbyOutputRowData = (char) usColorIndex;

        pbyOutputRowData++;

        usSubPixelIndex = (CHAR_BIT + RGB_OVERSCALE - sBitmapSubPixelStart) % CHAR_BIT;

		// Walk the scanline from the first subpixel, calculating R,G, & B values

		for( ulWidthIndex = 1; ulWidthIndex < ulMaxWidthIndex; ulWidthIndex++)
		{
            uSubPixelLeftShift = 0;
            uSubPixelRightShift = CHAR_BIT - RGB_OVERSCALE - usSubPixelIndex;
            if (uSubPixelRightShift < 0) 
            {
                uSubPixelLeftShift = - uSubPixelRightShift;
                uSubPixelRightShift = 0;
            }

            usColorIndex = ((unsigned char)(*pbyInputRowData) & ajRGBToWeightMask[usSubPixelIndex]) >> uSubPixelRightShift << uSubPixelLeftShift;

            if (pbyInputRowData+1 < pbyInputEndRowData)
            {
                /* avoid reading too far for the partial pixel at the end */
                uSubPixelRightShift = CHAR_BIT + CHAR_BIT - RGB_OVERSCALE - usSubPixelIndex;

                usColorIndex += (unsigned char)(*(pbyInputRowData+1)) >> uSubPixelRightShift;
            }
            usColorIndex = ajRGBToWeight222[usColorIndex];

            *pbyOutputRowData = (char) usColorIndex;

            pbyOutputRowData++;

            usSubPixelIndex = (usSubPixelIndex + RGB_OVERSCALE);
            if (usSubPixelIndex >= CHAR_BIT)
            {
                usSubPixelIndex = usSubPixelIndex % CHAR_BIT;
                pbyInputRowData ++;
            }
		}
	}
}

#endif // FSCFG_SUBPIXEL_STANDALONE

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\sfnt_en.h ===
/*
	File:       sfnt_en.h

	Written by: Mike Reed

	Copyright:  c 1989-1990 by Apple Computer, Inc., all rights reserved.

	Change History (most recent first):

		<8+>     7/16/90    MR      Fixed INTEL version of tag_GlyphData
		 <8>     7/16/90    MR      Conditionalize redefinition of script codes
		 <7>     7/13/90    MR      Conditionalize enums to allow for byte-reversal on INTEL chips
		 <6>     6/30/90    MR      Remove tag reference to 'mvt ' and 'cryp'
		 <4>     6/26/90    MR      Add all script codes, with SM naming conventions
		 <3>     6/20/90    MR      Change tag enums to #defines to be ansi-correct
		 <2>      6/1/90    MR      Add postscript name to sfnt_NameIndex and 'post' to tags.
	To Do:
*/

#ifndef SFNT_ENUMS

#define SFNT_ENUMS

typedef enum {
	plat_Unicode,
	plat_Macintosh,
	plat_ISO,
	plat_MS
} sfnt_PlatformEnum;

#ifndef __SCRIPT__
typedef enum {
	smRoman,
	smJapanese,
	smTradChinese,
	smChinese = smTradChinese,
	smKorean,
	smArabic,
	smHebrew,
	smGreek,
	smCyrillic,
	smRussian = smCyrillic,
	smRSymbol,
	smDevanagari,
	smGurmukhi,
	smGujarati,
	smOriya,
	smBengali,
	smTamil,
	smTelugu,
	smKannada,
	smMalayalam,
	smSinhalese,
	smBurmese,
	smKhmer,
	smThai,
	smLaotian,
	smGeorgian,
	smArmenian,
	smSimpChinese,
	smTibetan,
	smMongolian,
	smGeez,
	smEthiopic = smGeez,
	smAmharic = smGeez,
	smSlavic,
	smEastEurRoman = smSlavic,
	smVietnamese,
	smExtArabic,
	smSindhi = smExtArabic,
	smUninterp
} sfnt_ScriptEnum;
#endif

typedef enum {
	lang_English,
	lang_French,
	lang_German,
	lang_Italian,
	lang_Dutch,
	lang_Swedish,
	lang_Spanish,
	lang_Danish,
	lang_Portuguese,
	lang_Norwegian,
	lang_Hebrew,
	lang_Japanese,
	lang_Arabic,
	lang_Finnish,
	lang_Greek,
	lang_Icelandic,
	lang_Maltese,
	lang_Turkish,
	lang_Yugoslavian,
	lang_Chinese,
	lang_Urdu,
	lang_Hindi,
	lang_Thai
} sfnt_LanguageEnum;

typedef enum {
	name_Copyright,
	name_Family,
	name_Subfamily,
	name_UniqueName,
	name_FullName,
	name_Version,
	name_Postscript
} sfnt_NameIndex;

typedef uint32 sfnt_TableTag;

#define tag_CharToIndexMap      0x636d6170        /* 'cmap' */
#define tag_ControlValue        0x63767420        /* 'cvt ' */
#define tag_BitmapData          0x45424454        /* 'EBDT' */
#define tag_BitmapLocation      0x45424c43        /* 'EBLC' */
#define tag_BitmapScale         0x45425343        /* 'EBSC' */
#define tag_Editor0             0x65647430        /* 'edt0' */
#define tag_Editor1             0x65647431        /* 'edt1' */
#define tag_Encryption          0x63727970        /* 'cryp' */
#define tag_FontHeader          0x68656164        /* 'head' */
#define tag_FontProgram         0x6670676d        /* 'fpgm' */
#define tag_GridfitAndScanProc	0x67617370		  /* 'gasp' */
#define tag_GlyphDirectory      0x67646972        /* 'gdir' */
#define tag_GlyphData           0x676c7966        /* 'glyf' */
#define tag_HoriDeviceMetrics   0x68646d78        /* 'hdmx' */
#define tag_HoriHeader          0x68686561        /* 'hhea' */
#define tag_HorizontalMetrics   0x686d7478        /* 'hmtx' */
#define tag_IndexToLoc          0x6c6f6361        /* 'loca' */
#define tag_Kerning             0x6b65726e        /* 'kern' */
#define tag_LinearThreshold     0x4c545348        /* 'LTSH' */
#define tag_MaxProfile          0x6d617870        /* 'maxp' */
#define tag_NamingTable         0x6e616d65        /* 'name' */
#define tag_OS_2                0x4f532f32        /* 'OS/2' */
#define tag_Postscript          0x706f7374        /* 'post' */
#define tag_PreProgram          0x70726570        /* 'prep' */
#define tag_VertDeviceMetrics	0x56444d58		  /* 'VDMX' */
#define tag_VertHeader	        0x76686561		  /* 'vhea' */
#define tag_VerticalMetrics     0x766d7478		  /* 'vmtx' */

#define tag_TTO_GSUB     		0x47535542		  /* 'GSUB' */
#define tag_TTO_GPOS     		0x47504F53		  /* 'GPOS' */
#define tag_TTO_GDEF     		0x47444546		  /* 'GDEF' */
#define tag_TTO_BASE     		0x42415345		  /* 'BASE' */
#define tag_TTO_JSTF     		0x4A535446		  /* 'JSTF' */

#endif      /* not sfnt_enums */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\dbg.c ===
/******************************Module*Header*******************************\
* Module Name: dbg.c
*
* several debug routines
*
* Created: 20-Feb-1992 16:00:36
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
*
\**************************************************************************/

#include "fd.h"
#include "fdsem.h"


#if DBG


VOID
TtfdDbgPrint(
    PCHAR DebugMessage,
    ...
    )
{

  /*TERSE*/ VERBOSE((DebugMessage));

}




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\cvt.h ===
/******************************Module*Header*******************************\
* Module Name: cvt.h
*
* function declarations that are private to cvt.c
*
* Created: 26-Nov-1990 17:39:35
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
\**************************************************************************/


BOOL bGetTagIndex
(
    ULONG   ulTag,      // tag
    INT   * piTable,    // index into a table
    BOOL  * pbRequired  // requred or optional table
);

BOOL bGrabXform
(
    PFONTCONTEXT    pfc,
    USHORT          usOverScale,
    BOOL            bBitmapEmboldening,
    Fixed           subPosX,
    Fixed           subPosY
);


typedef struct _GMC  // Glyph Metrics Corrections
{

    ULONG cxCor;
    ULONG cyCor;


} GMC, *PGMC;

#define FL_SKIP_IF_BITMAP  1
#define FL_FORCE_UNHINTED  2

// iMode is used in the case the user select a specific overScale (QFD_TT_GRAY1_BITMAP to QFD_TT_GRAY8_BITMAP)
// to be able to set the overScale in the font context correctely

FONTCONTEXT *ttfdOpenFontContext (
    FONTOBJ *pfo
    );

#if DBG
#define IS_GRAY(p) ((((p)->flFontType & FO_CHOSE_DEPTH) ? \
    0 : TtfdDbgPrint("Level Not chosen yet\n")) ,(p)->flFontType & FO_GRAYSCALE)
#else
#define IS_GRAY(p) ((p)->flFontType & FO_GRAYSCALE)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\sfntoff.h ===
#define BIGDATE_BC      0
#define BIGDATE_AD      4
#define SIZEOF_BIGDATE  8

#define BBOX_XMIN   0
#define BBOX_YMIN   2
#define BBOX_XMAX   4
#define BBOX_YMAX   6
#define SIZEOF_BBOX 8

#define SFNT_DIRECTORYENTRY_TAG         0
#define SFNT_DIRECTORYENTRY_CHECKSUM    4
#define SFNT_DIRECTORYENTRY_TABLEOFFSET 8
#define SFNT_DIRECTORYENTRY_TABLELENGTH 12
#define SIZEOF_SFNT_DIRECTORYENTRY      16

#define SFNT_OFFSETTABLE_VERSION        0
#define SFNT_OFFSETTABLE_NUMOFFSETS     4
#define SFNT_OFFSETTABLE_SEARCHRANGE    6
#define SFNT_OFFSETTABLE_ENTRYSELECTOR  8
#define SFNT_OFFSETTABLE_RANGESHIFT     10
#define SFNT_OFFSETTABLE_TABLE          12
#define SIZEOF_SFNT_OFFSETTABLE         12

#define SFNT_FONTHEADER_VERSION             0
#define SFNT_FONTHEADER_FONTREVISION        4
#define SFNT_FONTHEADER_CHECKSUMADJUSTMENT  8
#define SFNT_FONTHEADER_MAGICNUMBER         12
#define SFNT_FONTHEADER_FLAGS               16
#define SFNT_FONTHEADER_UNITSPEREM          18
#define SFNT_FONTHEADER_CREATED             20
#define SFNT_FONTHEADER_MODIFIED            28
#define SFNT_FONTHEADER_XMIN                36
#define SFNT_FONTHEADER_YMIN                38
#define SFNT_FONTHEADER_XMAX                40
#define SFNT_FONTHEADER_YMAX                42
#define SFNT_FONTHEADER_MACSTYLE            44
#define SFNT_FONTHEADER_LOWESTRECPPEM       46
#define SFNT_FONTHEADER_FONTDIRECTIONHINT   48
#define SFNT_FONTHEADER_INDEXTOLOCFORMAT    50
#define SFNT_FONTHEADER_GLYPHDATAFORMAT     52
#define SIZEOF_SFNT_FONTHEADER              54

#define SFNT_HORIZONTALHEADER_VERSION                           0
#define SFNT_HORIZONTALHEADER_YASCENDER                         4
#define SFNT_HORIZONTALHEADER_YDESCENDER                        6
#define SFNT_HORIZONTALHEADER_YLINEGAP                          8
#define SFNT_HORIZONTALHEADER_ADVANCEWIDTHMAX                   10
#define SFNT_HORIZONTALHEADER_MINLEFTSIDEBEARING                12
#define SFNT_HORIZONTALHEADER_MINRIGHTSIDEBEARING               14
#define SFNT_HORIZONTALHEADER_XMAXEXTENT                        16
#define SFNT_HORIZONTALHEADER_HORIZONTALCARETSLOPENUMERATOR     18
#define SFNT_HORIZONTALHEADER_HORIZONTALCARETSLOPEDENOMINATOR   20
#define SFNT_HORIZONTALHEADER_RESERVED0                         22
#define SFNT_HORIZONTALHEADER_RESERVED1                         24
#define SFNT_HORIZONTALHEADER_RESERVED2                         26
#define SFNT_HORIZONTALHEADER_RESERVED3                         28
#define SFNT_HORIZONTALHEADER_RESERVED4                         30
#define SFNT_HORIZONTALHEADER_METRICDATAFORMAT                  32
#define SFNT_HORIZONTALHEADER_NUMBEROF_LONGHORMETRICS           34
#define SIZEOF_SFNT_HORIZONTALHEADER                            36

#define SFNT_HORIZONTALMETRICS_ADVANCEWIDTH     0
#define SFNT_HORIZONTALMETRICS_LEFTSIDEBEARING  2
#define SIZEOF_SFNT_HORIZONTALMETRICS           4

#define SFNT_VERTICALHEADER_NUMBEROF_LONGVERTMETRICS            34

#define SFNT_VERTICALMETRICS_ADVANCEHEIGHT      0
#define SFNT_VERTICALMETRICS_TOPSIDEBEARING     2
#define SIZEOF_SFNT_VERTICALMETRICS             4



#define SFNT_CONTROLVALUE 2

#define SFNT_MAPPINGTABLE_FORMAT            0
#define SFNT_MAPPINGTABLE_MAPTABLELENGTH    2
#define SFNT_MAPPINGTABLE_VERSION           4
#define SIZEOF_SFNT_MAPPINGTABLE            6

#define SFNT_PLATFORMENTRY_PLATFORMID       0
#define SFNT_PLATFORMENTRY_SPECIFICID       2
#define SFNT_PLATFORMENTRY_PLATFORMOFFSET   4
#define SIZEOF_SFNT_PLATFORMENTRY           8

#define SFNT_CHAR2INDEXDIRECTORY_VERSION    0
#define SFNT_CHAR2INDEXDIRECTORY_NUMTABLES  2
#define SFNT_CHAR2INDEXDIRECTORY_PLATFORM   4
#define SIZEOF_SFNT_CHAR2INDEXDIRECTORY     4

#define SFNT_SUBHEADER2_FIRSTCODE       0
#define SFNT_SUBHEADER2_ENTRYCOUNT      2
#define SFNT_SUBHEADER2_IDDELTA         4
#define SFNT_SUBHEADER2_IDRANGEOFFSET   6
#define SIZEOF_SFNT_SUBHEADER2          8

#define SFNT_MAPPINGTABLE2_SUBHEADERSKEYS   0
#define SFNT_MAPPINGTABLE2_SUBHEADERS       512
#define SIZEOF_SFNT_MAPPINGTABLE2           512

#define SFNT_MAPPINGTABLE4_SEGCOUNTX2       0
#define SFNT_MAPPINGTABLE4_SEARCHRANGE      2
#define SFNT_MAPPINGTABLE4_ENTRYSELECTOR    4
#define SFNT_MAPPINGTABLE4_RANGESHIFT       6
#define SFNT_MAPPINGTABLE4_ENDCOUNT         8
#define SIZEOF_SFNT_MAPPINGTABLE4           8

#define SFNT_MAPPINGTABLE6_FIRSTCODE    0
#define SFNT_MAPPINGTABLE6_ENTRYCOUNT   2
#define SFNT_MAPPINGTABLE6_GLYPHIDARRAY 4
#define SIZEOF_SFNT_MAPPINGTABLE6       4

#define SFNT_NAMERECORD_PLATFORMID  0
#define SFNT_NAMERECORD_SPECIFICID  2
#define SFNT_NAMERECORD_LANGUAGEID  4
#define SFNT_NAMERECORD_NAMEID      6
#define SFNT_NAMERECORD_NAMELENGTH  8
#define SFNT_NAMERECORD_NAMEOFFSET  10
#define SIZEOF_SFNT_NAMERECORD      12

#define SFNT_NAMINGTABLE_FORMAT         0
#define SFNT_NAMINGTABLE_COUNT          2
#define SFNT_NAMINGTABLE_STRINGOFFSET   4
/*  SFNT_NAMERECORD[COUNT]  */
#define SIZEOF_SFNT_NAMINGTABLE         6

#define SFNT_PACKEDSPLINEFORMAT_NUMBEROFCONTOURS    0
#define SFNT_PACKEDSPLINEFORMAT_BBOX                2
#define SFNT_PACKEDSPLINEFORMAT_ENDPOINTS           10
#define SIZEOF_SFNT_PACKEDSPLINEFORMAT              10

#define SFNT_DEVICEMETRICS_VERSION      0
#define SFNT_DEVICEMETRICS_NUMRECORDS   2
#define SFNT_DEVICEMETRICS_RECORDSIZE   4
/* BYTE WIDTHS[NUMGLYPHS+2] * NUMRECORDS */
#define SIZEOF_SFNT_DEVICEMETRICS       8

#define POSTSCRIPTNAMEINDICES_VERSION               0
#define POSTSCRIPTNAMEINDICES_ITALICANGLE           4
#define POSTSCRIPTNAMEINDICES_UNDERLINEPOSITION     8
#define POSTSCRIPTNAMEINDICES_UNDERLINETHICKNESS    10
#define POSTSCRIPTNAMEINDICES_ISFIXEDPITCH          12
#define POSTSCRIPTNAMEINDICES_PAD                   14
#define POSTSCRIPTNAMEINDICES_MINMEMTYPE42          16
#define POSTSCRIPTNAMEINDICES_MAXMEMTYPE42          20
#define POSTSCRIPTNAMEINDICES_MINMEMTYPE1           24
#define POSTSCRIPTNAMEINDICES_MAXMEMTYPE1           28
#define POSTSCRIPTNAMEINDICES_NUMBERGLYPHS          32
#define GLYPHNAMEINDEX                              34
#define GLYPHNAMEINDEX25                            34
#define SIZEOF_SFNT_POSTSCRIPTINFO                  36

#define SFNT_OS2_VERSION                0
#define SFNT_OS2_XAVGCHARWIDTH          2
#define SFNT_OS2_USWEIGHTCLASS          4
#define SFNT_OS2_USWIDTHCLASS           6
#define SFNT_OS2_FSTYPE                 8
#define SFNT_OS2_YSUBSCRIPTXSIZE        10
#define SFNT_OS2_YSUBSCRIPTYSIZE        12
#define SFNT_OS2_YSUBSCRIPTXOFFSET      14
#define SFNT_OS2_YSUBSCRIPTYOFFSET      16
#define SFNT_OS2_YSUPERSCRIPTXSIZE      18
#define SFNT_OS2_YSUPERSCRIPTYSIZE      20
#define SFNT_OS2_YSUPERSCRIPTXOFFSET    22
#define SFNT_OS2_YSUPERSCRIPTYOFFSET    24
#define SFNT_OS2_YSTRIKEOUTSIZE         26
#define SFNT_OS2_YSTRIKEOUTPOSITION     28
#define SFNT_OS2_SFAMILYCLASS           30
#define SFNT_OS2_PANOSE                 32
#define SFNT_OS2_ULCHARRANGE            42
#define SFNT_OS2_ACHVENDID              58
#define SFNT_OS2_USSELECTION            62
#define SFNT_OS2_USFIRSTCHAR            64
#define SFNT_OS2_USLASTCHAR             66
#define SFNT_OS2_STYPOASCENDER          68
#define SFNT_OS2_STYPODESCENDER         70
#define SFNT_OS2_STYPOLINEGAP           72
#define SFNT_OS2_SWINASCENT             74
#define SFNT_OS2_SWINDESCENT            76
#define SIZEOF_SFNT_OS2                 78

#define SFNT_HDMX_VERSION               0
#define SFNT_HDMX_SNUMRECORDS           2
#define SFNT_HDMX_LSIZERECORD           4
#define SFNT_HDMX_HDMXTABLE             8
#define SIZEOF_SFNT_HDMX                8

#define SFNT_HDMXRECORD_BEMY            0
#define SFNT_HDMXRECORD_BEMX            1
#define SFNT_HDMXRECORD_BWIDTHS         2
#define SIZEOF_SFNT_HDMXRECORD          2

#define SFNT_LTSH_VERSION               0
#define SFNT_LTSH_NUMGLYPHS             2
#define SFNT_LTSH_UBYPELSHEIGHT         4
#define SIZEOF_SFNT_LTSH                4

#define SFNT_MAXPROFILETABLE_VERSION                0
#define SFNT_MAXPROFILETABLE_NUMGLYPHS              4
#define SFNT_MAXPROFILETABLE_MAXPOINTS              6
#define SFNT_MAXPROFILETABLE_MAXCONTOURS            8
#define SFNT_MAXPROFILETABLE_MAXCOMPOSITEPOINTS     10
#define SFNT_MAXPROFILETABLE_MAXCOMPOSITECONTOURS   12
#define SFNT_MAXPROFILETABLE_MAXELEMENTS            14
#define SFNT_MAXPROFILETABLE_MAXTWILIGHTPOINTS      16
#define SFNT_MAXPROFILETABLE_MAXSTORAGE             18
#define SFNT_MAXPROFILETABLE_MAXFUNCTIONDEFS        20
#define SFNT_MAXPROFILETABLE_MAXINSTRUCTIONDEFS     22
#define SFNT_MAXPROFILETABLE_MAXSTACKELEMENTS       24
#define SFNT_MAXPROFILETABLE_MAXSIZEOFINSTRUCTIONS  26
#define SFNT_MAXPROFILETABLE_MAXCOMPONENTELEMENTS   28
#define SFNT_MAXPROFILETABLE_MAXCOMPONENTDEPTH      30
#define SIZEOF_SFNT_MAXPROFILETABLE 				32

#define SFNT_GASPRANGE_RANGEMAXPPEM 		0
#define SFNT_GASPRANGE_RANGEGASPBEHAVIOR	2
#define SIZEOF_SFNT_GASPRANGE				4

#define SFNT_GASP_VERSION					0
#define SFNT_GASP_NUMRANGES 				2
#define SFNT_GASP_GASPRANGE 				4
#define SIZEOF_SFNT_GASP					4

/**********************************************************************/

/*      Embedded Bitmap (sbit) Table Offsets      */

/**********************************************************************/

/*  Bloc, Bdat and Bsca file constants    */

/*  This first bloc is common to both bloc and bsca tables */

#define     SFNT_BLOC_NUMSIZES               4
#define     SFNT_BLOC_FIRSTSTRIKE            8

#define     SFNT_BLOC_INDEXARRAYOFFSET       0
#define     SFNT_BLOC_NUMINDEXTABLES         8
#define     SFNT_BLOC_COLORREF              12
#define     SFNT_BLOC_STARTGLYPH            40
#define     SFNT_BLOC_ENDGLYPH              42
#define     SFNT_BLOC_PPEMX                 44
#define     SFNT_BLOC_PPEMY                 45
#define     SFNT_BLOC_BITDEPTH              46
#define     SFNT_BLOC_FLAGS                 47
#define     SIZEOF_BLOC_SIZESUBTABLE        48

#define     SFNT_BLOC_FIRSTGLYPH             0
#define     SFNT_BLOC_LASTGLYPH              2
#define     SFNT_BLOC_ADDITIONALOFFSET       4
#define     SIZEOF_BLOC_INDEXARRAY           8

#define     SFNT_BLOC_INDEXFORMAT            0
#define     SFNT_BLOC_IMAGEFORMAT            2
#define     SFNT_BLOC_IMAGEOFFSET            4
#define     SFNT_BLOC_OFFSETARRAY            8

#define     SFNT_BLOC_IDX2IMAGESIZE          8
#define     SFNT_BLOC_IDX2METRICS           12

#define     SFNT_BLOC_IDX4NUMGLYPHS          8
#define     SFNT_BLOC_IDX4OFFSETARRAY       12

#define     SFNT_BLOC_IDX4CODE               0
#define     SFNT_BLOC_IDX4OFFSET             2
#define     SIZEOF_CODEOFFSETPAIR            4
                
#define     SFNT_BLOC_IDX5IMAGESIZE          8
#define     SFNT_BLOC_IDX5METRICS           12
#define     SFNT_BLOC_IDX5NUMGLYPHS         20
#define     SFNT_BLOC_IDX5CODEARRAY         24

#define     SFNT_SBIT_HEIGHT                 0
#define     SFNT_SBIT_WIDTH                  1
#define     SFNT_SBIT_BEARINGX               2
#define     SFNT_SBIT_BEARINGY               3
#define     SFNT_SBIT_ADVANCE                4
#define     SFNT_SBIT_VERTBEARINGX           5
#define     SFNT_SBIT_VERTBEARINGY           6
#define     SFNT_SBIT_VERTADVANCE            7
#define     SIZEOF_SBIT_SMALLMETRICS         5
#define     SIZEOF_SBIT_BIGMETRICS           8

#define     SFNT_BDAT_COMPCOUNT              0
#define     SIZEOF_SBIT_GLYPH8PAD            1
#define     SFNT_BDAT_FIRSTCOMP              2

#define     SFNT_BDAT_COMPGLYPH              0
#define     SFNT_BDAT_COMPXOFF               2
#define     SFNT_BDAT_COMPYOFF               3
#define     SIZEOF_SBIT_BDATCOMPONENT        4

#define     SFNT_BSCA_NUMSIZES               4
#define     SFNT_BSCA_FIRSTSTRIKE            8

#define     SFNT_BSCA_PPEMX                 24
#define     SFNT_BSCA_PPEMY                 25
#define     SFNT_BSCA_SUBPPEMX              26
#define     SFNT_BSCA_SUBPPEMY              27
#define     SIZEOF_BSCA_SIZESUBTABLE        28

/**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\fdfon.c ===
/******************************Module*Header*******************************\
* Module Name: fdfon.c
*
* basic file claim/load/unload font file functions
*
* Created: 08-Nov-1991 10:09:24
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/
#include "fd.h"
#include <stdlib.h>
#include <winerror.h>

BOOL
bLoadTTF (
    ULONG_PTR iFile,
    PVOID     pvView,
    ULONG     cjView,
    ULONG     ulTableOffset,
    ULONG     ulLangId,
    HFF       *phff
    );

STATIC UINT GetCodePageFromSpecId( uint16 ui16SpecId )
{
    USHORT AnsiCodePage, OemCodePage;
    UINT iCodePage;

    EngGetCurrentCodePage(&OemCodePage,&AnsiCodePage);

    iCodePage = AnsiCodePage;

    switch( ui16SpecId )
    {
        case BE_SPEC_ID_SHIFTJIS :
            iCodePage = 932;
            break;

        case BE_SPEC_ID_GB :
            iCodePage = 936;
            break;

        case BE_SPEC_ID_BIG5 :
            iCodePage = 950;
            break;

        case BE_SPEC_ID_WANSUNG :
            iCodePage = 949;
            break;

        default :
            //WARNING("TTFD!:Unknown SPECIFIC ID\n");
            break;
    }

    return( iCodePage );
}


STATIC uint16 ui16BeLangId(ULONG ulPlatId, ULONG ulLangId)
{
    ulLangId = CV_LANG_ID(ulPlatId,ulLangId);
    return BE_UINT16(&ulLangId);
}


STATIC FSHORT  fsSelectionTTFD(BYTE *pjView, TABLE_POINTERS *ptp)
{
    PBYTE pjOS2 = (ptp->ateOpt[IT_OPT_OS2].dp)        ?
                  pjView + ptp->ateOpt[IT_OPT_OS2].dp :
                  NULL                                ;

    sfnt_FontHeader * phead = (sfnt_FontHeader *)(pjView + ptp->ateReq[IT_REQ_HEAD].dp);

//
// fsSelection
//
    ASSERTDD(TT_SEL_ITALIC     == FM_SEL_ITALIC     , "ITALIC     \n");
    ASSERTDD(TT_SEL_UNDERSCORE == FM_SEL_UNDERSCORE , "UNDERSCORE \n");
    ASSERTDD(TT_SEL_NEGATIVE   == FM_SEL_NEGATIVE   , "NEGATIVE   \n");
    ASSERTDD(TT_SEL_OUTLINED   == FM_SEL_OUTLINED   , "OUTLINED   \n");
    ASSERTDD(TT_SEL_STRIKEOUT  == FM_SEL_STRIKEOUT  , "STRIKEOUT  \n");
    ASSERTDD(TT_SEL_BOLD       == FM_SEL_BOLD       , "BOLD       \n");

    if (pjOS2)
    {
        return((FSHORT)BE_UINT16(pjOS2 + OFF_OS2_usSelection));
    }
    else
    {
    #define  BE_MSTYLE_BOLD       0x0100
    #define  BE_MSTYLE_ITALIC     0x0200

        FSHORT fsSelection = 0;

        if (phead->macStyle & BE_MSTYLE_BOLD)
            fsSelection |= FM_SEL_BOLD;
        if (phead->macStyle & BE_MSTYLE_ITALIC)
            fsSelection |= FM_SEL_ITALIC;

        return fsSelection;
    }
}



STATIC BOOL  bComputeIFISIZE
(
BYTE             *pjView,
TABLE_POINTERS   *ptp,
uint16            ui16PlatID,
uint16            ui16SpecID,
uint16            ui16LangID,
PIFISIZE          pifisz
);

static BOOL bConvertExtras(GP_PIFIMETRICS  pifi,
                           PIFISIZE pifisz,
                           uint16 ui16LanguageID);

STATIC BOOL  bCheckLocaTable
(
int16	indexToLocFormat,
BYTE    *pjView,
TABLE_POINTERS   *ptp,
uint16 	numGlyphs
);

STATIC BOOL  bCheckHdmxTable
(
sfnt_hdmx      *phdmx,
ULONG 			size
);

STATIC BOOL bCvtUnToMac(BYTE *pjView, TABLE_POINTERS *ptp, uint16 ui16PlatformID);

STATIC BOOL  bVerifyTTF
(
ULONG_PTR           iFile,
PVOID               pvView,
ULONG               cjView,
PBYTE               pjOffsetTable,
ULONG               ulLangId,
PTABLE_POINTERS     ptp,
PIFISIZE            pifisz,
uint16             *pui16PlatID,
uint16             *pui16SpecID,
sfnt_mappingTable **ppmap,
ULONG              *pulGsetType,
ULONG              *pul_wcBias
);

STATIC BOOL  bGetTablePointers
(
PVOID               pvView,
ULONG               cjView,
PBYTE               pjOffsetTable,
PTABLE_POINTERS  ptp
);

STATIC BOOL bComputeIDs
(
BYTE                     * pjView,
TABLE_POINTERS           * ptp,
uint16                   * pui16PlatID,
uint16                   * pui16SpecID,
sfnt_mappingTable       ** ppmap
);


STATIC VOID vFill_IFIMETRICS
(
PFONTFILE       pff,
GP_PIFIMETRICS     pifi,
PIFISIZE        pifisz,
fs_GlyphInputType     *pgin
);

BYTE jIFIMetricsToGdiFamily (GP_PIFIMETRICS pifi);


BOOL
ttfdUnloadFontFileTTC (
    HFF hff
    )
{
    ULONG i;
    BOOL  bRet = TRUE;
    #if DBG
    ULONG ulTrueTypeResource = PTTC(hff)->ulTrueTypeResource;
    #endif

    // free hff for this ttc file.

    for( i = 0; i < PTTC(hff)->ulNumEntry; i++ )
    {
        if(PTTC(hff)->ahffEntry[i].iFace == 1)
        {
            if( !ttfdUnloadFontFile(PTTC(hff)->ahffEntry[i].hff) )
            {
                //WARNING("TTFD!ttfdUnloadFontFileTTC(): ttfdUnloadFontFile fail\n");
                bRet = FALSE;
            }

            #if DBG
            ulTrueTypeResource--;
            #endif
        }
    }


    // finally free the memory for the ttc itself

    vFreeTTC(PTTC(hff));

    ASSERTDD(ulTrueTypeResource == 0L,
              "TTFD!ttfdUnloadFontFileTTC(): ulTrueTypeResource != 0\n");

    return(bRet);
}

/******************************Public*Routine******************************\
*
* ttfdUnloadFontFile
*
*
* Effects: done with using this tt font file. Release all system resources
* associated with this font file
*
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
ttfdUnloadFontFile (
    HFF hff
    )
{
    if (hff == HFF_INVALID)
        return(FALSE);

// check the reference count, if not 0 (font file is still
// selected into a font context) we have a problem

    ASSERTDD(PFF(hff)->cRef == 0L, "ttfdUnloadFontFile: cRef\n");

// no need to unmap the file at this point
// it has been unmapped when cRef went down to zero

// assert that pff->pkp does not point to the allocated mem

// free the internal structure for the TrueType rasterizer

	if (PFF(hff)->pj034)
		V_FREE(PFF(hff)->pj034);

// free the pfc

	if (PFF(hff)->pfcToBeFreed)
		V_FREE(PFF(hff)->pfcToBeFreed);

// free vertical ifimetrics and the vertical glyphset that are allocated of the same chunk

    if (PFF(hff)->pifi_vertical)
        V_FREE(PFF(hff)->pifi_vertical);

// free memory associated with this FONTFILE object

    vFreeFF(hff);
    return(TRUE);
}

/******************************Public*Routine******************************\
*
* BOOL bVerifyTTF
*
*
* Effects: verifies that a ttf file contains consistent tt information
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bVerifyTTF (
    ULONG_PTR           iFile,
    PVOID               pvView,
    ULONG               cjView,
    PBYTE               pjOffsetTable,
    ULONG               ulLangId,
    PTABLE_POINTERS     ptp,
    PIFISIZE            pifisz,
    uint16             *pui16PlatID,
    uint16             *pui16SpecID,
    sfnt_mappingTable **ppmap,
    ULONG              *pulGsetType,
    ULONG              *pul_wcBias
    )
{
    // extern BOOL bCheckSumOK( void *pvView, ULONG cjView, sfnt_FontHeader *phead );
    sfnt_FontHeader      *phead;

    sfnt_HorizontalHeader  *phhea;
    sfnt_HorizontalMetrics *phmtx;
    sfnt_maxProfileTable   *pmaxp;
    sfnt_hdmx			   *phdmx;	
    ULONG  cHMTX;

// if attempted a bm *.fon file this will fail, so do not print
// warning, but if passes this, and then fails, something is wrong

    if (!bGetTablePointers(pvView,cjView,pjOffsetTable,ptp))
    {
        return( FALSE );
    }

    phead = (sfnt_FontHeader *)((BYTE *)pvView + ptp->ateReq[IT_REQ_HEAD].dp);
    phhea = (sfnt_HorizontalHeader *)((BYTE *)pvView + ptp->ateReq[IT_REQ_HHEAD].dp);
    phmtx = (sfnt_HorizontalMetrics *)((BYTE *)pvView + ptp->ateReq[IT_REQ_HMTX].dp);
    pmaxp = (sfnt_maxProfileTable *)((BYTE *)pvView + ptp->ateReq[IT_REQ_MAXP].dp);
    phdmx = ptp->ateOpt[IT_OPT_HDMX].dp ? 
    	(sfnt_hdmx *)((BYTE *)pvView + ptp->ateOpt[IT_OPT_HDMX].dp) : NULL;

    cHMTX = (ULONG) BE_UINT16(&phhea->numberOf_LongHorMetrics);

    if (sizeof(sfnt_HorizontalMetrics) * cHMTX > ptp->ateReq[IT_REQ_HMTX].cj)
    {
        return FALSE;
    }

    /*
    if ( !bCheckSumOK( pvView, cjView, phead ))
    {
        RET_FALSE("TTFD!_bVerifyTTF, possible file corruption, checksums did not match\n");
    }
    */

#define SFNT_MAGIC   0x5F0F3CF5
    if (BE_UINT32((BYTE*)phead + SFNT_FONTHEADER_MAGICNUMBER) != SFNT_MAGIC)
        RET_FALSE("TTFD: bVerifyTTF: SFNT_MAGIC \n");

    if (!bComputeIDs(pvView,
                     ptp,
                     pui16PlatID,
                     pui16SpecID,
                     ppmap)
        )
        RET_FALSE("TTFD!_bVerifyTTF, bComputeIDs failed\n");


    if (!bComputeIFISIZE (
                    pvView,
                    ptp,
                    *pui16PlatID,
                    *pui16SpecID,
                    ui16BeLangId(*pui16PlatID,ulLangId),
                    pifisz)             // return results here
        )
        {
            RET_FALSE("TTFD!_bVerifyTTF, bComputeIFISIZE failed\n");
        }

    if (!bCheckLocaTable (
    				SWAPW(phead->indexToLocFormat),
    				pvView,
    				ptp,
    				(uint16) SWAPW(pmaxp->numGlyphs) )
    	)
        {
            RET_FALSE("TTFD!_bVerifyTTF, bCheckLocaTable failed\n");
        }

    if (phdmx && !bCheckHdmxTable (
    				phdmx,
    				ptp->ateOpt[IT_OPT_HDMX].cj )
    	)
        {
            RET_FALSE("TTFD!_bVerifyTTF, bCheckHdmxTable failed\n");
        }

// all checks passed

    return(TRUE);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   bCheckSumOK
*
* Routine Description:
*
*   Check file for corruption by calculationg check sum
*   and comparing it against value in file.
*
*   Ref: TrueType 1.0 Font Files: Technical Specification,
*        Revision 1.64 beta, December 1994, p. 65,
*        'head' - Font Header".
*
* Arguments:
*
*   pvView              pointer to view of TrueType file
*
*   cjView              size of view in byte's
*
*   phead               pointer to sfnt_FontHeader table in view of
*                       TrueType file
*
* Return Value:
*
*   TRUE if check sum's match, FALSE if they don't
*
\**************************************************************************/
/*
BOOL bCheckSumOK( void *pvView, ULONG cjView, sfnt_FontHeader *phead )
{
    extern ULONG ttfdCheckSum( ULONG*, ULONG );
    ULONG ul, *pul, ulView;

    pul  = (ULONG*) ( (BYTE*) phead + SFNT_FONTHEADER_CHECKSUMADJUSTMENT );
                                    // pul now points to the
                                    // checkSumAdjustment field in the
                                    // 'head' table of the font file.
    if ( (ULONG) pul & 3 )          // Check that pul is DWORD aligned
    {
        RET_FALSE("bCheckSumOK: checkSumAdjustment is not DWORD aligned\n");
    }
    ul   = *pul;                    // Big endian representation
    *pul = 0;                       // required to calculate checksum
    ulView = ttfdCheckSum( (ULONG*) pvView, cjView );   // little endian value
    *pul = ul;                      // restore view
    ulView = 0xb1b0afba - ulView;   // magic subtraction as per spec
    ulView = BE_UINT32( &ulView );  // convert to big endian representation
    return( ul == ulView );         // compare with big endian number in file
}
*/
/******************************Public*Routine******************************\
*
* Routine Name:
*
*   ttfdCheckSum
*
* Routine Description:
*
*   Calculates check sum's of memory blocks according to TrueType
*   conventions.
*
*   Ref: TrueType 1.0 Font Files: Technical Specification,
*        Revision 1.64 beta, December 1994, p. 34, The Table
*        Directory
*
* Arguments:
*
*   pul                 pointer to DWORD aligned start of memory block
*
*   cj                  size of memory block in bytes. It is assumed
*                       that access of the last DWORD is allowed
*                       even if cj is not a multiple of 4.
*
* Return Value:
*
*   Little Endian representation of CheckSum.
*
\**************************************************************************/
/*
ULONG ttfdCheckSum( ULONG *pul, ULONG cj )
{
    ULONG *pulEnd, ul, Sum;
    pulEnd = (ULONG*) ((BYTE*) pul + ((cj + 3) & ~3) );
    for ( Sum = 0; pul < pulEnd; pul++)
    {
        ul = *pul;                  // ul is big endian
        Sum += BE_UINT32( &ul );    // do little endian sum
    }
    return( Sum );  // return little endian result
}
*/
/******************************Public*Routine******************************\
*
* PBYTE pjGetPointer(LONG clientID, LONG dp, LONG cjData)
*
* this function is required by scaler. It is very simple
* Returns a pointer to the position in a ttf file which is at
* offset dp from the top of the file:
*
* Effects:
*
* Warnings:
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

//!!! clientID should be uint32, just a set of bits
//!!! I hate to have this function defined like this [bodind]

voidPtr   FS_CALLBACK_PROTO
pvGetPointerCallback(
    ULONG_PTR clientID,
    long     dp,
    long     cjData
    )
{
    cjData;

// clientID is FONTFILE structure...

    if(dp)
    {
        if ((dp > 0) && (cjData >= 0) && (dp + cjData <= (long)PFF(clientID)->cjView))
        {
            return(voidPtr)((PBYTE)(PFF(clientID)->pvView) + dp);
        }
        else
        {
            return NULL;
        }
    }
     else
        return(voidPtr)((PBYTE)(PFF(clientID)->pvView) +
                               (PFF(clientID)->ffca.ulTableOffset));
}


/******************************Public*Routine******************************\
*
* void vReleasePointer(voidPtr pv)
*
*
* required by scaler, the type of this function is ReleaseSFNTFunc
*
*
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

void FS_CALLBACK_PROTO
vReleasePointerCallback(
    voidPtr pv
    )
{
    pv;
}


/******************************Public*Routine******************************\
*
* PBYTE pjTable
*
* Given a table tag, get a pointer and a size for the table
*
* History:
*  11-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


PBYTE pjTable(ULONG ulTag, PFONTFILE pff, ULONG *pcjTable)
{
    INT                 cTables;
    sfnt_OffsetTable    *pofft;
    register sfnt_DirectoryEntry *pdire, *pdireEnd;

// offset table is at the very top of the file,

    pofft = (sfnt_OffsetTable *) ((PBYTE) (pff->pvView) + pff->ffca.ulTableOffset);

    cTables = (INT) SWAPW(pofft->numOffsets);

// do linear search, this is usually small list and it is NOT always
// ordered by the tag as ttf spec says it should be.

    pdireEnd = &pofft->table[cTables];

    for
    (
        pdire = &pofft->table[0];
        pdire < pdireEnd;
        ((PBYTE)pdire) += SIZE_DIR_ENTRY
    )
    {

        if (ulTag == pdire->tag)
        {
            ULONG ulOffset = (ULONG)SWAPL(pdire->offset);
            ULONG ulLength = (ULONG)SWAPL(pdire->length);

        // check if the ends of all tables are within the scope of the
        // tt file. If this is is not the case trying to access the field in the
        // table may result in an access violation, as is the case with the
        // spurious FONT.TTF that had the beginning of the cmap table below the
        // end of file, which was resulting in the system crash reported by beta
        // testers. [bodind]

            if
            (
             !ulLength ||
             ((ulOffset + ulLength) > pff->cjView)
            )
            {
                RETURN("TTFD: pjTable: table offset/length \n", NULL);
            }
            else // we found it
            {
                *pcjTable = ulLength;
                return ((PBYTE)(pff->pvView) + ulOffset);
            }
        }
    }

// if we are here, we did not find it.

    return NULL;
}

/******************************Public*Routine******************************\
*
* bGetTablePointers - cache the pointers to all the tt tables in a tt file
*
* IF a table is not present in the file, the corresponding pointer is
* set to NULL
*
*
* //   tag_CharToIndexMap              // 'cmap'    0
* //   tag_GlyphData                   // 'glyf'    1
* //   tag_FontHeader                  // 'head'    2
* //   tag_HoriHeader                  // 'hhea'    3
* //   tag_HorizontalMetrics           // 'hmtx'    4
* //   tag_IndexToLoc                  // 'loca'    5
* //   tag_MaxProfile                  // 'maxp'    6
* //   tag_NamingTable                 // 'name'    7
* //   tag_Postscript                  // 'post'    9
* //   tag_OS_2                        // 'OS/2'    10
*
* // optional
*
* //   tag_ControlValue                // 'cvt '    11
* //   tag_FontProgram                 // 'fpgm'    12
* //   tag_HoriDeviceMetrics           // 'hdmx'    13
* //   tag_Kerning                     // 'kern'    14
* //   tag_LTSH                        // 'LTSH'    15
* //   tag_PreProgram                  // 'prep'    16
* //   tag_GlyphDirectory              // 'gdir'    17
* //   tag_Editor0                     // 'edt0'    18
* //   tag_Editor1                     // 'edt1'    19
* //   tag_Encryption                  // 'cryp'    20
*
*
* returns false if all of required pointers are not present
*
* History:
*  05-Dec-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL bGetTablePointers (
    PVOID            pvView,
    ULONG            cjView,
    PBYTE            pjOffsetTable,
    PTABLE_POINTERS  ptp
    )
{
    INT                 iTable;
    INT                 cTables;
    sfnt_OffsetTable    *pofft;
    register sfnt_DirectoryEntry *pdire, *pdireEnd;
    ULONG                ulTag;
    BOOL                 bRequiredTable;

    if ((PBYTE)pvView > pjOffsetTable ||
        pjOffsetTable > pjOffsetTable+offsetof(sfnt_OffsetTable, table) ||
        pjOffsetTable+offsetof(sfnt_OffsetTable, table) > (PBYTE)pvView + cjView
       )
        RET_FALSE("ttfd!font corruption: table directory header is out of file\n");


// offset table is at the very top of the file,

    pofft = (sfnt_OffsetTable *)pjOffsetTable;

// check version number, if wrong exit before doing
// anything else. This line rejects bm FON files
// if they are attempted to be loaed as TTF files
// Version #'s are in big endian.

#define BE_VER1     0x00000100
#define BE_VER2     0x00000200

    if ((pofft->version != BE_VER1) && (pofft->version !=  BE_VER2))
        return (FALSE); // *.fon files fail this check, make this an early out

// clean up the pointers

    RtlZeroMemory((VOID *)ptp, sizeof(TABLE_POINTERS));

    cTables = (INT) SWAPW(pofft->numOffsets);

    pdireEnd = &pofft->table[cTables];

    if ((unsigned)cTables > MAX_TABLES ||
        pjOffsetTable+offsetof(sfnt_OffsetTable, table) > (PBYTE)pdireEnd ||
        (PBYTE)pdireEnd > (PBYTE)pvView + cjView
       )
        RET_FALSE("ttfd!font corruption: table directory is out of file\n");

    for
    (
        pdire = &pofft->table[0];
        pdire < pdireEnd;
        ((PBYTE)pdire) += SIZE_DIR_ENTRY
    )
    {
        ULONG ulOffset = (ULONG)SWAPL(pdire->offset);
        ULONG ulLength = (ULONG)SWAPL(pdire->length);

        ulTag = (ULONG)SWAPL(pdire->tag);

    // check if the ends of all tables are within the scope of the
    // tt file. If this is is not the case trying to access the field in the
    // table may result in an access violation, as is the case with the
    // spurious FONT.TTF that had the beginning of the cmap table below the
    // end of file, which was resulting in the system crash reported by beta
    // testers. [bodind]

        if ((PBYTE)pvView > (PBYTE)pvView + ulOffset ||
            (PBYTE)pvView + ulOffset > (PBYTE)pvView + ulOffset + ulLength ||
            (PBYTE)pvView + ulOffset + ulLength > (PBYTE)pvView + cjView
        )
            RET_FALSE("TTFD: bGetTablePointers : table offset/length \n");

        if (bGetTagIndex(ulTag, &iTable, &bRequiredTable))
        {
            if (bRequiredTable)
            {
                ptp->ateReq[iTable].dp = ulOffset;
                ptp->ateReq[iTable].cj = ulLength;
            }
            else // optional table
            {
                ptp->ateOpt[iTable].dp = ulOffset;
                ptp->ateOpt[iTable].cj = ulLength;

            // here we are fixing a possible bug in in the tt file.
            // In lucida sans font they claim that pj != 0 with cj == 0 for
            // vdmx table. Attempting to use this vdmx table was
            // resulting in an access violation in bSearchVdmxTable

                if (ptp->ateOpt[iTable].cj == 0)
                    ptp->ateOpt[iTable].dp = 0;
            }
        }

    }

// now check that all required tables are present

    for (iTable = 0; iTable < C_REQ_TABLES; iTable++)
    {
        if ((ptp->ateReq[iTable].dp == 0) || (ptp->ateReq[iTable].cj == 0))
            RET_FALSE("TTFD!_required table absent\n");
    }

    return(TRUE);
}


/******************************Public*Routine******************************\
*
* BOOL bGetTagIndex
*
* Determines whether the table is required or optional, assiciates the index
* into TABLE_POINTERS  with the tag
*
* returns FALSE if ulTag is not one of the recognized tags
*
* History:
*  09-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bGetTagIndex (
    ULONG  ulTag,      // tag
    INT   *piTable,    // index into a table
    BOOL  *pbRequired  // requred or optional table
    )
{
    *pbRequired = FALSE;  // default set for optional tables, change the
                          // value if required table

    switch (ulTag)
    {
    // reqired tables:

    case tag_CharToIndexMap:
        *piTable = IT_REQ_CMAP;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_GlyphData:
        *piTable = IT_REQ_GLYPH;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_FontHeader:
        *piTable = IT_REQ_HEAD;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_HoriHeader:
        *piTable = IT_REQ_HHEAD;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_HorizontalMetrics:
        *piTable = IT_REQ_HMTX;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_IndexToLoc:
        *piTable = IT_REQ_LOCA;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_MaxProfile:
        *piTable = IT_REQ_MAXP;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_NamingTable:
        *piTable = IT_REQ_NAME;
        *pbRequired = TRUE;
        return (TRUE);

// optional tables

    case tag_OS_2:
        *piTable = IT_OPT_OS2;
        return (TRUE);
    case tag_HoriDeviceMetrics:
        *piTable = IT_OPT_HDMX;
        return (TRUE);
    case tag_Vdmx:
        *piTable = IT_OPT_VDMX;
        return (TRUE);
    case tag_Kerning:
        *piTable = IT_OPT_KERN;
        return (TRUE);
    case tag_LinearThreshold:
        *piTable = IT_OPT_LSTH;
        return (TRUE);
    case tag_Postscript:
        *piTable = IT_OPT_POST;
        return (TRUE);
    case tag_GridfitAndScanProc:
        *piTable = IT_OPT_GASP;
        return (TRUE);
    case tag_mort:
        *piTable = IT_OPT_MORT;
        return (TRUE);
    case tag_GSUB:
        *piTable = IT_OPT_GSUB;
        return (TRUE);
    case tag_VerticalMetrics:
        *piTable = IT_OPT_VMTX;
        return(TRUE);
    case tag_VertHeader:
        *piTable = IT_OPT_VHEA;
        return(TRUE);
    case tag_BitmapLocation:
        *piTable = IT_OPT_EBLC;
        return (TRUE);
    default:
        return (FALSE);
    }
}


// helper routine for bComputeIFISIZE()
static ULONG ConvertLangIDtoCodePage(uint16 uiLangID)
{
    switch(uiLangID)
    {
        case 0x0404:   // Taiwan
        case 0x040c:   // Hongkong
        case 0x0414:   // mckou
            return 950; // CHINESEBIG5_CHARSET
        case 0x0408:    // PRC
        case 0x0410:    // Singapore
            return 936; // GB2312_CHARSET
    }

    return 0;
}

// Open type name table definitions
#define BE_NAME_ID_COPYRIGHT   0x0000
#define BE_NAME_ID_FAMILY      0x0100
#define BE_NAME_ID_SUBFAMILY   0x0200
#define BE_NAME_ID_UNIQNAME    0x0300
#define BE_NAME_ID_FULLNAME    0x0400
#define BE_NAME_ID_VERSION     0x0500
#define BE_NAME_ID_PSCRIPT     0x0600
#define BE_NAME_ID_TRADEMARK   0x0700

/**************************************************************************\
*
* STATIC BOOL  bComputeIFISIZE
*
* Effects:  scans the name table and fills the given IFISIZE structure.
*
* Warnings:
*
* History:
*  10-Dec-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
*
*  3/5/2 mikhaill: fixed bug 565287
*
\**************************************************************************/

STATIC BOOL  bComputeIFISIZE
(
BYTE             *pjView,
TABLE_POINTERS   *ptp,
uint16            ui16PlatID,
uint16            ui16SpecID,
uint16            ui16LangID,
PIFISIZE          pifisz
)
{

    sfnt_OS2 * pOS2;

    // get the pointer to the name table
    sfnt_NamingTable *pname = (sfnt_NamingTable *)(pjView + ptp->ateReq[IT_REQ_NAME].dp);

    // get the pointer above the end of the table
    BYTE* pTableLimit = (PBYTE)pname + ptp->ateReq[IT_REQ_NAME].cj;

    BYTE* pjStorage;
    uintptr_t sizeStorage;

    sfnt_NameRecord * pnrecInit, *pnrec, *pnrecEnd;
    sfnt_NameRecord * pnrecFamily = (sfnt_NameRecord *)NULL;

    BOOL    bMatchLangId, bFoundAllNames;
    INT     iNameLoop;

    USHORT  AnsiCodePage, OemCodePage;
    UINT offsetAcc;


// get out if this is not one of the platID's we know what to do with

    if ((ui16PlatID != BE_PLAT_ID_MS) && (ui16PlatID != BE_PLAT_ID_MAC))
        RET_FALSE("ttfd!_ do not know how to handle this plat id\n");

// first clean the output structure:

    RtlZeroMemory((PVOID)pifisz, sizeof(IFISIZE));

// remember call arguments for use in bConvertExtras
    pifisz->ui16PlatID = ui16PlatID;
    pifisz->ui16SpecID = ui16SpecID;

// first name record is layed just below the naming table

    pnrecInit = (sfnt_NameRecord *)((PBYTE)pname + SIZE_NAMING_TABLE);

    // check the various possible corruptions in name table header:
    // first ensure that at leasr header fit into the table

    if ((BYTE*)pname     > (BYTE*)pnrecInit || 
        (BYTE*)pnrecInit > (BYTE*)pTableLimit)
         RETURN("ttfd!corrupted name table header in a file\n", FALSE);

    // now we can use the header

    // get the ptr above record array
    pnrecEnd = &pnrecInit[BE_UINT16(&pname->count)];

    // get the pointer to the beginning of the storage area for strings
    pjStorage = (PBYTE)pname + BE_UINT16(&pname->stringOffset);

     if ((BYTE*)pnrecInit > (BYTE*)pnrecEnd  || 
         (BYTE*)pnrecEnd  > (BYTE*)pjStorage || 
         (BYTE*)pjStorage > (BYTE*)pTableLimit)
          RETURN("ttfd!corrupted(2) name table header in a file\n", FALSE);

    sizeStorage = pTableLimit - pjStorage;

// in the first iteration of the loop we want to match lang id to our
// favorite lang id. If we find all 4 strings in that language we are
// done. If we do not find all 4 string with matching lang id we will try to
// language only, but not sublanguage. For instance if Canadian French
// is requested, but the file only contains "French" French names, we will
// return the names in French French. If that does not work either
// we shall go over name records again and try to find
// the strings in English. If that does not work either we
// shall resort to total desperation and just pick any language.
// therefore we may go up to 4 times through the NAME_LOOP

    bFoundAllNames = FALSE;

    EngGetCurrentCodePage(&OemCodePage,&AnsiCodePage);

// find the name record with the desired ID's
// NAME_LOOP:

    for (iNameLoop = 0; iNameLoop < 4 && !bFoundAllNames; iNameLoop++)
    {
        for (pnrec = pnrecInit; pnrec < pnrecEnd && !bFoundAllNames; pnrec++)
        {
            UINT nameOffset = BE_UINT16(&pnrec->offset);
            UINT nameLength = BE_UINT16(&pnrec->length);

            // ignore incorrect records
            if (nameLength == 0 || nameOffset + nameLength > sizeStorage) continue;

            switch (iNameLoop)
            {
            case 0:
            // match BOTH language and sublanguage

                bMatchLangId = (pnrec->languageID == ui16LangID);
                break;

            case 1:
            // match language but not sublanguage
            // except if we are dealing with LANG_CHINESE then we need to see
            // the font code page is same as system defaul or not

                if ((ui16LangID & 0xff00) == 0x0400) // LANG_CHINESE == 0x0400
                {
                    if ((ConvertLangIDtoCodePage(pnrec->languageID) != AnsiCodePage))
                    {
                        bMatchLangId = ((pnrec->languageID & 0xff00) == 0x0900);
                    }
                    else
                    {
                        bMatchLangId = ((pnrec->languageID & 0xff00) == (ui16LangID & 0xff00));
                    }
                }
                else
                {
                    bMatchLangId = ((pnrec->languageID & 0xff00) == (ui16LangID & 0xff00));
                }
                break;

            case 2:
            // try to find english names if desired language is not available

                if ((ui16LangID & 0xff00) == 0x0400) // LANG_CHINESE == 0x0400
                {
                    if ((ConvertLangIDtoCodePage(pnrec->languageID) != AnsiCodePage))
                    {
                        bMatchLangId = ((pnrec->languageID & 0xff00) == (ui16LangID & 0xff00));
                    }
                    else
                    {
                        bMatchLangId = ((pnrec->languageID & 0xff00) == 0x0900);
                    }
                }
                else
                {
                    bMatchLangId = ((pnrec->languageID & 0xff00) == 0x0900);
                }
                break;

            case 3:
            // do not care to match language at all, just give us something

                bMatchLangId = TRUE;
                break;

            default:
                //RIP("ttfd! must not have more than 3 loop iterations\n");
                break;
            }

            if
            (
                (pnrec->platformID == ui16PlatID) &&
                (pnrec->specificID == ui16SpecID) &&
                bMatchLangId
            )
            {
                switch (pnrec->nameID)
                {
                case BE_NAME_ID_FAMILY:

                    if (!pifisz->pjFamilyName) // if we did not find it before
                    {
                        pifisz->pjFamilyName = pjStorage + nameOffset;
                        pifisz->cjFamilyName =             nameLength;

                        pnrecFamily = pnrec; // keep it to distinguish from alias
                    }   
                    break;

                case BE_NAME_ID_SUBFAMILY:

                    if (!pifisz->pjSubfamilyName) // if we did not find it before
                    {
                        pifisz->pjSubfamilyName = pjStorage + nameOffset;
                        pifisz->cjSubfamilyName =             nameLength;
                    }
                    break;

                case BE_NAME_ID_UNIQNAME:

                    if (!pifisz->pjUniqueName) // if we did not find it before
                    {
                        pifisz->pjUniqueName    = pjStorage + nameOffset;
                        pifisz->cjUniqueName    =             nameLength;
                    }
                    break;

                case BE_NAME_ID_FULLNAME:

                    if (!pifisz->pjFullName)    // if we did not find it before
                    {
                        pifisz->pjFullName      = pjStorage + nameOffset;
                        pifisz->cjFullName      =             nameLength;
                    }
                    break;
                }

            }

            bFoundAllNames = pifisz->pjFamilyName
                          && pifisz->pjSubfamilyName
                          && pifisz->pjUniqueName
                          && pifisz->pjFullName;
        }


    } // end of iNameLoop

    if (!bFoundAllNames)
    {
    // we have gone through the all 3 iterations of the NAME loop
    // and still have not found all the names.

        RETURN("ttfd!can not find all name strings in a file\n", FALSE);
    }


// let us check if there  is a family alias, usually only exists in
// FE tt fonts, where there might be a western and fe family name.
// Do not do this for MAC case.

    if (ui16PlatID == BE_PLAT_ID_MS)
    {
        for (pnrec = pnrecInit; pnrec < pnrecEnd; pnrec++)
        {
            UINT nameOffset = BE_UINT16(&pnrec->offset);
            UINT nameLength = BE_UINT16(&pnrec->length);
            
            // ignore incorrect records
            if (nameLength == 0 || nameOffset + nameLength > sizeStorage) continue;
            
            if ((pnrec->platformID == ui16PlatID)    &&
                (pnrec->specificID == ui16SpecID)    &&
                (pnrec->nameID == BE_NAME_ID_FAMILY) &&
                (pnrecFamily != pnrec)
                )
            {
                pifisz->pjFamilyNameAlias = pjStorage + nameOffset;
                pifisz->cjFamilyNameAlias =             nameLength;
                pifisz->aliasLangID = pnrec->languageID;
                break;
            }
        }

        // remember langID (also not required for MAC)
        pifisz->langID = pnrecFamily->languageID;
    }

    // calculate unicode string lengths
    if (!bConvertExtras(0, pifisz, 0)) return 0;

    // now all the cb* lengths are known.
    // Calculate positions of names, relative to beginning
    // of GP_IFIMETRICS structure

    offsetAcc = sizeof(GP_IFIMETRICS);

    pifisz->dpFamilyName = offsetAcc;
    offsetAcc += pifisz->cbFamilyName;

    if(pifisz->pjFamilyNameAlias)
    {
        pifisz->dpFamilyNameAlias = offsetAcc;
        offsetAcc += pifisz->cbFamilyNameAlias;

        // ?? old comments
        // ?? we may need to add a '@' to facename and family name in case this
        // ?? font has a vertical face name.
        // Reserve space for two '@'
        offsetAcc += 2*sizeof(WCHAR);
    }

    // reserve space for second terminating zero
    offsetAcc += sizeof(WCHAR);

    pifisz->dpUniqueName = offsetAcc;
    offsetAcc += pifisz->cbUniqueName;

    pifisz->dpFullName = offsetAcc;
    offsetAcc += pifisz->cbFullName;

    // we may need to add an '@' to facename (== fullname)
    offsetAcc += sizeof(WCHAR);

    pifisz->dpSubfamilyName = offsetAcc;
    offsetAcc += pifisz->cbSubfamilyName;

    offsetAcc = DWORD_ALIGN(offsetAcc);

    {
        ULONG cSims = 0;

        switch (fsSelectionTTFD(pjView,ptp) & (FM_SEL_BOLD | FM_SEL_ITALIC))
        {
        case 0:
            cSims = 3;
            break;

        case FM_SEL_BOLD:
        case FM_SEL_ITALIC:
            cSims = 1;
            break;
        }

        if (cSims)
        {
            pifisz->dpSims = offsetAcc;
            offsetAcc += (DWORD_ALIGN(sizeof(FONTSIM)) + cSims * DWORD_ALIGN(sizeof(FONTDIFF)));
        }
        else
        {
            pifisz->dpSims = 0;
        }
    }
    pifisz->cjIFI = NATURAL_ALIGN(offsetAcc);
    return TRUE;
}

// Helpers for bConvertExtras()
static BOOL bConvertMBCS(WCHAR* pDst, UINT* pSizDst, BYTE* pSrc, UINT sizSrc, UINT iCodePage)
{
    // The source string is given in a specific format.
    // Basically it is DBCS (double byte character system)
    // but each single-byte char is represented by
    // WORD that's the original byte extended with zero.
    // So before calling MultiByteToWideChar we need
    // to squeeze off these extra zeros

    CHAR sqzBuf[256];
    UINT sqzSiz = 0, cch,i;
    
    if (sizSrc & 1) return FALSE;

    for (i = 0; i < sizSrc; i += 2)
    {
        if (pSrc[i])
        {
            if (sqzSiz+2 >= sizeof(sqzBuf)) return FALSE;
            sqzBuf[sqzSiz  ] = pSrc[i  ];
            sqzBuf[sqzSiz+1] = pSrc[i+1];
            sqzSiz += 2;
        }
        else
        {
            if (sqzSiz+1 >= sizeof(sqzBuf)) return FALSE;
            sqzBuf[sqzSiz++] = pSrc[i+1];
        }
    }

    // set terminating zero
    sqzBuf[sqzSiz++] = 0;
    
    cch = EngPlusMultiByteToWideChar(iCodePage, pDst, *pSizDst, sqzBuf, sqzSiz);
    if (cch == 0) return FALSE;

    if (*pSizDst == 0)
    {   // we are called in bConvertExtras() first pass
        *pSizDst = cch*sizeof(WCHAR);
    }
    else
    {   // second pass
        if (cch*sizeof(WCHAR) != *pSizDst) return FALSE;
        if (pDst[cch-1] != 0) return FALSE;
    }
    return TRUE;
}

static BOOL bConvertSwap(WCHAR* pDst, UINT* pSizDst, BYTE* pSrc, UINT sizSrc)
{
    if (*pSizDst == 0)
    {   // was called in bConvertExtras() first pass
        if (sizSrc%sizeof(WCHAR) != 0) return FALSE;
        *pSizDst = sizSrc + sizeof(WCHAR);
    }
    else
    {   // was called in bConvertExtras() second pass
        vCpyBeToLeUnicodeString(pDst, (LPWSTR)pSrc, *pSizDst/sizeof(WCHAR));
    }
    return TRUE;
}
                
static BOOL bConvertMac(WCHAR* pDst, UINT* pSizDst, BYTE* pSrc, UINT sizSrc, uint16 ui16LanguageID)
{
    if (*pSizDst == 0)
    {   // was called in bConvertExtras() first pass
        *pSizDst = (sizSrc + 1)*sizeof(WCHAR);
    }
    else
    {   // was called in bConvertExtras() second pass
        vCpyMacToLeUnicodeString(ui16LanguageID, pDst, pSrc, *pSizDst/sizeof(WCHAR));
    }
    return TRUE;
}
                
// Routine: bConvertExtras
// Executes the convertion of names in strict IFISIZE
// from internal font representation to Unicode.
// Works in two modes, depending on given "pifi" argument.
// When it is null, (preliminary pass) then no convertions
// are executed but the sizes of buffers are calculated and
// stored in IFISIZE.cc* fields.
// The IFISIZE.cjIFI value is calculated during this pass.
// The IFISIZE.cjIFI value means the total amount of memory,
// in bytes, required for GP_PIFIMETRICS with extra structures
// that follow it.
// 
// The second pass is called when GP_PIFIMETRICS is already
// allocated, so given pifi is nonzero.
// This pass uses the data accumulated in IFISIZE
// during first pass and actually converts the names,
// filling corresponding pointers in GP_PIFIMETRICS.

static BOOL bConvertExtras(GP_PIFIMETRICS  pifi,
                           PIFISIZE pifisz,
                           uint16 ui16LanguageID)
{
    if (pifisz->ui16PlatID == BE_PLAT_ID_MS)
    {

        if (pifisz->ui16SpecID == BE_SPEC_ID_BIG5     ||
            pifisz->ui16SpecID == BE_SPEC_ID_WANSUNG  ||
            pifisz->ui16SpecID == BE_SPEC_ID_GB)
        {
            // Convert MBCS string to Unicode..

            UINT iCodePage = GetCodePageFromSpecId(pifisz->ui16SpecID);

            // Do for FamilyName....
            if (!bConvertMBCS((WCHAR*)((PBYTE)pifi + pifisz->dpFamilyName),
                                                    &pifisz->cbFamilyName,
                                                     pifisz->pjFamilyName,
                                                     pifisz->cjFamilyName, iCodePage))
                return FALSE;


            // Do for FamilyNameAlias....
            if (pifisz->pjFamilyNameAlias)
            {   // this case requires double null terminating.

                if (!bConvertMBCS((WCHAR*)((PBYTE)pifi + pifisz->dpFamilyNameAlias),
                                                        &pifisz->cbFamilyNameAlias,
                                                         pifisz->pjFamilyNameAlias,
                                                         pifisz->cjFamilyNameAlias, iCodePage))
                    return FALSE;

                // on the second pass, put the second terminator
                if (pifi)
                {
                    *(WCHAR*)((PBYTE)pifi
                               + pifisz->dpFamilyNameAlias
                               + pifisz->cbFamilyNameAlias) = 0;
                }
            }

            // Do for FullName....
            if (!bConvertMBCS((WCHAR*)((PBYTE)pifi + pifisz->dpFullName),
                                                    &pifisz->cbFullName,
                                                     pifisz->pjFullName,
                                                     pifisz->cjFullName, iCodePage))
                return FALSE;

            // Do for UniqueName....
            if (!bConvertMBCS((WCHAR*)((PBYTE)pifi + pifisz->dpUniqueName),
                                                    &pifisz->cbUniqueName,
                                                     pifisz->pjUniqueName,
                                                     pifisz->cjUniqueName, iCodePage))
                return FALSE;


            // Do for SubfamilyName....
            if(pifisz->ui16SpecID == BE_SPEC_ID_WANSUNG  ||
               pifisz->ui16SpecID == BE_SPEC_ID_BIG5 )
            {
                // MingLi.TTF's bug, Style use Unicode encoding, not BIG5 encodingi, GB??
                if (!bConvertSwap((WCHAR*)((PBYTE)pifi + pifisz->dpSubfamilyName),
                                                        &pifisz->cbSubfamilyName,
                                                         pifisz->pjSubfamilyName,
                                                         pifisz->cjSubfamilyName))
                    return FALSE;
            }
            else
            {
                if (!bConvertMBCS((WCHAR*)((PBYTE)pifi + pifisz->dpSubfamilyName),
                                                        &pifisz->cbSubfamilyName,
                                                         pifisz->pjSubfamilyName,
                                                         pifisz->cjSubfamilyName, iCodePage))
                    return FALSE;
            }
        }
        else
        {
            // Do for FamilyName....
            if (!bConvertSwap((WCHAR*)((PBYTE)pifi + pifisz->dpFamilyName),
                                                    &pifisz->cbFamilyName,
                                                     pifisz->pjFamilyName,
                                                     pifisz->cjFamilyName))
                return FALSE;

            // Do for FamilyNameAlias....
            if (pifisz->pjFamilyNameAlias)
            {   // this case requires double null terminating.

                if (!bConvertSwap((WCHAR*)((PBYTE)pifi + pifisz->dpFamilyNameAlias),
                                                        &pifisz->cbFamilyNameAlias,
                                                         pifisz->pjFamilyNameAlias,
                                                         pifisz->cjFamilyNameAlias))
                    return FALSE;

                // on the second pass, put the second terminator
                if (pifi)
                {
                    *(WCHAR*)((PBYTE)pifi
                               + pifisz->dpFamilyNameAlias
                               + pifisz->cbFamilyNameAlias) = 0;
                }
            }

            // Do for FullName....
            if (!bConvertSwap((WCHAR*)((PBYTE)pifi + pifisz->dpFullName),
                                                    &pifisz->cbFullName,
                                                     pifisz->pjFullName,
                                                     pifisz->cjFullName))
                return FALSE;

            // Do for UniqueName....
            if (!bConvertSwap((WCHAR*)((PBYTE)pifi + pifisz->dpUniqueName),
                                                    &pifisz->cbUniqueName,
                                                     pifisz->pjUniqueName,
                                                     pifisz->cjUniqueName))
                return FALSE;


            // Do for SubfamilyName....
            if (!bConvertSwap((WCHAR*)((PBYTE)pifi + pifisz->dpSubfamilyName),
                                                    &pifisz->cbSubfamilyName,
                                                     pifisz->pjSubfamilyName,
                                                     pifisz->cjSubfamilyName))
                return FALSE;
        }
    }
    else
    {
        ASSERTDD(pifisz->ui16PlatID == BE_PLAT_ID_MAC, "bConvertExtras: not mac id \n");

        // Do for FamilyName....
        if (!bConvertMac((WCHAR*)((PBYTE)pifi + pifisz->dpFamilyName),
                                               &pifisz->cbFamilyName,
                                                pifisz->pjFamilyName,
                                                pifisz->cjFamilyName, ui16LanguageID))
            return FALSE;

        // Do for FullName....
        if (!bConvertMac((WCHAR*)((PBYTE)pifi + pifisz->dpFullName),
                                               &pifisz->cbFullName,
                                                pifisz->pjFullName,
                                                pifisz->cjFullName, ui16LanguageID))
            return FALSE;

        // Do for UniqueName....
        if (!bConvertMac((WCHAR*)((PBYTE)pifi + pifisz->dpUniqueName),
                                               &pifisz->cbUniqueName,
                                                pifisz->pjUniqueName,
                                                pifisz->cjUniqueName, ui16LanguageID))
            return FALSE;


        // Do for SubfamilyName....
        if (!bConvertMac((WCHAR*)((PBYTE)pifi + pifisz->dpSubfamilyName),
                                               &pifisz->cbSubfamilyName,
                                                pifisz->pjSubfamilyName,
                                                pifisz->cjSubfamilyName, ui16LanguageID))
            return FALSE;
    }

    return TRUE;
}

/******************************Public*Routine******************************\
*
* STATIC BOOL  bCheckLocaTable
*
* Effects:
*
* Warnings:
*
* History:
*  20-June-2000 -by- Sung-Tae Yoo [styoo]
* Wrote it.
\**************************************************************************/

STATIC BOOL  bCheckLocaTable
(
int16	indexToLocFormat,
BYTE    *pjView,
TABLE_POINTERS   *ptp,
uint16 	numGlyphs
)
{
	int32	i;
	
	if(indexToLocFormat){	//For Long Offsets
		uint32* pLongOffSet;

		pLongOffSet = (uint32 *)(pjView + ptp->ateReq[IT_REQ_LOCA].dp);

		for(i=0; i<numGlyphs; i++)
			if( (uint32)SWAPL(pLongOffSet[i]) > (uint32)SWAPL(pLongOffSet[i+1]) )
				return (FALSE);
	}
	else{	//For Short Offsets
		uint16* pShortOffSet;

		pShortOffSet = (uint16 *)(pjView + ptp->ateReq[IT_REQ_LOCA].dp);

		for(i=0; i<numGlyphs; i++)
			if( (uint16)SWAPW(pShortOffSet[i]) > (uint16)SWAPW(pShortOffSet[i+1]) )
				return (FALSE);
	}

	return (TRUE);
}

/******************************Public*Routine******************************\
*
* STATIC BOOL  bCheckHdmxTable
*
* Effects:
*
* Warnings:
*
* History:
*  20-Sep-2000 -by- Sung-Tae Yoo [styoo]
* Wrote it.
\**************************************************************************/

STATIC BOOL  bCheckHdmxTable
(
	sfnt_hdmx	   *phdmx,
	ULONG 			size
)
{
	return( size >= (ULONG) (SWAPW(phdmx->sNumRecords) * SWAPL(phdmx->lSizeRecord) + 8));
}

/******************************Public*Routine******************************\
*
* STATIC BOOL bComputeIDs
*
* Effects:
*
* Warnings:
*
* History:
*  13-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bComputeIDs (
    BYTE              * pjView,
    TABLE_POINTERS     *ptp,
    uint16             *pui16PlatID,
    uint16             *pui16SpecID,
    sfnt_mappingTable **ppmap)
{

    ULONG ul_startCount=0L;

    sfnt_char2IndexDirectory * pcmap =
            (sfnt_char2IndexDirectory *)(pjView + ptp->ateReq[IT_REQ_CMAP].dp);

    sfnt_platformEntry * pplat = &pcmap->platform[0];
    sfnt_platformEntry * pplatEnd = pplat + BE_UINT16(&pcmap->numTables);
    sfnt_platformEntry * pplatMac = (sfnt_platformEntry *)NULL;

	uint32 sizeOfCmap = ptp->ateReq[IT_REQ_CMAP].cj;

    *ppmap = (sfnt_mappingTable  *)NULL;

    if (pcmap->version != 0) // no need to swap bytes, 0 == be 0
        RET_FALSE("TTFD!_bComputeIDs: version number\n");
    if (BE_UINT16(&(pcmap->numTables)) > 30)
    {
        RET_FALSE("Number of cmap tables greater than 30 -- probably a bad font\n");
    }

// find the first sfnt_platformEntry with platformID == PLAT_ID_MS,
// if there was no MS mapping table, go for the mac one
    for (; pplat < pplatEnd; pplat++)
    {
        if (pplat->platformID == BE_PLAT_ID_MS)
        {
            BOOL bRet;
            uint32 offset = (uint32) SWAPL(pplat->offset);
            
            *pui16PlatID = BE_PLAT_ID_MS;
            *pui16SpecID = pplat->specificID;
            if( offset > sizeOfCmap )
            	RET_FALSE("Start position of cmap subtable is out of cmap size -- mustbe bad font\n");

            *ppmap = (sfnt_mappingTable  *) ((PBYTE)pcmap + offset);

            switch((*ppmap)->format)
            {
              case BE_FORMAT_MSFT_UNICODE :

                switch(pplat->specificID)
                {
                  case BE_SPEC_ID_SHIFTJIS :
                  case BE_SPEC_ID_GB :
                  case BE_SPEC_ID_BIG5 :
                  case BE_SPEC_ID_WANSUNG :

                                        bRet = TRUE;
                    break;

                  case BE_SPEC_ID_UGL :
                  default :

                // this will set *pulGsetType to GSET_TYPE_GENERAL

                                        bRet = TRUE;
                    break;
                }
                break;

              case BE_FORMAT_HIGH_BYTE :

                                        bRet = TRUE;
                break;

                default :

                bRet = FALSE;
                break;
            }

            if(!bRet)
            {
                *ppmap = (sfnt_mappingTable  *)NULL;
                RET_FALSE("TTFD!_bComputeIDs: bVerifyMsftTable failed \n");
            }

            // keep specific ID in CMAPINFO

            if (pplat->specificID == BE_SPEC_ID_UNDEFINED)
            {
            // correct the value of the glyph set, we cheat here

                sfnt_OS2 * pOS2 = (sfnt_OS2 *)(
                               (ptp->ateOpt[IT_OPT_OS2].dp)    ?
                               pjView + ptp->ateOpt[IT_OPT_OS2].dp :
                               NULL
                               );

                BOOL bSymbol = FALSE;
                if (pOS2)
                {
                    if (((pOS2->usSelection & 0x00ff) == ANSI_CHARSET) &&
                        (pOS2->Panose[0]==PAN_FAMILY_PICTORIAL)) // means symbol
                        bSymbol = TRUE;
                }

            // this code is put here because of the need to differentiate
            // between msicons2.ttf and bahamn1.ttf.
            // Both of them have Bias = 0, but msicons2 is a symbol font.

            }

            return (TRUE);
        }

        if ((pplat->platformID == BE_PLAT_ID_MAC)  &&
            (pplat->specificID == BE_SPEC_ID_UNDEFINED))
        {
            pplatMac = pplat;
        }
    }

    if (pplatMac != (sfnt_platformEntry *)NULL)
    {
        uint32 offset = (uint32) SWAPL(pplatMac->offset);
        *pui16PlatID = BE_PLAT_ID_MAC;
        *pui16SpecID = BE_SPEC_ID_UNDEFINED;
        if( offset > sizeOfCmap )
           	RET_FALSE("Offset of cmap subtable is out of cmap size -- mustbe bad font\n");

		*ppmap = (sfnt_mappingTable  *) ((PBYTE)pcmap + offset);

        if( offset + (uint16) SWAPW((*ppmap)->length) > sizeOfCmap )
          	RET_FALSE("End position of cmap subtable is out of cmap size -- must be bad font\n");

    //!!! lang issues, what if not roman but thai mac char set ??? [bodind]

    // see if it is necessary to convert unicode to mac code points, or we
    // shall cheat in case of symbol char set for win31 compatiblity

        return(TRUE);
    }
    else
    {
        RET_FALSE("TTFD!_bComputeIDs: unknown platID\n");
    }

}

/******************************Public*Routine******************************\
*
* STATIC BOOL bVerifyMacTable(sfnt_mappingTable * pmap)
*
* just checking consistency of the format
*
* History:
*  23-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bVerifyMacTable(
    sfnt_mappingTable * pmap
    )
{
    if (pmap->format != BE_FORMAT_MAC_STANDARD)
        RET_FALSE("TTFD!_bVerifyMacTable, format \n");

// sfnt_mappingTable is followed by <= 256 byte glyphIdArray

    if (BE_UINT16(&pmap->length) > DWORD_ALIGN(SIZEOF_SFNT_MAPPINGTABLE + 256))
        RET_FALSE("TTFD!_bVerifyMacTable, length \n");

    return (TRUE);
}


/******************************Public*Routine******************************\
*
* BOOL bLoadTTF
*
* Effects:
*
* Warnings:
*
* History:
*  29-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

//!!! SHOUD BE RETURNING hff


#define OFF_TTC_Sign           0x0000
#define OFF_TTC_Version        0x0004
#define OFF_TTC_DirectoryCount 0x0008
#define OFF_TTC_DirectoryEntry 0x000C

#define DSIG_LONG_TAG          0x44534947

#define TTC_VERSION_1_0     0x00010000



ULONG GetUlong( PVOID pvView, ULONG ulOffset)
{
    ULONG ulReturn;

    ulReturn = (  (ULONG)*((PBYTE) pvView + ulOffset +3)              |
                (((ULONG)*((PBYTE) pvView + ulOffset +2)) << 8)  |
                (((ULONG)*((PBYTE) pvView + ulOffset +1)) << 16) |
                (((ULONG)*((PBYTE) pvView + ulOffset +0)) << 24)
               );
    return ( ulReturn );
}


BOOL bVerifyTTC (
    PVOID pvView
    )
{
    ULONG ulVersion;
// Check TTC ID.

    #define TTC_ID      0x66637474

    if(*((PULONG)((BYTE*) pvView + OFF_TTC_Sign)) != TTC_ID)
        return(FALSE);

// Check TTC verson.

    ulVersion = SWAPL(*((PULONG)((BYTE*) pvView + OFF_TTC_Version)));

    if (ulVersion < TTC_VERSION_1_0)
        RETURN("TTFD!ttfdLoadFontFileTTC(): wrong TTC version\n", FALSE);

    return(TRUE);
}

VOID vCopy_IFIV ( GP_PIFIMETRICS pifi, GP_PIFIMETRICS pifiv)
{
    PWCHAR pwchSrc, pwchDst;

    RtlCopyMemory(pifiv, pifi, pifi->cjThis);

//
// modify facename so that it has '@' at the beginning of facename.
//
    pwchSrc = (PWCHAR)((PBYTE)pifiv + pifiv->dpwszFaceName);
    pwchDst = (PWCHAR)((PBYTE)pifi + pifi->dpwszFaceName);

    *pwchSrc++ = L'@';
    while ( *pwchDst )
    {
        *pwchSrc++ = *pwchDst++;
    }

    *pwchSrc = L'\0';

    // modify familyname so that it has '@' at the beginning of familyname

    pwchSrc = (PWCHAR)((PBYTE)pifiv + pifiv->dpwszFamilyName);
    pwchDst = (PWCHAR)((PBYTE)pifi + pifi->dpwszFamilyName);

    *pwchSrc++ = L'@';

    while ( *pwchDst )
    {
        *pwchSrc++ = *pwchDst++;
    }

    *pwchSrc = L'\0';

    if(pifiv->flInfo & FM_INFO_FAMILY_EQUIV)
    {
        pwchSrc++;
        pwchDst++;

        *pwchSrc++ = L'@';

        while ( *pwchDst )
        {
            *pwchSrc++ = *pwchDst++;
        }

        *pwchSrc++ = L'\0';
        *pwchSrc = L'\0';
    }

}

BOOL bLoadFontFile (
    ULONG_PTR   iFile,
    PVOID       pvView,
    ULONG       cjView,
    ULONG       ulLangId,
    HFF   *     phttc
    )
{
    BOOL           bRet = FALSE;

    BOOL           bTTCFormat;
    PTTC_FONTFILE  pttc;
    ULONG          cjttc;
    ULONG          i;

    HFF hff;

    PTTC_CACHE      pCache_TTC;
    PTTF_CACHE      pCache_TTF;
    ULONG           ulSize;

    *phttc = (HFF)NULL; // Important for clean up in case of exception


    if (sizeof(sfnt_OffsetTable) > cjView)
            RETURN("TTFD!bLoadFontFile(): size of font file too small\n", FALSE);


// How mamy TrueType resources in this file if TTC file.

// Look up the fontcache for IFI metrices

    pCache_TTC = NULL;
    pCache_TTF = NULL;

// Check this is a TrueType collection format or not.
    bTTCFormat = bVerifyTTC(pvView);

    if(bTTCFormat)
    {
        ULONG     ulTrueTypeResource;
        ULONG     ulEntry;
        BOOL      bCanBeLoaded = TRUE;

    // Get Directory count
        ulTrueTypeResource = GetUlong(pvView,OFF_TTC_DirectoryCount);

        {   // defense against overflow in cjttc calculations
            static const ULONG ulTrueTypeResourceMax =
                (ULONG_MAX - offsetof(TTC_FONTFILE,ahffEntry))/(sizeof(TTC_HFF_ENTRY) * 2);
            if (ulTrueTypeResource >= ulTrueTypeResourceMax ||
                ulTrueTypeResource > (cjView - OFF_TTC_DirectoryEntry)/sizeof(ULONG))
                RETURN("TTFD!bLoadFontFile(): size of font file too small for ttc directory\n", FALSE);
        }

   // Allocate TTC_FONTFILE structure

        cjttc =  offsetof(TTC_FONTFILE,ahffEntry);
        cjttc += sizeof(TTC_HFF_ENTRY) * ulTrueTypeResource * 2; // *2 for Vertical face

        *phttc = (HFF)pttcAlloc(cjttc);

        pttc = (PTTC_FONTFILE)*phttc;

        if(pttc == (HFF)NULL)
            RETURN("TTFD!ttfdLoadFontFileTTC(): pttcAlloc failed\n", FALSE);


    // fill hff array in TTC_FONTFILE struture

        ulEntry = 0;

        for(i = 0; i < ulTrueTypeResource; i++ )
        {
            ULONG    ulOffset;


            pCache_TTF = NULL;
            ulOffset = GetUlong(pvView,(OFF_TTC_DirectoryEntry + i * sizeof(ULONG)));

        // load font..

            pttc->ahffEntry[ulEntry].iFace = 1; // start from 1.
            pttc->ahffEntry[ulEntry].ulOffsetTable = ulOffset;

            if (bLoadTTF(iFile,pvView,cjView,ulOffset,ulLangId,
                            &pttc->ahffEntry[ulEntry].hff))
            {
                hff = pttc->ahffEntry[ulEntry].hff;

            // set pointer to TTC_FONTFILE in FONTFILE structure

                PFF(hff)->pttc = pttc;

                ASSERTDD(
                    PFF(hff)->ffca.ulNumFaces <= 2,
                    "TTFD!ulNumFaces > 2\n"
                    );

                if (PFF(hff)->ffca.ulNumFaces == 2)
                {
                    pttc->ahffEntry[ulEntry + 1].hff    = hff;
                    pttc->ahffEntry[ulEntry + 1].iFace  = 1; // start from 1.
                    pttc->ahffEntry[ulEntry + 1].ulOffsetTable = ulOffset;
                }

                ulEntry += PFF(hff)->ffca.ulNumFaces;
            }
            else
            {
                bCanBeLoaded = FALSE;
                break;
            }
        }

    // Is there a font that could be loaded ?

        if(bCanBeLoaded)
        {
            ASSERTDD(
                (ulTrueTypeResource * 2) >= ulEntry,
                "TTFD!ulTrueTypeResource * 2 < ulEntry\n"
                );

            pttc->ulTrueTypeResource = ulTrueTypeResource;
            pttc->ulNumEntry         = ulEntry;
            pttc->cRef               = 0;
            pttc->fl                 = 0;

            bRet = TRUE;
        }
        else
        {
            for (i = 0; i < ulEntry; i++)
            {
                if(pttc->ahffEntry[i].iFace == 1)
                    ttfdUnloadFontFile(pttc->ahffEntry[i].hff);
            }

            //WARNING("TTFD!No TrueType resource in this TTC file\n");
            vFreeTTC(*phttc);
            *phttc = (HFF)NULL;
        }
    }
    else
    {
    // This is the case of the single TTF being loaded (NOT TTC)
    // Allocate TTC_FONTFILE structure

        cjttc =  offsetof(TTC_FONTFILE,ahffEntry) + sizeof(TTC_HFF_ENTRY) * 2; // *2 for Vertical face

        *phttc = (HFF)pttcAlloc(cjttc);

        pttc = (PTTC_FONTFILE)*phttc;

        if(pttc != (HFF)NULL)
        {
            pttc->ahffEntry[0].iFace = 1;
            pttc->ahffEntry[0].ulOffsetTable = 0;

            if(bLoadTTF(iFile,pvView,cjView,0,ulLangId,
                            &pttc->ahffEntry[0].hff))
            {
                hff = pttc->ahffEntry[0].hff;

            // set pointer to TTC_FONTFILE in FONTFILE structure

                PFF(hff)->pttc = pttc;

            // fill hff array in TTC_FONTFILE struture

                pttc->ulTrueTypeResource = 1;
                pttc->ulNumEntry         = PFF(hff)->ffca.ulNumFaces;
                pttc->cRef               = 0;
                pttc->fl                 = 0;

            // fill up TTC_FONTFILE structure for each faces.

                ASSERTDD(
                    PFF(hff)->ffca.ulNumFaces <= 2,
                    "TTFD!ulNumFaces > 2\n"
                    );

                if (PFF(hff)->ffca.ulNumFaces == 2)
                {
                    pttc->ahffEntry[1].hff   = hff;
                    pttc->ahffEntry[1].iFace = 2;
                    pttc->ahffEntry[1].ulOffsetTable = 0;
                }

            // now, everything is o.k.

                bRet = TRUE;
            }
            else
            {
                vFreeTTC(*phttc);
                *phttc = (HFF)NULL;
            }
        }
        else
        {
            //WARNING("TTFD!ttfdLoadFontFileTTC(): pttcAlloc failed\n");
        }
    }

    return bRet;
}


STATIC BOOL
bLoadTTF (
    ULONG_PTR iFile,
    PVOID     pvView,
    ULONG     cjView,
    ULONG     ulTableOffset,
    ULONG     ulLangId,
    HFF       *phff
    )
{
    PFONTFILE      pff;
    FS_ENTRY       iRet;
    TABLE_POINTERS tp;
    IFISIZE        ifisz;
    fs_GlyphInputType   gin;
    fs_GlyphInfoType    gout;

    sfnt_FontHeader * phead;

    uint16 ui16PlatID, ui16SpecID;
    sfnt_mappingTable *pmap;
    ULONG              ulGsetType;
    ULONG              cjff, dpwszTTF;
    ULONG              ul_wcBias;

// the size of this structure is sizeof(fs_SplineKey) + STAMPEXTRA.
// It is because of STAMPEXTRA that we are not just putting the strucuture
// on the stack such as fs_SplineKey sk; we do not want to overwrite the
// stack at the bottom when putting a stamp in the STAMPEXTRA field.
// [bodind]. The other way to obtain the correct alignment would be to use
// union of fs_SplineKey and the array of bytes of length CJ_0.

    NATURAL             anat0[CJ_0 / sizeof(NATURAL)];

    PBYTE pjOffsetTable = (BYTE*) pvView + ulTableOffset;
    GP_PIFIMETRICS        pifiv = NULL; // ifimetrics for the vertical face

    ASSERTDD(sizeof(FONTFILE) == offsetof(FONTFILE,ifi) + sizeof(GP_IFIMETRICS),
            "TTFD! GP_IFIMETRICS is not the last field of FONTFILE\n");

    *phff = HFF_INVALID;

    {
        if(!bVerifyTTF(iFile,
                        pvView,
                        cjView,
                        pjOffsetTable,
                        ulLangId,
                        &tp,
                        &ifisz,
                        &ui16PlatID,
                        &ui16SpecID,
                        &pmap,
                        &ulGsetType,
                        &ul_wcBias
            ))
        {
            return(FALSE);
        }

        cjff = offsetof(FONTFILE,ifi) + ifisz.cjIFI;


    // at this point cjff is equal to the offset to the full path
    // name of the ttf file

        dpwszTTF = cjff;


        if ((pff = pffAlloc(cjff)) == PFF(NULL))
        {
            RET_FALSE("TTFD!ttfdLoadFontFile(): memory allocation error\n");
        }

        *phff = (HFF)pff;

    /* we need to clean the beginning of pff to ensure correct cleanup in case of error/exception */

        RtlZeroMemory((PVOID)pff, offsetof(FONTFILE,ifi));

    // init fields of pff structure
    // store the ttf file name at the bottom of the strucutre

        phead = (sfnt_FontHeader *)((BYTE *)pvView + tp.ateReq[IT_REQ_HEAD].dp);

    // remember which file this is

        pff->iFile = iFile;
        pff->pvView = pvView;
        pff->cjView = cjView;

        pff->ffca.ui16EmHt = BE_UINT16(&phead->unitsPerEm);
        if (pff->ffca.ui16EmHt < 16 || pff->ffca.ui16EmHt > 16384)
        {
            vFreeFF(*phff);
            *phff = (HFF)NULL;
            RET_FALSE("TTFD!bLoadTTF(): invalid unitsPerEm value\n");
        }
        pff->ffca.ui16PlatformID = ui16PlatID;
        pff->ffca.ui16SpecificID = ui16SpecID;

    // so far no exception

        pff->pfcToBeFreed = NULL;

    // convert Language id to macintosh style if this is mac style file
    // else leave it alone, store it in be format, ready to be compared
    // with the values in the font files

        pff->ffca.ui16LanguageID = ui16BeLangId(ui16PlatID,ulLangId);
        pff->ffca.dpMappingTable = (ULONG)((BYTE*)pmap - (BYTE*)pvView);

    // initialize count of HFC's associated with this HFF

        pff->cRef    = 0L;

    // cache pointers to ttf tables and ifi metrics size info

        pff->ffca.tp    = tp;

    // used for TTC fonts

        pff->ffca.ulTableOffset = ulTableOffset;

    // Notice that this information is totaly independent
    // of the font file in question, seems to be right according to fsglue.h
    // and compfont code

        if ((iRet = fs_OpenFonts(&gin, &gout)) != NO_ERR)
        {
            V_FSERROR(iRet);
            vFreeFF(*phff);
            *phff = (HFF)NULL;
            return (FALSE);
        }

        ASSERTDD(NATURAL_ALIGN(gout.memorySizes[0]) == CJ_0, "mem size 0\n");
        ASSERTDD(gout.memorySizes[1] == 0,  "mem size 1\n");


    #if DBG
        if (gout.memorySizes[2] != 0)
            TtfdDbgPrint("TTFD!_mem size 2 = 0x%lx \n", gout.memorySizes[2]);
    #endif

        gin.memoryBases[0] = (char *)anat0;
        gin.memoryBases[1] = NULL;
        gin.memoryBases[2] = NULL;

    // initialize the font scaler, notice no fields of gin are initialized [BodinD]

        if ((iRet = fs_Initialize(&gin, &gout)) != NO_ERR)
        {
        // clean up and return:
    
            V_FSERROR(iRet);
            vFreeFF(*phff);
            *phff = (HFF)NULL;
            RET_FALSE("TTFD!_ttfdLoadFontFile(): fs_Initialize \n");
        }

// initialize info needed by NewSfnt function

        gin.sfntDirectory  = (int32 *)pff->pvView; // pointer to the top of the view of
                                                   // the ttf file

        gin.clientID = (ULONG_PTR)pff;  // pointer to the top of the view of the ttf file

        gin.GetSfntFragmentPtr = pvGetPointerCallback;
        gin.ReleaseSfntFrag  = vReleasePointerCallback;

        gin.param.newsfnt.platformID = BE_UINT16(&pff->ffca.ui16PlatformID);
        gin.param.newsfnt.specificID = BE_UINT16(&pff->ffca.ui16SpecificID);

        if ((iRet = fs_NewSfnt(&gin, &gout)) != NO_ERR)
        {
        // clean up and exit

            V_FSERROR(iRet);
            vFreeFF(*phff);
            *phff = (HFF)NULL;
            RET_FALSE("TTFD!_ttfdLoadFontFile(): fs_NewSfnt \n");
        }

        pff->pj034   = (PBYTE)NULL;
        pff->pfcLast = (FONTCONTEXT *)NULL;

        pff->ffca.cj3 = NATURAL_ALIGN(gout.memorySizes[3]);
        pff->ffca.cj4 = NATURAL_ALIGN(gout.memorySizes[4]);


        if(tp.ateOpt[IT_OPT_VHEA].dp != 0 &&
           tp.ateOpt[IT_OPT_VMTX].dp != 0 )
        {
            sfnt_vheaTable *pvheaTable;

            pvheaTable = (sfnt_vheaTable *)((BYTE *)(pff->pvView) +
                                           tp.ateOpt[IT_OPT_VHEA].dp);
            pff->ffca.uLongVerticalMetrics = (uint16) SWAPW(pvheaTable->numOfLongVerMetrics);
        }
        else
        {
            pff->ffca.uLongVerticalMetrics = 0;
        }

    // By default the number of faces is 1L.  The vert facename code may change this.

        pff->ffca.ulNumFaces = 1L;
        pff->pifi_vertical = NULL;

    // finally compute the ifimetrics for this font, this assumes that gset has
    // also been computed

    // if ifimetrics are stored in the boot cache, copy them out, else compute ifimetrics

        vFill_IFIMETRICS(pff,&pff->ifi,&ifisz, &gin);

        return (TRUE);
    }
}

/******************************Public*Routine******************************\
*
* STATIC BOOL bCvtUnToMac
*
* the following piece of code is stolen from JeanP and
* he claims that this piece of code is lousy and checks whether
* we the font is a SYMBOL font in which case unicode to mac conversion
* should be disabled, according to JeanP (??? who understands this???)
* This piece of code actually applies to symbol.ttf [bodind]
*
*
* History:
*  24-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bCvtUnToMac(
    BYTE           *pjView,
    TABLE_POINTERS *ptp,
    uint16 ui16PlatformID
    )
{
// Find out if we have a Mac font and if the Mac charset translation is needed

    BOOL bUnToMac = (ui16PlatformID == BE_PLAT_ID_MAC);

    if (bUnToMac) // change your mind if needed
    {
        sfnt_PostScriptInfo *ppost;

        ppost = (ptp->ateOpt[IT_OPT_POST].dp)                                ?
                (sfnt_PostScriptInfo *)(pjView + ptp->ateOpt[IT_OPT_POST].dp):
                NULL;

        if
        (
            ppost &&
            (BE_UINT32((BYTE*)ppost + POSTSCRIPTNAMEINDICES_VERSION) == 0x00020000)
        )
        {
            INT i, cGlyphs;

            cGlyphs = (INT)BE_UINT16(&ppost->numberGlyphs);

            for (i = 0; i < cGlyphs; i++)
            {
                uint16 iNameIndex = ppost->postScriptNameIndices.glyphNameIndex[i];
                if ((int8)(iNameIndex & 0xff) && ((int8)(iNameIndex >> 8) > 1))
                    break;
            }

            if (i < cGlyphs)
                bUnToMac = FALSE;
        }
    }
    return bUnToMac;
}


// Weight (must convert from IFIMETRICS weight to Windows LOGFONT.lfWeight).

// !!! [Windows 3.1 compatibility]
//     Because of some fonts shipped with WinWord, if usWeightClass is 10
//     or above, then usWeightClass == lfWeight.  All other cases, use
//     the conversion table.

// pan wt -> Win weight converter:

STATIC USHORT ausIFIMetrics2WinWeight[10] = {
            0, 100, 200, 300, 350, 400, 600, 700, 800, 900
            };

STATIC BYTE
ajPanoseFamily[16] = {
     FF_DONTCARE       //    0 (Any)
    ,FF_DONTCARE       //    1 (No Fit)
    ,FF_ROMAN          //    2 (Cove)
    ,FF_ROMAN          //    3 (Obtuse Cove)
    ,FF_ROMAN          //    4 (Square Cove)
    ,FF_ROMAN          //    5 (Obtuse Square Cove)
    ,FF_ROMAN          //    6 (Square)
    ,FF_ROMAN          //    7 (Thin)
    ,FF_ROMAN          //    8 (Bone)
    ,FF_ROMAN          //    9 (Exaggerated)
    ,FF_ROMAN          //   10 (Triangle)
    ,FF_SWISS          //   11 (Normal Sans)
    ,FF_SWISS          //   12 (Obtuse Sans)
    ,FF_SWISS          //   13 (Perp Sans)
    ,FF_SWISS          //   14 (Flared)
    ,FF_SWISS          //   15 (Rounded)
    };


static BYTE
ajPanoseFamilyForJapanese[16] = {
     FF_DONTCARE       //    0 (Any)
    ,FF_DONTCARE       //    1 (No Fit)
    ,FF_ROMAN          //    2 (Cove)
    ,FF_ROMAN          //    3 (Obtuse Cove)
    ,FF_ROMAN          //    4 (Square Cove)
    ,FF_ROMAN          //    5 (Obtuse Square Cove)
    ,FF_ROMAN          //    6 (Square)
    ,FF_ROMAN          //    7 (Thin)
    ,FF_ROMAN          //    8 (Bone)
    ,FF_ROMAN          //    9 (Exaggerated)
    ,FF_ROMAN          //   10 (Triangle)
    ,FF_MODERN         //   11 (Normal Sans)
    ,FF_MODERN         //   12 (Obtuse Sans)
    ,FF_MODERN         //   13 (Perp Sans)
    ,FF_MODERN         //   14 (Flared)
    ,FF_MODERN         //   15 (Rounded)
    };


/******************************Public*Routine******************************\
*
* vFill_IFIMETRICS
*
* Effects: Looks into the font file and fills IFIMETRICS
*
* History:
*  Mon 09-Mar-1992 10:51:56 by Kirk Olynyk [kirko]
* Added Kerning Pair support.
*  18-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


STATIC VOID
vFill_IFIMETRICS(
    PFONTFILE       pff,
    GP_PIFIMETRICS     pifi,
    PIFISIZE        pifisz,
    fs_GlyphInputType     *pgin
    )
{
    BYTE           *pjView = (BYTE*)pff->pvView;
    PTABLE_POINTERS ptp = &pff->ffca.tp;

// ptrs to various tables of tt files

    sfnt_FontHeader *phead =
        (sfnt_FontHeader *)(pjView + ptp->ateReq[IT_REQ_HEAD].dp);

    sfnt_maxProfileTable * pmaxp =
        (sfnt_maxProfileTable *)(pjView + ptp->ateReq[IT_REQ_MAXP].dp);

    sfnt_HorizontalHeader *phhea =
        (sfnt_HorizontalHeader *)(pjView + ptp->ateReq[IT_REQ_HHEAD].dp);

    sfnt_PostScriptInfo   *ppost = (sfnt_PostScriptInfo *) (
                           (ptp->ateOpt[IT_OPT_POST].dp)        ?
                           pjView + ptp->ateOpt[IT_OPT_POST].dp :
                           NULL
                           );

    PBYTE  pjOS2 = (ptp->ateOpt[IT_OPT_OS2].dp)        ?
                   pjView + ptp->ateOpt[IT_OPT_OS2].dp :
                   NULL                                ;

    pifi->cjThis    = pifisz->cjIFI;
    
// enter the number of distinct font indicies

    pifi->cig = BE_UINT16(&pmaxp->numGlyphs);

// get name strings info
    {
#if DBG 
        BOOL ok =
#endif
        bConvertExtras(pifi, pifisz, pff->ffca.ui16LanguageID);
        ASSERTDD(ok, "bConvertExtras returned FALSE on second pass\n");

        pifi->dpwszFamilyName = pifisz->dpFamilyName;
        pifi->dpwszUniqueName = pifisz->dpUniqueName;
        pifi->dpwszFaceName   = pifisz->dpFullName;
        pifi->dpwszStyleName  = pifisz->dpSubfamilyName;
    }

//
// flInfo
//
    pifi->flInfo = (
                     FM_INFO_TECH_TRUETYPE    |
                     FM_INFO_ARB_XFORMS       |
                     FM_INFO_RETURNS_OUTLINES |
                     FM_INFO_RETURNS_BITMAPS  |
                     FM_INFO_1BPP             | // monochrome
                     FM_INFO_4BPP             | // anti-aliased too
                     FM_INFO_RIGHT_HANDED
                   );
    {
        ULONG cjDSIG;

        if (pff->ffca.ulTableOffset == 0)
        {
            if (pjTable('GISD', pff, &cjDSIG) && cjDSIG)
            {
                pifi->flInfo |= FM_INFO_DSIG;
            }
        }
        else
        {
            ULONG     ulValue;
            ULONG     ulOffset;

            // Get Directory count.

            ulValue = GetUlong(pff->pvView,OFF_TTC_DirectoryCount);

            ulOffset = OFF_TTC_DirectoryEntry + (sizeof(ULONG) * ulValue);

            // Read the DSIG_LONG_TAG

            ulValue = GetUlong(pff->pvView,ulOffset);

            if (ulValue == DSIG_LONG_TAG)
            {
                pifi->flInfo |= FM_INFO_DSIG;
            }
        }
    }

    pifi->familyNameLangID = pifisz->langID;
    pifi->familyAliasNameLangID = 0;

    if (pifisz->pjFamilyNameAlias )
    {
        pifi->flInfo |= FM_INFO_FAMILY_EQUIV;
        pifi->familyAliasNameLangID = pifisz->aliasLangID;
    }

    if (ppost && BE_UINT32((BYTE*)ppost + POSTSCRIPTNAMEINDICES_ISFIXEDPITCH))
    {
        pifi->flInfo |= FM_INFO_OPTICALLY_FIXED_PITCH;
    }

// fsSelection

    pifi->fsSelection = fsSelectionTTFD(pjView, ptp);

// em height

    pifi->fwdUnitsPerEm = (FWORD) BE_INT16(&phead->unitsPerEm);

// ascender, descender, linegap

    pifi->fwdMacAscender    = (FWORD) BE_INT16(&phhea->yAscender);
    pifi->fwdMacDescender   = (FWORD) BE_INT16(&phhea->yDescender);
    pifi->fwdMacLineGap     = (FWORD) BE_INT16(&phhea->yLineGap);

    if (pjOS2)
    {
        pifi->fwdWinAscender    = (FWORD) BE_INT16(pjOS2 + OFF_OS2_usWinAscent);
        pifi->fwdWinDescender   = (FWORD) BE_INT16(pjOS2 + OFF_OS2_usWinDescent);
        pifi->fwdTypoAscender   = (FWORD) BE_INT16(pjOS2 + OFF_OS2_sTypoAscender);
        pifi->fwdTypoDescender  = (FWORD) BE_INT16(pjOS2 + OFF_OS2_sTypoDescender);
        pifi->fwdTypoLineGap    = (FWORD) BE_INT16(pjOS2 + OFF_OS2_sTypoLineGap);
    }
    else
    {
        pifi->fwdWinAscender    = pifi->fwdMacAscender;
        pifi->fwdWinDescender   = -(pifi->fwdMacDescender);
        pifi->fwdTypoAscender   = pifi->fwdMacAscender;
        pifi->fwdTypoDescender  = pifi->fwdMacDescender;
        pifi->fwdTypoLineGap    = pifi->fwdMacLineGap;
    }

// font box

    pifi->rclFontBox.left   = (LONG)((FWORD)BE_INT16(&phead->xMin));
    pifi->rclFontBox.top    = (LONG)((FWORD)BE_INT16(&phead->yMax));
    pifi->rclFontBox.right  = (LONG)((FWORD)BE_INT16(&phead->xMax));
    pifi->rclFontBox.bottom = (LONG)((FWORD)BE_INT16(&phead->yMin));

// fwdMaxCharInc -- really the maximum character width
//
// [Windows 3.1 compatibility]
// Note: Win3.1 calculates max char width to be equal to the width of the
// bounding box (Font Box).  This is actually wrong since the bounding box
// may pick up its left and right max extents from different glyphs,
// resulting in a bounding box that is wider than any single glyph.  But
// this is the way Windows 3.1 does it, so that's the way we'll do it.

    // pifi->fwdMaxCharInc = (FWORD) BE_INT16(&phhea->advanceWidthMax);

    pifi->fwdMaxCharInc = (FWORD) (pifi->rclFontBox.right - pifi->rclFontBox.left);

// fwdAveCharWidth

    if (pjOS2)
    {
        pifi->fwdAveCharWidth = (FWORD)BE_INT16(pjOS2 + OFF_OS2_xAvgCharWidth);

    // This is here for Win 3.1 compatibility since some apps expect non-
    // zero widths and Win 3.1 does the same in this case.

        if( pifi->fwdAveCharWidth == 0 )
            pifi->fwdAveCharWidth = (FWORD)(pifi->fwdMaxCharInc / 2);
    }
    else
    {
        pifi->fwdAveCharWidth = (FWORD)((pifi->fwdMaxCharInc * 2) / 3);
    }

// !!! New code needed [kirko]
// The following is done for Win 3.1 compatibility
// reasons. The correct thing to do would be to look for the
// existence of the 'PCLT'Z table and retieve the XHeight and CapHeight
// fields, otherwise use the default Win 3.1 behavior.

    pifi->fwdCapHeight   = pifi->fwdUnitsPerEm/2;
    pifi->fwdXHeight     = pifi->fwdUnitsPerEm/4;

// Underscore, Subscript, Superscript, Strikeout

    if (ppost)
    {
        pifi->fwdUnderscoreSize     = (FWORD)BE_INT16(&ppost->underlineThickness);
        pifi->fwdUnderscorePosition = (FWORD)BE_INT16(&ppost->underlinePosition);
    }
    else
    {
    // must provide reasonable defaults, when there is no ppost table,
    // win 31 sets these quantities to zero. This does not sound reasonable.
    // I will supply the (relative) values the same as for arial font. [bodind]

        pifi->fwdUnderscoreSize     = (pifi->fwdUnitsPerEm + 7)/14;
        pifi->fwdUnderscorePosition = -((pifi->fwdUnitsPerEm + 5)/10);
    }

    if (pjOS2)
    {
        pifi->fwdStrikeoutSize      = BE_INT16(pjOS2 + OFF_OS2_yStrikeOutSize    );
        pifi->fwdStrikeoutPosition  = BE_INT16(pjOS2 + OFF_OS2_yStrikeOutPosition);
    }
    else
    {
        pifi->fwdStrikeoutSize      = pifi->fwdUnderscoreSize;
        pifi->fwdStrikeoutPosition  = (FWORD)(pifi->fwdMacAscender / 3) ;
    }


//
// panose
//
    if (pjOS2)
    {
        pifi->usWinWeight = BE_INT16(pjOS2 + OFF_OS2_usWeightClass);

    // now comes a hack from win31. Here is the comment from fonteng2.asm:

    // MAXPMWEIGHT equ ($ - pPM2WinWeight)/2 - 1

    //; Because winword shipped early TT fonts, - only index usWeightClass
    //; if between 0 and 9.  If above 9 then treat as a normal Windows lfWeight.
    //
    //        cmp     bx,MAXPMWEIGHT
    //        ja      @f                      ;jmp if weight is ok as is
    //        shl     bx, 1                   ;make it an offset into table of WORDs
    //        mov     bx, cs:[bx].pPM2WinWeight
    //@@:     xchg    ax, bx
    //        stosw                           ;store font weight

    // we emulate this in NT:

#define MAXPMWEIGHT ( sizeof(ausIFIMetrics2WinWeight) / sizeof(ausIFIMetrics2WinWeight[0]) )

        if (pifi->usWinWeight < MAXPMWEIGHT)
            pifi->usWinWeight = ausIFIMetrics2WinWeight[pifi->usWinWeight];

        RtlCopyMemory((PVOID)&pifi->panose,
                      (PVOID)(pjOS2 + OFF_OS2_Panose), sizeof(PANOSE));


        if(pifi->panose.bProportion == PAN_PROP_MONOSPACED)
        {
            pifi->flInfo |= FM_INFO_OPTICALLY_FIXED_PITCH;
        }

    }
    else  // os2 table is not present
    {
        pifi->panose.bFamilyType       = PAN_FAMILY_TEXT_DISPLAY;
        pifi->panose.bSerifStyle       = PAN_ANY;
        pifi->panose.bWeight           = (BYTE)
           ((phead->macStyle & BE_MSTYLE_BOLD) ?
            PAN_WEIGHT_BOLD                    :
            PAN_WEIGHT_BOOK
           );
        pifi->panose.bProportion       = (BYTE)
            ((pifi->flInfo & FM_INFO_OPTICALLY_FIXED_PITCH) ?
             PAN_PROP_MONOSPACED                     :
             PAN_ANY
            );
        pifi->panose.bContrast         = PAN_ANY;
        pifi->panose.bStrokeVariation  = PAN_ANY;
        pifi->panose.bArmStyle         = PAN_ANY;
        pifi->panose.bLetterform       = PAN_ANY;
        pifi->panose.bMidline          = PAN_ANY;
        pifi->panose.bXHeight          = PAN_ANY;

    // have to fake it up, cause we can not read it from the os2 table
    // really important to go through this table for compatibility reasons [bodind]

        pifi->usWinWeight =
            ausIFIMetrics2WinWeight[pifi->panose.bWeight];
    }



//!!! one should look into directional hints here, this is good for now

    pifi->ptlBaseline.x   = 1;
    pifi->ptlBaseline.y   = 0;

// this is what win 31 is doing, so we will do the same thing [bodind]

    pifi->ptlCaret.x = (LONG)BE_INT16(&phhea->horizontalCaretSlopeDenominator);
    pifi->ptlCaret.y = (LONG)BE_INT16(&phhea->horizontalCaretSlopeNumerator);

// We have to use one of the reserved fields to return the italic angle.

    if (ppost)
    {
    // The italic angle is stored in the POST table as a 16.16 fixed point
    // number.  We want the angle expressed in tenths of a degree.  What we
    // can do here is multiply the entire 16.16 number by 10.  The most
    // significant 16-bits of the result is the angle in tenths of a degree.
    //
    // In the conversion below, we don't care whether the right shift is
    // arithmetic or logical because we are only interested in the lower
    // 16-bits of the result.  When the 16-bit result is cast back to LONG,
    // the sign is restored.

        int16 iTmp;

        iTmp = (int16) ((BE_INT32((BYTE*)ppost + POSTSCRIPTNAMEINDICES_ITALICANGLE) * 10) >> 16);
        pifi->lItalicAngle = (LONG) iTmp;
    }
    else
        pifi->lItalicAngle = 0;

// simulation information:

    if (pifi->dpFontSim = pifisz->dpSims)
    {
        FONTDIFF FontDiff;
        FONTSIM * pfsim = (FONTSIM *)((BYTE *)pifi + pifi->dpFontSim);
        FONTDIFF *pfdiffBold       = NULL;
        FONTDIFF *pfdiffItalic     = NULL;
        FONTDIFF *pfdiffBoldItalic = NULL;

        switch (pifi->fsSelection & (FM_SEL_ITALIC | FM_SEL_BOLD))
        {
        case 0:
        // all 3 simulations are present

            pfsim->dpBold       = DWORD_ALIGN(sizeof(FONTSIM));
            pfsim->dpItalic     = pfsim->dpBold + DWORD_ALIGN(sizeof(FONTDIFF));
            pfsim->dpBoldItalic = pfsim->dpItalic + DWORD_ALIGN(sizeof(FONTDIFF));

            pfdiffBold       = (FONTDIFF *)((BYTE*)pfsim + pfsim->dpBold);
            pfdiffItalic     = (FONTDIFF *)((BYTE*)pfsim + pfsim->dpItalic);
            pfdiffBoldItalic = (FONTDIFF *)((BYTE*)pfsim + pfsim->dpBoldItalic);

            break;

        case FM_SEL_ITALIC:
        case FM_SEL_BOLD:

        // only bold italic variation is present:

            pfsim->dpBold       = 0;
            pfsim->dpItalic     = 0;

            pfsim->dpBoldItalic = DWORD_ALIGN(sizeof(FONTSIM));
            pfdiffBoldItalic = (FONTDIFF *)((BYTE*)pfsim + pfsim->dpBoldItalic);

            break;

        case (FM_SEL_ITALIC | FM_SEL_BOLD):
            //RIP("ttfd!another case when flags have been messed up\n");
            break;
        }

    // template reflecting a base font:
    // (note that the FM_SEL_REGULAR bit is masked off because none of
    // the simulations generated will want this flag turned on).

        FontDiff.jReserved1      = 0;
        FontDiff.jReserved2      = 0;
        FontDiff.jReserved3      = 0;
        FontDiff.bWeight         = pifi->panose.bWeight;
        FontDiff.usWinWeight     = pifi->usWinWeight;
        FontDiff.fsSelection     = pifi->fsSelection & ~FM_SEL_REGULAR;
        FontDiff.fwdAveCharWidth = pifi->fwdAveCharWidth;
        FontDiff.fwdMaxCharInc   = pifi->fwdMaxCharInc;
        FontDiff.ptlCaret        = pifi->ptlCaret;

    //
    // Create FONTDIFFs from the base font template
    //
        if (pfdiffBold)
        {
            *pfdiffBold = FontDiff;
            pfdiffBoldItalic->bWeight    = PAN_WEIGHT_BOLD;
            pfdiffBold->fsSelection     |= FM_SEL_BOLD;
            pfdiffBold->usWinWeight      = FW_BOLD;

        // really only true if ntod transform is unity

            pfdiffBold->fwdAveCharWidth += 1;
            pfdiffBold->fwdMaxCharInc   += 1;
        }

        if (pfdiffItalic)
        {
            *pfdiffItalic = FontDiff;
            pfdiffItalic->fsSelection     |= FM_SEL_ITALIC;

            pfdiffItalic->ptlCaret.x = CARET_X;
            pfdiffItalic->ptlCaret.y = CARET_Y;
        }

        if (pfdiffBoldItalic)
        {
            *pfdiffBoldItalic = FontDiff;
            pfdiffBoldItalic->bWeight          = PAN_WEIGHT_BOLD;
            pfdiffBoldItalic->fsSelection     |= (FM_SEL_BOLD | FM_SEL_ITALIC);
            pfdiffBoldItalic->usWinWeight      = FW_BOLD;

            pfdiffBoldItalic->ptlCaret.x       = CARET_X;
            pfdiffBoldItalic->ptlCaret.y       = CARET_Y;

            pfdiffBoldItalic->fwdAveCharWidth += 1;
            pfdiffBoldItalic->fwdMaxCharInc   += 1;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\dbg.h ===
/******************************Module*Header*******************************\
* Module Name: dbg.h
*
* several debug routines
*
* Created: 20-Feb-1992 16:00:36
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
*
\**************************************************************************/




// all the routines in this file MUST BE under DBG


#if DBG


VOID TtfdDbgPrint(PCHAR DebugMessage,...);


#define ASSERTDD(x,y) { if (!(x)) { TtfdDbgPrint(y); EngDebugBreak();} }

#else

#define ASSERTDD(x,y)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\fontddi.h ===
/*++

Copyright (c) 1985-1998, Microsoft Corporation

Module Name:

    fontddi.h

Abstract:

    Private entry points, defines and types for Windows NT GDI device
    driver interface.

--*/

#ifndef _FONTDDI_
#define _FONTDDI_



#ifdef __cplusplus
extern "C" {
#endif

typedef ULONG       HGLYPH;
typedef LONG        FIX;

#define HGLYPH_INVALID ((HGLYPH)-1)

typedef struct  _POINTFIX
{
    FIX   x;
    FIX   y;
} POINTFIX, *PPOINTFIX;

typedef struct _POINTQF    // ptq
{
    LARGE_INTEGER x;
    LARGE_INTEGER y;
} POINTQF, *PPOINTQF;


typedef struct _PATHOBJ
{
    FLONG   fl;
    ULONG   curveCount;
} PATHOBJ;

typedef struct _GLYPHBITS
{
    POINTL      ptlUprightOrigin;
    POINTL      ptlSidewaysOrigin;
    SIZEL       sizlBitmap;
    BYTE        aj[1];
} GLYPHBITS;

typedef union _GLYPHDEF
{
    GLYPHBITS  *pgb;
    PATHOBJ    *ppo;
} GLYPHDEF;

typedef struct _GLYPHDATA {
        GLYPHDEF gdf;               // pointer to GLYPHBITS or to PATHOBJ
        HGLYPH   hg;                // glyhp handle
        FIX      fxD;               // Character increment amount: D*r.
        FIX      fxA;               // Prebearing amount: A*r.
        FIX      fxAB;              // Advancing edge of character: (A+B)*r.
        FIX      fxD_Sideways;      // Character increment amount: D*r. for sideways characters in vertical writing
        FIX      fxA_Sideways;      // Prebearing amount: A*r. for sideways characters in vertical writing
        FIX      fxAB_Sideways;     // Advancing edge of character: (A+B)*r. for sideways characters in vertical writing
        FIX      VerticalOrigin_X;
        FIX      VerticalOrigin_Y;
        RECTL    rclInk;            // Ink box with sides parallel to x,y axes
} GLYPHDATA;


typedef LONG        PTRDIFF;
typedef PTRDIFF    *PPTRDIFF;
typedef ULONG       ROP4;
typedef ULONG       MIX;

typedef ULONG           IDENT;
typedef FLOAT           FLOATL;

//
// handles for font file and font context objects
//

typedef ULONG_PTR HFF;

#define HFF_INVALID ((HFF) 0)

#define FD_ERROR  0xFFFFFFFF

typedef struct _POINTE      /* pte  */
{
    FLOATL x;
    FLOATL y;
} POINTE, *PPOINTE;

DECLARE_HANDLE(HDEV);

#define LTOFX(x)            ((x)<<4)

#define FXTOL(x)            ((x)>>4)
#define FXTOLFLOOR(x)       ((x)>>4)
#define FXTOLCEILING(x)     ((x + 0x0F)>>4)
#define FXTOLROUND(x)       ((((x) >> 3) + 1) >> 1)

// context information

typedef struct _FD_XFORM {
    FLOATL eXX;
    FLOATL eXY;
    FLOATL eYX;
    FLOATL eYY;
} FD_XFORM, *PFD_XFORM;


typedef struct _FD_DEVICEMETRICS {
    ULONG  cjGlyphMax;          // (cxMax + 7)/8 * cyMax, or at least it should be
    INT   xMin;                 // From FONTCONTEXT
    INT   xMax;                 // From FONTCONTEXT
    INT   yMin;                 // From FONTCONTEXT
    INT   yMax;                 // From FONTCONTEXT
    INT   cxMax;                // From FONTCONTEXT
    INT   cyMax;                // From FONTCONTEXT
    BOOL  HorizontalTransform;  // From FONTCONTEXT flXform & XFORM_HORIZ
    BOOL  VerticalTransform;    // From FONTCONTEXT flXform & XFORM_VERT
} FD_DEVICEMETRICS, *PFD_DEVICEMETRICS;

// signed 16 bit integer type denoting number of FUnit's

typedef SHORT FWORD;


// IFIMETRICS constants

#define FM_VERSION_NUMBER                   0x0

//
// IFIMETRICS::fsType flags
//
#define FM_TYPE_LICENSED                    0x2
#define FM_READONLY_EMBED                   0x4
#define FM_EDITABLE_EMBED                   0x8
#define FM_NO_EMBEDDING                     FM_TYPE_LICENSED

//
// IFIMETRICS::flInfo flags
//
#define FM_INFO_TECH_TRUETYPE               0x00000001
#define FM_INFO_TECH_BITMAP                 0x00000002
#define FM_INFO_TECH_STROKE                 0x00000004
#define FM_INFO_TECH_OUTLINE_NOT_TRUETYPE   0x00000008
#define FM_INFO_ARB_XFORMS                  0x00000010
#define FM_INFO_1BPP                        0x00000020
#define FM_INFO_4BPP                        0x00000040
#define FM_INFO_8BPP                        0x00000080
#define FM_INFO_16BPP                       0x00000100
#define FM_INFO_24BPP                       0x00000200
#define FM_INFO_32BPP                       0x00000400
#define FM_INFO_INTEGER_WIDTH               0x00000800
#define FM_INFO_CONSTANT_WIDTH              0x00001000
#define FM_INFO_NOT_CONTIGUOUS              0x00002000
#define FM_INFO_TECH_MM                     0x00004000
#define FM_INFO_RETURNS_OUTLINES            0x00008000
#define FM_INFO_RETURNS_STROKES             0x00010000
#define FM_INFO_RETURNS_BITMAPS             0x00020000
#define FM_INFO_DSIG                        0x00040000 // FM_INFO_UNICODE_COMPLIANT
#define FM_INFO_RIGHT_HANDED                0x00080000
#define FM_INFO_INTEGRAL_SCALING            0x00100000
#define FM_INFO_90DEGREE_ROTATIONS          0x00200000
#define FM_INFO_OPTICALLY_FIXED_PITCH       0x00400000
#define FM_INFO_DO_NOT_ENUMERATE            0x00800000
#define FM_INFO_ISOTROPIC_SCALING_ONLY      0x01000000
#define FM_INFO_ANISOTROPIC_SCALING_ONLY    0x02000000
#define FM_INFO_TECH_CFF                    0x04000000
#define FM_INFO_FAMILY_EQUIV                0x08000000
#define FM_INFO_IGNORE_TC_RA_ABLE           0x40000000
#define FM_INFO_TECH_TYPE1                  0x80000000

// max number of charsets supported in a tt font, 16 according to win95 guys

#define MAXCHARSETS 16

//
// IFMETRICS::fsSelection flags
//
#define  FM_SEL_ITALIC          0x0001
#define  FM_SEL_UNDERSCORE      0x0002
#define  FM_SEL_NEGATIVE        0x0004
#define  FM_SEL_OUTLINED        0x0008
#define  FM_SEL_STRIKEOUT       0x0010
#define  FM_SEL_BOLD            0x0020
#define  FM_SEL_REGULAR         0x0040

//
// The FONTDIFF structure contains all of the fields that could
// possibly change under simulation
//
typedef struct _FONTDIFF {
    BYTE   jReserved1;      // 0x0
    BYTE   jReserved2;      // 0x1
    BYTE   jReserved3;      // 0x2
    BYTE   bWeight;         // 0x3  Panose Weight
    USHORT usWinWeight;     // 0x4
    FSHORT fsSelection;     // 0x6
    FWORD  fwdAveCharWidth; // 0x8
    FWORD  fwdMaxCharInc;   // 0xA
    POINTL ptlCaret;        // 0xC
} FONTDIFF;

typedef struct _FONTSIM {
    PTRDIFF  dpBold;       // offset from beginning of FONTSIM to FONTDIFF
    PTRDIFF  dpItalic;     // offset from beginning of FONTSIM to FONTDIFF
    PTRDIFF  dpBoldItalic; // offset from beginning of FONTSIM to FONTDIFF
} FONTSIM;

typedef struct _GP_IFIMETRICS {
    ULONG    cjThis;           // includes attached information
    PTRDIFF  dpwszFamilyName;
    PTRDIFF  dpwszStyleName;
    PTRDIFF  dpwszFaceName;
    PTRDIFF  dpwszUniqueName;
    PTRDIFF  dpFontSim;
    LONG     lItalicAngle;

    USHORT   usWinWeight;           // as in LOGFONT::lfWeight
    ULONG    flInfo;                // see above
    USHORT   fsSelection;           // see above
    USHORT   familyNameLangID;
    USHORT   familyAliasNameLangID;
    FWORD    fwdUnitsPerEm;         // em height
    FWORD    fwdWinAscender;
    FWORD    fwdWinDescender;
    FWORD    fwdMacAscender;
    FWORD    fwdMacDescender;
    FWORD    fwdMacLineGap;
    FWORD    fwdTypoAscender;
    FWORD    fwdTypoDescender;
    FWORD    fwdTypoLineGap;
    FWORD    fwdAveCharWidth;
    FWORD    fwdMaxCharInc;
    FWORD    fwdCapHeight;
    FWORD    fwdXHeight;
    FWORD    fwdUnderscoreSize;
    FWORD    fwdUnderscorePosition;
    FWORD    fwdStrikeoutSize;
    FWORD    fwdStrikeoutPosition;
    POINTL   ptlBaseline;           //
    POINTL   ptlCaret;              // points along caret
    RECTL    rclFontBox;            // bounding box for all glyphs (font space)
    ULONG    cig;                   // maxp->numGlyphs, # of distinct glyph indicies
    PANOSE   panose;

#if defined(_WIN64)

    //
    // IFIMETRICS must begin on a 64-bit boundary
    //

    PVOID    Align;

#endif

} GP_IFIMETRICS, *GP_PIFIMETRICS;

typedef struct _XFORML {
    FLOATL  eM11;
    FLOATL  eM12;
    FLOATL  eM21;
    FLOATL  eM22;
    FLOATL  eDx;
    FLOATL  eDy;
} XFORML, *PXFORML;


typedef struct _FONTOBJ
{
    ULONG      iFace; /* face ID, font index within a ttc file */
    FLONG      flFontType;
    ULONG_PTR   iFile; /* (FONTFILEVIEW *) id used for mapping of the font file */
    SIZE       sizLogResPpi;
    ULONG      ulPointSize; /* pointSize */
    PVOID      pvProducer; /* (FONTCONTEXT *) */
    FD_XFORM   fdx;            // N->D transform used to realize font
} FONTOBJ;

//
// FONTOBJ::flFontType
//
//#define FO_TYPE_RASTER   RASTER_FONTTYPE     /* 0x1 */
//#define FO_TYPE_DEVICE   DEVICE_FONTTYPE     /* 0x2 */
#define FO_TYPE_TRUETYPE TRUETYPE_FONTTYPE   /* 0x4 */
//#define FO_TYPE_OPENTYPE OPENTYPE_FONTTYPE   /* 0X8 */

#define FO_SIM_BOLD                  0x00002000
#define FO_SIM_ITALIC                0x00004000
#define FO_EM_HEIGHT                 0x00008000  /* in gdi+ this flag is always set */
#define FO_GRAYSCALE                 0x00010000          /* [1] */
#define FO_NOGRAY16                  0x00020000          /* [1] */
#define FO_MONO_UNHINTED             0x00040000          /* [3] */
#define FO_NO_CHOICE                 0x00080000          /* [3] */
#define FO_SUBPIXEL_4                0x00100000          /* Indicates non-hinted alignment */
#define FO_CLEARTYPE                 0x00200000
#define FO_CLEARTYPE_GRID            0x00400000
#define FO_NOCLEARTYPE               0x00800000
#define FO_COMPATIBLE_WIDTH          0x01000000
#define FO_SIM_ITALIC_SIDEWAYS       0x04000000 /* for far east vertical vriting sideways glyphs */
#define FO_CHOSE_DEPTH               0x80000000

// new accelerators so that printer drivers  do not need to look to ifimetrics

//#define FO_CFF            0x00100000
//#define FO_POSTSCRIPT     0x00200000
//#define FO_MULTIPLEMASTER 0x00400000
//#define FO_VERT_FACE      0x00800000
//#define FO_DBCS_FONT      0X01000000

/**************************************************************************\
*
*   [1]
*
*   If the FO_GRAYSCALE flag is set then the bitmaps of the font
*   are 4-bit per pixel blending (alpha) values. A value of zero
*   means that the the resulting pixel should be equal to the
*   background color. If the value of the alpha value is k != 0
*   then the resulting pixel must be:
*
*       c0 = background color
*       c1 = foreground color
*       b  = blending value = (k+1)/16  // {k = 1,2,..,15}
*       b  = 0 (k = 0)
*       d0 = gamma[c0], d1 = gamma[c1]  // luminance components
*       d = (1 - b)*d0 + b*d1           // blended luminance
*       c = lambda[d]                   // blended device voltage
*
*   where gamma[] takes a color component from application space
*   to CIE space and labmda[] takes a color from CIE space to
*   device color space
*
*   GDI will set this bit if it request a font be gray scaled
*   to 16 values then GDI will set FO_GRAYSCALE upon entry to
*   DrvQueryFontData().  If the font driver cannot (or will
*   not) grayscale a particular realization of a font then the
*   font provider will zero out FO_GRAYSCALE  and set FO_NOGRAY16
*   to inform GDI that
*   the gray scaling request cannot (or should not) be
*   satisfied.
*
*   [2]
*
*   The FO_NOHINTS indicates that hints were not used in the formation
*   of the glyph images. GDI will set this bit to request that hinting
*   be supressed. The font provider will set this bit accroding to the
*   rendering scheme that it used in generating the glyph image.
*
*   [3]
*
*   The FO_NO_CHOICE flag indicates that the flags FO_GRAYSCALE and
*   FO_NOHINTS must be obeyed if at all possible.
*
\**************************************************************************/

typedef struct _XFORMOBJ
{
    ULONG ulReserved;
} XFORMOBJ;


BOOL APIENTRY PATHOBJ_bMoveTo(
    PVOID      *ppo,
    POINTFIX    ptfx
    );

BOOL APIENTRY PATHOBJ_bPolyLineTo(
    PVOID     *ppo,
    POINTFIX  *pptfx,
    ULONG      cptfx
    );

BOOL APIENTRY PATHOBJ_bPolyBezierTo(
    PVOID     *ppo,
    POINTFIX  *pptfx,
    ULONG      cptfx
    );

BOOL APIENTRY PATHOBJ_bCloseFigure(
    PVOID *ppo
    );

#define BMF_1BPP       1L
#define BMF_4BPP       2L
#define BMF_8BPP       3L
#define BMF_16BPP      4L
#define BMF_24BPP      5L
#define BMF_32BPP      6L
#define BMF_4RLE       7L
#define BMF_8RLE       8L
#define BMF_JPEG       9L
#define BMF_PNG       10L

#define QFD_GLYPHANDBITMAP                  1L
#define QFD_GLYPHANDOUTLINE                 2L
#define QFD_MAXEXTENTS                      3L
#define QFD_TT_GLYPHANDBITMAP               4L
#define QFD_TT_GRAY1_BITMAP                 5L
#define QFD_TT_GRAY2_BITMAP                 6L
#define QFD_TT_GRAY4_BITMAP                 8L
#define QFD_TT_GRAY8_BITMAP                 9L

#define QFD_TT_MONO_BITMAP QFD_TT_GRAY1_BITMAP
#define QFD_CT                              10L
#define QFD_CT_GRID                         11L
#define QFD_GLYPHANDBITMAP_SUBPIXEL         12L

// values for bMetricsOnly. even though declared as BOOL
// by adding TTO_QUBICS, this is becoming a flag field.
// For versions of NT 4.0 and earlier, this value is always
// set to zero by GDI.

#define TTO_METRICS_ONLY 1
#define TTO_QUBICS       2
#define TTO_UNHINTED     4

//
// Kernel mode memory operations
//

#define FL_ZERO_MEMORY      0x00000001

VOID APIENTRY EngDebugBreak(
    VOID
    );


PVOID APIENTRY EngAllocMem(
    ULONG Flags,
    ULONG MemSize,
    ULONG Tag
    );

VOID APIENTRY EngFreeMem(
    PVOID Mem
    );

PVOID APIENTRY EngAllocUserMem(
    SIZE_T cj,
    ULONG tag
    );

VOID APIENTRY EngFreeUserMem(
    PVOID pv
    );

int APIENTRY EngMulDiv(
    int a,
    int b,
    int c
    );


VOID APIENTRY EngUnmapFontFileFD(
    ULONG_PTR iFile
    );


BOOL APIENTRY EngMapFontFileFD(
    ULONG_PTR  iFile,
    PULONG *ppjBuf,
    ULONG  *pcjBuf
    );

//
// Semaphores
//

DECLARE_HANDLE(HSEMAPHORE);

HSEMAPHORE APIENTRY EngCreateSemaphore(
    VOID
    );

VOID APIENTRY EngAcquireSemaphore(
    HSEMAPHORE hsem
    );

VOID APIENTRY EngReleaseSemaphore(
    HSEMAPHORE hsem
    );

VOID APIENTRY EngDeleteSemaphore(
    HSEMAPHORE hsem
    );


INT APIENTRY EngPlusMultiByteToWideChar(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString
    );

VOID APIENTRY EngGetCurrentCodePage(
    PUSHORT OemCodePage,
    PUSHORT AnsiCodePage
    );

#ifdef __cplusplus
}  // extern "C"
#endif

#endif  //  _FONTDDI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\fd_poly.c ===
/******************************Module*Header*******************************\
* Module Name: fd_poly.c
*
* stolen from win31 tt code
*
* Created: 10-Feb-1992 17:10:39
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
*
\**************************************************************************/

#include "fd.h"
#include "winerror.h"

STATIC VOID vQsplineToPolyBezier (
    ULONG      cBez,          // IN  count of curves to convert to beziers format
    POINTFIX * pptfixStart,   // IN  starting point on the first curve
    POINTFIX * pptfixSpline,  // IN  array of (cBez+1) points that, together with the starting point *pptfixStart define the spline
    POINTFIX * pptfixBez      // OUT buffer to be filled with 3 * cBez poly bezier control points
    );


BOOL bGeneratePath (
    PVOID           * ppo,        // IN OUT pointer to the path object to be generated
    TTPOLYGONHEADER * ppolyStart, // IN     pointer to the buffer with outline data
    ULONG             cj,         // IN     size of the buffer
    ULONG           * pcjOut,      // OUT   size of needed bezier buffer
    TTPOLYGONHEADER * ppolyBeziers // OUT   buffer with Bezier outline data
    );

#if DBG

// #define DBG_POLYGON

#endif

VOID vFillSingularGLYPHDATA(HGLYPH,ULONG,FONTCONTEXT*,GLYPHDATA*);
VOID vFillGLYPHDATA(HGLYPH,ULONG,FONTCONTEXT*,fs_GlyphInfoType*,GLYPHDATA*,GMC*);
BOOL bGetGlyphMetrics(FONTCONTEXT*,HGLYPH,FLONG,FS_ENTRY*);

/******************************Public*Routine******************************\
*
* void Scale_16DOT16
*
*
* Effects: 26.6 -> 16.16
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* stole it from jeanp and modified for nt
\**************************************************************************/

//!!! some checks should be put in so as to verify that 26.6 -> 16.16
//!!! conversion can be done without loosing information [bodind]

void Scale_16DOT16 (POINTFX  *ppfx, F26Dot6 x, F26Dot6 y, int xLsb2Org, int yLsb2Org)
{
    LONG lTmp;

#ifdef  DBG_POLYGON

    xLsb2Org;
    yLsb2Org;

    lTmp = (LONG)x;
    ppfx->x = * (FIXED *) &lTmp;

    lTmp = (LONG)y;
    ppfx->y = * (FIXED *) &lTmp;

#else // true version

// for this to work the following assert must be true:

    ASSERTDD(sizeof(LONG) == sizeof(FIXED), "_Scale 16.16 \n");

    lTmp = (LONG) ((x - xLsb2Org) << 10);
    ppfx->x = * (FIXED *) &lTmp;

    lTmp = (LONG) ((y - yLsb2Org) << 10);
    ppfx->y = * (FIXED *) &lTmp;

#endif //  DBG_POLYGON
}


/******************************Public*Routine******************************\
*
* void Scale_28Dot4
*
*
* Effects: 26.6 -> 28.4
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* wrote it
\**************************************************************************/

void Scale_28DOT4 (POINTFX  *ppfx, F26Dot6 x, F26Dot6 y, int xLsb2Org, int yLsb2Org)
{
    LONG lTmp;

// for this to work the following assert must be true:

    ASSERTDD(sizeof(LONG) == sizeof(FIXED), "Scale, 28.4\n");

    lTmp = (LONG) ((x - xLsb2Org) >> 2);
    ppfx->x = * (FIXED *) &lTmp;

// note that the sign of y coordinate differs from the 16.16 case

    lTmp = - (LONG) ((y - yLsb2Org) >> 2);
    ppfx->y = * (FIXED *) &lTmp;
}


/******************************Public*Routine******************************\
*
* Scale_None
*
* Called when only the size of the ppoly buffer is wanted
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

void Scale_None (POINTFX *ppfx, F26Dot6 x, F26Dot6 y, int xLsb2Org, int yLsb2Org)
{
  ppfx;
  x;
  y;
  xLsb2Org;
  yLsb2Org;

  return;
}


/******************************Public*Routine******************************\
*
* cjFillPolygon
*
* Effects: fills in the array of structures that describe glyph's
*          outline. There is one polygonheader stuct for every closed contour
*          that composes the glyph. A polygon headed structure is followed
*          by an array of polycurve structure that describe composite curves
*          of a closed contour.
*
* Note: if pBuffer is NULL or cb is 0, then it is assumed that the caller
*       only wants the size of the buffer required.
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it. (stole it from JeanP's win31 code and addapted for NT)
\**************************************************************************/

UINT cjFillPolygon(
    PFONTCONTEXT pfc,
    BOOL         b16Dot16,  // FORMAT of the points, 16.16 or 28.4
    PBYTE        pBuffer,
    UINT         cb
    )
{
  BOOL            bGetLength = ( (pBuffer == (PBYTE)NULL) || (cb == 0) );
  uint16          nc = pfc->pgout->numberOfContours;
  uint8           *pbOnCurve = pfc->pgout->onCurve;
  uint8           *pbFc = pfc->pgout->fc;
  int16           *sp = pfc->pgout->startPtr;
  int16           *ep = pfc->pgout->endPtr;
  F26Dot6         *x = pfc->pgout->xPtr;
  F26Dot6         *y = pfc->pgout->yPtr;
  BYTE            *pBuf = pBuffer;
  BYTE            *pStart = pBuf;
  BYTE            *pEnd = pStart + (bGetLength ? -1 : cb);
  TTPOLYGONHEADER *pPoly;
  TTPOLYCURVE     *pCurve;
  POINTFX         *ppfxStart;
  POINTFX         *pptfx;

  uint16      iContour;   //  index into a contour
  int16       iptEnd, cpt;
  int16       ipt = 0; // follows the points on the contour

  uint8        ucMask;
  void        (*Scale)(POINTFX *ppfx, F26Dot6 x, F26Dot6 y, int xlsb, int ylsb);

  int       xLsb2Org;
  int       yLsb2Org;

  if (!pfc->pgout->outlinesExist)
    return 0;

  if (!bGetLength) // we are actually filling in the information
  {

    if (b16Dot16)
    {
      Scale = Scale_16DOT16;
    }
    else  // scale to 28.4 format
    {
      Scale = Scale_28DOT4;
    }
  }
  else // just computing the size of the buffer needed to store the information
  {
    Scale = Scale_None;
  }

// Compute the delta between the referencial origin and dev left bearing

  cpt = (int16)(ep[nc - 1] + 1);  // total number of points in a contour

  xLsb2Org = x [cpt];  // LEFTSIDEBEARING == 0
  yLsb2Org = y [cpt];  // LEFTSIDEBEARING == 0

  for (iContour = 0; iContour < nc; iContour++)
  {
     // make sure that ipt points to the firts point on a contour upon entry
     // to the loop

    ipt    = sp [iContour];
    iptEnd = ep [iContour];

      // skip contour made of one point
    if (ipt == iptEnd)
    {
      continue; // go to the starting point of the next contour,
    }

    if (!bGetLength)
    {
      pPoly = (TTPOLYGONHEADER *) pBuf; //!!! dangerous, alignment [bodind]
      pPoly->dwType = TT_POLYGON_TYPE;
      ppfxStart = &pPoly->pfxStart;

    #ifdef  DBG_POLYGON
      TtfdDbgPrint("Begin Polygon\n\n");
    #endif //  DBG_POLYGON
    }

    pBuf += sizeof (TTPOLYGONHEADER);

    if (pbFc[iContour] & OUTLINE_MISORIENTED)
    {
	    // we need to change the orientation of the contour
        x = &pfc->pgout->xPtr[iptEnd];
        y = &pfc->pgout->yPtr[iptEnd];

          // The last point on the curve
        if (pbOnCurve[iptEnd] & 1)
        {
            //Easy case
          (*Scale) (ppfxStart, *x--, *y--, xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
          --iptEnd;
        }
        else
        {
            // Is first contour point on the curve
          if (pbOnCurve[ipt] & 1)
          {
              //Make the first point the last point and decrement the first point
            (*Scale) (ppfxStart, x[ipt - iptEnd], y[ipt - iptEnd], xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
          }
          else
          {
              //last and first point are off the countour, fake a mid point
            (*Scale) (ppfxStart, (x[ipt - iptEnd] + *x) >> 1, (y[ipt - iptEnd] + *y) >> 1, xLsb2Org, yLsb2Org);
          }
        }

        while (ipt <= iptEnd)
        {
          pCurve = (TTPOLYCURVE *) pBuf;
          pptfx = pCurve->apfx;
          ucMask = (int8) (1 & (~pbOnCurve[iptEnd]));
          if (!bGetLength)
          {
              // if mid point not on the curve this is qspline, this is midpoint
              // because the starting point is in the previous record [bodind]
            pCurve->wType = (WORD)((ucMask == 0) ? TT_PRIM_LINE : TT_PRIM_QSPLINE);
          }
            // Set up the POLYCURVE
          while ((ipt <= iptEnd) && ((pbOnCurve[iptEnd] & 1) ^ ucMask))
          {
              // Check overflow
            if (pEnd < (BYTE *)(pptfx + 1))
              return FD_ERROR;

            (*Scale) (pptfx++, *x--, *y--, xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
            iptEnd --;
          }

          if (ucMask == 1) // if this curve is a qspline
          {
              // Check overflow
            if (pEnd < (BYTE *)(pptfx + 1))
              return FD_ERROR;

             // Set up the end point
            if (ipt <= iptEnd)
            {
              ASSERTDD(pbOnCurve[iptEnd] & 1, " end point not on the curve\n");
              (*Scale) (pptfx, *x--, *y--, xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
              iptEnd--;
            }
            else
            {
               // close the contour
              if (!bGetLength)
                 *pptfx = *ppfxStart;
            }
            pptfx++;
          }
          if (!bGetLength)
          {
            pCurve->cpfx = (WORD)(pptfx - pCurve->apfx);
          }

          pBuf = (BYTE *) pptfx;
        }
    } 
    else
    {
        x = &pfc->pgout->xPtr[ipt];
        y = &pfc->pgout->yPtr[ipt];

          // The first point on the curve
        if (pbOnCurve[ipt] & 1)
        {
            //Easy case
          (*Scale) (ppfxStart, *x++, *y++, xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
          ++ipt;
        }
        else
        {
            // Is last contour point on the curve
          if (pbOnCurve[iptEnd] & 1)
          {
              //Make the last point the first point and decrement the last point
            (*Scale) (ppfxStart, x[iptEnd - ipt], y[iptEnd - ipt], xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
          }
          else
          {
              //First and last point are off the countour, fake a mid point
            (*Scale) (ppfxStart, (x[iptEnd - ipt] + *x) >> 1, (y[iptEnd - ipt] + *y) >> 1, xLsb2Org, yLsb2Org);
          }
        }

        while (ipt <= iptEnd)
        {
          pCurve = (TTPOLYCURVE *) pBuf;
          pptfx = pCurve->apfx;
          ucMask = (int8) (1 & (~pbOnCurve[ipt]));
          if (!bGetLength)
          {
              // if mid point not on the curve this is qspline, this is midpoint
              // because the starting point is in the previous record [bodind]
            pCurve->wType = (WORD)((ucMask == 0) ? TT_PRIM_LINE : TT_PRIM_QSPLINE);
          }
            // Set up the POLYCURVE
          while ((ipt <= iptEnd) && ((pbOnCurve[ipt] & 1) ^ ucMask))
          {
              // Check overflow
            if (pEnd < (BYTE *)(pptfx + 1))
              return FD_ERROR;

            (*Scale) (pptfx++, *x++, *y++, xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
            ipt++;
          }

          if (ucMask == 1) // if this curve is a qspline
          {
              // Check overflow
            if (pEnd < (BYTE *)(pptfx + 1))
              return FD_ERROR;

             // Set up the end point
            if (ipt <= iptEnd)
            {
              ASSERTDD(pbOnCurve[ipt] & 1, " end point not on the curve\n");
              (*Scale) (pptfx, *x++, *y++, xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
              ipt++;
            }
            else
            {
               // close the contour
              if (!bGetLength)
                 *pptfx = *ppfxStart;
            }
            pptfx++;
          }
          if (!bGetLength)
          {
            pCurve->cpfx = (WORD)(pptfx - pCurve->apfx);
          }

          pBuf = (BYTE *) pptfx;
        }
    }
    if (!bGetLength)
    {
      pPoly->cb = (DWORD) (pBuf - (BYTE *) pPoly);
      #ifdef DBG_POLYGON
        TtfdDbgPrint("\n end polygon, pPoly->cb = %ld\n\n", pPoly->cb);
      #endif // DBG_POLYGON
    }
  }
  #ifdef  DBG_POLYGON
    if (!bGetLength)
        TtfdDbgPrint("\n END NEW GLYPH \n\n");
  #endif //  DBG_POLYGON

  return (UINT) (pBuf - pStart);
}


/******************************Public*Routine******************************\
*
* lQuerySingularTrueTypeOutline
*
* Effects:
*
* Warnings:
*
* History:
*  22-Sep-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




LONG lQuerySingularTrueTypeOutline(
    PFONTCONTEXT pfc,            // IN
    BOOL         b16Dot16,       // IN  format of the points, 16.16 or 28.4
    HGLYPH       hglyph,         // IN  glyph for which info is wanted
    BOOL         bMetricsOnly,   // IN  only metrics is wanted, not the outline
    GLYPHDATA *   pgldt,         // OUT this is where the metrics should be returned
    ULONG        cjBuf,          // IN  size in bytes of the ppoly buffer
    TTPOLYGONHEADER * ppoly      // OUT output buffer
    )
{
    FS_ENTRY     iRet;
    ULONG        ig; // <--> hglyph

// hglyph is valid, either asking about the size for that particular
// glyph bitmap, or want the bitmap itself

    vCharacterCode(pfc->pff,hglyph,pfc->pgin);

// compute the glyph index from the character code:

    if ((iRet = fs_NewGlyph(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);
        RET_FALSE("TTFD!_lQuerySingularTrueTypeOutline, fs_NewGlyph\n");
    }

// return the glyph index corresponding to this hglyph:

    ig = pfc->pgout->glyphIndex;

// must call cjFillPolygon now since fsFindBitmapSize messes up outline
// data in pgout

// fill all of GLYPHDATA structure

    if (pgldt != (GLYPHDATA *)NULL)
    {
        vFillSingularGLYPHDATA(hglyph,ig,pfc,pgldt);
    }

// now check whether the caller is asking about the size of the buffer
// needed to store the array of POLYGONHEADER structures:

    return 0; // nothing written to the ppoly buffer
}


/******************************Public*Routine******************************\
*
* LONG lQueryTrueTypeOutline
*
*
* Effects:
*
* Warnings:
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lQueryTTOutline(
    PFONTCONTEXT pfc,            // IN
    BOOL         b16Dot16,       // IN  format of the points, 16.16 or 28.4
    HGLYPH       hglyph,         // IN  glyph for which info is wanted
    BOOL         bMetricsOnly,   // IN  only metrics is wanted, not the outline
    BOOL         bUnhinted,      //     unhinted
    GLYPHDATA *   pgldt,          // OUT this is where the metrics should be returned
    ULONG        cjBuf,          // IN  size in bytes of the ppoly buffer
    TTPOLYGONHEADER * ppoly      // OUT output buffer
    )
{
    FS_ENTRY     iRet;
    LONG         cjRet;
    ULONG        ig = pfc->gstat.igLast;

// check if the rasterizer would behave unpolitely for this xform:

    if (pfc->flXform & XFORM_SINGULAR)
        return lQuerySingularTrueTypeOutline(
                    pfc,
                    b16Dot16,
                    hglyph,
                    bMetricsOnly,
                    pgldt,
                    cjBuf,
                    ppoly);

// check the last glyph processed to determine
// whether we have to register the glyph as new and compute its size

    if ((pfc->gstat.hgLast != hglyph) || bUnhinted)
    {
        extern BOOL bGetGlyphOutline(FONTCONTEXT*,HGLYPH,ULONG*,FLONG,FS_ENTRY*);

        FLONG flOutline = bUnhinted ? FL_FORCE_UNHINTED : 0;

        // DO NOT skip grid fitting even if embedded bitmpas are found,
        // for we will be interested in outlines -+
        //                                        |
        //                                        |
        if ( !bGetGlyphOutline(pfc, hglyph , &ig, flOutline, &iRet) )
        {
            V_FSERROR(iRet);
            RETURN("lQueryTTOutline: bGetGlyphOutline failed\n", FD_ERROR);
        }

        // in order to be compatible with older applications we must
        // call the monochrome version we do not call fs_FindGraySize
        // even if the FONTOBJ suggests that it be anti-aliased

        if ((iRet = fs_FindBitMapSize(pfc->pgin, pfc->pgout)) != NO_ERR)
        {
            V_FSERROR(iRet);
            RETURN("lQueryTTOutline: fs_FindBitMapSize failed\n", FD_ERROR);
        }

        // now that everything is computed sucessfully, we can update
        // glyphstate (hg data stored in pj3) and return

        if (!bUnhinted)
        {
            pfc->gstat.hgLast = hglyph;
            pfc->gstat.igLast = ig;
        }
        else
        {
            vInitGlyphState(&pfc->gstat);
        }
    }

// must call cjFillPolygon now since fsFindBitmapSize messes up outline
// data in pgout

    if (!(bMetricsOnly & TTO_METRICS_ONLY))
    {
        if ((cjRet = cjFillPolygon(pfc, b16Dot16, (PBYTE)ppoly, cjBuf)) == FD_ERROR)
            RETURN("TTFD!_cjFillPolygon failed\n", FD_ERROR);
    }
    else // nothing will be written to ppoly buffer
    {
        cjRet = 0;
    }

// fill all of GLYPHDATA structure

    if (pgldt != (GLYPHDATA *)NULL)
    {
        // Normal case
        vFillGLYPHDATA(
                hglyph,
                ig,
                pfc,
                pfc->pgout,
                pgldt,
                (PGMC)NULL);
    }

// now check whether the caller is asking about the size of the buffer
// needed to store the array of POLYGONHEADER structures:

    return cjRet;
}


/******************************Public*Routine******************************\
*
* LONG ttfdQueryTrueTypeOutline
*
*
* Effects:
*
* Warnings:
*
* History:
*  12-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG ttfdQueryQuadTrueTypeOutline (
    FONTOBJ   *pfo,
    HGLYPH     hglyph,         // IN  glyph for which info is wanted
    BOOL       bMetricsOnly,   // IN  only metrics is wanted, not the outline
    GLYPHDATA *pgldt,          // OUT this is where the metrics should be returned
    ULONG      cjBuf,          // IN  size in bytes of the ppoly buffer
    TTPOLYGONHEADER * ppoly    // IN OUT  output buffer
    )
{
    FONTCONTEXT *pfc;
	USHORT usOverScale;
    BOOL     bUnhinted = (bMetricsOnly & TTO_UNHINTED) ? TRUE : FALSE;

    bMetricsOnly = (bMetricsOnly & ~TTO_UNHINTED);

    ASSERTDD(pfo->iFile, "ttfdQueryTrueTypeOutline, pfo->iFile\n");

    if (((TTC_FONTFILE *)pfo->iFile)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
        //WARNING("ttfd, ttfdQueryTrueTypeOutline: file is gone\n");
        return FD_ERROR;
    }
//
// If pfo->pvProducer is NULL, then we need to open a font context.
//
    if ( pfo->pvProducer == (PVOID) NULL )
    {
        pfo->pvProducer = pfc = ttfdOpenFontContext(pfo);
    }
    else
    {
        pfc = (FONTCONTEXT*) pfo->pvProducer;
        pfc->flFontType = (pfc->flFontType & FO_CHOSE_DEPTH) | pfo->flFontType;
    }

    if ( pfc == (FONTCONTEXT *) NULL )
    {
        //WARNING("gdisrv!ttfdQueryTrueTypeOutline(): cannot create font context\n");
        return FD_ERROR;
    }
    pfc->pfo = pfo;

// call fs_NewTransformation if needed:

// ClaudeBe 1/22/98 :
//
// for backwards compatibility, we always return the BW version of the outline
// (TrueType rasterizer 1.7 allow specific grayscale hinting)
//
// the code could be :
//
//	if (IS_GRAY(pfc))
//	{
//		usOverScale = 4;
//	}
//	else
//	{
//		usOverScale = 0;
//	}
//
// but then we would need to copy the outline from gout, before calling fs_FindBitmapSize
// to avoid getting an overscaled outline

	usOverScale = 0;

/* outline code path, no bitmap emboldening simulation */
    if (!bGrabXform(pfc, usOverScale, FALSE, 0, 0))
        RETURN("gdisrv!ttfd  bGrabXform failed\n", FD_ERROR);

       return  lQueryTTOutline(pfc,
                               TRUE, // b16Dot16 is true, this is the desired
                                     // format
                               hglyph,
                               bMetricsOnly, bUnhinted,
                               pgldt,
                               cjBuf,
                               ppoly);
}




/******************************Public*Routine******************************\
*
* ttfdQueryGlyphOutline
*
*
*
* History:
*  12-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL ttfdQueryGlyphOutline (
    FONTCONTEXT *pfc,
    HGLYPH       hglyph,
    GLYPHDATA   *pgldt,
    PVOID       *ppo        // pointer to path to be built
    )
{
    LONG             cjAllPolygons, cjAllPolygons2;
    BOOL             bOk;

    if (ppo == NULL)
    {
    // if ppo == NULL, the caller wants metrics only:

        ASSERTDD(pgldt, "ttfdQueryGlyphOutline, pgldt NULL\n");

        cjAllPolygons =
              lQueryTTOutline
                (
                 pfc,              // lpMat2 is incorporated into this fc
                 FALSE,            // NOT 16.16 i.e. 28.4
                 hglyph,           // glyph for which info is wanted
                 TTO_METRICS_ONLY, // DO just metrics, do NOT do outline
                 FALSE,            // hinted
                 pgldt,            // STORE the result here
                 0,                // size in bytes of the ppoly buffer
                 (TTPOLYGONHEADER *)NULL // do not need it
                 );

    // interpret the result, if zero for polygons, we succeded
    // glyph data was filled in and no polygon computation has been
    // performed.
    // if FD_ERROR we did not, no other result should be possible

        if (cjAllPolygons == 0)
            return TRUE;
        else
        {
            ASSERTDD(cjAllPolygons == FD_ERROR,
                     "ttfdQueryGlyphOutline, pgldt == NULL\n");
            return FALSE;
        }

    }

// first learn how big a buffer we need for all polygons:

    cjAllPolygons = lQueryTTOutline
          (
           pfc,              // lpMat2 is incorporated into this fc
           FALSE,            // NOT 16.16 i.e. 28.4
           hglyph,           // glyph for which info is wanted
           FALSE,            //  DO more than just metrics
           FALSE,            // hinted
           (GLYPHDATA *)NULL,// do not need glyphdata
           0,                // size in bytes of the ppoly buffer
           (TTPOLYGONHEADER *)NULL
           );
    if (cjAllPolygons == FD_ERROR)
        RET_FALSE("TTFD! cjAllPolygons\n");

    if (cjAllPolygons != 0)
    {
        if ((pfc->gstat.pv = PV_ALLOC(cjAllPolygons)) == NULL)
        {
            RET_FALSE("TTFD_cjAllPolygons or ppoly\n");
        }
    }
    else
    {
        pfc->gstat.pv = NULL;
    }

// get all the polygons in the buffer we just allocated:

    cjAllPolygons2 = lQueryTTOutline
          (
           pfc,            // lpMat2 is incorporated into this fc
           FALSE,          // NOT 16.16 i.e. 28.4
           hglyph,         // glyph for which info is wanted
           FALSE,          //  DO more than just metrics
           FALSE,            // hinted
           pgldt,          // this is where the metrics should be returned
           cjAllPolygons,  // size in bytes of the ppoly buffer
           (TTPOLYGONHEADER *)pfc->gstat.pv
           );

    if (cjAllPolygons2 == FD_ERROR)
    {
        if (pfc->gstat.pv)
        {
            V_FREE(pfc->gstat.pv);
            pfc->gstat.pv = NULL;
        }
        RET_FALSE("TTFD_ QueryTrueTypeOutline failed\n");
    }

    ASSERTDD(cjAllPolygons == cjAllPolygons2,
              "cjAllPolygons PROBLEM\n");

// now that we have all the info in ppoly buffer we can generate the path

    bOk = bGeneratePath(
            ppo,
            (TTPOLYGONHEADER *)pfc->gstat.pv,
            cjAllPolygons, NULL, NULL
            );

    if (pfc->gstat.pv)
    {
        V_FREE(pfc->gstat.pv);
        pfc->gstat.pv = NULL;
    }

    return (bOk);
}


/******************************Public*Routine******************************\
*
* bGeneratePath
*
* Effects: Adds control points of the glyph to the gluph path
*
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

// macro that computes the size of the polycurve record:

#define CJ_CRV(pcrv)                                            \
(                                                               \
    offsetof(TTPOLYCURVE,apfx) + (pcrv)->cpfx * sizeof(POINTFX) \
)

#define CJ_BEZCRV(cBezPts)                                       \
(                                                                \
    offsetof(TTPOLYCURVE,apfx) + (cBezPts) * sizeof(POINTFX)     \
)


// reasonable guess that in most cases a contour will not consist of more
// than this many beziers

#define C_BEZIER 6


BOOL bGeneratePath(
    PVOID           * ppo,        // IN OUT pointer to the path object to be generated
    TTPOLYGONHEADER * ppolyStart, // IN OUT pointer to the buffer with outline data
    ULONG             cjTotal,    // IN     size of the buffer
    ULONG           * pcjOut,      // OUT   size of needed bezier buffer
    TTPOLYGONHEADER * ppolyBeziers // OUT   buffer with Bezier outline data
    )
{
    TTPOLYGONHEADER * ppoly, * ppolyEnd, *ppolyBez;
    TTPOLYCURVE     * pcrv, * pcrvEnd, *pcrvBez;
    POINTFIX          aptfixBez[3 * C_BEZIER];  // 3 points per bezier
    POINTFIX        * pptfixBez;
    ULONG             cBez;
    POINTFIX        * pptfixStart;
    ULONG             cjPolyBez = 0;
    ULONG             cjCrv, cjCrvBez;

    if (pcjOut)
        *pcjOut = 0; // to begin with

    // The code is no problem with NULL.
    ppolyBez = NULL;
    
    if (ppolyBeziers)
        ppolyBez = ppolyBeziers;

    for (
         ppoly = ppolyStart, ppolyEnd = (TTPOLYGONHEADER *)((PBYTE)ppolyStart + cjTotal);
         ppoly < ppolyEnd;
         ppoly = (TTPOLYGONHEADER *)((PBYTE)ppoly + ppoly->cb),
         ppolyBez = (TTPOLYGONHEADER *)((PBYTE)ppolyBez + cjPolyBez)
        )
    {
        ASSERTDD(ppoly->dwType == TT_POLYGON_TYPE, "TT_POLYGON_TYPE\n");

    // begin new closed contour

        if (ppo && !PATHOBJ_bMoveTo(ppo, *(POINTFIX *)&ppoly->pfxStart))
            RET_FALSE("TTFD!_PATHOBJ_bMoveTo failed\n");

    // init a loop over curves


        pptfixStart = (POINTFIX *)&ppoly->pfxStart;
        pcrvEnd = (TTPOLYCURVE *)((PBYTE)ppoly + ppoly->cb);

        for (
             pcrv = (TTPOLYCURVE *)(ppoly + 1),
             pcrvBez = (TTPOLYCURVE *)(ppolyBez + 1),
             cjPolyBez = sizeof(TTPOLYGONHEADER);
             pcrv < pcrvEnd;
             pcrv = (TTPOLYCURVE *)((PBYTE)pcrv + cjCrv),
             pcrvBez = (TTPOLYCURVE *)((PBYTE)pcrvBez + cjCrvBez),
             cjPolyBez += cjCrvBez
            )
        {
        // must compute the size of this curve first

            cjCrv = CJ_CRV(pcrv);

            if (pcrv->wType == TT_PRIM_LINE)
            {
                if (ppo && !PATHOBJ_bPolyLineTo(ppo,(POINTFIX *)pcrv->apfx, pcrv->cpfx))
                    RET_FALSE("TTFD!_bPolyLineTo()\n");

                cjCrvBez = cjCrv;

            // in the case of poly lines, we just copy the data out

                if (ppolyBeziers)
                    RtlCopyMemory(pcrvBez, pcrv, cjCrv);
            }
            else // qspline
            {
                BOOL bOk;
                ULONG cBezPts;

                ASSERTDD(pcrv->wType == TT_PRIM_QSPLINE, "TT_PRIM_QSPLINE\n");
                ASSERTDD(pcrv->cpfx > 1, "_TT_PRIM_QSPLINE, cpfx <= 1\n");
                cBez = pcrv->cpfx - 1;
                cBezPts = 3 * cBez;

                if (cBez > C_BEZIER) // must allocate buffer for the bezier points
                {
                    if ((pptfixBez = (POINTFIX *)PV_ALLOC(cBezPts * sizeof(POINTFIX))) == (POINTFIX *)NULL)
                    {
                        return (FALSE);
                    }
                }
                else // enough memory on the stack
                {
                    pptfixBez = aptfixBez;
                }

                vQsplineToPolyBezier (
                    cBez,                     // count of curves to convert to beziers format
                    pptfixStart,              // starting point on the first curve
                    (POINTFIX *)pcrv->apfx,   // array of (cBez+1) points that, together with the starting point *pptfixStart define the spline
                    pptfixBez);               // buffer to be filled with 3 * cBez poly bezier control points

                bOk = !ppo || PATHOBJ_bPolyBezierTo(ppo, pptfixBez, cBezPts);

            // compute the size of the corresponding bezier curve

                cjCrvBez = CJ_BEZCRV(cBezPts);

            // may need to fill bezier data out

                if (ppolyBeziers)
                {
                    pcrvBez->wType = TT_PRIM_CSPLINE;
                    pcrvBez->cpfx  = (WORD) cBezPts;
                    RtlCopyMemory(pcrvBez->apfx, pptfixBez,
                                  cBezPts * sizeof(POINTFIX));
                }

            // free mem if needed

                if (cBez > C_BEZIER)
                    V_FREE(pptfixBez);

                if (!bOk)
                    RET_FALSE("TTFD!_bPolyBezierTo() failed\n");
            }

        // get to the next curve in this polygon

            pptfixStart = (POINTFIX *) &pcrv->apfx[pcrv->cpfx - 1];
        }
        ASSERTDD(pcrv == pcrvEnd, "pcrv problem\n");

    // close the path

        if (ppo && !PATHOBJ_bCloseFigure(ppo))
            RET_FALSE("TTFD!_bPolyLineTo()\n");

    // add the size of the bezier polygon to the total bezier buffer size

        if (pcjOut)
            *pcjOut += cjPolyBez;

    // write polygon header to the out buffer

        if (ppolyBeziers)
        {
            ppolyBez->dwType = TT_POLYGON_TYPE;
            ppolyBez->cb = cjPolyBez;
            ppolyBez->pfxStart = ppoly->pfxStart;
        }
    }                                             // loop over polygons

    ASSERTDD(ppoly == ppolyEnd, "poly problem\n");
    return (TRUE);
}


/******************************Public*Routine******************************\
*
*    vQsplineToPolyBezier
*
* Effects:
*
* Warnings:
*
* History:
*  20-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#define DIV_BY_2(x) (((x) + 0x00000001) / 2)
#define DIV_BY_3(x) (((x) + 0x00000002) / 3)

STATIC VOID vQsplineToPolyBezier(
    ULONG      cBez,          //IN  count of curves to convert to beziers format
    POINTFIX * pptfixStart,   //IN  starting point on the first curve
    POINTFIX * pptfixSpline,  //IN  array of (cBez+1) points that, together with the starting point *pptfixStart define the spline
    POINTFIX * pptfixBez      //OUT buffer to be filled with 3 * cBez poly bezier control points
    )
{
    ULONG    iBez,cMidBez;
    POINTFIX ptfixA;

// cMidBez == # of beziers for whom the last point on the bezier is computed
// as a mid point of the two consecutive points in the input array. Only the
// last bezier is not a mid bezier, the last point for that bezier is equal
// to the last point in the input array

    ASSERTDD(cBez > 0, "cBez == 0\n");

    cMidBez = cBez - 1;
    ptfixA = *pptfixStart;

    for (iBez = 0; iBez < cMidBez; iBez++, pptfixSpline++)
    {
    // let us call the three spline points
    // A,B,C;
    // B = *pptfix;
    // C = (pptfix[0] + pptfix[1]) / 2; // mid point, unless at the end
    //
    // if we decide to call the two intermediate control points for the
    // bezier M,N (i.e. full set of control points for the bezier is
    // A,M,N,C), the points M,N are determined by following formulas:
    //
    // M = (2*B + A) / 3  ; two thirds along the segment AB
    // N = (2*B + C) / 3  ; two thirds along the segment CB
    //
    // this is the computation we are doing in this loop:

    // M point for this bezier

        pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
        pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
        pptfixBez++;

    // compute C point for this bezier, which is also the A point for the next
    // bezier

        ptfixA.x = DIV_BY_2(pptfixSpline[0].x + pptfixSpline[1].x);
        ptfixA.y = DIV_BY_2(pptfixSpline[0].y + pptfixSpline[1].y);

    // now compute N point for this bezier:

        pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
        pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
        pptfixBez++;

    // finally record the C point for this curve

        *pptfixBez++ = ptfixA;
    }

// finally do the last bezier. If the last bezier is the only one, the loop
// above has been skipped

// M point for this bezier

    pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
    pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
    pptfixBez++;

// compute C point for this bezier, its end point is the last point
// in the input array

    ptfixA = pptfixSpline[1];

// now compute N point for this bezier:

    pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
    pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
    pptfixBez++;

// finally record the C point for this curve, no need to increment pptfixBez

    *pptfixBez = ptfixA;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\fdsem.h ===
/******************************Module*Header*******************************\
* Module Name: fdsem.h
*
* declarations for the wrappers that serialize access to the rasterizer
*
* Created: 11-Apr-1992 19:37:49
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/


// EXPORTED FUNCTIONS OF THE IFI INTERFACE


HFF
ttfdSemLoadFontFile (
    //ULONG cFiles,
    ULONG_PTR *piFile,
    ULONG ulLangId
    );

BOOL
ttfdSemUnloadFontFile (
    HFF hff
    );

LONG
ttfdSemQueryFontData (
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH   hg,
    GLYPHDATA *pgd,
    PVOID   pv
    );
    
LONG
ttfdSemQueryFontDataSubPos (
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH   hg,
    GLYPHDATA *pgd,
    PVOID   pv,
    ULONG   subX,
    ULONG   subY
    );


VOID
ttfdSemDestroyFont (
    FONTOBJ *pfo
    );

LONG
ttfdQueryNumFaces (
    HFF     hff
    );

GP_IFIMETRICS *
ttfdQueryFont (
    HFF    hff,
    ULONG  iFace,
    ULONG *pid
    );

/* for GDI+ internal use, provide a pointer to the TrueType table, we need to call the
   release function for every Get function for the font file to get unmapped */

LONG
ttfdSemGetTrueTypeTable (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifyint the tt table
    PBYTE  *ppjTable,// ptr to table in the font file
    ULONG  *cjTable  // size of table
    );

void
ttfdSemReleaseTrueTypeTable (
    HFF     hff
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\fd_query.c ===
/******************************Module*Header*******************************\
* Module Name: fd_query.c                                                  *
*                                                                          *
* QUERY functions.                                                         *
*                                                                          *
* Created: 18-Nov-1991 14:37:56                                            *
* Author: Bodin Dresevic [BodinD]                                          *
*                                                                          *
* Copyright (c) 1993 Microsoft Corporation                                 *
\**************************************************************************/

#include "fd.h"
//#include "winfont.h"
#include "fdsem.h"
#include "winerror.h"

// extern HSEMAPHORE ghsemTTFD;

#ifdef _X86_
//
// For x86, FLOATL is actually DWORD, but the value is IEEE format floating
// point, then check sign bit.
//
#define IS_FLOATL_MINUS(x)   ((DWORD)(x) & 0x80000000)
#else
//
// For RISC, FLOATL is FLOAT.
//
#define IS_FLOATL_MINUS(x)   (((FLOATL)(x)) < 0.0f)
#endif // _X86_

//
// Monochrome: 1  bit per pixel
// Gray:       8 bits per pixel
// ClearType   8 bits per pixel also, no modification needed for CLEARTYPE
///            because FO_GRAYSCALE will be set along with FO_CLEARTYPE_GRID
//
// CJ_TT_SCAN rounds up to a 32-bit boundary
//
#define CJ_TT_SCAN(cx,p) \
    (4*((((((p)->flFontType & FO_GRAYSCALE)?(8):(1))*(cx))+31)/32))

// Each scan of a glyph bitmap is BYTE aligned (except for the
// top (first) scan which is DWORD aligned. The last scan is
// padded out with zeros to the nearest DWORD boundary. These
// statements apply to monochrome and 4-bpp gray glyphs images.
// The number of bytes per scan will depend upon the number of
// pixels in a scan and the depth of the image. For monochrome
// glyphs the number of bytes per scan is ceil(cx/8) = floor((cx+7)/8)
// For the case of 4-bpp bitmaps the count of bytes in a scan
// is ceil( 4*cx/8 ) = ceil(cx/2)

#define CJ_MONOCHROME_SCAN(cx)  (((cx)+7)/8)
#define CJ_4BIT_SCAN(cx)        (((cx)+1)/2)
#define CJ_8BIT_SCAN(cx)        (cx)

#define LABS(x) ((x)<0)?(-x):(x)

#if DBG
// #define  DEBUG_OUTLINE
// #define  DBG_CHARINC
#endif

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewContourGridFit(FONTCONTEXT *pfc)
{
    fs_GlyphInputType *gin  = pfc->pgin;          // used a lot
    fs_GlyphInfoType  *gout = pfc->pgout;         // used a lot
    FS_ENTRY iRet;


    iRet = fs_ContourGridFit(gin, gout);

    if (iRet != NO_ERR)
    {
        V_FSERROR(iRet);

    // try to recover, most likey bad hints, just return unhinted glyph

        iRet = fs_ContourNoGridFit(gin, gout);
    }
    return iRet;
}



/******************************Public*Routine******************************\
* VOID vCharacterCode
*
* History:
*  07-Dec-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vCharacterCode (
    FONTFILE          *pff,
    HGLYPH             hg,
    fs_GlyphInputType *pgin
    )
{
    ASSERTDD((hg & 0xffff0000) == 0, "hg not unicode\n");

    pgin->param.newglyph.characterCode = NONVALID;
    pgin->param.newglyph.glyphIndex = (uint16)hg;
    pgin->param.newglyph.bMatchBBox  = FALSE;
    pgin->param.newglyph.bNoEmbeddedBitmap = FALSE;
    return;
}



/******************************Public*Routine******************************\
* PIFIMETRICS ttfdQueryFont
*
* Return a pointer to the IFIMETRICS for the specified face of the font
* file.  Also returns an id (via the pid parameter) that is later used
* by ttfdFree.
*
* History:
*  21-Oct-1992 Gilman Wong [gilmanw]
* IFI/DDI merge
*
*  18-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

GP_IFIMETRICS *ttfdQueryFont (
    HFF    hff,
    ULONG  iFace,
    ULONG *pid
    )
{
    HFF    httc = hff;

// Validate handle.

    ASSERTDD(hff, "ttfdQueryFaces(): invalid iFile (hff)\n");
    ASSERTDD(iFace <= PTTC(hff)->ulNumEntry,
             "gdisrv!ttfdQueryFaces(): iFace out of range\n");

// get real hff from ttc array.

    hff   = PTTC(httc)->ahffEntry[iFace-1].hff;
    iFace = PTTC(httc)->ahffEntry[iFace-1].iFace;

//
// Validate handle.
//
    ASSERTDD(hff, "ttfdQueryFaces(): invalid iFile (hff)\n");
    ASSERTDD(iFace <= PFF(hff)->ffca.ulNumFaces,
             "ttfdQueryFaces(): iFace out of range\n");

//
// ttfdFree can ignore this.  IFIMETRICS will be deleted with the FONTFILE
// structure.
//
    *pid = (ULONG_PTR) NULL;

//
// Return the pointer to the precomputed IFIMETRICS in the PFF.
//

    if ( iFace == 1L )
        return ( &(PFF(hff)->ifi) ); // Normal face
    else
      return ( PFF(hff)->pifi_vertical ); // Vertical face
}


/******************************Public*Routine******************************\
* vFillSingularGLYPHDATA
*
* History:
*  22-Sep-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vFillSingularGLYPHDATA (
    HGLYPH       hg,
    ULONG        ig,
    FONTCONTEXT *pfc,
    GLYPHDATA   *pgldt   // OUT
    )
{
    extern VOID vGetNotionalGlyphMetrics(FONTCONTEXT*, ULONG, NOT_GM*);
    NOT_GM ngm;  // notional glyph data

    // may get changed by the calling routine if bits requested too
    pgldt->gdf.pgb = NULL;
    pgldt->hg = hg;

    pgldt->rclInk.left   = 0;
    pgldt->rclInk.top    = 0;
    pgldt->rclInk.right  = 0;
    pgldt->rclInk.bottom = 0;

// go on to compute the positioning info:

// here we will just xform the notional space data:

    vGetNotionalGlyphMetrics(pfc,ig,&ngm);

// xforms are computed by simple multiplication

    pgldt->fxD         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sD);
    pgldt->fxA         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sA);
    pgldt->fxAB        = fxLTimesEf(&pfc->efBase, (LONG)ngm.xMax);

    pgldt->fxD_Sideways  = fxLTimesEf(&pfc->efSide, (LONG)ngm.sD_Sideways);
    pgldt->fxA_Sideways  = fxLTimesEf(&pfc->efSide, (LONG)ngm.sA_Sideways);
    pgldt->fxAB_Sideways = pgldt->fxA_Sideways + fxLTimesEf(&pfc->efSide, (LONG)ngm.yMax - (LONG)ngm.yMin);

}


/******************************Public*Routine******************************\
* lGetSingularGlyphBitmap
*
* History:
*  22-Sep-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lGetSingularGlyphBitmap (
    FONTCONTEXT *pfc,
    HGLYPH       hglyph,
    GLYPHDATA   *pgd,
    VOID        *pv
    )
{
    LONG         cjGlyphData;
    ULONG        ig;
    FS_ENTRY     iRet;


    vCharacterCode(pfc->pff,hglyph,pfc->pgin);

// Compute the glyph index from the character code:

    if ((iRet = fs_NewGlyph(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);

        //WARNING("gdisrv!lGetSingularGlyphBitmap(): fs_NewGlyph failed\n");
        return FD_ERROR;
    }

// Return the glyph index corresponding to this hglyph.

    ig = pfc->pgout->glyphIndex;

    ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
    cjGlyphData = CJGD(0,0,pfc);

// If prg is NULL, caller is requesting just the size.

// At this time we know that the caller wants the whole GLYPHDATA with
// bitmap bits, or maybe just the glypdata without the bits.
// In either case we shall reject the caller if he did not
// provide sufficiently big buffer

// fill all of GLYPHDATA structure except for bitmap bits

    if ( pgd != (GLYPHDATA *)NULL )
    {
        vFillSingularGLYPHDATA( hglyph, ig, pfc, pgd );
    }

    if ( pv != NULL )
    {
        GLYPHBITS *pgb = (GLYPHBITS *)pv;

        // The corresponding GLYPHDATA structure has been modified
        // by vFillGlyphData. See the statement "pgldt->fxA = 0"
        // in vFillGlyphData.

        pgb->ptlUprightOrigin.x = 0;
        pgb->ptlUprightOrigin.y = 0;

        pgb->ptlSidewaysOrigin.x = 0;
        pgb->ptlSidewaysOrigin.y = 0;

        pgb->sizlBitmap.cx = 0;
        pgb->sizlBitmap.cy = 0;
    }

    if ( pgd != (GLYPHDATA *)NULL )
    {
        pgd->gdf.pgb = (GLYPHBITS *)pv;
    }


// Return the size.

    return(cjGlyphData);
}


/******************************Public*Routine******************************\
* lGetGlyphBitmap
*
* History:
*  20-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lGetGlyphBitmap (
    FONTCONTEXT *pfc,
    HGLYPH       hglyph,
    GLYPHDATA   *pgd,
    VOID        *pv,
    FS_ENTRY    *piRet
)
{
    PVOID pvSetMemoryBases(fs_GlyphInfoType*, fs_GlyphInputType*, int);
    VOID vCopyAndZeroOutPaddingBits(FONTCONTEXT*, GLYPHBITS*, BYTE*, GMC*);
    VOID vCopy4BitsPerPixel(FONTCONTEXT*, GLYPHBITS*, BYTE*, GMC*);
    VOID vCopy8BitsPerPixel(FONTCONTEXT *, GLYPHBITS *, BYTE *, GMC *);
    VOID vCopyClearTypeBits(FONTCONTEXT *, GLYPHBITS *, BYTE *, GMC *);
    VOID vFillGLYPHDATA(HGLYPH, ULONG, FONTCONTEXT*, fs_GlyphInfoType*, GLYPHDATA*, GMC*);
    BOOL bGetGlyphMetrics(FONTCONTEXT*, HGLYPH, FLONG, FS_ENTRY*);

    LONG         cjGlyphData;
    ULONG        cx,cy;
    GMC          gmc;
    GLYPHDATA    gd;
    BOOL         bBlankGlyph = FALSE; // initialization essential;

    ASSERTDD(hglyph != HGLYPH_INVALID, "lGetGlyphBitmap, hglyph == -1\n");
    ASSERTDD(pfc == pfc->pff->pfcLast, "pfc! = pfcLast\n");

    *piRet = NO_ERR;

// check the last glyph processed to determine
// whether we have to register the glyph as new and compute its size

    if (pfc->gstat.hgLast != hglyph)
    {
    // DO skip grid fitting if embedded bitmpas are found,
    // for we will NOT be interested in outlines

        if (!bGetGlyphMetrics(pfc,hglyph,FL_SKIP_IF_BITMAP,piRet))
        {
            return(FD_ERROR);
        }
    }


    cx = pfc->pgout->bitMapInfo.bounds.right
       - pfc->pgout->bitMapInfo.bounds.left;
    cy = pfc->pgout->bitMapInfo.bounds.bottom
       - pfc->pgout->bitMapInfo.bounds.top;

    // don't cheat like GDI, just return cx = 0, cy = 0, cj = 0 for empty bitmap

    if ((cx == 0) || (cy == 0))
    {
        bBlankGlyph = TRUE;
    }

    if (bBlankGlyph)
    {
        ASSERTDD(
            pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
        cjGlyphData = CJGD(0,0,pfc);
    }
    else
    {
    // this is quick and dirty computation, the acutal culGlyphData
    // written to the buffer may be little smaller if we had to shave
    // off a few scans off the glyph bitmap that extended over
    // the pfc->yMin or pfc->yMax bounds. Notice that culGlyphData
    // computed this way may be somewhat bigger than pfc->culGlyphMax,
    // but the actual glyph written to the buffer will be smaller than
    // pfc->culGlyphMax

        // really win31 hack, shold not always be shifting right [bodind]
        // Win95 FE hack

        ASSERTDD(
            pfc->flFontType & FO_CHOSE_DEPTH,
            "Depth Not Chosen Yet!\n"
        );
        cjGlyphData = CJGD(cx,cy,pfc);

    // since we will shave off any extra rows if there are any,
    // we can fix culGlyphData so as not extend over the max value

        if ((ULONG)cjGlyphData > pfc->cjGlyphMax)
        {
            cjGlyphData = (LONG)pfc->cjGlyphMax;

            if (cy > pfc->cyMax)
                cy = pfc->cyMax;
            if (cx > pfc->cxMax)
                cx = pfc->cxMax;
        }
    }

    if ( (pgd == NULL) && (pv == NULL))
        return cjGlyphData;

// at this time we know that the caller wants the whole GLYPHDATA with
// bitmap bits, or maybe just the glypdata without the bits.

// fill all of GLYPHDATA structure except for bitmap bits
// !!! Scummy hack - there appears to be no way to get just the
// !!! bitmap, without getting the metrics, since the origin for the
// !!! bitmap is computed from the rclink field in the glyphdata.
// !!! this is surely fixable but I have neither the time nor the
// !!! inclination to pursue it.
// !!!
// !!! We should fix this when we have time.

    if ( pgd == NULL )
    {
        pgd = &gd;
    }


    // Normal case
    vFillGLYPHDATA(
            hglyph,
            pfc->gstat.igLast,
            pfc,
            pfc->pgout,
            pgd,
            &gmc);

    {   // fix the cjGlyphData, cause it might have been a bit more than we actually need
        LONG newcjGlyphData = CJGD(gmc.cxCor, gmc.cyCor, pfc);
        ASSERT(newcjGlyphData <= cjGlyphData);
        cjGlyphData = newcjGlyphData;
    }

    // the caller wants the bits too

    if ( pv != NULL )
    {
        GLYPHBITS *pgb = (GLYPHBITS *)pv;

    // allocate mem for the glyph, 5-7 are magic #s required by the spec
    // remember the pointer so that the memory can be freed later in case
    // of exception

        pfc->gstat.pv = pvSetMemoryBases(pfc->pgout, pfc->pgin, IS_GRAY(pfc));
        if (!pfc->gstat.pv)
           RETURN("TTFD!_ttfdQGB, mem allocation failed\n",FD_ERROR);

    // initialize the fields needed by fs_ContourScan,
    // the routine that fills the outline, do the whole
    // bitmap at once, do not want banding

        pfc->pgin->param.scan.bottomClip = pfc->pgout->bitMapInfo.bounds.top;
        pfc->pgin->param.scan.topClip = pfc->pgout->bitMapInfo.bounds.bottom;
        pfc->pgin->param.scan.outlineCache = (int32 *)NULL;


    // make sure that our state is ok: the ouline data in the shared buffer 3
    // must correspond to the glyph we are processing, and the last
    // font context that used the shared buffer pj3 to store glyph outlines
    // has to be the pfc passed to this function:

        ASSERTDD(hglyph == pfc->gstat.hgLast, "hgLast trashed \n");

        *piRet = fs_ContourScan(pfc->pgin,pfc->pgout);

        pfc->gstat.hgLast = HGLYPH_INVALID;


        if (*piRet != NO_ERR)
        {
        // just to be safe for the next time around, reset pfcLast to NULL

            V_FSERROR(*piRet);
            V_FREE(pfc->gstat.pv);
            pfc->gstat.pv = NULL;

            return(FD_ERROR);
        }

        if (!bBlankGlyph && gmc.cxCor && gmc.cyCor)
        {
        // copy to the engine's buffer and zero out the bits
        // outside of the black box


        // Call either the monochrome or the gray level function
        // depending upon the gray bit in the font context

            if (IS_GRAY(pfc))
            {
                if (IS_CLEARTYPE(pfc))
                    vCopyClearTypeBits(pfc, pgb, (BYTE*) pfc->pgout->bitMapInfo.baseAddr, &gmc);
                else if (pfc->flFontType & FO_SUBPIXEL_4)
                    vCopy8BitsPerPixel(pfc, pgb, (BYTE*) pfc->pgout->bitMapInfo.baseAddr, &gmc);
                else
                    vCopy4BitsPerPixel(pfc, pgb, (BYTE*) pfc->pgout->bitMapInfo.baseAddr, &gmc);
            }
            else
            {
                vCopyAndZeroOutPaddingBits(pfc, pgb, (BYTE*) pfc->pgout->bitMapInfo.baseAddr, &gmc);
            }

        // bitmap origin, i.e. the upper left corner of the bitmap, bitmap
        // is as big as its black box


            pgb->ptlUprightOrigin.x = pgd->rclInk.left;
            pgb->ptlUprightOrigin.y = pgd->rclInk.top;

            pgb->ptlSidewaysOrigin.x = F16_16TOLROUND(pfc->pgout->verticalMetricInfo.devTopSideBearing.x);
            pgb->ptlSidewaysOrigin.y = -F16_16TOLROUND(pfc->pgout->verticalMetricInfo.devTopSideBearing.y);
        }
        else // blank glyph, return a blank 0x0 bitmap
        {
            pgb->ptlUprightOrigin.x = 0;
            pgb->ptlUprightOrigin.y = 0;

            pgb->ptlSidewaysOrigin.x = 0;
            pgb->ptlSidewaysOrigin.y = 0;

            pgb->sizlBitmap.cx = 0;
            pgb->sizlBitmap.cy = 0;
        }

        pgd->gdf.pgb = pgb;


    // free memory and return

        V_FREE(pfc->gstat.pv);
        pfc->gstat.pv = NULL;
    }

    return(cjGlyphData);
}


/******************************Public*Routine******************************\
*
* BOOL bGetGlyphOutline
*
* valid outline points are in pfc->gout after this call
*
* History:
*  19-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bGetGlyphOutline (
    FONTCONTEXT *pfc,
    HGLYPH       hg,
    ULONG       *pig,
    FLONG        fl,
    FS_ENTRY    *piRet
    )
{
// new glyph coming in or the metric has to be recomputed
// because the contents of the gin,gout strucs have been destroyed

    vInitGlyphState(&pfc->gstat);

    ASSERTDD((hg != HGLYPH_INVALID) && ((hg & (HGLYPH)0xFFFF0000) == 0),
              "ttfdQueryGlyphBitmap: hg\n");

    vCharacterCode(pfc->pff,hg,pfc->pgin);

// compute the glyph index from the character code:

    if ((*piRet = fs_NewGlyph(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(*piRet);
        RET_FALSE("TTFD!_bGetGlyphOutline, fs_NewGlyph\n");
    }

// return the glyph index corresponding to this hglyph:

    *pig = pfc->pgout->glyphIndex;

// these two field must be initialized before calling fs_ContourGridFit

    pfc->pgin->param.gridfit.styleFunc = 0; //!!! do some casts here

    pfc->pgin->param.gridfit.traceFunc = (FntTraceFunc)NULL;

// if bitmap is found for this glyph and if we are ultimately interested
// in bitmaps only and do not care about intermedieate outline, then set the
// bit in the "in" structure to hint the rasterizer that grid fitting
// will not be necessary:

    if (!IS_GRAY(pfc) && pfc->pgout->usBitmapFound && (fl & FL_SKIP_IF_BITMAP))
        pfc->pgin->param.gridfit.bSkipIfBitmap = 0;
    else
        pfc->pgin->param.gridfit.bSkipIfBitmap = 0; // must do hinting

// fs_ContourGridFit hints the glyph (executes the instructions for the glyph)
// and converts the glyph data from the tt file into an outline for this glyph

    if (!(fl & FL_FORCE_UNHINTED) )
    {
        if ((*piRet = fs_NewContourGridFit(pfc)) != NO_ERR)
        {
            V_FSERROR(*piRet);
            RET_FALSE("TTFD!_bGetGlyphOutline, fs_NewContourGridFit\n");
        }
    }
    else // unhinted glyphs are desired
    {
        if ((*piRet = fs_ContourNoGridFit(pfc->pgin, pfc->pgout)) != NO_ERR)
        {
            V_FSERROR(*piRet);
            RET_FALSE("TTFD!_bGetGlyphOutline, fs_ContourNoGridFit\n");
        }
    }


    return(TRUE);
}


/******************************Public*Routine******************************\
*
* BOOL bGetGlyphMetrics
*
* History:
*  22-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bGetGlyphMetrics (
    PFONTCONTEXT pfc,
    HGLYPH       hg,
    FLONG        fl,
    FS_ENTRY    *piRet
    )
{
    ULONG  ig;
    FS_ENTRY i;

    if (!bGetGlyphOutline(pfc,hg,&ig,fl,piRet))
    {
        V_FSERROR(*piRet);
        RET_FALSE("TTFD!_bGetGlyphMetrics, bGetGlyphOutline failed \n");
    }

// get the metric info for this glyph,

    i = fs_FindBitMapSize(pfc->pgin, pfc->pgout);

    if (i != NO_ERR)
    {
        *piRet = i;
        V_FSERROR(*piRet);
        RET_FALSE("TTFD!_bGetGlyphMetrics, fs_FindBitMapSize \n");
    }


// now that everything is computed sucessfully, we can update
// glyphstate (hg data stored in pj3) and return

    pfc->gstat.hgLast = hg;
    pfc->gstat.igLast = ig;

    return(TRUE);
}




/******************************Public*Routine******************************\
* VOID vFillGLYPHDATA
*
* History:
*  22-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vFillGLYPHDATA(
    HGLYPH            hg,
    ULONG             ig,
    FONTCONTEXT      *pfc,
    fs_GlyphInfoType *pgout,   // outputed from fsFind bitmap size
    GLYPHDATA        *pgldt,   // OUT
    GMC              *pgmc     // optional, not used if doing outline only
    )
{
    extern VOID vGetNotionalGlyphMetrics(FONTCONTEXT*, ULONG, NOT_GM*);

    BOOL bOutOfBounds = FALSE;

    vectorType     * pvtD;  // 16.16 point
    vectorType     * pvtDv;  // 16.16 point

    LONG lA,lAB;      // *pvtA rounded to the closest integer value

    ULONG  cx = (ULONG)(pgout->bitMapInfo.bounds.right - pgout->bitMapInfo.bounds.left);
    ULONG  cy = (ULONG)(pgout->bitMapInfo.bounds.bottom - pgout->bitMapInfo.bounds.top);

    LONG lAdvanceHeight;
    LONG lTopSideBearing;

    pgldt->gdf.pgb = NULL; // may get changed by the calling routine if bits requested too
    pgldt->hg = hg;


// fs_FindBitMapSize returned  the the following information in gout:
//
//  1) gout.metricInfo // left side bearing and advance width
//
//  2) gout.bitMapInfo // black box info
//
//  3) memory requirement for the bitmap,
//     returned in gout.memorySizes[5] and gout.memorySizes[6]
//
// Notice that fs_FindBitMapSize is exceptional scaler interface routine
// in that it returns info in several rather than in a single
// substructures of gout

// Check if hinting produced totally unreasonable result:

    bOutOfBounds = ( (pgout->bitMapInfo.bounds.left > pfc->xMax)    ||
                     (pgout->bitMapInfo.bounds.right < pfc->xMin)   ||
                     (-pgout->bitMapInfo.bounds.bottom > pfc->yMax) ||
                     (-pgout->bitMapInfo.bounds.top < pfc->yMin)    );

    #if DBG
        if (bOutOfBounds)
            TtfdDbgPrint("TTFD! Glyph out of bounds: ppem = %ld, gi = %ld\n",
                pfc->lEmHtDev, hg);
    #endif


    if ((cx == 0) || (cy == 0) || bOutOfBounds)
    {
        pgldt->rclInk.left   = 0;
        pgldt->rclInk.top    = 0;
        pgldt->rclInk.right  = 0;
        pgldt->rclInk.bottom = 0;

        if (pgmc != (PGMC)NULL)
        {
            pgmc->cxCor = 0;  // forces blank glyph case when filling the bits
            pgmc->cyCor = 0;  // forces blank glyph case when filling the bits
        }

        pgldt->VerticalOrigin_X = 0;
        pgldt->VerticalOrigin_Y = 0;
    }
    else // non empty bitmap
    {

        // black box info, we have to transform y coords to ifi specifications

        pgldt->rclInk.bottom = - pgout->bitMapInfo.bounds.top;
        pgldt->rclInk.top    = - pgout->bitMapInfo.bounds.bottom;
        pgldt->rclInk.left = pgout->bitMapInfo.bounds.left;
        pgldt->rclInk.right = pgout->bitMapInfo.bounds.right;

        if (cy > pfc->cyMax)
        {
            #if DBG
                    TtfdDbgPrint("ttfdQueryGlyphBitmap, out of bounds, cy > pfc->cyMax \n");
            #endif // DBG
            // clip the bottom side
            pgldt->rclInk.bottom = pgldt->rclInk.bottom + pfc->cyMax - cy;
            cy = pfc->cyMax;
        }
        if (cx > pfc->cxMax)
        {
            #if DBG
                    TtfdDbgPrint("ttfdQueryGlyphBitmap, out of bounds, cx > pfc->cxMax \n");
            #endif // DBG
            // clip the right side
            pgldt->rclInk.right = pgldt->rclInk.right + pfc->cxMax - cx;
            cx = pfc->cxMax;
        }

        if (pgmc != (PGMC)NULL)
        {
            pgmc->cxCor    = cx;
            pgmc->cyCor    = cy;

        // only corrected values have to obey this condition:

            ASSERTDD(
                pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
            #if DBG
                if (CJGD(pgmc->cxCor,pgmc->cyCor,pfc) > pfc->cjGlyphMax)
                    TtfdDbgPrint("ttfdQueryGlyphBitmap, out of bounds, > cjGlyphMax \n");
            #endif // DBG
        }


        // Determine vertical origin

        if (UNHINTED_MODE(pfc))
        {
            pgldt->VerticalOrigin_X = F26_6TO28_4(pgout->xPtr[pgout->endPtr[
                                (unsigned)pgout->numberOfContours-1]+3]);

            pgldt->VerticalOrigin_Y = - F26_6TO28_4(pgout->yPtr[pgout->endPtr[
                                (unsigned)pgout->numberOfContours-1]+3]);
        }
        else
        {
            pgldt->VerticalOrigin_X = (   pgldt->rclInk.left
                                       -  F16_16TOLROUND(pfc->pgout->verticalMetricInfo.devTopSideBearing.x)) << 4;
            pgldt->VerticalOrigin_Y = (   pgldt->rclInk.top
                                       +  F16_16TOLROUND(pfc->pgout->verticalMetricInfo.devTopSideBearing.y)) << 4;
        }

    } // end of the non empty bitmap clause


    // go on to compute the positioning info:

    pvtD = & pgout->metricInfo.devAdvanceWidth;
    pvtDv = & pgout->verticalMetricInfo.devAdvanceHeight;

    if (pfc->flXform & (XFORM_HORIZ | XFORM_VERT))  // scaling or 90 degree rotation
    {
        FIX fxTmp, horAdvance, vertAdvance;

        if (pfc->flXform & XFORM_HORIZ )
        {
            horAdvance = LABS(pvtD->x);
            vertAdvance = LABS(pvtDv->y);
            pgldt->fxA = LTOFX(pgldt->rclInk.left);
            pgldt->fxAB = LTOFX(pgldt->rclInk.right);
            pgldt->fxA_Sideways = LTOFX(pgldt->rclInk.top) - pgldt->VerticalOrigin_Y;
            pgldt->fxAB_Sideways = LTOFX(pgldt->rclInk.bottom) - pgldt->VerticalOrigin_Y;
        }
        else
        {
            horAdvance = LABS(pvtD->y);
            vertAdvance = LABS(pvtDv->x);
            pgldt->fxA = -LTOFX(pgldt->rclInk.bottom);
            pgldt->fxAB = -LTOFX(pgldt->rclInk.top);
            pgldt->fxA_Sideways = LTOFX(pgldt->rclInk.left) - pgldt->VerticalOrigin_X;
            pgldt->fxAB_Sideways = LTOFX(pgldt->rclInk.right) - pgldt->VerticalOrigin_X;
        }

        if ((pfc->mx.transform[0][0] < 0) || (pfc->mx.transform[0][1] < 0))
        {
            fxTmp = pgldt->fxA;
            pgldt->fxA = -pgldt->fxAB;
            pgldt->fxAB = -fxTmp;
            fxTmp = pgldt->fxA_Sideways;
            pgldt->fxA_Sideways = -pgldt->fxAB_Sideways;
            pgldt->fxAB_Sideways = -fxTmp;
        }

        if(UNHINTED_MODE(pfc))
        {
            pgldt->fxD = F16_16TO28_4(horAdvance);
            pgldt->fxD_Sideways = F16_16TO28_4(vertAdvance);
        }
        else if (IS_CLEARTYPE_NATURAL(pfc))
        {
            // in the cleartype natural width, we want to ignore the cached width, use the widths from the rasterizer
            // we we still need to round the widths to a pixel value
            pgldt->fxD = F16_16TOLROUND(horAdvance);
            pgldt->fxD = LTOFX(pgldt->fxD);
            pgldt->fxD_Sideways = F16_16TOLROUND(vertAdvance);
            pgldt->fxD_Sideways = LTOFX(pgldt->fxD_Sideways);
        }
        else
        {
            // bGetFastAdvanceWidth return the cached or linear width, we use the fast value to have the same result as GDI
           if (!bGetFastAdvanceWidth(pfc,ig, &pgldt->fxD))
            {
                // not possible to get the fast value, use the "slow" value
                // supplied by the rasterizer.
                pgldt->fxD = F16_16TOLROUND(horAdvance);
                pgldt->fxD = LTOFX(pgldt->fxD);
            }
            pgldt->fxD_Sideways = F16_16TOLROUND(vertAdvance);
            pgldt->fxD_Sideways = LTOFX(pgldt->fxD_Sideways);

        }
    }
    else // non trivial information
    {
        // here we will just xform the notional space data:

        NOT_GM ngm;  // notional glyph data
        USHORT cxExtra = (pfc->flFontType & FO_SIM_BOLD) ? (1 << 4) : 0;

        vGetNotionalGlyphMetrics(pfc,ig,&ngm);

        // xforms are computed by simple multiplication

        pgldt->fxD         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sD);

        pgldt->fxA         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sA);
        pgldt->fxAB        = fxLTimesEf(&pfc->efBase, (LONG)ngm.xMax);

        if (pfc->flFontType & FO_SIM_BOLD)
        {

            if (pgldt->fxD) /* we don't increase the width of a zero width glyph, problem with indic script */
            {
                pgldt->fxD += LTOFX(1);
            }
            pgldt->fxAB += LTOFX(pfc->dBase);
        }

        pgldt->fxD_Sideways  = fxLTimesEf(&pfc->efSide, (LONG)ngm.sD_Sideways);
        pgldt->fxA_Sideways  = fxLTimesEf(&pfc->efSide, (LONG)ngm.sA_Sideways);
        pgldt->fxAB_Sideways = pgldt->fxA_Sideways + fxLTimesEf(&pfc->efSide, (LONG)ngm.yMax - (LONG)ngm.yMin);

        // just to be safe let us round these up and down appropriately

        #define ROUND_DOWN(X) ((X) & ~0xf)
        #define ROUND_UP(X)   (((X) + 15) & ~0xf)

        pgldt->fxA         = ROUND_DOWN(pgldt->fxA);
        pgldt->fxAB        = ROUND_UP(pgldt->fxAB);

        pgldt->fxA_Sideways   = ROUND_DOWN(pgldt->fxA_Sideways);
        pgldt->fxAB_Sideways  = ROUND_UP(pgldt->fxAB_Sideways);

    }

}


/******************************Public*Routine******************************\
*
* ttfdQueryTrueTypeTable
*
* copies cjBytes starting at dpStart from the beginning of the table
* into the buffer
*
* if pjBuf == NULL or cjBuf == 0, the caller is asking how big a buffer
* is needed to store the info from the offset dpStart to the table
* specified by ulTag to the end of the table
*
* if pjBuf != 0  the caller wants no more than cjBuf bytes from
* the offset dpStart into the table copied into the
* buffer.
*
* if table is not present or if dpScart >= cjTable 0 is returned
*
* tag 0 means that the data has to be retrieved from the offset dpStart
* from the beginning of the file. The lenght of the whole file
* is returned if pBuf == nULL
*
* History:
*  09-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


PBYTE pjTable(ULONG ulTag, PFONTFILE pff, ULONG *pcjTable);

LONG ttfdQueryTrueTypeTable2 (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifying the tt table
    PTRDIFF dpStart, // offset into the table
    ULONG   cjBuf,   // size of the buffer to retrieve the table into
    BYTE   *pjBuf,   // ptr to buffer into which to return the data
    PBYTE  *ppjTable,// ptr to table in the mapped file
    ULONG  *pcjTable // size of the whole table
    )
{
    PBYTE     pjBegin;  // ptr to the beginning of the table
    LONG      cjTable;
    HFF       hffTTC = hff;

    ASSERTDD(hff, "ttfdQueryTrueTypeTable\n");

    if (dpStart < 0)
        return (FD_ERROR);

// if this font file is gone we are not gonna be able to answer any questions
// about it

    if (PTTC(hffTTC)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
        //WARNING("ttfd, ttfdQueryTrueTypeTable: file is gone\n");
        return FD_ERROR;
    }

    ASSERTDD(ulFont <= PTTC(hffTTC)->ulNumEntry,
             "gdisrv!ttfdQueryFaces(): iFace out of range\n"
             );

// get real hff from ttc array.

    hff    = PTTC(hffTTC)->ahffEntry[ulFont-1].hff;
    ulFont = PTTC(hffTTC)->ahffEntry[ulFont-1].iFace;

    ASSERTDD(ulFont <= PFF(hff)->ffca.ulNumFaces,
             "TTFD!_ttfdQueryTrueTypeTable: ulFont != 1\n");

// verify the tag, determine whether this is a required or an optional
// table:

#define tag_TTCF  0x66637474    // 'ttcf'

    if(ulTag == tag_TTCF)
    {
    // if the table offset is 0 it can't be a TTC and we should fail.

        if(PFF(hff)->ffca.ulTableOffset)
        {
            pjBegin = (PBYTE)PFF(hff)->pvView;
            cjTable = PFF(hff)->cjView;
        }
        else
        {
            return(FD_ERROR);
        }
    }
    else
    if (ulTag == 0)  // requesting the whole file
    {
        pjBegin = (PBYTE)PFF(hff)->pvView + PFF(hff)->ffca.ulTableOffset;
        cjTable = PFF(hff)->cjView - PFF(hff)->ffca.ulTableOffset; // cjView == cjFile
    }
    else // some specific table is requested
    {
        pjBegin = pjTable(ulTag, PFF(hff), &cjTable);

        if (pjBegin == (PBYTE)NULL)  // table not present
            return (FD_ERROR);
    }

// if we are succesfull now is the time to return
// the pointer to the whole table in the file and its size:

    if (ppjTable)
    {
        *ppjTable = pjBegin;
    }
    if (pcjTable)
    {
        *pcjTable = cjTable;
    }

// adjust pjBegin to point to location from where the data is to be copied

    pjBegin += dpStart;
    cjTable -= (LONG)dpStart;

    if (cjTable <= 0) // dpStart offsets into mem after the end of table
        return (FD_ERROR);

    if ( (pjBuf == (PBYTE)NULL) || (cjBuf == 0) )
    {
    // the caller is asking how big a buffer it needs to allocate to
    // store the bytes from the offset dpStart into the table to
    // the end of the table (or file if tag is zero)

        return (cjTable);
    }

// at this point we know that pjBuf != 0, the caller wants cjBuf bytes copied
// into his buffer:

    if ((ULONG)cjTable > cjBuf)
        cjTable = (LONG)cjBuf;

    if (pjBuf != NULL)
        RtlCopyMemory((PVOID)pjBuf, (PVOID)pjBegin, cjTable);

    return (cjTable);
}



LONG
ttfdQueryTrueTypeTable (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifying the tt table
    PTRDIFF dpStart, // offset into the table
    ULONG   cjBuf,   // size of the buffer to retrieve the table into
    BYTE   *pjBuf,   // ptr to buffer into which to return the data
    PBYTE  *ppjTable,// pointer in the file
    ULONG  *pcjTable // size of the whole table
    )
{
    LONG lRet;
    HFF hffTTF;

    // update the HFF with the remapped view

    hffTTF   = PTTC(hff)->ahffEntry[ulFont-1].hff;

    if (PFF(hffTTF)->cRef == 0)
    {

        PFF(hffTTF)->pvView = PTTC(hff)->pvView;
        PFF(hffTTF)->cjView = PTTC(hff)->cjView;
    }

    lRet = ttfdQueryTrueTypeTable2(
               hff, ulFont, ulTag, dpStart,
               cjBuf, pjBuf, ppjTable, pcjTable);

    return lRet;
}



/******************************Public*Routine******************************\
* ttfdQueryNumFaces
*
* Returns: the number of faces in font file.
*
\**************************************************************************/

LONG ttfdQueryNumFaces (
    HFF     hff         // handle to font file
    )
{
    // Currently, only one face per TrueType file.  This may one day change!
    return (PTTC(hff))->ulNumEntry;
}


/******************************Public*Routine******************************\
*
* vCopyAndZeroOutPaddingBits
*
* copies the bits of the bitmap and zeroes out padding bits
*
* History:
*  18-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

// array of masks for the last byte in a row

static const BYTE gjMask[8] = {0XFF, 0X80, 0XC0, 0XE0, 0XF0, 0XF8, 0XFC, 0XFE };
static const BYTE gjMaskHighBit[8] = {0XFF, 0X01, 0X03, 0X07, 0X0F, 0X1F, 0X3F, 0X7F};

VOID vCopyAndZeroOutPaddingBits(
    FONTCONTEXT *pfc,
    GLYPHBITS   *pgb,
    BYTE        *pjSrc,
    GMC         *pgmc
    )
{
    BYTE   jMask = gjMask[pgmc->cxCor & 7];
    ULONG  cjScanSrc = CJ_TT_SCAN(pgmc->cxCor,pfc);
    ULONG  cxDst = pgmc->cxCor;
    ULONG  cjScanDst = CJ_MONOCHROME_SCAN(cxDst);      // includes emboldening if any
    ULONG  cjDst = CJ_MONOCHROME_SCAN(pgmc->cxCor);    // does not include emboldening
    BYTE   *pjScan, *pjScanEnd;
    ULONG  iByteLast = cjDst - 1;

// sanity checks

    ASSERTDD(!IS_GRAY(pfc),"Monochrome Images Only Please!\n");
    ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,
        "We haven't decided about pixel depth\n"
    );
    ASSERTDD(pgmc->cxCor < LONG_MAX, "TTFD!vCopyAndZeroOutPaddingBits, cxCor\n");
    ASSERTDD(pgmc->cyCor < LONG_MAX, "TTFD!vCopyAndZeroOutPaddingBits, cyCor\n");
    ASSERTDD(pgmc->cxCor > 0, "vCopyAndZeroOutPaddingBits, cxCor == 0\n");
    ASSERTDD(pgmc->cyCor > 0, "vCopyAndZeroOutPaddingBits, cyCor == 0\n");

    pgb->sizlBitmap.cx = cxDst;

    pgb->sizlBitmap.cy = pgmc->cyCor;

// if must chop off a few columns (on the right, this should almost
// never happen), put the warning for now to detect these
// situations and look at them, it does not matter if this is slow

    pjScan = pgb->aj;


    for (
         pjScanEnd = pjScan + (pgmc->cyCor * cjScanDst);
         pjScan < pjScanEnd;
         pjScan += cjScanDst, pjSrc += cjScanSrc
        )
    {
        RtlCopyMemory((PVOID)pjScan,(PVOID)pjSrc,cjDst);
        pjScan[iByteLast] &= jMask; // mask off the last byte
    }

}


/******************************Public*Routine******************************\
* vGetNotionalGlyphMetrics
*
*
\**************************************************************************/

// be values for the format of the indexToLocation table

#define BE_ITOLOCF_SHORT   0X0000
#define BE_ITOLOCF_LONG    0X0100

// offsets to the non scaled glyphdata

#define OFF_nc    0
#define OFF_xMin  2
#define OFF_yMin  4
#define OFF_xMax  6
#define OFF_yMax  8


VOID vGetNotionalGlyphMetrics(
    FONTCONTEXT *pfc,  // IN
    ULONG        ig,   // IN , glyph index
    NOT_GM      *pngm  // OUT, notional glyph metrics
    )
{
    sfnt_FontHeader        * phead;
    sfnt_HorizontalHeader  * phhea;
    sfnt_HorizontalMetrics * phmtx;
    PBYTE                    pjGlyph;
    PBYTE                    pjLoca;
    ULONG                    numberOf_LongHorMetrics;
    BYTE                   * pjView = pfc->pff->pvView;

    sfnt_VerticalMetrics   * pvmtx;
    ULONG                    numberOf_LongVerticalMetrics = pfc->pff->ffca.uLongVerticalMetrics;

#if DBG
    sfnt_maxProfileTable   * pmaxp;
    ULONG                    cig;

    pmaxp = (sfnt_maxProfileTable *)(pjView + pfc->ptp->ateReq[IT_REQ_MAXP].dp);
    cig = BE_UINT16(&pmaxp->numGlyphs) + 1;
    ASSERTDD(ig < cig, "ig >= numGlyphs\n");
#endif

// compute the relevant pointers:

    phead = (sfnt_FontHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HEAD].dp);
    phhea = (sfnt_HorizontalHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HHEAD].dp);
    phmtx = (sfnt_HorizontalMetrics *)(pjView + pfc->ptp->ateReq[IT_REQ_HMTX].dp);
    pjGlyph = pjView + pfc->ptp->ateReq[IT_REQ_GLYPH].dp;
    pjLoca  = pjView + pfc->ptp->ateReq[IT_REQ_LOCA].dp;
    numberOf_LongHorMetrics = BE_UINT16(&phhea->numberOf_LongHorMetrics);


// get the pointer to the beginning of the glyphdata for this glyph
// if short format, offset divided by 2 is stored in the table, if long format,
// the actual offset is stored. Offsets are measured from the beginning
// of the glyph data table, i.e. from pjGlyph

    switch (phead->indexToLocFormat)
    {
    case BE_ITOLOCF_SHORT:
        pjGlyph += 2 * BE_UINT16(pjLoca + (sizeof(uint16) * ig));
        break;

    case BE_ITOLOCF_LONG :
        pjGlyph += BE_UINT32(pjLoca + (sizeof(uint32) * ig));
        break;

    default:
        //RIP("TTFD!_illegal phead->indexToLocFormat\n");
        break;
    }

// get the bounds, flip y

    pngm->xMin = BE_INT16(pjGlyph + OFF_xMin);
    pngm->xMax = BE_INT16(pjGlyph + OFF_xMax);
    pngm->yMin = - BE_INT16(pjGlyph + OFF_yMax);
    pngm->yMax = - BE_INT16(pjGlyph + OFF_yMin);

// get the adwance width and the lsb
// the piece of code stolen from the rasterizer [bodind]

    if (ig < numberOf_LongHorMetrics)
    {
        pngm->sD = BE_INT16(&phmtx[ig].advanceWidth);
        pngm->sA = BE_INT16(&phmtx[ig].leftSideBearing);
    }
    else
    {
    // first entry after[AW,LSB] array

        int16 * psA = (int16 *) &phmtx[numberOf_LongHorMetrics];

        pngm->sD = BE_INT16(&phmtx[numberOf_LongHorMetrics-1].advanceWidth);
        pngm->sA = BE_INT16(&psA[ig - numberOf_LongHorMetrics]);
    }

// redefine x coords so that they correspond to being measured relative to
// the real character origin

    pngm->xMax = pngm->xMax - pngm->xMin + pngm->sA;
    pngm->xMin = pngm->sA;

    if (pfc->flFontType & FO_SIM_ITALIC)
    {
    // IF there is italic simulation A,B,C spaces change

        pngm->sA   -= (SHORT)FixMul(pngm->yMax, FX_SIN20);
        pngm->xMax -= (SHORT)FixMul(pngm->yMin, FX_SIN20);
    }

// vertical sideways computation :

    if (numberOf_LongVerticalMetrics)  // the font has vmtx table
    {
        pvmtx = (sfnt_VerticalMetrics *)(pjView + pfc->ptp->ateOpt[IT_OPT_VMTX].dp);

        if (ig < numberOf_LongVerticalMetrics)
        {
            pngm->sD_Sideways  = BE_INT16(&pvmtx[ig].advanceHeight);
            pngm->sA_Sideways = BE_INT16(&pvmtx[ig].topSideBearing);
        }
        else
        {
    // first entry after[AH,TSB] array

            int16 * psTSB = (int16 *) &pvmtx[numberOf_LongVerticalMetrics];

            pngm->sD_Sideways  = BE_INT16(&pvmtx[numberOf_LongVerticalMetrics-1].advanceHeight);
            pngm->sA_Sideways = BE_INT16(&psTSB[ig - numberOf_LongVerticalMetrics]); 
        }
    }
    else // few buggy fonts do not have vmtx table
    {
    // default AdvanceHeight and TopSideBearing from Ascender and Descender

        pngm->sD_Sideways  = pfc->pff->ifi.fwdWinAscender + pfc->pff->ifi.fwdWinDescender;
        pngm->sA_Sideways = pfc->pff->ifi.fwdWinAscender + pngm->yMin; // y points down!!!

    // at this point sTSB should be bigger than 0. But because of the bugs in
    // our fonts, mingliu.ttc etc, it turns out that there are glyphs that
    // have their tops significanly above the descender so sTSB becomes
    // negative, even though it should not be. So we fix it now:

        if (pngm->sA_Sideways < 0)
            pngm->sA_Sideways = 0;
    }

    if (pfc->flFontType & FO_SIM_ITALIC_SIDEWAYS)
    {
    // IF there is italic simulation A,B,C spaces change
        SHORT TopOriginX = pfc->pff->ifi.fwdWinDescender -((pfc->pff->ifi.fwdWinAscender + pfc->pff->ifi.fwdWinDescender - pngm->sD) /2);

        pngm->yMin += (SHORT)FixMul(pngm->xMin, FX_SIN20);
        pngm->yMax += (SHORT)FixMul(pngm->xMax, FX_SIN20);
        pngm->sA_Sideways -= (SHORT)FixMul(TopOriginX, FX_SIN20);
    }

}

LONG lFFF(LONG l);
#define FFF(e,l) *(LONG*)(&(e)) = lFFF(l)

/******************************Public*Routine******************************\
* lQueryDEVICEMETRICS
*
* History:
*  08-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lQueryDEVICEMETRICS (
         FONTCONTEXT *pfc,
               ULONG  cjBuffer,
    FD_DEVICEMETRICS *pdevm
    )
{
    sfnt_FontHeader *phead;

    LONG  lTotalLeading;

    BYTE *pjView =  (BYTE *)pfc->pff->pvView;

    PBYTE pjOS2 = (pfc->pff->ffca.tp.ateOpt[IT_OPT_OS2].dp)         ?
                  (pjView + pfc->pff->ffca.tp.ateOpt[IT_OPT_OS2].dp):
                  NULL                                         ;

   Fixed fxXScale = pfc->mx.transform[0][0];
   if (fxXScale < 0)
       fxXScale = - fxXScale;

// actually requesting the data

    ASSERTDD (
        sizeof(FD_DEVICEMETRICS) <= cjBuffer,
        "FD_QUERY_DEVICEMETRICS: buffer too small\n");


    // get the pointers to needed tables in the tt file

    phead = (sfnt_FontHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HEAD].dp);


    // add new fields:

    pdevm->HorizontalTransform = pfc->flXform & XFORM_HORIZ;
    pdevm->VerticalTransform   = pfc->flXform & XFORM_VERT;

    if ( pfc->flXform & XFORM_SINGULAR )
    {
        ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
        pdevm->cjGlyphMax  = CJGD(0,0,pfc);
        pdevm->xMin        = 0;
        pdevm->xMax        = 0;
        pdevm->yMin        = 0;
        pdevm->yMax        = 0;
        pdevm->cxMax       = 0;
        pdevm->cyMax       = 0;
    }
    else // Otherwise, the max glyph size is cached in the FONTCONTEXT.
    {
        pdevm->cjGlyphMax  = pfc->cjGlyphMax;
        pdevm->xMin        = pfc->xMin;
        pdevm->xMax        = pfc->xMax;
        pdevm->yMin        = pfc->yMin;
        pdevm->yMax        = pfc->yMax;
        pdevm->cxMax       = pfc->cxMax;
        pdevm->cyMax       = pfc->cyMax;
    }

// we are outa here

    return sizeof(FD_DEVICEMETRICS);
}



/******************************Public*Routine******************************\
* ttfdQueryFontData
*
*   dhpdev      Not used.
*
*   pfo         Pointer to a FONTOBJ.
*
*   iMode       This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFD_GLYPH           -- return glyph metrics only
*
*       QFD_GLYPHANDBITMAP  -- return glyph metrics and bitmap
*
*       QFD_GLYPHANDOUTLINE -- return glyph metrics and outline
*
*       QFD_MAXEXTENTS      -- return FD_DEVICEMETRICS structure
*
*   pgd        Buffer to hold glyphdata structure, if any
*
*   pv         Output buffer to hold glyphbits or pathobj, if any.
*
* Returns:
*
*   Otherwise, returns the size of the glyphbits
*
*   FD_ERROR is returned if an error occurs.
*
* History:
*  31-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LONG ttfdQueryFontData (
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       subX,       // Fixed point for 16.16
    ULONG       subY        // Fixed point for 16.16
    )
{
extern LONG lGetSingularGlyphBitmap(FONTCONTEXT*, HGLYPH, GLYPHDATA*, PVOID);
extern STATIC LONG lQueryDEVICEMETRICS(FONTCONTEXT*, ULONG, FD_DEVICEMETRICS*);
extern LONG lGetGlyphBitmapErrRecover(FONTCONTEXT*, HGLYPH, GLYPHDATA*, PVOID);
extern LONG lGetGlyphBitmap(FONTCONTEXT*, HGLYPH, GLYPHDATA*, PVOID, FS_ENTRY*);
extern BOOL ttfdQueryGlyphOutline(FONTCONTEXT*, HGLYPH, GLYPHDATA*, PATHOBJ*);

// declare the locals

    PFONTCONTEXT pfc;
    USHORT usOverScale;
    LONG cj = 0, cjDataRet = 0;

// if this font file is gone we are not gonna be able to answer any questions
// about it

    ASSERTDD(pfo->iFile, "ttfdQueryFontData, pfo->iFile\n");

    if (((TTC_FONTFILE *)pfo->iFile)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
        //WARNING("ttfd, ttfdQueryFontData(): file is gone\n");
        return FD_ERROR;
    }

// If pfo->pvProducer is NULL, then we need to open a font context.

    if ( pfo->pvProducer == (PVOID) NULL )
    {
        pfo->pvProducer = pfc = ttfdOpenFontContext(pfo);
    }
    else
    {
        pfc = (FONTCONTEXT*) pfo->pvProducer;
        pfc->flFontType = (pfc->flFontType & FO_CHOSE_DEPTH) | pfo->flFontType;
    }

    if ( pfc == (FONTCONTEXT *) NULL )
    {
        //WARNING("gdisrv!ttfdQueryFontData(): cannot create font context\n");
        return FD_ERROR;
    }

    pfc->pfo = pfo;

    switch ( iMode )
    {
        case QFD_TT_GRAY1_BITMAP: // monochrome

            usOverScale = 0;  /// !!! 0 for monochrome
            break;

        case QFD_TT_GRAY2_BITMAP: // one byte per pixel: 0..4

            usOverScale = 2;
            break;

        case QFD_TT_GRAY4_BITMAP: // one byte per pixel: 0..16

            usOverScale = 4;
            break;

        case QFD_TT_GRAY8_BITMAP: // one byte per pixel: 0..64

            usOverScale = 8;
            break;
        case QFD_MAXEXTENTS:
            if (pfc->flFontType & FO_GRAYSCALE)
            {
                if (IS_CLEARTYPE(pfc))
                    usOverScale = 0;
                else
                    usOverScale = 4;
            }
            else
                usOverScale = 0;
            break;
        case QFD_CT:
        case QFD_CT_GRID:
        case QFD_GLYPHANDBITMAP:
        case QFD_GLYPHANDBITMAP_SUBPIXEL:
        default:
            usOverScale = 0;
            break;
    }

// call fs_NewTransformation if needed:
    {
        BOOL bBitmapEmboldening = FALSE;

        if ( (pfc->flFontType & FO_SIM_BOLD) &&
            (pfc->flXform & (XFORM_HORIZ | XFORM_VERT) )
            && (iMode != QFD_GLYPHANDOUTLINE)
            && !( pfc->flFontType & FO_SUBPIXEL_4) )
        {
            /* for backwards compatibility and to get better bitmaps at screen resolution, we are doing
               bitmap emboldening simulation (as opposed to outline emboldening simulation) if we are
               emboldening only by one pixel and we are under no rotation or 90 degree rotation and not doing subxixel positionning
               or asking for the bitmap */
            bBitmapEmboldening = TRUE;
        }

        if (!bGrabXform(pfc, usOverScale, bBitmapEmboldening, subX, subY))
        {
            RETURN("gdisrv!ttfd  bGrabXform failed\n", FD_ERROR);
        }
    }

    switch ( iMode )
    {
    case QFD_TT_GRAY1_BITMAP: // monochrome
    case QFD_TT_GRAY2_BITMAP: // one byte per pixel: 0..4
    case QFD_TT_GRAY4_BITMAP: // one byte per pixel: 0..16
    case QFD_TT_GRAY8_BITMAP: // one byte per pixel: 0..64
    case QFD_GLYPHANDBITMAP:
    case QFD_GLYPHANDBITMAP_SUBPIXEL:
    case QFD_TT_GLYPHANDBITMAP:
    case QFD_CT:
    case QFD_CT_GRID:
        {
        // Engine should not be querying on the HGLYPH_INVALID.

            ASSERTDD (
                hg != HGLYPH_INVALID,
                "ttfdQueryFontData(QFD_GLYPHANDBITMAP): HGLYPH_INVALID \n"
                );

        // If singular transform, the TrueType driver will provide a blank
        // 0x0 bitmap.  This is so device drivers will not have to implement
        // special case code to handle singular transforms.
        //
        // So depending on the transform type, choose a function to retrieve
        // bitmaps.

            if (pfc->flXform & XFORM_SINGULAR)
            {
                cj = lGetSingularGlyphBitmap(pfc, hg, pgd, pv);
            }
            else
            {
                FS_ENTRY iRet;

                cj = lGetGlyphBitmap(pfc, hg, pgd, pv, &iRet);

                if ((cj == FD_ERROR) && (iRet == POINT_MIGRATION_ERR))
                {
                // this is buggy glyph where hinting has so severly distorted
                // the glyph that one of the points went out of range.
                // We will just return a blank glyph but with correct
                // advance width

                    cj = lGetGlyphBitmapErrRecover(pfc, hg, pgd, pv);
                }
            }

        #if DBG
            if (cj == FD_ERROR)
            {
                //WARNING("ttfdQueryFontData(QFD_GLYPHANDBITMAP): get bitmap failed\n");
            }
        #endif
        }
        return cj;

    case QFD_GLYPHANDOUTLINE:

        ASSERTDD (
            hg != HGLYPH_INVALID,
            "ttfdQueryFontData(QFD_GLYPHANDOUTLINE): HGLYPH_INVALID \n"
            );

        if (!ttfdQueryGlyphOutline(pfc, hg, pgd, (PATHOBJ *) pv))
        {
            //WARNING("ttfdQueryFontData(QFD_GLYPHANDOUTLINE): failed to get outline\n");
            return FD_ERROR;
        }
        return sizeof(GLYPHDATA);

    case QFD_MAXEXTENTS:

        return lQueryDEVICEMETRICS(
                   pfc,
                   sizeof(FD_DEVICEMETRICS),
                   (FD_DEVICEMETRICS *) pv
                   );


    default:

        //WARNING("gdisrv!ttfdQueryFontData(): unsupported mode\n");
        return FD_ERROR;
    }
}

/******************************Public*Routine******************************\
*
* pvSetMemoryBases
*
* To release this memory simply do vFreeMemoryBases(&pv); where pv is
* returned from bSetMemoryBases in ppv
*
* Looks into memory request in fs_GlyphInfoType and allocates this memory
* , than it fills memoryBases in fs_GlyphInputType with pointers to the
* requested memory
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


void *pvSetMemoryBases(fs_GlyphInfoType *pgout,fs_GlyphInputType *pgin,int isGray)
{
    FS_MEMORY_SIZE adp[MEMORYFRAGMENTS];
    FS_MEMORY_SIZE cjTotal;
    INT i;
    PBYTE pjMem;

#define I_LO 5
#define I_HI 7

    cjTotal = 0;    // total memory to allocate for all fragments


// unroll the loop:

//     for (i = I_LO; i <= I_HI; i++)
//     {
//         adp[i] = cjTotal;
//         cjTotal += NATURAL_ALIGN(pgin->memorySizes[i]);
//     }

    adp[5] = cjTotal;
    cjTotal += NATURAL_ALIGN(pgout->memorySizes[5]);
    adp[6] = cjTotal;
    cjTotal += NATURAL_ALIGN(pgout->memorySizes[6]);
    adp[7] = cjTotal;
    cjTotal += NATURAL_ALIGN(pgout->memorySizes[7]);
    if (isGray)
    {
        adp[8] = cjTotal;
        cjTotal += NATURAL_ALIGN(pgout->memorySizes[8]);
    }


    if (cjTotal == 0)
    {
        cjTotal = 4;
    }

    if ((pjMem = (PBYTE)PV_ALLOC((ULONG)cjTotal)) == (PBYTE)NULL)
    {
        for (i = I_LO; i <= I_HI; i++)
            pgin->memoryBases[i] = (PBYTE)NULL;

        RETURN("TTFD!_bSetMemoryBases mem alloc failed\n",NULL);
    }

// unroll the loop:
// set the pointers

//    for (i = I_LO; i <= I_HI; i++)
//    {
//        if (pgin->memorySizes[i] != (FS_MEMORY_SIZE)0)
//        {
//            pgout->memoryBases[i] = pjMem + adp[i];
//        }
//        else
//        {
//        // if no mem was required set to NULL to prevent accidental use
//
//            pgout->memoryBases[i] = (PBYTE)NULL;
//        }
//    }

    if (pgout->memorySizes[5] != (FS_MEMORY_SIZE)0)
    {
        pgin->memoryBases[5] = pjMem + adp[5];
    }
    else
    {
        pgin->memoryBases[5] = (PBYTE)NULL;
    }

    if (pgout->memorySizes[6] != (FS_MEMORY_SIZE)0)
    {
        pgin->memoryBases[6] = pjMem + adp[6];
    }
    else
    {
        pgin->memoryBases[6] = (PBYTE)NULL;
    }

    if (pgout->memorySizes[7] != (FS_MEMORY_SIZE)0)
    {
        pgin->memoryBases[7] = pjMem + adp[7];
    }
    else
    {
        pgin->memoryBases[7] = (PBYTE)NULL;
    }
    if (isGray)
    {
        if (pgout->memorySizes[8] != (FS_MEMORY_SIZE)0)
        {
            pgin->memoryBases[8] = pjMem + adp[8];
        }
        else
        {
            pgin->memoryBases[8] = (PBYTE)NULL;
        }
    }

    return pjMem;
}

/******************************Public*Routine******************************\
* VOID vFreeMemoryBases()                                                  *
*                                                                          *
* Releases the memory allocated by bSetMemoryBases.                        *
*                                                                          *
* History:                                                                 *
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/

VOID vFreeMemoryBases(PVOID * ppv)
{
    if (*ppv != (PVOID) NULL)
    {
        V_FREE(*ppv);
        *ppv = (PVOID) NULL; // clean up the state and prevent accidental use
    }
}


typedef struct
{
  unsigned short  Version;
  unsigned short  cGlyphs;
  unsigned char   PelsHeight[1];
} LSTHHEADER;



/******************************Public*Routine******************************\
*
* BOOL bGetFastAdvanceWidth
*
*
* Effects: retrieves the same result as bQueryAdvanceWidth, except it
*          ignores adding 1 for EMBOLDENING and it does not do anything
*          for non horiz. xforms
*
* Warnings: !!! if a bug is found in bQueryAdvanceWidth this routine has to
*           !!! changed as well
*
* return a positive value that include the emboldening
*
* History:
*  25-Mar-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




BOOL bGetFastAdvanceWidth(
    FONTCONTEXT *pfc,
    ULONG        ig,    // glyph index
    FIX         *pfxD   // result in 28.4
    )
{
    HDMXTABLE   *phdmx = pfc->phdmx;
    sfnt_FontHeader        *phead;
    sfnt_HorizontalHeader  *phhea;
    sfnt_HorizontalMetrics *phmtx;
    LSTHHEADER             *plsth;
    ULONG  cHMTX;
    USHORT dxLastWidth;
    LONG   dx;
    BOOL   bRet;
    BOOL   bNonLinear = TRUE;
    BYTE  *pjView;
    Fixed   transform;

    ASSERTDD(pfc->flXform & (XFORM_HORIZ | XFORM_VERT), "bGetFastAdvanceWidth xform\n");

    if (phdmx != (HDMXTABLE *) NULL)
    {
        *pfxD = (((FIX) phdmx->aucInc[ig]) << 4);
        if ((pfc->flFontType & FO_SIM_BOLD) && (*pfxD != 0))
        {
            *pfxD += (1 << 4);
        }
        return(TRUE);
    }

// Otherwise, try to scale.  Pick up the tables.


    pjView = (BYTE *)pfc->pff->pvView;
    ASSERTDD(pjView, "pjView is NULL 1\n");

    phead = (sfnt_FontHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HEAD ].dp);
    phhea = (sfnt_HorizontalHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HHEAD].dp);
    phmtx = (sfnt_HorizontalMetrics *)(pjView + pfc->ptp->ateReq[IT_REQ_HMTX].dp);
    plsth = (LSTHHEADER *)(
              (pfc->ptp->ateOpt[IT_OPT_LSTH].dp && pfc->ptp->ateOpt[IT_OPT_LSTH].cj != 0) ?
              (pjView + pfc->ptp->ateOpt[IT_OPT_LSTH ].dp):
              NULL
              );

    cHMTX = (ULONG) BE_UINT16(&phhea->numberOf_LongHorMetrics);
    dxLastWidth = BE_UINT16(&phmtx[cHMTX-1].advanceWidth);

// See if there is cause for worry.

    if
    (
      (((BYTE *) &phead->flags)[1] & 0x14)==0 // Bits indicating nonlinearity.
    )
    {
        bNonLinear = FALSE; // we are linear regardless of the size
    }

    bRet = TRUE;

    if
    (
        bNonLinear &&
        ( (plsth == (LSTHHEADER *) NULL)
        || (pfc->lEmHtDev < plsth->PelsHeight[ig]) )
        )
    {
        *pfxD  = 0xFFFFFFFF;
        bRet = FALSE;
    }
    else
    {
    // OK, let's scale using the FIXED transform.

        if (ig < cHMTX)
            dx = (LONG) BE_UINT16(&phmtx[ig].advanceWidth);
        else
            dx = (LONG) dxLastWidth;

        if (pfc->flXform & XFORM_HORIZ )
        {
            transform = pfc->mx.transform[0][0];
        } else
        {
            transform = pfc->mx.transform[0][1];
        }

        if (transform < 0)
            transform = - transform;

        *pfxD = (FIX) (((transform * dx + 0x8000L) >> 12) & 0xFFFFFFF0);

        if ((pfc->flFontType & FO_SIM_BOLD) && (*pfxD != 0))
        {
            *pfxD += (1 << 4);
        }
    }
    return(bRet);
}


/******************************Public*Routine******************************\
*
*  vFillGLYPHDATA_ErrRecover
*
* Effects: error recovery routine, if rasterizer messed up just
*          provide linearly scaled values with blank bitmap.
*
* History:
*  24-Jun-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID vFillGLYPHDATA_ErrRecover(
    HGLYPH        hg,
    ULONG         ig,
    FONTCONTEXT  *pfc,
    GLYPHDATA    *pgldt    // OUT
    )
{

    extern VOID vGetNotionalGlyphMetrics(FONTCONTEXT*, ULONG, NOT_GM*);
    NOT_GM ngm;  // notional glyph data

    pgldt->gdf.pgb = NULL; // may get changed by the calling routine if bits requested too
    pgldt->hg = hg;

// this is a blank 0x0 bitmap, no ink

    pgldt->rclInk.left   = 0;
    pgldt->rclInk.top    = 0;
    pgldt->rclInk.right  = 0;
    pgldt->rclInk.bottom = 0;
    pgldt->VerticalOrigin_X = 0;
    pgldt->VerticalOrigin_Y = 0;


// go on to compute the positioning info:

    vGetNotionalGlyphMetrics(pfc,ig,&ngm);

    if (pfc->flXform & XFORM_HORIZ)  // scaling only
    {
        Fixed fxMxx =  pfc->mx.transform[0][0];
        if (fxMxx < 0)
            fxMxx = -fxMxx;

    // bGetFastAdvanceWidth returns the same aw that would get
    // computed by bQueryAdvanceWidths and propagated to an api
    // level through GetTextExtent and GetCharWidths. We have to
    // fill in the same aw for consistency reasons.
    // This also has to be done for win31 compatibility.

        if (!bGetFastAdvanceWidth(pfc,ig, &pgldt->fxD))
        {
        // just provide something reasonable, force linear scaling
        // even if we would not normally do it.

            pgldt->fxD = FixMul(ngm.sD,pfc->mx.transform[0][0]) << 4;
        }

        if (pfc->mx.transform[0][0] < 0)
            pgldt->fxD = - pgldt->fxD;  // this is an absolute value

        pgldt->fxA   = FixMul(fxMxx, (LONG)ngm.sA) << 4;
        pgldt->fxAB  = FixMul(fxMxx, (LONG)ngm.xMax) << 4;

    }
    else // non trivial information
    {
    // here we will just xform the notional space data:

    // xforms are computed by simple multiplication

        pgldt->fxD         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sD);
        pgldt->fxA         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sA);
        pgldt->fxAB        = fxLTimesEf(&pfc->efBase, (LONG)ngm.xMax);

        pgldt->fxD_Sideways  = fxLTimesEf(&pfc->efSide, (LONG)ngm.sD_Sideways);
        pgldt->fxA_Sideways  = fxLTimesEf(&pfc->efSide, (LONG)ngm.sA_Sideways);
        pgldt->fxAB_Sideways = pgldt->fxA_Sideways + fxLTimesEf(&pfc->efSide, (LONG)ngm.yMax - (LONG)ngm.yMin);
    }

// finally check if the glyphdata will need to get modified because of the
// emboldening simulation:

    if (pfc->flFontType & FO_SIM_BOLD)
    {
        if (pgldt->fxD != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
                pgldt->fxD += LTOFX(1);  // this is the absolute value by def

    }
}



/******************************Public*Routine******************************\
*
* LONG lGetGlyphBitmapErrRecover
*
* Effects: error recovery routine, if rasterizer messed up just
*          provide linearly scaled values with blank bitmap.
*
* History:
*  Thu 24-Jun-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lGetGlyphBitmapErrRecover (
    FONTCONTEXT *pfc,
    HGLYPH       hglyph,
    GLYPHDATA   *pgd,
    PVOID        pv
    )
{
    LONG         cjGlyphData;
    GLYPHDATA    gd;      // Scummy hack
    FS_ENTRY     iRet;
    ULONG        ig; // <--> hglyph


    ASSERTDD(hglyph != HGLYPH_INVALID, "lGetGlyphBitmap, hglyph == -1\n");
    ASSERTDD(pfc == pfc->pff->pfcLast, "pfc! = pfcLast\n");

    ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
    cjGlyphData = CJGD(0,0,pfc);

    if ( (pgd == NULL) && (pv == NULL))
        return cjGlyphData;

// at this time we know that the caller wants the whole GLYPHDATA with
// bitmap bits, or maybe just the glypdata without the bits.

    if ( pgd == NULL )
    {
        pgd = &gd;
    }

// compute the glyph index from the character code:

    vCharacterCode(pfc->pff,hglyph,pfc->pgin);

    if ((iRet = fs_NewGlyph(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);
        return FD_ERROR; // even backup funcion can fail
    }

// return the glyph index corresponding to this hglyph:

    ig = pfc->pgout->glyphIndex;

    vFillGLYPHDATA_ErrRecover(
        hglyph,
        ig,
        pfc,
        pgd
        );

// the caller wants the bits too

    if ( pv != NULL )
    {
        GLYPHBITS *pgb = (GLYPHBITS *)pv;

        // return blank 0x0 bitmap

        pgb->ptlUprightOrigin.x = 0;
        pgb->ptlUprightOrigin.y = 0;

        pgb->ptlSidewaysOrigin.x = 0;
        pgb->ptlSidewaysOrigin.y = 0;

        pgb->sizlBitmap.cx = 0;
        pgb->sizlBitmap.cy = 0;

        pgd->gdf.pgb = pgb;
    }

    return(cjGlyphData);
}


#if(WINVER < 0x0400)

typedef struct tagFONTSIGNATURE
{
    DWORD fsUsb[4];
    DWORD fsCsb[2];
} FONTSIGNATURE, *PFONTSIGNATURE,FAR *LPFONTSIGNATURE;
#endif
/******************************Public*Routine******************************\
*
* VOID vGetFontSignature(HFF hff, FONTSIGNATURE *pfs);
*
*
* Effects: If font file contains the font signature,
*          it copies the data out, else computes it using win95 mechanism.
*
* History:
*  10-Jan-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vGetFontSignature(FONTFILE *pff, FONTSIGNATURE *pfs)
{
    pff;
    pfs;
}

/******************************Public*Routine******************************\
*
* DWORD ttfdQueryLpkInfo
*
*
* Effects: returns per font information needed to support various new
*          multilingual api's invented by DavidMS from Chicago team
*
* History:
*  10-Jan-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

// called by GetFontLanguageInfo

#define LPK_GCP_FLAGS       1
#define LPK_FONTSIGNATURE   2

DWORD ttfdQueryLpkInfo(
    FONTFILE  *pff,
    ULONG      ulFont,
    ULONG      ulMode,
    ULONG      cj,
    BYTE      *pj
    )
{
    FONTSIGNATURE *pfs = (FONTSIGNATURE *)pj;

    switch (ulMode)
    {
    default:
    case LPK_GCP_FLAGS:
        return 0;
    case LPK_FONTSIGNATURE:
        if (pj)
        {
            vGetFontSignature(pff, pfs);
            return sizeof(FONTSIGNATURE);
        }
        else
        {
            return 0;
        }

    }
}

#if DBG
/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpGrayGLYPHBITS
*
* Routine Description:
*
*   Dumps a 4bpp gray glyph bitmap to the debugging screen
*
* Arguments:
*
*   pgb -- pointer to a gray GLYPHBITS structure
*
* Return Value:
*
*   None.
*
\**************************************************************************/

void vDumpGrayGLYPHBITS(GLYPHBITS *pgb)
{
    #define CH_TOP_LEFT_CORNER '\xDA'
    #define CH_HORIZONTAL_BAR  '\xC4'
    #define CH_VERTICAL_BAR    '\xB3'
    #define CH_PIXEL_ON        '\x02'
    #define CH_PIXEL_OFF       '\xFA'

    BYTE *pj8, *pj, *pjNext, *pjEnd;
    int cjScan, i, k, c8, c4, cj;
    static const char achGray[16] = {
        CH_PIXEL_OFF,
        '1','2','3','4','5','6','7','8','9','a','b','c','d','e',
        CH_PIXEL_ON
    };

    TtfdDbgPrint(
        "\n\n"
        "ptlOrigin  = (%d,%d)\n"
        "sizlBitmap = (%d,%d)\n"
        "\n\n"
        , pgb->ptlUprightOrigin.x
        , pgb->ptlUprightOrigin.y
        , pgb->sizlBitmap.cx
        , pgb->sizlBitmap.cy
    );
    cjScan = (pgb->sizlBitmap.cx + 1)/2;
    cj = cjScan * pgb->sizlBitmap.cy;
    TtfdDbgPrint("\n\n  ");
    for (i = 0, k = 0; i < pgb->sizlBitmap.cx; i++, k++)
    {
        k = (k > 9) ? 0 : k;
        TtfdDbgPrint("%1d", k);
    }
    TtfdDbgPrint("\n %c",CH_TOP_LEFT_CORNER);
    for (i = 0; i < pgb->sizlBitmap.cx; i++)
    {
        TtfdDbgPrint("%c",CH_HORIZONTAL_BAR);
    }
    TtfdDbgPrint("\n");
    c8 = pgb->sizlBitmap.cx / 2;
    c4 = pgb->sizlBitmap.cx % 2;
    for (
        pj = pgb->aj, pjNext=pj+cjScan , pjEnd=pjNext+cj, k=0
        ; pjNext < pjEnd
        ; pj=pjNext , pjNext+=cjScan, k++
    )
    {
        k = (k > 9) ? 0 : k;
        TtfdDbgPrint("%1d%c",k,CH_VERTICAL_BAR);
        for (pj8 = pj+c8 ; pj < pj8; pj++)
        {
            TtfdDbgPrint("%c%c", achGray[*pj>>4], achGray[*pj & 0xf]);
        }
        if (c4)
        {
            TtfdDbgPrint("%c%c", achGray[*pj>>4], achGray[*pj & 0xf]);
        }
        TtfdDbgPrint("\n");
    }
}
#endif


/******************************Public*Routine******************************\
* vGCGB
*
* Called by: vCopyGrayBits, vMakeAFixedPitchGrayBitmap
*
* void General Copy Gray Bits
*
* History:
*  Wed 22-Feb-1995 13:14:36 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

VOID vGCGB(
    FONTCONTEXT *pfc,   // pointer to the FONTCONTEXT this is used
                        // to determine if the font is bold simulated
    GLYPHBITS   *pgb,   // pointer to destination GRAY GLYPHBITS structure
                        // In the case where dY is zero, all the fields
                        // of the GLYPHBITS structure must be filled
                        // this includes sizlBitmap and the bits; in
                        // the case where dY is non-zero, the
                        // sizlBitmap components are precomputed and
                        // must not be touched.
    BYTE        *pjSrc, // pointer to TT gray scale bitmap
                        // This is 8-bit per pixel bitmap whose scans
                        // are aligned on 4-byte multiples. The values
                        // stored in the bitmaps are in the range
                        // 0-16. In order to fit 17 levels in the 4 bit
                        // per pixel destination we reduce the level
                        // value by 1, except for zero which is left alone.
    GMC         *pgmc,  // pointer to the glyph-metric-correction structure
                        // which has information on how to "shave" the
                        // bitmap so that it does not get above a guaranteed
                        // value
    LONG dY             // vertical offset into destination bitmap used
                        // for "special fixed pitch fonts" like Lucida
                        // Console.
    )
{
    unsigned cxDst;     // width of destination bitmap
    unsigned cjSrcScan; // count of bytes in a source scan including
                        // padding out to nearest 4-byte multiple boundary
    unsigned cjDstScan; // count of bytes in a desintation scan including
                        // padding out to nearest byte boundary

    BYTE   *pjDst, *pjSrcScan, *pjDstScan, *pjDstScanEnd;

    static const BYTE ajGray[17] = {0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};


    ASSERTDD(
        pfc->flFontType & FO_CHOSE_DEPTH
       ,"We haven't decided about pixel depth\n"
    );
    ASSERTDD(pgmc->cxCor < LONG_MAX && pgmc->cyCor < LONG_MAX
     , "vCopyGrayBits -- bad gmc\n"
    );

    cjSrcScan = CJ_TT_SCAN(pgmc->cxCor,pfc);

    cxDst = pgmc->cxCor;

    cjDstScan = CJ_4BIT_SCAN(cxDst);

    pjSrcScan = pjSrc;
    pjDstScan = pgb->aj;

    // destination correction for special fixed pitch fonts

    if (dY)
    {
        // Console font
        // the size of the bitmap has been established already
        pjDstScan += dY * cjDstScan;
    }
    else
    {
        // Extended with Embold
        pgb->sizlBitmap.cx = cxDst;
        pgb->sizlBitmap.cy = pgmc->cyCor;
    }
    pjDstScanEnd = pjDstScan + pgmc->cyCor * cjDstScan;

    for (
        ; pjDstScan < pjDstScanEnd                  // whole byte loop
        ; pjDstScan += cjDstScan, pjSrcScan += cjSrcScan)
    {
        for (
            pjSrc = pjSrcScan, pjDst = pjDstScan
          ; pjDst < pjDstScan + (pgmc->cxCor  / 2)
          ; pjDst += 1
        )
        {
            *pjDst  = 16*ajGray[*pjSrc++];  // set high nyble
            *pjDst += ajGray[*pjSrc++];     // set low nyble
        }

        // The dxAbsBold has been enhanced >= 1

        if (pgmc->cxCor & 1)                // one more pixel in source?
        {                                   // yes
            *pjDst++  = 16*ajGray[*pjSrc];    // set high nyble
        }                                   // low nyble is cleared

        while ( pjDst < (pjDstScan + cjDstScan) )    // embodening is taken care of
            *pjDst++ = 0;                           // emboldened?
                                                    // yes; clear last byte
                                                    //
   }

}

VOID
vCopy4BitsPerPixel(
    FONTCONTEXT *pfc
  , GLYPHBITS *pgb
  , BYTE *pjSrc
  , GMC *pgmc
)
{
    vGCGB(pfc, pgb, pjSrc, pgmc, 0);
}

VOID vCopy8BitsPerPixel(
    FONTCONTEXT *pfc,
    GLYPHBITS   *pgb,
    BYTE        *pjSrc,
    GMC         *pgmc
)
{
    unsigned cjSrcScan; // count of bytes in a source scan including
                        // padding out to nearest 4-byte multiple boundary
    unsigned cjDstScan; // count of bytes in a desintation scan including
                        // padding out to nearest byte boundary

    BYTE   *pjDst, *pjSrcScan, *pjDstScan, *pjDstScanEnd;

    cjSrcScan = CJ_TT_SCAN(pgmc->cxCor,pfc);
    cjDstScan = CJ_8BIT_SCAN(pgmc->cxCor);  // should be the same as cxCor

    pjSrcScan = pjSrc;
    pjDstScan = pgb->aj;

    pgb->sizlBitmap.cx = pgmc->cxCor;
    pgb->sizlBitmap.cy = pgmc->cyCor;

    pjDstScanEnd = pjDstScan + pgmc->cyCor * cjDstScan;

    for ( ; pjDstScan < pjDstScanEnd ; pjDstScan += cjDstScan, pjSrcScan += cjSrcScan)
    {
        for
        (
          pjSrc = pjSrcScan, pjDst = pjDstScan;
          pjDst < (pjDstScan + pgmc->cxCor);
          pjDst++, pjSrc++
        )
        {
            if (*pjSrc)
                *pjDst  = *pjSrc - 1;
            else
                *pjDst = 0;
        }
    }
}

VOID vCopyClearTypeBits(
    FONTCONTEXT *pfc,   // pointer to the FONTCONTEXT this is used
                        // to determine if the font is bold simulated
    GLYPHBITS   *pgb,   // pointer to destination CLEARTYPE GLYPHBITS structure
                        // All the fields
                        // of the GLYPHBITS structure must be filled
                        // this includes sizlBitmap and the bits;
                        // The sizlBitmap components are precomputed and
                        // must not be touched.
    BYTE        *pjSrc, // pointer to TT ClearType bitmap
                        // This is 8-bit per pixel bitmap whose scans
                        // are aligned on 4-byte multiples. The values
                        // stored in the bitmaps are in the range
                        // 0-252.
    GMC         *pgmc   // pointer to the glyph-metric-correction structure
                        // which has information on how to "shave" the
                        // bitmap so that it does not get above a guaranteed
                        // value
    )
{
    unsigned cjSrcScan; // count of bytes in a source scan including
                        // padding out to nearest 4-byte multiple boundary
    unsigned cjDstScan; // count of bytes in a desintation scan including
                        // padding out to nearest byte boundary

    BYTE   *pjDst, *pjSrcScan, *pjDstScan, *pjDstScanEnd;

    cjSrcScan = CJ_TT_SCAN(pgmc->cxCor,pfc);
    cjDstScan = CJ_8BIT_SCAN(pgmc->cxCor);  // should be the same as cxCor

    pjSrcScan = pjSrc;
    pjDstScan = pgb->aj;

    pgb->sizlBitmap.cx = pgmc->cxCor;
    pgb->sizlBitmap.cy = pgmc->cyCor;

    pjDstScanEnd = pjDstScan + pgmc->cyCor * cjDstScan;

    for ( ; pjDstScan < pjDstScanEnd ; pjDstScan += cjDstScan, pjSrcScan += cjSrcScan)
    {
        for
        (
          pjSrc = pjSrcScan, pjDst = pjDstScan;
          pjDst < (pjDstScan + pgmc->cxCor);
          pjDst++, pjSrc++
        )
        {
            *pjDst  = *pjSrc;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\fd.h ===
/******************************Module*Header*******************************\
* Module Name: fd.h
*
* file which is going to be included by the most *.c files in this directory.
* Supplies basic types, debugging stuff, error logging and checking stuff,
* error codes, usefull macros etc.
*
* Created: 22-Oct-1990 15:23:44
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/


#define  IFI_PRIVATE

#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <excpt.h>
#include <windef.h>
#include <wingdi.h>
#include "fontddi.h"   // modified subset of winddi.h

typedef ULONG W32PID;

#include "mapfile.h"

#include "service.h"     // string service routines
#include "tt.h"          // interface to the font scaler
//#include "common.h"

#include "fontfile.h"
#include "cvt.h"
#include "dbg.h"
#include "..\..\..\runtime\debug.h"

#define RETURN(x,y)   {WARNING((x)); return(y);}
#define RET_FALSE(x)  {WARNING((x)); return(FALSE);}

#define ALIGN4(X) (((X) + 3) & ~3)

#if defined(_AMD64_) || defined(_IA64_)

#define  vLToE(pe,l)           (*(pe) = (FLOATL)(l))

#else   // i386

ULONG  ulLToE (LONG l);
VOID   vLToE(FLOATL * pe, LONG l);

#endif

#define STATIC
#define DWORD_ALIGN(x) (((x) + 3L) & ~3L)
#define QWORD_ALIGN(x) (((x) + 7L) & ~7L)

#if defined(i386)
// natural alignment for x86 is on 32 bit boundary

#define NATURAL           DWORD
#define NATURAL_ALIGN(x)  DWORD_ALIGN(x)

#else
// for mips and alpha we want 64 bit alignment

#define NATURAL           DWORDLONG
#define NATURAL_ALIGN(x)  QWORD_ALIGN(x)

#endif

#define ULONG_SIZE(x)  (((x) + sizeof(ULONG) - 1) / sizeof(ULONG))


// MACROS FOR converting 16.16 BIT fixed numbers to LONG's


#define F16_16TOL(fx)            ((fx) >> 16)
#define F16_16TOLFLOOR(fx)       F16_16TOL(fx)
#define F16_16TOLCEILING(fx)     F16_16TOL((fx) + (Fixed)0x0000FFFF)
#define F16_16TOLROUND(fx)       ((((fx) >> 15) + 1) >> 1)


// MACROS FOR GOING THE OTHER WAY ARROUND

#define LTOF16_16(l)   (((LONG)(l)) << 16)
#define BLTOF16_16OK(l)  (((l) < 0x00007fff) && ((l) > -0x00007fff))

// 16.16 --> 28.4

#define F16_16TO28_4(X)   ((X) >> 12)

// going back is not always legal

#define F28_4TO16_16(X)   ((X) << 12)
#define B28_4TO16_16OK(X) (((X) < 0x0007ffff) && ((X) > -0x0007ffff))

// 26.6 --> 16.16, never go the other way

#define F26_6TO16_16(X)   ((X) << 10)
#define B26_6TO16_16OK(X) (((X) < 0x003fffff) && ((X) > -0x003fffff))

#define F26_6TO28_4(X)   ((X) >> 2)

// sin of 20 degrees in 16.16 notation, however computed only with
// 8.8 presission to be fully win31 compatible, SEE gdifeng.inc, SIM_ITALIC
// SIM_ITALIC equ 57h

#define FX_SIN20 0x5700
#define FX_COS20 0xF08F

// CARET_Y/CARET_X = tan 12
// these are the values for arial italic from hhead table

#define CARET_X  0X07
#define CARET_Y  0X21


#if DBG
VOID vFSError(FS_ENTRY iRet);
#define V_FSERROR(iRet) vFSError((iRet))
#else
#define V_FSERROR(iRet)
#endif


BOOL
ttfdUnloadFontFile (
    HFF hff
    );

BOOL
ttfdUnloadFontFileTTC (
    HFF hff
    );

LONG
ttfdQueryFontData (
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       subX,
    ULONG       subY
    );

VOID
ttfdDestroyFont (
    FONTOBJ *pfo
    );

LONG
ttfdQueryTrueTypeTable (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifyint the tt table
    PTRDIFF dpStart, // offset into the table
    ULONG   cjBuf,   // size of the buffer to retrieve the table into
    PBYTE   pjBuf,   // ptr to buffer into which to return the data
    PBYTE  *ppjTable,// ptr to table in otf file
    ULONG  *cjTable  // size of table
    );


LONG
ttfdQueryTrueTypeOutline (
    FONTOBJ   *pfo,
    HGLYPH     hglyph,         // glyph for which info is wanted
    BOOL       bMetricsOnly,   // only metrics is wanted, not the outline
    GLYPHDATA *pgldt,          // this is where the metrics should be returned
    ULONG      cjBuf,          // size in bytes of the ppoly buffer
    TTPOLYGONHEADER *ppoly
    );


BOOL bLoadFontFile (
    ULONG_PTR iFile,
    PVOID pvView,
    ULONG cjView,
    ULONG ulLangId,
    HFF   *phttc
    );

typedef struct _NOT_GM  // ngm, notional glyph metrics
{
    SHORT xMin;
    SHORT xMax;
    SHORT yMin;   // char box in notional
    SHORT yMax;
    SHORT sA;     // a space in notional
    SHORT sD;     // char inc in notional
    SHORT sA_Sideways;     // a space in notional, for sideways characters in vertical writing
    SHORT sD_Sideways;     // char inc in notional, for sideways characters in vertical writing

} NOT_GM, *PNOT_GM;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\fdfc.c ===
/******************************Module*Header*******************************\
* Module Name: fdfc.c                                                      *
*                                                                          *
* Open,Close,Reset Font Context                                            *
*                                                                          *
* Created: 18-Nov-1991 11:55:38                                            *
* Author: Bodin Dresevic [BodinD]                                          *
*                                                                          *
* Copyright (c) 1993 Microsoft Corporation                                 *
\**************************************************************************/


#include "fd.h"
//#include "winfont.h"

extern INT UnicodeStringCompareCI(const WCHAR* str1, const WCHAR* str2);

BOOL bSetXform
(
    PFONTCONTEXT    pfc,             // OUT
    BOOL            bBitmapEmboldening,
    Fixed           subPosX,
    Fixed           subPosY
);

STATIC BOOL bNewXform
(
    FONTOBJ      *pfo,            // IN
    PFONTCONTEXT  pfc             // OUT
);

STATIC BOOL bComputeMaxGlyph(PFONTCONTEXT pfc);

#define CVT_TRUNCATE  0x00000001
#define CVT_TO_FIX    0X00000002

STATIC BOOL bFloatToL(FLOATL e, PLONG pl);
STATIC Fixed fxPtSize(PFONTCONTEXT pfc);
STATIC BOOL ttfdCloseFontContext(FONTCONTEXT *pfc);
STATIC VOID vFindHdmxTable(PFONTCONTEXT pfc);
STATIC ULONG iHipot(LONG x, LONG y);
LONG lFFF(LONG l);


#define FFF(e,l) *(LONG*)(&(e)) = lFFF(l)

#define MAX_BOLD 56

/******************************Public*Routine******************************\
*
* PVOID Pv_Realloc
*
*
* History:
*  10-14-1997 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/
PVOID   Pv_Realloc(PVOID pv, LONG newSize, LONG oldSize)
{
// This function will only used by
// fst_CallBackFSTraceFunction() for robust rasterizer
// There is an assumption, the input parameter will be
// alwys correct and there is no need to do value checking.
// If other function need to use it, please be aware of that.
    PVOID   pvNew;

    ASSERTDD(newSize > oldSize, "Pv_Realloc wrong input parameters \n");

    pvNew = PV_ALLOC(newSize);

    if (pvNew == NULL)
    {
        V_FREE(pv);
        return NULL;
    }

    RtlCopyMemory(pvNew, pv, oldSize);
    V_FREE(pv);

    return pvNew;
}

/******************************Public*Routine******************************\
*
* BOOL bInitInAndOut
*
*
* History:
*  18-Nov-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL bInitInAndOut(FONTFILE *pff)
{
    FS_ENTRY           iRet;
    fs_GlyphInputType *pgin;
    fs_GlyphInfoType  *pgout;

    ASSERTDD(pff->pj034 != NULL, "pff->pj3 IS null\n");

    pgin  = (fs_GlyphInputType *)pff->pj034;
    pgout = (fs_GlyphInfoType  *)(pff->pj034 + CJ_IN);

    if ((iRet = fs_OpenFonts(pgin, pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);
        return (FALSE);
    }

    pgin->memoryBases[0] = (char *)(pff->pj034 + CJ_IN + CJ_OUT);
    pgin->memoryBases[1] = NULL;
    pgin->memoryBases[2] = NULL;

// initialize the font scaler, notice no fields of pfc->gin are initialized [BodinD]

    if ((iRet = fs_Initialize(pgin, pgout)) != NO_ERR)
    {
    // clean up and return:

        V_FSERROR(iRet);
    RET_FALSE("TTFD!_ttfdLoadFontFile(): fs_Initialize \n");
    }

// initialize info needed by NewSfnt function

    pgin->sfntDirectory  = (int32 *)pff->pvView; // pointer to the top of the view of the ttf file

    pgin->clientID = (ULONG_PTR)pff; // pointer to FONTFILE.

    pgin->GetSfntFragmentPtr = pvGetPointerCallback;
    pgin->ReleaseSfntFrag  = vReleasePointerCallback;

    pgin->param.newsfnt.platformID = BE_UINT16(&pff->ffca.ui16PlatformID);
    pgin->param.newsfnt.specificID = BE_UINT16(&pff->ffca.ui16SpecificID);

    if ((iRet = fs_NewSfnt(pgin, pgout)) != NO_ERR)
    {
    // clean up and exit

        V_FSERROR(iRet);
        RET_FALSE("TTFD!_ttfdLoadFontFile(): fs_NewSfnt \n");
    }

// sizes 3 and 4 returned

    ASSERTDD(pff->ffca.cj3 == (ULONG)NATURAL_ALIGN(pgout->memorySizes[3]), "cj3\n");
    ASSERTDD(pff->ffca.cj4 == (ULONG)NATURAL_ALIGN(pgout->memorySizes[4]), "cj4\n");

// pj3 should  be shareable, but unfortunately there are fonts that
// use it to store some info there which they expect to find there at
// later times, so we have to make pj3 private as well

    pgin->memoryBases[3] = pff->pj034 + (CJ_IN + CJ_OUT + CJ_0);

// not shared, private

    pgin->memoryBases[4] = pgin->memoryBases[3] + pff->ffca.cj3;

    return TRUE;
}


#define LGINT_TO_LL(X)                                       \
((LONGLONG)(((LONGLONG)((X).HighPart) << 32) | (LONGLONG)((X).LowPart)))


VOID vLONG_X_POINTQF(LONG lIn, POINTQF *ptqIn, POINTQF *ptqOut)
{
    LONGLONG dx, dy;

    dx = LGINT_TO_LL(ptqIn->x);
    dy = LGINT_TO_LL(ptqIn->y);

    dx *= lIn;
    dy *= lIn;

    ptqOut->x = *((LARGE_INTEGER*)(&dx));
    ptqOut->y = *((LARGE_INTEGER*)(&dy));
}




/******************************Public*Routine******************************\
*
* void vCalcEmboldSize
*
* We only support embold enhancemet in FE font.
* The basic rule is 2% extended from normal font.
*
* History:
*  14-May-1997 -by- Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/


void vCalcEmboldSize(FONTCONTEXT * pfc)
{
    USHORT dDesc;

// we always shift glyphs in the direction of baseline and then in
// the direction opposite from ascender direction.
// That is the full shift vector is
//
// we shall use the win95-J compatible algorithm where
// we will shift bitmpas (((2%+1) right X 2% down)) algorithm
//
// The following computation was adapted to get the same cutoff than Win'98 between 50 and 51 ppem
// for an emboldening factor of 2%

    dDesc = (USHORT)((pfc->lEmHtDev * 2 - 1) / 100);

// dBase is always at least 1, we do not compute it based on width

    pfc->dBase = dDesc + 1;

}


/******************************Public*Routine******************************\
* ttfdOpenFontContext                                                      *
*                                                                          *
* History:                                                                 *
*  11-Nov-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/


FONTCONTEXT *ttfdOpenFontContextInternal(FONTOBJ *pfo)
{
    PFONTCONTEXT  pfc   = PFC(NULL);
    PTTC_FONTFILE pttc  = (PTTC_FONTFILE)pfo->iFile;
    ULONG         iFace = pfo->iFace;
    ULONG_PTR     iFile;
    PFONTFILE     pff;

    if (!pttc)
        return((FONTCONTEXT *) NULL);

    ASSERTDD(
        iFace <= pttc->ulNumEntry,
        "gdisrv!ttfdOpenFontContextTTC(): ulFont out of range\n"
        );

    iFile = PFF(pttc->ahffEntry[0].hff)->iFile;

    if (pttc->cRef == 0)
    {
    // have to remap the file

        if
        (
            !EngMapFontFileFD(
                iFile,
                (PULONG*)&pttc->pvView,
                &pttc->cjView
                )
        )
        {
            RETURN("TTFD!_bMapTTF, somebody removed a ttf file\n",NULL);
        }
    }

    // Get FONTFILE structure.

    pff = PFF(pttc->ahffEntry[iFace-1].hff);

    if (pff->cRef == 0)
    {
    // Update FILEVIEW structure in FONTFILE

        pttc->pvView = ((FONTFILEVIEW *)iFile)->pvView;
        pttc->cjView = ((FONTFILEVIEW *)iFile)->cjView;

        pff->pvView = pttc->pvView;
        pff->cjView = pttc->cjView;

    // We have precomputed all sizes and we are allocating all memory at once:

        ASSERTDD(pff->pj034 == NULL, "TTFD, pff->pj034 should be null\n");

        if
        (
            !(pff->pj034 = (PBYTE)PV_ALLOC(
                                    CJ_IN    +
                                    CJ_OUT   +
                                    CJ_0     +
                                    pff->ffca.cj3 +
                                    pff->ffca.cj4
                                    ))
        )
        {
            if(pttc->cRef == 0)
                EngUnmapFontFileFD(iFile);
            RETURN("ttfd, MEM Alloc  failed for pj034\n", NULL);
        }

        if (!bInitInAndOut(pff)) // could cause the exception
        {
            if(pttc->cRef == 0)
                EngUnmapFontFileFD(iFile);
            V_FREE(pff->pj034);
            pff->pj034 = (BYTE *)NULL;
            RETURN("ttfd, bInitInAndOut failed for \n", NULL);
        }

    }

// allocate memory for the font context and get the pointer to font context

    ASSERTDD(!pff->pfcToBeFreed, "TTFD!ttfdOpenFontContext, pfcToBeFreed NOT null\n");

    if ((pff->pfcToBeFreed = pfc = pfcAlloc(sizeof(FONTCONTEXT))) ==
        (FONTCONTEXT *) NULL )
    {
        //WARNING("TTFD!_ttfdOpenFontContext, hfcAlloc failed\n");
        if (pttc->cRef == 0)
            EngUnmapFontFileFD(iFile);
        if (pff->cRef == 0)
        {
            V_FREE(pff->pj034);
            pff->pj034 = (BYTE *)NULL;
        }
        return((FONTCONTEXT *) NULL);
    }

// state that the hff passed to this function is the FF selected in
// this font context

    pfc->pfo = pfo;
    pfc->pff = pff;
    pfc->ptp = &pff->ffca.tp;

// parts of FONTOBJ that are important

    pfc->flFontType   = pfo->flFontType  ;
    pfc->sizLogResPpi = pfo->sizLogResPpi;
    pfc->ulStyleSize  = pfo->ulPointSize ;

// tt strucs

    pfc->pgin  = (fs_GlyphInputType *) pfc->pff->pj034;
    pfc->pgout = (fs_GlyphInfoType  *) (pfc->pff->pj034 + CJ_IN);


// given the values in the context info store the transform matrix:



    if (!bNewXform(pfo,pfc))
    {
    // clean up and exit

        //WARNING("TTFD!_ttfdOpenFontContext, bNewXform\n");

        vFreeFC(pfc);
        pff->pfcToBeFreed = NULL;

        if (pttc->cRef == 0)
            EngUnmapFontFileFD(iFile);
        if (pff->cRef == 0)
        {
            V_FREE(pff->pj034);
            pff->pj034 = (BYTE *)NULL;
        }
        return((FONTCONTEXT *) NULL);
    }


// setting up of the overScale to a default value

    pfc->overScale = FF_UNDEFINED_OVERSCALE;

// increase the reference count of the font file, WE DO THIS ONLY WHEN
// WE ARE SURE that can not fail any more
// we have pfc, no exceptions any more

// now that we have pfc, we do not want to delete it

    pff->pfcToBeFreed = NULL;

    (pff->cRef)++;
    (pttc->cRef)++;

    return(pfc);
}

/**************************Public*Routine****************************\
* ttfdOpenFontContext                                                *
*                                                                    *
* History:                                                           *
*  07-Jan-1999 -by- Xudong Wu [tessiew]                              *
* Wrote it.                                                          *
\********************************************************************/
FONTCONTEXT *ttfdOpenFontContext(FONTOBJ *pfo)
{
    FONTCONTEXT *pfc;

    VOID vMarkFontGone(TTC_FONTFILE*, DWORD);
    DWORD iExcCode;
    TTC_FONTFILE *pttc = (TTC_FONTFILE *)pfo->iFile;

    try
    {
        pfc = ttfdOpenFontContextInternal(pfo);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        //WARNING("TTFD!_ exception in ttfdOpenFontContext\n");

        vMarkFontGone(pttc, iExcCode = GetExceptionCode());
        if (pttc && (pttc->cRef == 0) && (iExcCode == STATUS_IN_PAGE_ERROR))
        {
            EngUnmapFontFileFD(PFF(pttc->ahffEntry[0].hff)->iFile);
        }
        pfc = NULL;
    }

    return pfc;
}

/******************************Public*Routine******************************\
*
* ttfdCloseFontContext
*
*
* Effects:
*
*
* History:
*  11-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
ttfdCloseFontContext (
    FONTCONTEXT *pfc
    )
{
    PTTC_FONTFILE pttc;
    PFONTFILE     pff;

    if (pfc == (FONTCONTEXT *) NULL)
        return(FALSE);

    pff  = pfc->pff;
    pttc = pfc->pff->pttc;

// decrement the reference count for the corresponding FONTFILE

    ASSERTDD(pff->cRef > 0L, "TTFD!_CloseFontContext: cRef <= 0 \n");

    pff->cRef--;
    pttc->cRef--;

// if this was the last fc that last used the buffer at pj3, invalidate
// the associated pfcLast

    if (pff->pfcLast == pfc)
        pff->pfcLast = PFC(NULL);

// in case that this is happening after the exception, make sure to release
// any memory that may have possibly been allocated to perform queries
// on per character basis:

    if (pttc->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
    // if exception this memory has already been freed

        ASSERTDD(!pff->pj034, "\n TTFD! pff->pj3 is NOT null\n");

        if (pfc->gstat.pv) // this may or may have not been allocated
        {
            V_FREE(pfc->gstat.pv);
            pfc->gstat.pv = NULL;
        }
    }
    else
    {
        ASSERTDD(pff->pj034, "\n TTFD! pff->pj3 is null\n");
    }

    if (pff->cRef == 0)
    {
    // there are no fc's  around to use memory at pff->pj3, release it.

        if (!(pttc->fl & FF_EXCEPTION_IN_PAGE_ERROR))
        {
            V_FREE(pff->pj034);
            pff->pj034 = (BYTE *)NULL;
        }
    }

    if (pttc->cRef == 0)
    {
    // file will not be used for a while,

        EngUnmapFontFileFD(PFF(pttc->ahffEntry[0].hff)->iFile);
    }

// free the memory associated with hfc

    vFreeFC(pfc);
    return(TRUE);
}

/******************************Public*Routine******************************\
* ttfdDestroyFont
*
* Driver can release all resources associated with this font realization
* (embodied in the FONTOBJ).
*
* History:
*  27-Oct-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
ttfdDestroyFont (
    FONTOBJ *pfo
    )
{
// For the ttfd, this is simply closing the font context.
// We cleverly store the font context handle in the FONTOBJ pvProducer
// field.

// pfo->pvProducer COULD BE null if exception occured while trying to create fc

    if (pfo->pvProducer)
    {
        ttfdCloseFontContext((FONTCONTEXT *) pfo->pvProducer);
        pfo->pvProducer = NULL;
    }
}


/******************************Public*Routine******************************\
*
* bSetXform
*
* the only reason this funcion can fail is if fs_NewTransformation has failed
* Needs to be called when the transform has changed relative to the
* transform stored in this fc
*
* History:
*  28-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL bSetXform (
    PFONTCONTEXT    pfc,
    BOOL            bBitmapEmboldening,
    Fixed           subPosX,
    Fixed           subPosY
    )
{
    FS_ENTRY    iRet;
    transMatrix mx = pfc->mx;
    Fixed       fxScale;
    LONG        ptSize;

// no previous glyph metric computation can be used

    vInitGlyphState(&pfc->gstat);

// if an illegal junk is passed for style size replace by reasonable default

    if (pfc->ulStyleSize > SHRT_MAX)
        pfc->ulStyleSize = 0;


    pfc->subPosX = subPosX;
    pfc->subPosY = subPosY;

    mx.transform[0][2] = subPosX;
    mx.transform[1][2] = subPosY;

    if (UNHINTED_MODE(pfc))
    {
        pfc->pgin->param.newtrans.bHintAtEmSquare = TRUE;
    }
    else
    {
        pfc->pgin->param.newtrans.bHintAtEmSquare = FALSE;
    }

    pfc->pgin->param.newtrans.xResolution = (int16)pfc->sizLogResPpi.cx;
    pfc->pgin->param.newtrans.yResolution = (int16)pfc->sizLogResPpi.cy;

    if (pfc->flXform & XFORM_SINGULAR)
    {
    // just put in some junk so that the preprogram does not explode

        pfc->pgin->param.newtrans.pointSize = LTOF16_16(12);

        mx.transform[0][0] = LTOF16_16(1);
        mx.transform[1][0] = 0;
        mx.transform[1][1] = LTOF16_16(1);
        mx.transform[0][1] = 0;
    }
    else
    {
        if (pfc->flXform & XFORM_HORIZ)
        {
            if (pfc->ulStyleSize == 0)
            {
            // hinting is determined by ptSize that corresponds to the
            // actual height in points of the font

                pfc->pgin->param.newtrans.pointSize = pfc->fxPtSize;

            // factor out pointSize from the xform:

                if (pfc->mx.transform[1][1] > 0)
                    mx.transform[1][1] = LTOF16_16(1);
                else
                    mx.transform[1][1] = LTOF16_16(-1);

                if
                (
                    (pfc->mx.transform[1][1] == pfc->mx.transform[0][0])
                    &&
                    (pfc->sizLogResPpi.cy == pfc->sizLogResPpi.cx)
                )
                {
                // important special case, simplify computation

                    mx.transform[0][0] = mx.transform[1][1];
                }
                else // general case
                {
                    fxScale = LongMulDiv(
                                 LTOF16_16(pfc->pff->ffca.ui16EmHt),pfc->sizLogResPpi.cy,
                                 pfc->lEmHtDev * pfc->sizLogResPpi.cx
                                 );

                    mx.transform[0][0] = FixMul(mx.transform[0][0], fxScale);
                }
            }
            else
            {
            // This is the support for new optical scaling feature.
            // Hint the font as determined by the style point size from
            // ExtLogFont,  but possibly zoom the font to a different
            // physical size

                pfc->pgin->param.newtrans.pointSize =
                    (Fixed)LTOF16_16(pfc->ulStyleSize);

            // factor out pointSize from the xform:

                fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),72,
                             pfc->ulStyleSize * pfc->sizLogResPpi.cx
                             );

                mx.transform[0][0] = FixMul(mx.transform[0][0], fxScale);

                if (pfc->sizLogResPpi.cy != pfc->sizLogResPpi.cx)
                {
                    fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),72,
                                  pfc->ulStyleSize * pfc->sizLogResPpi.cy
                                  );
                }

                mx.transform[1][1] = FixMul(mx.transform[1][1], fxScale);
            }
        }
        else
        {
            if (pfc->ulStyleSize == 0)
            {
            // compute the physical point size

                ptSize = F16_16TOLROUND(pfc->fxPtSize);
                pfc->pgin->param.newtrans.pointSize = pfc->fxPtSize;
            }
            else // use style size from logfont, the support for optical scaling
            {
                ptSize = pfc->ulStyleSize;
                pfc->pgin->param.newtrans.pointSize = LTOF16_16(pfc->ulStyleSize);
            }

        // factor out pointSize from the xform:

            if
            (
                (pfc->flXform & XFORM_VERT) &&
                (pfc->mx.transform[1][0] == -pfc->mx.transform[0][1])
                &&
                (pfc->sizLogResPpi.cy == pfc->sizLogResPpi.cx)
            )
            {
            // important special case, simplify computation
            // and avoid rounding error

                if (pfc->mx.transform[0][1] > 0)
                    mx.transform[0][1] = LTOF16_16(1);
                else
                    mx.transform[0][1] = LTOF16_16(-1);

                mx.transform[1][0] = -mx.transform[0][1];
                mx.transform[0][0] = 0;
                mx.transform[1][1] = 0;
            }
            else
            {

                if (((ptSize + 1) * pfc->sizLogResPpi.cx) > 0x8000)
                {
                    /* keep the old computation to avoid overflow */
                    fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),72,
                                 ptSize * pfc->sizLogResPpi.cx
                                 );
                } else {
                    fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),0x480000 /* 72 */,
                                 pfc->pgin->param.newtrans.pointSize * pfc->sizLogResPpi.cx
                                 );
                }

                mx.transform[0][0] = FixMul(mx.transform[0][0], fxScale);
                mx.transform[1][0] = FixMul(mx.transform[1][0], fxScale);

                if (pfc->sizLogResPpi.cy != pfc->sizLogResPpi.cx)
                {
                    if (((ptSize + 1) * pfc->sizLogResPpi.cy) > 0x8000)
                    {
                    /* keep the old computation to avoid overflow */
                        fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),72,
                                      ptSize * pfc->sizLogResPpi.cy
                                      );
                    } else {
                        fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),0x480000 /* 72 */,
                                      pfc->pgin->param.newtrans.pointSize * pfc->sizLogResPpi.cy
                                      );
                    }
                }

                mx.transform[1][1] = FixMul(mx.transform[1][1], fxScale);
                mx.transform[0][1] = FixMul(mx.transform[0][1], fxScale);
            }
        }

    }

// last minute modification to the matrix if italicization is present:

    if (pfc->flFontType & FO_SIM_ITALIC)
    {
    // the result of multiplying arbitrary matrix with italicization matrix
    // We are multiplying from the left because the italicization matrix
    // acts first on the notional space vectors on the left
    //
    // |1      0|   |m00    m01|   |m00                 m01              |
    // |        | * |          | = |                                     |
    // |sin20  1|   |m10    m11|   |m10 + m00 * sin20   m11 + m01 * sin20|
    //

        mx.transform[1][0] += FixMul(mx.transform[0][0], FX_SIN20);
        mx.transform[1][1] += FixMul(mx.transform[0][1], FX_SIN20);

    } else if (pfc->flFontType & FO_SIM_ITALIC_SIDEWAYS)
    {
    // the result of multiplying arbitrary matrix with italicization matrix
    // We are multiplying from the left because the italicization matrix
    // acts first on the notional space vectors on the left
    //
    // |1  -sin20|   |m00    m01|   |m00 - m10 * sin20   m01 - m11 * sin20|
    // |         | * |          | = |                                     |
    // |0       1|   |m10    m11|   |m10                 m11              |
    //

        mx.transform[0][0] -= FixMul(mx.transform[1][0], FX_SIN20);
        mx.transform[0][1] -= FixMul(mx.transform[1][1], FX_SIN20);
    }

    pfc->pgin->param.newtrans.transformMatrix = &mx;

// FIXEDSQRT2 is good as pixel diameter for all practical purposes
// according to EliK, LenoxB and JeanP [bodind]

    pfc->pgin->param.newtrans.pixelDiameter = FIXEDSQRT2;

    pfc->pgin->param.newtrans.usOverScale = pfc->overScale;
    ASSERTDD( pfc->overScale != FF_UNDEFINED_OVERSCALE , "Undefined Overscale\n" );

    if (pfc->flFontType & FO_CLEARTYPE_GRID)
    {
		if (pfc->flFontType & FO_COMPATIBLE_WIDTH)
		{
			pfc->pgin->param.newtrans.flSubPixel = SP_SUB_PIXEL | SP_COMPATIBLE_WIDTH;
		} else {
			pfc->pgin->param.newtrans.flSubPixel = SP_SUB_PIXEL;
		}
    } else {
        pfc->pgin->param.newtrans.flSubPixel = 0;
    }

    pfc->pgin->param.newtrans.traceFunc = (FntTraceFunc)NULL;

    if (pfc->flFontType & FO_SIM_BOLD)
    {
	/* 2% + 1 pixel along baseline, 2% along descender line */
	    pfc->pgin->param.newtrans.usEmboldWeightx = 20;
	    pfc->pgin->param.newtrans.usEmboldWeighty = 20;
	    pfc->pgin->param.newtrans.lDescDev = pfc->lDescDev;
	    pfc->pgin->param.newtrans.bBitmapEmboldening = bBitmapEmboldening;
    }
    else
    {
	    pfc->pgin->param.newtrans.usEmboldWeightx = 0;
	    pfc->pgin->param.newtrans.usEmboldWeighty = 0;
	    pfc->pgin->param.newtrans.lDescDev = 0;
	    pfc->pgin->param.newtrans.bBitmapEmboldening = FALSE;
    }

// now call the rasterizer to acknowledge the new transform

    if ((iRet = fs_NewTransformation(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);

    // try to recover, most likey bad hints, just return unhinted glyph

        if ((iRet = fs_NewTransformNoGridFit(pfc->pgin, pfc->pgout)) != NO_ERR)
        {
           V_FSERROR(iRet);
            return(FALSE);
        }
    }

    if (bBitmapEmboldening && (pfc->flFontType & FO_SIM_BOLD))
    {
        pfc->flXform |= XFORM_BITMAP_SIM_BOLD;
    } else {
        pfc->flXform &= ~XFORM_BITMAP_SIM_BOLD;
    }
    return(TRUE);
}


VOID vQuantizeXform
(
PFONTCONTEXT pfc
);


/******************************Public*Routine******************************\
*
* STATIC bComputeMaxGlyph
*
*
* Effects:
*
* Warnings:
*
* History:
*  04-Dec-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bComputeMaxGlyph (
    PFONTCONTEXT   pfc
    )
{
    VOID vSetGrayState__FONTCONTEXT(FONTCONTEXT *);
    VOID vSetClearTypeState__FONTCONTEXT(FONTCONTEXT *);

    LONG              cxMax,cyMax;

    LONG              yMinN, yMaxN;
    LONG              xMinN, xMaxN;

    LONG              lTmp;
    Fixed             fxMxx,fxMyy;
    BYTE             *pjView = (BYTE *)pfc->pff->pvView;

    sfnt_FontHeader * phead = (sfnt_FontHeader *) (
                      pjView + pfc->ptp->ateReq[IT_REQ_HEAD].dp
                      );

    BYTE * pjOS2 = (pfc->ptp->ateOpt[IT_OPT_OS2].dp)          ?
                   (pjView + pfc->ptp->ateOpt[IT_OPT_OS2].dp) :
                   NULL                                       ;

    ASSERTDD(pjView, "bComputeMaxGlyph, pjView\n");

// get the notional space values

    if (pjOS2 && (pfc->flXform & (XFORM_HORIZ | XFORM_VERT)))
    {
    // win 31 compatibility: we only take the max over win 31 char set.
    // All the glyphs outside this set, if they stand out will get shaved
    // off to match the height of the win31 char subset. Also notice that
    // for nonhorizontal cases we do not use os2 values because shaving
    // only applies to horizontal case, otherwise our bounding box values
    // will not be computed properly for nonhorizontal cases.

        yMinN =  - BE_INT16(pjOS2 + OFF_OS2_usWinAscent);
        yMaxN =    BE_INT16(pjOS2 + OFF_OS2_usWinDescent);
    }
    else
    {
        yMinN = - BE_INT16(&phead->yMax);
        yMaxN = - BE_INT16(&phead->yMin);
    }

    if (yMinN >= yMaxN)
            RETURN("TTFD! yMinN >= yMaxN, must fail\n", FALSE);

    xMinN = BE_INT16(&phead->xMin);
    xMaxN = BE_INT16(&phead->xMax);

    if (pfc->flFontType & FO_SIM_ITALIC)
    {
    // IF there is italic simulation
    //     xMin -> xMin - yMaxN * sin20
    //     xMax -> xMax - yMinN * sin20

        xMinN -= FixMul(yMaxN, FX_SIN20);
        xMaxN -= FixMul(yMinN, FX_SIN20);
    } else if (pfc->flFontType & FO_SIM_ITALIC_SIDEWAYS)
    {
    // IF there is italic simulation
    //     yMin -> yMin + xMinN * sin20
    //     yMax -> yMax + xMaxN * sin20

        yMinN += FixMul(xMinN, FX_SIN20);
        yMaxN += FixMul(xMaxN, FX_SIN20);
    }

    if (xMinN >= xMaxN)
            RETURN("TTFD! xMinN >= xMaxN, must fail\n", FALSE);

    pfc->lEmHtDev = 0; // flag that it has not been computed
    pfc->fxPtSize = 0; // flag that it has not been computed
    pfc->phdmx = NULL; // NULL unless computed otherwise

    if ((pfc->flXform & XFORM_HORIZ) &&
        !(pfc->flXform & XFORM_SINGULAR))  // XX AND YY Only
    {
        sfnt_HorizontalHeader  *phhea;
        ULONG  cHMTX;

        fxMxx = pfc->mx.transform[0][0];
        fxMyy = pfc->mx.transform[1][1];

    // ascender, round up

        yMinN = FixMul(fxMyy, yMinN);
        yMaxN = FixMul(fxMyy, yMaxN);

        if (fxMyy > 0)
        {
        // vdmx table should be consulted if present and used to compute
        // ascender and descender. If this computation can not be done
        // based on vdmx table or if vdmx table is not present simple
        // linear scaling will suffice [bodind].

            if (!UNHINTED_MODE(pfc))
            {
                /* we ignore VDMX if we are in an unhinted mode */
                vQuantizeXform(pfc);
            }

            if (!(pfc->flXform & XFORM_VDMXEXTENTS)) // COMPUTED FROM VDMX
            {
                pfc->yMin = yMinN;
                pfc->yMax = yMaxN;
            }
            else
            {
                /* take the biggest between the VDMX metrics and the linearly scaled metrics
                   the font Lucida Sans Unicode is an exemple of font that have VDMX metrics
                    10% smaller than linearly scaled metrics */
                if (yMinN < pfc->yMin)
                    pfc->yMin = yMinN;

                if (yMaxN > pfc->yMax)
                    pfc->yMax = yMaxN;
            }

            pfc->lAscDev  = - pfc->yMin;
            pfc->lDescDev =   pfc->yMax;
        }
        else // fxMyy < 0
        {
            pfc->lAscDev =    yMinN;
            pfc->lDescDev = - yMaxN;

        // swap yMin and yMax for when the xform flips y coord

            lTmp  = yMinN;
            yMinN = yMaxN;
            yMaxN = lTmp;

            pfc->yMin = yMinN;
            pfc->yMax = yMaxN;

        }

        if (pfc->lEmHtDev == 0)
        {
        // if this value has not been computed in vQuantizeXform routine

            pfc->lEmHtDev = FixMul(fxMyy, pfc->pff->ifi.fwdUnitsPerEm);
            if (pfc->lEmHtDev < 0)
                pfc->lEmHtDev = - pfc->lEmHtDev;
        }

        ASSERTDD(pfc->lEmHtDev >= 0, "lEmHt negative\n");

    // now that em height has been computed, we can compute the
    // pt size on the rendering device. This value will be fed to
    // fs_NewTransformation

        pfc->fxPtSize = LongMulDiv(
                            LTOF16_16(pfc->lEmHtDev), 72,
                            pfc->sizLogResPpi.cy);

        cyMax = pfc->yMax - pfc->yMin;

        phhea = (sfnt_HorizontalHeader *)(
                (BYTE *)pfc->pff->pvView + pfc->ptp->ateReq[IT_REQ_HHEAD].dp
                );
        cHMTX = (ULONG) BE_UINT16(&phhea->numberOf_LongHorMetrics);


    // scale xMin,xMax to device, 28.4 format

        xMinN = FixMul(LTOFX(xMinN), fxMxx);
        xMaxN = FixMul(LTOFX(xMaxN), fxMxx);

        if (fxMxx < 0)
        {
            lTmp  = xMinN;
            xMinN = xMaxN;
            xMaxN = lTmp;
        }

    // I run the experiment on 400 fonts at several sizes. I found
    // that subtracting 2 from xMin and adding 1 to xMax suffices
    // in all situations to prevent any columns from being shaved off.
    // [bodind]

        xMinN = FXTOLFLOOR(xMinN) - 2;
        xMaxN = FXTOLCEILING(xMaxN) + 1;

        pfc->xMin = xMinN;
        pfc->xMax = xMaxN;

        cxMax = xMaxN - xMinN;

    }
    else // nontrivial transformation
    {
        POINTL   aptl[4];
        POINTFIX aptfx[4];
        BOOL     bOk;
        INT      i;
        FIX      xMinD, xMaxD, yMinD, yMaxD; // device space values;

    // add little extra space to be safe

        i = (INT)(pfc->pff->ffca.ui16EmHt / 64);
        yMaxN +=  i; // adds about 1.7% to ht
        yMinN -=  i; // adds about 1.7% to ht

    // set up the input array, the four corners of the maximal bounding
    // box in the notional coords

        aptl[0].x = xMinN;       //  tl.x
        aptl[0].y = yMinN;       //  tl.y

        aptl[1].x = xMaxN;       //  tr.x
        aptl[1].y = yMinN;       //  tr.y

        aptl[2].x = xMinN;       //  bl.x
        aptl[2].y = yMaxN;       //  bl.y

        aptl[3].x = xMaxN;       //  br.x
        aptl[3].y = yMaxN;       //  br.y

    // xform to device coords with 28.4 precision:

        // !!! [GilmanW] 27-Oct-1992
        // !!! Should change over to engine user object helper functions
        // !!! instead of the fontmath.cxx functions.

        bOk = bFDXform(&pfc->xfm, aptfx, aptl, 4);

        if (!bOk) { RETURN("TTFD!_:bFDXform\n", FALSE); }

        xMaxD = xMinD = aptfx[0].x;
        yMaxD = yMinD = aptfx[0].y;

        for (i = 1; i < 4; i++)
        {
            if (aptfx[i].x < xMinD)
                xMinD = aptfx[i].x;
            if (aptfx[i].x > xMaxD)
                xMaxD = aptfx[i].x;
            if (aptfx[i].y < yMinD)
                yMinD = aptfx[i].y;
            if (aptfx[i].y > yMaxD)
                yMaxD = aptfx[i].y;
        }

        yMinD = FXTOLFLOOR(yMinD)   ;
        yMaxD = FXTOLCEILING(yMaxD) ;
        xMinD = FXTOLFLOOR(xMinD)   ;
        xMaxD = FXTOLCEILING(xMaxD) ;

        cxMax = xMaxD - xMinD;
        cyMax = yMaxD - yMinD;

    // now re-use aptl to store e1 and -e2, base and side unit
    // vectors in the notional space.
    //!!! This may be wrong if have font for
    //!!! right to left or vert writing [bodind]

        aptl[0].x = 1;    // base.x
        aptl[0].y = 0;    // base.y

        aptl[1].x =  0;   // side.x
        aptl[1].y = -1;   // side.y

        // !!! [GilmanW] 27-Oct-1992
        // !!! Should change over to engine user object helper functions
        // !!! instead of the fontmath.cxx functions.

        bOk = bXformUnitVector (
                  &aptl[0],          // IN,  incoming unit vector
                  &pfc->xfm,         // IN,  xform to use
                  &pfc->efBase       // OUT, |*pptqXormed|
                  );

        bOk &= bXformUnitVector (
                  &aptl[1],          // IN,  incoming unit vector
                  &pfc->xfm,         // IN,  xform to use
                  &pfc->efSide       // OUT, |*pptqXormed|
                  );

        if (!bOk) { RETURN("TTFD!_:bXformUnitVector\n", FALSE); }

        pfc->lAscDev  = -fxLTimesEf(&pfc->efSide,yMinN);
        pfc->lDescDev =  fxLTimesEf(&pfc->efSide,yMaxN);

        pfc->lAscDev  = FXTOLCEILING(pfc->lAscDev) ;
        pfc->lDescDev = FXTOLCEILING(pfc->lDescDev);

        // finally store the results:

        pfc->xMin        = xMinD;
        pfc->xMax        = xMaxD;
        pfc->yMin        = yMinD;
        pfc->yMax        = yMaxD;

    // compute em ht in pixels and points


        pfc->fxPtSize = fxPtSize(pfc);

        /* compute pfc->lEmHtDev from pfc->fxPtSize to make sure values are coherent */

        {
            Fixed fxScale;

            fxScale = LongMulDiv(pfc->fxPtSize, pfc->sizLogResPpi.cy, 72);
            pfc->lEmHtDev = (uint16)ROUNDFIXTOINT(fxScale);
        }

    }

    if ((pfc->flXform & (XFORM_HORIZ | XFORM_VERT)) && 
        ((pfc->mx.transform[0][0] == pfc->mx.transform[1][1]) || (pfc->mx.transform[0][0] == -pfc->mx.transform[1][1]) ) &&
        ((pfc->mx.transform[0][1] == pfc->mx.transform[1][0]) || (pfc->mx.transform[0][1] == -pfc->mx.transform[1][0])) )
    {
    // find the hdmx table, in case of the console fixed pitch font this
    // table may be useful in determining if cxMax needs to be cut off
    // to the advance width of this font
    // we can use this table for rotations that are a multiple of 90 degree and mirror flips as long as we have a square transform

        vFindHdmxTable(pfc); 
    }

// compute corrections

    if (pfc->flFontType & FO_SIM_BOLD)
    {
        vCalcEmboldSize(pfc);
    }
    else
    {
        pfc->dBase = 0;
    }

// if this is one of the almost singular transforms, reject this

    if ((cxMax == 0) || (cyMax == 0))
    {
        RETURN("TTFD! almost singular xform, must fail\n", FALSE);
    }


    if (pfc->flFontType & FO_SIM_BOLD)
    {
        /* we are on the safe side by adding dBase to both cxMax and cyMax */
        cxMax += pfc->dBase;
        cyMax += pfc->dBase;
    }

// we can liberally extend cxMax to the byte boundary, this is not
// going to change memory requirements of the system.

    cxMax = ((cxMax + 7) & ~7);
    pfc->cxMax = cxMax;
    pfc->cyMax = cyMax;

// now we have to determine how big in memory is the biggest glyph.
// let us remember that the rasterizer needs little more storage than the
// the engine does, because rasterizer will want dword aligned rows rather
// than byte aligned rows

    {
        DWORDLONG lrg;

    // why am I dword instead byte extending cxMax? because that is
    // how much rasterizer will want for this bitmap

        ULONG          cjMaxScan = ((cxMax + 31) & ~31) / 8;
        lrg =  UInt32x32To64(cjMaxScan, cyMax);
        if (lrg > ULONG_MAX)
        {
        // the result does not fit in 32 bits, alloc memory will fail
        // this is too big to digest, we fail to open fc

            RETURN("TTFD! huge pt size, must fail\n", FALSE);
        }
    }

// We now have all the informaiton to set the gray bit
// appropriately.

    if (pfc->flFontType & FO_CLEARTYPE_GRID || pfc->flFontType & FO_CLEARTYPE)
    {
        vSetClearTypeState__FONTCONTEXT(pfc);
    }
    else
    {
        vSetGrayState__FONTCONTEXT(pfc);
    }

    ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,
        "We haven't decided about pixel depth\n"
    );

    pfc->cjGlyphMax = CJGD(cxMax,cyMax,pfc);

    return TRUE;
}

//--------------------------------------------------------------------
// LONG iHipot(x, y)
//
// This routine returns the hypoteneous of a right triangle.
//
// FORMULA:
//          use sq(x) + sq(y) = sq(hypo);
//          start with MAX(x, y),
//          use sq(x + 1) = sq(x) + 2x + 1 to incrementally get to the
//          target hypotenouse.
//
// History:
//  Mon 07-Feb-1994 -by- Bodin Dresevic [BodinD]
//  update:   update to use Fixed 16.16
//   10-Feb-1993    -by-    Kent Settle     (kentse)
//  Stole from RASDD.
//   21-Aug-1991    -by-    Lindsay Harris  (lindsayh)
//  Cleaned up UniDrive version, added comments etc.
//--------------------------------------------------------------------


/*

      Algorithm analysis by DChinn :

      After a bit of incorrect attempts, I figured it all out.  It turns out that
    the if h is the correct hypotenuse, then the routine returns the
    ceiling of h.  Here's the analysis:


    Let h = the correct hypotenuse
        h = sqrt{x^2 + y^2}

        x and y are integers.

    Let h' = the value returned by the algorithm

                      { d-1                        }
        h' = y +  min { sum [ 2(y+i) + 1 ]  >= x^2 }
                  d>0 { i=0                        }

                 { d-1                        }
    Let d' = min { sum [ 2(y+i) + 1 ]  >= x^2 }
             d>0 { i=0                        }

    Consider the smallest d for which

            d-1
            sum [ 2(y+i) + 1 ]  >= x^2  .
            i=0

            d-1                d-1
            sum (2y + 1)  +  2 sum i   >= x^2
            i=0                i=0

               2yd + d    + (d-1)d   - x^2 >= 0

            d^2 + 2yd - x^2 >= 0        (solve this equation as if it were an equality)

                  -2y +/- sqrt{ (2y)^2 - 4 * 1 * (-x^2) }
            d  =  ---------------------------------------
                                    2
            d' =  ceiling (d)

            d' =  ceiling (  -y +/- sqrt{ y^2 + x^2 }  )

               =  -y + ceiling ( sqrt{ y^2 + x^2 } )     (the minus in +/- is impossible)

    So, h' = y +  (-y) + ceiling ( sqrt{ y^2 + x^2 } )
           = ceiling ( sqrt{ y^2 + x^2 } )

    The loop invariant: Since delta is incremented by 2*hypo+1 in each iteration and
    (hypo+1)^2 = hypo^2 + (2*hypo + 1), then at the end of each iteration, a
    triangle with sides y, sqrt{delta}, and hypo is always a right triangle.

    Note that there is no assumption in the above that y >= x, so
    that assumption is for performance reasons only.

  */

STATIC ULONG iHipot(LONG x, LONG y)
{
    ULONG  hypo;         /* Value to calculate */
    ULONG  delta;        /* Used in the calculation loop */
    ULONG  target;       /* Loop limit factor */
	USHORT  shift = 0;

// quick exit for frequent trivial cases [bodind]

    if (x < 0)
        x = -x;

    if (y < 0)
        y = -y;

    if (x == 0)
        return y;

    if (y == 0)
        return x;

    /* avoid overflow */
    while ((x > 0x8000L) || (y > 0x8000L))
    {
        x >>= 1;
        y >>= 1;
        shift ++;
    }

    if (x > y)
    {
        hypo = x;
        target = y * y;
    }
    else
    {
        hypo = y;
        target = x * x;
    }

    for (delta = 0; delta < target; hypo++)
        delta += ((hypo << 1) + 1);

    return (hypo << shift);
}


/******************************Public*Routine******************************\
*
* bSingularXform
*
* Checks whether this is one of the xforms that the rasterizer is known
* to choke on. Those are the transforms that generate very
* narrow fonts (less than 0.5 pixels/em wide or tall). For fonts that
* allow only integer widths/em and heights/em this number will get rounded
* down to zero and generate divide by zero exception in the preprogram.
* We will flag such transforms as XFORM_SINGULAR and return empty bitmaps
* and outlines for them shortcircuiting the rasterizer which would die on
* us.
*
* Actually, for compatibility reasons we will have to change
* this plan a little bit. It turns out that
* win 31 does not allow for the rasterization of a font that is less
* than 2 pixels tall (ie. the Em Ht of the font in device space must be
* >= 2 pixels). If a request comes down to realize a font that is tall less
* than 2 pixels we will simply have to substitute the transform by a scaled
* transform that will produce a font of height two pixels. We will still keep
* our singular transform code in case a font is requested that is singular in
* X direction, that is, too narrow.
*
* History:
*  22-Sep-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

// smallest ppem allowed under  win31:

#define WIN31_PPEM_CUTOFF 2

STATIC VOID vCheckForSingularXform (PFONTCONTEXT  pfc) // OUT
{

    register LONG  lEmHtDev;

    Fixed fxEmHtDev;
    Fixed fxEmHtNot = LTOF16_16(pfc->pff->ffca.ui16EmHt);
    Fixed fxScale;
    Fixed fxEmWidthDev;

// xforms are conforming left multiplication rule v' = v * M i.e.:
//
// (x,0) -> x(m00,m01)
// (0,y) -> y(m10,m11)
//
// compute length of (0,Em) after it gets transformed to device space:
// We need to have fxEmHtDev computed with high precission, for we
// shall be using it to divide the original transform by.
// We want to avoid division by zero when that is not neccessary.

    fxEmHtDev = FixMul(
                   iHipot(pfc->mx.transform[1][1],pfc->mx.transform[1][0]),
                   fxEmHtNot
                   );

    lEmHtDev = F16_16TOLROUND(fxEmHtDev);
    if (lEmHtDev < WIN31_PPEM_CUTOFF) // too small a transform:
    {
        pfc->flXform |= XFORM_2PPEM;

    // according to win31 algorithm, we must scale this xform so that the
    // resulting xform will produce font that is 2 pels tall.
    // That is, the new transform M' is going to be
    //
    // M' = (WIN31_PPEM_CUTOFF / lEmHtDev) * M
    //
    // so that the following equation is satisfied:
    //
    // |(0,EmNotional) * M'| == WIN31_PPEM_CUTOFF == 2;

        if (pfc->flXform & XFORM_HORIZ)
        {
        // in this special case the above formula for M' becomes:
        //
        //                                         | m00/|m11|     0     |
        // M' = (WIN31_PPEM_CUTOFF / EmNotional) * |                     |
        //                                         |   0        sgn(m11) |

#define LABS(x) ((x)<0)?(-x):(x)

            Fixed fxAbsM11 = LABS(pfc->mx.transform[1][1]);
            Fixed fxAbsM00 = LABS(pfc->mx.transform[0][0]);

            LONG lSgn11 = (pfc->mx.transform[1][1] >= 0) ? 1 : -1;
            LONG lSgn00 = (pfc->mx.transform[0][0] >= 0) ? 1 : -1;

            fxScale = FixDiv(WIN31_PPEM_CUTOFF,pfc->pff->ffca.ui16EmHt);

            pfc->mx.transform[1][1] = fxScale;
            if (fxAbsM00 != fxAbsM11)
            {
                pfc->mx.transform[0][0] = LongMulDiv(fxScale,fxAbsM00,fxAbsM11);
            }
            else
            {
                pfc->mx.transform[0][0] = fxScale;
            }

        // fix the signs if needed:

            if (lSgn11 < 0)
                pfc->mx.transform[1][1] = - pfc->mx.transform[1][1];

            if (lSgn00 < 0)
                pfc->mx.transform[0][0] = - pfc->mx.transform[0][0];
        }
        else
        {
        // general case, compute scale (which involves division) once,
        // and use it for all four members of the matrix:

            fxScale = FixDiv(LTOF16_16(WIN31_PPEM_CUTOFF),fxEmHtDev);

            pfc->mx.transform[0][0] = FixMul(pfc->mx.transform[0][0],fxScale);
            pfc->mx.transform[0][1] = FixMul(pfc->mx.transform[0][1],fxScale);
            pfc->mx.transform[1][0] = FixMul(pfc->mx.transform[1][0],fxScale);
            pfc->mx.transform[1][1] = FixMul(pfc->mx.transform[1][1],fxScale);

        // In general case must also fix the original EFLOAT xform because
        // it is going to be used for computation of extents, max glyphs etc.

            FFF(pfc->xfm.eM11, +pfc->mx.transform[0][0]);
            FFF(pfc->xfm.eM22, +pfc->mx.transform[1][1]);
            FFF(pfc->xfm.eM12, -pfc->mx.transform[0][1]);
            FFF(pfc->xfm.eM21, -pfc->mx.transform[1][0]);
        }
    }

// Now check if the transform is singular in x. To do this
// compute length of (Em,0) after it gets transformed to device space:

    fxEmWidthDev = FixMul(
                   iHipot(pfc->mx.transform[0][0],pfc->mx.transform[0][1]),
                   fxEmHtNot
                   );

    if (fxEmWidthDev <= ONEHALFFIX)
    {
    // We are in trouble, we shall have to lie to the engine:

        pfc->flXform |= XFORM_SINGULAR;
    }
}




/******************************Public*Routine******************************\
*
* bNewXform:
*
* converts the transform matrix to the form the rasterizer likes
* and computes the global (per font) sizes that are relevant for this
* transform.
*
* History:
*  28-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


STATIC BOOL
bNewXform (
    FONTOBJ      *pfo,
    PFONTCONTEXT pfc             // OUT
    )
{
// do not write immediately to pfc->mx until sure that all bFloatToL
// have succeeded. You do not want to leave this function and leave
// fc in a dirty state

    Fixed fx00, fx01, fx10, fx11;

// Get the transform elements.

    pfc->xfm.eM11 = pfo->fdx.eXX;
    pfc->xfm.eM12 = pfo->fdx.eXY;
    pfc->xfm.eM21 = pfo->fdx.eYX;
    pfc->xfm.eM22 = pfo->fdx.eYY;
    pfc->xfm.eDx = 0;
    pfc->xfm.eDy = 0;

    if (
        !bFloatToL(pfc->xfm.eM11, &fx00) ||
        !bFloatToL(pfc->xfm.eM22, &fx11) ||
        !bFloatToL(pfc->xfm.eM12, &fx01) ||
        !bFloatToL(pfc->xfm.eM21, &fx10)
       )
        RET_FALSE("TTFD!_bFloatToL failed\n");

// we are fine now, can not fail after this:

    pfc->mx.transform[0][0]  = fx00;
    pfc->mx.transform[1][1]  = fx11;
    pfc->mx.transform[0][1]  = -fx01;
    pfc->mx.transform[1][0]  = -fx10;

// check if this is one of the sing xform where one row or column is zero:
// It is important to do this after bFloatToL, some floating numbers can be
// so small that can only be represented as zeros in 16.16 format

    if
    (
        !(fx00 | fx01) ||
        !(fx00 | fx10) ||
        !(fx11 | fx10) ||
        !(fx11 | fx01)
    )
    {
        ASSERTDD(1, "We are messed up by this xform\n");
        return FALSE;
    }

// components in the projective space are zero

// ClaudeBe, from the client interface Doc :
// Please note that although the third column of the matrix is defined as Fixed numbers
// you will actually need to use  Fract numbers in that column. The higher resolution provided
// by Fracts is required to change the perspective of a glyph. Fracts are 2.30 fixed point numbers.

    pfc->mx.transform[2][2] = ONEFRAC;
    pfc->mx.transform[0][2] = (Fixed)0;
    pfc->mx.transform[1][2] = (Fixed)0;
    pfc->mx.transform[2][0] = (Fixed)0;
    pfc->mx.transform[2][1] = (Fixed)0;

// set the flags for the transform:

    pfc->flXform = 0;

    if ((fx01 == 0) && (fx10 == 0))
        pfc->flXform |= XFORM_HORIZ;

    if ((fx00 == 0) && (fx11 == 0))
        pfc->flXform |= XFORM_VERT;

// important to check for "singular transform"
// (ie. request for too small a font realization) after flags have been set

    vCheckForSingularXform(pfc);

// no glyph metrics computation is valid yet

    vInitGlyphState(&pfc->gstat);

// no memory to rasterize a glyph or produce glyph outline has been allocated

    pfc->gstat.pv = NULL;

// now get the sizes for this transform

    return bComputeMaxGlyph(pfc);
}


/******************************Public*Function*****************************\
* bFToL                                                                    *
*                                                                          *
* Convert an IEEE floating point number to a long integer.                 *
*                                                                          *
* History:                                                                 *
*
*  Thu 29-Mar-2001 -by- Mikhail Leonov [MLeonov]
* update:
*   changed <= 23 to < 23, otherwise numbers like 142.5 get converted to 0
*
*  Sun 17-Nov-1991 -by- Bodin Dresevic [BodinD]
* update:
*
* changed the line
*    if (flType & CVT_TO_FIX) lExp += 4;
* to
*    if (flType & CVT_TO_FIX) lExp += 16;
* to reflect that we are converting to 16.16 format rather than to 28.4
*
*
*  03-Jan-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

STATIC BOOL bFloatToL(FLOATL e, PLONG pl)
{
    LONG lEf, lExp;

    lEf = (*((LONG *) &e));        // convert type EFLOAT to LONG

// if exponent < 0 then convert to 0 and return true

    lExp = ((lEf >> 23) & 0xff) -127;

    lExp += 16; // this is the only line I changed [bodind]

    if (lExp < 0)
    {
        *pl = 0;
        return(TRUE);
    }

// if exponent < 23 then
//     lMantissa = (lEf & 0x7fffff) | 0x800000;
//         l = ((lMantissa >> (23 - lExponent -1)) + 1) >> 1;

    if (lExp < 23)
    {
        *pl = (lEf & 0x80000000) ?
             -(((((lEf & 0x7fffff) | 0x800000) >> (23 - lExp -1)) + 1) >> 1) :
             ((((lEf & 0x7fffff) | 0x800000) >> (23 - lExp -1)) + 1) >> 1;
        return(TRUE);
    }

// if exponent <= 30 then
// lMantissa = (lEf & 0x7fffff) | 0x800000;
// l = lMantissa << (lExponent - 23);

    if (lExp <= 30)
    {
        *pl = (lEf & 0x80000000) ?
            -(((lEf & 0x7fffff) | 0x800000) << (lExp - 23)) :
            ((lEf & 0x7fffff) | 0x800000) << (lExp - 23);
        return(TRUE);
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* lFFF = long-float-from-fixed
*
* input: 16.16 representation
* output: LONG that is bit equivalent of the 32-bit ieee float
*         equal to the fix point number. To recover the float
*   the FLOAT representation you simply cast the bits as a float
*   that is
*
*   FLOAT e;
*
*       *(LONG*)&e = lFFF(n16Dot16)
*
* History:
*  Tue 03-Jan-1995 14:33:35 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

LONG lFFF(LONG l)
{
#if defined(_AMD64_) || defined(_IA64_)
    FLOAT e = ((FLOATL) l)/((FLOATL) 65536);
    return(*(LONG*)&e);
#elif defined(_X86_)
    int i;                              // shift count
    unsigned k;                         // significand

    if (k = (unsigned) l)
    {
        if (l < 0)
            k = (unsigned) -l;          // significand is positive, sign
                                        // bit accounted for later
        i = 0;
        if (k < (1 << 16)) {            // put the number in the
            k <<= 16;                   // range 2^31 <= k < 2^32
            i += 16;                    // by shifting to left, put
        }                               // shift count in i
        if (k < (1 << 24)) {
            k <<= 8;
            i += 8;
        }
        if (k < (1 << 28)) {
            k <<= 4;
            i += 4;
        }
        if (k < (1 << 30)) {
            k <<= 2;
            i += 2;
        }
        if (k < (1 << 31)) {
            k <<= 1;
            i += 1;
        }
                                        // at this point
                                        // i = 31-floor(log2(abs(l)))

        k += (1 << 7);                  // about to shift out
                                        // the lowest 8-bits
                                        // account for their effect by
                                        // rounding. This has the effect
                                        // that numbers are rounded away
                                        // from zero as opposed to rounding
                                        // stricktly up
        k >>= 8;                        // shift out the lowest 8 bits

        k &= ((1<<23) - 1);             // 2^23 bit is implicit so mask it out
        k |= (0xff & (142 - i)) << 23;  // set exponent at correct place
        if (l < 0)                      // if original number was negative
            k |= (1<<31);               // then set the sign bit
    }
    return((LONG) k);
#endif
}


#if DBG

/******************************Public*Routine******************************\
*
* VOID vFSError(FS_ENTRY iRet);
*
*
* Effects:
*
* Warnings:
*
* History:
*  25-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID vFSError(FS_ENTRY iRet)
{
    PCHAR psz;

    switch (iRet)
    {
        case BAD_CALL_ERR:
            psz =  "BAD_CALL_ERR";
            break;
        case BAD_CLIENT_ID_ERR:
            psz =  "BAD_CLIENT_ID_ERR";
            break;
        case BAD_MAGIC_ERR:
            psz =  "BAD_MAGIC_ERR";
            break;
        case BAD_START_POINT_ERR:
            psz =  "BAD_START_POINT_ERR";
            break;
        case CLIENT_RETURNED_NULL:
            psz =  "CLIENT_RETURNED_NULL";
            break;
        case CONTOUR_DATA_ERR:
            psz =  "CONTOUR_DATA_ERR";
            break;
        case GLYPH_INDEX_ERR:
            psz =  "GLYPH_INDEX_ERR";
            break;
        case INSTRUCTION_SIZE_ERR:
            psz =  "INSTRUCTION_SIZE_ERR";
            break;
        case INVALID_GLYPH_INDEX:
            psz =  "INVALID_GLYPH_INDEX";
            break;
        case MISSING_SFNT_TABLE:
            psz =  "MISSING_SFNT_TABLE";
            break;
        case NULL_INPUT_PTR_ERR:
            psz =  "NULL_INPUT_PTR_ERR";
            break;
        case NULL_KEY_ERR:
            psz =  "NULL_KEY_ERR";
            break;
        case NULL_MEMORY_BASES_ERR:
            psz =  "NULL_MEMORY_BASES_ERR";
            break;
        case NULL_OUTPUT_PTR_ERR:
            psz =  "NULL_OUTPUT_PTR_ERR";
            break;
        case NULL_SFNT_DIR_ERR:
            psz =  "NULL_SFNT_DIR_ERR";
            break;
        case NULL_SFNT_FRAG_PTR_ERR:
            psz =  "NULL_SFNT_FRAG_PTR_ERR";
            break;
        case OUT_OFF_SEQUENCE_CALL_ERR:
            psz =  "OUT_OFF_SEQUENCE_CALL_ERR";
            break;
        case OUT_OF_RANGE_SUBTABLE:
            psz =  "OUT_OF_RANGE_SUBTABLE";
            break;
        case POINTS_DATA_ERR:
            psz =  "POINTS_DATA_ERR";
            break;
        case POINT_MIGRATION_ERR:
            psz =  "POINT_MIGRATION_ERR";
            break;
        case SCAN_ERR:
            psz =  "SCAN_ERR";
            break;
        case SFNT_DATA_ERR:
            psz =  "SFNT_DATA_ERR";
            break;
        case TRASHED_MEM_ERR:
            psz =  "TRASHED_MEM_ERR";
            break;
        case TRASHED_OUTLINE_CACHE:
            psz =  "TRASHED_OUTLINE_CACHE";
            break;
        case UNDEFINED_INSTRUCTION_ERR:
            psz =  "UNDEFINED_INSTRUCTION_ERR";
            break;
        case UNKNOWN_CMAP_FORMAT:
            psz =  "UNKNOWN_CMAP_FORMAT";
            break;
        case UNKNOWN_COMPOSITE_VERSION:
            psz =  "UNKNOWN_COMPOSITE_VERSION";
            break;
        case VOID_FUNC_PTR_BASE_ERR:
            psz =  "VOID_FUNC_PTR_BASE_ERR";
            break;
        case SBIT_COMPONENT_MISSING_ERR:
            psz =  "SBIT_COMPONENT_MISSING_ERR";
            break;
        case TRACE_FAILURE_ERR:
            psz = "Trace_Failure_Error";
            break;
        case DIV_BY_0_IN_HINTING_ERR:
            psz = "DIV_BY_0_IN_HINTING_ERR";
            break;
        case MISSING_ENDF_ERR:
            psz = "MISSING_ENDF_ERR";
            break;
        case MISSING_EIF_ERR:
            psz = "MISSING_EIF_ERR";
            break;
        case INFINITE_RECURSION_ERR:
            psz = "INFINITE_RECURSION_ERR";
            break;
        case INFINITE_LOOP_ERR:
            psz = "INFINITE_LOOP_ERR";
            break;
        case FDEF_IN_GLYPHPGM_ERR:
            psz = "FDEF_IN_GLYPHPGM_ERR";
            break;
        case IDEF_IN_GLYPHPGM_ERR:
            psz = "IDEF_IN_GLYPHPGM_ERR";
            break;
        case JUMP_BEFORE_START_ERR:
            psz = "JUMP_BEFORE_START_ERR";
            break;
        case RAW_NOT_IN_GLYPHPGM_ERR:
            psz = "RAW_NOT_IN_GLYPHPGM_ERR";
            break;	
        case INSTRUCTION_ERR:
            psz = "INSTRUCTION_ERR";
            break;
        case SECURE_STACK_UNDERFLOW:
            psz = "SECURE_STACK_UNDERFLOW";
            break;
        case SECURE_STACK_OVERFLOW:
            psz = "SECURE_STACK_OVERFLOW";
            break;
        case SECURE_POINT_OUT_OF_RANGE:
            psz = "SECURE_POINT_OUT_OF_RANGE";
            break;
        case SECURE_INVALID_STACK_ACCESS:
            psz = "SECURE_INVALID_STACK_ACCESS";
            break;
        case SECURE_FDEF_OUT_OF_RANGE:
            psz = "SECURE_FDEF_OUT_OF_RANGE";
            break;
        case SECURE_ERR_FUNCTION_NOT_DEFINED:
            psz = "SECURE_ERR_FUNCTION_NOT_DEFINED";
            break;
        case SECURE_INVALID_ZONE:
            psz = "SECURE_INVALID_ZONE";
            break;
        case SECURE_INST_OPCODE_TO_LARGE:
            psz = "SECURE_INST_OPCODE_TO_LARGE";
            break;
        case SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP:
            psz = "SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP";
            break;
        case SECURE_STORAGE_OUT_OF_RANGE:
            psz = "SECURE_STORAGE_OUT_OF_RANGE";
            break;
        case SECURE_CONTOUR_OUT_OF_RANGE:
            psz = "SECURE_CONTOUR_OUT_OF_RANGE";
            break;
        case SECURE_CVT_OUT_OF_RANGE:
            psz = "SECURE_CVT_OUT_OF_RANGE";
            break;
        case SECURE_UNITIALIZED_ZONE:
            psz = "SECURE_UNITIALIZED_ZONE";
            break;	
        default:
            psz = "UNKNOWN FONT SCALER ERROR";
                break;
    }
    TtfdDbgPrint ("\n Rasterizer Error: 0x%lx, %s \n", iRet, psz);

}


#endif


/******************************Public*Routine******************************\
*
* fxPtSize
*
* Effects: computes the size in points for this font realization
*
* History:
*  06-Aug-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC LONG fxPtSize(PFONTCONTEXT pfc)
{
// This is done as follows:
//
// Transform
// (0, ui16EmHt) to device (pixel) space.
// Let us say that the vector obtained is (xEm, yEm).
// Then, ptSize should be computed as
// ptSize =  72 * sqrt((xEm/xRes)^2 + (yEm/yRes)^2);

// expanding here a bit we get:
// ptSize =  72 * ui16EmHt * sqrt((mx10/xRes)^2 + (mx11/yRes)^2);

	Fixed x,y;
    LONG  lEmHtX72 = (LONG)(72 * pfc->pff->ffca.ui16EmHt);

    x = LongMulDiv(lEmHtX72,pfc->mx.transform[1][0],pfc->sizLogResPpi.cx);
    y = LongMulDiv(lEmHtX72,pfc->mx.transform[1][1],pfc->sizLogResPpi.cy);
    return iHipot(x,y);
}


//
// this is win31 code intended as a comment for our code:
//

#ifdef THIS_IS_WIN31_CODE_INTENDED_AS_COMMENT

      // Find out if a width Table is available
    if (pfnt->ulHdmxPos && !(pfc->fStatus & FD_MORE_THAN_STRETCH) && pfc->Mx11 == pfc->Mx00)
    {
      unsigned    i;
      HDMXHEADER  FAR *pHdmx;
      HDMXTABLE   FAR *pHdmxTable;

      if (pHdmx = (HDMXHEADER  FAR *) SfntReadFragment (pfc->fgi.clientID, pfnt->ulHdmxPos, pfnt->uHdmxSize))
      {
        if (pHdmx->Version == 0)
        {
          pHdmxTable = pHdmx->HdmxTable;

            // Init the the glyph count
          pfc->cHdmxRecord = (unsigned) SWAPL (pHdmx->cbSizeRecord);

           // look through the table if the size is available
          for (i = 0; i < (unsigned) SWAPW (pHdmx->cbRecord); i++, pHdmxTable = (HDMXTABLE FAR *)((char FAR *) pHdmxTable + pfc->cHdmxRecord))
            if (pfc->Mx11 == (int) pHdmxTable->ucEmY)
            {
              pfc->ulHdmxPosTable = pfnt->ulHdmxPos + (i * pfc->cHdmxRecord + sizeof (HDMXHEADER));
              break;
            }
        }
        ReleaseSFNT (pHdmx);
      }
    }

#endif // THIS_IS_WIN31_CODE_INTENDED_AS_COMMENT

STATIC VOID vFindHdmxTable(PFONTCONTEXT pfc)
{
    HDMXHEADER  *phdr = (HDMXHEADER  *)(
        (pfc->ptp->ateOpt[IT_OPT_HDMX].dp)                                   ?
        ((BYTE *)pfc->pff->pvView + pfc->ptp->ateOpt[IT_OPT_HDMX].dp) :
        NULL
        );

    UINT         cRecords;
    ULONG        cjRecord;

    HDMXTABLE    *phdmx, *phdmxEnd;
    LONG         yEmHt = pfc->lEmHtDev;

// assume failure, no hdmx table can be used:

    pfc->phdmx = NULL;

// first see if hdmx table is there at all:

    if (!phdr || !pfc->ptp->ateOpt[IT_OPT_HDMX].cj)
        return;

// if table is there but not necessary since the whole font scales
// linearly at all sizes, we will ignore it:

    //(phead->flags & SWAP(2))
    //    return;

// if transform is not such as to allow the use of hdmx table, return;

    ASSERTDD(pfc->flXform & (XFORM_HORIZ | XFORM_VERT),
        "vFindHdmxTable, bogus xform\n");

// if this is the version that we do not understand, return

    if (BE_UINT16(&phdr->Version) != 0)
        return;

    cRecords = BE_UINT16(&phdr->cRecords);
    cjRecord = (ULONG)SWAPL(phdr->cjRecord);

    ASSERTDD((cjRecord & 3) == 0, "cjRecord\n");

// if yEmHt > 255, can not fit in the byte, so there is no need to
// to search for the hdmx entry:

    if (yEmHt > 255)
        return;

// Finally, find out if there is something useful there.  Note that the
// table is sorted by size, so we can take an early out.

    phdmx = (HDMXTABLE *)(phdr + 1);
    phdmxEnd = (HDMXTABLE *)((PBYTE)phdmx + cRecords * cjRecord);

    for
    (
        ;
        phdmx < phdmxEnd;
        phdmx = (HDMXTABLE *)((PBYTE)phdmx + cjRecord)
    )
    {
        if (((BYTE) yEmHt) <= phdmx->ucEmY)
        {
            if (((BYTE) yEmHt) == phdmx->ucEmY)
                pfc->phdmx = phdmx; // We found it.
            break;
        }
    }
}

/******************************Public*Routine******************************\
*
* bGrabXform
*
*  updates buffers 0 and 4, those that save the state of the transform.
*  also for "buggy" fonts (URW FONTS) some of the transform dependent
*  info (twightlight points) may be stored in the buffer 3, which otherwise would be shareable
*  this is unfortunate, more memory is required
*
*
* History:
*  24-Mar-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL
bGrabXform (
    PFONTCONTEXT    pfc,
	USHORT          usOverScale,
    BOOL            bBitmapEmboldening,
    Fixed           subPosX,
    Fixed           subPosY
)
{
    BOOL bOk = TRUE;
    if ((pfc->pff->pfcLast != pfc) || (pfc->overScale != usOverScale) ||
        (pfc->subPosX != subPosX) || (pfc->subPosY != subPosY) ||
        ( (BOOL)(!!(pfc->flFontType & FO_CLEARTYPE_GRID)) != (BOOL)(!!(pfc->pgin->param.newtrans.flSubPixel & SP_SUB_PIXEL))) ||
        ( (BOOL)(!!(pfc->flFontType & FO_COMPATIBLE_WIDTH)) != (BOOL)(!!(pfc->pgin->param.newtrans.flSubPixel & SP_COMPATIBLE_WIDTH))) ||
        (bBitmapEmboldening != (BOOL)(!!(pfc->flXform & XFORM_BITMAP_SIM_BOLD)) ) )
    {

		/* set the overscale to the current one */
		pfc->overScale = usOverScale;

    // have to refresh the transform, somebody has changed it on us

        if (bOk = bSetXform(pfc, bBitmapEmboldening, subPosX, subPosY))
        {
        // affirm that we are the ones who have set the transform last

            pfc->pff->pfcLast = pfc;
        }
        else // make sure to restore the old current transform
        {
            if (pfc->pff->pfcLast)
            {
            #if DBG
                BOOL bOkXform =
            #endif
                bSetXform(pfc->pff->pfcLast, (pfc->flXform & XFORM_BITMAP_SIM_BOLD),
                    pfc->pff->pfcLast->subPosX, pfc->pff->pfcLast->subPosY);
                ASSERTDD(bOkXform, "bOkXform\n");
            }
        }

    }
    return (bOk);
}

/******************************Public*Routine******************************\
* vSetGrayState__FONTCONTEXT                                               *
*                                                                          *
* This routine set the FO_GRAYSCALE bit in pfc->flFontType and                *
* pfc->pfo->flFontType as is appropriate. If the bit is set                *
* then, later on, we shall make calls to the fs_FindGraySize and           *
* fs_ContourGrayScan pair instead of the usual monochrome pair of          *
* calls, fs_FindBitmapSize and fs_ContourScan.                             *
*                                                                          *
* The only effect that this routine could have is to clear                 *
* the FO_GRAYSCALE flags in pfc->flFontType and pfc->pfo->flFontType.         *
*                                                                          *
* The only way in which this clearing could occur is if all of the         *
* following conditions are met: 1) the caller has not set the              *
* FO_NO_CHOICE bit; 2) the font has a 'gasp' table; 3) the 'gasp'          *
* table indicates that for the requested number of pixels per em           *
* the 'gasp' table indicates that the font should not be grayed; 4)        *
* the glyphs of the font are not acted upon by a simple scaling            *
* transformation.                                                          *
*                                                                          *
* On Entry                                                                 *
*                                                                          *
*   pfc->flFontType & FO_GRAYSCALE      != 0                                  *
*   pfc->pfo->flFontType & FO_GRAYSCALE != 0                                  *
*                                                                          *
* Procedure                                                                *
*                                                                          *
*   1. if the force bit is on then go to 6.                                *
*   2. if the transformation is not axial then go to 6.                    *
*   3. if the font does not gave a 'gasp' table then go to 6.              *
*   4. if the gasp table says that this size is ok for graying then        *
*      go to 6.                                                            *
*   5. clear the FO_GRAYSCALE flags in both places                            *
*   6. return                                                              *
*                                                                          *
* History:                                                                 *
*  Fri 10-Feb-1995 14:02:51 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID vSetGrayState__FONTCONTEXT(FONTCONTEXT *this)
{
    #if DBG
        void vPrintGASPTABLE(GASPTABLE*);
    #endif

    ptrdiff_t dp;               // offset from the beginning of the font to the
                                // 'gasp' table
    GASPTABLE *pgasp;           // pointer to the 'gasp' table
    GASPRANGE *pgr, *pgrOut;

    ASSERTDD(
        this->flFontType == this->pfo->flFontType
      ,"flFontType value should be identical here\n"
    );
    ASSERTDD(
        !(this->flFontType & FO_CHOSE_DEPTH)
       ,"We should not have chosen a level at this time\n"
    );

    this->flFontType |= FO_CHOSE_DEPTH;
    if (this->flFontType & FO_GRAYSCALE)
    {
        if (this->flFontType & FO_SUBPIXEL_4)
            return;

        this->flFontType &= ~(FO_GRAYSCALE);
        if (this->flFontType & FO_NO_CHOICE)
        {
            this->flFontType |= FO_GRAYSCALE;
        }
        else
        {
            if (!(dp = (ptrdiff_t) (this->ptp->ateOpt[IT_OPT_GASP].dp)))
            {
                USHORT fs;

                // Win95 lifts the default GASP tables from the registry
                // We should have the same behavior. Bug #11755

                #define US2BE(x)     ((((x) >> 8) | ((x) << 8)) & 0xFFFF)
                static CONST USHORT gaspDefaultRegular[] = {
                    US2BE(0)    // version
                  , US2BE(3)    // numRanges
                  , US2BE(8)         , US2BE(GASP_DOGRAY)
                  , US2BE(17)        , US2BE(GASP_GRIDFIT)
                  , US2BE(USHRT_MAX) , US2BE(GASP_GRIDFIT + GASP_DOGRAY)
                };
                static CONST USHORT gaspDefaultBold[] = {
                    US2BE(0)     // version
                  , US2BE(2)     // numRanges
                  , US2BE(8)         , US2BE(GASP_DOGRAY)
                  , US2BE(USHRT_MAX) , US2BE(GASP_GRIDFIT + GASP_DOGRAY)
                };
                static CONST USHORT *gaspDefaultItalic = gaspDefaultRegular;

                fs = this->pff->ifi.fsSelection;
                if (fs & FM_SEL_ITALIC)
                {
                    pgasp = (GASPTABLE*) gaspDefaultItalic;
                }
                else if (fs & FM_SEL_BOLD)
                {
                    pgasp = (GASPTABLE*) gaspDefaultBold;
                }
                else
                {
                    pgasp = (GASPTABLE*) gaspDefaultRegular;
                }
            }
            else
            {
                pgasp = (GASPTABLE*) (((BYTE *)(this->pff->pvView)) + dp);
            }

            if (this->lEmHtDev > USHRT_MAX)
            {
                //WARNING("vSetGrayScale: lEmHtDev > USHRT_MAX\n");
            }
            else
            {
                size_t cRanges;
                int iLow, iHt, iHigh;

                // Search the gasp table for the instructions
                // for this particular em height. I have assumed that there
                // are not too many GASP tables (typically 3 or less) so
                // I use a linear search.

                pgr     = pgasp->gaspRange;
                cRanges = BE_UINT16(&(pgasp->numRanges));
                if (cRanges > 8)
                {
                    //WARNING("Unusual GASPTABLE : cRanges > 8\n");
                    cRanges = 8;
                }
                pgrOut = pgr + cRanges;
                iLow = -1;
                iHt  = this->lEmHtDev;
                for ( ; pgr < pgrOut; pgr++)
                {
                    iHigh = (int) BE_UINT16(&(pgr->rangeMaxPPEM));
                    if (iLow < iHt && iHt <= iHigh)
                    {
                        if (GASP_DOGRAY & BE_UINT16(&(pgr->rangeGaspBehavior)))
                        {
                            this->flFontType |= FO_GRAYSCALE;
                        }
                        break;
                    }
                    iLow = iHigh;
                }
            }
        }

        if (!(this->flFontType & FO_GRAYSCALE))
        {
            this->flFontType |= FO_NOGRAY16;
            this->pfo->flFontType = this->flFontType;
        }
    }

}

/******************************Public*Routine******************************\
* vSetClearTypeState__FONTCONTEXT                                          *
*                                                                          *
* This routine set the FO_GRAYSCALE bit in pfc->flFontType and                *
* pfc->pfo->flFontType as is appropriate. If the bit is set                *
*                                                                          *
* History:                                                                 *
*  15-Nov-1999 by Claude Betrisey [claudebe]                               *
* Wrote it.                                                                *
\**************************************************************************/
/**********************************************************************/

/*  Find a strike that matches ppem in the bloc table, simplified from scaler\sfntaccs.c */

static
BOOL fd_FindBlocStrike (
	const uint8 *pbyBloc,
	uint16 usPpem)
{
	uint32 ulNumStrikes = (uint32)SWAPL(*((uint32*)&pbyBloc[SFNT_BLOC_NUMSIZES]));
	uint32 ulStrikeOffset = SFNT_BLOC_FIRSTSTRIKE;

    uint16 usNumberBitmaps = 0;
    /* we want to turn off ClearType only if font has a significant number of embedded bitmaps, e.g. >100 */

	while (ulNumStrikes > 0)
	{
		if ((usPpem == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMX]) &&
			(usPpem == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMY]))
		{
	        uint32 ulNumIndexTables = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_NUMINDEXTABLES]));
	        uint32 ulIndexArrayTop  = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_INDEXARRAYOFFSET]));
	        uint32 ulIndexArrayOffset = ulIndexArrayTop;

	        while (ulNumIndexTables > 0)
            {
		        uint16 usFirstGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_FIRSTGLYPH]));
		        uint16 usLastGlyph  = (uint16)SWAPW(*((uint16*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_LASTGLYPH]));
                usNumberBitmaps += (usLastGlyph - usFirstGlyph + 1);
                if (usNumberBitmaps > 100)
                    return TRUE;

		        ulNumIndexTables--;    
		        ulIndexArrayOffset += SIZEOF_BLOC_INDEXARRAY;
            }
		}
		ulNumStrikes--;
		ulStrikeOffset += SIZEOF_BLOC_SIZESUBTABLE;
	}

	return FALSE;                                   /* match not found */
}

VOID vSetClearTypeState__FONTCONTEXT(FONTCONTEXT *this)
{

    /* we want to turn off ClearType only if font has a significant number of embedded bitmaps, e.g. >100 */

    ptrdiff_t dp;               // offset from the beginning of the font to the
                                // 'EBLC' table
    uint8 *pEBLC;           // pointer to the 'EBLC' table

    ASSERTDD(
        this->flFontType == this->pfo->flFontType
      ,"flFontType value should be identical here\n"
    );
    ASSERTDD(
        !(this->flFontType & FO_CHOSE_DEPTH)
       ,"We should not have chosen a level at this time\n"
    );

    this->flFontType |= FO_CHOSE_DEPTH;

    if ((this->flXform & (XFORM_HORIZ | XFORM_VERT)) && 
        ((this->mx.transform[0][0] == this->mx.transform[1][1]) || (this->mx.transform[0][0] == -this->mx.transform[1][1]) ) &&
        ((this->mx.transform[0][1] == this->mx.transform[1][0]) || (this->mx.transform[0][1] == -this->mx.transform[1][0])) )
    {
        /* we only want to look for embedded bitmap if we are in a square transformation that is a multiple of 90 degree rotation */
        /* we want to turn off ClearType only if font has a significant number of embedded bitmaps, e.g. >100 */
        if ((dp = (ptrdiff_t)(this->ptp->ateOpt[IT_OPT_EBLC].dp)))
        {
            pEBLC = (uint8*) (((BYTE *)(this->pff->pvView)) + dp);

		    if (fd_FindBlocStrike (pEBLC, (uint16)this->lEmHtDev))
		    {
	            this->flFontType &= ~(FO_GRAYSCALE | FO_CLEARTYPE_GRID);
	            this->flFontType |= FO_NOCLEARTYPE;
	            this->pfo->flFontType = this->flFontType;
	        }
        }
    }

    // we want to disable ClearType for the Marlett font
    if (!UnicodeStringCompareCI((PWSTR)((BYTE*)&this->pff->ifi + this->pff->ifi.dpwszFamilyName),L"Marlett"))
    {
	        this->flFontType &= ~(FO_GRAYSCALE | FO_CLEARTYPE_GRID);
	        this->flFontType |= FO_NOCLEARTYPE;
	        this->pfo->flFontType = this->flFontType;
    }

}

#if DBG
/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   vPrintGASPTABLE                                                        *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Dumps a GASPTABLE to the debug screen                                  *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pgasp   --  pointer to a big endian GASPTABLE                          *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   none                                                                   *
*                                                                          *
\**************************************************************************/

void vPrintGASPTABLE(GASPTABLE *pgasp)
{
    GASPRANGE *pgr, *pgrOut;

    TtfdDbgPrint(
        "\n"
        "-------------------------------------\n"
        "GASPTABLE HEADER\n"
        "-------------------------------------\n"
        "pgasp     = %-#x\n"
        "version   = %d\n"
        "numRanges = %d\n"
        "-------------------------------------\n"
        "    rangeMaxPPEM    rangeGaspBehavior\n"
        "-------------------------------------\n"
       , pgasp
       , BE_UINT16(&(pgasp->version))
       , BE_UINT16(&(pgasp->numRanges))
    );
    pgr     = pgasp->gaspRange;
    pgrOut  = pgr + BE_UINT16(&(pgasp->numRanges));
    for (pgr = pgasp->gaspRange; pgr < pgrOut; pgr++)
    {
        char *psz;
        USHORT us = BE_UINT16(&(pgr->rangeGaspBehavior));
        us &= (GASP_GRIDFIT | GASP_DOGRAY);
        switch (us)
        {
        case 0:
            psz = "";
            break;
        case GASP_GRIDFIT:
            psz = "GASP_GRIDFIT";
            break;
        case GASP_DOGRAY:
            psz = "GASP_DOGRAY";
            break;
        case GASP_GRIDFIT | GASP_DOGRAY:
            psz = "GASP_GRIDFIT | GASP_DOGRAY";
            break;
        }
        TtfdDbgPrint(
            "    %12d    %s\n"
          , BE_UINT16(&(pgr->rangeMaxPPEM))
          , psz
        );
    }
    TtfdDbgPrint(
        "-------------------------------------\n\n\n"
    );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\service.h ===
/******************************Module*Header*******************************\
* Module Name: service.h
*
* routines in service.c
*
* Created: 15-Nov-1990 13:00:56
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
*
\**************************************************************************/



VOID vCpyBeToLeUnicodeString(LPWSTR pwcLeDst, LPWSTR pwcBeSrc, ULONG c);


VOID  vCpyMacToLeUnicodeString
(
ULONG  ulLangId,
LPWSTR pwcLeDst,
PBYTE  pjSrcMac,
ULONG  c
);

VOID  vCvtMacToUnicode
(
ULONG  ulLangId,
LPWSTR pwcLeDst,
PBYTE  pjSrcMac,
ULONG  c
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\gdistubs.c ===
/******************************Module*Header*******************************\
* Module Name: fd-stubs.c                                                  *
*                                                                          *
* Stubs for tricking GDI font files into compiling                         *
*                                                                          *
* Created: 1-June-1999                                                     *
* Author: Cameron Browne                                                   *
*                                                                          *
* Copyright (c) 1999 Microsoft Corporation                                 *
\**************************************************************************/


#include "fd.h"
//#include "fdsem.h"
//#include "dbg.h"
//#include "fdfc.h"
#include "fontddi.h"   // modified subset of winddi.h

#include <Math.h> /* for sqrt */

#include "..\..\..\runtime\mem.h"

#if 0
void * __stdcall GpMalloc( size_t size );
void * __stdcall GpRealloc( void *memblock, size_t size );
void __stdcall GpFree( void *memblock );
#endif

HSEMAPHORE APIENTRY EngCreateSemaphore(
    VOID
    )
{
    return NULL;
}

VOID APIENTRY EngAcquireSemaphore(
    HSEMAPHORE hsem
    )
{
}


VOID APIENTRY EngReleaseSemaphore(
    HSEMAPHORE hsem
    )
{
}

VOID APIENTRY EngDeleteSemaphore(
    HSEMAPHORE hsem
    )
{
}

VOID APIENTRY EngDebugBreak(
    VOID
    )
{
    RIP( ("TrueType font driver debug break"));
}

PVOID APIENTRY EngAllocMem(
    ULONG Flags,
    ULONG MemSize,
    ULONG Tag
    )
{
    return GpMalloc(MemSize);
}

VOID APIENTRY EngFreeMem(
    PVOID Mem
    )
{
    GpFree(Mem);
}

PVOID APIENTRY EngAllocUserMem(
    SIZE_T cj,
    ULONG tag
    )
{
    return GpMalloc(cj);
}

VOID APIENTRY EngFreeUserMem(
    PVOID pv
    )
{
    GpFree(pv);
}

int APIENTRY EngMulDiv(
    int a,
    int b,
    int c
    )
{
    LONGLONG ll;
    int iSign = 1;

    if (a < 0)
    {
        iSign = -iSign;
        a = -a;
    }
    if (b < 0)
    {
        iSign = -iSign;
        b = -b;
    }

    if (c != 0)
    {
        if (c < 0)
        {
            iSign = -iSign;
            c = -c;
        }

        ll = (LONGLONG)a;
        ll *= b;
        ll += (c/2); // used to add (c+1)/2 which is wrong
        ll /= c;

    // at this point ll is guaranteed to be > 0. Thus we will do
    // unsigned compare in the next step which generates two less instructions
    // on x86 [bodind]

        if ((ULONGLONG)ll > (ULONG)INT_MAX) // check for overflow:
        {
            if (iSign > 0)
                return INT_MAX;
            else
                return INT_MIN;
        }
        else
        {
            if (iSign > 0)
                return ((int)ll);
            else
                return (-(int)ll);
        }
    }
    else
    {
//        ASSERTGDI(c, "EngMulDiv - c == 0\n");
//        ASSERTGDI(a | b, "EngMulDiv - a|b == 0\n");

        if (iSign > 0)
            return INT_MAX;
        else
            return INT_MIN;
    }
}

BOOL APIENTRY EngLpkInstalled()
{
    return FALSE;
}

/******************************Public*Routine******************************\
*
* bFDXform, transform an array of points, output in POINTFIX
*
* Effects:
*
* Warnings:
*
* History:
*  05-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/
#define FIX4_PRECISION  4
#define FIX4_ONE        (1 << FIX4_PRECISION)

FIX RealToPointFix(
    EFLOAT        realValue
    )
{
    return (FIX)(realValue * FIX4_ONE);
}


BOOL bFDXform(
    XFORML    *pxf
  , POINTFIX *pptfxDst
  , POINTL   *pptlSrc
  , SIZE_T    c
    )
{
    BOOL bRet;
    EFLOAT ef11;
    EFLOAT ef12;
    EFLOAT ef21;
    EFLOAT ef22;

    ef11 = pxf->eM11;
    ef12 = pxf->eM12;
    ef21 = pxf->eM21;
    ef22 = pxf->eM22;

    bRet = FALSE;

    if ( ef12 == 0.0 && ef21 == 0.0) {
        for ( ; c ; pptfxDst++, pptlSrc++, c--) {

            EFLOAT ef;

            ef = (EFLOAT)pptlSrc->x;
            ef *= ef11;
            pptfxDst->x = RealToPointFix( ef );

			ef = (EFLOAT)pptlSrc->y;
            ef *= ef22;
            pptfxDst->y = RealToPointFix( ef );
        }
        bRet = TRUE;
    } else {
        for ( ; c ; pptfxDst++, pptlSrc++, c--) {
            EFLOAT efX;
            EFLOAT efY;
            EFLOAT ef1;
            EFLOAT ef2;

            efX = (EFLOAT)pptlSrc->x;
            efY = (EFLOAT)pptlSrc->y;

            ef1  = efX;
            ef1 *= ef11;
            ef2  = efY;
            ef2 *= ef21;
            ef2 += ef1;

            pptfxDst->x = RealToPointFix( ef2 );

            ef1  = efX;
            ef1 *= ef12;
            ef2  = efY;
            ef2 *= ef22;
            ef2 += ef1;

            pptfxDst->y = RealToPointFix( ef2 );
        }
        bRet = TRUE;
    }
    return( bRet );
}

/******************************Public*Routine******************************\
*
* bXformUnitVector
*
* xform vector by pfdxo, compute the unit vector of the transformed
* vector and the norm of the transformed vector. Norm and the transformed
* vector are multiplied by 16 so that when converting to long the result
* will acutally be a 28.4 fix
*
* Effects:
*
* Warnings:
*
* History:
*  01-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bXformUnitVector(
      POINTL *pptl           // IN  incoming unit vector
 ,    XFORML *pxf            // IN  xform to use
 ,    EFLOAT *pefNorm        // OUT |*pptqXormed|
    )
{
    EFLOAT efX_;
    EFLOAT efY_;
    BOOL b = TRUE;

    EFLOAT ef11;
    EFLOAT ef12;
    EFLOAT ef21;
    EFLOAT ef22;
    EFLOAT efX;
    EFLOAT efY;
    //
    // Convert longs to FIX point
    //

    efX = (EFLOAT)16.0 * (EFLOAT)pptl->x;
    efY = (EFLOAT)16.0 * (EFLOAT)pptl->y;

    //
    // Convert the matrix elements from FLOAT to EFLOAT
    //

    ef11 = pxf->eM11;
    ef12 = pxf->eM12;
    ef21 = pxf->eM21;
    ef22 = pxf->eM22;

    //
    // Transform the vector and put the result in efX_ and efY_
    //

    if ( ef12 == 0.0 && ef21== 0.0 ) {
        efX_  = efX;
        efX_ *= ef11;
        efY_  = efY;
        efY_ *= ef22;
    } else {
        EFLOAT ef;

        efX_  = efX;
        efX_ *= ef11;
        ef    = efY;
        ef   *= ef21;
        efX_ += ef;

        ef    = efX;
        ef   *= ef12;
        efY_  = efY;
        efY_ *= ef22;
        efY_ += ef;
    }

    // get the norm

    efX_ *= efX_;
    efY_ *= efY_;
    efX_ += efY_;
    efX_ = (EFLOAT)sqrt(efX_);

    *pefNorm = efX_;

    return b; 
}

/******************************Public*Routine******************************\
*
* vLTimesVtfl
*
* Effects:
*
* Warnings:
*
* History:
*  05-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID vLTimesVtfl     // *pptq = l * pvtfl, *pptq is in 28.36 format
(
LONG       l,
VECTORFL  *pvtfl,
POINTQF  *pptq
)
{
    LONGLONG dx, dy;

//    EVECTORFL  vtfl;
//    EFLOAT     ef; ef = l;
//    vtfl.x.eqMul(pvtfl->x,ef);
//    vtfl.y.eqMul(pvtfl->y,ef);

    dx = (LONGLONG)(pvtfl->x * (EFLOAT)l);
    dy = (LONGLONG)(pvtfl->y * (EFLOAT)l);

    pptq->x.HighPart = (LONG) (((LARGE_INTEGER*)(&dx))->LowPart);
    pptq->x.LowPart = 0;
    pptq->y.HighPart = (LONG) (((LARGE_INTEGER*)(&dy))->LowPart);
    pptq->y.u.LowPart = 0;

// convert to 28.36 format. The incoming vector will already have been
// multliplied by 16 to ensure that the result is in the 28.36

//    *pptq = vtfl;
}

#if defined(_X86_)

VOID   vLToE(FLOATL * pe, LONG l)
{
    *pe = (FLOATL)l;
}

#endif // _X86_



/******************************Public*Function*****************************\
* bFToL                                                                    *
*                                                                          *
* Converts an IEEE 747 float to a LONG. The form of the conversion is      *
* specified by the caller.                                                 *
*                                                                          *
*  Arguments                                                               *
*                                                                          *
*      e                    IEEE 747 32-bit float to be converted          *
*                                                                          *
*      pl                   pointer to where answer should be placed       *
*                                                                          *
*      lType                contains bits specifying the type of           *
*                           conversion to be done this can be any          *
*                           combination of the following bits:             *
*                                                                          *
*                           CV_TO_FIX   if this bit is set then            *
*                                       the answer should                  *
*                                       should be in the form              *
*                                       of a 28.4 fix point number         *
*                                       otherwise the answer is            *
*                                       to be interpreted as a 32-bit      *
*                                       LONG                               *
*                                                                          *
*                           CV_TRUNCATE if this bit is set then the        *
*                                       answer is floor(e)                 *
*                                       (if CV_TO_FIX is not set) or       *
*                                       floor(16 * e)                      *
*                                       (if CV_TO_FIX is set)              *
*                                                                          *
*  Theory                                                                  *
*                                                                          *
*  An IEEE 747 float is contained in 32 bits which for the                 *
*  purposes of this discussion I shall call "e". e is                      *
*  equivalent to                                                           *
*                                                                          *
*      e = (-1)^s * mu * 2^E                                               *
*                                                                          *
*  s is the sign bit that is contained in the 31'st bit of e.              *
*  mu is the mantissa and E is the exponetial. These are obtained          *
*  from e in the following way.                                            *
*                                                                          *
*      s = e & 0x80000000 ? -1 : 1                                         *
*                                                                          *
*      mu = M * 2^-23      // 2^23 <= M < 2^24                             *
*                                                                          *
*      M = 0x800000 | (0x7FFFFF & e)                                       *
*                                                                          *
*      E = ((0x7F800000 & e) * 2^-23) - 127                                *
*                                                                          *
*  Suppose the 32.32 Fix point number is Q, then the relation              *
*  between the float and the 32.32 is given by                             *
*                                                                          *
*      Q = e * 2^32 = s * M * 2^(E+9)                                      *
*                                                                          *
* History:                                                                 *
*  Tue 15-Aug-1995 10:36:31 by Kirk Olynyk [kirko]                         *
* Rewrote it                                                               *
*                                                                          *
*  03-Jan-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

#define CV_TRUNCATE     1
#define CV_ROUNDOFF     2
#define CV_TO_LONG      4
#define CV_TO_FIX       8

BOOL bFToL(FLOAT e, PLONG pl, LONG lType)
{
    LONGLONG Q;         // 32.32 repn of abs(e)
    LONG E;             // used to hold exponent then integer parts
    LONG le;            // bit identical to FLOAT argument e
    BOOL bRet = TRUE;   // return value

    le = *(LONG*)&e;                                    // get IEEE 747 bits
    E = (int) (((0x7f800000 & le) >> 23) - 127) + 9;    // E = exponent
    if (lType & CV_TO_FIX)                              // if (want FIX point)
        E += 4;                                         //     multiply by 16
    if (E > (63-23))                                    // if (overflow)
    {                                                   //     bail out
        bRet = FALSE;
    }
    else
    {
        Q = (LONGLONG) (0x800000 | (0x7FFFFF & le));    // abs val of mantissa
        Q = (E >= 0) ? Q << E : Q >> -E;                // account for exponent
        if (!(lType & CV_TRUNCATE))                     // if (rounding) then
            Q += 0x80000000;                            //     add 1/2
        E = (long) (Q >> 32);                           // E = abs(integer part)
        *pl = (le < 0) ? -E : E;                        // fix up sign
    }
    return(bRet);
};



LONG lCvt(FLOAT f,LONG l)
{
    LONG l_ = 0;
    bFToL(f * l, &l_, 0);
    return(l_);
}

FIX  fxLTimesEf
(
EFLOAT *pef,
LONG    l
)
{
// *pef is a norm, already multiplied by 16 to ensure that the result
// is in 28.4 format

    l = lCvt((*pef), l);
    return (FIX)l;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\service.c ===
/******************************Module*Header*******************************\
* Module Name: service.c
*
* set of service routines for converting between ascii and  unicode strings
*
* Created: 15-Nov-1990 11:38:31
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/


#include "fd.h"

/******************************Public*Routine******************************\
*
* vCpyBeToLeUnicodeString,
*
* convert (c - 1) WCHAR's in big endian format to little endian and
* put a terminating zero at the end of the dest string
*
* History:
*  11-Dec-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID vCpyBeToLeUnicodeString(LPWSTR pwcLeDst, LPWSTR pwcBeSrc, ULONG c)
{
    LPWSTR pwcBeSrcEnd;

    ASSERTDD(c > 0, "vCpyBeToLeUnicodeString: c == 0\n");

    for
    (
        pwcBeSrcEnd = pwcBeSrc + (c - 1);
        pwcBeSrc < pwcBeSrcEnd;
        pwcBeSrc++, pwcLeDst++
    )
    {
        *pwcLeDst = BE_UINT16(pwcBeSrc);
    }
    *pwcLeDst = (WCHAR)(UCHAR)'\0';

}



/******************************Public*Routine******************************\
*
* VOID  vCvtMacToUnicode
*
* Effects:
*
* Warnings:
*
* History:
*  07-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




VOID  vCvtMacToUnicode
(
ULONG  ulLangId,
LPWSTR pwcLeDst,
PBYTE  pjSrcMac,
ULONG  c
)
{
    PBYTE pjSrcEnd;

//!!! I believe that LangId should be used to select the proper conversion
//!!! routine, this is a stub [bodind]

    ulLangId;

    for
    (
        pjSrcEnd = pjSrcMac + c;
        pjSrcMac < pjSrcEnd;
        pjSrcMac++, pwcLeDst++
    )
    {
        *pwcLeDst = (WCHAR)(*pjSrcMac);
    }
}

/******************************Public*Routine******************************\
*
* VOID  vCpyMacToLeUnicodeString
*
*
* Ensures that string is zero terminated so that other cool things can be
* done to it such as wcscpy, wcslen e.t.c.
*
* History:
*  13-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID  vCpyMacToLeUnicodeString
(
ULONG  ulLangId,
LPWSTR pwcLeDst,
PBYTE  pjSrcMac,
ULONG  c
)
{
    ASSERTDD(c > 0, "vCpyMacToLeUnicodeString: c == 0\n");

    c -= 1;
    vCvtMacToUnicode (ulLangId, pwcLeDst, pjSrcMac, c);
    pwcLeDst[c] = (WCHAR)(UCHAR)'\0';
}


/**************************************************************************\
* The rest of the file is stolen from JeanP's win31 code in fd_mac.c
*
* Conversion routines from Mac character code and Mac langageID to
* Unicode character code and OS2 langage ID
*
* Public routines:
*   Unicode2Mac
*   Mac2Lang
*
\**************************************************************************/



/*
** Converts the OS2 langageID to the to the Mac langage ID
*/

#ifdef JEANP_IS_WRONG

// JEANp messed up danish and german, else my conversion table is the
// same as mine [bodind]

uint16  aCvLang [32] =
{
   0, 12,  0,  0,  0,  0,  0,  7,
  14,  0,  6, 13,  1, 10,  0, 15,
   3, 11, 21,  4,  9,  0,  8,  0,
   0,  0, 18,  0,  0,  5, 22, 17
};

#endif // JEANP_IS_WRONG

uint16  aCvLang [32] =
{
   0,     //  0 -> 0  (0           -> english == default)
  12,     //  1 -> 12 (arabic      -> arabic)
   0,     //  2 -> 0  (bulgarian   -> english == default)
   0,     //  3 -> 0  (catalon     -> english == default)
   0,     //  4 -> 0  (Chinese     -> english == default)
   0,     //  5 -> 0  (Czeh        -> english == default)
   7,     //  6 -> 7  (Danish      -> Danish)
   2,     //  7 -> 2  (German      -> German)
  14,     //  8 -> 14 (Greek       -> Greek)
   0,     //  9 -> 0  (English     -> english)
   6,     //  a -> 6  (spanish     -> spanish)
  13,     //  b -> 13 (finnish     -> finnish)
   1,     //  c -> 1  (french      -> french)
  10,     //  d -> 10 (hebrew      -> hebrew)
   0,     //  e -> 0  (hungarian   -> english == default)
  15,     //  f -> 15 (icelandic   -> icelandic)
   3,     // 10 -> 3  (Italian     -> italian)
  11,     // 11 -> 11 (japanese    -> japanese)
  21,     // 12 -> 21 (korean      -> hindi, this seems to be a bug?????????)
   4,     // 13 -> 4  (dutch       -> dutch)
   9,     // 14 -> 9  (norweign    -> norweign)
   0,     // 15 -> 0  (Polish      -> english == default)
   8,     // 16 -> 8  (portugese   -> portugese)
   0,     // 17 -> 0  (rhaeto-romanic -> english == default)
   0,     // 18 -> 0  (romanian    -> english == default)
   0,     // 19 -> 0  (russian     -> english == default)
  18,     // 1a -> 18 (Yugoslavian -> Yugoslavian), lat or cyr ????
   0,     // 1b -> 0  (slovakian   -> english == default)
   0,     // 1c -> 0  (albanian    -> english == default)
   5,     // 1d -> 5  (swedish     -> swedish)
  22,     // 1e -> 22 (thai        -> thai)
  17      // 1f -> 17 (turkish     -> turkish)
};



/************************** Public Routine *****************************\
*  Mac2Lang
*
* Converts the OS2 langageID to the to the Mac langage ID
*
* History:
*  Fri Dec 08 11:28:35 1990    -by-    Jean-Francois Peyroux [jeanp]
* Wrote it.
\***********************************************************************/

uint16 ui16Mac2Lang (uint16 Id)
{
// this is just a way to bail out if an incorrect lang id is passed to
// this routine [bodind]
// Note that Id & 1f < 32 == sizeof(aCvLang)/sizeof(aCvLang[0]), no gp-fault

    return aCvLang[Id & 0x1f];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\fontfile.h ===
/******************************Module*Header*******************************\
* Module Name: fontfile.h
*
* FONTFILE and FONTCONTEXT objects
*
* Created: 25-Oct-1990 09:20:11
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
*
\**************************************************************************/


#include "xform.h"


// cjIFI - size of the whole ifimetrics struct, with all strings appended
// cjFamilyName
// cjFaceName
// cjUniqueName
// cjSubfamilyName


typedef struct _IFISIZE  // ifisz
{
    ULONG cjIFI;    // total size of GP_IFIMETRICS
                    // together with data structure that follows it

    // pointers to the locations in the ttf file
    PBYTE pjFamilyName;
    PBYTE pjFamilyNameAlias;
    PBYTE pjSubfamilyName;
    PBYTE pjUniqueName;
    PBYTE pjFullName;

    // sizes, in bytes, in the ttf file, without terminating zero
    ULONG cjFamilyName;
    ULONG cjFamilyNameAlias;
    ULONG cjSubfamilyName;
    ULONG cjUniqueName;
    ULONG cjFullName;

    // offsets, in bytes, relative to GP_IFIMETRICS
    ULONG dpFamilyName;
    ULONG dpFamilyNameAlias;
    ULONG dpSubfamilyName;
    ULONG dpUniqueName;
    ULONG dpFullName;

    // sizes, in bytes, of the names converted to unicode, including terminating zero
    ULONG cbFamilyName;
    ULONG cbFamilyNameAlias;
    ULONG cbSubfamilyName;
    ULONG cbUniqueName;
    ULONG cbFullName;

    ULONG dpSims;          // offset of the FONTSIM struct

    USHORT langID;
    USHORT aliasLangID;

    // bComputeIFISIZE call arguments
    USHORT ui16PlatID;
    USHORT ui16SpecID;

} IFISIZE, *PIFISIZE;


typedef struct _TT_FONTFILE       *PFONTFILE;     // pff
typedef struct _TT_FONTCONTEXT    *PFONTCONTEXT;  // pfc
typedef struct _TTC_FONTFILE   *PTTC_FONTFILE; // pttc


// in the debug version of the rasterizer STAMPEXTRA shoud be added to the
// sizes. strictly speaking this is illegal, but nevertheless very useful.
// it assumes the knowlege of rasterizer internalls [bodind],
// see fscaler.c

#define STAMPEXTRA 4


#define CJ_0  NATURAL_ALIGN(sizeof(fs_SplineKey) + STAMPEXTRA)

#define FF_EXCEPTION_IN_PAGE_ERROR 1

// set if any DBCS charset is supported

#define FF_DBCS_CHARSET        256

typedef struct _FFCACHE
{
//
// Move it from FONTFILE. We will cache it into TTCACHE.
//

    TABLE_POINTERS  tp;

    ULONG           ulTableOffset;

// FE vertical facename support

    ULONG           ulVerticalTableOffset; 
    uint16          uLongVerticalMetrics;

    ULONG           ulNumFaces;       // 1 or at most 2 if this is a FE font, (foo and @foo)

    ULONG           cj3;     // request memorySizes[3],   
    ULONG           cj4;     // request memorySizes[4],     

// some general flags, for now only exception info, such as in_page_err

    FLONG           fl;

    ULONG           dpMappingTable;

// make it simple to access the ttf file

    uint16          ui16EmHt;
    uint16          ui16PlatformID;
    uint16          ui16SpecificID;
    uint16          ui16LanguageID;

} FFCACHE;

typedef struct _TT_FONTFILE    // ff
{
    PTTC_FONTFILE pttc;


    GP_PIFIMETRICS pifi_vertical;

    PBYTE        pj034;   // 0,3,4 buffers
    PFONTCONTEXT pfcLast; // last fc that set 034 buffers

// mem to be freed if file disappeared while trying to open font context
// only used in exception scenarios

    PFONTCONTEXT pfcToBeFreed;

    ULONG cRef;    // # no of times this font file is selected into fnt context

    ULONG_PTR iFile; // contains a pointer
    PVOID  pvView;   // contains the pointer to the top of ttf
    ULONG  cjView;  // contains size of the font file

    FFCACHE ffca;

// Note:
// The way memory is allocated for the FONTFILE structure, the IFIMETRICS
// MUST BE THE LAST ELEMENT of the structure!

    GP_IFIMETRICS   ifi;         //!!! should it not this be put on the disk??? [bodind]

} FONTFILE;


typedef struct _TTC_CACHE
{
    FLONG       flTTCFormat;
    ULONG       cTTFsInTTC;       // number of TTF's in this TTC (or one if this is a TTF file)
    DWORD       dpTTF[1];         // there will be cTTFsInTTC of these offsets in the array
} TTC_CACHE,    *PTTC_CACHE;

// we will have one of these for every TTF in a TTC. Therefore ulNumFaces can be at most 2,
// for foo and @foo faces. cjIFI is the size of either IFIMETRICS corresponding
// to foo or @foo faces (we allocate the same size for foo and @foo IFIMETRICS structures).
// cjIFI is is NOT the sum of the sizes of the two IFIMETRICS.

typedef struct _TTF_CACHE
{
    FFCACHE      ffca;       // shared data between foo and @foo faces

// we store the ifimetrics for foo face starting here, followed by the the ifimetrics for
// @foo face if there is one, followed by gset for foo face. For now we do not store gsetv,
// but compute it dynamically

    double      acIfi[1];    // really a byte array but now compiler guarantees QUAD alignment

} TTF_CACHE, *PTTF_CACHE;

// the values for iSearchVerticalGlyph

#define SUB_FUNCTION_DUMMY 0
#define SUB_FUNCTION_GSUB  1
#define SUB_FUNCTION_MORT  2

//
// TrueType collection 'ttc' font file support
//

typedef struct _TTC_HFF_ENTRY
{
    ULONG     ulOffsetTable;
    ULONG     iFace;
    HFF       hff;
} TTC_HFF_ENTRY, *PTTC_HFF_ENTRY;

typedef struct _TTC_FONTFILE    // ttcff
{
    ULONG         cRef;
    FLONG         fl;
    ULONG         ulTrueTypeResource;
    ULONG         ulNumEntry;
    PVOID         pvView;
    ULONG         cjView;
    TTC_HFF_ENTRY ahffEntry[1];
} TTC_FONTFILE, *PTTC_FONTFILE;


#define CJ_IN      NATURAL_ALIGN(sizeof(fs_GlyphInputType))
#define CJ_OUT     NATURAL_ALIGN(sizeof(fs_GlyphInfoType))


/**************************************************************************\

         GLYPHSTATUS structure

// handle of the last glyph that has been processed and a boolean
// which indicates whether metric info for a bitmap corresponding
// to that glyph has been computed

\**************************************************************************/

typedef struct _GLYPHSTATUS
{
    HGLYPH hgLast;
    ULONG  igLast;       // corresponding glyph index, rasterizer likes it better
    PVOID  pv;           // pointer to mem allocated just for the purpose of
                         // or producing bitmap or the outline for this glyph
} GLYPHSTATUS, *PGLYPHSTATUS;

// "method" acting on this "object"

VOID vInitGlyphState(PGLYPHSTATUS pgstat);

// HDMX stuff, from fd_royal.h in win31 sources:

typedef struct
{
  BYTE     ucEmY;
  BYTE     ucEmX;          // MAX advance width for this EmHt;
  BYTE     aucInc [1];     // maxp->numGlyphs of entries
} HDMXTABLE;        // hdmx

typedef struct
{
  uint16            Version;    // table version number, starts at zero
  uint16            cRecords;
  uint32            cjRecord;   // dword aligned size of individual record,
                                // all of them have the same size

// after this records follow:

  // HDMXTABLE         HdmxTable [cRecords]
} HDMXHEADER;  // hdhdr

// to get to the next record one does the following:
// phdmx = (HDMXTABLE *)((BYTE *)phdmx + phdhdr->cjRecord);

// 'gasp' structures

typedef struct
{
    uint16  rangeMaxPPEM;
    uint16  rangeGaspBehavior;
} GASPRANGE;

typedef struct
{
    uint16  version;
    uint16  numRanges;
    GASPRANGE   gaspRange[1];
} GASPTABLE;

#define GASP_GRIDFIT    0x0001
#define GASP_DOGRAY     0x0002

/**************************************************************************\
 *  FONTCONTEXT structure
\**************************************************************************/

typedef struct _TT_FONTCONTEXT     // fc
{
    FONTOBJ*  pfo;          // points back to calling FONTOBJ
    PFONTFILE pff;          // handle of the font file selected into this context

// handle of the last glyph that has been processed and a boolean
// which indicates whether metric info for a bitmap corresponding
// to that glyph has been computed

    GLYPHSTATUS gstat;

// parts of FONTOBJ that are important

    FLONG   flFontType;
    SIZE    sizLogResPpi;
    ULONG   ulStyleSize;

// transform matrix in the format as requested by the font scaler
// the FONTOBJ and XFORMOBJ (in the form of the XFORM) fully specify
// the font context for the realization

    XFORML      xfm;          // cached xform
    transMatrix mx;           // the same as above, just a different format
    FLONG       flXform;

// if it were not for win31 vdmx hacks this field would not be necessary,

    LONG   lEmHtDev;          // em height in pixels in device space
    Fixed  fxPtSize;          // em height in points on the rendering device

// pointer to the hdmx table that applies if any, else NULL

    HDMXTABLE *phdmx;

// asc and desc measured along unit ascender vector in device coords.
// Unit ascender vector in device coords == xForm(0,-1)/|xForm(0,-1)|

    LONG  lAscDev;
    LONG  lDescDev;

// xMin and xMax in device coords for grid fitted glyphs, cxMax = xMax - xMin

    LONG  xMin;
    LONG  xMax;

// asender and descender in device coords for grid fitted glyphs
// cyMax = yMax - yMin;

    LONG  yMin;
    LONG  yMax;

// max width in pixels of all rasterized bitmaps

    ULONG cxMax;
    ULONG cyMax;

// the size of the GLYPHDATA structure necessary to store the largest
// glyph bitmap with the header info. This is value is cashed at the
// time the font context is opened and used later in FdQueryGlyphBitmap

    ULONG cjGlyphMax;  // in BYTE's

// tt structures, they live in pff->cj034

    fs_GlyphInputType *pgin;
    fs_GlyphInfoType  *pgout;

    PTABLE_POINTERS     ptp;

// a few fields that are realy only necessary if the xform is
// non trivial, cached here to speed up metric computations for glyphs:

    EFLOAT   efBase;        // |ptqBase|, enough precission

    EFLOAT   efSide;        // |ptqSide|, enough precission

    Fixed    pointSize;     // for fs_NewTransformation

// for font emboldening, most glyphs will use global emboldening info,
// only those glyphs which extend to descender will have to
// use different emb.

    USHORT  dBase;

// TrueType Rasterizer 1.7 require the overScale (for antialiazed text) to be passed to fs_NewTransformation
// we need to keep track of this value to pass it at fs_NewTransform

	USHORT  overScale;

    Fixed   subPosX;
    Fixed   subPosY;

} FONTCONTEXT;

/* fc->overscale get first set to FF_UNDEFINED_OVERSCALE and at fs_NewTransform get set to the current one */
#define FF_UNDEFINED_OVERSCALE 0x0FFFF

// flags describing the transform, may change a bit,
// quantized bit means that the original xform has been
// changed a bit to take into account vdmx quantization

#define XFORM_HORIZ           1
#define XFORM_VERT            2
#define XFORM_VDMXEXTENTS     4
#define XFORM_SINGULAR        8
#define XFORM_2PPEM	     32
#define XFORM_BITMAP_SIM_BOLD  128


// basic "methods" that act on the FONTFILE object  (in fontfile.c)

#define   PFF(hff)      ((PFONTFILE)hff)
#define   pffAlloc(cj)  ((PFONTFILE)EngAllocMem(0, cj, 'dftT'))
#define   vFreeFF(hff)  EngFreeMem((PVOID)hff)

// basic "methods" that act on the TTC_FONTFILE object

#define   PTTC(httc)     ((PTTC_FONTFILE)httc)
#define   pttcAlloc(cj)  ((PTTC_FONTFILE)EngAllocMem(FL_ZERO_MEMORY, cj, 'dftT'))
#define   vFreeTTC(httc) V_FREE(httc)

// basic "methods" that act on the FONTCONTEXT object  (in fontfile.c)

#define   PFC(hfc)      ((PFONTCONTEXT)hfc)
#define   pfcAlloc(cj)  ((PFONTCONTEXT)EngAllocMem(0, cj, 'dftT'))
#define   vFreeFC(hfc)  EngFreeMem((PVOID)hfc)

#define   V_FREE(pv)    EngFreeMem((PVOID)pv)
#define   PV_ALLOC(cj)  EngAllocMem(0, cj, 'dftT')

// New added Pv_Realloc used in robust rasterizer

PVOID   Pv_Realloc(PVOID pv, LONG newSzie, LONG oldSize);

// Robust rasterizer need malloc, free & realloc
// NT kernel can not support realloc, we got to implement by ourselves
#define FST_MALLOC PV_ALLOC
#define FST_FREE V_FREE
#define FST_REALLOC Pv_Realloc

// Robust rasterizer assertion
#ifdef DBG
#define FSTAssert(exp, str) ASSERTDD(exp, str)
#else
#define FSTAssert(exp,str)
#endif

// tt required functions, callbacks

// I hate to have this function defined like this [bodind],

voidPtr FS_CALLBACK_PROTO pvGetPointerCallback    (ULONG_PTR  clientID, long dp, long cjData);
void    FS_CALLBACK_PROTO vReleasePointerCallback (voidPtr pv);

BOOL bGetFastAdvanceWidth(FONTCONTEXT *, ULONG, FIX *);


//
// Data types allocated dynamically:
//
//  ID_KERNPAIR dynamically allocated array of FD_KERNINGPAIR structures
//

#define UNHINTED_MODE(pfc)       (pfc->flFontType & (FO_MONO_UNHINTED | FO_SUBPIXEL_4 | FO_CLEARTYPE))
#define IS_CLEARTYPE_NATURAL(pfc)       ((pfc->flFontType & FO_CLEARTYPE_GRID) && !(pfc->flFontType & FO_COMPATIBLE_WIDTH))
#define IS_CLEARTYPE(pfc)       ((pfc->flFontType & FO_CLEARTYPE_GRID) || (pfc->flFontType & FO_CLEARTYPE))


#define CJGD(w,h,p)                                                      \
  ALIGN4(offsetof(GLYPHBITS,aj)) +                                       \
  ALIGN4((h)*(((p)->flFontType & FO_GRAYSCALE)?((IS_CLEARTYPE(pfc) || (pfc->flFontType & FO_SUBPIXEL_4))?(w):(((w)+1)/2)):(((w)+7)/8)))

LONG lExL(FLOATL e, LONG l);


VOID vCharacterCode (PFONTFILE pff, HGLYPH hg, fs_GlyphInputType *pgin);
BOOL bGetGlyphOutline(FONTCONTEXT*,HGLYPH, ULONG*, FLONG, FS_ENTRY*);


VOID vLONG_X_POINTQF(LONG lIn, POINTQF *ptqIn, POINTQF *ptqOut);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\fontfile.c ===
/******************************Module*Header*******************************\
* Module Name: fontfile.c                                                  *
*                                                                          *
* "Methods" for operating on FONTCONTEXT and FONTFILE objects              *
*                                                                          *
* Created: 18-Nov-1990 15:23:10                                            *
* Author: Bodin Dresevic [BodinD]                                          *
*                                                                          *
* Copyright (c) 1993 Microsoft Corporation                                 *
\**************************************************************************/

#include "fd.h"
#include "fdsem.h"


#define C_ANSI_CHAR_MAX 256

//HSEMAPHORE ghsemTTFD;



/******************************Public*Routine******************************\
*
* VOID vInitGlyphState(PGLYPHSTAT pgstat)
*
* Effects: resets the state of the new glyph
*
* History:
*  22-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vInitGlyphState(PGLYPHSTATUS pgstat)
{
    pgstat->hgLast  = HGLYPH_INVALID;
    pgstat->igLast  = 0xffffffff;
}



VOID vMarkFontGone(TTC_FONTFILE *pff, DWORD iExceptionCode)
{
    ULONG i;

    ASSERTDD(pff, "ttfd!vMarkFontGone, pff\n");

// this font has disappeared, probably net failure or somebody pulled the
// floppy with ttf file out of the floppy drive

    if (iExceptionCode == STATUS_IN_PAGE_ERROR) // file disappeared
    {
    // prevent any further queries about this font:

        pff->fl |= FF_EXCEPTION_IN_PAGE_ERROR;

        for( i = 0; i < pff->ulNumEntry ; i++ )
        {
            PFONTFILE pffReal;

        // get real pff.

            pffReal = PFF(pff->ahffEntry[i].hff);

        // if memoryBases 0,3,4 were allocated free the memory,
        // for they are not going to be used any more

            if (pffReal->pj034)
            {
                V_FREE(pffReal->pj034);
                pffReal->pj034 = NULL;
            }

        // if memory for font context was allocated and exception occured
        // after allocation but before completion of ttfdOpenFontContext,
        // we have to free it:

            if (pffReal->pfcToBeFreed)
            {
                V_FREE(pffReal->pfcToBeFreed);
                pffReal->pfcToBeFreed = NULL;
            }
        }
    }

    if (iExceptionCode == STATUS_ACCESS_VIOLATION)
    {
        //RIP("TTFD!this is probably a buggy ttf file\n");
    }
}

/**************************************************************************\
*
* These are semaphore grabbing wrapper functions for TT driver entry
* points that need protection.
*
*  Mon 29-Mar-1993 -by- Bodin Dresevic [BodinD]
* update: added try/except wrappers
*
*   !!! should we also do some unmap file clean up in case of exception?
*   !!! what are the resources to be freed in this case?
*   !!! I would think,if av files should be unmapped, if in_page exception
*   !!! nothing should be done
*
 *
\**************************************************************************/

HFF ttfdSemLoadFontFile (
    //ULONG cFiles,
    ULONG_PTR * piFile,
    ULONG       ulLangId
    )
{
    HFF       hff   = (HFF)NULL;
    ULONG_PTR iFile = *piFile;
    PVOID pvView;
    ULONG cjView;

    //  Remove hack that limits entries loaded to 1
    //if (cFiles != 1)
    //    return hff;

        if
        (!EngMapFontFileFD(
                iFile,
                (PULONG*)&pvView,
                &cjView
                )
        )
        return hff;

//    EngAcquireSemaphore(ghsemTTFD);

    try
    {
        BOOL bRet = bLoadFontFile(iFile, pvView, cjView, ulLangId, &hff);
        
        if (!bRet)
        {
            ASSERTDD(hff == (HFF)NULL, "LoadFontFile, hff not null\n");
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        //WARNING("TTFD!_ exception in ttfdLoadFontFile\n");
        ASSERTDD(GetExceptionCode() == STATUS_IN_PAGE_ERROR,
                  "ttfdSemLoadFontFile, strange exception code\n");
        if (hff)
        {
            ttfdUnloadFontFileTTC(hff);
            hff = (HFF)NULL;
        }
    }

//    EngReleaseSemaphore(ghsemTTFD);

    EngUnmapFontFileFD(iFile);

    return hff;
}

BOOL ttfdSemUnloadFontFile(HFF hff)
{
    BOOL bRet;
//    EngAcquireSemaphore(ghsemTTFD);

    try
    {
        bRet = ttfdUnloadFontFileTTC(hff);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        //WARNING("TTFD!_ exception in ttfdUnloadFontFile\n");
        bRet = FALSE;
    }

//    EngReleaseSemaphore(ghsemTTFD);
    return bRet;
}

BOOL bttfdMapFontFileFD(PTTC_FONTFILE pttc)
{
    return (pttc ? (EngMapFontFileFD(PFF(pttc->ahffEntry[0].hff)->iFile,
                                     (PULONG*)&pttc->pvView,
                                     &pttc->cjView))
                 : FALSE);
}


LONG
ttfdSemQueryFontData (
    FONTOBJ     *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA   *pgd,
    PVOID       pv
    )
{
    LONG lRet = FD_ERROR;

    if (bttfdMapFontFileFD((TTC_FONTFILE *)pfo->iFile))
    {
//        EngAcquireSemaphore(ghsemTTFD);
    
        try
        {
            lRet = ttfdQueryFontData (
                       pfo,
                       iMode,
                       hg,
                       pgd,
                       pv,
                       0,
                       0
                       );
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            //WARNING("TTFD!_ exception in ttfdQueryFontData\n");
    
            vMarkFontGone((TTC_FONTFILE *)pfo->iFile, GetExceptionCode());
        }
        
//        EngReleaseSemaphore(ghsemTTFD);

        EngUnmapFontFileFD(PFF(PTTC(pfo->iFile)->ahffEntry[0].hff)->iFile);
    }
    return lRet;
}


LONG
ttfdSemQueryFontDataSubPos (
    FONTOBJ     *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA   *pgd,
    PVOID       pv,
    ULONG       subX,
    ULONG       subY
    )
{
    LONG lRet = FD_ERROR;

    if (bttfdMapFontFileFD((TTC_FONTFILE *)pfo->iFile))
    {
//        EngAcquireSemaphore(ghsemTTFD);
    
        try
        {
            lRet = ttfdQueryFontData (
                       pfo,
                       iMode,
                       hg,
                       pgd,
                       pv,
                       subX,
                       subY
                       );
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            //WARNING("TTFD!_ exception in ttfdQueryFontData\n");
    
            vMarkFontGone((TTC_FONTFILE *)pfo->iFile, GetExceptionCode());
        }
        
//        EngReleaseSemaphore(ghsemTTFD);

        EngUnmapFontFileFD(PFF(PTTC(pfo->iFile)->ahffEntry[0].hff)->iFile);
    }
    return lRet;
}



VOID
ttfdSemDestroyFont (
    FONTOBJ *pfo
    )
{
//    EngAcquireSemaphore(ghsemTTFD);

    ttfdDestroyFont (
        pfo
        );

//   EngReleaseSemaphore(ghsemTTFD);
}




LONG
ttfdSemGetTrueTypeTable (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifying the tt table
    PBYTE  *ppjTable,// ptr to table in mapped font file
    ULONG  *pcjTable // size of the whole table in the file
    )
{
    LONG lRet;
    lRet = FD_ERROR;

    if (bttfdMapFontFileFD((TTC_FONTFILE *)hff))
    {
//        EngAcquireSemaphore(ghsemTTFD);
    
        try
        {
            lRet = ttfdQueryTrueTypeTable (
                        hff,
                        ulFont,  // always 1 for version 1.0 of tt
                        ulTag,   // tag identifying the tt table
                        0, // offset into the table
                        0,   // size of the buffer to retrieve the table into
                        NULL,   // ptr to buffer into which to return the data
                        ppjTable,
                        pcjTable
                        );
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            //WARNING("TTFD!_ exception in ttfdQueryTrueTypeTable\n");
            vMarkFontGone((TTC_FONTFILE *)hff, GetExceptionCode());
        }
    
        if (lRet == FD_ERROR)
            EngUnmapFontFileFD(PFF(PTTC(hff)->ahffEntry[0].hff)->iFile);

//        EngReleaseSemaphore(ghsemTTFD);

    }

    return lRet;
}

void
ttfdSemReleaseTrueTypeTable (
    HFF     hff
    )
{
        EngUnmapFontFileFD(PFF(PTTC(hff)->ahffEntry[0].hff)->iFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\mapfile.h ===
/******************************Module*Header*******************************\
* Module Name: os.h
*
* Created: 26-Oct-1990 18:07:56
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/


// warning the first two fields of FILEVIEW and FONTFILE view must be
// the same so that they can be used in common routines

typedef struct _FONTFILEVIEW {
   ULARGE_INTEGER  LastWriteTime;   // time stamp
            ULONG  mapCount;
            PVOID  pvView;          // font driver process view of file
            ULONG  cjView;          // size of font file view in bytes
           LPWSTR  pwszPath;        // path of the file
        // HANDLE     hFile;
        // HANDLE     hMapping;
} FONTFILEVIEW;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\tt.h ===
/******************************Module*Header*******************************\
* Module Name: tt.h
*
*  interface to the font scaler. Also defines some macros that should
* have been defined in the scaler *.h files
*
* Created: 17-Nov-1991 15:56:21
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
*
\**************************************************************************/



// turns out that some of the macros that follow are already defined
// in some of the top include files that precede tt.h. Worse, these
// macros are defined DIFFERENTLY than in tt.h.
// We want to enforce that these macros when used in ttfd have the meaning
// defined in tt include files so that we have to kill the definitions
// inherited from anywhere else.


//!!! maybe this should go to scaler\config.h !!!!!!!!

#ifdef SWAPL
#undef SWAPL
#endif

#ifdef SWAPW
#undef SWAPW
#endif

// defined earlier, turns on the garbage in fserror.h

#ifdef XXX
#undef XXX
#endif

// defined earlier, use tt definition

#ifdef HIWORD
#undef HIWORD
#endif

// defined earlier, use tt definition

#ifdef LOWORD
#undef LOWORD
#endif

#include "FSERROR.H"
#include "FSCDEFS.H"    // inlcudes fsconfig.h
#include "FONTMATH.H"
#include "SFNT.H"       // includes sfnt_en.h
#include "FNT.H"
#include "INTERP.H"
#include "FNTERR.H"
#include "SFNTACCS.H"
#include "FSGLUE.H"
#include "SCENTRY.H"
#include "SBIT.H"
#include "FSCALER.H"
#include "SCGLOBAL.H"
#include "SFNTOFF.H"

// allowed specific ID's

#define SPEC_ID_UNDEFINED    0   // undefined char set or indexing scheme
#define SPEC_ID_UGL          1   // UGL char set with UNICODE indexing
#define SPEC_ID_SHIFTJIS     2   // SHIFTJIS mapping
#define SPEC_ID_GB           3   // GB mapping
#define SPEC_ID_BIG5         4   // BIG5 mapping
#define SPEC_ID_WANSUNG      5   // Hangeul WANSUNG mapping

// the same but in big endian format

#define BE_SPEC_ID_UNDEFINED    0x0000   // undefined char set or indexing scheme
#define BE_SPEC_ID_UGL          0x0100   // UGL char set with UNICODE indexing
#define BE_SPEC_ID_SHIFTJIS     0x0200   // SHIFTJIS mapping
#define BE_SPEC_ID_GB           0x0300   // GB mapping
#define BE_SPEC_ID_BIG5         0x0400   // BIG5 mapping
#define BE_SPEC_ID_WANSUNG      0x0500   // Hangeul WANSUMG mapping

// platform id's, this is copied from sfnt_en.h

/*
*
* typedef enum {
*     plat_Unicode,
*     plat_Macintosh,
*     plat_ISO,
*     plat_MS
* } sfnt_PlatformEnum;
*
*/

#define  PLAT_ID_UNICODE   0
#define  PLAT_ID_MAC       1
#define  PLAT_ID_ISO       2
#define  PLAT_ID_MS        3

// the same but in big endian format

#define  BE_PLAT_ID_UNICODE   0x0000
#define  BE_PLAT_ID_MAC       0x0100
#define  BE_PLAT_ID_ISO       0x0200
#define  BE_PLAT_ID_MS        0x0300


// language id's that are required to exhist in a ttf file:

#define LANG_ID_USENGLISH   0X0409  // for microsoft records
#define LANG_ID_MAC         0       // ENGLISH FOR MAC RECORDS

// the same but in big endian format

#define BE_LANG_ID_USENGLISH   0X0904  // for microsoft records
#define BE_LANG_ID_MAC         0X0000  // ENGLISH FOR MAC RECORDS


// allowed format values of the cmap tables:

#define BE_FORMAT_MAC_STANDARD      0X0000
#define BE_FORMAT_HIGH_BYTE         0X0200
#define BE_FORMAT_MSFT_UNICODE      0X0400
#define BE_FORMAT_TRIMMED           0X0600


/*
*
* typedef enum {
*     name_Copyright,
*     name_Family,
*     name_Subfamily,
*     name_UniqueName,
*     name_FullName,
*     name_Version,
*     name_Postscript
* } sfnt_NameIndex;
*
*/

#if  0

#define NAME_ID_COPYRIGHT   0
#define NAME_ID_FAMILY      1
#define NAME_ID_SUBFAMILY   2
#define NAME_ID_UNIQNAME    3
#define NAME_ID_FULLNAME    4
#define NAME_ID_VERSION     5
#define NAME_ID_PSCRIPT     6
#define NAME_ID_TRADEMARK   7

#endif

// there are 19 tables (10 required + 9 optianal) defined in 1.0 revision
// of tt spec. We define this cut off arbitrarily (but bigger than 19)
// to get out of the loops rather than sit there and die;


#define MAX_TABLES 128

// size of some sfnt_xxx Structures as they are layed out on the disk:

#define SIZE_DIR_ENTRY        16
#define SIZE_NAMING_TABLE     6
#define SIZE_NAME_RECORD      12

// offsets into OS2 metrics table. Significant enough to be done by hand
// to ensure portability:

// original structure (from sfnt.h), version 0

/*
*
*
*   typedef struct {
*       uint16  Version;
*       int16   xAvgCharWidth;
*       uint16  usWeightClass;
*       uint16  usWidthClass;
*       int16   fsType;
*       int16   ySubscriptXSize;
*       int16   ySubscriptYSize;
*       int16   ySubscriptXOffset;
*       int16   ySubscriptYOffset;
*       int16   ySuperScriptXSize;
*       int16   ySuperScriptYSize;
*       int16   ySuperScriptXOffset;
*       int16   ySuperScriptYOffset;
*       int16   yStrikeOutSize;
*       int16   yStrikeOutPosition;
*       int16   sFamilyClass;
*       uint8   Panose [10];
*       uint32  ulCharRange [4];
*       char    achVendID [4];
*       uint16  usSelection;
*       uint16  usFirstChar;
*       uint16  usLastChar;
*   } sfnt_OS2;
*
*/



#define     OFF_OS2_Version               0
#define     OFF_OS2_xAvgCharWidth         2
#define     OFF_OS2_usWeightClass         4
#define     OFF_OS2_usWidthClass          6
#define     OFF_OS2_fsType                8
#define     OFF_OS2_ySubscriptXSize       10
#define     OFF_OS2_ySubscriptYSize       12
#define     OFF_OS2_ySubscriptXOffset     14
#define     OFF_OS2_ySubscriptYOffset     16
#define     OFF_OS2_ySuperScriptXSize     18
#define     OFF_OS2_ySuperScriptYSize     20
#define     OFF_OS2_ySuperScriptXOffset   22
#define     OFF_OS2_ySuperScriptYOffset   24
#define     OFF_OS2_yStrikeOutSize        26
#define     OFF_OS2_yStrikeOutPosition    28
#define     OFF_OS2_sFamilyClass          30
#define     OFF_OS2_Panose                32
#define     OFF_OS2_ulCharRange           42
#define     OFF_OS2_achVendID             58
#define     OFF_OS2_usSelection           62
#define     OFF_OS2_usFirstChar           64
#define     OFF_OS2_usLastChar            66


// these fields are defined in the spec but not in the sfnt.h structure above.
// I shall have to check whether these really exhist in tt files or not

#define     OFF_OS2_sTypoAscender         68
#define     OFF_OS2_sTypoDescender        70
#define     OFF_OS2_sTypoLineGap          72
#define     OFF_OS2_usWinAscent           74
#define     OFF_OS2_usWinDescent          76

// these two are added for version 200

#define     OFF_OS2_ulCodePageRange1      78
#define     OFF_OS2_ulCodePageRange2      82




// #define SIZE_OS2                        86

// values of some flags of the flag fields of the OS2 structure
//            taken from the tt spec


// fsType flags, notice bit 0x0001 is not used

#define TT_FSDEF_LICENSED        0x0002
#define TT_FSDEF_READONLY_ENCAPS 0x0004
#define TT_FSDEF_EDITABLE_ENCAPS 0x0008

#define TT_FSDEF_MASK  (TT_FSDEF_LICENSED|TT_FSDEF_READONLY_ENCAPS|TT_FSDEF_EDITABLE_ENCAPS)

// usSelection

#define TT_SEL_ITALIC            0x0001
#define TT_SEL_UNDERSCORE        0x0002
#define TT_SEL_NEGATIVE          0x0004
#define TT_SEL_OUTLINED          0x0008
#define TT_SEL_STRIKEOUT         0x0010
#define TT_SEL_BOLD              0x0020
#define TT_SEL_REGULAR           0x0040

//
// Macro to extract the big endian word at pj, really
// the correct equivalent of SWAPW macro, which does not assume
// that pj is word aligned.
//

#define BE_UINT16(pj)                                \
    (                                                \
        ((USHORT)(((PBYTE)(pj))[0]) << 8) |          \
        (USHORT)(((PBYTE)(pj))[1])                   \
    )


#define BE_INT16(pj)  ((SHORT)BE_UINT16(pj))


//
// macro to extract the big endian dword at pj, really
// a the correct equivalent of SWAPL macro, which does not assume
// that pj is DWORD aligned
//


#define BE_UINT32(pj)                                              \
    (                                                              \
        ((ULONG)BE_UINT16(pj) << 16) |                             \
        (ULONG)BE_UINT16((PBYTE)(pj) + 2)                          \
    )


#define BE_INT32(pj) ((LONG)BE_UINT32(pj))

// number of tt tables may change as we decide to add more tables to
// tt files, this list is extracted from sfnt_en.h

// required tables

//   tag_CharToIndexMap              // 'cmap'    0
//   tag_GlyphData                   // 'glyf'    1
//   tag_FontHeader                  // 'head'    2
//   tag_HoriHeader                  // 'hhea'    3
//   tag_HorizontalMetrics           // 'hmtx'    4
//   tag_IndexToLoc                  // 'loca'    5
//   tag_MaxProfile                  // 'maxp'    6
//   tag_NamingTable                 // 'name'    7
//   tag_Postscript                  // 'post'    8
//   tag_OS_2                        // 'OS/2'    9

// optional

//   tag_ControlValue                // 'cvt '    11
//   tag_FontProgram                 // 'fpgm'    12
//   tag_HoriDeviceMetrics           // 'hdmx'    13
//   tag_Kerning                     // 'kern'    14
//   tag_LSTH                        // 'LTSH'    15
//   tag_PreProgram                  // 'prep'    16
//   tag_GridfitAndScanProc          // 'gasp'    21
//   tag_BitmapLocation              // 'EBLC'    

//!!! not in the tt spec, but in defined in sfnt_en.h

//   tag_GlyphDirectory              // 'gdir'    17
//   tag_Editor0                     // 'edt0'    18
//   tag_Editor1                     // 'edt1'    19
//   tag_Encryption                  // 'cryp'    20

// REQUIRED TABLES

#define IT_REQ_CMAP    0
#define IT_REQ_GLYPH   1
#define IT_REQ_HEAD    2
#define IT_REQ_HHEAD   3
#define IT_REQ_HMTX    4
#define IT_REQ_LOCA    5
#define IT_REQ_MAXP    6
#define IT_REQ_NAME    7

#define C_REQ_TABLES   8

// optional tables

#define IT_OPT_OS2     0
#define IT_OPT_HDMX    1
#define IT_OPT_VDMX    2
#define IT_OPT_KERN    3
#define IT_OPT_LSTH    4
#define IT_OPT_POST    5
#define IT_OPT_GASP    6
#define IT_OPT_MORT    7 
#define IT_OPT_GSUB    8
#define IT_OPT_VMTX    9
#define IT_OPT_VHEA    10
#define IT_OPT_EBLC    11
#define C_OPT_TABLES   12

/*

// there are more optional tables, but ttfd is not
// using them so we are eliminating these from the code

#define IT_OPT_CVT
#define IT_OPT_FPGM
#define IT_OPT_PREP

// these are not mentioned in the spec (unless
// they are mentioned under a different name) but tags
// for them exhist in sfnt_en.h

#define IT_OPT_GDIR
#define IT_OPT_EDT0
#define IT_OPT_EDT1
#define IT_OPT_ENCR
#define IT_OPT_FOCA
#define IT_OPT_WIN

//!!! these ARE mentioned in the spec, but I found no tags for them
//!!! in the sfnt_en.h include file [bodind], I am putting the tags
//!!! here for now, until they are added to sfnt_en.h

*/



#define tag_Vdmx      0x56444d58
#define tag_Foca      0x666f6361
#define tag_Win       0x0077696e
// for far east support
#define tag_mort      0x6d6f7274 
#define tag_GSUB      0x47535542
#define tag_DSIG      'DSIG'

typedef struct _TABLE_ENTRY // te
{
    ULONG dp;  // offset to the beginning of the table
    ULONG cj;  // size of the table
} TABLE_ENTRY, *PTABLE_ENTRY;


typedef struct _TABLE_POINTERS // tptr
{
    TABLE_ENTRY ateReq[C_REQ_TABLES];
    TABLE_ENTRY ateOpt[C_OPT_TABLES];
} TABLE_POINTERS, *PTABLE_POINTERS;


// jeanp's functions

uint16 ui16Mac2Lang (uint16 Id);


// convert "os2" language id to the mac style lang id if this is a mac file

#define  CV_LANG_ID(ui16PlatformID, Id)                               \
(                                                                     \
(ui16PlatformID == BE_PLAT_ID_MS) ? (Id) : ui16Mac2Lang((uint16)(Id)) \
)

// magic number in big endian

#define BE_SFNT_MAGIC   0xF53C0F5F

// in order to understand this structure one needs to know
// the format of the table pmap  which is as follows
//
// typedef struct {
//     uint16 format;
//     uint16 length;
//     uint16 version;

// the three fields above are common for all formats

//     uint16 segCountX2;
//     uint16 searchRange;
//     uint16 entrySelector;
//     uint16 rangeShift;
//     uint16 endCount[segCount];
//     uint16 reservedPad;         // only God knows why
//     uint16 startCount[segCount];
//     uint16 idDelta[segCount];
//     uint16 idRangeOffset[segCount];
//     uint16 glyphIdArray[1];     // arbitrary length
// } CMAP_TABLE_IN_MSFT_FORMAT;
//
// Not all of these fields are relevant for us,
// we shall only need few of them. Their offsets
// from the beginning of the structure are as follows:
//

// cmap table  size and offsets

#define SIZEOF_CMAPTABLE  (3 * sizeof(uint16))

#define OFF_segCountX2  6
#define OFF_endCount    14


//
// offsets within kerning table
//

#define KERN_OFFSETOF_TABLE_VERSION             0
#define KERN_OFFSETOF_TABLE_NTABLES             1 * sizeof(USHORT)
#define KERN_SIZEOF_TABLE_HEADER                2 * sizeof(USHORT)

//
// offsets within a kerning sub table
//

#define KERN_OFFSETOF_SUBTABLE_VERSION          0
#define KERN_OFFSETOF_SUBTABLE_LENGTH           1 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_COVERAGE         2 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_NPAIRS           3 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_SEARCHRANGE      4 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_ENTRYSELECTOR    5 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_RANGESHIFT       6 * sizeof(USHORT)
#define KERN_SIZEOF_SUBTABLE_HEADER             7 * sizeof(USHORT)

#define KERN_OFFSETOF_ENTRY_LEFT                0
#define KERN_OFFSETOF_ENTRY_RIGHT               1 * sizeof(USHORT)
#define KERN_OFFSETOF_ENTRY_VALUE               2 * sizeof(USHORT)
#define KERN_SIZEOF_ENTRY                       2 * sizeof(USHORT) + sizeof(FWORD)

#define KERN_OFFSETOF_SUBTABLE_FORMAT           KERN_OFFSETOF_SUBTABLE_COVERAGE
#define KERN_WINDOWS_FORMAT                     0


// these functions are candidates to be bracketed the try/except


// FS_ENTRY fs_NewSfnt           (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_NewTransformation (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_NewGlyph          (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_GetAdvanceWidth   (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_ContourGridFit    (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_ContourNoGridFit  (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_FindBitMapSize    (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_ContourScan       (fs_GlyphInputType *, fs_GlyphInfoType *);




#define MAX_UINT8    0xff
#define MAX_INT8     0x7f
#define MIN_INT8     (-0x7f)
#define B_INT8(x)    (((x) <= MAX_INT8) && ((x) >= MIN_INT8))

#define MAX_UINT16   0xffff
#define MAX_INT16    0x7fff
#define MIN_INT16    (-0x7fff)
#define B_INT16(x)   (((x) <= MAX_INT16) && ((x) >= MIN_INT16))

#define MAX_UINT32  0xffffffff
#define MAX_INT32   0x7fffffff
#define MIN_INT32   (-0x7fffffff)
#define B_INT32(x)   (((x) <= MAX_INT32) && ((x) >= MIN_INT32))

typedef struct 
{
    int32   version;
    int16   ascent;
    int16   descent;
    int16   lineGap;
    int16   advanceHeightMax;
    int16   minTopSideBearing;
    int16   minBottomSideBearing;
    int16   yMaxExtent;
    int16   caretSlopeRise;
    int16   caretSlopeRun;
    int16   caretOffset;
    int16   reserved1;
    int16   reserved2;
    int16   reserved3;
    int16   reserved4;
    int16   metricDataFormat;
    uint16  numOfLongVerMetrics;
} sfnt_vheaTable;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\vdmx.c ===
/******************************Module*Header*******************************\
* Module Name: vdmx.c
*
* Created: 03-Oct-1991 10:58:34
* Author: Jean-francois Peyroux [jeanp]
*
*     Microsoft Confidential
*
*         Copyright (c) Microsoft Corporation 1989, 1991
*
*         All Rights Reserved
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/


#include "fd.h"
//#include "winfont.h"

#define LINEAR_TRESHOLD 255

#pragma pack(1)

typedef struct
{
  BYTE    bCharSet;       // Character set (0=all glyphs, 1=Windows ANSI subset
  BYTE    xRatio;         // Value to use for x-Ratio
  BYTE    yStartRatio;    // Starting y-Ratio value
  BYTE    yEndRatio;      // Ending y-Ratio value
}  RATIOS;

typedef struct
{
  USHORT  version;        // Version number for table (starts at 0)
  USHORT  numRecs;        // Number of VDMX groups present
  USHORT  numRatios;      // Number of aspect ratio groupings
} VDMX_HDR;

typedef struct
{
  USHORT  yPelHeight;     // yPelHeight (PPEM in Y) to which values apply
  SHORT   yMax;           // yMax (in pels) for this yPelHeight
  SHORT   yMin;           // yMin (in pels) for this yPelHeight
} VTABLE;

typedef struct
{
  USHORT  recs;           // Number of height records in this group.
  BYTE    startsz;        // Starting yPelHeight
  BYTE    endsz;          // Ending yPelHeight
} VDMX;

#pragma pack()

/******************************Public Routine*******************************
*
* BOOL   bSearchVdmxTable
*
* Description:
*
*   if em > 0
*       searches vdmx table for vA+vD == em. returns vA,vD (== em - vA), vEm
*   else // em < 0
*       searches vdmx table for vEm == em. returns vA,vD, vEm
*
* History:
*
*  Tue 21-Jul-1992 -by- Bodin Dresevic [BodinD]
* update: ported to NT
*   15 Nov 1991 -by-    Raymond E. Endres   [rayen]
* Added aspect ratio option and optimized the function.
*   3  Oct 1991 -by-    Jean-francois Peyroux   [jeanp]
* Wrote it.
**************************************************************************/

BOOL
bSearchVdmxTable (
    PBYTE     pjVdmx,
    ULONG     ResX,
    ULONG     ResY,
    INT       EM,     // NOT really EM, could be asc + desc wish in pixel units
    VTABLE    *pVTAB  // out put structure
    )
{
    USHORT    numRatios;        // VDMX_HDR.numRatios
    USHORT    numVtable;        // VDMX.recs, not VDMX_HDR.numRecs

    RATIOS   *pRatios;
    VDMX     *pVdmx;
    VTABLE   *pVtable;
    LONG      lRet, lRet2;
    UINT      i;
    BYTE      Abs_EM;

// do not call us if pjVdmx is null

    ASSERTDD (pjVdmx != (PBYTE)NULL, "pjVdmx == NULL\n");

// The following line is strange, but we keep it here for win31 compatibility.
// It is possible to have EM = +256, which corresponds to |ppem| < 256
// such that there is an entry for this -|ppem| in the table but
// yMax-yMin for this entry may be equal to 256. This in fact is the case
// with symbol.ttf font [bodind]

    if ((EM >= LINEAR_TRESHOLD) || (EM <= -LINEAR_TRESHOLD)) // assume EM > LINEAR_TRESHOLD scales linearly
        return FALSE;

// need to proceed to search vdmx table

    numRatios = SWAPW(((VDMX_HDR  *) pjVdmx)->numRatios);
    pRatios = (RATIOS  *) &((VDMX_HDR  *) pjVdmx)[1];

    for(i = 0; i < numRatios; i++)
    {
        if (pRatios[i].bCharSet == 1)
        {
        // must be Windows ANSI subset

            if (pRatios[i].xRatio == 0)
            {
                break;
            }           // auto match if 0
            else
            {                   // is it within aspect ratios
                lRet = ResY * pRatios[i].xRatio;
                lRet2= ResX * pRatios[i].yStartRatio;
                if (lRet >= lRet2)
                {
                    lRet2 = ResX * pRatios[i].yEndRatio;
                    if (lRet <= lRet2)
                        break;
                }
            }
        }
    }

    if (i == numRatios)  // did not find an aspect ratio match
        return FALSE;

// found an aspect ratio match

    pVdmx = (VDMX  *) (pjVdmx + SWAPW(((USHORT  *) &pRatios[numRatios])[i]));
    Abs_EM = (BYTE) (EM >=0 ? EM : - EM);

    if (EM > 0 || Abs_EM >= pVdmx->startsz && Abs_EM <= pVdmx->endsz)
    {
    // is there a Vtable for this EM

        pVtable = (VTABLE  *) &pVdmx[1];
        numVtable = SWAPW(pVdmx->recs);

        if (EM > 0)
        {
        // return the original yPelHeight

            for (i = 0; i < numVtable; i++)
            {
                pVTAB->yPelHeight = SWAPW(pVtable[i].yPelHeight);
                pVTAB->yMax       = SWAPW(pVtable[i].yMax);
                pVTAB->yMin       = SWAPW(pVtable[i].yMin);

            if ((pVTAB->yMax - pVTAB->yMin) == EM)
                {
                    return TRUE;
            }
            else if ((pVTAB->yMax - pVTAB->yMin) > EM)
                {
                    return FALSE;
            }
            }
        }
        else // return the actual em height in pixels
        {
            for (i = 0; i < numVtable; i++)
            {
                pVTAB->yPelHeight = SWAPW(pVtable[i].yPelHeight);
                pVTAB->yMax       = SWAPW(pVtable[i].yMax);
                pVTAB->yMin       = SWAPW(pVtable[i].yMin);

            if ((INT)pVTAB->yPelHeight == -EM)
                {
                    return TRUE;
            }
            else if ((INT)pVTAB->yPelHeight > -EM)
                {
                    return FALSE;
            }
            }
        }
    }
    return FALSE;
}

#ifdef THIS_IS_COMMENTED_PSEUDOCODE

// BASED ON THE DISCUSSION OF KIRKO, BODIND AND GILMANW WITH GUNTERZ

|INPUT:  hWish = wish height in pixel units
|
|OUTPUT: ascender, descender, ppem (all in pixel units) (dA,dD,dEm)
|
|
|    NOTATION:
|
|        dA = ascender in device/pixel space
|        nA = ascender in notional space
|        vA = ascender in vdmx table
|
|        dD = descender in device/pixel space
|        nD = descender in notional space
|        vD = descender in vdmx table
|
|        dEm = pixels per em in device space
|        nEm = em height in notional space
|        vEm = pixels per em in vdmx table
|
|
|LOCALS
|
|    LONG hTrial
|    LONG hEqualOrBelow
|    BOOL wasAbove
|    BOOL wasBelow
|
|PROCEDURE
|{
|    if (hWish < 0) then
|    {
|        <look in the vdmx and look for a vEm that matches -hWish>;
|        if (a match is found) then
|        {
|            dA = vA;
|            dD = vD;
|        }
|        else
|        {
|        //
|        // No Match is found in vdmx table, assume linear scaling
|        //
|            dA = round(nA * (-hWish) / nEm);
|            dD = round(nD * (-hWish) / nEm);
|        }
|        ppEm = -hWish;
|        return;
|    }
|
|//
|// hWish > 0
|//
|    <search the vdmx table for (vA + vD) that matches hWish>;
|    if (a match is found)
|    {
|        dA  = vA;
|        dCs = vD;
|        dEm = vEm;
|        return;
|    }
|
|//
|// Note, that from this point forward vA + vD never equals hWish
|// otherwise we would have found it in the step above
|//
|    ppemTrial = round(nEm * hWish / (nA + nD));
|
|    wasAbove = FALSE;
|    wasBelow = FALSE;
|
|    while (TRUE)
|    {
|        <search the vdmx table for vEm that matches ppemTrial>;
|        if (a match is found)
|        {
|            hTrial = vA + vD;
|        //
|        // This can't equal hWish (see above) so don't bother
|        // checking
|        }
|        else
|        {
|            hTrial = round(ppemTrial * (nA + nD) / nEm);
|            if (hTrial == hWish)
|            {
|                hEqualOrBelow = hTrial;
|                break;
|            }
|        }
|
|        if (hTrial < hWish)
|        {
|            hEqualOrBelow = hTrial;
|            if (wasAbove)
|                break;
|            ppemTrial = ppemTrial + 1;
|            wasBelow  = TRUE;
|        }
|        else
|        {
|            ppemTrial = ppemTrial - 1;   // <==== NEW POSITION
|            if (wasBelow)
|                break;
|                                         // <==== OLD POSITION
|            wasAbove = TRUE
|        }
|    }
|    dA  = round(ppemTrial * nA / nEm);
|    dD  = hEqualOrBelow - dA;
|    dEm = ppemTrial;
|    return;
|}.
|

#endif // THIS_IS_COMMENTED_PSEUDOCODE


/******************************Public*Routine******************************\
*
* VOID vQuantizeXform
*
* Effects: quantize the xform according to win31 recipe. as side effects
*          this routine may compute ascender and descener in device space
*          from vdmx table as well as number of pixels per M in device space.
*
* History:
*  25-Jul-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID
vQuantizeXform (
    PFONTCONTEXT pfc
    )
{
    BYTE  *pjView =  (BYTE *)pfc->pff->pvView;
    Fixed  fxMyy = pfc->mx.transform[1][1];
    PBYTE  pjVdmx  = (pfc->ptp->ateOpt[IT_OPT_VDMX].dp)          ?
                     (pjView + pfc->ptp->ateOpt[IT_OPT_VDMX].dp) :
                     NULL                                        ;

    LONG   hWish;
    VTABLE vtb, vtbPrev;

    LONG   ppemTrial, hTrial, yEmN, yHeightN;

    BOOL   bWasAbove, bWasBelow, bFound, bFoundPrev;

    sfnt_FontHeader * phead =
                      (sfnt_FontHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HEAD].dp);
    BYTE * pjOS2 = (pfc->ptp->ateOpt[IT_OPT_OS2].dp)         ?
                   (pjView + pfc->ptp->ateOpt[IT_OPT_OS2].dp):
                   NULL                                      ;

    yEmN = pfc->pff->ifi.fwdUnitsPerEm;

    if (!((pfc->flXform & XFORM_HORIZ) && (fxMyy > 0) && (pjVdmx != (PBYTE)NULL)))
    {
    // nothing to do, just return.

        return;
    }

// compute hWish in pixel coords. This is lfHeight from the logfont, except
// that it has been transformed to device pixel units and the sign is preserved

    if (pfc->flFontType & FO_EM_HEIGHT)
    {
        hWish = FixMul(fxMyy, -yEmN);
    }
    else // use tmp variable
    {
        yHeightN = pfc->pff->ifi.fwdWinAscender + pfc->pff->ifi.fwdWinDescender;
        hWish = FixMul(fxMyy, yHeightN);
    }

// quick out, all bSearchVdmxTable routines will fail if hWish is too big:



    if (bSearchVdmxTable(pjVdmx,
                         pfc->sizLogResPpi.cx,
                         pfc->sizLogResPpi.cy,
                         hWish,
                         &vtb)
    )
    {
        pfc->yMax = - vtb.yMin;
        pfc->yMin = - vtb.yMax;
        pfc->lEmHtDev = vtb.yPelHeight;

    // flag that dA and dD have been computed, do not scale linerly:

        pfc->flXform |= XFORM_VDMXEXTENTS;
    }
    else
    {
    // dA and dD will have to be computed using linear scaling
    // after the xform is quantized using win31 hacked recipe
    // get the notional space values which are needed for scaling

    // get the notional space values

        if (pjOS2)
        {
        // win 31 compatibility: we only take the max over win 31 char set:
        // all the glyphs outside this set, if they stand out will get chopped
        // off to match the height of the win31 char subset:

            yHeightN = BE_INT16(pjOS2 + OFF_OS2_usWinDescent) +
                       BE_INT16(pjOS2 + OFF_OS2_usWinAscent);
        }
        else
        {
            yHeightN = BE_INT16(&phead->yMax) - BE_INT16(&phead->yMin);
        }

        if (hWish < 0)
        {
            pfc->lEmHtDev = -hWish;
        }
        else // hWish > 0
        {
        // Note, that from this point forward vA + vD never equals hWish
        // otherwise we would have found it in the step above. This claim
        // is WRONG for only one reason. suppose hWish is 256. bSearchVdmxTable
        // will return FALSE because of the early exit test |EM| <= LINEAR_TRESHOLD
        // at the begininig of the routine. We have to keep this test in the
        // code for compatibility reasons. Now it is possible to have
        // ppemTrial <= LINEAR_TRESHOLD, so that bSearchVdmxTable will not hit the
        // early exit, and such that there exists an entry in the vdmx table
        // for this -ppemTrial, but with yMax-yMin == 256 == hWish.

            // ppemTrial = F16_16TOLROUND(yEmN * fxMyy);
            ppemTrial = FixMul(fxMyy, yEmN);

            bWasAbove  = FALSE;
            bWasBelow  = FALSE;
            bFound     = FALSE;
            bFoundPrev = FALSE; // save the value from the prev. loop

        // init the strucs

            vtb.yMin       = 0;
            vtb.yMax       = 0;
            vtb.yPelHeight = 0;
            vtbPrev        = vtb;

            for (;TRUE; bFoundPrev = bFound, vtbPrev = vtb)
            {
            // search the vdmx table for vEm that matches ppemTrial

                if
                (
                    bFound = bSearchVdmxTable(
                                     pjVdmx,
                                     pfc->sizLogResPpi.cx,
                                     pfc->sizLogResPpi.cy,
                                     -ppemTrial,
                                     &vtb)
                )
                {
                    hTrial = vtb.yMax - vtb.yMin;
                //
                // This can't equal hWish (see above) so don't bother
                // checking? WRONG!!! see teh comment above.

                    if (hTrial == hWish)
                    {
                    // This assert would be correct if it were not
                    // for occasional bugs in vdmx tables.
                    // In the case of Bell MT Regular, vA+vD = 0x13 for
                    // lEmHt = 0x0f which is STRICTLY bigger than
                    // vA+vD = 0x12 for lEmHt = 0x10 which is absurd.
                    // For this reason the first
                    // bSearchVdmxTable(EM = 0X12) fails to find an entry
                    // while the second bSearchVdmxTable(EM =- 0X10)
                    // DOES FIND an entry
                    // in vdmx table such that vA+vD=0x12, generating
                    // the commented assertion to bark. That is why we converted
                    // assertion to just print out a warning message.


                    #if DBG

                        // ASSERTGDI(hWish > LINEAR_TRESHOLD, "TTFD! hWish <= LINEAR_TRESHOLD\n");

                        if (hWish <= LINEAR_TRESHOLD)
                            TtfdDbgPrint("TTFD! hWish <= LINEAR_TRESHOLD\n");

                    #endif

                    /*   Bell MT Table:

    pVtable  -->    f800 ff08       //  F8 entries = numVtable,
                                    //  startsz = 8, endsz = ff
                    0800 0800 feff
                    0900 0900 feff
                    0a00 0900 fdff
                    0b00 0a00 fdff
                    0c00 0c00 fdff
                    0d00 0c00 fdff
                    0e00 0d00 fcff
                    0f00 0e00 fbff  <- yMax-yMin = 14-(-5) = 19 == 0X13
                    1000 0e00 fcff  <- yMax-yMin = 14-(-4) = 18 // problem
                    1100 0f00 fbff
                    1200 1100 fbff
                    1300 1100 fbff
                    ..............

                    */

                        pfc->yMax = - vtb.yMin;
                        pfc->yMin = - vtb.yMax;
                        pfc->lEmHtDev = vtb.yPelHeight;

                    // flag that dA and dD have been computed, do not scale linerly:

                        pfc->flXform |= XFORM_VDMXEXTENTS;
                        break;
                    }
                }
                else
                {
                    hTrial = LongMulDiv(ppemTrial, yHeightN, yEmN);

                    if (hTrial == hWish)
                    {
                        // hEqualOrBelow = hTrial;
                        break;
                    }
                }

                if (hTrial < hWish)
                {
                    // hEqualOrBelow = hTrial;
                    if (bWasAbove)
                    {
                        if (bFound) // just found this hTrial in the search above
                        {
                            pfc->yMax = - vtb.yMin;
                            pfc->yMin = - vtb.yMax;

                        // flag that dA and dD have been computed, do not scale linerly:

                            pfc->flXform |= XFORM_VDMXEXTENTS;
                        }
                        break;
                    }
                    ppemTrial = ppemTrial + 1;
                    bWasBelow  = TRUE;
                }
                else
                {
                    ppemTrial = ppemTrial - 1;   // <==== NEW POSITION
                    if (bWasBelow)
                    {
                        if (bFoundPrev) // just found this hTrial in the search above
                        {
                            ASSERTDD (ppemTrial == vtbPrev.yPelHeight,
                                      "vdmx logic messed up");

                            pfc->yMax = - vtbPrev.yMin;
                            pfc->yMin = - vtbPrev.yMax;

                        // flag that dA and dD have been computed, do not scale linerly:

                            pfc->flXform |= XFORM_VDMXEXTENTS;
                        }
                        break;
                    }
                                             // <==== OLD POSITION
                    bWasAbove = TRUE;
                }
            }
            pfc->lEmHtDev = ppemTrial;
        }
    }

// the following line means quantizing:

    pfc->mx.transform[1][1] = FixDiv(pfc->lEmHtDev, yEmN);

// now fix xx component accordingly: xxNew = xxOld * (yyNew/yyOld)

// we do one final tweak with the transform here:
// If the difference between
// horizontal and vertical scaling is so small that the resulting
// avg font width is the same if we replace x scaling by y scaling
// than we will do it, which will result in diag transform and we will
// be able to use hdmx tables for this realization. By doing so
// we ensure that we get the same realization when we enumerate font
// and then use the logfont returned from enumeration to realize this font
// again.

    if
    (
        (pfc->mx.transform[0][0] == fxMyy) ||
        (FixMul(pfc->mx.transform[0][0] - pfc->mx.transform[1][1],
                (Fixed)pfc->pff->ifi.fwdAveCharWidth) == 0)
    )
    {
        pfc->mx.transform[0][0] = pfc->mx.transform[1][1];
    }
    else
    {
        pfc->mx.transform[0][0] = LongMulDiv(
                                      pfc->mx.transform[0][0],
                                      pfc->mx.transform[1][1],
                                      fxMyy
                                      );
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gdiplusguids\imagingguds.cpp ===
//
// this is where we get the real defn's for all of the DEFINE_GUID statements
// so that people who link to gdiplus.lib will be able to resolve them
//

#include <windows.h>
#include <wtypes.h>
#include <objbase.h>
#define INITGUID
#include <guiddef.h>
#include <gdipluspixelformats.h>
#include <gdiplusImaging.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\xform.h ===
/******************************Module*Header*******************************\
* Module Name: xform.h
*
* (Brief description)
*
* Created: 05-Apr-1992 11:06:23
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/



typedef FLOAT EFLOAT;
typedef EFLOAT *PEFLOAT;

LONG lCvt(FLOAT f,LONG l);

typedef struct _VECTORFL
{
    EFLOAT x;
    EFLOAT y;
} VECTORFL, *PVECTORFL;


BOOL bFDXform
(
XFORML   *pxf,
POINTFIX *pptfxDst,
POINTL   *pptlSrc,
SIZE_T     c
);

BOOL bXformUnitVector
(
POINTL       *pptl,           // IN,  incoming unit vector
XFORML       *pxf,            // IN,  xform to use
EFLOAT       *pefNorm         // OUT, |*pptqXormed|
);

VOID vLTimesVtfl     // *pptq = l * pvtfl, *pptq is in 28.36 format
(
LONG       l,
VECTORFL  *pvtfl,
POINTQF   *pptq
);


FIX  fxLTimesEf  //!!! SHOULD BE MOVED TO TTFD and VTFD
(
EFLOAT *pef,
LONG    l
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\colors.c ===
/*****************************************************************************
 *
 * colors - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * History:
 *  Sep 1992	-by-	Hock San Lee	[hockl]
 * Complete rewrite.
 *
 *  The following implementation takes into account that all 16-bit metafile
 *  palette records reference the current palette.
 *
 *  CreatePalette
 *      Create a private copy of the logical palette in the converter but
 *      don't emit the 16-bit record.
 *
 *  SelectPalette
 *      Emit a CreatePalette record followed by a SelectPalette record.
 *      Then emit a 16-bit DeleteObject record to delete the previous palette.
 *      The selected logical palette can be queried from the private copy
 *      maintained by the converter.  You need to keep track of the current
 *      palette so that you can emit ResizePalette or SetPaletteEntries record
 *      if the palette identifies the current palette.  You also need to deal
 *      with the stock palette correctly here (you don't need to keep a
 *      private copy of the stock palette).  Don't delete the private copy
 *      of the logical palette here! (see DeleteObject below)
 *
 *  RealizePalette
 *      Just emit a 16-bit record.  This record always references the current
 *      palette in both 16 and 32-bit metafiles.
 *
 *  ResizePalette
 *      Update the private copy of the logical palette in the converter.
 *      Emit a 16-bit record only if the palette identifies the current palette.
 *
 *  SetPaletteEntries
 *      Update the private copy of the logical palette in the converter.
 *      Emit a 16-bit record only if the palette identifies the current palette.
 *
 *  DeleteObject
 *      Don't emit the 16-bit record for palettes since all palettes are
 *      deleted in SelectPalette above.  Similarly, don't emit palette delete
 *      records at the end of conversion.  However, you need to delete the
 *      private copy of the palette maintained by the converter here and at
 *      the end of conversion.
 *
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************
 *  SelectPalette  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Emit a CreatePalette record followed by a SelectPalette record.
 *      Then emit a 16-bit DeleteObject record to delete the previous palette.
 *      The selected logical palette can be queried from the private copy
 *      maintained by the converter.  You need to keep track of the current
 *      palette so that you can emit ResizePalette or SetPaletteEntries record
 *      if the palette identifies the current palette.  You also need to deal
 *      with the stock palette correctly here (you don't need to keep a
 *      private copy of the stock palette).  Don't delete the private copy
 *      of the logical palette here! (see DeleteObject below)
 *
 **************************************************************************/
BOOL WINAPI DoSelectPalette
(
PLOCALDC pLocalDC,
DWORD	 ihpal
)
{
BOOL	     b = FALSE;
WORD         cEntries;
LPLOGPALETTE lpLogPal = (LPLOGPALETTE) NULL;
HPALETTE     hpalW32;
INT	     ihW16, ihW32Norm;

	// No need to do anything if selecting the same palette.

	if (pLocalDC->ihpal32 == ihpal)
	    return(TRUE);

	// Validate the palette index.

	if ((ihpal != (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
	 && (ihpal >= pLocalDC->cW32hPal || !pLocalDC->pW32hPal[ihpal]))
	{
            RIPS("MF3216: DoSelectPalette - ihpal invalid");
            goto error_exit;
	}

	// Get the W32 handle.

	if (ihpal == (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
	    hpalW32 = GetStockObject(DEFAULT_PALETTE) ;
	else
	    hpalW32 = pLocalDC->pW32hPal[ihpal];

        if(hpalW32 == 0)
        {
            RIPS("MF3216: DoSelectPalette - hpalW32 == 0\n");
            goto error_exit;
        }
	// Emit a CreatePalette record.

	if (!GetObjectA(hpalW32, sizeof(WORD), &cEntries))
	{
	    RIPS("MF3216: DoSelectPalette - GetObjectA failed\n");
            goto error_exit;
	}

	if (!(lpLogPal = (LPLOGPALETTE) LocalAlloc(
				LMEM_FIXED,
				sizeof(LOGPALETTE) - sizeof(PALETTEENTRY)
				 + sizeof(PALETTEENTRY) * cEntries)))
            goto error_exit;

	lpLogPal->palVersion    = 0x300;
        lpLogPal->palNumEntries = cEntries;

	GetPaletteEntries(hpalW32, 0, cEntries, lpLogPal->palPalEntry);

	// Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihpal, REALIZED_PALETTE);
        if (ihW16 == -1)
            goto error_exit;

	if (!bEmitWin16CreatePalette(pLocalDC, lpLogPal))
            goto error_exit;

	// Emit a SelectPalette record.

	if (!SelectPalette(pLocalDC->hdcHelper, hpalW32, TRUE))
	    goto error_exit;

	if (!bEmitWin16SelectPalette(pLocalDC, (WORD) ihW16))
	    goto error_exit;

	// Emit a DeleteObject record to delete the previous palette.

	if (pLocalDC->ihpal16 != -1)
	{
	    ihW32Norm = iNormalizeHandle(pLocalDC, pLocalDC->ihpal32);
	    if (ihW32Norm == -1)
		goto error_exit;

	    pLocalDC->pW16ObjHndlSlotStatus[pLocalDC->ihpal16].use
		= OPEN_AVAILABLE_SLOT;
	    pLocalDC->piW32ToW16ObjectMap[ihW32Norm]
		= UNMAPPED;

	    bEmitWin16DeleteObject(pLocalDC, (WORD) pLocalDC->ihpal16);
	}

	pLocalDC->ihpal32 = ihpal;
	pLocalDC->ihpal16 = ihW16;

	b = TRUE;

error_exit:

        if (lpLogPal)
	    LocalFree((HANDLE) lpLogPal);

	return(b);
}

/***************************************************************************
 *  ResizePalette  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Update the private copy of the logical palette in the converter.
 *      Emit a 16-bit record only if the palette identifies the current palette.
 *
 **************************************************************************/
BOOL WINAPI DoResizePalette
(
PLOCALDC  pLocalDC,
DWORD     ihpal,
DWORD     cEntries
)
{
	// Do not modify the default palette.

	if (ihpal == (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
	    return(TRUE);

	// Validate the palette index.

	if (ihpal >= pLocalDC->cW32hPal || !pLocalDC->pW32hPal[ihpal])
	{
            RIPS("MF3216: DoResizePalette - ihpal invalid");
	    return(FALSE);
	}

	// Do it to the private palette.

	if (!ResizePalette(pLocalDC->pW32hPal[ihpal], cEntries))
	{
            RIPS("MF3216: DoResizePalette - ResizePalette failed");
	    return(FALSE);
	}

	// Emit a 16-bit record only if the palette identifies the
	// current palette.

	if (pLocalDC->ihpal32 == ihpal)
            return(bEmitWin16ResizePalette(pLocalDC, (WORD) cEntries));

        return(TRUE);
}

/***************************************************************************
 *  SetPaletteEntries  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Update the private copy of the logical palette in the converter.
 *      Emit a 16-bit record only if the palette identifies the current palette.
 *
 **************************************************************************/
BOOL WINAPI DoSetPaletteEntries
(
PLOCALDC       pLocalDC,
DWORD 	       ihpal,
DWORD 	       iStart,
DWORD 	       cEntries,
LPPALETTEENTRY pPalEntries
)
{
	// Do not modify the default palette.

	if (ihpal == (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
	    return(TRUE);

	// Validate the palette index.

	if (ihpal >= pLocalDC->cW32hPal || !pLocalDC->pW32hPal[ihpal])
	{
            RIPS("MF3216: DoSetPaletteEntries - ihpal invalid");
	    return(FALSE);
	}

	// Do it to the private palette.

	if (!SetPaletteEntries(pLocalDC->pW32hPal[ihpal], iStart, cEntries, pPalEntries))
	{
            RIPS("MF3216: DoSetPaletteEntries - SetPaletteEntries failed");
	    return(FALSE);
	}

	// Emit a 16-bit record only if the palette identifies the
	// current palette.

	if (pLocalDC->ihpal32 == ihpal)
            return(bEmitWin16SetPaletteEntries(pLocalDC, iStart, cEntries, pPalEntries));

        return(TRUE);
}

/***************************************************************************
 *  RealizePalette  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Just emit a 16-bit record.  This record always references the current
 *      palette in both 16 and 32-bit metafiles.
 *
 **************************************************************************/
BOOL WINAPI DoRealizePalette
(
PLOCALDC pLocalDC
)
{
        // Emit the Win16 metafile drawing order.

        return(bEmitWin16RealizePalette(pLocalDC));
}

/***************************************************************************
 *  CreatePalette  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Create a private copy of the logical palette in the converter but
 *      don't emit the 16-bit record.
 *
 **************************************************************************/
BOOL WINAPI DoCreatePalette
(
PLOCALDC     pLocalDC,
DWORD        ihPal,
LPLOGPALETTE lpLogPal
)
{
	if (ihPal != (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
        {
            LOGPALETTE *lpLogPalNew;

        // Validate the palette index.

	    if (ihPal >= pLocalDC->cW32hPal || pLocalDC->pW32hPal[ihPal])
                return(FALSE);

        // Allocate size of log palette + 2 entries for black and white.

            lpLogPalNew = LocalAlloc(LMEM_FIXED, lpLogPal->palNumEntries * sizeof(DWORD) + (sizeof(LOGPALETTE) + sizeof(DWORD)));

            if (lpLogPalNew == NULL)
            {
                return(FALSE);
            }

            RtlMoveMemory(lpLogPalNew, lpLogPal, lpLogPal->palNumEntries * sizeof(DWORD) + (sizeof(LOGPALETTE) - sizeof(DWORD)));
            lpLogPalNew->palNumEntries += 2;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 1].peRed   = 0;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 1].peGreen = 0;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 1].peBlue  = 0;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 1].peFlags = 0;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 2].peRed   = 0xff;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 2].peGreen = 0xff;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 2].peBlue  = 0xff;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 2].peFlags = 0;

        // Create a private copy of the logical palette and keep it
        // in the converter palette table.

            pLocalDC->pW32hPal[ihPal] = CreatePalette(lpLogPalNew);
            LocalFree(lpLogPalNew);

            if (!(pLocalDC->pW32hPal[ihPal]))
            {
                RIPS("MF3216: DoCreatePalette - CreatePalette failed\n") ;
                return(FALSE);
            }
        }

        return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\apientry.c ===
/*****************************************************************************
 *
 * apientry.c - This module contains the API entry points for the
 *              Win32 to Win16 metafile converter.
 *
 * Date: 8/29/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/


#include "precomp.h"
#pragma hdrstop

BOOL     bMemUpdateCheckSum(PLOCALDC pLocalDC) ;
PLOCALDC pldcInitLocalDC(HDC hdcRef, INT iMapMode, DWORD flags) ;
VOID     vFreeLocalDC(PLOCALDC pLocalDC);


extern VOID __cdecl _cfltcvt_init(VOID) ;

//CRITICAL_SECTION CriticalSection ;
//BOOL initCrit = FALSE ;

fnGetTransform pfnGetTransform = NULL ;
fnSetVirtualResolution pfnSetVirtualResolution = NULL;

// Constant definition for internal static string(s).

BYTE    szDisplay[] = "DISPLAY" ;


/*****************************************************************************
 * Entry point for translation
 *****************************************************************************/
UINT GdipConvertEmfToWmf(PBYTE pMetafileBits, UINT cDest, PBYTE pDest,
                         INT iMapMode, HDC hdcRef, UINT flags)
{
BOOL        b ;
DWORD       lret = 0;
PLOCALDC    pLocalDC ;
static HMODULE     hGDI32 = NULL;

        // This is the entry point... Make sure our function pointers are set
        if( hGDI32 == NULL )
        {
            hGDI32 = LoadLibrary(L"GDI32.DLL");
            if(hGDI32 != NULL)
            {
                pfnGetTransform = (fnGetTransform) GetProcAddress(hGDI32, "GetTransform");
                pfnSetVirtualResolution = (fnSetVirtualResolution) GetProcAddress(hGDI32, "SetVirtualResolution");
            }

            if(pfnSetVirtualResolution == NULL || pfnGetTransform == NULL )
            {
                pfnSetVirtualResolution = NULL ;
                pfnGetTransform = NULL ;
            }
        }

        // Check the requested map mode and if it's valid

        if (iMapMode < MM_MIN || iMapMode > MM_MAX)
        {
            RIPS("MF3216:ConvertEmfToWmf - Invalid MapMode\n") ;
            goto ErrorExit;
        }

        // Allocate the LocalDC and initialize some of it's fields.
        pLocalDC = pldcInitLocalDC(hdcRef, iMapMode, flags) ;
        if (pLocalDC == (PLOCALDC) 0)
        {
            goto ErrorExit ;
        }

        // If pDest is NULL then we just return the size of the buffer required
        // to hold the Win16 metafile bits.

        if (pDest == (PBYTE) 0)
        {
            pLocalDC->flags |= SIZE_ONLY ;
            b = bParseWin32Metafile(pMetafileBits, pLocalDC) ;
            if (b == TRUE)
            {
                lret = pLocalDC->ulBytesEmitted /* for the placeable Header */ ;
            }
            else
            {
                PUTS("MF3216: ConvertEmfToWmf - Size Only failed\n") ;
            }
        }
        else
        {

            // Put the user specified Win16 buffer pointer and buffer length
            // into the localDC.

            pLocalDC->pMf16Bits = pDest ;
            pLocalDC->cMf16Dest = cDest ;

            //  Translate the Win32 metafile to a Win16 metafile.

            b = bParseWin32Metafile(pMetafileBits, pLocalDC) ;
            if (b == TRUE)
            {
                // Update the Win16 metafile header.

                b = bUpdateMf16Header(pLocalDC) ;
                if (b == TRUE)
                {
                    // Only acknowledge that we have translated some bits
                    // if everything has gone well.

                    lret = pLocalDC->ulBytesEmitted;

                    // If we're including the Win32 metafile then update the
                    // checksum field in the "Win32Comment header" record.

                    if (pLocalDC->flags & INCLUDE_W32MF_COMMENT)
                        bMemUpdateCheckSum(pLocalDC) ;

                }
            }
            else
            {
                PUTS("MF3216: ConvertEmfToWmf - Metafile conversion failed\n") ;
            }
        }

        // Free the LocalDC and its resources.

        vFreeLocalDC(pLocalDC);

ErrorExit:

        return (lret) ;
}


/*****************************************************************************
 * pldcInitLocalDC - Initialize the Local DC.
 *****************************************************************************/
PLOCALDC pldcInitLocalDC(HDC hdcRef, INT iMapMode, DWORD flags)
{
PLOCALDC    pLocalDC;
PLOCALDC    pldcRet = (PLOCALDC) NULL;  // assume error

        // Allocate and initialize memory for the LocalDC.

        pLocalDC = (PLOCALDC) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                         sizeof(LOCALDC));
        if (!pLocalDC)
        {
            PUTS("MF3216:pldcInitLocalDC - LocalAlloc failure\n") ;
            return((PLOCALDC) NULL);
        }

        // Record the size of the DC.

        pLocalDC->nSize = sizeof(LOCALDC) ;

        // Set the LocalDC boolean that controls whether or not we include
        // the Win32 metafile as one or more comment records.

        if (flags & MF3216_INCLUDE_WIN32MF)
            pLocalDC->flags |= INCLUDE_W32MF_COMMENT ;

        if (flags & GPMF3216_INCLUDE_XORPATH)
            pLocalDC->flags |= INCLUDE_W32MF_XORPATH ;

#if 0
        // Need to create a hdc for the display.
        // Initially this will be used by the bitblt translation code
        // to get a reasonable set of palette entries.
        // The reference DC only has a black & white palette.

        pLocalDC->hdcDisp = CreateDCA((LPCSTR)szDisplay, (LPCSTR)NULL, (LPCSTR)NULL, (CONST DEVMODEA *)NULL) ;
        if (pLocalDC->hdcDisp == (HDC) 0)
        {
            RIPS("MF3216:pldcInitLocalDC - CreateDCA(hdcDisp) failed\n") ;
            goto pldcInitLocalDC_exit;
        }
#endif // 0

        //  Create the HelperDC.

        if( pfnSetVirtualResolution != NULL )
        {
            pLocalDC->hdcHelper = CreateICA((LPCSTR) szDisplay,
                                           (LPCSTR) NULL,
                                           (LPCSTR) NULL,
                                           (LPDEVMODEA) NULL) ;
            if (pLocalDC->hdcHelper == (HDC)0)
            {
                PUTS("MF3216: pldcInitLocalDC, Create Helper DC failed\n") ;
                goto pldcInitLocalDC_exit;
            }
        }

        // For Win9x the DC will be created when we parse the header

        // Initialize the counters we need to keep for updating the header,
        // and keeping track of the object table.

        pLocalDC->nObjectHighWaterMark = -1;

        // If the hdcRef == NULL then we use the size of the DC in the EMF header
        if (hdcRef != NULL)
        {
            // if hdcRef == NULL then we will use the values in the MF Header
            // They will get filled in before they are used.
            pLocalDC->cxPlayDevMM  = GetDeviceCaps(hdcRef, HORZSIZE);
            pLocalDC->cyPlayDevMM  = GetDeviceCaps(hdcRef, VERTSIZE);
            pLocalDC->cxPlayDevPels = GetDeviceCaps(hdcRef, HORZRES);
            pLocalDC->cyPlayDevPels = GetDeviceCaps(hdcRef, VERTRES);
        }
        // Record the requested map mode and reference DC.

        pLocalDC->iMapMode = iMapMode ;
        pLocalDC->hdcRef   = hdcRef ;

        // Init Arc Direction.

        pLocalDC->iArcDirection = AD_COUNTERCLOCKWISE ;

        // Make current position invalid so that a moveto will be
        // emitted when it is first used.  See comments in DoMoveTo.

        pLocalDC->ptCP.x = MAXLONG ;
        pLocalDC->ptCP.y = MAXLONG ;

        // Default pen is a black pen.

        pLocalDC->lhpn32  = BLACK_PEN | ENHMETA_STOCK_OBJECT;

        // Default brush is a white brush.

        pLocalDC->lhbr32  = WHITE_BRUSH | ENHMETA_STOCK_OBJECT;

        // Default palette.

        pLocalDC->ihpal32 = DEFAULT_PALETTE | ENHMETA_STOCK_OBJECT;
        pLocalDC->ihpal16 = (DWORD) -1; // no W16 palette created yet

        pLocalDC->crBkColor = RGB(0xFF,0xFF,0xFF);

//      pLocalDC->pW16ObjHndlSlotStatus = NULL;
//      pLocalDC->cW16ObjHndlSlotStatus = 0;
//      pLocalDC->piW32ToW16ObjectMap = NULL;
//      pLocalDC->cW32ToW16ObjectMap = 0;
//      pLocalDC->crTextColor = RGB(0x0,0x0,0x0);
//      pLocalDC->iLevel = 0;
//      pLocalDC->pLocalDCSaved = NULL;
//      pLocalDC->ulBytesEmitted = 0;
//      pLocalDC->ulMaxRecord = 0;
//      pLocalDC->pW32hPal = NULL;
//      pLocalDC->iXORPass = NOTXORPASS;
//      pLocalDC->pvOldPos = NULL;
//      pLocalDC->iROP = 0;

        // Set the advanced graphics mode in the helper DC.  This is needed
        // to notify the helper DC that rectangles and ellipses are
        // inclusive-inclusive etc., especially when rendering them in a path.
        // Also, the world transform can only be set in the advanced mode.

        if( pfnSetVirtualResolution != NULL )
        {
            (void) SetGraphicsMode(pLocalDC->hdcHelper, GM_ADVANCED);
        }

        // We are golden.

        pldcRet = pLocalDC;

pldcInitLocalDC_exit:

        if (!pldcRet)
            vFreeLocalDC(pLocalDC);

        return(pldcRet) ;
}

/*****************************************************************************
 * vFreeLocalDC - Free the Local DC and its resources.
 *****************************************************************************/
VOID vFreeLocalDC(PLOCALDC pLocalDC)
{
    UINT i;

// Free the helper DCs.

    if (pLocalDC->hdcHelper)
        if (!DeleteDC(pLocalDC->hdcHelper))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, DeleteDC failed");
#if 0
    if (pLocalDC->hdcDisp)
        if (!DeleteDC(pLocalDC->hdcDisp))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, DeleteDC failed");
#endif // 0

    if (pLocalDC->hbmpMem)
    {
        if (!DeleteObject(pLocalDC->hbmpMem))
        {
            ASSERTGDI(FALSE, "GPMF3216: vFreeLocalDC, DeleteObject failed");
        }
    }

// Free the storage for the object translation map.

    if (pLocalDC->piW32ToW16ObjectMap)
    {
#if 0
        for (i = 0 ; i < pLocalDC->cW32ToW16ObjectMap ; i++)
        {
            if (pLocalDC->piW32ToW16ObjectMap[i] != UNMAPPED)
                if (i > STOCK_LAST)
                    PUTS1("MF3216: vFreeLocalDC, object32 %ld is not freed\n", i - STOCK_LAST - 1);
                else
                    PUTS1("MF3216: vFreeLocalDC, stock object32 %ld is mapped\n",i);
        }
#endif // 0

        if (LocalFree(pLocalDC->piW32ToW16ObjectMap))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
    }

// Free the W32 palette handles.

    if (pLocalDC->pW32hPal)
    {
    for (i = 0; i < pLocalDC->cW32hPal; i++)
    {
        if (pLocalDC->pW32hPal[i])
                if (!DeleteObject(pLocalDC->pW32hPal[i]))
                    ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, delete palette failed");
    }

        if (LocalFree(pLocalDC->pW32hPal))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
    }

// Free the w32 handles in the pW16ObjHndlSlotStatus array.
// We free the handles after we have deleted the helper DC so that
// the w32 handles are not selected into any DC.

    if (pLocalDC->pW16ObjHndlSlotStatus)
    {
        for (i = 0 ; i < pLocalDC->cW16ObjHndlSlotStatus ; i++)
        {
#if 0
            if (pLocalDC->pW16ObjHndlSlotStatus[i].use
                != OPEN_AVAILABLE_SLOT)
                PUTS1("MF3216: vFreeLocalDC, object16 %ld is not freed\n", i);
#endif // 0

            if (pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle)
            {
                ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[i].use
                          != OPEN_AVAILABLE_SLOT,
                          "MF3216: error in object handle table");

                if (!DeleteObject(pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle))
                    ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, DeleteObject failed");
            }
        }

        if (LocalFree(pLocalDC->pW16ObjHndlSlotStatus))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
    }

    ASSERTGDI((pLocalDC->flags & (ERR_BUFFER_OVERFLOW | ERR_XORCLIPPATH)) ||
              (pLocalDC->pW16RecreationSlot == NULL),
              "MF3216 Recreation slots haven't been freed");
    DoDeleteRecreationSlots(pLocalDC);

    // The DC level should be balanced.
    if (pLocalDC->pLocalDCSaved != NULL)
    {
        PLOCALDC pNext, pTmp;

        for (pNext = pLocalDC->pLocalDCSaved; pNext; )
        {
            PUTS("MF3216: vFreeLocalDC, unbalanced DC level\n");

            pTmp = pNext->pLocalDCSaved;
            if (LocalFree(pNext))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
            pNext = pTmp;
        }
    }

// Finally, free the LocalDC.

    if (LocalFree(pLocalDC))
        ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
}


/***************************************************************************
 *  Handle emitting the Win32  metafile comment  record(s).
 **************************************************************************/
BOOL bHandleWin32Comment(PLOCALDC pLocalDC)
{
INT     i;
BOOL    b ;
META_ESCAPE_ENHANCED_METAFILE mfeEnhMF;

    // Win30 may have problems with large (over 8K) escape records.
    // We will limit the size of each Win32 Comment record to
    // MAX_WIN32_COMMENT_REC_SIZE.

    // Initialize the record header.

    mfeEnhMF.rdFunction = META_ESCAPE;
    mfeEnhMF.wEscape    = MFCOMMENT;
    mfeEnhMF.ident      = MFCOMMENT_IDENTIFIER;
    mfeEnhMF.iComment   = MFCOMMENT_ENHANCED_METAFILE;
    mfeEnhMF.nVersion   = ((PENHMETAHEADER) pLocalDC->pMf32Bits)->nVersion;
    mfeEnhMF.wChecksum  = 0;   // updated by bMemUpdateCheckSum
    mfeEnhMF.fFlags     = 0;
    mfeEnhMF.nCommentRecords
    = (pLocalDC->cMf32Bits + MAX_WIN32_COMMENT_REC_SIZE - 1)
      / MAX_WIN32_COMMENT_REC_SIZE;
    mfeEnhMF.cbEnhMetaFile = pLocalDC->cMf32Bits;

    mfeEnhMF.cbRemainder = pLocalDC->cMf32Bits;
    i = 0 ;
    while (mfeEnhMF.cbRemainder)
    {
    mfeEnhMF.cbCurrent = min(mfeEnhMF.cbRemainder, MAX_WIN32_COMMENT_REC_SIZE);
    mfeEnhMF.rdSize = (sizeof(mfeEnhMF) + mfeEnhMF.cbCurrent) / 2;
    mfeEnhMF.wCount = (WORD)(sizeof(mfeEnhMF) + mfeEnhMF.cbCurrent - sizeof(METARECORD_ESCAPE));
    mfeEnhMF.cbRemainder -= mfeEnhMF.cbCurrent;

    b = bEmitWin16EscapeEnhMetaFile(pLocalDC,
        (PMETARECORD_ESCAPE) &mfeEnhMF, &pLocalDC->pMf32Bits[i]);

    if (!b)
        break;
    i += mfeEnhMF.cbCurrent;
    }

    return(b) ;
}


/*****************************************************************************
 * bMemUpdateCheckSum - Update the checksum
 *****************************************************************************/
BOOL bMemUpdateCheckSum(PLOCALDC pLocalDC)
{
INT         i, k ;
PWORD       pword ;
WORD        CheckSum ;
PMETA_ESCAPE_ENHANCED_METAFILE pmfeEnhMF;


    // CheckSum the file.
    // Do a 16 bit checksum

    pword = (PWORD) pLocalDC->pMf16Bits ;
    k = pLocalDC->ulBytesEmitted / 2 ;

    CheckSum = 0 ;
    for (i = 0 ; i < k ; i++)
    CheckSum += pword[i] ;

    // Update the checksum record value with the real checksum.

    pmfeEnhMF = (PMETA_ESCAPE_ENHANCED_METAFILE)
            &pLocalDC->pMf16Bits[sizeof(METAHEADER)];

    ASSERTGDI(IS_META_ESCAPE_ENHANCED_METAFILE(pmfeEnhMF)
       && pmfeEnhMF->wChecksum  == 0
       && pmfeEnhMF->fFlags     == 0,
    "MF3216: bMemUpdateCheckSum: Bad pmfeEnhMF");

    pmfeEnhMF->wChecksum = -CheckSum;

#if DBG
    // Now test the checksum.  The checksum of the entire file
    // should be 0.

    CheckSum = 0 ;
    pword = (PWORD) pLocalDC->pMf16Bits ;
    for (i = 0 ; i < k ; i++)
    CheckSum += pword[i] ;

    if (CheckSum != 0)
    {
    RIPS("MF3216: MemUpdateCheckSum, (CheckSum != 0)\n") ;
    }
#endif
    return (TRUE) ;
}


/******************************Public*Routine******************************\
* Mf3216DllInitialize                                                      *
*                                                                          *
* This is the init procedure for MF3216.DLL,                               *
* which is called each time a new                                          *
* process links to it.                                                     *
\**************************************************************************/

BOOL Mf3216DllInitialize(PVOID pvDllHandle, DWORD ulReason, PCONTEXT pcontext)
{
        NOTUSED(pvDllHandle) ;
        NOTUSED(pcontext) ;

        if ( ulReason == DLL_PROCESS_ATTACH )
        {
            // This does the critical section initialization for a single
            // process.  Each process does this.  The CriticalSection data
            // structure is one of the very few (if not the only one) data
            // structures in the data segment.

//            InitializeCriticalSection(&CriticalSection) ;

        }

        return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\emit.c ===
/*****************************************************************************
 *
 * emit - Emit routines for MF3216
 *
 * Date: 7/17/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 *  01-Feb-1992     -by-        c-jeffn
 *
 *      Major code cleanup from Code review 1.
 *
 * Copyright (c) 1991,92 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*----------------------------------------------------------------------------
 *  Emit (copy) nCount Bytes in pBuffer to the user supplied output buffer.
 *
 *  If this is a size only request, send the bits to the bit-bucket and
 *  just keep track of the size.
 *
 *  Note: ERROR_BUFFER_OVERFLOW flag is set in pLocalDC if output buffer
 *  is overrun.
 *---------------------------------------------------------------------------*/
BOOL bEmit(PLOCALDC pLocalDC, PVOID pBuffer, DWORD nCount)
{
BOOL    b ;
UINT    ulBytesEmitted ;

        b = TRUE ;

        // Test for a size only request.

        if (!(pLocalDC->flags & SIZE_ONLY))
        {
            ulBytesEmitted = pLocalDC->ulBytesEmitted ;
            if ((ulBytesEmitted + nCount) <= pLocalDC->cMf16Dest)
            {
                memcpy(&(pLocalDC->pMf16Bits[ulBytesEmitted]), pBuffer, nCount) ;
                b = TRUE ;
            }
            else
            {
                // Signal output buffer overflow error.
                // It can happen that we overflow the buffer if we fail the XOR
                // pass but don't fail the second pass. If the failure in the
                // XOR pass happens after we have reached the end of the buffer
                // the we will have a buffer overflow because it wasn't the
                // initial XOR pass that returned the size but the second pass
                // (The same thing could happen between the second pass and the
                // GDI pass) so we make it only a warning now.
                pLocalDC->flags |= ERR_BUFFER_OVERFLOW;
                b = FALSE ;

                WARNING(("MF3216: bEmit, (pLocalDC->ulBytesEmitted + nCount) > cMf16Dest \n"));
            }


        }

        // Update the local DC byte count

        pLocalDC->ulBytesEmitted += nCount ;

        return(b) ;

}



/*----------------------------------------------------------------------------
 * Update the max record size.  Used to update the metafile header.
 *---------------------------------------------------------------------------*/
VOID vUpdateMaxRecord(PLOCALDC pLocalDC, PMETARECORD pmr)
{

    if (pLocalDC->ulMaxRecord < pmr->rdSize)
        pLocalDC->ulMaxRecord = pmr->rdSize;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\beziers.c ===
/*****************************************************************************
 *
 * beziers - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOL PolyBezierCommon(PLOCALDC pLocalDC, LPPOINT pptl, PBYTE pb, DWORD cptl, DWORD mrType) ;


/***************************************************************************
 *  PolyDraw  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyDraw
(
PLOCALDC pLocalDC,
LPPOINT pptl,
PBYTE   pb,
DWORD   cptl
)
{
        return(PolyBezierCommon(pLocalDC, pptl, pb, cptl, EMR_POLYDRAW));
}

/***************************************************************************
 *  PolyBezier  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyBezier
(
PLOCALDC pLocalDC,
LPPOINT pptl,
DWORD   cptl
)
{
        return(PolyBezierCommon(pLocalDC, pptl, (PBYTE) NULL, cptl, EMR_POLYBEZIER));
}

/***************************************************************************
 *  PolyBezierTo  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyBezierTo
(
PLOCALDC pLocalDC,
LPPOINT pptl,
DWORD   cptl
)
{
        return(PolyBezierCommon(pLocalDC, pptl, (PBYTE) NULL, cptl, EMR_POLYBEZIERTO));
}

/***************************************************************************
 *  PolyBezierCommon  - Common code for PolyDraw, PolyBezier and PolyBezierTo
 **************************************************************************/
BOOL PolyBezierCommon(PLOCALDC pLocalDC, LPPOINT pptl, PBYTE pb, DWORD cptl, DWORD mrType)
{
BOOL    b ;

// If we're recording the drawing order for a path
// then just pass the drawing order to the helper DC.
// Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        {
            // On Win9x transform the points with the WorldToPage transform
            // before calling the HelperDC functions
            if (pfnSetVirtualResolution == NULL)
            {
                if (!bXformWorkhorse((PPOINTL) pptl, cptl, &pLocalDC->xformRWorldToRDev))
                    return FALSE;
            }
            switch (mrType)
            {
                case EMR_POLYBEZIER:
                    b = PolyBezier(pLocalDC->hdcHelper, pptl, cptl) ;
                    break ;

                case EMR_POLYBEZIERTO:
                    b = PolyBezierTo(pLocalDC->hdcHelper, pptl, cptl) ;
                    break ;

                case EMR_POLYDRAW:
                    b = PolyDraw(pLocalDC->hdcHelper, pptl, pb, cptl) ;
                    break ;

                default:
                    b = FALSE;
                    RIPS(("MF3216: PolyBezierCommon, bad mrType\n")) ;
                    break ;
            }

            ASSERTGDI(b, "MF3216: PolyBezierCommon, in path render failed\n") ;
            return (b) ;
        }

// Call the common curve renderer.

        return
        (
            bRenderCurveWithPath(pLocalDC, pptl, pb, cptl,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0.0f, 0.0f, mrType)
        );
}


/***************************************************************************
 *  bRenderCurveWithPath - Renders a curve or area using the path api.
 *     The supported curves and areas are PolyDraw, PolyBezier, PolyBezierTo,
 *     AngleArc, Arc, Chord, Pie, Ellipse, Rectangle, and RoundRect.
 **************************************************************************/
BOOL bRenderCurveWithPath
(
    PLOCALDC pLocalDC,
    LPPOINT  pptl,
    PBYTE    pb,
    DWORD    cptl,
    INT      x1,
    INT      y1,
    INT      x2,
    INT      y2,
    INT      x3,
    INT      y3,
    INT      x4,
    INT      y4,
    DWORD    nRadius,
    FLOAT    eStartAngle,
    FLOAT    eSweepAngle,
    DWORD    mrType
)
{
    BOOL     b = FALSE;
    INT      iPathType;
    POINTL   ppts[4] = {x1, y1, x2, y2, x3, y3, x4, y4};

    if (pfnSetVirtualResolution == NULL)
    {
        // On Win9x tranform the points before passing them to the DC
        if (!bXformWorkhorse((PPOINTL) pptl, cptl, &pLocalDC->xformRWorldToRDev))
        {
            RIPS("GPMF3216: bRenderCurveWithPath, BeginPath failed\n");
            goto exit_bRenderCurveWithPath;
        }
        if (!bXformWorkhorse(ppts, 4, &pLocalDC->xformRWorldToRDev))
        {
            RIPS("GPMF3216: bRenderCurveWithPath, BeginPath failed\n");
            goto exit_bRenderCurveWithPath;
        }
    }

// We don't do curves in a path bracket here.  They should be
// taken care of by the caller.

    ASSERTGDI(!(pLocalDC->flags & RECORDING_PATH),
        "MF3216: bRenderCurveWithPath, cannot be in a path bracket\n");

// Save the helper DC first.
// This is to prevent us from accidentally deleteing the current path
// in the helper DC when we create another path to render the curve.
// E.g. BeginPath, Polyline, EndPath, PolyBezier, StrokePath.

    if (!SaveDC(pLocalDC->hdcHelper))
    {
        RIPS("MF3216: bRenderCurveWithPath, SaveDC failed\n");
        return(FALSE);
    }

// Create the path for the curve and stroke it.
// Be careful not to modify the states of the LocalDC especially in
// DoRenderPath below.
// Note that BeginPath uses the previous current position.  So this
// code will work correctly in the case of PolyBezierTo, PolyDraw
// and AngleArc.

    // Begin the path.

    b = BeginPath(pLocalDC->hdcHelper);
    if (!b)
    {
        RIPS("MF3216: bRenderCurveWithPath, BeginPath failed\n");
        goto exit_bRenderCurveWithPath;
    }

    // Do the curve.


    switch (mrType)
    {
        case EMR_POLYBEZIER:

            iPathType = EMR_STROKEPATH;
            b = PolyBezier(pLocalDC->hdcHelper, pptl, cptl);
            break;

        case EMR_POLYBEZIERTO:
            iPathType = EMR_STROKEPATH;
            b = PolyBezierTo(pLocalDC->hdcHelper, pptl, cptl);
            break;

        case EMR_POLYDRAW:
            iPathType = EMR_STROKEPATH;
            b = PolyDraw(pLocalDC->hdcHelper, pptl, pb, cptl);
            break;

        case EMR_ANGLEARC:
            iPathType = EMR_STROKEPATH;
            b = AngleArc(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, nRadius, eStartAngle, eSweepAngle);
            break;

        case EMR_ARC:
            iPathType = EMR_STROKEPATH;
            b = Arc(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                         ppts[2].x, ppts[2].y, ppts[3].x, ppts[3].y);
            break;

        case EMR_CHORD:
            iPathType = EMR_STROKEANDFILLPATH;
            b = Chord(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                           ppts[2].x, ppts[2].y, ppts[3].x, ppts[3].y);
            break;

        case EMR_PIE:
            iPathType = EMR_STROKEANDFILLPATH;
            b = Pie(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                         ppts[2].x, ppts[2].y, ppts[3].x, ppts[3].y);
            break;

        case EMR_ELLIPSE:
            iPathType = EMR_STROKEANDFILLPATH;
            b = Ellipse(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y);
            break;

        case EMR_RECTANGLE:
            iPathType = EMR_STROKEANDFILLPATH;
            b = Rectangle(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y) ;
            break;

        case EMR_ROUNDRECT:
            iPathType = EMR_STROKEANDFILLPATH;
            b = RoundRect(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                               ppts[2].x, ppts[2].y) ;
            break;

        default:
            b = FALSE;
            RIPS("MF3216: bRenderCurveWithPath, bad mrType");
            break;
    }

    if (!b)
    {
        RIPS("MF3216: bRenderCurveWithPath, render failed\n");
        goto exit_bRenderCurveWithPath;
    }

    // End the path

    b = EndPath(pLocalDC->hdcHelper);
    if (!b)
    {
        RIPS("MF3216: bRenderCurveWithPath, EndPath failed\n");
        goto exit_bRenderCurveWithPath;
    }

    // Stroke or fill the path.

    b = DoRenderPath(pLocalDC, iPathType, FALSE);
    if (!b)
    {
        RIPS("MF3216: bRenderCurveWithPath, DoRenderPath failed\n");
        goto exit_bRenderCurveWithPath;
    }

exit_bRenderCurveWithPath:

// Restore the helper DC.

    if (!RestoreDC(pLocalDC->hdcHelper, -1))
        ASSERTGDI(FALSE, "MF3216: bRenderCurveWithPath, RestoreDC failed\n") ;

// If this is a PolyBezeirTo, PolyDraw or AngleArc, make the call to the
// helper DC to update its current position.

    if (b)
    {
        switch (mrType)
        {
            case EMR_POLYBEZIER:
            case EMR_ARC:
            case EMR_CHORD:
            case EMR_PIE:
            case EMR_ELLIPSE:
            case EMR_RECTANGLE:
            case EMR_ROUNDRECT: // no need to update the helper DC
                break ;

            case EMR_POLYBEZIERTO:
                (void) PolyBezierTo(pLocalDC->hdcHelper, pptl, cptl) ;
                break ;

            case EMR_POLYDRAW:
                (void) PolyDraw(pLocalDC->hdcHelper, pptl, pb, cptl) ;
                break ;

            case EMR_ANGLEARC:
                (void) AngleArc(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, nRadius, eStartAngle, eSweepAngle);
                break ;

            default:
                RIPS("MF3216: bRenderCurveWithPath, bad mrType");
                break;
        }
    }

// Return the result.

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\bitmaps.c ===
/*****************************************************************************
*
* bitmaps - Entry points for Win32 to Win 16 converter
*
* History:
*  Sep 1992    -by-    Hock San Lee    [hockl]
* Big rewrite.
*
* Copyright 1991 Microsoft Corp
*****************************************************************************/

#include "precomp.h"
#pragma hdrstop

HDC hdcMakeCompatibleDC(LPXFORM lpxform);

HBITMAP CreateMonoDib(LPBITMAPINFO pbmi, CONST BYTE * pjBits, UINT iUsage);

BOOL bEmitBitmap(PLOCALDC pLocalDC, HBITMAP hbm,
                 LONG xDst, LONG yDst, LONG cxDst, LONG cyDst,
                 LONG xSrc, LONG ySrc, LONG cxSrc, LONG cySrc, DWORD rop);

BOOL WINAPI DoMakeBitmapBottomUp
(
 PBITMAPINFO lpBitmapInfo,
 DWORD       cbBitmapInfo,
 LPBYTE      lpBits,
 DWORD       cbBits
 );



#define ABS(A)      ((A) < 0 ? (-(A)) : (A))

/****************************** Internal Function **************************\
* GetSizeOfColorTable (LPBITMAPINFOHEADER lpDIBInfo)
*
* Returns the number of bytes in the color table for the giving info header
*
\***************************************************************************/

WORD GetSizeOfColorTable (LPBITMAPINFOHEADER lpDIBInfo)
{
    PUTS("GetSizeOfColorTable\n");

    ASSERTGDI(!((ULONG_PTR) lpDIBInfo & 0x3), "GetSizeOfColorTable: dword alignment error\n");

    if (lpDIBInfo->biBitCount == 16 || lpDIBInfo->biBitCount == 32)
        return(3 * sizeof(DWORD));

    if (lpDIBInfo->biClrUsed)
        return((WORD)lpDIBInfo->biClrUsed * (WORD)sizeof(RGBQUAD));

    if (lpDIBInfo->biBitCount < 16)
        return((1 << lpDIBInfo->biBitCount) * sizeof(RGBQUAD));
    else
        return(0);
}



BOOL APIENTRY DoStretchBltAlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 HDC          hdcSrc,
 HBITMAP      hbmSrc,
 PXFORM       pxformSrc
 );

BOOL APIENTRY DoRotatedStretchBlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 PXFORM       pxformSrc,
 DWORD        iUsageSrc,
 PBITMAPINFO  lpBitmapInfo,
 DWORD        cbBitmapInfo,
 LPBYTE       lpBits
 );

BOOL APIENTRY DoMaskBltNoSrc
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop4,
 PXFORM       pxformSrc,
 LONG         xMask,
 LONG         yMask,
 DWORD        iUsageMask,
 PBITMAPINFO  lpBitmapInfoMask,
 DWORD        cbBitmapInfoMask,
 LPBYTE       lpBitsMask,
 DWORD        cbBitsMask
 );



 /***************************************************************************
 * SetDIBitsToDevice - Win32 to Win16 Metafile Converter Entry Point
 *
 *  CR2: Notes...
 *      The xDib, yDib, cxDib, & cyDib are in device units.  These must be
 *      converted to logical units for the stretchblt.
**************************************************************************/
BOOL APIENTRY DoSetDIBitsToDevice
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         xDib,
 LONG         yDib,
 LONG         cxDib,
 LONG         cyDib,
 DWORD        iUsage,
 DWORD        iStartScan,
 DWORD        cScans,
 LPBITMAPINFO lpBitmapInfo,
 DWORD        cbBitmapInfo,
 LPBYTE       lpBits,
 DWORD        cbBits
 )
{
    BOOL    b ;
    LPBITMAPINFO pbmi;
    POINTL       ptlDst ;
    RECTL        rclDst ;

    b = FALSE;

    if (!cbBitmapInfo)
        return(FALSE);

    // Adjust the height of the bitmap we're going to Blt.

    pbmi = (LPBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfo);
    if (pbmi == (LPBITMAPINFO) NULL)
        goto dsdbd_exit;

    RtlCopyMemory(pbmi, lpBitmapInfo, cbBitmapInfo);
    pbmi->bmiHeader.biHeight = cScans;
    pbmi->bmiHeader.biSizeImage = cbBits;

    // We will convert it into a StretchBlt call.  But first we have to
    // transform the destination rectangle.  In SetDIBitsToDevice, the destination
    // rectangle is in device units but in StretchBlt, it is in logical units.

    // Transform the destination origin to the device units on the original device.

    ptlDst.x = xDst;
    ptlDst.y = yDst;
    if (!bXformRWorldToRDev(pLocalDC, &ptlDst, 1))
        goto dsdbd_exit;

    // Transform the destination rectangle to record time world coordinates.

    rclDst.left   = ptlDst.x;
    rclDst.top    = ptlDst.y;
    rclDst.right  = ptlDst.x + cxDib;
    rclDst.bottom = ptlDst.y + cyDib;
    if (!bXformRDevToRWorld(pLocalDC, (PPOINTL) &rclDst, 2))
        goto dsdbd_exit;

    b = DoStretchBlt
        (
        pLocalDC,
        rclDst.left,
        rclDst.top,
        rclDst.right - rclDst.left,
        rclDst.bottom - rclDst.top,
        SRCCOPY,
        xDib,
        // dib to bitmap units
        ABS(pbmi->bmiHeader.biHeight) - yDib - cyDib + (LONG) iStartScan,
        cxDib,
        cyDib,
        &xformIdentity,     // source is in device units
        iUsage,
        pbmi,
        cbBitmapInfo,
        lpBits,
        cbBits
        );

dsdbd_exit:
    if (pbmi)
        LocalFree(pbmi);

    return(b);
}


/***************************************************************************
* StretchDIBits - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL APIENTRY DoStretchDIBits
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xDib,
 LONG         yDib,
 LONG         cxDib,
 LONG         cyDib,
 DWORD        iUsage,
 LPBITMAPINFO lpBitmapInfo,
 DWORD        cbBitmapInfo,
 LPBYTE       lpBits,
 DWORD        cbBits
 )
{
    BOOL    b ;

    b = DoStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        rop,
        xDib,
        ISSOURCEINROP3(rop)
        // dib to bitmap units
        ? ABS(lpBitmapInfo->bmiHeader.biHeight) - yDib - cyDib
        : 0,
        cxDib,
        cyDib,
        &xformIdentity,     // source is in device units
        iUsage,
        lpBitmapInfo,
        cbBitmapInfo,
        lpBits,
        cbBits
        );

    return(b) ;
}


/***************************************************************************
*  StretchBltAlt
**************************************************************************/
BOOL APIENTRY DoStretchBltAlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 HDC          hdcSrc,
 HBITMAP      hbmSrc,
 PXFORM       pxformSrc
 )
{
    BITMAPINFOHEADER bmih;
    DWORD            cbBitmapInfo;
    LPBITMAPINFO     lpBitmapInfo;
    DWORD            cbBits;
    LPBYTE           lpBits;
    BOOL         b;

    b = FALSE;

    // A NOOP ROP do nothing
    if (rop == 0x00AA0029)
    {
        return TRUE;
    }
    lpBitmapInfo = (LPBITMAPINFO) NULL;
    lpBits       = (LPBYTE) NULL;

    if (!ISSOURCEINROP3(rop))
        return
        (
        DoStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        rop,
        0,
        0,
        0,
        0,
        (PXFORM) NULL,
        0,
        (PBITMAPINFO) NULL,
        0,
        (LPBYTE) NULL,
        0
        )
        );

    bmih.biSize = sizeof(BITMAPINFOHEADER);
    bmih.biBitCount = 0;    // don't fill in color table
    bmih.biCompression = BI_RGB;

    if (!GetDIBits(hdcSrc,
        hbmSrc,
        0,
        0,
        (LPBYTE) NULL,
        (LPBITMAPINFO) &bmih,
        DIB_RGB_COLORS))
        goto dsba_exit;

    // Compute size of the bitmap info with color table.

    cbBitmapInfo= sizeof(BITMAPINFOHEADER);
    if (bmih.biBitCount == 16 || bmih.biBitCount == 32)
        cbBitmapInfo += 3 * sizeof(DWORD);
    else if (bmih.biClrUsed)
        cbBitmapInfo += bmih.biClrUsed * sizeof(RGBQUAD);
    else if (bmih.biBitCount < 16)
        cbBitmapInfo += (1 << bmih.biBitCount) * sizeof(RGBQUAD);

    // Compute size of the buffer required for bitmap bits.

    if (bmih.biSizeImage)
        cbBits = bmih.biSizeImage;
    else
        cbBits = CJSCAN(bmih.biWidth,bmih.biPlanes, bmih.biBitCount) *
        ABS(bmih.biHeight);

    lpBitmapInfo = (LPBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfo);
    if (lpBitmapInfo == (LPBITMAPINFO) NULL)
        goto dsba_exit;

    lpBits = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBits);
    if (lpBits == (LPBYTE) NULL)
        goto dsba_exit;

    // Get bitmap info and bits.

    *(PBITMAPINFOHEADER) lpBitmapInfo = bmih;

    if (!GetDIBits(hdcSrc,
        hbmSrc,
        0,
        (UINT) ABS(bmih.biHeight),
        lpBits,
        lpBitmapInfo,
        DIB_RGB_COLORS))
        goto dsba_exit;

    // Call DoStretchBlt.

    b = DoStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        rop,
        xSrc,
        ySrc,
        cxSrc,
        cySrc,
        pxformSrc,
        DIB_RGB_COLORS,
        lpBitmapInfo,
        cbBitmapInfo,
        lpBits,
        cbBits
        );

dsba_exit:
    if (lpBitmapInfo)
        LocalFree((HANDLE) lpBitmapInfo);
    if (lpBits)
        LocalFree((HANDLE) lpBits);

    return(b);
}


/***************************************************************************
*  StretchBlt  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL APIENTRY DoStretchBlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 PXFORM       pxformSrc,
 DWORD        iUsageSrc,
 PBITMAPINFO  lpBitmapInfo,
 DWORD        cbBitmapInfo,
 LPBYTE       lpBits,
 DWORD        cbBits
 )
{
    BOOL    b;
    RECTL   rclDst,
            rclSrc;

    // A NOOP ROP do nothing
    if (rop == 0x00AA0029)
    {
        return TRUE;
    }


    // Handle strange destination transform separately.

    if (pLocalDC->flags & STRANGE_XFORM)
        return
        (
        DoRotatedStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        rop,
        xSrc,
        ySrc,
        cxSrc,
        cySrc,
        pxformSrc,
        iUsageSrc,
        lpBitmapInfo,
        cbBitmapInfo,
        lpBits
        )
        );

    if (pLocalDC->iXORPass != NOTXORPASS)
    {
        if (rop == SRCCOPY)
        {
            rop = SRCINVERT;
        }
        else if (rop == PATCOPY)
        {
            rop = PATINVERT;
        }
        else
        {
            pLocalDC->flags |= ERR_XORCLIPPATH;
            return FALSE;
        }
    }


    // Do stretchblt with a simple destination transform.

    // Translate the dest rectangle

    rclDst.left   = xDst;
    rclDst.top    = yDst;
    rclDst.right  = xDst + cxDst;
    rclDst.bottom = yDst + cyDst;
    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &rclDst, 2))
        return(FALSE);

    // Handle stretchblt without source

    if (!ISSOURCEINROP3(rop))
    {
        // Emit the Win16 metafile record.

        b = bEmitWin16BitBltNoSrc(pLocalDC,
            (SHORT) rclDst.left,
            (SHORT) rclDst.top,
            (SHORT) (rclDst.right - rclDst.left),
            (SHORT) (rclDst.bottom - rclDst.top),
            rop);
        return(b);
    }

    // Handle stretchblt with source

    // Note: Both Win32 and Win16 DIB Bitmaps are DWord aligned.

    // Make sure the source xform is valid.
    // The source is not allowed to have a rotation or shear.

    if (bRotationTest(pxformSrc) == TRUE)
    {
        RIPS("MF3216: DoStretchBlt - Invalid source xform\n");
        SetLastError(ERROR_INVALID_DATA);
        return(FALSE);
    }

    // Translate the source rectangle.  Win3.1 assumes that the
    // source rectangle is in bitmap units.

    rclSrc.left   = xSrc;
    rclSrc.top    = ySrc;
    rclSrc.right  = xSrc + cxSrc;
    rclSrc.bottom = ySrc + cySrc;
    if (!bXformWorkhorse((PPOINTL) &rclSrc, 2, pxformSrc))
        return(FALSE);

    // The win3.1 StretchBlt metafile record only accepts win3.1 standard
    // bitmap with DIB_RGB_COLORS usage.  If this is not the case, we have
    // to convert it to a standard bitmap.

    if (iUsageSrc != DIB_RGB_COLORS
        || lpBitmapInfo->bmiHeader.biPlanes != 1
        || !(lpBitmapInfo->bmiHeader.biBitCount == 1
        || lpBitmapInfo->bmiHeader.biBitCount == 4
        || lpBitmapInfo->bmiHeader.biBitCount == 8
        || lpBitmapInfo->bmiHeader.biBitCount == 24)
        || lpBitmapInfo->bmiHeader.biCompression != BI_RGB )
    {
        HBITMAP hbmSrc;
        DWORD fdwInit;

        b = FALSE;
        hbmSrc = (HBITMAP) 0;

        if( ( lpBitmapInfo->bmiHeader.biCompression == BI_RGB ) ||
            ( lpBitmapInfo->bmiHeader.biCompression == BI_BITFIELDS ) )
        {
            fdwInit = CBM_INIT | CBM_CREATEDIB;
        }
        else
        {
            fdwInit = CBM_INIT;
        }

        // Create the source bitmap.
        // Use the helper DC in CreateDIBitmap so that the colors get bind correctly.
        if (!(hbmSrc = CreateDIBitmap(
            pLocalDC->hdcHelper,
            (LPBITMAPINFOHEADER) lpBitmapInfo,
            fdwInit,
            lpBits,
            lpBitmapInfo,
            (UINT) iUsageSrc)))
            goto dsb_internal_exit;

        // Emit the bitmap.

        b = bEmitBitmap(pLocalDC,
            hbmSrc,
            rclDst.left,
            rclDst.top,
            rclDst.right - rclDst.left,
            rclDst.bottom - rclDst.top,
            rclSrc.left,
            rclSrc.top,
            rclSrc.right - rclSrc.left,
            rclSrc.bottom - rclSrc.top,
            rop);

dsb_internal_exit:
        if (hbmSrc)
            DeleteObject(hbmSrc);
    }
    else
    {
        // Win98 might have added a MAX_PATH in the EMR_STRETCHDIBits
        // We need to remove it because WMF don't support it
        cbBitmapInfo = lpBitmapInfo->bmiHeader.biSize + GetSizeOfColorTable(&(lpBitmapInfo->bmiHeader));
        DoMakeBitmapBottomUp(lpBitmapInfo, cbBitmapInfo, lpBits, cbBits);
        // Handle the standard formats.

        // Emit a Win16 metafile record.
        b = bEmitWin16StretchBlt(pLocalDC,
            (SHORT) rclDst.left,
            (SHORT) rclDst.top,
            (SHORT) (rclDst.right - rclDst.left),
            (SHORT) (rclDst.bottom - rclDst.top),
            (SHORT) rclSrc.left,
            (SHORT) rclSrc.top,
            (SHORT) (rclSrc.right - rclSrc.left),
            (SHORT) (rclSrc.bottom - rclSrc.top),
            rop,
            lpBitmapInfo,
            cbBitmapInfo,
            lpBits,
            cbBits);
    }

    return(b);
}

BOOL APIENTRY DoRotatedStretchBlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 PXFORM       pxformSrc,
 DWORD        iUsageSrc,
 PBITMAPINFO  lpBitmapInfo,
 DWORD        cbBitmapInfo,
 LPBYTE       lpBits
 )
{
    BOOL    b;
    POINTL  aptlDst[4];
    RECTL   rclBndDst;
    HDC     hdcShadow, hdcSrc;
    HBITMAP hbmShadow, hbmShadowOld, hbmSrc, hbmSrcOld;
    PBITMAPINFO pbmiShadow;

    b = FALSE;
    if (pLocalDC->iXORPass != NOTXORPASS)
    {
        if (rop == SRCCOPY)
        {
            rop = SRCINVERT;
        }
        else if (rop == PATCOPY)
        {
            rop = PATINVERT;
        }
        else
        {
            pLocalDC->flags |= ERR_XORCLIPPATH;
            return FALSE;
        }
    }

    hdcShadow = hdcSrc = (HDC) 0;
    hbmShadow = hbmShadowOld = hbmSrc = hbmSrcOld = (HBITMAP) 0;
    pbmiShadow = (PBITMAPINFO) NULL;

    // First, compute the bounds of the destination rectangle.

    aptlDst[0].x = xDst;
    aptlDst[0].y = yDst;
    aptlDst[1].x = xDst + cxDst;
    aptlDst[1].y = yDst;
    aptlDst[2].x = xDst + cxDst;
    aptlDst[2].y = yDst + cyDst;
    aptlDst[3].x = xDst;
    aptlDst[3].y = yDst + cyDst;

    if (!bXformRWorldToPPage(pLocalDC, aptlDst, 4))
        goto drsb_exit;

    rclBndDst.left   = min(aptlDst[0].x,min(aptlDst[1].x,min(aptlDst[2].x,aptlDst[3].x)));
    rclBndDst.top    = min(aptlDst[0].y,min(aptlDst[1].y,min(aptlDst[2].y,aptlDst[3].y)));
    rclBndDst.right  = max(aptlDst[0].x,max(aptlDst[1].x,max(aptlDst[2].x,aptlDst[3].x)));
    rclBndDst.bottom = max(aptlDst[0].y,max(aptlDst[1].y,max(aptlDst[2].y,aptlDst[3].y)));

    // Prepare the source if any.

    if (ISSOURCEINROP3(rop))
    {
        // Create a compatible shadow DC with the destination transform.

        if (!(hdcShadow = hdcMakeCompatibleDC(&pLocalDC->xformRWorldToPPage)))
            goto drsb_exit;

        // Create a shadow bitmap the size of the destination rectangle bounds.
        // Use the helper DC in CreateDIBitmap so that the colors get bind correctly.

        pbmiShadow = (PBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfo);
        if (pbmiShadow == (PBITMAPINFO) NULL)
            goto drsb_exit;
        RtlCopyMemory(pbmiShadow, lpBitmapInfo, cbBitmapInfo);
        pbmiShadow->bmiHeader.biWidth  = rclBndDst.right - rclBndDst.left;
        pbmiShadow->bmiHeader.biHeight = rclBndDst.bottom - rclBndDst.top;
        pbmiShadow->bmiHeader.biSizeImage = 0;
        if (!(hbmShadow = CreateDIBitmap(pLocalDC->hdcHelper,
            (LPBITMAPINFOHEADER) pbmiShadow, CBM_CREATEDIB,
            (LPBYTE) NULL, pbmiShadow, iUsageSrc)))
            goto drsb_exit;

        // Select the bitmap.

        if (!(hbmShadowOld = (HBITMAP) SelectObject(hdcShadow, hbmShadow)))
            goto drsb_exit;

        // Create a compatible source DC with the given source transform.

        if (!(hdcSrc = hdcMakeCompatibleDC(pxformSrc)))
            goto drsb_exit;

        // Create the source bitmap.
        // Use the helper DC in CreateDIBitmap so that the colors get bind correctly.

        if (!(hbmSrc = CreateDIBitmap(pLocalDC->hdcHelper,
            (LPBITMAPINFOHEADER) lpBitmapInfo,
            CBM_INIT | CBM_CREATEDIB,
            lpBits,
            (LPBITMAPINFO) lpBitmapInfo,
            (UINT) iUsageSrc)))
            goto drsb_exit;

        // Select the bitmap.

        if (!(hbmSrcOld = (HBITMAP) SelectObject(hdcSrc, hbmSrc)))
            goto drsb_exit;

        // Set up the viewport origin of the shadow DC so that the destination
        // rectangle will map into coordinates within the shadow bitmap.

        OffsetViewportOrgEx(hdcShadow, (int) -rclBndDst.left,
            (int) -rclBndDst.top, (LPPOINT) NULL);

        // Stretch the source to the shadow.

        if (!StretchBlt
            (
            hdcShadow,
            (int) xDst,
            (int) yDst,
            (int) cxDst,
            (int) cyDst,
            hdcSrc,
            (int) xSrc,
            (int) ySrc,
            (int) cxSrc,
            (int) cySrc,
            SRCCOPY
            )
            )
            goto drsb_exit;

        // Deselect the shadow bitmap.

        if (!SelectObject(hdcShadow, hbmShadowOld))
            goto drsb_exit;

    }

    // Save the DC so that we can restore the clipping when we are done

    if (!DoSaveDC(pLocalDC))
        goto drsb_exit;

    // Set up the clipping rectangle on the destination.

    if (!DoClipRect(pLocalDC, xDst, yDst,
        xDst + cxDst, yDst + cyDst, EMR_INTERSECTCLIPRECT))
    {
        (void) DoRestoreDC(pLocalDC, -1);
        goto drsb_exit;
    }

    // Blt the shadow to the destination.

    // Emit a Win16 metafile record.

    if (ISSOURCEINROP3(rop))
        b = bEmitBitmap(pLocalDC,
        hbmShadow,
        rclBndDst.left,
        rclBndDst.top,
        rclBndDst.right - rclBndDst.left,
        rclBndDst.bottom - rclBndDst.top,
        0,
        0,
        rclBndDst.right - rclBndDst.left,
        rclBndDst.bottom - rclBndDst.top,
        rop);
    else
        b = bEmitWin16BitBltNoSrc(pLocalDC,
        (SHORT) rclBndDst.left,
        (SHORT) rclBndDst.top,
        (SHORT) (rclBndDst.right - rclBndDst.left),
        (SHORT) (rclBndDst.bottom - rclBndDst.top),
        rop);

    // Restore the clipping region.

    (void) DoRestoreDC(pLocalDC, -1);

    // Cleanup

drsb_exit:

    if (hbmShadowOld)
        SelectObject(hdcShadow, hbmShadowOld);
    if (hbmShadow)
        DeleteObject(hbmShadow);
    if (hdcShadow)
        DeleteDC(hdcShadow);

    if (hbmSrcOld)
        SelectObject(hdcSrc, hbmSrcOld);
    if (hbmSrc)
        DeleteObject(hbmSrc);
    if (hdcSrc)
        DeleteDC(hdcSrc);

    if (pbmiShadow)
        LocalFree((HANDLE) pbmiShadow);
    return(b);
}

/*****************************************************************************
* hdcMakeCompatibleDC
*   Create a compatible DC with the given transform.
****************************************************************************/
HDC hdcMakeCompatibleDC(LPXFORM lpxform)
{
    HDC     hdc;

    hdc = CreateCompatibleDC((HDC) 0);
    if(hdc == 0)
    {
        RIPS("MF3216: hdcMakeCompatibleDC, CreateCompatibleDC failed\n");
        return (HDC)0;
    }

    // Must be in the advanced graphics mode to modify the world transform.

    SetGraphicsMode(hdc, GM_ADVANCED);

    // Set the transform.

    if (!SetWorldTransform(hdc, lpxform))
    {
        DeleteDC(hdc);
        RIPS("MF3216: hdcMakeCompatibleDC, SetWorldTransform failed\n");
        return((HDC) 0);
    }

    return(hdc);
}

/***************************************************************************
* bEmitBitmap
**************************************************************************/
BOOL bEmitBitmap
(
 PLOCALDC pLocalDC,
 HBITMAP  hbm,
 LONG     xDst,
 LONG     yDst,
 LONG     cxDst,
 LONG     cyDst,
 LONG     xSrc,
 LONG     ySrc,
 LONG     cxSrc,
 LONG     cySrc,
 DWORD    rop
 )
{
    BITMAPINFOHEADER bmih;
    DWORD            cbBitmapInfo;
    LPBITMAPINFO     lpBitmapInfo;
    DWORD            cbBits;
    LPBYTE           lpBits;
    BOOL         b;

    b = FALSE;
    lpBitmapInfo = (LPBITMAPINFO) NULL;
    lpBits       = (LPBYTE) NULL;

    bmih.biSize = sizeof(BITMAPINFOHEADER);
    bmih.biBitCount = 0;    // don't fill in color table
    bmih.biCompression = BI_RGB;
    if (!GetDIBits(pLocalDC->hdcHelper, hbm, 0, 0,
        (LPBYTE) NULL, (LPBITMAPINFO) &bmih, DIB_RGB_COLORS))
        goto eb_exit;

    // Compute size of the bitmap info with color table.

    cbBitmapInfo= sizeof(BITMAPINFOHEADER);
    if (bmih.biPlanes != 1 || bmih.biBitCount == 16 || bmih.biBitCount == 32)
    {
        bmih.biPlanes       = 1;
        bmih.biBitCount     = 24;
        bmih.biCompression  = BI_RGB;
        bmih.biSizeImage    = 0;
        bmih.biClrUsed      = 0;
        bmih.biClrImportant = 0;
    }
    else if (bmih.biClrUsed)
        cbBitmapInfo += bmih.biClrUsed * sizeof(RGBQUAD);
    else if (bmih.biBitCount < 16)
        cbBitmapInfo += (1 << bmih.biBitCount) * sizeof(RGBQUAD);

    // Compute size of the buffer required for bitmap bits.

    if (bmih.biSizeImage)
        cbBits = bmih.biSizeImage;
    else
        cbBits = CJSCAN(bmih.biWidth,bmih.biPlanes, bmih.biBitCount) *
        ABS(bmih.biHeight);

    lpBitmapInfo = (LPBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfo);
    if (lpBitmapInfo == (LPBITMAPINFO) NULL)
        goto eb_exit;

    lpBits = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBits);
    if (lpBits == (LPBYTE) NULL)
        goto eb_exit;

    // Get bitmap info and bits.

    *(PBITMAPINFOHEADER) lpBitmapInfo = bmih;

    if (!GetDIBits(pLocalDC->hdcHelper,
        hbm,
        0,
        (UINT) ABS(bmih.biHeight),
        lpBits,
        lpBitmapInfo,
        DIB_RGB_COLORS))
        goto eb_exit;

    // Emit the metafile record.

    b = bEmitWin16StretchBlt(pLocalDC,
        (SHORT) xDst,
        (SHORT) yDst,
        (SHORT) cxDst,
        (SHORT) cyDst,
        (SHORT) xSrc,
        (SHORT) ySrc,
        (SHORT) cxSrc,
        (SHORT) cySrc,
        rop,
        lpBitmapInfo,
        cbBitmapInfo,
        lpBits,
        cbBits);
eb_exit:
    if (lpBitmapInfo)
        LocalFree((HANDLE) lpBitmapInfo);
    if (lpBits)
        LocalFree((HANDLE) lpBits);

    return(b);
 }


 /***************************************************************************
 *  MaskBlt  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
 BOOL APIENTRY DoMaskBlt
     (
     PLOCALDC     pLocalDC,
     LONG         xDst,
     LONG         yDst,
     LONG         cxDst,
     LONG         cyDst,
     DWORD        rop4,
     LONG         xSrc,
     LONG         ySrc,
     PXFORM       pxformSrc,
     DWORD        iUsageSrc,
     PBITMAPINFO  lpBitmapInfoSrc,
     DWORD        cbBitmapInfoSrc,
     LPBYTE       lpBitsSrc,
     DWORD        cbBitsSrc,
     LONG         xMask,
     LONG         yMask,
     DWORD        iUsageMask,
     PBITMAPINFO  lpBitmapInfoMask,
     DWORD        cbBitmapInfoMask,
     LPBYTE       lpBitsMask,
     DWORD        cbBitsMask
     )
 {
     BOOL    b;
     DWORD   rop1;
     DWORD   rop0;
     HDC     hdcMask, hdcSrc;
     HBITMAP hbmMask, hbmMaskOld, hbmSrc, hbmSrcOld;
     RECTL   rclMask;

     b    = FALSE;
     hdcMask = hdcSrc = (HDC) 0;
     hbmMask = hbmMaskOld = hbmSrc = hbmSrcOld = (HBITMAP) 0;

     rop0 = rop4 >> 8;           // rop for 0's
     rop1 = rop4 & 0xFF0000;     // rop for 1's

     // If no mask is given, the mask is assumed to contain all 1's.
     // This is equivalent to a BitBlt using the low rop.

     if (!cbBitmapInfoMask)
         return
         (
         DoStretchBlt
         (
         pLocalDC,
         xDst,
         yDst,
         cxDst,
         cyDst,
         rop1,
         xSrc,
         ySrc,
         cxDst,
         cyDst,
         pxformSrc,
         iUsageSrc,
         lpBitmapInfoSrc,
         cbBitmapInfoSrc,
         lpBitsSrc,
         cbBitsSrc
         )
         );

     // Handle MaskBlt with no source bitmap.

     if (!ISSOURCEINROP3(rop4))
         return
         (
         DoMaskBltNoSrc
         (
         pLocalDC,
         xDst,
         yDst,
         cxDst,
         cyDst,
         rop4,
         pxformSrc,
         xMask,
         yMask,
         iUsageMask,
         lpBitmapInfoMask,
         cbBitmapInfoMask,
         lpBitsMask,
         cbBitsMask
         )
         );

     // Create a compatible mask DC.

     if (!(hdcMask = CreateCompatibleDC((HDC) 0)))
         goto dmb_exit;

     // Must be in the advanced graphics mode to modify the world transform.

     SetGraphicsMode(hdcMask, GM_ADVANCED);

     // Create the mask bitmap.
     // Make it as big as the source and initialize it.

     // Create the mask bitmap as big as the source bitmap.

     if (!(hbmMask = CreateBitmap((int) lpBitmapInfoSrc->bmiHeader.biWidth,
         (int) lpBitmapInfoSrc->bmiHeader.biHeight,
         1, 1, (CONST VOID *) NULL)))
         goto dmb_exit;

     // Select the bitmap.

     if (!(hbmMaskOld = (HBITMAP) SelectObject(hdcMask, hbmMask)))
         goto dmb_exit;

     // Initialize the mask bitmap to 0's.

     if (!PatBlt(hdcMask,0,0,(int) lpBitmapInfoSrc->bmiHeader.biWidth,
         (int) lpBitmapInfoSrc->bmiHeader.biHeight,BLACKNESS))
         goto dmb_exit;

     // Compute the mask rectangle.
     // The mask bitmap is aligned against the source device rectangle.

     rclMask.left   = xSrc;
     rclMask.top    = ySrc;
     rclMask.right  = xSrc + cxDst;
     rclMask.bottom = ySrc + cyDst;
     if (!bXformWorkhorse((PPOINTL) &rclMask, 2, pxformSrc))
         goto dmb_exit;

     if (rclMask.left > rclMask.right)
         rclMask.left = rclMask.right /* + 1 */;// align the mask against the left edge

     if (rclMask.top > rclMask.bottom)
         rclMask.top = rclMask.bottom /* + 1 */;// align the mask against the top edge

     // Set the mask bits.

     if (!StretchDIBits(hdcMask,
         (int) rclMask.left - xMask,
         (int) rclMask.top  - yMask,
         (int) lpBitmapInfoMask->bmiHeader.biWidth,
         (int) lpBitmapInfoMask->bmiHeader.biHeight,
         (int) 0,
         (int) 0,
         (int) lpBitmapInfoMask->bmiHeader.biWidth,
         (int) lpBitmapInfoMask->bmiHeader.biHeight,
         (CONST VOID *) lpBitsMask,
         (LPBITMAPINFO) lpBitmapInfoMask,
         (UINT) iUsageMask,
         SRCCOPY))
         goto dmb_exit;

     // Set the source transform in the mask DC.

     if (!SetWorldTransform(hdcMask, pxformSrc))
         goto dmb_exit;

     // Create a compatible source DC with the given source transform.

     if (!(hdcSrc = hdcMakeCompatibleDC(pxformSrc)))
         goto dmb_exit;

     // Create the source bitmap.
     // We cannot use CBM_CREATEDIB option here because index 0 does not
     // neccesarily contain black and index 15 or 255 does not have to be white.
     // We need a compatible bitmap that contain the standard color table so
     // that we can perform the following rop operations to emulate the maskblt.
     // Gdi uses rgb colors to perform rop operations in dibs, not color indices!
     // The helper DC is needed to create the compatible format bitmap.

     if (!(hbmSrc = CreateDIBitmap(pLocalDC->hdcHelper,
         (LPBITMAPINFOHEADER) lpBitmapInfoSrc,
         CBM_INIT,
         lpBitsSrc,
         (LPBITMAPINFO) lpBitmapInfoSrc,
         (UINT) iUsageSrc)))
         goto dmb_exit;

     // Select the bitmap.

     if (!(hbmSrcOld = (HBITMAP) SelectObject(hdcSrc, hbmSrc)))
         goto dmb_exit;

     // We need to handle the low rop (mask bit 1) and high rop (mask bit 0)
     // separately.  For each rop, we need to go through two passes.
     //
     // For the low rop (mask bit 1), we use the following rop table:
     //
     //  P S D | R1  R2
     //  ------+--------
     //  0 0 0 | 0   x
     //  0 0 1 | 1   x
     //  0 1 0 | x   0
     //  0 1 1 | x   1
     //  1 0 0 | 0   x
     //  1 0 1 | 1   x
     //  1 1 0 | x   0
     //  1 1 1 | x   1
     //
     // In the first pass, we AND the mask to the source bitmap to remove
     // the mask 0 bits.  This is then used to get the result (R1) for the
     // bitblt involving source 1's.
     //
     // In the second pass, we OR the NOT of the mask to the source bitmap
     // to obtain the source 0 bits.  This is then used to get the result (R2)
     // for the bitblt involving source 0's.

     // AND the mask to the source bitmap to remove the mask 0 bits.

     if (!BitBlt(hdcSrc,
         (int) xSrc, (int) ySrc,
         (int) cxDst, (int) cyDst,
         hdcMask,
         (int) xSrc, (int) ySrc,
         SRCAND))
         goto dmb_exit;

     // Get the result (R1) for the bits involving source 1's.

     if (!DoStretchBltAlt
         (
         pLocalDC,
         xDst,
         yDst,
         cxDst,
         cyDst,
         (rop1 & 0xCC0000) | 0x220000,
         xSrc,
         ySrc,
         cxDst,
         cyDst,
         hdcSrc,
         hbmSrc,
         pxformSrc
         )
         )
         goto dmb_exit;

     // OR the NOT of the mask to the source bitmap to obtain the source 0 bits.

     if (!BitBlt(hdcSrc,
         (int) xSrc, (int) ySrc,
         (int) cxDst, (int) cyDst,
         hdcMask,
         (int) xSrc, (int) ySrc,
         MERGEPAINT))
         goto dmb_exit;

     // Get the result (R2) for the bitblt involving source 0's.

     if (!DoStretchBltAlt
         (
         pLocalDC,
         xDst,
         yDst,
         cxDst,
         cyDst,
         (rop1 & 0x330000) | 0x880000,
         xSrc,
         ySrc,
         cxDst,
         cyDst,
         hdcSrc,
         hbmSrc,
         pxformSrc
         )
         )
         goto dmb_exit;

     // For the high rop (mask bit 0), we use the following rop table:
     //
     //  P S D | R1  R2
     //  ------+--------
     //  0 0 0 | 0   x
     //  0 0 1 | 1   x
     //  0 1 0 | x   0
     //  0 1 1 | x   1
     //  1 0 0 | 0   x
     //  1 0 1 | 1   x
     //  1 1 0 | x   0
     //  1 1 1 | x   1
     //
     // In the first pass, we AND the NOT of the mask to the source bitmap to remove
     // the mask 1 bits.  This is then used to get the result (R1) for the
     // bitblt involving source 1's.
     //
     // In the second pass, we OR the mask to the source bitmap
     // to obtain the source 0 bits.  This is then used to get the result (R2)
     // for the bitblt involving source 0's.

     // Restore the source bits.

     if (!SelectObject(hdcSrc, hbmSrcOld))
         goto dmb_exit;

     if (!SetDIBits(pLocalDC->hdcHelper,
         hbmSrc,
         0,
         (UINT) lpBitmapInfoSrc->bmiHeader.biHeight,
         (CONST VOID *) lpBitsSrc,
         (LPBITMAPINFO) lpBitmapInfoSrc,
         (UINT) iUsageSrc))
         goto dmb_exit;

     if (!SelectObject(hdcSrc, hbmSrc))
         goto dmb_exit;

     // AND the NOT of the mask to the source bitmap to remove the mask 1 bits.

     if (!BitBlt(hdcSrc,
         (int) xSrc, (int) ySrc,
         (int) cxDst, (int) cyDst,
         hdcMask,
         (int) xSrc, (int) ySrc,
         0x220326))       // DSna
         goto dmb_exit;

     // Get the result (R1) for the bits involving source 1's.

     if (!DoStretchBltAlt
         (
         pLocalDC,
         xDst,
         yDst,
         cxDst,
         cyDst,
         (rop0 & 0xCC0000) | 0x220000,
         xSrc,
         ySrc,
         cxDst,
         cyDst,
         hdcSrc,
         hbmSrc,
         pxformSrc
         )
         )
         goto dmb_exit;

     // OR the mask to the source bitmap to obtain the source 0 bits.

     if (!BitBlt(hdcSrc,
         (int) xSrc, (int) ySrc,
         (int) cxDst, (int) cyDst,
         hdcMask,
         (int) xSrc, (int) ySrc,
         SRCPAINT))
         goto dmb_exit;

     // Get the result (R2) for the bitblt involving source 0's.

     if (!DoStretchBltAlt
         (
         pLocalDC,
         xDst,
         yDst,
         cxDst,
         cyDst,
         (rop0 & 0x330000) | 0x880000,
         xSrc,
         ySrc,
         cxDst,
         cyDst,
         hdcSrc,
         hbmSrc,
         pxformSrc
         )
         )
         goto dmb_exit;

     b = TRUE;

     // Cleanup.

dmb_exit:

     if (hbmMaskOld)
         SelectObject(hdcMask, hbmMaskOld);
     if (hbmMask)
         DeleteObject(hbmMask);
     if (hdcMask)
         DeleteDC(hdcMask);

     if (hbmSrcOld)
         SelectObject(hdcSrc, hbmSrcOld);
     if (hbmSrc)
         DeleteObject(hbmSrc);
     if (hdcSrc)
         DeleteDC(hdcSrc);

     return(b);
}

/***************************************************************************
*  MaskBltNoSrc
**************************************************************************/
BOOL APIENTRY DoMaskBltNoSrc
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop4,
 PXFORM       pxformSrc,
 LONG         xMask,
 LONG         yMask,
 DWORD        iUsageMask,
 PBITMAPINFO  lpBitmapInfoMask,
 DWORD        cbBitmapInfoMask,
 LPBYTE       lpBitsMask,
 DWORD        cbBitsMask
 )
{
    BOOL    b;
    DWORD   rop1;
    DWORD   rop0;
    HDC     hdcMask;
    HBITMAP hbmMask, hbmMaskOld;
    RECTL   rclMask;
    LONG    cxMask, cyMask;

    b    = FALSE;
    hdcMask = (HDC) 0;
    hbmMask = hbmMaskOld = (HBITMAP) 0;

    rop0 = rop4 >> 8;           // rop for 0's
    rop1 = rop4 & 0xFF0000;     // rop for 1's

    // When no source bitmap is required in the rop4, the mask is used
    // as the source in that the low rop is applied to the corresponding
    // mask 1 bits and the high rop is applied to mask 0 bits.  The source
    // transform is used to determine the mask rectangle to be used.

    // Create a compatible mask DC.

    if (!(hdcMask = CreateCompatibleDC((HDC) 0)))
        goto dmbns_exit;

    // Create the mask bitmap.

    if (!(hbmMask = CreateMonoDib(lpBitmapInfoMask, lpBitsMask, (UINT) iUsageMask)))
        goto dmbns_exit;

    // Select the bitmap.

    if (!(hbmMaskOld = (HBITMAP) SelectObject(hdcMask, hbmMask)))
        goto dmbns_exit;

    // Compute the mask extents.

    rclMask.left   = 0;
    rclMask.top    = 0;
    rclMask.right  = cxDst;
    rclMask.bottom = cyDst;
    if (!bXformWorkhorse((PPOINTL) &rclMask, 2, pxformSrc))
        goto dmbns_exit;

    cxMask = rclMask.right - rclMask.left;
    cyMask = rclMask.bottom - rclMask.top;

    // Align the mask rectangle.

    if (cxMask < 0)
        xMask = xMask - cxMask + 1;
    if (cyMask < 0)
        yMask = yMask - cyMask + 1;

    // We need to handle the low rop (mask bit 1) and high rop (mask bit 0)
    // separately.
    //
    // For the low rop (mask bit 1), we use the following rop table:
    //
    //  P M D | R
    //  ------+---
    //  0 0 0 | 0
    //  0 0 1 | 1
    //  0 1 0 | x
    //  0 1 1 | x
    //  1 0 0 | 0
    //  1 0 1 | 1
    //  1 1 0 | x
    //  1 1 1 | x
    //
    // The above rop will give us the result for bits that correspond to 1's
    // in the mask bitmap.  The destination bits that correspond to the 0 mask
    // bits will not be changed.  We effectively treat the mask as the source
    // in the operation.

    // Get the result (R) for the bits involving mask 1's.

    if (!DoStretchBltAlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop1 & 0xCC0000) | 0x220000,
        xMask,
        yMask,
        cxMask,
        cyMask,
        hdcMask,
        hbmMask,
        &xformIdentity
        )
        )
        goto dmbns_exit;
#if 0
    DoStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop1 & 0xCC0000) | 0x220000,
        xMask,
        yMask,
        cxMask,
        cyMask,
        &xformIdentity,
        iUsageMask,
        lpBitmapInfoMask,
        cbBitmapInfoMask,
        lpBitsMask,
        cbBitsMask
        )
#endif // 0

        // For the high rop (mask bit 0), we use the following rop table:
        //
        //  P M D | R
        //  ------+---
        //  0 0 0 | x
        //  0 0 1 | x
        //  0 1 0 | 0
        //  0 1 1 | 1
        //  1 0 0 | x
        //  1 0 1 | x
        //  1 1 0 | 0
        //  1 1 1 | 1
        //
        // The above rop will give us the result for bits that correspond to 0's
        // in the mask bitmap.  The destination bits that correspond to the 1 mask
        // bits will not be changed.  We effectively treat the mask as the source
        // in the operation.

        // Get the result (R) for the bits involving mask 0's.

        if (!DoStretchBltAlt
            (
            pLocalDC,
            xDst,
            yDst,
            cxDst,
            cyDst,
            (rop0 & 0x330000) | 0x880000,
            xMask,
            yMask,
            cxMask,
            cyMask,
            hdcMask,
            hbmMask,
            &xformIdentity
            )
            )
            goto dmbns_exit;
#if 0
        DoStretchBlt
            (
            pLocalDC,
            xDst,
            yDst,
            cxDst,
            cyDst,
            (rop0 & 0x330000) | 0x880000,
            xMask,
            yMask,
            cxMask,
            cyMask,
            &xformIdentity,
            iUsageMask,
            lpBitmapInfoMask,
            cbBitmapInfoMask,
            lpBitsMask,
            cbBitsMask
            )
#endif // 0

            b = TRUE;

        // Cleanup.

dmbns_exit:

        if (hbmMaskOld)
            SelectObject(hdcMask, hbmMaskOld);
        if (hbmMask)
            DeleteObject(hbmMask);
        if (hdcMask)
            DeleteDC(hdcMask);

        return(b);
}


/***************************************************************************
*  PlgBlt  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL APIENTRY DoPlgBlt
(
 PLOCALDC    pLocalDC,
 PPOINTL     pptlDst,
 LONG        xSrc,
 LONG        ySrc,
 LONG        cxSrc,
 LONG        cySrc,
 PXFORM      pxformSrc,
 DWORD       iUsageSrc,
 PBITMAPINFO lpBitmapInfoSrc,
 DWORD       cbBitmapInfoSrc,
 LPBYTE      lpBitsSrc,
 DWORD       cbBitsSrc,
 LONG        xMask,
 LONG        yMask,
 DWORD       iUsageMask,
 PBITMAPINFO lpBitmapInfoMask,
 DWORD       cbBitmapInfoMask,
 LPBYTE      lpBitsMask,
 DWORD       cbBitsMask
 )
{
    BOOL    b, bMask;
    DWORD   rop4;
    HDC     hdcSrc, hdcSrcRDev;
    PBITMAPINFO pbmiSrcRDev, pbmiMaskRDev;
    LPBYTE  lpBitsSrcRDev, lpBitsMaskRDev;
    DWORD   cbBitsSrcRDev, cbBitsMaskRDev;
    HBITMAP hbmMask, hbmMaskRDev, hbmSrc, hbmSrcRDev, hbmSrcOld, hbmSrcRDevOld;
    RECTL   rclBndRDev;
    POINTL  aptlDst[4];
    POINT   ptMask;
    BITMAPINFOHEADER bmihMask;

    // We are going to convert the PlgBlt into a MaskBlt.  This can be done
    // by converting the source and mask bitmaps to the device space of the
    // recording device and then maskblt the result.

    b      = FALSE;
    hdcSrc = hdcSrcRDev = (HDC) 0;
    hbmMask = hbmMaskRDev = hbmSrc = hbmSrcRDev = hbmSrcOld = hbmSrcRDevOld = (HBITMAP) 0;
    pbmiSrcRDev = pbmiMaskRDev = (PBITMAPINFO) NULL;
    lpBitsSrcRDev = lpBitsMaskRDev = (LPBYTE) NULL;
    bMask = (cbBitmapInfoMask != 0);

    rop4 = 0xAACC0000;          // rop for MaskBlt

    // First, we transform the destination parallelogram to the device space
    // of the recording device.  This device parallelogram is then used in
    // plgblt'ing the source and mask bitmaps to the device space of the
    // recording device.

    aptlDst[0] = pptlDst[0];
    aptlDst[1] = pptlDst[1];
    aptlDst[2] = pptlDst[2];
    aptlDst[3].x = aptlDst[1].x + aptlDst[2].x - aptlDst[0].x;
    aptlDst[3].y = aptlDst[1].y + aptlDst[2].y - aptlDst[0].y;

    if (!bXformRWorldToRDev(pLocalDC, aptlDst, 4))
        goto dpb_exit;

    // Find the bounding rectangle of the parallelogram in the recording
    // device space.  This rectangle is used as the basis of the MaskBlt call.

    rclBndRDev.left   = min(aptlDst[0].x,min(aptlDst[1].x,min(aptlDst[2].x,aptlDst[3].x)));
    rclBndRDev.top    = min(aptlDst[0].y,min(aptlDst[1].y,min(aptlDst[2].y,aptlDst[3].y)));
    rclBndRDev.right  = max(aptlDst[0].x,max(aptlDst[1].x,max(aptlDst[2].x,aptlDst[3].x)));
    rclBndRDev.bottom = max(aptlDst[0].y,max(aptlDst[1].y,max(aptlDst[2].y,aptlDst[3].y)));

    // Offset the device parallelogram to the origin.

    aptlDst[0].x -= rclBndRDev.left; aptlDst[0].y -= rclBndRDev.top;
    aptlDst[1].x -= rclBndRDev.left; aptlDst[1].y -= rclBndRDev.top;
    aptlDst[2].x -= rclBndRDev.left; aptlDst[2].y -= rclBndRDev.top;
    aptlDst[3].x -= rclBndRDev.left; aptlDst[3].y -= rclBndRDev.top;

    // Create the source bitmap in the recording device space for MaskBlt.
    // The size of the source bitmap is that of rclBndRDev.
    // The source image is then plgblt'd into the device parallelogram.
    // PlgBlt always takes a source bitmap.

    // Create the original source.

    if (!(hdcSrc = hdcMakeCompatibleDC(pxformSrc)))
        goto dpb_exit;

    if (!(hbmSrc = CreateDIBitmap(hdcSrc,
        (LPBITMAPINFOHEADER) lpBitmapInfoSrc,
        CBM_INIT | CBM_CREATEDIB,
        lpBitsSrc,
        (LPBITMAPINFO) lpBitmapInfoSrc,
        (UINT) iUsageSrc)))
        goto dpb_exit;

    if (!(hbmSrcOld = (HBITMAP) SelectObject(hdcSrc, hbmSrc)))
        goto dpb_exit;

    // Create the source for MaskBlt.

    if (!(hdcSrcRDev = CreateCompatibleDC((HDC) 0)))
        goto dpb_exit;

    pbmiSrcRDev = (PBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfoSrc);
    if (pbmiSrcRDev == (PBITMAPINFO) NULL)
        goto dpb_exit;
    RtlCopyMemory(pbmiSrcRDev, lpBitmapInfoSrc, cbBitmapInfoSrc);
    pbmiSrcRDev->bmiHeader.biWidth  = rclBndRDev.right - rclBndRDev.left + 1;
    pbmiSrcRDev->bmiHeader.biHeight = rclBndRDev.bottom - rclBndRDev.top + 1;
    pbmiSrcRDev->bmiHeader.biSizeImage = 0;
    if (!(hbmSrcRDev = CreateDIBitmap(hdcSrcRDev, (LPBITMAPINFOHEADER) pbmiSrcRDev,
        CBM_CREATEDIB, (LPBYTE) NULL, pbmiSrcRDev, iUsageSrc)))
        goto dpb_exit;

    if (!(hbmSrcRDevOld = (HBITMAP) SelectObject(hdcSrcRDev, hbmSrcRDev)))
        goto dpb_exit;

    // PlgBlt the original source bitmap into the source bitmap for MaskBlt.

    if (!PlgBlt(hdcSrcRDev, (LPPOINT) aptlDst, hdcSrc, xSrc, ySrc, cxSrc, cySrc, (HBITMAP) NULL, 0, 0))
        goto dpb_exit;

    // Retrieve the source bits for MaskBlt.

    // Get biSizeImage!

    if (!GetDIBits(hdcSrcRDev, hbmSrcRDev, 0, 0, (LPBYTE) NULL, pbmiSrcRDev, iUsageSrc))
        goto dpb_exit;

    // Compute size of the buffer required for source bits.

    if (pbmiSrcRDev->bmiHeader.biSizeImage)
        cbBitsSrcRDev = pbmiSrcRDev->bmiHeader.biSizeImage;
    else
        cbBitsSrcRDev = CJSCAN(pbmiSrcRDev->bmiHeader.biWidth,
        pbmiSrcRDev->bmiHeader.biPlanes,
        pbmiSrcRDev->bmiHeader.biBitCount)
        * ABS(pbmiSrcRDev->bmiHeader.biHeight);

    lpBitsSrcRDev = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBitsSrcRDev);
    if (lpBitsSrcRDev == (LPBYTE) NULL)
        goto dpb_exit;

    // Get the source bits.

    if (!GetDIBits(hdcSrcRDev, hbmSrcRDev, 0, (UINT) pbmiSrcRDev->bmiHeader.biHeight,
        lpBitsSrcRDev, pbmiSrcRDev, iUsageSrc))
        goto dpb_exit;

    // Create the mask bitmap in the recording device space for MaskBlt.
    // The size of the mask bitmap is that of rclBndRDev.
    // The mask image is then plgblt'd into the device parallelogram.
    // If a mask is not given, create one that describes the parallelogram
    // for the source.

    if (bMask)
    {
        // Create the original mask.

        if (!(hbmMask = CreateMonoDib(lpBitmapInfoMask, lpBitsMask, (UINT) iUsageMask)))
            goto dpb_exit;

        if (!SelectObject(hdcSrc, hbmMask))
            goto dpb_exit;
    }
    else
    {
        // Create a mask describing the original source bitmap.

        ASSERTGDI(sizeof(BITMAPINFOHEADER) == 0x28,
            "MF3216: DoPlgBlt, BITMAPINFOHEADER has changed!\n");

        iUsageMask       = DIB_PAL_INDICES;
        cbBitmapInfoMask = 0x28;
        lpBitmapInfoMask = (PBITMAPINFO) &bmihMask;

        bmihMask.biSize          = 0x28;
        bmihMask.biWidth         = lpBitmapInfoSrc->bmiHeader.biWidth;
        bmihMask.biHeight        = lpBitmapInfoSrc->bmiHeader.biHeight;
        bmihMask.biPlanes        = 1;
        bmihMask.biBitCount      = 1;
        bmihMask.biCompression   = BI_RGB;
        bmihMask.biSizeImage     = 0;
        bmihMask.biXPelsPerMeter = 0;
        bmihMask.biYPelsPerMeter = 0;
        bmihMask.biClrUsed       = 0;
        bmihMask.biClrImportant  = 0;

        if (!(hbmMask = CreateBitmap((int) bmihMask.biWidth,
            (int) bmihMask.biHeight, 1, 1, (CONST VOID *) NULL)))
            goto dpb_exit;

        if (!SelectObject(hdcSrc, hbmMask))
            goto dpb_exit;

        // Initialize the mask bitmap to 1's.

        if (!PatBlt(hdcSrc,0,0,(int)bmihMask.biWidth,(int)bmihMask.biHeight,WHITENESS))
            goto dpb_exit;
    }

    // Create the mask for MaskBlt.

    pbmiMaskRDev = (PBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfoMask);
    if (pbmiMaskRDev == (PBITMAPINFO) NULL)
        goto dpb_exit;
    RtlCopyMemory(pbmiMaskRDev, lpBitmapInfoMask, cbBitmapInfoMask);
    pbmiMaskRDev->bmiHeader.biWidth  = rclBndRDev.right - rclBndRDev.left + 1;
    pbmiMaskRDev->bmiHeader.biHeight = rclBndRDev.bottom - rclBndRDev.top + 1;
    pbmiMaskRDev->bmiHeader.biSizeImage = 0;
    pbmiMaskRDev->bmiHeader.biCompression = BI_RGB;
    if (!(hbmMaskRDev = CreateBitmap(pbmiMaskRDev->bmiHeader.biWidth,
        pbmiMaskRDev->bmiHeader.biHeight, 1, 1, (CONST VOID *) NULL)))
        goto dpb_exit;

    if (!SelectObject(hdcSrcRDev, hbmMaskRDev))
        goto dpb_exit;

    // Initialize the mask bitmap to 0's.

    if (!PatBlt(hdcSrcRDev,0,0,(int)pbmiMaskRDev->bmiHeader.biWidth,
        (int)pbmiMaskRDev->bmiHeader.biHeight,BLACKNESS))
        goto dpb_exit;

    // PlgBlt the original mask bitmap into the mask bitmap for MaskBlt.

    if (bMask)
    {
        ptMask.x = xMask;
        ptMask.y = yMask;
        if (!DPtoLP(hdcSrc, &ptMask, 1))
            goto dpb_exit;
    }
    else
    {
        ptMask.x = xSrc;
        ptMask.y = ySrc;
    }

    if (!PlgBlt(hdcSrcRDev, (LPPOINT) aptlDst, hdcSrc, ptMask.x, ptMask.y, cxSrc, cySrc, (HBITMAP) NULL, 0, 0))
        goto dpb_exit;

    // Retrieve the mask bits for MaskBlt.

    // Compute size of the buffer required for mask bits.

    cbBitsMaskRDev = CJSCAN(pbmiMaskRDev->bmiHeader.biWidth,
        pbmiMaskRDev->bmiHeader.biPlanes,
        pbmiMaskRDev->bmiHeader.biBitCount)
        * ABS(pbmiMaskRDev->bmiHeader.biHeight);

    lpBitsMaskRDev = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBitsMaskRDev);
    if (lpBitsMaskRDev == (LPBYTE) NULL)
        goto dpb_exit;

    // Get the mask bits.

    if (!GetDIBits(hdcSrcRDev, hbmMaskRDev, 0, (UINT) pbmiMaskRDev->bmiHeader.biHeight,
        lpBitsMaskRDev, pbmiMaskRDev, iUsageMask))
        goto dpb_exit;

    // Prepare for the MaskBlt.
    // The destination for the MaskBlt is rclBndRDev.  Since the extents for
    // the destination and source share the same logical values in MaskBlt,
    // we have to set the transform in the destination DC to identity.

    // Save the DC so that we can restore the transform when we are done

    if (!DoSaveDC(pLocalDC))
        goto dpb_exit;

    // Set the transforms to identity.

    if (!DoSetMapMode(pLocalDC, MM_TEXT)
        || !DoModifyWorldTransform(pLocalDC, (PXFORM) NULL, MWT_IDENTITY)
        || !DoSetWindowOrg(pLocalDC, 0, 0)
        || !DoSetViewportOrg(pLocalDC, 0, 0))
        goto dpb_restore_exit;

    // Now do the MaskBlt.

    b = DoMaskBlt
        (
        pLocalDC,
        rclBndRDev.left,        // xDst
        rclBndRDev.top,     // yDst
        rclBndRDev.right - rclBndRDev.left + 1,
        rclBndRDev.bottom - rclBndRDev.top + 1,
        rop4,
        0,              // xSrc
        0,              // ySrc
        &xformIdentity,
        iUsageSrc,
        pbmiSrcRDev,
        cbBitmapInfoSrc,
        lpBitsSrcRDev,
        cbBitsSrcRDev,
        0,              // xMask
        0,              // yMask
        iUsageMask,
        pbmiMaskRDev,
        cbBitmapInfoMask,
        lpBitsMaskRDev,
        cbBitsMaskRDev
        );

    // Restore the transforms.

dpb_restore_exit:

    (void) DoRestoreDC(pLocalDC, -1);

    // Cleanup.

dpb_exit:

    if (hbmSrcOld)
        SelectObject(hdcSrc, hbmSrcOld);
    if (hbmSrcRDevOld)
        SelectObject(hdcSrcRDev, hbmSrcRDevOld);

    if (hbmSrc)
        DeleteObject(hbmSrc);
    if (hbmSrcRDev)
        DeleteObject(hbmSrcRDev);
    if (hbmMask)
        DeleteObject(hbmMask);
    if (hbmMaskRDev)
        DeleteObject(hbmMaskRDev);

    if (hdcSrc)
        DeleteDC(hdcSrc);
    if (hdcSrcRDev)
        DeleteDC(hdcSrcRDev);

    if (pbmiSrcRDev)
        LocalFree((HANDLE) pbmiSrcRDev);
    if (pbmiMaskRDev)
        LocalFree((HANDLE) pbmiMaskRDev);
    if (lpBitsSrcRDev)
        LocalFree((HANDLE) lpBitsSrcRDev);
    if (lpBitsMaskRDev)
        LocalFree((HANDLE) lpBitsMaskRDev);

    return(b);
}


/***************************************************************************
*  SetPixel  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoSetPixel
(
 PLOCALDC    pLocalDC,
 int         x,
 int         y,
 COLORREF    crColor
 )
{
    POINTL  ptl ;
    BOOL    b ;

    ptl.x = (LONG) x ;
    ptl.y = (LONG) y ;

    b = bXformRWorldToPPage(pLocalDC, &ptl, 1) ;
    if (b == FALSE)
        goto exit1 ;

    b = bEmitWin16SetPixel(pLocalDC, LOWORD(ptl.x), LOWORD(ptl.y), crColor) ;
exit1:
    return(b) ;
}


/***************************************************************************
*  SetStretchBltMode  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoSetStretchBltMode
(
 PLOCALDC  pLocalDC,
 DWORD   iStretchMode
 )
{
    BOOL    b ;

    // Emit the Win16 metafile drawing order.

    b = bEmitWin16SetStretchBltMode(pLocalDC, LOWORD(iStretchMode)) ;

    return(b) ;
}

BOOL WINAPI DoMakeBitmapBottomUp
(
 PBITMAPINFO lpBitmapInfo,
 DWORD       cbBitmapInfo,
 LPBYTE      lpBits,
 DWORD       cbBits
 )
{
    BYTE * lpNewBits;
    DWORD  destByteWidth;
    BYTE * destRaster, * srcRaster;
    INT i;
   // If it's already Bottom-Up then nothing to do
    if (lpBitmapInfo->bmiHeader.biHeight >= 0)
    {
        return TRUE;
    }

    if (lpBitmapInfo->bmiHeader.biPlanes != 1 ||
        !(lpBitmapInfo->bmiHeader.biBitCount == 1 ||
        lpBitmapInfo->bmiHeader.biBitCount == 4 ||
        lpBitmapInfo->bmiHeader.biBitCount == 8 ||
        lpBitmapInfo->bmiHeader.biBitCount == 16 ||
        lpBitmapInfo->bmiHeader.biBitCount == 24 ||
        lpBitmapInfo->bmiHeader.biBitCount == 32)
        || lpBitmapInfo->bmiHeader.biCompression != BI_RGB )
    {
        return FALSE;
    }

    lpBitmapInfo->bmiHeader.biHeight = ABS(lpBitmapInfo->bmiHeader.biHeight);
    lpNewBits = (BYTE*) LocalAlloc(LMEM_FIXED, cbBits);
    if (lpNewBits == NULL)
    {
        return FALSE;
    }

    destByteWidth = ((lpBitmapInfo->bmiHeader.biWidth * lpBitmapInfo->bmiHeader.biBitCount + 31) & ~31) >> 3;

    ASSERT(((cbBits/lpBitmapInfo->bmiHeader.biHeight)*lpBitmapInfo->bmiHeader.biHeight)==cbBits);
    ASSERT(cbBits == destByteWidth * lpBitmapInfo->bmiHeader.biHeight);

    // Start the destination at the end of the bitmap.
    destRaster    = lpNewBits + (destByteWidth * (lpBitmapInfo->bmiHeader.biHeight - 1));
    srcRaster     = lpBits;

    for (i = 0; i < lpBitmapInfo->bmiHeader.biHeight ; i++)
    {
        memcpy(destRaster, srcRaster, destByteWidth);
        destRaster -= destByteWidth;
        srcRaster  += destByteWidth;
    }

    // Recopy the reversed bitmap into the original buffer
    memcpy(lpBits, lpNewBits, cbBits);
    LocalFree( (HLOCAL) lpNewBits);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\conics.c ===
/*****************************************************************************
 *
 * conics - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


FLOAT   eRadsPerDegree = (FLOAT) (ePI / (FLOAT) 180.0) ;

BOOL bFindRadialEllipseIntersection(PLOCALDC pLocalDC,
                                    INT x1, INT y1, INT x2, INT y2,
                                    INT x3, INT y3, INT x4, INT y4,
                                    PPOINT pptStart, PPOINT pptEnd) ;

BOOL bIncIncToIncExcXform (PLOCALDC pLocalDC, PRECTL prcl) ;

VOID vDoArcReflection(PLOCALDC pLocalDC, PPOINTL pptl) ;


/***************************************************************************
 * DoSetArcDirection - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetArcDirection(PLOCALDC pLocalDC, INT iArcDirection)
{
        pLocalDC->iArcDirection = iArcDirection ;

        return(SetArcDirection(pLocalDC->hdcHelper, iArcDirection) != 0);
}


/***************************************************************************
 *  AngleArc  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoAngleArc
(
PLOCALDC pLocalDC,
int     x,
int     y,
DWORD   ulRadius,
FLOAT   eStartAngle,
FLOAT   eSweepAngle
)
{
BOOL    b ;
POINTL  aptl[4] ;
FLOAT   eEndAngle;
INT     iArcDirection;

// If we're recording the drawing orders for a path
// then just pass the drawing order to the helper DC.
// Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        {
            if (pfnSetVirtualResolution == NULL)
            {
                POINTL p = {x, y};
                bXformWorkhorse(&p, 1, &pLocalDC->xformRWorldToRDev);
                b = AngleArc(pLocalDC->hdcHelper, p.x, p.y, ulRadius, eStartAngle, eSweepAngle) ;
            }
            else
            {
                b = AngleArc(pLocalDC->hdcHelper, x, y, ulRadius, eStartAngle, eSweepAngle) ;
            }

            ASSERTGDI(b, "MF3216: DoAngleArc, in path render failed\n") ;
            return(b) ;
        }

// Do the transformations.
// And emit the Win16 drawing orders.

    if (pLocalDC->flags & STRANGE_XFORM
     || eSweepAngle >  360.0f   // more than one revolution
     || eSweepAngle < -360.0f
       )
        {
            b = bRenderCurveWithPath(pLocalDC, (LPPOINT) NULL, (PBYTE) NULL, 0,
            x, y, 0, 0, 0, 0, 0, 0,
            ulRadius, eStartAngle, eSweepAngle, EMR_ANGLEARC);

        return(b);
    }

// Calculate the ARC bounding box.

        aptl[0].x = x - ulRadius ;
        aptl[0].y = y - ulRadius ;
        aptl[1].x = x + ulRadius ;
        aptl[1].y = y + ulRadius ;

// Calculate the begin and end points for ARC from the
// eStartAngle and eSweepAngle.

        aptl[2].x = x + (LONG) ((double) (ulRadius) * cos(eStartAngle * eRadsPerDegree) + 0.5f) ;
        aptl[2].y = y - (LONG) ((double) (ulRadius) * sin(eStartAngle * eRadsPerDegree) + 0.5f) ;

        eEndAngle = eStartAngle + eSweepAngle ;

        aptl[3].x = x + (LONG) ((double) (ulRadius) * cos(eEndAngle * eRadsPerDegree) + 0.5f) ;
        aptl[3].y = y - (LONG) ((double) (ulRadius) * sin(eEndAngle * eRadsPerDegree) + 0.5f) ;

// If the endpoints are identical, we cannot represent the AngleArc as
// an ArcTo.  Use path to render it instead.

    if (aptl[2].x == aptl[3].x && aptl[2].y == aptl[3].y)
        {
            b = bRenderCurveWithPath(pLocalDC, (LPPOINT) NULL, (PBYTE) NULL, 0,
            x, y, 0, 0, 0, 0, 0, 0,
            ulRadius, eStartAngle, eSweepAngle, EMR_ANGLEARC);

        return(b);
    }

// At this point we have the same parameters that would apply to
// a standard ArcTo.  However, we still need to determine the arc
// direction to apply.  If the sweep angle is positive, it is counter-
// clockwise.  If the sweep angle is negative, it is clockwise.

// Save the current arc direction.

        iArcDirection = pLocalDC->iArcDirection;

// Prepare the arc direction for the ArcTo.

        (void) DoSetArcDirection
        (pLocalDC, eSweepAngle < 0.0f ? AD_CLOCKWISE : AD_COUNTERCLOCKWISE);

// Do the ArcTo.

        b = DoArcTo(pLocalDC, aptl[0].x, aptl[0].y, aptl[1].x, aptl[1].y,
                              aptl[2].x, aptl[2].y, aptl[3].x, aptl[3].y) ;

// Restore the current arc direction.

        (void) DoSetArcDirection(pLocalDC, iArcDirection);

        return (b) ;
}

/***************************************************************************
 *  Arc  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoArc
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3,
int x4,
int y4
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4, EMR_ARC) ;

        return(b) ;
}

/***************************************************************************
 *  ArcTo  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoArcTo
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3,
int x4,
int y4
)
{
BOOL    b ;
POINT   ptStart,
        ptEnd ;

    // If we're recording the drawing orders for a path
        // then just pass the drawing order to the helper DC.
        // Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        {
            if (pfnSetVirtualResolution == NULL)
            {
                POINTL p[4] = {x1, y1, x2, y2, x3, y3, x4, y4};
                bXformWorkhorse(p, 4, &pLocalDC->xformRWorldToRDev);
                b = ArcTo(pLocalDC->hdcHelper, p[0].x, p[0].y, p[1].x, p[1].y,
                                               p[2].x, p[2].y, p[3].x, p[3].y) ;
            }
            else
            {
                b = ArcTo(pLocalDC->hdcHelper, x1, y1, x2, y2, x3, y3, x4, y4) ;
            }
            return(b) ;
        }


        b = bFindRadialEllipseIntersection(pLocalDC,
                                           x1, y1, x2, y2,
                                           x3, y3, x4, y4,
                                           &ptStart, &ptEnd) ;
        if (b == FALSE)
            return(b) ;

        b = DoLineTo(pLocalDC, ptStart.x, ptStart.y) ;
        if (b == FALSE)
            return(b) ;

        b = DoArc(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;
        if (b == FALSE)
            return(b) ;

        b = DoMoveTo(pLocalDC, ptEnd.x, ptEnd.y) ;

        return(b) ;
}


/***************************************************************************
 *  Chord  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoChord
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3,
int x4,
int y4
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4, EMR_CHORD) ;

        return(b) ;
}


/***************************************************************************
 *  Ellipse  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoEllipse
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, 0, 0, 0, 0, EMR_ELLIPSE) ;

        return(b) ;
}


/***************************************************************************
 *  Pie  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPie
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3,
int x4,
int y4
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4, EMR_PIE) ;

        return(b) ;
}


/***************************************************************************
 * bConicCommon - The mother of all conic translations.
 *                They are Arc, Chord, Pie, Ellipse, Rectangle and RoundRect.
 **************************************************************************/
BOOL bConicCommon (PLOCALDC pLocalDC, INT x1, INT y1, INT x2, INT y2,
                                      INT x3, INT y3, INT x4, INT y4,
                                      DWORD mrType)
{
SHORT       sx1, sx2, sx3, sx4,
            sy1, sy2, sy3, sy4 ;
LONG        nPointls ;
POINTL      aptl[4] ;
BOOL        b ;

// If we're recording the drawing orders for a path
// then just pass the drawing order to the helper DC.
// Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        {
            POINTL ppts[4] = {x1, y1, x2, y2, x3, y3, x4, y4};
            if (pfnSetVirtualResolution == NULL)
            {
                if (!bXformWorkhorse(ppts, 4, &pLocalDC->xformRWorldToRDev))
                {
                    return(FALSE) ;
                }
            }
            switch(mrType)
            {
                case EMR_ARC:
                    b = Arc(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                                 ppts[2].x, ppts[2].y, ppts[3].x, ppts[3].y);
                    break ;

                case EMR_CHORD:
                    b = Chord(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                                   ppts[2].x, ppts[2].y, ppts[3].x, ppts[3].y);

                    break ;

                case EMR_ELLIPSE:
                    b = Ellipse(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y);
                    break ;

                case EMR_PIE:
                    b = Pie(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                                 ppts[2].x, ppts[2].y, ppts[3].x, ppts[3].y);
                    break ;

                case EMR_RECTANGLE:
                    b = Rectangle(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y);
                    break ;

                case EMR_ROUNDRECT:
                    b = RoundRect(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                                       ppts[2].x, ppts[2].y);
                    break ;

                default:
                    b = FALSE;
                    RIPS("MF3216: bConicCommon, bad mrType");
                    break ;
            }

            ASSERTGDI(b, "MF3216: bConicCommon, in path render failed\n") ;
            return(b) ;
        }

// Do the transformations.
// And emit the Win16 drawing orders.

    if (pLocalDC->flags & STRANGE_XFORM)
        {
            b = bRenderCurveWithPath(pLocalDC, (LPPOINT) NULL, (PBYTE) NULL, 0,
            x1, y1, x2, y2, x3, y3, x4, y4, 0, 0.0f, 0.0f, mrType);

        return(b);
    }

// Do the simple transform case.

        // Compute the number of points

        nPointls = (LONG) (sizeof(aptl) / sizeof(POINTL)) ;

        // Assign all the coordinates into an array for conversion.

        aptl[0].x = x1 ;
        aptl[0].y = y1 ;
        aptl[1].x = x2 ;
        aptl[1].y = y2 ;
        aptl[2].x = x3 ;
        aptl[2].y = y3 ;
        aptl[3].x = x4 ;
        aptl[3].y = y4 ;

        // Take care of the arc direction.

        switch (mrType)
        {
            case EMR_ARC:
            case EMR_CHORD:
            case EMR_PIE:
                vDoArcReflection(pLocalDC, &aptl[2]) ;
                break ;

            default:
                break ;
        }

        // Do the Record-time World to Play-time Page transformations.
        // The radial definitions need only a world to page xform,
        // and the ellipse definitions for roundrects only require
        // a magnitude transformation.

        if (mrType != EMR_ROUNDRECT)
        {
        b = bXformRWorldToPPage(pLocalDC, (PPOINTL) aptl, nPointls) ;
            if (!b)
                goto exit1 ;
        }
        else
        {
            /*
                For roundrects do a Record-time-World to Play-time-Page
                transform of the bounding box only.  Then a magnatude only
                transform of the corner ellipse definitions.
            */

        b = bXformRWorldToPPage(pLocalDC, (PPOINTL) aptl, 2) ;
            if (!b)
                goto exit1 ;

            aptl[2].x = iMagnitudeXform(pLocalDC, aptl[2].x, CX_MAG) ;
            aptl[2].y = iMagnitudeXform(pLocalDC, aptl[2].y, CY_MAG) ;
            aptl[3].x = iMagnitudeXform(pLocalDC, aptl[3].x, CX_MAG) ;
            aptl[3].y = iMagnitudeXform(pLocalDC, aptl[3].y, CY_MAG) ;
        }

        // The bounding boxes for
        // all the conics and rectangles that are handled by this
        // common routine are inclusive-inclusive, and they must
        // be transformed to the inclusive-exclusive Win16 form.

        b = bIncIncToIncExcXform(pLocalDC, (PRECTL) &aptl[0]) ;
    if (!b)
            goto exit1 ;

        // Assign the converted coordinates variables suited to
        // the Win16 metafile.

    sx1 = LOWORD(aptl[0].x) ;
    sy1 = LOWORD(aptl[0].y) ;
    sx2 = LOWORD(aptl[1].x) ;
    sy2 = LOWORD(aptl[1].y) ;
    sx3 = LOWORD(aptl[2].x) ;
    sy3 = LOWORD(aptl[2].y) ;
    sx4 = LOWORD(aptl[3].x) ;
    sy4 = LOWORD(aptl[3].y) ;

        // Emit the Win16 drawing orders to the Win16 metafile.

        switch(mrType)
        {
            case EMR_ARC:
                b = bEmitWin16Arc(pLocalDC, sx1, sy1, sx2, sy2,
                                            sx3, sy3, sx4, sy4) ;
                break ;

            case EMR_CHORD:
                b = bEmitWin16Chord(pLocalDC, sx1, sy1, sx2, sy2,
                                              sx3, sy3, sx4, sy4) ;
                break ;

            case EMR_ELLIPSE:
                b = bEmitWin16Ellipse(pLocalDC, sx1, sy1, sx2, sy2) ;
                break ;

            case EMR_PIE:
                b = bEmitWin16Pie(pLocalDC, sx1, sy1, sx2, sy2,
                                            sx3, sy3, sx4, sy4) ;
                break ;

            case EMR_RECTANGLE:
                b = bEmitWin16Rectangle(pLocalDC, sx1, sy1, sx2, sy2) ;
                break ;

            case EMR_ROUNDRECT:
                b = bEmitWin16RoundRect(pLocalDC, sx1, sy1, sx2, sy2, sx3, sy3) ;
                break ;

        default:
        RIPS("MF3216: bConicCommon, bad mrType");
                break ;
        }

exit1:
        return (b) ;
}


/*****************************************************************************
 * vDoArcReflection - Test for an inversion in the RWorld to PPage matrix.
 *                    If one and only one is found then swap the start
 *                    and  end position for the conics.
 *****************************************************************************/
VOID vDoArcReflection(PLOCALDC pLocalDC, PPOINTL pptl)
{
FLOAT   eM11,
        eM22 ;
POINTL  ptl ;
BOOL    bFlip ;

    // Win16 assumes the counter-clockwise arc direction in the
    // device coordinates.  Win32 defines the arc direction in the
    // world coordinates.

    // Assume no flipping of start and end points.

    bFlip = FALSE ;

    // Account for current arc direction.

    if (pLocalDC->iArcDirection == AD_CLOCKWISE)
        bFlip = !bFlip;

        // If there is an inversion in the xform matrix then invert
        // the arc direction.

        eM11 = pLocalDC->xformRWorldToPPage.eM11 ;
        eM22 = pLocalDC->xformRWorldToPPage.eM22 ;

        if (  (eM11 < 0.0f && eM22 > 0.0f)
            ||(eM11 > 0.0f && eM22 < 0.0f)
           )
        bFlip = !bFlip;

        // If the REQUESTED Win16 mapmode is fixed, then invert the
    // arc direction.

        switch(pLocalDC->iMapMode)
        {
            case MM_LOMETRIC:
            case MM_HIMETRIC:
            case MM_LOENGLISH:
            case MM_HIENGLISH:
            case MM_TWIPS:
                bFlip = !bFlip;
                break ;
        }

    if (bFlip)
        SWAP(pptl[0], pptl[1], ptl);

        return ;
}


/*****************************************************************************
 * bIncIncToIncExcXform - Inclusize Inclusive To Inclusive Exclusize
 *                        transform in play time coordinate space.
 *****************************************************************************/
BOOL bIncIncToIncExcXform (PLOCALDC pLocalDC, PRECTL prcl)
{
LONG     l;

        // Convert the points from Playtime Page to Playtime Device space.

        if (!bXformPPageToPDev(pLocalDC, (PPOINTL) prcl, 2))
        return(FALSE);

    // Reorder the rectangle

    if (prcl->left > prcl->right)
        SWAP(prcl->left, prcl->right, l);

    if (prcl->top > prcl->bottom)
        SWAP(prcl->top, prcl->bottom, l);

        // Expand the right and bottom by one pixel.

        prcl->right++ ;
        prcl->bottom++ ;

        // Convert the points back to Playtime Page space

        return(bXformPDevToPPage(pLocalDC, (PPOINTL) prcl, 2));
}


/*****************************************************************************
 * bFindRadialEllipseIntersection - Calculate the intersection of a radial
 *                                   and an Ellipse.
 *
 *  Play the ArcTo into a path then query the path for the first and
 *  last points on the Arc.
 *****************************************************************************/
BOOL bFindRadialEllipseIntersection(PLOCALDC pLocalDC,
                                    INT x1, INT y1, INT x2, INT y2,
                                    INT x3, INT y3, INT x4, INT y4,
                                    LPPOINT pptStart, LPPOINT pptEnd)
{
BOOL    b;
POINT   ptCP;
POINTL  ppts[4] = {x1, y1, x2, y2, x3, y3, x4, y4};

    b = FALSE;          // assume failure

// Save the current position in the helper DC.

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, &ptCP))
        return(FALSE);

    if (pfnSetVirtualResolution == NULL)
    {
        if (!bXformWorkhorse(ppts, 4, &pLocalDC->xformRWorldToRDev))
        {
            goto exit_bFindRadialEllipseIntersection;
        }
    }

// Do an ArcTo with the same start radial line.

     if (!ArcTo(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                     ppts[2].x, ppts[2].y, ppts[2].x, ppts[2].y))
        goto exit_bFindRadialEllipseIntersection;

// Get the start point of the arc.  It is the current position.

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, pptStart))
        goto exit_bFindRadialEllipseIntersection;

    if (pfnSetVirtualResolution == NULL)
    {
        // On Win9x we need to convert from Device Units in the Helper DC
        // to WorldUnits
        if (!bXformWorkhorse((PPOINTL) pptStart, 1, &pLocalDC->xformRDevToRWorld))
            goto exit_bFindRadialEllipseIntersection;
    }


// Continue with the ArcTo with the same end radial line this time.

    if (!ArcTo(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                    ppts[3].x, ppts[3].y, ppts[3].x, ppts[3].y))
        goto exit_bFindRadialEllipseIntersection;

// Get the end point of the arc.  It is the current position.

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, pptEnd))
        goto exit_bFindRadialEllipseIntersection;

    if (pfnSetVirtualResolution == NULL)
    {
        // On Win9x we need to convert from Device Units in the Helper DC
        // to WorldUnits
        if (!bXformWorkhorse((PPOINTL) pptEnd, 1, &pLocalDC->xformRDevToRWorld))
            goto exit_bFindRadialEllipseIntersection;
    }
// Everything is golden.

    b = TRUE;

exit_bFindRadialEllipseIntersection:

// Restore the current position in the helper DC.

    if (!MoveToEx(pLocalDC->hdcHelper, ptCP.x, ptCP.y, (LPPOINT) NULL))
        RIPS("MF3216: bFindRadialEllipseIntersection, MoveToEx failed");

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\entry.h ===
#ifndef _MF3216_ENTRY_
#define _MF3216_ENTRY_

BOOL APIENTRY DoSetArcDirection(PLOCALDC pLocalDC, INT iArcDirection) ;
BOOL APIENTRY DoGdiComment(PLOCALDC pLocalDC, PEMR pEMR);

BOOL APIENTRY DoAngleArc
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y,
     DWORD   ulRadius,
     FLOAT   eStartAngle,
     FLOAT   eSweepAngle
) ;


BOOL APIENTRY DoArcTo
(
     PLOCALDC pLocalDC,
     int x1,
     int y1,
     int x2,
     int y2,
     int x3,
     int y3,
     int x4,
     int y4
) ;

BOOL APIENTRY DoArc
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2,
     INT x3,
     INT y3,
     INT x4,
     INT y4
) ;

BOOL APIENTRY DoStretchBlt(
PLOCALDC     pLocalDC,
LONG         xDst,
LONG         yDst,
LONG         cxDst,
LONG         cyDst,
DWORD        rop,
LONG         xSrc,
LONG         ySrc,
LONG         cxSrc,
LONG         cySrc,
PXFORM       pxformSrc,
DWORD        iUsageSrc,
PBITMAPINFO  lpBitmapInfo,
DWORD        cbBitmapInfo,
LPBYTE       lpBits,
DWORD        cbBits
) ;

BOOL APIENTRY DoStretchDIBits
(
PLOCALDC     pLocalDC,
LONG         xDst,
LONG         yDst,
LONG         cxDst,
LONG         cyDst,
DWORD        rop,
LONG         xDib,
LONG         yDib,
LONG         cxDib,
LONG         cyDib,
DWORD        iUsage,
LPBITMAPINFO lpBitmapInfo,
DWORD        cbBitmapInfo,
LPBYTE       lpBits,
DWORD        cbBits
) ;

BOOL APIENTRY DoSetDIBitsToDevice
(
PLOCALDC     pLocalDC,
LONG         xDst,
LONG         yDst,
LONG         xDib,
LONG         yDib,
LONG         cxDib,
LONG         cyDib,
DWORD        iUsage,
DWORD        iStartScan,
DWORD        cScans,
LPBITMAPINFO lpBitmapInfo,
DWORD        cbBitmapInfo,
LPBYTE       lpBits,
DWORD        cbBits
);

BOOL APIENTRY DoChord
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2,
     INT x3,
     INT y3,
     INT x4,
     INT y4
) ;

BOOL APIENTRY DoEllipse
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2
) ;

BOOL APIENTRY DoExtCreateFont
(
    PLOCALDC  pLocalDC,
    INT       ihFont,
    PLOGFONTA plfa
) ;

BOOL APIENTRY DoExtFloodFill
(
     PLOCALDC pLocalDC,
     INT         x,
     INT         y,
     COLORREF    crColor,
     DWORD       iFillType
) ;

BOOL APIENTRY DoLineTo
(
     PLOCALDC  pLocalDC,
     LONG    x,
     LONG    y
) ;

BOOL APIENTRY DoMaskBlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop4,
 LONG         xSrc,
 LONG         ySrc,
 PXFORM       pxformSrc,
 DWORD        iUsageSrc,
 PBITMAPINFO  lpBitmapInfoSrc,
 DWORD        cbBitmapInfoSrc,
 LPBYTE       lpBitsSrc,
 DWORD        cbBitsSrc,
 LONG         xMask,
 LONG         yMask,
 DWORD        iUsageMask,
 PBITMAPINFO  lpBitmapInfoMask,
 DWORD        cbBitmapInfoMask,
 LPBYTE       lpBitsMask,
 DWORD        cbBitsMask
) ;

BOOL APIENTRY DoPlgBlt
(
    PLOCALDC    pLocalDC,
    PPOINTL pptlDst,
    LONG    xSrc,
    LONG    ySrc,
    LONG    cxSrc,
    LONG    cySrc,
    PXFORM      pxformSrc,
    DWORD   iUsageSrc,
    PBITMAPINFO lpBitmapInfoSrc,
    DWORD       cbBitmapInfoSrc,
    LPBYTE      lpBitsSrc,
    DWORD       cbBitsSrc,
    LONG    xMask,
    LONG    yMask,
    DWORD       iUsageMask,
    PBITMAPINFO lpBitmapInfoMask,
    DWORD       cbBitmapInfoMask,
    LPBYTE      lpBitsMask,
    DWORD       cbBitsMask
) ;

BOOL APIENTRY DoMoveTo
(
     PLOCALDC pLocalDC,
     LONG    x,
     LONG    y
) ;


BOOL APIENTRY DoPie
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2,
     INT x3,
     INT y3,
     INT x4,
     INT y4
) ;

BOOL APIENTRY DoPolyBezier
(
     PLOCALDC pLocalDC,
     LPPOINT pptl,
     DWORD   cptl
) ;

BOOL APIENTRY DoPolyBezierTo
(
     PLOCALDC pLocalDC,
     LPPOINT pptl,
     DWORD   cptl
) ;

BOOL WINAPI DoPolyDraw
(
    PLOCALDC pLocalDC,
    LPPOINT pptl,
    PBYTE   pb,
    DWORD   cptl
) ;

BOOL APIENTRY DoPoly
(
     PLOCALDC pLocalDC,
     PPOINTL  pptl,
     DWORD    cptl,
     INT      mrType,
     BOOL     transform
) ;

BOOL APIENTRY DoPolylineTo
(
     PLOCALDC pLocalDC,
     PPOINTL pptl,
     DWORD   cptl
) ;

BOOL APIENTRY DoPolyPolygon
(
     PLOCALDC pLocalDC,
     PPOINTL pptl,
     PDWORD  pcptl,
     DWORD   cptl,
     DWORD   ccptl,
     BOOL    transform
) ;

BOOL APIENTRY DoPolyPolyline
(
     PLOCALDC pLocalDC,
     PPOINTL pptl,
     PDWORD  pcptl,
     DWORD   ccptl,
     BOOL    transform
) ;

BOOL APIENTRY DoRectangle
(
     PLOCALDC pLocalDC,
     INT    x1,
     INT    y1,
     INT    x2,
     INT    y2
) ;

BOOL APIENTRY DoRestoreDC
(
     PLOCALDC pLocalDC,
     INT nSavedDC
) ;

BOOL APIENTRY DoRoundRect
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2,
     INT x3,
     INT y3
) ;

BOOL APIENTRY DoSaveDC
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoSetPixel
(
     PLOCALDC pLocalDC,
     INT         x,
     INT         y,
     COLORREF    crColor
) ;

BOOL APIENTRY DoExtTextOut
(
     PLOCALDC pLocalDC,
     INT     x,                  // Initial x position
     INT     y,                  // Initial y position
     DWORD   flOpts,             // Options
     PRECTL  prcl,               // Clipping rectangle
     PWCH    awch,               // Wide Character array
     DWORD   cch,                // Character count
     PLONG   pDx,                // Character positioning
     DWORD   iGraphicsMode,  // Graphics mode
     INT     mrType              // Either unicode or ANSI
) ;

BOOL APIENTRY DoBeginPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoEndPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoFlattenPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoAbortPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoCloseFigure
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoRenderPath
(
     PLOCALDC pLocalDC,
     INT      mrType,
     BOOL     psOnly
);

BOOL APIENTRY DoWidenPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoClipRect
(
 PLOCALDC pLocalDC,
 INT xLeft,
 INT yTop,
 INT xRight,
 INT yBottom,
 INT mrType
) ;

BOOL APIENTRY DoDrawRgn
(
 PLOCALDC  pLocalDC,
 INT       ihBrush,
 INT       nWidth,
 INT       nHeight,
 INT       cRgnData,
 LPRGNDATA pRgnData,
 INT       mrType
) ;

BOOL APIENTRY DoOffsetClipRgn
(
     PLOCALDC pLocalDC,
     INT x,
     INT y
) ;

BOOL APIENTRY DoSetMetaRgn
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoSelectClipPath
(
     PLOCALDC pLocalDC,
     INT    iMode
) ;

BOOL APIENTRY DoExtSelectClipRgn
(
 PLOCALDC  pLocalDC,
 INT       cRgnData,
 LPRGNDATA pRgnData,
 INT       iMode
) ;

BOOL APIENTRY DoModifyWorldTransform
(
     PLOCALDC pLocalDC,
     PXFORM  pxf,
     DWORD   imode
) ;

BOOL APIENTRY DoSetMapMode
(
     PLOCALDC pLocalDC,
     DWORD   ulMapMode
) ;

BOOL WINAPI DoScaleWindowExt
(
 PLOCALDC pLocalDC,
 INT      Xnum,
 INT      Xdenom,
 INT      Ynum,
 INT      Ydenom
) ;

BOOL WINAPI DoScaleViewportExt
(
 PLOCALDC pLocalDC,
 INT      Xnum,
 INT      Xdenom,
 INT      Ynum,
 INT      Ydenom
) ;



BOOL APIENTRY DoSetViewportExt
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y
) ;

BOOL APIENTRY DoSetViewportOrg
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y
) ;

BOOL APIENTRY DoSetWindowExt
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y
) ;

BOOL APIENTRY DoSetWindowOrg
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y
) ;

BOOL APIENTRY DoSetWorldTransform
(
     PLOCALDC pLocalDC,
     PXFORM  pxf
) ;

BOOL APIENTRY DoDeleteObject
(
     PLOCALDC pLocalDC,
     INT hObject
) ;

BOOL APIENTRY DoSelectObject
(
     PLOCALDC pLocalDC,
     LONG   ihObject
) ;

BOOL APIENTRY DoSetBkColor
(
     PLOCALDC      pLocalDC,
     COLORREF    crColor
) ;

BOOL APIENTRY DoSetBkMode
(
     PLOCALDC pLocalDC,
     DWORD   iBkMode
) ;

BOOL APIENTRY DoSetMapperFlags
(
     PLOCALDC pLocalDC,
     DWORD   f
) ;

BOOL APIENTRY DoSetPolyFillMode
(
     PLOCALDC pLocalDC,
     DWORD   iPolyFillMode
) ;

BOOL APIENTRY DoSetRop2
(
     PLOCALDC pLocalDC,
     DWORD   rop
) ;

BOOL APIENTRY DoSetStretchBltMode
(
     PLOCALDC pLocalDC,
     DWORD   iStretchMode
) ;

BOOL APIENTRY DoSetTextAlign
(
     PLOCALDC pLocalDC,
     DWORD   fMode
) ;

BOOL APIENTRY DoSetTextColor
(
     PLOCALDC      pLocalDC,
     COLORREF    crColor
) ;

BOOL APIENTRY DoCreateBrushIndirect
(
     PLOCALDC      pLocalDC,
     INT         ihBrush,
     LPLOGBRUSH  lpLogBrush
) ;

BOOL WINAPI DoCreateDIBPatternBrush
(
    PLOCALDC    pLocalDC,
    DWORD       ihBrush,
    PBITMAPINFO pBitmapInfo,
    DWORD       cbBitmapInfo,
    PBYTE       pBits,
    DWORD       cbBits,
    DWORD       iUsage
) ;

BOOL WINAPI DoCreateMonoBrush
(
    PLOCALDC    pLocalDC,
    DWORD       ihBrush,
    PBITMAPINFO pBitmapInfo,
    DWORD       cbBitmapInfo,
    PBYTE       pBits,
    DWORD       cbBits,
    DWORD       iUsage
) ;


BOOL WINAPI DoCreatePen
(
    PLOCALDC    pLocalDC,
    INT         ihPen,
    PLOGPEN     pLogPen
) ;

BOOL WINAPI DoExtCreatePen
(
    PLOCALDC    pLocalDC,
    INT         ihPen,
    PEXTLOGPEN  pExtLogPen
) ;

BOOL APIENTRY DoCreatePalette
(
    PLOCALDC     pLocalDC,
    DWORD        ihPal,
    LPLOGPALETTE lpLogPal
) ;

BOOL APIENTRY DoSelectPalette
(
    PLOCALDC    pLocalDC,
    DWORD   ihpal
) ;

BOOL APIENTRY DoSetPaletteEntries
(
    PLOCALDC       pLocalDC,
    DWORD      ihPal,
    DWORD      iStart,
    DWORD      cEntries,
    LPPALETTEENTRY pPalEntries
);

BOOL APIENTRY DoResizePalette
(
    PLOCALDC    pLocalDC,
    DWORD       ihpal,
    DWORD       cEntries
) ;

BOOL APIENTRY DoRealizePalette
(
    PLOCALDC    pLocalDC
);

BOOL APIENTRY DoHeader
(
    PLOCALDC pLocalDC,
    PENHMETAHEADER pemfheader
) ;

BOOL APIENTRY DoEOF
(
    PLOCALDC  pLocalDC
) ;

BOOL APIENTRY DoRemoveObjects
(
    PLOCALDC pLocalDC
) ;

BOOL WINAPI DoDeleteRecreationSlots
(
    PLOCALDC pLocalDC
) ;

BOOL WINAPI DoMakeBitmapBottomUp
(
 PBITMAPINFO lpBitmapInfo,
 DWORD       cbBitmapInfo,
 LPBYTE      lpBits,
 DWORD       cbBits
) ;


#endif  // _MF3216_ENTRY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\fonts.c ===
/*****************************************************************************
 *
 * fonts - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


 /***************************************************************************
 *  ExtCreateFont  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoExtCreateFont
(
 PLOCALDC  pLocalDC,
 INT       ihFont,
 PLOGFONTA plfa
 )
{
    BOOL    b ;
    INT     ihW16 ;
    WIN16LOGFONT Win16LogFont;
    
    b = FALSE;
    
    // Create a win16 logfont(a)
    
    Win16LogFont.lfHeight = (SHORT) iMagnitudeXform(pLocalDC, plfa->lfHeight, CY_MAG);
    if (plfa->lfHeight < 0)		// preserve sign
        Win16LogFont.lfHeight = -Win16LogFont.lfHeight;
    Win16LogFont.lfWidth  = (SHORT) iMagnitudeXform(pLocalDC, plfa->lfWidth, CX_MAG);
    if (plfa->lfWidth < 0)		// preserve sign
        Win16LogFont.lfWidth = -Win16LogFont.lfWidth;
    Win16LogFont.lfEscapement     = (SHORT) plfa->lfEscapement;
    Win16LogFont.lfOrientation    = (SHORT) plfa->lfOrientation;
    Win16LogFont.lfWeight         = (SHORT) plfa->lfWeight;
    Win16LogFont.lfItalic         = plfa->lfItalic;
    Win16LogFont.lfUnderline      = plfa->lfUnderline;
    Win16LogFont.lfStrikeOut      = plfa->lfStrikeOut;
    Win16LogFont.lfCharSet        = plfa->lfCharSet;
    Win16LogFont.lfOutPrecision   = plfa->lfOutPrecision;
    Win16LogFont.lfClipPrecision  = plfa->lfClipPrecision;
    Win16LogFont.lfQuality        = plfa->lfQuality;
    Win16LogFont.lfPitchAndFamily = plfa->lfPitchAndFamily;
    
    //vUnicodeToAnsi(pLocalDC->hdcHelper,(PCHAR) Win16LogFont.lfFaceName,
    //    (PWCH)  plfa->lfFaceName,
    //    LF_FACESIZE);
   CopyMemory(&Win16LogFont.lfFaceName, &plfa->lfFaceName, LF_FACESIZE);

    
    // Allocate the W16 handle.
    
    ihW16 = iAllocateW16Handle(pLocalDC, ihFont, REALIZED_FONT) ;
    if (ihW16 == -1)
        goto error_exit ;
    
    // Create the w32 font and store it in the w16 slot table.
    // This font is needed by the helper DC for TextOut simulations.
    
    pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
        = CreateFontIndirectA(plfa);
    
    ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
        "MF3216: CreateFontIndirectW failed");
    
    // Emit the Win16 CreateFont metafile record.
    
    b = bEmitWin16CreateFontIndirect(pLocalDC, &Win16LogFont);
    
error_exit:
    return(b);
}

/***************************************************************************
 *  SetMapperFlags  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetMapperFlags
(
 PLOCALDC pLocalDC,
 DWORD   f
)
{
BOOL    b ;

	// Do it to the helper DC.

	SetMapperFlags(pLocalDC->hdcHelper, (DWORD) f);

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetMapperFlags(pLocalDC, f) ;

        return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\mf3216debug.h ===
#ifndef _MF3216DEBUG_H
#define _MF3216DEBUG_H

#define ASSERTGDI(cond, msg)    ASSERTMSG((cond), (msg))
#define RIPS(msg)               RIP((msg))
#define PUTS(msg)               WARNING((msg))
#define PUTS1(msg, arg)         WARNING((msg, arg))

#endif // !_MF3216DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\mf3216.h ===
/*****************************************************************************
 *
 *  MF3216.h - The include file for MF3216.  This will contain all
 *             the miscellaneous includes.
 *
 *  Author: Jeffrey Newman (c-jeffn)
 *
 *  Creation Date: 31-Jan-1992
 *
 ****************************************************************************/

//////////////////////////////////////////////////////////////////////////////
// GillesK: April 2000
// This is a full copy of the MF3216 source code for use with GDI+...
// Whatever gets fixed in the real MF3216 should be reflected here. in order
// to keep the bugs consistent.
//////////////////////////////////////////////////////////////////////////////


#ifndef _MF3216_
#define _MF3216_

#define NOTUSED(x) {}

#define NOTXORPASS       0
#define DRAWXORPASS      1
#define OBJECTRECREATION 2
#define ERASEXORPASS     3

#define STARTPSIGNORE    1
#define ENDPSIGNORE      0

/* Types for postscript written to metafiles */
#define CLIP_SAVE       0
#define CLIP_RESTORE    1
#define CLIP_INCLUSIVE  2
#define CLIP_EXCLUSIVE  3

typedef struct _w16objhndlslotstatus {
    INT     use ;
    HANDLE  w32Handle ;
    INT     iXORPassCreation ;  // In which XOR pass the object was created
    PBYTE   pbCreatRec;         // Which EMF record created the object
} W16OBJHNDLSLOTSTATUS ;

typedef W16OBJHNDLSLOTSTATUS *PW16OBJHNDLSLOTSTATUS ;

typedef struct _w16recreationslot {
    INT     slot ;              // The slot that we need to create the object in
    PBYTE   pbCreatRec ;        // The record that will create the object
    struct _w16recreationslot* pNext ;
} W16RECREATIONSLOT ;

typedef W16RECREATIONSLOT *PW16RECREATIONSLOT ;

// This structure contains the current metafile information to gather the
// proper transforms
typedef struct tagMAPPING {    // The Page transform in its less
    INT     iMapMode;
    INT     iWox;
    INT     iWoy;
    INT     iVox;
    INT     iVoy;
    INT     iWex;
    INT     iWey;
    INT     iVex;
    INT     iVey;
} MAPPING, *PMAPPING;


typedef struct _localDC {
    UINT    nSize ;                     // Size of this Local DC structure.
    DWORD   flags ;                     // Boolean controls.
    PBYTE   pMf32Bits ;                 // ptr to W32 metafile bits.
    UINT    cMf32Bits ;                 // count of W32 metafile size.
    PBYTE   pMf16Bits ;                 // ptr to user supplied out buffer
    UINT    cMf16Dest ;                 // length of user supplied buffer
    HDC     hdcHelper ;                 // Our helper DC.
    HDC     hdcRef ;                    // Reference DC.
    HBITMAP hbmpMem;                    // A Memory Bitmap for Win9x
    INT     iMapMode ;                  // User requested map mode.
    INT     cxPlayDevMM,
            cyPlayDevMM,
            cxPlayDevPels,
            cyPlayDevPels ;
    XFORM   xformRWorldToRDev,          // aka Metafile-World to Metafile-Device
            xformRDevToRWorld,          // aka Metafile-Device to Metafile-World
            xformRDevToPDev,            // aka Metafile-Device to Reference-Device
            xformPDevToPPage,           // aka Reference-Device to Reference-Logical
            xformPPageToPDev,           // aka Reference-Logical to Reference-Device
            xformRDevToPPage,           // aka Metafile-Device to Reference-Logical
            xformRWorldToPPage ;
    XFORM   xformW ;                    // The World Transform for Win9x
    XFORM   xformP ;                    // The Page Transform for Win9x
    XFORM   xformDC ;                   // The DC Transform for Win9x
    MAPPING map ;                       // The mapping info for Win9x
    POINT   ptCP ;                      // Current position
    PBYTE   pbEnd ;                     // End of W32 metafile bits.
    METAHEADER  mf16Header ;            // The W16 metafile header.
    PINT    piW32ToW16ObjectMap ;
    UINT    cW16ObjHndlSlotStatus ;     // used in slot search
    UINT    cW32ToW16ObjectMap ;        // used in Normalize handle.
    PW16OBJHNDLSLOTSTATUS   pW16ObjHndlSlotStatus ;
    COLORREF crTextColor ;              // current text color - used by
                                        // ExtCreatePen.
    COLORREF crBkColor ;                // Current background color
    INT     iArcDirection ;             // Current arc direction in W32 metafile
    LONG    lhpn32;                     // Currently selected pen.  Used in path and text
    LONG    lhbr32;                     // Currently selected brush.  Used in text
    DWORD   ihpal32;                    // Currently selected (i32) palette.
    DWORD   ihpal16;                    // Currently selected (i16) palette.
    UINT    iLevel;                     // Current DC save level.
    INT     iSavePSClipPath;            // Number of times we save the PSclipPath

    struct _localDC *pLocalDCSaved;     // Point to the saved DCs



// The following fields are not restored by RestoreDC!

    // Information for the XOR ClipPath rendering
    INT     iROP;           // Current ROP Mode
    POINT   pOldPosition ;
    INT     iXORPass ;
    INT     iXORPassDCLevel ;

    UINT    ulBytesEmitted ;            // Total bytes emitted so far.
    UINT    ulMaxRecord ;               // Max W16 record size.
    INT     nObjectHighWaterMark;       // Max slot index used so far.

    PBYTE   pbRecord ;                  // Current record in W32 metafile bits.
    PBYTE   pbCurrent;                  // Next record in W32 metafile bits.
    DWORD   cW32hPal;                   // Size of private W32 palette table.

    PBYTE   pbChange ;                  // Old position in the metafile
    PBYTE   pbLastSelectClip ;          // Old position in the metafile for path drawing
    LONG    lholdp32 ;
    LONG    lholdbr32;

    HPALETTE *pW32hPal;                 // Private W32 palette table.
    PW16RECREATIONSLOT pW16RecreationSlot ;    // Used to recreate objects deleted in XOR Pass

} LOCALDC ;

typedef LOCALDC *PLOCALDC ;

// Routines in apientry.c

BOOL bHandleWin32Comment(PLOCALDC pLocalDC);

// Routines in misc.c

BOOL bValidateMetaFileCP(PLOCALDC pLocalDC, LONG x, LONG y);

// Following are the bit definitions for the flags.

#define SIZE_ONLY               0x00000001
#define INCLUDE_W32MF_COMMENT   0x00000002
#define STRANGE_XFORM           0x00000004
#define RECORDING_PATH          0x00000008
#define INCLUDE_W32MF_XORPATH   0x00000010
#define ERR_BUFFER_OVERFLOW     0x80000000
#define ERR_XORCLIPPATH         0x40000000

// Make this big in case more flags are added to MF3216
#define GPMF3216_INCLUDE_XORPATH    0x1000



// This define sets the size of each Win32 metafile comment record.
// The reason we do not just use a 64K record is due to a caution given
// to use about large escape records in Win3.0 by the GBU (MS Palo Alto).

#define MAX_WIN32_COMMENT_REC_SIZE  0x2000


// Function(s) used in parser.c

extern BOOL  bParseWin32Metafile(PBYTE pMetafileBits, PLOCALDC pLocalDC) ;

// Function definitions for preamble.

extern BOOL bUpdateMf16Header(PLOCALDC pLocalDC) ;

// Function definitions for the emitter.

extern BOOL bEmit(PLOCALDC pLocalDC, PVOID pBuffer, DWORD nCount) ;
extern VOID vUpdateMaxRecord(PLOCALDC pLocalDC, PMETARECORD pmr);

// Defines used in objects.c

#define OPEN_AVAILABLE_SLOT         1
#define REALIZED_BRUSH              2
#define REALIZED_PEN                3
#define REALIZED_BITMAP             4
#define REALIZED_PALETTE            5
#define REALIZED_REGION             6
#define REALIZED_FONT               7
#define REALIZED_OBJECT             8  // used by multiformats record
#define REALIZED_DUMMY              9  // used by multiformats record

#define UNMAPPED                    -1

// Routines in objects.c

extern BOOL bInitHandleTableManager(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header) ;
extern INT  iGetW16ObjectHandleSlot(PLOCALDC pLocalDC, INT iIntendedUse) ;
extern INT  iValidateHandle(PLOCALDC pLocalDC, INT ihW32) ;
extern INT  iAllocateW16Handle(PLOCALDC pLocalDC, INT ihW32, INT iIntendedUse) ;
extern BOOL bDeleteW16Object(PLOCALDC pLocalDC, INT ihW16) ;
extern INT  iNormalizeHandle(PLOCALDC pLocalDC, INT ihW32) ;

// Routines in text.c

VOID vUnicodeToAnsi(HDC hdc, PCHAR pAnsi, PWCH pUnicode, DWORD cch) ;

// Routines in regions.c

BOOL bNoDCRgn(PLOCALDC pLocalDC, INT iType);
BOOL bDumpDCClipping(PLOCALDC pLocalDC);

// Defines used in bNoDCRgn().

#define DCRGN_CLIP     1
#define DCRGN_META     2

// Defines used in xforms.c

#define     CX_MAG  1
#define     CY_MAG  2

typedef struct
{
    FLOAT x;
    FLOAT y;
} POINTFL;
typedef POINTFL *PPOINTFL;

// Function definitions from xform

extern BOOL bInitXformMatrices(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header, RECTL* frameBounds) ;

extern BOOL bXformRWorldToPPage(PLOCALDC pLocalDC, PPOINTL aptl, DWORD nCount) ;
extern BOOL bXformRWorldToRDev(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount) ;
extern BOOL bXformPDevToPPage(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount) ;
extern BOOL bXformPPageToPDev(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount) ;
extern BOOL bXformRDevToRWorld(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount) ;

extern INT  iMagnitudeXform (PLOCALDC pLocalDC, INT value, INT iType) ;

extern XFORM xformIdentity ;
extern BOOL  bRotationTest(PXFORM pxform) ;
extern INT   iMagXformWorkhorse (INT value, PXFORM pxform, INT iType) ;
extern BOOL  bXformWorkhorse(PPOINTL aptl, DWORD nCount, PXFORM pXform) ;
extern VOID  vXformWorkhorseFloat(PPOINTFL aptfl, UINT nCount, PXFORM pXform);
extern BOOL  bCoordinateOverflowTest(PLONG pCoordinates, INT nCount) ;

BOOL bCombineTransform(
  LPXFORM lpxformResult,  // combined transformation
  CONST XFORM *lpxform1,  // first transformation
  CONST XFORM *lpxform2   // second transformation
);



// Defines used in Conics

#define SWAP(x,y,t)        {t = x; x = y; y = t;}

#define ePI ((FLOAT)(((FLOAT) 22.0 / (FLOAT) 7.0 )))

// Exported support functions and defines for Conics & rectangles.

extern BOOL bConicCommon (PLOCALDC pLocalDC, INT x1, INT y1, INT x2, INT y2,
                                             INT x3, INT y3, INT x4, INT y4,
                                             DWORD mrType) ;

extern BOOL bRenderCurveWithPath
(
    PLOCALDC pLocalDC,
    LPPOINT  pptl,
    PBYTE    pb,
    DWORD    cptl,
    INT      x1,
    INT      y1,
    INT      x2,
    INT      y2,
    INT      x3,
    INT      y3,
    INT      x4,
    INT      y4,
    DWORD    nRadius,
    FLOAT    eStartAngle,
    FLOAT    eSweepAngle,
    DWORD    mrType
);

// Exported functions from lines.c

extern VOID vCompressPoints(PVOID pBuff, LONG nCount) ;


// Defines (macros) used in bitmaps.

// Check if a source is needed in a 3-way bitblt operation.
// This works on both rop and rop3.  We assume that a rop contains zero
// in the high byte.
//
// This is tested by comparing the rop result bits with source (column A
// below) vs. those without source (column B).  If the two cases are
// identical, then the effect of the rop does not depend on the source
// and we don't need a source device.  Recall the rop construction from
// input (pattern, source, target --> result):
//
//  P S T | R   A B     mask for A = 0CCh
//  ------+--------     mask for B =  33h
//  0 0 0 | x   0 x
//  0 0 1 | x   0 x
//  0 1 0 | x   x 0
//  0 1 1 | x   x 0
//  1 0 0 | x   0 x
//  1 0 1 | x   0 x
//  1 1 0 | x   x 0
//  1 1 1 | x   x 0

#define ISSOURCEINROP3(rop3)    \
    (((rop3) & 0xCCCC0000) != (((rop3) << 2) & 0xCCCC0000))


#define CJSCAN(width,planes,bits) ((((width)*(planes)*(bits)+31) & ~31) / 8)

#define MAX4(a, b, c, d)    max(max(max(a,b),c),d)
#define MIN4(a, b, c, d)    min(min(min(a,b),c),d)

// GillesK: Mar 2000
// This is needed because GetTransform is not in GDI32.lib but is in GDI32.dll
typedef BOOL (*fnGetTransform)(HDC,DWORD,LPXFORM);
typedef BOOL (*fnSetVirtualResolution)(HDC,
                                   int,
                                   int,
                                   int,
                                   int);




#endif  //_MF3216_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\metafile.hpp ===
#ifndef __GPMETAFILE_HPP__
#define __GPMETAFILE_HPP__

extern "C" UINT GdipConvertEmfToWmf(PBYTE pMetafileBits, UINT cDest, PBYTE pDest,
                 INT iMapMode, HDC hdcRef, UINT flags);

DWORD
WINAPI
GetObjectTypeInternal(
    IN HGDIOBJ handle
    );

DWORD
WINAPI
GetDCType(
    IN HDC hdc
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\lines.c ===
/*****************************************************************************
 *
 * lines - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************
 *  PolylineTo  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolylineTo
(
PLOCALDC pLocalDC,
PPOINTL pptl,
DWORD   cptl
)
{
BOOL    b ;

    // Handle path.

    if (pLocalDC->flags & RECORDING_PATH)
    {
        if (pfnSetVirtualResolution == NULL)
        {
            bXformWorkhorse((PPOINTL) pptl, cptl, &pLocalDC->xformRWorldToRDev);
        }
        return(PolylineTo(pLocalDC->hdcHelper, (LPPOINT) pptl, (DWORD) cptl));
    }

    // Handle the trivial case.

    if (cptl == 0)
        return(TRUE);

    // This can be done by using a LineTo, PolyLine, & MoveTo.

    if (!DoLineTo(pLocalDC, pptl[0].x, pptl[0].y))
        return(FALSE);

    // If there is only one point, we are done.

    if (cptl == 1)
        return(TRUE);

    if (!DoPoly(pLocalDC, pptl, cptl, EMR_POLYLINE, TRUE))
        return(FALSE);

    b = DoMoveTo(pLocalDC, pptl[cptl-1].x, pptl[cptl-1].y) ;
    return (b) ;
}


/***************************************************************************
 *  PolyPolyline  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyPolyline
(
PLOCALDC pLocalDC,
PPOINTL pptl,                       // -> to PolyPolyline points.
PDWORD  pcptl,                      // -> to PolyCounts
DWORD   ccptl,                      // # of PolyCounts.
BOOL    transform                   // do we want to transform the points
)
{
BOOL    b ;
UINT    i,
        iStart,
        nCount ;

    b = TRUE;       // just in case if there is no poly

    // Let polyline do the work.

    iStart = 0 ;
    for (i = 0 ; i < ccptl ; i++)
    {
        nCount = pcptl[i] ;
        b = DoPoly(pLocalDC, &pptl[iStart], nCount, EMR_POLYLINE, transform) ;
        if (b == FALSE)
            break ;
        iStart += nCount ;
    }

    return(b) ;
}


/***************************************************************************
 *  LineTo  - Win32 to Win16 Metafile Converter Entry Point
 *
 *  See DoMoveTo() in misc.c for notes on the current position.
 **************************************************************************/
BOOL WINAPI DoLineTo
(
PLOCALDC  pLocalDC,
LONG    x,
LONG    y
)
{
BOOL    b ;
POINT   pt ;
POINT   ptCP;

    // Whether we are recording for a path or acutally emitting
    // a drawing order we must pass the drawing order to the helper DC
    // so the helper can maintain the current positon.
    // If we're recording the drawing orders for a path
    // then just pass the drawing order to the helper DC.
    // Do not emit any Win16 drawing orders.

    POINTL p = {x, y};
    if (pfnSetVirtualResolution == NULL)
    {
        bXformWorkhorse(&p, 1, &pLocalDC->xformRWorldToRDev);
    }

    if (pLocalDC->flags & RECORDING_PATH)
    {
        return(LineTo(pLocalDC->hdcHelper, (INT) p.x, (INT) p.y));
    }

    // Update the current position in the converted metafile if
    // it is different from that of the helper DC.  See notes
    // in DoMoveTo().

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, &ptCP))
        return(FALSE);

    if (pfnSetVirtualResolution == NULL)
    {
        // On Win9x we need to convert from Device Units in the Helper DC
        // to WorldUnits
        if (!bXformWorkhorse((PPOINTL) &ptCP, 1, &pLocalDC->xformRDevToRWorld))
            return(FALSE);
    }

    // Make sure that the converted metafile has the same CP as the
    // helper DC.

    if (!bValidateMetaFileCP(pLocalDC, ptCP.x, ptCP.y))
        return(FALSE);

    // Update the helper DC.
    // Update the helper DC.  (We only need to update the CP so there's no
    // reason to actually call LineTo.)

    if (!MoveToEx(pLocalDC->hdcHelper, (INT) p.x, (INT) p.y, 0))
        return(FALSE);

    // Compute the new current position.

    pt.x = x ;
    pt.y = y ;
    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &pt, 1L))
        return(FALSE);

    // Update the mf16 current position to what it will be when this call
    // is finished.

    pLocalDC->ptCP = pt ;

    // Call the Win16 routine to emit the line to the metafile.

    b = bEmitWin16LineTo(pLocalDC, LOWORD(pt.x), LOWORD(pt.y)) ;
    return(b) ;
}

/***************************************************************************
 *  Polyline/Polygon  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPoly
(
PLOCALDC pLocalDC,
PPOINTL  pptl,
DWORD    cptl,
INT      mrType,
BOOL     transform
)
{
BOOL    b ;
PPOINTL pptlBuff ;

    // If we're recording the drawing orders for a path
    // then just pass the drawing order to the helper DC.
    // Do not emit any Win16 drawing orders.

    if (pLocalDC->flags & RECORDING_PATH)
    {
        if (pfnSetVirtualResolution == NULL)
        {
            bXformWorkhorse(pptl, cptl, &pLocalDC->xformRWorldToRDev);
        }
        switch(mrType)
        {
            case EMR_POLYLINE:
                b = Polyline(pLocalDC->hdcHelper, (LPPOINT) pptl, (INT) cptl) ;
                break;
            case EMR_POLYGON:
                b = Polygon(pLocalDC->hdcHelper, (LPPOINT) pptl, (INT) cptl) ;
                break;
        }
        return(b) ;
    }

    // The Win16 poly record is limited to 64K points.
    // Need to check this limit.

    if (cptl > (DWORD) (WORD) MAXWORD)
    {
        b = FALSE;
        PUTS("MF3216: DoPoly, Too many point in poly array\n") ;
        SetLastError(ERROR_NOT_ENOUGH_MEMORY) ;
        goto exit1 ;
    }

    // Allocate a buffer to do the transformation in.
    // Then copy the points to this buffer.

    pptlBuff = (PPOINTL) LocalAlloc(LMEM_FIXED, cptl * sizeof(POINTL)) ;
    if (!pptlBuff)
    {
        b = FALSE;
        PUTS("MF3216: DoPoly, LocalAlloc failed\n") ;
        goto exit1 ;
    }

    RtlCopyMemory(pptlBuff, pptl, cptl * sizeof(POINTL)) ;

    // Do the transformations.
    if (transform)
    {
        b = bXformRWorldToPPage(pLocalDC, pptlBuff, cptl) ;
        if (b == FALSE)
            goto exit2 ;
    }


    // Compress the POINTLs to POINTSs

    vCompressPoints(pptlBuff, cptl) ;

    // Call the Win16 routine to emit the poly to the metafile.
    b = bEmitWin16Poly(pLocalDC, (LPPOINTS) pptlBuff, (SHORT) cptl,
        (WORD) (mrType == EMR_POLYLINE ? META_POLYLINE : META_POLYGON)) ;

    // Free the memory used as the transform buffer.
exit2:
    if (LocalFree(pptlBuff))
    ASSERTGDI(FALSE, "MF3216: DoPoly, LocalFree failed");
exit1:
    return(b) ;
}


/***************************************************************************
 * vCompressPoints - Utility routine to compress the POINTLs to POINTSs.
 **************************************************************************/
VOID vCompressPoints(PVOID pBuff, LONG nCount)
{
PPOINTL pPointl ;
PPOINTS pPoints ;
INT     i ;

    pPointl = (PPOINTL) pBuff ;
    pPoints = (PPOINTS) pBuff ;

    for (i = 0 ; i < nCount ; i++)
    {
        pPoints[i].x = LOWORD(pPointl[i].x) ;
        pPoints[i].y = LOWORD(pPointl[i].y) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\handlers.c ===
/****************************************************************************
*  Handlers.c - Handlers for the Win32 metafile  records
*
*  DATE:   11-Dec-1991
*  Author: Jeffrey Newman (c-jeffn)
*
*  Copyright (c) Microsoft Inc. 1991
****************************************************************************/


#include "precomp.h"
#include <wtypes.h>
#pragma hdrstop

extern fnSetVirtualResolution pfnSetVirtualResolution;

// Max number of pointl's allowed on stack before explicit memory allocation.

#define MAX_STACK_POINTL    128

// Convert array of POINTSs to POINTLs.

#define POINTS_TO_POINTL(pptl, ppts, cpt)           \
    {                               \
    DWORD i;                        \
    for (i = 0; i < (cpt); i++)             \
    {                           \
    (pptl)[i].x = (LONG) (ppts)[i].x;           \
    (pptl)[i].y = (LONG) (ppts)[i].y;           \
    }                           \
    }

DWORD GetCodePage(HDC hdc);

/**************************************************************************
* Handler - NotImplemented
*
* The following 32-bit records have no equivalent 16-bit metafile records:
*      SETBRUSHORGEX
*
*************************************************************************/
BOOL bHandleNotImplemented(PVOID pVoid, PLOCALDC pLocalDC)
{
    PENHMETARECORD pemr ;
    INT            iType ;

    NOTUSED(pLocalDC) ;

    pemr = (PENHMETARECORD) pVoid ;
    iType = pemr->iType ;

    if (iType != EMR_SETBRUSHORGEX
        && iType != EMR_SETCOLORADJUSTMENT
        && iType != EMR_SETMITERLIMIT
        && iType != EMR_SETICMMODE
        && iType != EMR_CREATECOLORSPACE
        && iType != EMR_SETCOLORSPACE
        && iType != EMR_DELETECOLORSPACE
        && iType != EMR_GLSRECORD
        && iType != EMR_GLSBOUNDEDRECORD
        && iType != EMR_PIXELFORMAT)
    {
        PUTS1("MF3216: bHandleNotImplemented - record not supported: %d\n", iType) ;
    }
    return(TRUE) ;
}


/**************************************************************************
* Handler - GdiComment
*************************************************************************/
BOOL bHandleGdiComment(PVOID pVoid, PLOCALDC pLocalDC)
{
    return(DoGdiComment(pLocalDC, (PEMR) pVoid));
}


/**************************************************************************
* Handler - SetPaletteEntries
*************************************************************************/
BOOL bHandleSetPaletteEntries(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL     b ;
    PEMRSETPALETTEENTRIES pMfSetPaletteEntries ;
    DWORD    ihPal, iStart, cEntries ;
    PPALETTEENTRY   pPalEntry ;

    pMfSetPaletteEntries = (PEMRSETPALETTEENTRIES) pVoid ;

    // Now do the translation.

    ihPal     = pMfSetPaletteEntries->ihPal ;
    iStart    = pMfSetPaletteEntries->iStart ;
    cEntries  = pMfSetPaletteEntries->cEntries ;
    pPalEntry = pMfSetPaletteEntries->aPalEntries ;

    b = DoSetPaletteEntries(pLocalDC, ihPal, iStart, cEntries, pPalEntry) ;

    return (b) ;
}


/**************************************************************************
* Handler - CreatePalette
*************************************************************************/
BOOL bHandleCreatePalette(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRCREATEPALETTE pMfCreatePalette ;
    LPLOGPALETTE     lpLogPal ;
    DWORD   ihPal ;

    pMfCreatePalette = (PEMRCREATEPALETTE) pVoid ;

    // Now do the translation.

    ihPal    = pMfCreatePalette->ihPal ;
    lpLogPal = &pMfCreatePalette->lgpl ;

    b = DoCreatePalette(pLocalDC, ihPal, lpLogPal) ;

    return (b) ;
}


/**************************************************************************
* Handler - RealizePalette
*************************************************************************/
BOOL bHandleRealizePalette(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL     b ;

    NOTUSED(pVoid);

    // Now do the translation.

    b = DoRealizePalette(pLocalDC) ;

    return (b) ;
}


/**************************************************************************
* Handler - ResizePalette
*************************************************************************/
BOOL bHandleResizePalette(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL     b ;
    PEMRRESIZEPALETTE pMfResizePalette ;
    DWORD    ihPal, cEntries ;

    pMfResizePalette = (PEMRRESIZEPALETTE) pVoid ;

    // Now do the translation.

    ihPal    = pMfResizePalette->ihPal ;
    cEntries = pMfResizePalette->cEntries ;

    b = DoResizePalette(pLocalDC, ihPal, cEntries) ;

    return (b) ;
}


/**************************************************************************
* Handler - SelectPalette
*************************************************************************/
BOOL bHandleSelectPalette(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL     b ;
    PEMRSELECTPALETTE pMfSelectPalette ;
    DWORD    ihPal ;

    pMfSelectPalette = (PEMRSELECTPALETTE) pVoid ;

    // Now do the translation.

    ihPal = pMfSelectPalette->ihPal ;

    b = DoSelectPalette(pLocalDC, ihPal) ;

    return (b) ;
}

/**************************************************************************
* Handler - OffsetClipRgn
*************************************************************************/
BOOL bHandleOffsetClipRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMROFFSETCLIPRGN pMfOffsetClipRgn ;
    INT      x, y ;

    pMfOffsetClipRgn = (PEMROFFSETCLIPRGN) pVoid ;

    // Now do the translation.

    x = pMfOffsetClipRgn->ptlOffset.x ;
    y = pMfOffsetClipRgn->ptlOffset.y ;

    b = DoOffsetClipRgn(pLocalDC, x, y) ;

    return (b) ;
}

/**************************************************************************
* Handler - ExtSelectClipRgn
*************************************************************************/
BOOL bHandleExtSelectClipRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMREXTSELECTCLIPRGN pMfExtSelectClipRgn ;
    INT        cbRgnData, iMode ;
    LPRGNDATA  pRgnData ;

    pMfExtSelectClipRgn = (PEMREXTSELECTCLIPRGN) pVoid ;

    // Now do the translation.

    cbRgnData = pMfExtSelectClipRgn->cbRgnData ;
    pRgnData = (LPRGNDATA) pMfExtSelectClipRgn->RgnData;
    iMode    = pMfExtSelectClipRgn->iMode ;

    b = DoExtSelectClipRgn(pLocalDC, cbRgnData, pRgnData, iMode) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetMetaRgn
*************************************************************************/
BOOL bHandleSetMetaRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;

    NOTUSED(pVoid) ;

    b = DoSetMetaRgn(pLocalDC) ;

    return(b) ;
}


/**************************************************************************
* Handler - PaintRgn
*************************************************************************/
BOOL bHandlePaintRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRPAINTRGN pMfPaintRgn ;
    INT      cbRgnData;
    LPRGNDATA    pRgnData ;

    pMfPaintRgn = (PEMRPAINTRGN) pVoid ;

    // Now do the translation.

    cbRgnData  = pMfPaintRgn->cbRgnData ;
    pRgnData   = (LPRGNDATA) pMfPaintRgn->RgnData;

    b = DoDrawRgn(pLocalDC, 0, 0, 0, cbRgnData, pRgnData, EMR_PAINTRGN);

    return (b) ;
}

/**************************************************************************
* Handler - InvertRgn
*************************************************************************/
BOOL bHandleInvertRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRINVERTRGN pMfInvertRgn ;
    INT      cbRgnData;
    LPRGNDATA    pRgnData ;

    pMfInvertRgn = (PEMRINVERTRGN) pVoid ;

    // Now do the translation.

    cbRgnData  = pMfInvertRgn->cbRgnData ;
    pRgnData   = (LPRGNDATA) pMfInvertRgn->RgnData;

    b = DoDrawRgn(pLocalDC, 0, 0, 0, cbRgnData, pRgnData, EMR_INVERTRGN);

    return (b) ;
}


/**************************************************************************
* Handler - FrameRgn
*************************************************************************/
BOOL bHandleFrameRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRFRAMERGN pMfFrameRgn ;
    INT     ihBrush,
        cbRgnData,
        nWidth,
        nHeight ;
    LPRGNDATA   pRgnData ;

    pMfFrameRgn = (PEMRFRAMERGN) pVoid ;

    // Now do the translation.

    ihBrush    = pMfFrameRgn->ihBrush ;
    nWidth     = pMfFrameRgn->szlStroke.cx ;
    nHeight    = pMfFrameRgn->szlStroke.cy ;
    cbRgnData  = pMfFrameRgn->cbRgnData ;
    pRgnData   = (LPRGNDATA) pMfFrameRgn->RgnData;

    b = DoDrawRgn(pLocalDC, ihBrush, nWidth, nHeight, cbRgnData, pRgnData, EMR_FRAMERGN);

    return (b) ;
}

/**************************************************************************
* Handler - FillRgn
*************************************************************************/
BOOL bHandleFillRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRFILLRGN pMfFillRgn ;
    INT    ihBrush,
        cbRgnData;
    LPRGNDATA  pRgnData ;


    // Set up the pointer the Doer uses to reference the
    // the Win32 drawing order.  Also setup the drawing order specific
    // pointer.

    pMfFillRgn = (PEMRFILLRGN) pVoid ;

    // Now do the translation.

    ihBrush    = pMfFillRgn->ihBrush ;
    cbRgnData  = pMfFillRgn->cbRgnData ;
    pRgnData   = (LPRGNDATA) pMfFillRgn->RgnData;

    b = DoDrawRgn(pLocalDC, ihBrush, 0, 0, cbRgnData, pRgnData, EMR_FILLRGN);

    return (b) ;
}


/**************************************************************************
* Handler - IntersectClipRect
*************************************************************************/
BOOL bHandleIntersectClipRect(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRINTERSECTCLIPRECT pMfIntersectClipRect ;
    INT xLeft, yTop, xRight, yBottom ;


    pMfIntersectClipRect = (PEMRINTERSECTCLIPRECT) pVoid ;

    // Now do the translation.
    xLeft   = pMfIntersectClipRect->rclClip.left ;
    yTop    = pMfIntersectClipRect->rclClip.top ;
    xRight  = pMfIntersectClipRect->rclClip.right ;
    yBottom = pMfIntersectClipRect->rclClip.bottom ;

    b = DoClipRect(pLocalDC, xLeft, yTop, xRight, yBottom, EMR_INTERSECTCLIPRECT) ;

    return (b) ;

}

/**************************************************************************
* Handler - ExcludeClipRect
*************************************************************************/
BOOL bHandleExcludeClipRect(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMREXCLUDECLIPRECT pMfExcludeClipRect ;
    INT xLeft, yTop, xRight, yBottom ;


    pMfExcludeClipRect = (PEMREXCLUDECLIPRECT) pVoid ;

    // Now do the translation.
    xLeft   = pMfExcludeClipRect->rclClip.left ;
    yTop    = pMfExcludeClipRect->rclClip.top ;
    xRight  = pMfExcludeClipRect->rclClip.right ;
    yBottom = pMfExcludeClipRect->rclClip.bottom ;

    b = DoClipRect(pLocalDC, xLeft, yTop, xRight, yBottom, EMR_EXCLUDECLIPRECT) ;

    return (b) ;

}


/**************************************************************************
* Handler - SetPixel
*************************************************************************/
BOOL bHandleSetPixel(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRSETPIXELV pMfSetPixel ;
    INT     x, y ;
    COLORREF    crColor ;

    pMfSetPixel = (PEMRSETPIXELV) pVoid ;

    // Now do the translation.

    x   = (INT) pMfSetPixel->ptlPixel.x ;
    y   = (INT) pMfSetPixel->ptlPixel.y ;
    crColor = pMfSetPixel->crColor ;

    b = DoSetPixel(pLocalDC, x, y, crColor) ;

    return (b) ;
}


/**************************************************************************
* Handler - ExtFloodFill
*************************************************************************/
BOOL bHandleExtFloodFill(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL            b ;
    PEMREXTFLOODFILL pMfExtFloodFill ;
    INT         x, y ;
    COLORREF        crColor ;
    DWORD           iMode ;

    pMfExtFloodFill = (PEMREXTFLOODFILL) pVoid ;

    // Now do the translation.

    x   = (INT) pMfExtFloodFill->ptlStart.x ;
    y   = (INT) pMfExtFloodFill->ptlStart.y ;
    crColor = pMfExtFloodFill->crColor ;
    iMode   = pMfExtFloodFill->iMode ;

    b = DoExtFloodFill(pLocalDC, x, y, crColor, iMode) ;

    return (b) ;
}


/**************************************************************************
* Handler - ModifyWorldTransform
*************************************************************************/
BOOL bHandleModifyWorldTransform(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRMODIFYWORLDTRANSFORM pMfModifyWorldTransform ;
    PXFORM  pxform ;
    DWORD   iMode ;


    pMfModifyWorldTransform = (PEMRMODIFYWORLDTRANSFORM) pVoid ;

    // get a pointer to the xform matrix

    pxform = &pMfModifyWorldTransform->xform ;
    iMode  = pMfModifyWorldTransform->iMode ;

    // Now do the translation.

    b = DoModifyWorldTransform(pLocalDC, pxform, iMode) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetWorldTransform
*************************************************************************/
BOOL bHandleSetWorldTransform(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRSETWORLDTRANSFORM pMfSetWorldTransform ;
    PXFORM  pxform ;


    pMfSetWorldTransform = (PEMRSETWORLDTRANSFORM) pVoid ;

    // get a pointer to the xform matrix

    pxform = &pMfSetWorldTransform->xform ;

    // Now do the translation.

    b = DoSetWorldTransform(pLocalDC, pxform) ;

    return (b) ;
}


/**************************************************************************
* Handler - PolyBezierTo
*************************************************************************/
BOOL bHandlePolyBezierTo(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRPOLYBEZIERTO pMfPolyBezierTo ;
    DWORD   nCount ;
    PPOINTL pptl ;

    pMfPolyBezierTo = (PEMRPOLYBEZIERTO) pVoid ;

    // Copy the BezierTo count and the polyBezierTo verticies to
    // the record.

    nCount = pMfPolyBezierTo->cptl ;
    pptl   = pMfPolyBezierTo->aptl ;

    // Now do the translation.

    b = DoPolyBezierTo(pLocalDC, (LPPOINT) pptl, nCount) ;

    return (b) ;
}


/**************************************************************************
* Handler - PolyDraw
*************************************************************************/
BOOL bHandlePolyDraw(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRPOLYDRAW pMfPolyDraw ;
    DWORD   nCount ;
    PPOINTL pptl ;
    PBYTE   pb ;

    pMfPolyDraw = (PEMRPOLYDRAW) pVoid ;

    // Copy the Draw count and the polyDraw verticies to
    // the record.

    nCount = pMfPolyDraw->cptl ;
    pptl   = pMfPolyDraw->aptl ;
    pb     = (PBYTE) &pMfPolyDraw->aptl[nCount];

    // Now do the translation.

    b = DoPolyDraw(pLocalDC, (LPPOINT) pptl, pb, nCount) ;

    return (b) ;
}


/**************************************************************************
* Handler - PolyBezier
*************************************************************************/
BOOL bHandlePolyBezier(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRPOLYBEZIER pMfPolyBezier ;
    DWORD   nCount ;
    PPOINTL pptl ;

    pMfPolyBezier = (PEMRPOLYBEZIER) pVoid ;

    // Copy the Bezier count and the polyBezier verticies to
    // the record.

    nCount = pMfPolyBezier->cptl ;
    pptl   = pMfPolyBezier->aptl ;

    // Now do the translation.

    b = DoPolyBezier(pLocalDC, (LPPOINT) pptl, nCount) ;

    return (b) ;
}


/**************************************************************************
* Handler - Begin Path
*************************************************************************/
BOOL bHandleBeginPath(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;

    NOTUSED(pVoid) ;

    b = DoBeginPath(pLocalDC) ;

    return (b) ;
}

/**************************************************************************
* Handler - End Path
*************************************************************************/
BOOL bHandleEndPath(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;

    NOTUSED(pVoid) ;

    b = DoEndPath(pLocalDC) ;

    return (b) ;
}

/**************************************************************************
* Handler - Flatten Path
*************************************************************************/
BOOL bHandleFlattenPath(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;

    NOTUSED(pVoid) ;

    b = DoFlattenPath(pLocalDC) ;

    return (b) ;
}

/**************************************************************************
* Handler - CloseFigure
*************************************************************************/
BOOL bHandleCloseFigure(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;

    NOTUSED(pVoid) ;

    b = DoCloseFigure(pLocalDC) ;

    return (b) ;
}

/**************************************************************************
* Handler - Abort Path
*************************************************************************/
BOOL bHandleAbortPath(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;

    NOTUSED(pVoid) ;

    b = DoAbortPath(pLocalDC) ;

    return (b) ;
}

/**************************************************************************
* Handler - Stroke Path
*************************************************************************/
BOOL bHandleStrokePath(PVOID pVoid, PLOCALDC pLocalDC)
{
    NOTUSED(pVoid) ;

    return(DoRenderPath(pLocalDC, EMR_STROKEPATH, FALSE));
}

/**************************************************************************
* Handler - Fill Path
*************************************************************************/
BOOL bHandleFillPath(PVOID pVoid, PLOCALDC pLocalDC)
{
    NOTUSED(pVoid) ;

    return(DoRenderPath(pLocalDC, EMR_FILLPATH, FALSE));
}

/**************************************************************************
* Handler - Stroke and Fill Path
*************************************************************************/
BOOL bHandleStrokeAndFillPath(PVOID pVoid, PLOCALDC pLocalDC)
{
    NOTUSED(pVoid) ;

    return(DoRenderPath(pLocalDC, EMR_STROKEANDFILLPATH, FALSE));
}

/**************************************************************************
* Handler - Widen Path
*************************************************************************/
BOOL bHandleWidenPath(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;

    NOTUSED(pVoid) ;

    b = DoWidenPath(pLocalDC) ;

    return(b) ;
}

/**************************************************************************
* Handler - Select Clip Path
*************************************************************************/
BOOL bHandleSelectClipPath(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRSELECTCLIPPATH   pMfSelectClipPath ;
    INT     iMode ;

    pMfSelectClipPath = (PEMRSELECTCLIPPATH) pVoid ;

    iMode = (INT) pMfSelectClipPath->iMode ;

    b = DoSelectClipPath(pLocalDC, iMode) ;

    return(b) ;
}

/**************************************************************************
* Handler - StretchDIBits
*************************************************************************/
BOOL bHandleStretchDIBits(PVOID pVoid, PLOCALDC pLocalDC)
{
    PEMRSTRETCHDIBITS pMfStretchDIBits ;

    BOOL    b ;
    LONG    xDest ;
    LONG    yDest ;
    LONG    xSrc ;
    LONG    ySrc ;
    LONG    cxSrc ;
    LONG    cySrc ;
    DWORD   offBmiSrc ;
    DWORD   cbBmiSrc ;
    DWORD   offBitsSrc ;
    DWORD   cbBitsSrc ;
    DWORD   iUsageSrc ;
    DWORD   dwRop ;
    LONG    cxDest ;
    LONG    cyDest ;

    LPBITMAPINFO    lpBitmapInfo ;
    LPBYTE          lpBits ;

    pMfStretchDIBits = (PEMRSTRETCHDIBITS) pVoid ;

    xDest      = pMfStretchDIBits->xDest ;
    yDest      = pMfStretchDIBits->yDest ;
    xSrc       = pMfStretchDIBits->xSrc ;
    ySrc       = pMfStretchDIBits->ySrc ;
    cxSrc      = pMfStretchDIBits->cxSrc ;
    cySrc      = pMfStretchDIBits->cySrc ;
    offBmiSrc  = pMfStretchDIBits->offBmiSrc ;
    cbBmiSrc   = pMfStretchDIBits->cbBmiSrc ;
    offBitsSrc = pMfStretchDIBits->offBitsSrc ;
    cbBitsSrc  = pMfStretchDIBits->cbBitsSrc ;
    iUsageSrc  = pMfStretchDIBits->iUsageSrc ;
    dwRop      = pMfStretchDIBits->dwRop;
    cxDest     = pMfStretchDIBits->cxDest ;
    cyDest     = pMfStretchDIBits->cyDest ;

    lpBitmapInfo = (LPBITMAPINFO) ((PBYTE) pMfStretchDIBits + offBmiSrc) ;
    lpBits = (PBYTE) pMfStretchDIBits + offBitsSrc ;

    b = DoStretchDIBits(pLocalDC,
        xDest,
        yDest,
        cxDest,
        cyDest,
        dwRop,
        xSrc,
        ySrc,
        cxSrc,
        cySrc,
        iUsageSrc,
        lpBitmapInfo,
        cbBmiSrc,
        lpBits,
        cbBitsSrc ) ;
    return(b) ;
}

/**************************************************************************
* Handler - SetDIBitsToDevice
*************************************************************************/
BOOL bHandleSetDIBitsToDevice(PVOID pVoid, PLOCALDC pLocalDC)
{
    PEMRSETDIBITSTODEVICE pMfSetDIBitsToDevice ;

    BOOL    b ;
    LONG    xDest ;
    LONG    yDest ;
    LONG    xSrc ;
    LONG    ySrc ;
    LONG    cxSrc ;
    LONG    cySrc ;
    DWORD   offBmiSrc ;
    DWORD   cbBmiSrc ;
    DWORD   offBitsSrc ;
    DWORD   cbBitsSrc ;
    DWORD   iUsageSrc ;
    DWORD   iStartScan ;
    DWORD   cScans ;

    LPBITMAPINFO    lpBitmapInfo ;
    LPBYTE          lpBits ;

    pMfSetDIBitsToDevice = (PEMRSETDIBITSTODEVICE) pVoid ;

    xDest       = pMfSetDIBitsToDevice->xDest ;
    yDest       = pMfSetDIBitsToDevice->yDest ;
    xSrc        = pMfSetDIBitsToDevice->xSrc ;
    ySrc        = pMfSetDIBitsToDevice->ySrc ;
    cxSrc       = pMfSetDIBitsToDevice->cxSrc ;
    cySrc       = pMfSetDIBitsToDevice->cySrc ;
    offBmiSrc   = pMfSetDIBitsToDevice->offBmiSrc ;
    cbBmiSrc    = pMfSetDIBitsToDevice->cbBmiSrc ;
    offBitsSrc  = pMfSetDIBitsToDevice->offBitsSrc ;
    cbBitsSrc   = pMfSetDIBitsToDevice->cbBitsSrc ;
    iUsageSrc   = pMfSetDIBitsToDevice->iUsageSrc ;
    iStartScan  = pMfSetDIBitsToDevice->iStartScan ;
    cScans      = pMfSetDIBitsToDevice->cScans ;

    lpBitmapInfo = (LPBITMAPINFO) ((PBYTE) pMfSetDIBitsToDevice + offBmiSrc) ;
    lpBits = (PBYTE) pMfSetDIBitsToDevice + offBitsSrc ;

    b = DoSetDIBitsToDevice(pLocalDC,
        xDest,
        yDest,
        xSrc,
        ySrc,
        cxSrc,
        cySrc,
        iUsageSrc,
        iStartScan,
        cScans,
        lpBitmapInfo,
        cbBmiSrc,
        lpBits,
        cbBitsSrc ) ;

    return(b) ;
}


/**************************************************************************
* Handler - BitBlt
*************************************************************************/
BOOL bHandleBitBlt(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRBITBLT  pMfBitBlt ;
    LONG        xDest ;
    LONG        yDest ;
    LONG        cxDest ;
    LONG        cyDest ;
    DWORD       dwRop ;
    LONG        xSrc ;
    LONG        ySrc ;
    PXFORM      pxformSrc ;
    COLORREF    crBkColorSrc ;
    DWORD       iUsageSrc ;
    DWORD       offBmiSrc ;
    DWORD       cbBmiSrc ;
    DWORD       offBitsSrc ;
    DWORD       cbBitsSrc ;
    PBITMAPINFO pbmi ;
    LPBYTE      lpBits ;

    pMfBitBlt = (PEMRBITBLT) pVoid ;

    xDest        = pMfBitBlt->xDest ;
    yDest        = pMfBitBlt->yDest ;
    cxDest       = pMfBitBlt->cxDest ;
    cyDest       = pMfBitBlt->cyDest ;
    dwRop        = pMfBitBlt->dwRop ;
    xSrc         = pMfBitBlt->xSrc ;
    ySrc         = pMfBitBlt->ySrc ;
    pxformSrc    =&(pMfBitBlt->xformSrc) ;
    crBkColorSrc = pMfBitBlt->crBkColorSrc ;        // not used

    iUsageSrc    = pMfBitBlt->iUsageSrc ;
    offBmiSrc    = pMfBitBlt->offBmiSrc ;
    cbBmiSrc     = pMfBitBlt->cbBmiSrc ;
    offBitsSrc   = pMfBitBlt->offBitsSrc ;
    cbBitsSrc    = pMfBitBlt->cbBitsSrc ;

    lpBits = (PBYTE) pMfBitBlt + offBitsSrc ;
    pbmi   = (PBITMAPINFO) ((PBYTE) pMfBitBlt + offBmiSrc) ;

    b = DoStretchBlt(pLocalDC,
        xDest,
        yDest,
        cxDest,
        cyDest,
        dwRop,
        xSrc,
        ySrc,
        cxDest,
        cyDest,
        pxformSrc,
        iUsageSrc,
        pbmi,
        cbBmiSrc,
        lpBits,
        cbBitsSrc);
    return(b) ;
}


/**************************************************************************
* Handler - StretchBlt
*************************************************************************/
BOOL bHandleStretchBlt(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRSTRETCHBLT   pMfStretchBlt ;
    LONG        xDest ;
    LONG        yDest ;
    LONG        cxDest ;
    LONG        cyDest ;
    DWORD       dwRop ;
    LONG        xSrc ;
    LONG        ySrc ;
    LONG        cxSrc ;
    LONG        cySrc ;
    PXFORM      pxformSrc ;
    COLORREF    crBkColorSrc ;
    DWORD       iUsageSrc ;
    DWORD       offBmiSrc ;
    DWORD       cbBmiSrc ;
    DWORD       offBitsSrc ;
    DWORD       cbBitsSrc ;
    PBITMAPINFO pbmi ;
    LPBYTE      lpBits ;

    pMfStretchBlt = (PEMRSTRETCHBLT) pVoid ;

    xDest          = pMfStretchBlt->xDest ;
    yDest          = pMfStretchBlt->yDest ;
    cxDest         = pMfStretchBlt->cxDest ;
    cyDest         = pMfStretchBlt->cyDest ;
    dwRop          = pMfStretchBlt->dwRop ;
    xSrc           = pMfStretchBlt->xSrc ;
    ySrc           = pMfStretchBlt->ySrc ;
    pxformSrc      =&(pMfStretchBlt->xformSrc) ;
    crBkColorSrc   = pMfStretchBlt->crBkColorSrc ;  // not used

    iUsageSrc      = pMfStretchBlt->iUsageSrc ;
    offBmiSrc      = pMfStretchBlt->offBmiSrc ;
    cbBmiSrc       = pMfStretchBlt->cbBmiSrc ;
    offBitsSrc     = pMfStretchBlt->offBitsSrc ;
    cbBitsSrc      = pMfStretchBlt->cbBitsSrc ;

    lpBits = (PBYTE) pMfStretchBlt + offBitsSrc ;
    pbmi   = (PBITMAPINFO) ((PBYTE) pMfStretchBlt + offBmiSrc) ;

    cxSrc          = pMfStretchBlt->cxSrc ;
    cySrc          = pMfStretchBlt->cySrc ;


    b = DoStretchBlt(pLocalDC,
        xDest,
        yDest,
        cxDest,
        cyDest,
        dwRop,
        xSrc,
        ySrc,
        cxSrc,
        cySrc,
        pxformSrc,
        iUsageSrc,
        pbmi,
        cbBmiSrc,
        lpBits,
        cbBitsSrc);
    return(b) ;
}


/**************************************************************************
* Handler - MaskBlt
*************************************************************************/
BOOL bHandleMaskBlt(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRMASKBLT  pMfMaskBlt ;
    LONG        xDest ;
    LONG        yDest ;
    LONG        cxDest ;
    LONG        cyDest ;
    DWORD       dwRop ;
    LONG        xSrc ;
    LONG        ySrc ;
    PXFORM      pxformSrc ;
    COLORREF    crBkColorSrc ;
    DWORD       iUsageSrc ;
    DWORD       offBmiSrc ;
    DWORD       cbBmiSrc ;
    DWORD       offBitsSrc ;
    DWORD       cbBitsSrc ;
    PBITMAPINFO pbmi ;
    LPBYTE      lpBits ;
    LONG        xMask ;
    LONG        yMask ;
    DWORD       iUsageMask ;
    DWORD       offBmiMask ;
    DWORD       cbBmiMask ;
    DWORD       offBitsMask ;
    DWORD       cbBitsMask ;
    PBITMAPINFO pbmiMask ;
    LPBYTE      lpMaskBits ;

    pMfMaskBlt   = (PEMRMASKBLT) pVoid ;

    xDest        = pMfMaskBlt->xDest ;
    yDest        = pMfMaskBlt->yDest ;
    cxDest       = pMfMaskBlt->cxDest ;
    cyDest       = pMfMaskBlt->cyDest ;
    dwRop        = pMfMaskBlt->dwRop ;
    xSrc         = pMfMaskBlt->xSrc ;
    ySrc         = pMfMaskBlt->ySrc ;
    pxformSrc    =&(pMfMaskBlt->xformSrc) ;
    crBkColorSrc = pMfMaskBlt->crBkColorSrc ;       // not used

    iUsageSrc    = pMfMaskBlt->iUsageSrc ;
    offBmiSrc    = pMfMaskBlt->offBmiSrc ;
    cbBmiSrc     = pMfMaskBlt->cbBmiSrc ;
    offBitsSrc   = pMfMaskBlt->offBitsSrc ;
    cbBitsSrc    = pMfMaskBlt->cbBitsSrc ;

    lpBits = (PBYTE) pMfMaskBlt + offBitsSrc ;
    pbmi   = (PBITMAPINFO) ((PBYTE) pMfMaskBlt + offBmiSrc) ;

    xMask        = pMfMaskBlt->xMask ;
    yMask        = pMfMaskBlt->yMask ;
    iUsageMask   = pMfMaskBlt->iUsageMask ;
    offBmiMask   = pMfMaskBlt->offBmiMask ;
    cbBmiMask    = pMfMaskBlt->cbBmiMask ;
    offBitsMask  = pMfMaskBlt->offBitsMask ;
    cbBitsMask   = pMfMaskBlt->cbBitsMask ;

    lpMaskBits = (PBYTE) pMfMaskBlt + offBitsMask ;
    pbmiMask   = (PBITMAPINFO) ((PBYTE) pMfMaskBlt + offBmiMask) ;

    b = DoMaskBlt(pLocalDC,
        xDest,
        yDest,
        cxDest,
        cyDest,
        dwRop,
        xSrc,
        ySrc,
        pxformSrc,
        iUsageSrc,
        pbmi,
        cbBmiSrc,
        lpBits,
        cbBitsSrc,
        xMask,
        yMask,
        iUsageMask,
        pbmiMask,
        cbBmiMask,
        lpMaskBits,
        cbBitsMask);

    return(b) ;
}


/**************************************************************************
* Handler - PlgBlt
*************************************************************************/
BOOL bHandlePlgBlt(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRPLGBLT   pMfPlgBlt ;
    PPOINTL     pptlDest ;
    LONG        xSrc ;
    LONG        ySrc ;
    LONG        cxSrc ;
    LONG        cySrc ;
    PXFORM      pxformSrc ;
    COLORREF    crBkColorSrc ;
    DWORD       iUsageSrc ;
    DWORD       offBmiSrc ;
    DWORD       cbBmiSrc ;
    DWORD       offBitsSrc ;
    DWORD       cbBitsSrc ;
    PBITMAPINFO pbmi ;
    LPBYTE      lpBits ;
    LONG        xMask ;
    LONG        yMask ;
    DWORD       iUsageMask ;
    DWORD       offBmiMask ;
    DWORD       cbBmiMask ;
    DWORD       offBitsMask ;
    DWORD       cbBitsMask ;
    PBITMAPINFO pbmiMask ;
    LPBYTE      lpMaskBits ;

    pMfPlgBlt    = (PEMRPLGBLT) pVoid ;

    pptlDest     = pMfPlgBlt->aptlDest ;
    xSrc         = pMfPlgBlt->xSrc ;
    ySrc         = pMfPlgBlt->ySrc ;
    cxSrc        = pMfPlgBlt->cxSrc ;
    cySrc        = pMfPlgBlt->cySrc ;
    pxformSrc    =&(pMfPlgBlt->xformSrc) ;
    crBkColorSrc = pMfPlgBlt->crBkColorSrc ;        // not used

    iUsageSrc    = pMfPlgBlt->iUsageSrc ;
    offBmiSrc    = pMfPlgBlt->offBmiSrc ;
    cbBmiSrc     = pMfPlgBlt->cbBmiSrc ;
    offBitsSrc   = pMfPlgBlt->offBitsSrc ;
    cbBitsSrc    = pMfPlgBlt->cbBitsSrc ;

    lpBits = (PBYTE) pMfPlgBlt + offBitsSrc ;
    pbmi   = (PBITMAPINFO) ((PBYTE) pMfPlgBlt + offBmiSrc) ;

    xMask        = pMfPlgBlt->xMask ;
    yMask        = pMfPlgBlt->yMask ;
    iUsageMask   = pMfPlgBlt->iUsageMask ;
    offBmiMask   = pMfPlgBlt->offBmiMask ;
    cbBmiMask    = pMfPlgBlt->cbBmiMask ;
    offBitsMask  = pMfPlgBlt->offBitsMask ;
    cbBitsMask   = pMfPlgBlt->cbBitsMask ;

    lpMaskBits = (PBYTE) pMfPlgBlt + offBitsMask ;
    pbmiMask   = (PBITMAPINFO) ((PBYTE) pMfPlgBlt + offBmiMask) ;

    b = DoPlgBlt(pLocalDC,
        pptlDest,
        xSrc,
        ySrc,
        cxSrc,
        cySrc,
        pxformSrc,
        iUsageSrc,
        pbmi,
        cbBmiSrc,
        lpBits,
        cbBitsSrc,
        xMask,
        yMask,
        iUsageMask,
        pbmiMask,
        cbBmiMask,
        lpMaskBits,
        cbBitsMask);

    return(b) ;
}


/**************************************************************************
* Handler - Save DC
*************************************************************************/
BOOL bHandleSaveDC(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;

    NOTUSED(pVoid) ;

    b = DoSaveDC(pLocalDC) ;

    return(b) ;
}


/**************************************************************************
* Handler - Restore DC
*************************************************************************/
BOOL bHandleRestoreDC(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL            b ;
    PEMRRESTOREDC   pMfRestoreDc ;
    INT             nSavedDC ;

    pMfRestoreDc = (PEMRRESTOREDC) pVoid ;

    nSavedDC = (INT) pMfRestoreDc->iRelative ;

    b = DoRestoreDC(pLocalDC, nSavedDC) ;

    return(b) ;
}


/**************************************************************************
* Handler - End of File
*************************************************************************/
BOOL bHandleEOF(PVOID pVoid, PLOCALDC pLocalDC)
{

    NOTUSED(pVoid) ;

    DoEOF(pLocalDC) ;

    return (TRUE) ;
}

/**************************************************************************
* Handler - Header
*************************************************************************/
BOOL bHandleHeader(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PENHMETAHEADER pemfheader ;

    pemfheader = (PENHMETAHEADER) pVoid ;

    b = DoHeader(pLocalDC, pemfheader) ;

    return (b) ;
}

/**************************************************************************
* Handler - ScaleWindowExtEx
*************************************************************************/
BOOL bHandleScaleWindowExt(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRSCALEWINDOWEXTEX pMfScaleWindowExt ;
    INT     Xnum,
        Xdenom,
        Ynum,
        Ydenom ;


    pMfScaleWindowExt = (PEMRSCALEWINDOWEXTEX) pVoid ;

    // Scale the MapMode Mode

    Xnum   = (INT) pMfScaleWindowExt->xNum ;
    Xdenom = (INT) pMfScaleWindowExt->xDenom ;
    Ynum   = (INT) pMfScaleWindowExt->yNum ;
    Ydenom = (INT) pMfScaleWindowExt->yDenom ;

    // Do the translation.

    b = DoScaleWindowExt(pLocalDC, Xnum, Xdenom, Ynum, Ydenom) ;

    return (b) ;
}


/**************************************************************************
* Handler - ScaleViewportExtEx
*************************************************************************/
BOOL bHandleScaleViewportExt(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRSCALEVIEWPORTEXTEX pMfScaleViewportExt ;
    INT     Xnum,
        Xdenom,
        Ynum,
        Ydenom ;


    pMfScaleViewportExt = (PEMRSCALEVIEWPORTEXTEX) pVoid ;

    // Scale the MapMode Mode

    Xnum   = (INT) pMfScaleViewportExt->xNum ;
    Xdenom = (INT) pMfScaleViewportExt->xDenom ;
    Ynum   = (INT) pMfScaleViewportExt->yNum ;
    Ydenom = (INT) pMfScaleViewportExt->yDenom ;

    // Do the translation.

    b = DoScaleViewportExt(pLocalDC, Xnum, Xdenom, Ynum, Ydenom) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetViewportExtEx
*************************************************************************/
BOOL bHandleSetViewportExt(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRSETVIEWPORTEXTEX pMfSetViewportExt ;
    LONG    x, y ;

    pMfSetViewportExt = (PEMRSETVIEWPORTEXTEX) pVoid ;

    // Set the MapMode Mode

    x = pMfSetViewportExt->szlExtent.cx ;
    y = pMfSetViewportExt->szlExtent.cy ;

    // Do the translation.

    b = DoSetViewportExt(pLocalDC, (INT) x, (INT) y) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetViewportOrgEx
*************************************************************************/
BOOL bHandleSetViewportOrg(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRSETVIEWPORTORGEX pMfSetViewportOrg ;
    LONG    x, y ;

    pMfSetViewportOrg = (PEMRSETVIEWPORTORGEX) pVoid ;

    // Set the MapMode Mode

    x = pMfSetViewportOrg->ptlOrigin.x ;
    y = pMfSetViewportOrg->ptlOrigin.y ;

    // Do the translation.

    b = DoSetViewportOrg(pLocalDC, (INT) x, (INT) y) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetWindowExtEx
*************************************************************************/
BOOL bHandleSetWindowExt(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRSETWINDOWEXTEX pMfSetWindowExt ;
    LONG    x, y ;

    pMfSetWindowExt = (PEMRSETWINDOWEXTEX) pVoid ;

    // Set the MapMode Mode

    x = pMfSetWindowExt->szlExtent.cx ;
    y = pMfSetWindowExt->szlExtent.cy ;

    // Do the translation.

    b = DoSetWindowExt(pLocalDC, (INT) x, (INT) y) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetWindowOrgEx
*************************************************************************/
BOOL bHandleSetWindowOrg(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRSETWINDOWORGEX pMfSetWindowOrg ;
    LONG    x, y ;

    pMfSetWindowOrg = (PEMRSETWINDOWORGEX) pVoid ;

    // Set the MapMode Mode

    x = pMfSetWindowOrg->ptlOrigin.x ;
    y = pMfSetWindowOrg->ptlOrigin.y ;

    // Do the translation.

    b = DoSetWindowOrg(pLocalDC, (INT) x, (INT) y) ;

    return (b) ;
}

/**************************************************************************
* Handler - SetMapMode
*************************************************************************/
BOOL bHandleSetMapMode(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    DWORD   iMapMode ;
    PEMRSETMAPMODE pMfSetMapMode ;

    pMfSetMapMode = (PEMRSETMAPMODE) pVoid ;

    // Set the MapMode Mode

    iMapMode = pMfSetMapMode->iMode ;

    // Do the translation.

    b = DoSetMapMode(pLocalDC, iMapMode) ;

    return (b) ;

}

/**************************************************************************
* Handler - SetArcDirection
*************************************************************************/
BOOL bHandleSetArcDirection(PVOID pVoid, PLOCALDC pLocalDC)
{
    PEMRSETARCDIRECTION pMfSetArcDirection ;
    INT             iArcDirection ;
    BOOL            b ;


    pMfSetArcDirection = (PEMRSETARCDIRECTION) pVoid ;

    iArcDirection = (INT) pMfSetArcDirection->iArcDirection ;

    b = DoSetArcDirection(pLocalDC, iArcDirection) ;

    return (b) ;
}


/**************************************************************************
* Handler - AngleArc
*************************************************************************/
BOOL bHandleAngleArc(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRANGLEARC  pMfAngleArc ;
    int     x, y;
    DWORD   nRadius ;
    FLOAT   eStartAngle,
        eSweepAngle ;

    pMfAngleArc = (PEMRANGLEARC) pVoid ;

    // Set the Arc center

    x  = (int) pMfAngleArc->ptlCenter.x ;
    y  = (int) pMfAngleArc->ptlCenter.y ;

    // Get the radius of the Arc

    nRadius = (INT) pMfAngleArc->nRadius ;

    // Set the start & sweep angles

    eStartAngle = pMfAngleArc->eStartAngle ;
    eSweepAngle = pMfAngleArc->eSweepAngle ;

    b = DoAngleArc(pLocalDC, x, y, nRadius, eStartAngle, eSweepAngle) ;

    return (b) ;
}


/**************************************************************************
* Handler - ArcTo
*************************************************************************/
BOOL bHandleArcTo(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRARCTO  pMfArcTo ;
    INT     x1, x2, x3, x4,
        y1, y2, y3, y4 ;

    pMfArcTo = (PEMRARCTO) pVoid ;

    // Set up the ellipse box, this will be the same as the bounding
    // rectangle.

    x1 = (INT) pMfArcTo->rclBox.left ;
    y1 = (INT) pMfArcTo->rclBox.top ;
    x2 = (INT) pMfArcTo->rclBox.right ;
    y2 = (INT) pMfArcTo->rclBox.bottom ;

    // Set the start point.

    x3 = (INT) pMfArcTo->ptlStart.x ;
    y3 = (INT) pMfArcTo->ptlStart.y ;

    // Set the end point.

    x4 = (INT) pMfArcTo->ptlEnd.x ;
    y4 = (INT) pMfArcTo->ptlEnd.y ;

    b = DoArcTo(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;

    return (b) ;
}


/**************************************************************************
* Handler - Arc
*************************************************************************/
BOOL bHandleArc(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRARC  pMfArc ;
    INT     x1, x2, x3, x4,
        y1, y2, y3, y4 ;

    pMfArc = (PEMRARC) pVoid ;

    // Set up the ellipse box, this will be the same as the bounding
    // rectangle.

    x1 = (INT) pMfArc->rclBox.left ;
    y1 = (INT) pMfArc->rclBox.top ;
    x2 = (INT) pMfArc->rclBox.right ;
    y2 = (INT) pMfArc->rclBox.bottom ;

    // Set the start point.

    x3 = (INT) pMfArc->ptlStart.x ;
    y3 = (INT) pMfArc->ptlStart.y ;

    // Set the end point.

    x4 = (INT) pMfArc->ptlEnd.x ;
    y4 = (INT) pMfArc->ptlEnd.y ;

    b = DoArc(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;

    return (b) ;
}


/**************************************************************************
* Handler - Ellipse
*************************************************************************/
BOOL bHandleEllipse(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    INT     x1, y1, x2, y2 ;
    PEMRELLIPSE  pMfEllipse ;

    pMfEllipse = (PEMRELLIPSE) pVoid ;

    // Set up the ellipse box, this will be the same as the bounding
    // rectangle.

    x1 = (INT) pMfEllipse->rclBox.left ;
    y1 = (INT) pMfEllipse->rclBox.top ;
    x2 = (INT) pMfEllipse->rclBox.right ;
    y2 = (INT) pMfEllipse->rclBox.bottom ;

    // Do the Ellipse translation.

    b = DoEllipse(pLocalDC, x1, y1, x2, y2) ;

    return (b) ;
}


/**************************************************************************
* Handler - SelectObject
*************************************************************************/
BOOL bHandleSelectObject(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRSELECTOBJECT pMfSelectObject ;
    INT     ihObject ;

    pMfSelectObject = (PEMRSELECTOBJECT) pVoid ;

    // Get the Object (it's really a Long)

    ihObject = (INT) pMfSelectObject->ihObject ;

    // Do the translation

    b = DoSelectObject(pLocalDC, ihObject) ;

    return (b) ;
}


/**************************************************************************
* Handler - DeleteObject
*************************************************************************/
BOOL bHandleDeleteObject(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRDELETEOBJECT pMfDeleteObject ;
    INT     ihObject ;


    pMfDeleteObject = (PEMRDELETEOBJECT) pVoid ;
    ihObject = (INT) pMfDeleteObject->ihObject ;
    b = DoDeleteObject(pLocalDC, ihObject) ;

    return(b) ;
}


/**************************************************************************
* Handler - CreateBrushIndirect
*************************************************************************/
BOOL bHandleCreateBrushIndirect(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRCREATEBRUSHINDIRECT  pMfCreateBrushIndirect ;
    LOGBRUSH LogBrush ;
    INT     ihBrush ;

    pMfCreateBrushIndirect = (PEMRCREATEBRUSHINDIRECT) pVoid ;

    // Get the Brush parameters.

    LogBrush.lbStyle = pMfCreateBrushIndirect->lb.lbStyle;
    LogBrush.lbColor = pMfCreateBrushIndirect->lb.lbColor;
    LogBrush.lbHatch = (ULONG_PTR)pMfCreateBrushIndirect->lb.lbHatch;

    ihBrush   = pMfCreateBrushIndirect->ihBrush ;

    // Do the translation.

    b = DoCreateBrushIndirect(pLocalDC, ihBrush, &LogBrush) ;

    return (b) ;
}

/**************************************************************************
* Handler - CreateMonoBrush
*************************************************************************/
BOOL bHandleCreateMonoBrush(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRCREATEMONOBRUSH  pMfCreateMonoBrush ;
    DWORD   ihBrush ;
    DWORD   iUsage ;
    DWORD   offBmi ;
    DWORD   cbBmi ;
    DWORD   offBits ;
    DWORD   cbBits ;

    PBITMAPINFO pBmi ;
    PBYTE       pBits ;

    pMfCreateMonoBrush = (PEMRCREATEMONOBRUSH) pVoid ;

    ihBrush     =    pMfCreateMonoBrush->ihBrush ;
    iUsage      =    pMfCreateMonoBrush->iUsage ;
    offBmi      =    pMfCreateMonoBrush->offBmi ;
    cbBmi       =    pMfCreateMonoBrush->cbBmi ;
    offBits     =    pMfCreateMonoBrush->offBits ;
    cbBits      =    pMfCreateMonoBrush->cbBits ;

    pBmi        = (PBITMAPINFO) ((PBYTE) pVoid + offBmi) ;
    pBits       = (PBYTE) pVoid + offBits ;

    b = DoCreateMonoBrush(pLocalDC, ihBrush,
        pBmi, cbBmi,
        pBits, cbBits,
        iUsage) ;
    return (b) ;
}

/**************************************************************************
* Handler - CreateDIBPatternBrush
*************************************************************************/
BOOL bHandleCreateDIBPatternBrush(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRCREATEDIBPATTERNBRUSHPT  pMfCreateDIBPatternBrush ;
    DWORD   ihBrush ;
    DWORD   iUsage ;
    DWORD   offBmi ;
    DWORD   cbBmi ;
    DWORD   offBits ;
    DWORD   cbBits ;

    PBITMAPINFO pBmi ;
    PBYTE       pBits ;

    pMfCreateDIBPatternBrush = (PEMRCREATEDIBPATTERNBRUSHPT) pVoid ;

    ihBrush     =    pMfCreateDIBPatternBrush->ihBrush ;
    iUsage      =    pMfCreateDIBPatternBrush->iUsage ;
    offBmi      =    pMfCreateDIBPatternBrush->offBmi ;
    cbBmi       =    pMfCreateDIBPatternBrush->cbBmi ;
    offBits     =    pMfCreateDIBPatternBrush->offBits ;
    cbBits      =    pMfCreateDIBPatternBrush->cbBits ;

    pBmi        = (PBITMAPINFO) ((PBYTE) pVoid + offBmi) ;
    pBits       = (PBYTE) pVoid + offBits ;

    b = DoCreateDIBPatternBrush(pLocalDC, ihBrush,
        pBmi, cbBmi,
        pBits, cbBits,
        iUsage) ;
    return (b) ;
}


/**************************************************************************
* Handler - CreatePen
*************************************************************************/
BOOL bHandleCreatePen(PVOID pVoid, PLOCALDC pLocalDC)
{
    PEMRCREATEPEN pMfCreatePen ;
    INT          ihPen ;
    PLOGPEN      pLogPen ;
    BOOL         b ;

    pMfCreatePen = (PEMRCREATEPEN) pVoid ;

    ihPen   = pMfCreatePen->ihPen ;
    pLogPen = &pMfCreatePen->lopn ;

    b = DoCreatePen(pLocalDC, ihPen, pLogPen) ;

    return(b) ;
}


/**************************************************************************
* Handler - ExtCreatePen
*************************************************************************/
BOOL bHandleExtCreatePen(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMREXTCREATEPEN     pMfExtCreatePen ;
    PEXTLOGPEN          pExtLogPen ;
    INT                 ihPen ;

    pMfExtCreatePen = (PEMREXTCREATEPEN) pVoid ;

    pExtLogPen = &pMfExtCreatePen->elp ;
    ihPen      = pMfExtCreatePen->ihPen ;

    b = DoExtCreatePen(pLocalDC, ihPen, pExtLogPen) ;

    return (b) ;
}


/**************************************************************************
* Handler - MoveToEx
*************************************************************************/
BOOL bHandleMoveTo(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRMOVETOEX pMfMoveTo ;
    INT     x, y ;

    pMfMoveTo = (PEMRMOVETOEX) pVoid ;

    // Get the position.

    x = (INT) pMfMoveTo->ptl.x ;
    y = (INT) pMfMoveTo->ptl.y ;

    // Do the translation.

    b = DoMoveTo(pLocalDC, x, y) ;

    return (b) ;
}


/**************************************************************************
* Handler - LineTo
*************************************************************************/
BOOL bHandleLineTo(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRLINETO   pMfLineTo ;
    INT     x, y ;

    pMfLineTo = (PEMRLINETO) pVoid ;

    // Get the new point.

    x = (INT) pMfLineTo->ptl.x ;
    y = (INT) pMfLineTo->ptl.y ;

    // Do the translation.

    b = DoLineTo(pLocalDC, x, y) ;

    return (b) ;
}


/**************************************************************************
* Handler - Chord
*************************************************************************/
BOOL bHandleChord(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRCHORD  pMfChord ;
    INT     x1, x2, x3, x4,
        y1, y2, y3, y4 ;

    pMfChord = (PEMRCHORD) pVoid ;

    // Set the rectangle

    x1 = (INT) pMfChord->rclBox.left   ;
    y1 = (INT) pMfChord->rclBox.top    ;
    x2 = (INT) pMfChord->rclBox.right  ;
    y2 = (INT) pMfChord->rclBox.bottom ;

    // Set the start point.

    x3 = (INT) pMfChord->ptlStart.x ;
    y3 = (INT) pMfChord->ptlStart.y ;

    // Set the end point.

    x4 = (INT) pMfChord->ptlEnd.x ;
    y4 = (INT) pMfChord->ptlEnd.y ;

    // Do the translation

    b = DoChord(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;

    return (b) ;
}


/**************************************************************************
* Handler - Pie
*************************************************************************/
BOOL bHandlePie(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRPIE  pMfPie ;
    INT     x1, x2, x3, x4,
        y1, y2, y3, y4 ;

    pMfPie = (PEMRPIE) pVoid ;

    // Set up the ellipse box

    x1 = (INT) pMfPie->rclBox.left   ;
    y1 = (INT) pMfPie->rclBox.top    ;
    x2 = (INT) pMfPie->rclBox.right  ;
    y2 = (INT) pMfPie->rclBox.bottom ;

    // Set the start point.

    x3 = (INT) pMfPie->ptlStart.x ;
    y3 = (INT) pMfPie->ptlStart.y ;

    // Set the end point.

    x4 = (INT) pMfPie->ptlEnd.x ;
    y4 = (INT) pMfPie->ptlEnd.y ;

    // Do the Pie translation.

    b = DoPie(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;

    return (b) ;
}


/**************************************************************************
* Handler - Polyline
*************************************************************************/
BOOL bHandlePolyline(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRPOLYLINE pMfPolyline ;
    INT     nCount ;
    PPOINTL pptl ;

    pMfPolyline = (PEMRPOLYLINE) pVoid ;

    // Copy the line count and the polyline verticies to
    // the record.

    nCount = (INT) pMfPolyline->cptl ;
    pptl = pMfPolyline->aptl ;

    // Now do the translation.

    b = DoPoly(pLocalDC, pptl, nCount, EMR_POLYLINE, TRUE) ;

    return (b) ;
}


/**************************************************************************
* Handler - PolylineTo
*************************************************************************/
BOOL bHandlePolylineTo (PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRPOLYLINETO pMfPolylineTo ;
    INT     nCount ;
    PPOINTL pptl ;

    pMfPolylineTo = (PEMRPOLYLINETO) pVoid ;

    // Copy the line count and the polyline verticies to
    // the record.

    nCount = (INT) pMfPolylineTo->cptl ;
    pptl = pMfPolylineTo->aptl ;

    // Now do the translation.

    b = DoPolylineTo(pLocalDC, pptl, nCount) ;

    return (b) ;
}


/**************************************************************************
* Handler - PolyBezier16,Polygon16,Polyline16,PolyBezierTo16,PolylineTo16
*           PolyDraw16
*************************************************************************/
BOOL bHandlePoly16 (PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b = FALSE;
    PEMRPOLYLINE16 pMfPoly16 ;  // common structure for the poly16 records
    PEMRPOLYDRAW16 pMfPolyDraw16 ;
    POINTL      aptl[MAX_STACK_POINTL];
    PPOINTL     pptl ;
    INT         nCount ;
    PBYTE       pb ;

    // PolyDraw16 contains the structure of Poly16 followed by the byte array.

    pMfPoly16 = (PEMRPOLYLINE16) pVoid ;

    nCount = (INT) pMfPoly16->cpts ;

    if (nCount <= MAX_STACK_POINTL)
        pptl = aptl;
    else if (!(pptl = (PPOINTL) LocalAlloc(LMEM_FIXED, nCount * sizeof(POINTL))))
        return(b);

    POINTS_TO_POINTL(pptl, pMfPoly16->apts, (DWORD) nCount);

    // Now do the translation.

    switch (pMfPoly16->emr.iType)
    {
    case EMR_POLYBEZIER16:
        b = DoPolyBezier(pLocalDC, (LPPOINT) pptl, nCount) ;
        break;

    case EMR_POLYGON16:
        b = DoPoly(pLocalDC, pptl, nCount, EMR_POLYGON, TRUE) ;
        break;

    case EMR_POLYLINE16:
        b = DoPoly(pLocalDC, pptl, nCount, EMR_POLYLINE, TRUE) ;
        break;

    case EMR_POLYBEZIERTO16:
        b = DoPolyBezierTo(pLocalDC, (LPPOINT) pptl, nCount) ;
        break;

    case EMR_POLYLINETO16:
        b = DoPolylineTo(pLocalDC, pptl, nCount) ;
        break;

    case EMR_POLYDRAW16:
        if (pfnSetVirtualResolution != NULL)
        {
            pMfPolyDraw16 = (PEMRPOLYDRAW16) pVoid ;
            pb = (PBYTE) &pMfPolyDraw16->apts[nCount];
            b = DoPolyDraw(pLocalDC, (LPPOINT) pptl, pb, nCount);
            break;
        }
        // Fall through for win9x

    default:
        ASSERTGDI(FALSE, "Bad record type");
        break;
    }

    if (nCount > MAX_STACK_POINTL)
        if (LocalFree(pptl))
            ASSERTGDI(FALSE, "bHandlePoly16: LocalFree failed");

        return (b) ;
}


/**************************************************************************
* Handler - PolyPolyline
*************************************************************************/
BOOL bHandlePolyPolyline(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRPOLYPOLYLINE pMfPolyPolyline ;
    PDWORD  pPolyCount ;
    PPOINTL pptl ;
    INT     nPolys ;

    pMfPolyPolyline = (PEMRPOLYPOLYLINE) pVoid ;

    // Copy the  Polycount count, the polycount array
    // and the polyline verticies to
    // the record.

    nPolys = (INT) pMfPolyPolyline->nPolys ;
    pPolyCount = pMfPolyPolyline->aPolyCounts ;
    pptl = (PPOINTL) &pMfPolyPolyline->aPolyCounts[nPolys] ;

    // Now do the translation.

    b = DoPolyPolyline(pLocalDC, pptl, pPolyCount, nPolys, TRUE) ;

    return (b) ;
}


/**************************************************************************
* Handler - PolyPolyline16,PolyPolygon16
*************************************************************************/
BOOL bHandlePolyPoly16 (PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b = FALSE;
    PEMRPOLYPOLYLINE16 pMfPolyPoly16 ;  // common structure for polypoly16 records
    PDWORD  pPolyCount ;
    POINTL  aptl[MAX_STACK_POINTL];
    PPOINTL pptl ;
    INT     nCount;
    DWORD   cpts ;

    pMfPolyPoly16 = (PEMRPOLYPOLYLINE16) pVoid ;

    nCount = (INT) pMfPolyPoly16->nPolys ;
    cpts   = pMfPolyPoly16->cpts;
    pPolyCount = pMfPolyPoly16->aPolyCounts ;

    if (cpts <= MAX_STACK_POINTL)
        pptl = aptl;
    else if (!(pptl = (PPOINTL) LocalAlloc(LMEM_FIXED, cpts * sizeof(POINTL))))
        return(b);

    POINTS_TO_POINTL(pptl, (PPOINTS) &pMfPolyPoly16->aPolyCounts[nCount], cpts);

    // Now do the translation.

    switch (pMfPolyPoly16->emr.iType)
    {
    case EMR_POLYPOLYLINE16:
        b = DoPolyPolyline(pLocalDC, pptl, pPolyCount, nCount, TRUE) ;
        break;
    case EMR_POLYPOLYGON16:
        b = DoPolyPolygon(pLocalDC, pptl, pPolyCount, cpts, nCount, TRUE) ;
        break;
    default:
        ASSERTGDI(FALSE, "Bad record type");
        break;
    }

    if (cpts > MAX_STACK_POINTL)
        if (LocalFree(pptl))
            ASSERTGDI(FALSE, "bHandlePolyPoly16: LocalFree failed");

        return (b) ;
}


/**************************************************************************
* Handler - Polygon
*************************************************************************/
BOOL bHandlePolygon (PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRPOLYGON pMfPolygon ;
    PPOINTL pptl ;
    INT     nCount ;

    pMfPolygon = (PEMRPOLYGON) pVoid ;

    // Copy the line count and the Polygon verticies to
    // the record.

    nCount = (INT) pMfPolygon->cptl ;
    pptl = pMfPolygon->aptl ;

    // Now do the translation.

    b = DoPoly(pLocalDC, pptl, nCount, EMR_POLYGON, TRUE) ;

    return (b) ;
}


/**************************************************************************
* Handler - PolyPolygon
*************************************************************************/
BOOL bHandlePolyPolygon(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRPOLYPOLYGON pMfPolyPolygon ;
    PDWORD  pPolyCount ;
    PPOINTL pptl ;
    DWORD   cptl ;
    INT     nPolys ;

    pMfPolyPolygon = (PEMRPOLYPOLYGON) pVoid ;

    // Copy the  Polycount count, the polycount array
    // and the polygon verticies to
    // the record.

    nPolys = (INT) pMfPolyPolygon->nPolys ;
    pPolyCount = pMfPolyPolygon->aPolyCounts ;
    pptl = (PPOINTL) &pMfPolyPolygon->aPolyCounts[nPolys] ;
    cptl = pMfPolyPolygon->cptl ;

    // Now do the translation.

    b = DoPolyPolygon(pLocalDC, pptl, pPolyCount, cptl, nPolys, TRUE) ;

    return (b) ;
}


/**************************************************************************
* Handler - Rectangle
*************************************************************************/
BOOL bHandleRectangle(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRRECTANGLE  pMfRectangle ;
    INT     x1, y1, x2, y2 ;

    pMfRectangle = (PEMRRECTANGLE) pVoid ;

    // Set up the Rectangle box, this will be the same as the bounding
    // rectangle.

    x1 = (INT) pMfRectangle->rclBox.left   ;
    y1 = (INT) pMfRectangle->rclBox.top    ;
    x2 = (INT) pMfRectangle->rclBox.right  ;
    y2 = (INT) pMfRectangle->rclBox.bottom ;

    // Do the Rectangle translation.

    b = DoRectangle(pLocalDC, x1, y1, x2, y2) ;

    return (b) ;
}


/**************************************************************************
* Handler - RoundRect
*************************************************************************/
BOOL bHandleRoundRect (PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRROUNDRECT  pMfRoundRect ;
    INT     x1, y1, x2, y2, x3, y3 ;

    pMfRoundRect = (PEMRROUNDRECT) pVoid ;

    // Set up the RoundRect box, this will be the same as the bounding
    // RoundRect.

    x1 = (INT) pMfRoundRect->rclBox.left   ;
    y1 = (INT) pMfRoundRect->rclBox.top    ;
    x2 = (INT) pMfRoundRect->rclBox.right  ;
    y2 = (INT) pMfRoundRect->rclBox.bottom ;
    x3 = (INT) pMfRoundRect->szlCorner.cx ;
    y3 = (INT) pMfRoundRect->szlCorner.cy ;

    // Do the RoundRect translation.

    b = DoRoundRect(pLocalDC, x1, y1, x2, y2, x3, y3) ;

    return (b) ;
}


/**************************************************************************
* Handler - ExtTextOut for both ANSI and UNICODE characters.
**************************************************************************/
BOOL bHandleExtTextOut(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMREXTTEXTOUTA  pMfExtTextOut ;    // same for both ansi and unicode
    INT     x, y, nCount ;
    DWORD   flOptions ;
    PRECTL  pRectl ;
    PLONG   pDx ;
    PWCH    pwchar ;
    DWORD   iGraphicsMode;

    pMfExtTextOut = (PEMREXTTEXTOUTA) pVoid ;

    ASSERTGDI(pMfExtTextOut->emr.iType == EMR_EXTTEXTOUTA
           || pMfExtTextOut->emr.iType == EMR_EXTTEXTOUTW,
           "MF3216: bHandleExtTextOut: bad record type");

    // Copy over the start position for the string.

    x = (INT) pMfExtTextOut->emrtext.ptlReference.x ;
    y = (INT) pMfExtTextOut->emrtext.ptlReference.y ;

    // Now copy over the Options flag, character count,
    // the clip/opaque rectangle, and the Ansi/Unicode string.

    flOptions = pMfExtTextOut->emrtext.fOptions  ;
    nCount    = (INT) pMfExtTextOut->emrtext.nChars ;
    pRectl    = &pMfExtTextOut->emrtext.rcl ;
    pwchar    = (PWCH) ((PBYTE) pMfExtTextOut + pMfExtTextOut->emrtext.offString);
    iGraphicsMode = pMfExtTextOut->iGraphicsMode;

    // Set up the spacing vector

    pDx = (PLONG) ((PBYTE) pMfExtTextOut + pMfExtTextOut->emrtext.offDx);

    // Now do the conversion.

    b = DoExtTextOut(pLocalDC, x, y, flOptions,
        pRectl, pwchar, nCount, pDx, iGraphicsMode,
        pMfExtTextOut->emr.iType);

    return (b) ;
}


/**************************************************************************
* Handler - PolyTextOut for both ANSI and UNICODE characters.
**************************************************************************/
BOOL bHandlePolyTextOut(PVOID pVoid, PLOCALDC pLocalDC)
{
    PEMRPOLYTEXTOUTA pMfPolyTextOut;    // same for both ansi and unicode
    PWCH    pwchar;
    LONG    i;
    DWORD   iType;
    LONG    cStrings;
    PEMRTEXT pemrtext;
    PLONG   pDx ;
    DWORD   iGraphicsMode;

    pMfPolyTextOut = (PEMRPOLYTEXTOUTA) pVoid ;

    ASSERTGDI(pMfPolyTextOut->emr.iType == EMR_POLYTEXTOUTA
           || pMfPolyTextOut->emr.iType == EMR_POLYTEXTOUTW,
           "MF3216: bHandlePolyTextOut: bad record type");

    iType  = pMfPolyTextOut->emr.iType == EMR_POLYTEXTOUTA
        ? EMR_EXTTEXTOUTA
        : EMR_EXTTEXTOUTW;
    cStrings = pMfPolyTextOut->cStrings;
    iGraphicsMode = pMfPolyTextOut->iGraphicsMode;

    // Convert to ExtTextOut

    for (i = 0; i < cStrings; i++)
    {
        pemrtext = &pMfPolyTextOut->aemrtext[i];
        pwchar = (PWCH) ((PBYTE) pMfPolyTextOut + pemrtext->offString);
        pDx    = (PLONG) ((PBYTE) pMfPolyTextOut + pemrtext->offDx);

        if (!DoExtTextOut(pLocalDC, pemrtext->ptlReference.x, pemrtext->ptlReference.y,
            pemrtext->fOptions, &pemrtext->rcl,
            pwchar, pemrtext->nChars, pDx, iGraphicsMode, iType))
            return(FALSE);
    }

    return(TRUE);
}


/**************************************************************************
* Handler - ExtCreateFont
*************************************************************************/
BOOL bHandleExtCreateFont(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b;
    PEMREXTCREATEFONTINDIRECTW pMfExtCreateFontW;
    LOGFONTA  lfa = {0};
    INT       ihFont;
    int       iRet = 0;

    pMfExtCreateFontW = (PEMREXTCREATEFONTINDIRECTW) pVoid ;

    // Get the font parameters.

    ihFont               = (INT) pMfExtCreateFontW->ihFont ;
    lfa.lfHeight         = pMfExtCreateFontW->elfw.elfLogFont.lfHeight;
    lfa.lfWidth          = pMfExtCreateFontW->elfw.elfLogFont.lfWidth;
    lfa.lfEscapement     = pMfExtCreateFontW->elfw.elfLogFont.lfEscapement;
    lfa.lfOrientation    = pMfExtCreateFontW->elfw.elfLogFont.lfOrientation;
    lfa.lfWeight         = pMfExtCreateFontW->elfw.elfLogFont.lfWeight;
    lfa.lfItalic         = pMfExtCreateFontW->elfw.elfLogFont.lfItalic;
    lfa.lfUnderline      = pMfExtCreateFontW->elfw.elfLogFont.lfUnderline;
    lfa.lfStrikeOut      = pMfExtCreateFontW->elfw.elfLogFont.lfStrikeOut;
    lfa.lfCharSet        = pMfExtCreateFontW->elfw.elfLogFont.lfCharSet;
    lfa.lfOutPrecision   = pMfExtCreateFontW->elfw.elfLogFont.lfOutPrecision;
    lfa.lfClipPrecision  = pMfExtCreateFontW->elfw.elfLogFont.lfClipPrecision;
    lfa.lfQuality        = pMfExtCreateFontW->elfw.elfLogFont.lfQuality;
    lfa.lfPitchAndFamily = pMfExtCreateFontW->elfw.elfLogFont.lfPitchAndFamily;

    iRet = WideCharToMultiByte(CP_ACP,
                        0,
                        pMfExtCreateFontW->elfw.elfLogFont.lfFaceName,
                        -1,
                        lfa.lfFaceName,
                        sizeof(lfa.lfFaceName),
                        NULL, NULL);
    if (iRet == 0)
    {
        ASSERTGDI(FALSE, "WideCharToMultByte failed to convert lfFaceName");
        return FALSE;
    }

    // Do the translation.

    b = DoExtCreateFont(pLocalDC, ihFont, &lfa);

    return (b) ;
}


/**************************************************************************
* Handler - SetBkColor
*************************************************************************/
BOOL bHandleSetBkColor(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRSETBKCOLOR pMfSetBkColor ;

    pMfSetBkColor = (PEMRSETBKCOLOR) pVoid ;

    // Do the translation.

    b = DoSetBkColor(pLocalDC, pMfSetBkColor->crColor) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetBkMode
*************************************************************************/
BOOL bHandleSetBkMode(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    DWORD   iBkMode ;
    PEMRSETBKMODE pMfSetBkMode ;

    pMfSetBkMode = (PEMRSETBKMODE) pVoid ;

    // Set the Background Mode variable

    iBkMode = pMfSetBkMode->iMode ;

    // Do the translation.

    b = DoSetBkMode(pLocalDC, iBkMode) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetMapperFlags
*************************************************************************/
BOOL bHandleSetMapperFlags(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    DWORD   f ;
    PEMRSETMAPPERFLAGS pMfSetMapperFlags ;

    pMfSetMapperFlags = (PEMRSETMAPPERFLAGS) pVoid ;

    f = pMfSetMapperFlags->dwFlags ;

    // Do the translation.

    b = DoSetMapperFlags(pLocalDC, f) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetPolyFillMode
*************************************************************************/
BOOL bHandleSetPolyFillMode(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    INT     iPolyFillMode ;
    PEMRSETPOLYFILLMODE pMfSetPolyFillMode ;

    pMfSetPolyFillMode = (PEMRSETPOLYFILLMODE) pVoid ;

    // Set the PolyFill Mode

    iPolyFillMode = (INT) pMfSetPolyFillMode->iMode ;

    // Do the translation.

    b = DoSetPolyFillMode(pLocalDC, iPolyFillMode) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetRop2
*************************************************************************/
BOOL bHandleSetRop2(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    DWORD   iDrawMode ;
    PEMRSETROP2 pMfSetROP2 ;

    pMfSetROP2 = (PEMRSETROP2) pVoid ;

    // Set the Draw Mode

    iDrawMode = pMfSetROP2->iMode ;

    // Do the translation.

    b = DoSetRop2(pLocalDC, iDrawMode) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetStretchBltMode
*************************************************************************/
BOOL bHandleSetStretchBltMode(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    DWORD   iStretchMode ;
    PEMRSETSTRETCHBLTMODE pMfSetStretchBltMode ;

    pMfSetStretchBltMode = (PEMRSETSTRETCHBLTMODE) pVoid ;

    // Set the StretchBlt Mode

    iStretchMode = pMfSetStretchBltMode->iMode ;

    // Do the translation.

    b = DoSetStretchBltMode(pLocalDC, iStretchMode) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetTextAlign
*************************************************************************/
BOOL bHandleSetTextAlign(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    DWORD   fMode ;
    PEMRSETTEXTALIGN pMfSetTextAlign ;

    pMfSetTextAlign = (PEMRSETTEXTALIGN) pVoid ;

    // Set the TextAlign Mode

    fMode = pMfSetTextAlign->iMode ;

    // Do the translation.

    b = DoSetTextAlign(pLocalDC, fMode) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetTextColor
*************************************************************************/
BOOL bHandleSetTextColor(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRSETTEXTCOLOR pMfSetTextColor ;

    pMfSetTextColor = (PEMRSETTEXTCOLOR) pVoid ;

    // Do the translation.

    b = DoSetTextColor(pLocalDC, pMfSetTextColor->crColor) ;

    return (b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\gdippathflatten.cpp ===
extern "C"
{
#include "precomp.h"
}
#include "wtypes.h"
#include "objbase.h"
#include "gdiplus.h"


extern "C" BOOL bInvertxform(PXFORM pxformSrc, PXFORM pxformDest);
extern "C" BOOL bXformWorkhorse(PPOINTL aptl, DWORD nCount, PXFORM pXform);

using namespace Gdiplus;

inline REAL
GetDistance(
    GpPointF &      p1,
    GpPointF &      p2
    )
{
    double      dx = (double)p2.X - p1.X;
    double      dy = (double)p2.Y - p1.Y;

    return (REAL)sqrt((dx * dx) + (dy * dy));
}

// Flatten a path using GDI+ and transform the points before hand so we flatten
// the points that will go in the metafile. We allocate one buffer that will
// contain the points and types. The caller has to free that buffer
extern "C" BOOL GdipFlattenGdiPath(PLOCALDC pLocalDC,
                                   LPVOID   *buffer,
                                   INT      *count)
{
    BOOL    b = FALSE;
    INT     i ;
    INT     cpt;
    PBYTE   pb = NULL;
    PointF* pptf;
    LPPOINT ppt;
    PBYTE   pjType;
    INT     flattenCount;
    PBYTE   flattenpb = NULL;
    PointF* flattenPoints;
    PBYTE   flattenTypes;
    PBYTE   returnpb = NULL;

    ASSERT(buffer != NULL && *buffer == NULL && count != NULL);

    // Get the path data.

    // First get a count of the number of points.

    cpt = GetPath(pLocalDC->hdcHelper, (LPPOINT) NULL, (LPBYTE) NULL, 0);
    if (cpt == -1)
    {
        RIPS("MF3216: DoFlattenPath, GetPath failed\n");
        goto exit_DoFlattenPath;
    }

    // Check for empty path.

    if (cpt == 0)
    {
        b = TRUE;
        goto exit_DoFlattenPath;
    }

    // Allocate memory for the path data.

    if (!(pb = (PBYTE) LocalAlloc
        (
        LMEM_FIXED,
        cpt * (sizeof(PointF) + sizeof(POINT) + sizeof(BYTE))
        )
        )
        )
    {
        RIPS("MF3216: DoFlattenPath, LocalAlloc failed\n");
        goto exit_DoFlattenPath;
    }

    // Order of assignment is important for dword alignment.

    pptf    = (PointF*) pb;
    ppt     = (LPPOINT) (pptf + cpt);
    pjType  = (LPBYTE)  (ppt + cpt);

    // Finally, get the path data.

    if (GetPath(pLocalDC->hdcHelper, ppt, pjType, cpt) != cpt)
    {
        RIPS("MF3216: DoFlattenPath, GetPath failed\n");
        goto exit_DoFlattenPath;
    }

    if (pfnSetVirtualResolution == NULL)
    {
        if (!bXformWorkhorse((PPOINTL) ppt, cpt, &pLocalDC->xformRDevToRWorld))
            goto exit_DoFlattenPath;
    }

    BYTE tempType;
    for (i = 0; i < cpt; i++)
    {
        pptf[i] = PointF((REAL) ppt[i].x, (REAL) ppt[i].y);
        switch (pjType[i] & ~PT_CLOSEFIGURE)
        {
        case PT_LINETO:
            tempType = PathPointTypeLine;
            break;

        case PT_MOVETO:
            tempType = PathPointTypeStart;
            break;

        case PT_BEZIERTO:
            tempType = PathPointTypeBezier;
            break;

        default:
            WARNING(("MF3216: There's something wrong with this path"));
            tempType = PathPointTypeLine;
            break;
        }
        if (pjType[i] & PT_CLOSEFIGURE)
        {
            tempType |= PathPointTypeCloseSubpath;
        }
        pjType[i] = tempType;
    }
    {

        XFORM* xform = &(pLocalDC->xformRWorldToPPage);
        Matrix matrix((REAL)xform->eM11, (REAL)xform->eM12, (REAL)xform->eM21,
                      (REAL)xform->eM22, (REAL)xform->eDx, (REAL)xform->eDy);
        GraphicsPath gdipPath (pptf,
                               pjType,
                               cpt);
        // This will transform the flattened point into the resolution of the
        // metafile, giving us the best resolution for playtime
        gdipPath.Flatten(&matrix, 1.0f/6.0f);
        flattenCount = gdipPath.GetPointCount();

        if (flattenCount < 0)
        {
            RIPS("MF3216: GDIP failed in flatting the path\n");
            goto exit_DoFlattenPath;
        }

        if (!(flattenpb = (PBYTE) LocalAlloc
            (
            LMEM_FIXED,
            flattenCount * (sizeof(PointF) + sizeof(BYTE))
            )
            )
            )
        {
            RIPS("MF3216: DoFlattenPath, LocalAlloc failed\n");
            goto exit_DoFlattenPath;
        }
        flattenPoints = (PointF*) flattenpb;
        flattenTypes  = (PBYTE) (flattenPoints + flattenCount);

        if (!(returnpb = (PBYTE) LocalAlloc
            (
            LMEM_FIXED,
            flattenCount * (sizeof(POINT) + sizeof(BYTE))
            )
            )
            )
        {
            RIPS("MF3216: DoFlattenPath, LocalAlloc failed\n");
            goto exit_DoFlattenPath;
        }
        ppt     = (LPPOINT) returnpb;
        pjType  = (PBYTE) (ppt + flattenCount);

        if (gdipPath.GetPathTypes(flattenTypes, flattenCount) != Ok)
        {
            RIPS("MF3216: DoFlattenPath, GetPathTypes failed\n");
            goto exit_DoFlattenPath;
        }

        if (gdipPath.GetPathPoints(flattenPoints, flattenCount) != Ok)
        {
            RIPS("MF3216: DoFlattenPath, GetPathPoints failed\n");
            goto exit_DoFlattenPath;
        }

        for (i = 0; i < flattenCount; i++)
        {
            ppt[i].x = (INT)(flattenPoints[i].X + 0.5f);
            ppt[i].y = (INT)(flattenPoints[i].Y + 0.5f);
            switch (flattenTypes[i] & ~PathPointTypeCloseSubpath)
            {
            case PathPointTypeLine:
                tempType = PT_LINETO;
                break;

            case PathPointTypeStart:
                tempType = PT_MOVETO;
                break;

                break;

            default:
                WARNING(("MF3216: There's something wrong with this path"));
                break;
            }
            if (flattenTypes[i] & PathPointTypeCloseSubpath)
            {
                tempType |= PT_CLOSEFIGURE;
            }
            pjType[i] = tempType;
        }
    }
    *buffer = returnpb;
    *count  = flattenCount;
    returnpb = NULL;
    b = TRUE;

exit_DoFlattenPath:

    // Cleanup any allocations
    if (pb != NULL)
    {
        LocalFree((HANDLE)pb);
    }
    if (flattenpb != NULL)
    {
        LocalFree((HANDLE)flattenpb);
    }
    // This should only happen if we failed
    if (returnpb != NULL)
    {
        LocalFree((HANDLE)returnpb);
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\handlers.h ===
/****************************************************************************
 *  Handlers.h - Definitions for handlers.
 *
 *  DATE:   11-Dec-1991
 *  Author: Jeffrey Newman (c-jeffn)
 *
 *  Copyright (c) Microsoft Inc. 1991
 ****************************************************************************/

//  Following is a typedef for the Drawing Order Handler

typedef BOOL DOFN (PVOID, PLOCALDC) ;
typedef DOFN *PDOFN ;

DOFN bHandleHeader;
DOFN bHandleSetArcDirection;
DOFN bHandleArc;
DOFN bHandleArcTo;
DOFN bHandleAngleArc;
DOFN bHandleEllipse;
DOFN bHandleSelectObject;
DOFN bHandleDeleteObject;
DOFN bHandleCreateBrushIndirect;
DOFN bHandleCreateDIBPatternBrush;
DOFN bHandleCreateMonoBrush;
DOFN bHandleCreatePen;
DOFN bHandleExtCreatePen;
DOFN bHandleMoveTo;
DOFN bHandleLineTo;
DOFN bHandleChord;
DOFN bHandlePie;
DOFN bHandlePolyline;
DOFN bHandlePolylineTo ;
DOFN bHandlePolyPolyline;
DOFN bHandlePolygon ;
DOFN bHandlePolyPolygon;
DOFN bHandleRectangle;
DOFN bHandleRoundRect ;
DOFN bHandlePoly16 ;
DOFN bHandlePolyPoly16 ;

DOFN bHandleExtTextOut;
DOFN bHandlePolyTextOut;
DOFN bHandleExtCreateFont;
DOFN bHandleSetBkColor;
DOFN bHandleSetBkMode;
DOFN bHandleSetMapperFlags;
DOFN bHandleSetPolyFillMode;
DOFN bHandleSetRop2;
DOFN bHandleSetStretchBltMode;
DOFN bHandleSetTextAlign;
DOFN bHandleSetTextColor;

DOFN bHandleSelectPalette;
DOFN bHandleCreatePalette;
DOFN bHandleSetPaletteEntries;
DOFN bHandleResizePalette;
DOFN bHandleRealizePalette;

DOFN bHandleSetMapMode;

DOFN bHandleSetWindowOrg;
DOFN bHandleSetWindowExt;

DOFN bHandleSetViewportOrg;
DOFN bHandleSetViewportExt;

DOFN bHandleScaleViewportExt;
DOFN bHandleScaleWindowExt;

DOFN bHandleEOF;

DOFN bHandleSaveDC;
DOFN bHandleRestoreDC;

DOFN bHandleBitBlt;
DOFN bHandleStretchBlt;
DOFN bHandleMaskBlt;
DOFN bHandlePlgBlt;
DOFN bHandleSetDIBitsToDevice;
DOFN bHandleStretchDIBits;


DOFN bHandleBeginPath;
DOFN bHandleEndPath;
DOFN bHandleFlattenPath;
DOFN bHandleStrokePath;
DOFN bHandleFillPath;
DOFN bHandleStrokeAndFillPath;
DOFN bHandleWidenPath;
DOFN bHandleSelectClipPath;
DOFN bHandleCloseFigure;
DOFN bHandleAbortPath;

DOFN bHandlePolyBezier;
DOFN bHandlePolyBezierTo;
DOFN bHandlePolyDraw;

DOFN bHandleSetWorldTransform;
DOFN bHandleModifyWorldTransform;

DOFN bHandleSetPixel;

DOFN bHandleFillRgn;
DOFN bHandleFrameRgn;
DOFN bHandleInvertRgn;
DOFN bHandlePaintRgn;
DOFN bHandleExtSelectClipRgn;
DOFN bHandleOffsetClipRgn;

DOFN bHandleExcludeClipRect;
DOFN bHandleIntersectClipRect;
DOFN bHandleSetMetaRgn;

DOFN bHandleGdiComment;

DOFN bHandleExtFloodFill;
DOFN bHandleNotImplemented;

extern fnSetVirtualResolution pfnSetVirtualResolution;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\metafile.cpp ===
/******************************Module*Header*******************************\
* Module Name: metafile.cxx
*
* Includes enhanced metafile API functions.
*
* Created: 17-July-1991 10:10:36
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#define NO_STRICT

#define _GDI32_

#define WMF_KEY 0x9ac6cdd7l

extern "C" {
#if defined(_GDIPLUS_)
#include <gpprefix.h>
#endif

#include <string.h>
#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>  // defines but doesn't use ASSERT and ASSERTMSG

#undef ASSERT
#undef ASSERTMSG

#include <nturtl.h>

#include <stddef.h>
#include <windows.h>    // GDI function declarations.
#include <winspool.h>

#include "..\runtime\debug.h"
#include "mf3216Debug.h"

#define ERROR_ASSERT(cond, msg)    ASSERTMSG((cond), (msg))

//#include "nlsconv.h"    // UNICODE helpers
//#include "firewall.h"

#define __CPLUSPLUS
#include <winspool.h>
#include <w32gdip.h>
#include "ntgdistr.h"
#include "winddi.h"
#include "hmgshare.h"
#include "icm.h"
#include "local.h"      // Local object support.
#include "gdiicm.h"
#include "metadef.h"    // Metafile record type constants.
#include "metarec.h"
#include "mf16.h"
#include "ntgdi.h"
#include "glsup.h"
#include "mf3216.h"
#include <GdiplusEnums.h>
}

#undef WARNING
#define WARNING(msg)        WARNING1(msg)
#include "rectl.hxx"
#include "mfdc.hxx"     // Metafile DC declarations.

#define USE(x)  (x)
#include "mfrec.hxx"    // Metafile record class declarations.
#undef USE

#undef WARNING
#define WARNING SAVE_WARNING

#include "Metafile.hpp"

DWORD  GetDWordCheckSum(UINT cbData, PDWORD pdwData);

#define DbgPrint printf

static inline void PvmsoFromW(void *pv, WORD w)
    { ((BYTE*)pv)[0] = BYTE(w); ((BYTE*)pv)[1] = BYTE(w >> 8); }

static inline void PvmsoFromU(void *pv, ULONG u)
    {  ((BYTE*)pv)[0] = BYTE(u);
        ((BYTE*)pv)[1] = BYTE(u >> 8);
        ((BYTE*)pv)[2] = BYTE(u >> 16);
        ((BYTE*)pv)[3] = BYTE(u >> 24);  }

#ifdef DBG
static BOOL g_outputEMF = FALSE;
#endif



/******************************Public*Routine******************************\
* GetWordCheckSum(UINT cbData, PWORD pwData)
*
* Adds cbData/2 number of words pointed to by pwData to provide an
* additive checksum.  If the checksum is valid the sum of all the WORDs
* should be zero.
*
\**************************************************************************/

static DWORD GetDWordCheckSum(UINT cbData, PDWORD pdwData)
{
    DWORD   dwCheckSum = 0;
    UINT    cdwData = cbData / sizeof(DWORD);

    ASSERTGDI(!(cbData%sizeof(DWORD)), "GetDWordCheckSum data not DWORD multiple");
    ASSERTGDI(!((ULONG_PTR)pdwData%sizeof(DWORD)), "GetDWordCheckSum data not DWORD aligned");

    while (cdwData--)
        dwCheckSum += *pdwData++;

    return(dwCheckSum);
}


/******************************Public*Routine******************************\
* UINT APIENTRY GetWinMetaFileBits(
*          HENHMETAFILE hemf,
*          UINT nSize,
*          LPBYTE lpData
*          INT iMapMode,
*          HDC hdcRef)
*
* The GetWinMetaFileBits function returns the metafile records of the
* specified enhanced metafile  in the Windows 3.0 format and copies
* them into the buffer specified.
*
* Parameter  Description
* hemf       Identifies the metafile.
* nSize      Specifies the size of the buffer reserved for the data. Only this
*            many bytes will be written.
* lpData     Points to the buffer to receive the metafile data. If this
*            pointer is NULL, the function returns the size necessary to hold
*            the data.
* iMapMode   the desired mapping mode of the metafile contents to be returned
* hdcRef     defines the units of the metafile to be returned
*
* Return Value
* The return value is the size of the metafile data in bytes. If an error
* occurs, 0 is returned.
*
* Comments
* The handle used as the hemf parameter does NOT become invalid when the
* GetWinMetaFileBits function returns.
*
* History:
*  Thu Apr  8 14:22:23 1993     -by-    Hock San Lee    [hockl]
* Rewrote it.
*  02-Jan-1992     -by-    John Colleran    [johnc]
* Wrote it.
\**************************************************************************/

UINT GdipGetWinMetaFileBitsEx
(
HENHMETAFILE hemf,
UINT         cbData16,
LPBYTE       pData16,
INT          iMapMode,
INT          eFlags
)
{
    BOOL bEmbedEmf = ((eFlags & EmfToWmfBitsFlagsEmbedEmf) == EmfToWmfBitsFlagsEmbedEmf);
    BOOL bXorPass  = !((eFlags & EmfToWmfBitsFlagsNoXORClip) == EmfToWmfBitsFlagsNoXORClip);
    UINT fConverter = 0;
    if (bEmbedEmf)
    {
        fConverter |= MF3216_INCLUDE_WIN32MF;
    }
    if (bXorPass)
    {
        fConverter |= GPMF3216_INCLUDE_XORPATH;
    }

    PEMRGDICOMMENT_WINDOWS_METAFILE pemrWinMF;
    UINT uiHeaderSize ;

    // Always go through Cleanup to return...
    UINT returnVal = 0 ; // Pessimistic Case

    PENHMETAHEADER pmfh = NULL;
    PBYTE pemfb = NULL;

    PUTS("GetWinMetaFileBits\n");

    // Validate mapmode.

    if ((iMapMode < MM_MIN) ||
        (iMapMode > MM_MAX) ||
        GetObjectTypeInternal(hemf) != OBJ_ENHMETAFILE)
    {
        ERROR_ASSERT(FALSE, "GetWinMetaFileBits: Bad mapmode");
        return 0;
    }

    if(hemf == (HENHMETAFILE) 0 )
    {
        ERROR_ASSERT(FALSE, "GetWinMetaFileBits: Bad HEMF");
        return 0;
    }

    // Validate the metafile handle.

    // GillesK:
    // We cannot access the MF object from the handle given, but all we need
    // is the PENHMETAHEADER, so get it
    uiHeaderSize = GetEnhMetaFileHeader(hemf,      // handle to enhanced metafile
                   0,          // size of buffer
                   NULL);   // data buffer

    // We have the size of the header that we need, so Allocate the header....
    // We must make sure to free it after we are done....
    pmfh = (PENHMETAHEADER)GlobalAlloc(GMEM_FIXED,uiHeaderSize);
    if(pmfh == NULL)
    {
        goto Cleanup ;
    }
    uiHeaderSize = GetEnhMetaFileHeader(hemf,      // handle to enhanced metafile
                   uiHeaderSize,          // size of buffer
                   pmfh);   // data buffer

    ERROR_ASSERT(pmfh->iType == EMR_HEADER, "GetWinMetaFileBits: invalid data");

//    ASSERTGDI(pmf->pmrmf->iType == EMR_HEADER, "GetWinMetaFileBits: invalid data");

#ifndef DO_NOT_USE_EMBEDDED_WINDOWS_METAFILE
// See if the this was originally an old style metafile and if it has
// an encapsulated original

    pemrWinMF = (PEMRGDICOMMENT_WINDOWS_METAFILE)
            ((PBYTE) pmfh + ((PENHMETAHEADER) pmfh)->nSize);

    if (((PMRGDICOMMENT) pemrWinMF)->bIsWindowsMetaFile())
    {
        // Make sure that this is what we want and verify checksum

        if (iMapMode != MM_ANISOTROPIC)
        {
            PUTS("GetWinMetaFileBits: Requested and embedded metafile mapmodes mismatch\n");
        }
        else if ((pemrWinMF->nVersion != METAVERSION300 &&
                  pemrWinMF->nVersion != METAVERSION100)
              || pemrWinMF->fFlags != 0)
        {
            // In this release, we can only handle the given metafile
            // versions.  If we return a version that we don't recognize,
            // the app will not be able to play that metafile later on!

            //VERIFYGDI(FALSE, "GetWinMetaFileBits: Unrecognized Windows metafile\n");
        }
        else if (GetDWordCheckSum((UINT) pmfh->nBytes, (PDWORD) pmfh))
        {
            PUTS("GetWinMetaFileBits: Metafile has been modified\n");
        }
        else
        {
            PUTS("GetWinMetaFileBits: Returning embedded Windows metafile\n");

            if (pData16)
            {
                if (cbData16 < pemrWinMF->cbWinMetaFile)
                {
                    ERROR_ASSERT(FALSE, "GetWinMetaFileBits: insufficient buffer");
                    //GdiSetLastError(ERROR_INSUFFICIENT_BUFFER);
                    goto Cleanup ;
                }

                RtlCopyMemory(pData16,
                          (PBYTE) &pemrWinMF[1],
                          pemrWinMF->cbWinMetaFile);
            }
            returnVal = pemrWinMF->cbWinMetaFile ;
            goto Cleanup ;
        }

        // Either the enhanced metafile containing an embedded Windows
        // metafile has been modified or the embedded Windows metafile
        // is not what we want.  Since the original format is Windows
        // format, we will not embed the enhanced metafile in the
        // returned Windows metafile.

        PUTS("GetWinMetaFileBits: Skipping embedded windows metafile\n");

        fConverter &= ~MF3216_INCLUDE_WIN32MF;
    }
#endif // DO_NOT_USE_EMBEDDED_WINDOWS_METAFILE

// Tell the converter to emit the Enhanced metafile as a comment only if
// this metafile is not previously a Windows metafile

    if (fConverter & MF3216_INCLUDE_WIN32MF)
    {
        PUTS("GetWinMetaFileBits: Embedding enhanced metafile\n");
    }
    else
    {
        PUTS("GetWinMetaFileBits: No embedding of enhanced metafile\n");
    }

    uiHeaderSize = GetEnhMetaFileBits(hemf, 0, NULL);

    // Allocate the memory to receive the enhance MetaFile
    pemfb = (PBYTE) GlobalAlloc(GMEM_FIXED, uiHeaderSize);
    if( pemfb == NULL )
    {
        goto Cleanup;
    }

    uiHeaderSize = GetEnhMetaFileBits(hemf, uiHeaderSize, pemfb);

#if DBG
    // This in only here for debugging... Save the initial EMF file to be
    // able to compare later
    // We need the ASCII version for it to work with Win98
    if (g_outputEMF)
    {
        ::DeleteEnhMetaFile(::CopyEnhMetaFileA(hemf, "C:\\emf.emf" ));
    }
#endif

    returnVal = (GdipConvertEmfToWmf((PBYTE) pemfb, cbData16, pData16,
                                     iMapMode, NULL,
                                     fConverter));

    if(!returnVal && bXorPass)
    {
        // If we fail then call without the XOR PASS
        returnVal = (GdipConvertEmfToWmf((PBYTE) pemfb, cbData16, pData16,
                                         iMapMode, NULL,
                                         fConverter & ~GPMF3216_INCLUDE_XORPATH));
#if DBG
        if( !returnVal )
        {
            // The Win32API version needs an hdcRef, get the screen DC and
            // do it
            HDC newhdc = ::GetDC(NULL);
            // If we fail again then go back to Windows
            ASSERT(::GetWinMetaFileBits(hemf, cbData16, pData16,
                                        iMapMode, newhdc) == 0);
            ::ReleaseDC(NULL, newhdc);
        }
#endif
    }

Cleanup:
    if(pmfh != NULL)
    {
        GlobalFree(pmfh);
    }
    if(pemfb != NULL)
    {
        GlobalFree(pemfb);
    }

    return returnVal;
}


extern "C"
UINT ConvertEmfToPlaceableWmf
(
    HENHMETAFILE hemf,
    UINT         cbData16,
    LPBYTE       pData16,
    INT          iMapMode,
    INT          eFlags
)
{

    UINT uiRet ;
    ENHMETAHEADER l_emetaHeader ;

    BOOL placeable = (eFlags & EmfToWmfBitsFlagsIncludePlaceable) == EmfToWmfBitsFlagsIncludePlaceable;
    // Call the GdipGetWinMetaFileBits
    // And add the header information afterwards
    // If we have a buffer then leave room for the header

    uiRet = GdipGetWinMetaFileBitsEx(hemf,
        cbData16,
        pData16?pData16+(placeable?22:0):pData16,
        iMapMode,
        eFlags);

    // If the client only wants the size of the buffer, then we return the size
    // of the buffer plus the size of the header
    if(uiRet != 0 && placeable)
    {
        // If the previous call succeeded then we will append the size of the
        // header to the return value
        uiRet += 22;

        if(pData16 != NULL)
        {
            BYTE *rgb = pData16;
            PvmsoFromU(rgb   , WMF_KEY);
            PvmsoFromW(rgb+ 4, 0);
            PvmsoFromU(rgb+16, 0);

            if(GetEnhMetaFileHeader(hemf, sizeof(l_emetaHeader), &l_emetaHeader))
            {
                FLOAT pp01mm = ((((FLOAT)l_emetaHeader.szlDevice.cx)/l_emetaHeader.szlMillimeters.cx/100.0f +
                                 (FLOAT)l_emetaHeader.szlDevice.cy)/l_emetaHeader.szlMillimeters.cy/100.0f)/2.0f;
                PvmsoFromW(rgb+ 6, SHORT((FLOAT)l_emetaHeader.rclFrame.left*pp01mm));
                PvmsoFromW(rgb+ 8, SHORT((FLOAT)l_emetaHeader.rclFrame.top*pp01mm));
                PvmsoFromW(rgb+10, SHORT((FLOAT)l_emetaHeader.rclFrame.right*pp01mm));
                PvmsoFromW(rgb+12, SHORT((FLOAT)l_emetaHeader.rclFrame.bottom*pp01mm));
                PvmsoFromW(rgb+14, SHORT(pp01mm*2540.0f));
            }
            else
            {
                // If we cant get the information from the EMF then default
                PvmsoFromW(rgb+ 6, SHORT(0));
                PvmsoFromW(rgb+ 8, SHORT(0));
                PvmsoFromW(rgb+10, SHORT(2000));
                PvmsoFromW(rgb+12, SHORT(2000));
                PvmsoFromW(rgb+14, 96);
            }
            /* Checksum.  This works on any byte order machine because the data is swapped
                consistently. */
            USHORT *pu = (USHORT*)rgb;
            USHORT u = 0;
            /* The checksum is even parity. */
            while (pu < (USHORT*)(rgb+20))
                u ^= *pu++;
            *pu = u;
        }
    }

    return uiRet ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\mftypes.hpp ===
#include "precomp.h"

/*********************************Class************************************\
* class MF
*
* Metafile MF structure.
*
* There is no constructor or destructor for this object.  We do the
* initialization in pmfAllocMF and cleanup in vFreeMF.
*
* History:
*  Wed Jul 17 17:10:28 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

class MF
{
private:
    ULONG        ident;         // Identifier 'MF'
    HANDLE       hFile;         // Handle to the disk metafile.
    HANDLE       hFileMap;      // Handle to the disk file mapping object.
public:
    PENHMETAHEADER pmrmf;       // Pointer to MRMETAFILE record
    EMFSpoolData *pEMFSpool;    // handle to extra EMF spool information
private:
    ULONG        iMem;          // Current memory index pointer.
    ERECTL       erclClipBox;   // Incl-incl clip box in source device units.
    WCHAR        wszPathname[MAX_PATH+1];
                                // Full pathname of the disk metafile.
public:
    ULONG        fl;            // Flags.
    PHANDLETABLE pht;           // Pointer to the object handle table.
    BOOL         bBeginGroup;   // Is begin group comment emitted?
                                // Init to FALSE before play or enum.
    ULONG        cLevel;        // Saved level.  Init to 1 before play or enum.
    XFORM        xformBase;     // Base playback transform for target.
                                // This happens to be the same as cliprgn xform.
    HDC          hdcXform;      // Virtual DC for use in transform computation.

public:
// bIsDiskFile -- Is this a disk or memory metafile?

    BOOL bIsDiskFile()  { return(fl & MF_DISKFILE); }

// bIsEMFSpool -- During EMF spooling?

    BOOL bIsEMFSpool()  { return (pEMFSpool != NULL); }

// bSetTransform -- Set up the transform in the target DC.

    BOOL bSetTransform(HDC hdc)
    {
        return(FALSE);
    }

// bClipped -- Returns TRUE if erclBounds does not intersect the clip box,
//             otherwise FALSE.  Both rectangles are assumed to be incl-incl
//             in source device units.  The clip box must not be empty.
//
// If erclBounds is empty, we will return FALSE to force playback of the
// record.  The reason is that at record (or embed) time, the scale transform
// at the time may cause the bounds to be empty due to rounding error.  At
// playback time, this bounds may not be empty anymore.

    BOOL bClipped(ERECTL &erclBounds)
    {
        if (erclBounds.bEmpty())
            return(FALSE);
        else
            return(erclClipBox.bNoIntersect(erclBounds));
    }
};

typedef MF *PMF;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\polygons.c ===
/*****************************************************************************
 *
 * polygons - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************
 *  PolyPolygon  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyPolygon
(
PLOCALDC pLocalDC,
PPOINTL pptl,
PDWORD  pcptl,
DWORD   cptl,
DWORD   ccptl,
BOOL    transform
)
{
BOOL    b;
PWORD   pcptlBuff = (PWORD) NULL;
PPOINTL pptlBuff  = (PPOINTL) NULL;
PPOINTL pptlSrc, pptlDst;
DWORD   i, cptlMax, cptlNeed, cptli;

    // If we're recording the drawing orders for a path
    // then just pass the drawing order to the helper DC.
    // Do not emit any Win16 drawing orders.

    if (pLocalDC->flags & RECORDING_PATH)
    {
        if (pfnSetVirtualResolution == NULL)
        {
            bXformWorkhorse(pptl, cptl, &pLocalDC->xformRWorldToRDev);
        }
        return(PolyPolygon(pLocalDC->hdcHelper, (LPPOINT) pptl, (LPINT) pcptl, (INT) ccptl));
    }

    // NOTE: There is a semantic between the Win32 PolyPolygon and
    // the Win16 PolyPolygon.  Win32 will close each polygon, Win16
    // will not.  As a result, we have to insert points as necessary
    // to make the polygons closed.  We cannot use multiple polygons
    // to replace a single PolyPolygon because they are different if
    // the polygons overlap and the polyfill mode is winding.

    // If there are not verrics just return TRUE.

    if (ccptl == 0)
        return(TRUE) ;

    b = FALSE;          // assume failure

    // Compute the maximum size of the temporary point array required
    // to create closed PolyPolygon in win16.

    cptlMax = cptl + ccptl;

    // Allocate a buffer for the temporary point array.

    pptlBuff = (PPOINTL) LocalAlloc(LMEM_FIXED, cptlMax * sizeof(POINTL)) ;
    if (!pptlBuff)
    {
        PUTS("MF3216: DoPolyPolygon, LocalAlloc failed\n") ;
        goto exit;
    }

    // Allocate a buffer for the new polycount array and make a copy
    // of the old array.

    pcptlBuff = (PWORD) LocalAlloc(LMEM_FIXED, ccptl * sizeof(WORD)) ;
    if (!pcptlBuff)
    {
        PUTS("MF3216: DoPolyPolygon, LocalAlloc failed\n") ;
        goto exit;
    }

    for (i = 0; i < ccptl; i++)
        pcptlBuff[i] = (WORD) pcptl[i];

    // Insert the points and update the polycount as necessary.

    pptlDst = pptlBuff;
    pptlSrc = pptl;
    cptlNeed = cptl;
    for (i = 0; i < ccptl; i++)
    {
        cptli = pcptl[i];

        if (cptli < 2)
        goto exit;

        RtlCopyMemory(pptlDst, pptlSrc, cptli * sizeof(POINTL)) ;
        if (pptlDst[0].x != pptlDst[cptli - 1].x
         || pptlDst[0].y != pptlDst[cptli - 1].y)
        {
        pptlDst[cptli] = pptlDst[0];
        pptlDst++;
        cptlNeed++;
        pcptlBuff[i]++;
        }
        pptlSrc += cptli;
        pptlDst += cptli;
    }

    // The Win16 poly record is limited to 64K points.
    // Need to check this limit.

    if (cptlNeed > (DWORD) (WORD) MAXWORD)
    {
            PUTS("MF3216: DoPolyPolygon, Too many point in poly array\n") ;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY) ;
            goto exit ;
    }

    // Do the transformations.
    if (transform)
    {
        if (!bXformRWorldToPPage(pLocalDC, pptlBuff, cptlNeed))
            goto exit;
    }

    // Compress the POINTLs to POINTSs

    vCompressPoints(pptlBuff, cptlNeed) ;

    // Call the Win16 routine to emit the PolyPolygon to the metafile.

	if (ccptl == 1)
	{
		b = bEmitWin16Poly(pLocalDC, (PPOINTS) pptlBuff, (WORD)cptlNeed, META_POLYGON);
	}
	else
	{
		b = bEmitWin16PolyPolygon(pLocalDC, (PPOINTS) pptlBuff,
			pcptlBuff, (WORD) cptlNeed, (WORD) ccptl);
	}

exit:
    // Free the memory.

    if (pptlBuff)
        if (LocalFree(pptlBuff))
        ASSERTGDI(FALSE, "MF3216: DoPolyPolygon, LocalFree failed");

    if (pcptlBuff)
        if (LocalFree(pcptlBuff))
        ASSERTGDI(FALSE, "MF3216: DoPolyPolygon, LocalFree failed");

    return(b) ;
}

/***************************************************************************
 *  SetPolyFillMode  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetPolyFillMode
(
PLOCALDC  pLocalDC,
DWORD   iPolyFillMode
)
{
BOOL    b ;

    // Emit the Win16 metafile drawing order.

    b = bEmitWin16SetPolyFillMode(pLocalDC, LOWORD(iPolyFillMode)) ;

    return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\precomp.h ===
#include "stddef.h"
#include <windows.h>
#include "..\runtime\debug.h"
#include "mf3216Debug.h"
#include "mf3216.h"
#include "wingdip.h"
#include "entry.h"
#include "win16api.h"
#include "..\..\..\..\Core\ntgdi\client\mf16.h"
#include "..\..\..\..\Core\ntgdi\client\metadef.h"
#include <math.h>
#include "handlers.h"
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\parser.c ===
/*****************************************************************************
 *
 * parser.cxx - Parser for the Win32 to Win16 metafile converter.
 *
 * Date: 8/13/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/


#include "precomp.h"
#pragma hdrstop

#define EMR_LAST_MF3216_SUPPORTED 97

BOOL bGetNextRecord(PLOCALDC pLocalDC, PENHMETARECORD *pemr) ;

// Call table for the translation entry points.

PDOFN pdofnDrawingOrders[] = {
        (PDOFN) NULL,
        bHandleHeader,                  // EMR_HEADER                       1
        bHandlePolyBezier,              // EMR_POLYBEZIER                   2
        bHandlePolygon,                 // EMR_POLYGON                      3
        bHandlePolyline,                // EMR_POLYLINE                     4
        bHandlePolyBezierTo,            // EMR_POLYBEZIERTO                 5
        bHandlePolylineTo,              // EMR_POLYLINETO                   6
        bHandlePolyPolyline,            // EMR_POLYPOLYLINE                 7
        bHandlePolyPolygon,             // EMR_POLYPOLYGON                  8
        bHandleSetWindowExt,            // EMR_SETWINDOWEXTEX               9
        bHandleSetWindowOrg,            // EMR_SETWINDOWORGEX               10
        bHandleSetViewportExt,          // EMR_SETVIEWPORTEXTEX             11
        bHandleSetViewportOrg,          // EMR_SETVIEWPORTORGEX             12
        bHandleNotImplemented,          // EMR_SETBRUSHORGEX                13
        bHandleEOF,                     // EMR_EOF                          14
        bHandleSetPixel,                // EMR_SETPIXELV                    15
        bHandleSetMapperFlags,          // EMR_SETMAPPERFLAGS               16
        bHandleSetMapMode,              // EMR_SETMAPMODE                   17
        bHandleSetBkMode,               // EMR_SETBKMODE                    18
        bHandleSetPolyFillMode,         // EMR_SETPOLYFILLMODE              19
        bHandleSetRop2,                 // EMR_SETROP2                      20
        bHandleSetStretchBltMode,       // EMR_SETSTRETCHBLTMODE            21
        bHandleSetTextAlign,            // EMR_SETTEXTALIGN                 22
        bHandleNotImplemented,          // EMR_SETCOLORADJUSTMENT           23
        bHandleSetTextColor,            // EMR_SETTEXTCOLOR                 24
        bHandleSetBkColor,              // EMR_SETBKCOLOR                   25
        bHandleOffsetClipRgn,           // EMR_OFFSETCLIPRGN                26
        bHandleMoveTo,                  // EMR_MOVETOEX                     27
        bHandleSetMetaRgn,              // EMR_SETMETARGN                   28
        bHandleExcludeClipRect,         // EMR_EXCLUDECLIPRECT              29
        bHandleIntersectClipRect,       // EMR_INTERSECTCLIPRECT            30
        bHandleScaleViewportExt,        // EMR_SCALEVIEWPORTEXTEX           31
        bHandleScaleWindowExt,          // EMR_SCALEWINDOWEXTEX             32
        bHandleSaveDC,                  // EMR_SAVEDC                       33
        bHandleRestoreDC,               // EMR_RESTOREDC                    34
        bHandleSetWorldTransform,       // EMR_SETWORLDTRANSFORM            35
        bHandleModifyWorldTransform,    // EMR_MODIFYWORLDTRANSFORM         36
        bHandleSelectObject,            // EMR_SELECTOBJECT                 37
        bHandleCreatePen,               // EMR_CREATEPEN                    38
        bHandleCreateBrushIndirect,     // EMR_CREATEBRUSHINDIRECT          39
        bHandleDeleteObject,            // EMR_DELETEOBJECT                 40
        bHandleAngleArc,                // EMR_ANGLEARC                     41
        bHandleEllipse,                 // EMR_ELLIPSE                      42
        bHandleRectangle,               // EMR_RECTANGLE                    43
        bHandleRoundRect,               // EMR_ROUNDRECT                    44
        bHandleArc,                     // EMR_ARC                          45
        bHandleChord,                   // EMR_CHORD                        46
        bHandlePie,                     // EMR_PIE                          47
        bHandleSelectPalette,           // EMR_SELECTPALETTE                48
        bHandleCreatePalette,           // EMR_CREATEPALETTE                49
        bHandleSetPaletteEntries,       // EMR_SETPALETTEENTRIES            50
        bHandleResizePalette,           // EMR_RESIZEPALETTE                51
        bHandleRealizePalette,          // EMR_REALIZEPALETTE               52
        bHandleExtFloodFill,            // EMR_EXTFLOODFILL                 53
        bHandleLineTo,                  // EMR_LINETO                       54
        bHandleArcTo,                   // EMR_ARCTO                        55
        bHandlePolyDraw,                // EMR_POLYDRAW                     56
        bHandleSetArcDirection,         // EMR_SETARCDIRECTION              57
        bHandleNotImplemented,          // EMR_SETMITERLIMIT                58
        bHandleBeginPath,               // EMR_BEGINPATH                    59
        bHandleEndPath,                 // EMR_ENDPATH                      60
        bHandleCloseFigure,             // EMR_CLOSEFIGURE                  61
        bHandleFillPath,                // EMR_FILLPATH                     62
        bHandleStrokeAndFillPath,       // EMR_STROKEANDFILLPATH            63
        bHandleStrokePath,              // EMR_STROKEPATH                   64
        bHandleFlattenPath,             // EMR_FLATTENPATH                  65
        bHandleWidenPath,               // EMR_WIDENPATH                    66
        bHandleSelectClipPath,          // EMR_SELECTCLIPPATH               67
        bHandleAbortPath,               // EMR_ABORTPATH                    68
        bHandleNotImplemented,          //                                  69
        bHandleGdiComment,              // EMR_GDICOMMENT                   70
        bHandleFillRgn,                 // EMR_FILLRGN                      71
        bHandleFrameRgn,                // EMR_FRAMERGN                     72
        bHandleInvertRgn,               // EMR_INVERTRGN                    73
        bHandlePaintRgn,                // EMR_PAINTRGN                     74
        bHandleExtSelectClipRgn,        // EMR_EXTSELECTCLIPRGN             75
        bHandleBitBlt,                  // EMR_BITBLT                       76
        bHandleStretchBlt,              // EMR_STRETCHBLT                   77
        bHandleMaskBlt,                 // EMR_MASKBLT                      78
        bHandlePlgBlt,                  // EMR_PLGBLT                       79
        bHandleSetDIBitsToDevice,       // EMR_SETDIBITSTODEVICE            80
        bHandleStretchDIBits,           // EMR_STRETCHDIBITS                81
        bHandleExtCreateFont,           // EMR_EXTCREATEFONTINDIRECTW       82
        bHandleExtTextOut,              // EMR_EXTTEXTOUTA                  83
        bHandleExtTextOut,              // EMR_EXTTEXTOUTW                  84
        bHandlePoly16,                  // EMR_POLYBEZIER16                 85
        bHandlePoly16,                  // EMR_POLYGON16                    86
        bHandlePoly16,                  // EMR_POLYLINE16                   87
        bHandlePoly16,                  // EMR_POLYBEZIERTO16               88
        bHandlePoly16,                  // EMR_POLYLINETO16                 89
        bHandlePolyPoly16,              // EMR_POLYPOLYLINE16               90
        bHandlePolyPoly16,              // EMR_POLYPOLYGON16                91
        bHandlePoly16,                  // EMR_POLYDRAW16                   92
        bHandleCreateMonoBrush,         // EMR_CREATEMONOBRUSH              93
        bHandleCreateDIBPatternBrush,   // EMR_CREATEDIBPATTERNBRUSHPT      94
        bHandleExtCreatePen,            // EMR_EXTCREATEPEN                 95
        bHandlePolyTextOut,             // EMR_POLYTEXTOUTA                 96
        bHandlePolyTextOut,             // EMR_POLYTEXTOUTW                 97
        bHandleNotImplemented,          // EMR_SETICMMODE                   98
        bHandleNotImplemented,          // EMR_CREATECOLORSPACE             99
        bHandleNotImplemented,          // EMR_SETCOLORSPACE               100
        bHandleNotImplemented,          // EMR_DELETECOLORSPACE            101
        bHandleNotImplemented,          // EMR_GLSRECORD                   102
        bHandleNotImplemented,          // EMR_GLSBOUNDEDRECORD            103
        bHandleNotImplemented,          // EMR_PIXELFORMAT                 104
        bHandleNotImplemented,          //                                 105
        bHandleNotImplemented,          //                                 106
        bHandleNotImplemented,          //                                 107
        bHandleNotImplemented,          //                                 108
        bHandleNotImplemented,          //                                 109
        bHandleNotImplemented,          //                                 110
        bHandleNotImplemented,          // EMR_COLORCORRECTPALETTE         111
        bHandleNotImplemented,          // EMR_ALPHABLEND                  112
        bHandleNotImplemented,          // EMR_ALPHADIBBLEND               113
        bHandleNotImplemented,          // EMR_TRANSPARENTIMAGE            114
        bHandleNotImplemented,          // EMR_TRANSPARENTDIBIMAGE         115
        bHandleNotImplemented           // EMR_GRADIENTFILL                116

} ;

#if DBG

PSZ         pszMfRecords[] = {
                        "NULL RECORD               ",
                        "EMR_HEADER                ",
                        "EMR_POLYBEZIER            ",
                        "EMR_POLYGON               ",
                        "EMR_POLYLINE              ",
                        "EMR_POLYBEZIERTO          ",
                        "EMR_POLYLINETO            ",
                        "EMR_POLYPOLYLINE          ",
                        "EMR_POLYPOLYGON           ",
                        "EMR_SETWINDOWEXTEX        ",
                        "EMR_SETWINDOWORGEX        ",
                        "EMR_SETVIEWPORTEXTEX      ",
                        "EMR_SETVIEWPORTORGEX      ",
                        "EMR_SETBRUSHORGEX         ",
                        "EMR_EOF                   ",
                        "EMR_SETPIXELV             ",
                        "EMR_SETMAPPERFLAGS        ",
                        "EMR_SETMAPMODE            ",
                        "EMR_SETBKMODE             ",
                        "EMR_SETPOLYFILLMODE       ",
                        "EMR_SETROP2               ",
                        "EMR_SETSTRETCHBLTMODE     ",
                        "EMR_SETTEXTALIGN          ",
                        "EMR_SETCOLORADJUSTMENT    ",
                        "EMR_SETTEXTCOLOR          ",
                        "EMR_SETBKCOLOR            ",
                        "EMR_OFFSETCLIPRGN         ",
                        "EMR_MOVETOEX              ",
                        "EMR_SETMETARGN            ",
                        "EMR_EXCLUDECLIPRECT       ",
                        "EMR_INTERSECTCLIPRECT     ",
                        "EMR_SCALEVIEWPORTEXTEX    ",
                        "EMR_SCALEWINDOWEXTEX      ",
                        "EMR_SAVEDC                ",
                        "EMR_RESTOREDC             ",
                        "EMR_SETWORLDTRANSFORM     ",
                        "EMR_MODIFYWORLDTRANSFORM  ",
                        "EMR_SELECTOBJECT          ",
                        "EMR_CREATEPEN             ",
                        "EMR_CREATEBRUSHINDIRECT   ",
                        "EMR_DELETEOBJECT          ",
                        "EMR_ANGLEARC              ",
                        "EMR_ELLIPSE               ",
                        "EMR_RECTANGLE             ",
                        "EMR_ROUNDRECT             ",
                        "EMR_ARC                   ",
                        "EMR_CHORD                 ",
                        "EMR_PIE                   ",
                        "EMR_SELECTPALETTE         ",
                        "EMR_CREATEPALETTE         ",
                        "EMR_SETPALETTEENTRIES     ",
                        "EMR_RESIZEPALETTE         ",
                        "EMR_REALIZEPALETTE        ",
                        "EMR_EXTFLOODFILL          ",
                        "EMR_LINETO                ",
                        "EMR_ARCTO                 ",
                        "EMR_POLYDRAW              ",
                        "EMR_SETARCDIRECTION       ",
                        "EMR_SETMITERLIMIT         ",
                        "EMR_BEGINPATH             ",
                        "EMR_ENDPATH               ",
                        "EMR_CLOSEFIGURE           ",
                        "EMR_FILLPATH              ",
                        "EMR_STROKEANDFILLPATH     ",
                        "EMR_STROKEPATH            ",
                        "EMR_FLATTENPATH           ",
                        "EMR_WIDENPATH             ",
                        "EMR_SELECTCLIPPATH        ",
                        "EMR_ABORTPATH             ",
                        "unknown record            ",
                        "EMR_GDICOMMENT            ",
                        "EMR_FILLRGN               ",
                        "EMR_FRAMERGN              ",
                        "EMR_INVERTRGN             ",
                        "EMR_PAINTRGN              ",
                        "EMR_EXTSELECTCLIPRGN      ",
                        "EMR_BITBLT                ",
                        "EMR_STRETCHBLT            ",
                        "EMR_MASKBLT               ",
                        "EMR_PLGBLT                ",
                        "EMR_SETDIBITSTODEVICE     ",
                        "EMR_STRETCHDIBITS         ",
                        "EMR_EXTCREATEFONTINDIRECTW",
                        "EMR_EXTTEXTOUTA           ",
                        "EMR_EXTTEXTOUTW           ",
                        "EMR_POLYBEZIER16          ",
                        "EMR_POLYGON16             ",
                        "EMR_POLYLINE16            ",
                        "EMR_POLYBEZIERTO16        ",
                        "EMR_POLYLINETO16          ",
                        "EMR_POLYPOLYLINE16        ",
                        "EMR_POLYPOLYGON16         ",
                        "EMR_POLYDRAW16            ",
                        "EMR_CREATEMONOBRUSH       ",
                        "EMR_CREATEDIBPATTERNBRUSHP",
                        "EMR_EXTCREATEPEN          ",
                        "EMR_POLYTEXTOUTA          ",
                        "EMR_POLYTEXTOUTW          ",
                        "EMR_SETICMMODE            ",
                        "EMR_CREATECOLORSPACE      ",
                        "EMR_SETCOLORSPACE         ",
                        "EMR_DELETECOLORSPACE      ",
                        "EMR_GLSRECORD             ",
                        "EMR_GLSBOUNDEDRECORD      ",
                        "EMR_PIXELFORMAT           ",
                        "105                       ",
                        "106                       ",
                        "107                       ",
                        "108                       ",
                        "109                       ",
                        "110                       ",
                        "EMR_COLORCORRECTPALETTE   ",
                        "EMR_ALPHABLEND            ",
                        "EMR_ALPHADIBBLEND         ",
                        "EMR_TRANSPARENTIMAGE      ",
                        "EMR_TRANSPARENTDIBIMAGE   ",
                        "EMR_GRADIENTFILL          "
};

#endif

/*****************************************************************************
 *  Parse the Win32 metafile.
 *
 *  The Win32 metafile is represented by the metafile bits pointed to
 *  by pMetafileBits.  The metafile bits may be obtained from a memory mapped
 *  file, or from some shared memory (from the clipboard).
 *****************************************************************************/
BOOL bParseWin32Metafile(PBYTE pMetafileBits, PLOCALDC pLocalDC)
{
INT         iType ;
PVOID       pVoid ;
PENHMETARECORD pemr ;
PENHMETAHEADER pMf32Header ;
DWORD       nFileSize ;
BOOL        bRet ;
INT         iRecordCount,
            iLastError ;

        bRet = TRUE ;

        // Get the file length from the header.
        // Test to make sure the first record is a Win32 Metafile header.

        pMf32Header = (PENHMETAHEADER) pMetafileBits ;
        if (   (pMf32Header->iType      != EMR_HEADER)
            || (pMf32Header->dSignature != ENHMETA_SIGNATURE)
           )
        {
            RIPS("MF3216: bParseWin32Metafile, First Record not a Win32 Metafile Header\n") ;
            return(FALSE) ;
        }

        // Record a pointer to the beginning of the Win32 metafile and
        // it's length incase we need to emit the Win32 metafile  as  a comment
        // record(s).

        pLocalDC->pMf32Bits = (PBYTE) pMf32Header ;
        pLocalDC->cMf32Bits = pMf32Header->nBytes ;

        // Get the file size for the parser.

        nFileSize = pMf32Header->nBytes ;

        // Initialize pbCurrent, & pbEnd pointers into the
        // metafile bits.

        pLocalDC->pbCurrent = pMetafileBits ;
        pLocalDC->pbEnd   = pLocalDC->pbCurrent + nFileSize ;

        // Init the record count.

        iRecordCount = 0 ;

        // Go through the metafile bits.  Handle each record based on
        // it's type.  bGetNextRecord returns TRUE if pemr contains
        // a pointer to a record.

        while (bGetNextRecord(pLocalDC, &pemr))
        {

            iRecordCount++ ;

            // Set up a convienent point to the record.

            pVoid = (PVOID) pemr ;

            // Handle the record based on it's type.

            iType = (INT) pemr->iType ;

            // Check if the record type falls within the range of the
            // call table.  Eventually, all the record handlers  should
            // be in the call table.

            if (iType <= EMR_LAST_MF3216_SUPPORTED)
            {
                bRet = pdofnDrawingOrders[iType](pVoid, pLocalDC) ;
#if DBG
                if (bRet == FALSE)
                {
                    iLastError = GetLastError() ;
                    PUTS1("MF3216: Error on Win32 Metafile record #: %d\n", iRecordCount) ;
                    PUTS1("\tRecord type: %s\n", pszMfRecords[iType]) ;
                    PUTS1("\tLast Error Code: %08.8X\n", iLastError) ;
                }
#endif
#if 0
                if (bRet == FALSE)
                    break ;
#else
                // In ancient times (i.e., before NT4.0), someone explicitly
                // removed the code above which exits the loop if the handler
                // fails.  Possibly this was a compatibility fix in which
                // the app depended on the metafile conversion to continue
                // even in the event of a failure.
                //
                // Unfortunately, this fix also allows the parser to continue
                // even if the output buffer has run out of space.  To
                // minimize the change, we will explicitly look for this case
                // and break out of the loop if it happens.  (Refer to bEmit()
                // in emit.c to see where ERROR_BUFFER_OVERFLOW is set).

                if (pLocalDC->flags & ( ERR_BUFFER_OVERFLOW | ERR_XORCLIPPATH ) )
                    break ;
#endif
            }
            else
            {
                PUTS1("MF3216: bParseWin32Metafile - record not supported: %d\n", iType) ;
            }
        }
#if 0
        // Display some statictics

        if (bRet == TRUE)
        {
            PUTS1("MF3216: %d Win32 Metafile records processed\n",
                   iRecordCount) ;
        }
#endif
        return(bRet) ;
}

/*****************************************************************************
 * Get next record
 *
 *  This is a support routine for bParseWin32Metafile.
 *  It is assumed that pbCurrent, & pbEnd are initialized
 *  the first time this routine is called.
 *
 *  It returns TRUE if a valid pointer to record is returned in
 *  pemr.  If there are not more records FALSE is returned.
 *
 *  We now need to take into consideration 
 *****************************************************************************/
BOOL bGetNextRecord(PLOCALDC pLocalDC, PENHMETARECORD *ppemr)
{
DWORD   nSize ;

        // if we are recreating the objects then go through our list of objects
        if (pLocalDC->iXORPass == OBJECTRECREATION)
        {
            if (pLocalDC->pW16RecreationSlot == NULL)
            {
                // All our objects are created... Set the next record to be the start
                // of the second pass
                pLocalDC->pbRecord = pLocalDC->pbChange ;
                pLocalDC->pbCurrent = pLocalDC->pbRecord ;
                *ppemr = (PENHMETARECORD) pLocalDC->pbCurrent ;

                nSize = ((PENHMETARECORD) pLocalDC->pbCurrent)->nSize ;
                pLocalDC->pbCurrent += nSize ;

                pLocalDC->iXORPass = ERASEXORPASS ;

                DoSelectObject(pLocalDC, pLocalDC->lholdp32);
                DoSelectObject(pLocalDC, pLocalDC->lholdbr32);

                return TRUE ;
            }
            else
            {
                PW16RECREATIONSLOT pW16RecreationSlot = pLocalDC->pW16RecreationSlot ;
                pLocalDC->pW16RecreationSlot = pW16RecreationSlot->pNext ;
                pLocalDC->pbRecord = (PBYTE) pW16RecreationSlot->pbCreatRec ;
                pLocalDC->pbCurrent = (PBYTE) pW16RecreationSlot->pbCreatRec ;
                *ppemr = (PENHMETARECORD) pLocalDC->pbCurrent ;
                nSize = ((PENHMETARECORD) pLocalDC->pbCurrent)->nSize ;
                pLocalDC->pbCurrent += nSize ;

                LocalFree(pW16RecreationSlot);

                return TRUE ;
            }
        }


        // Check for the end of buffer.
        // If this is the end return FALSE and set *ppemr to 0.

        if (pLocalDC->pbCurrent == pLocalDC->pbEnd)
        {
            *ppemr = (PENHMETARECORD) NULL ;
            pLocalDC->pbRecord = NULL ;
            return (FALSE) ;
        }

        // Well it's not the end of the buffer.
        // So, return a pointer to this record, update pbCurrent, and
        // return TRUE ;

        *ppemr = (PENHMETARECORD) pLocalDC->pbCurrent ;
        pLocalDC->pbRecord = pLocalDC->pbCurrent ;

        nSize = ((PENHMETARECORD) pLocalDC->pbCurrent)->nSize ;
        pLocalDC->pbCurrent += nSize ;

        return(TRUE) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\paths.c ===
/*****************************************************************************
 *
 * paths - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#pragma pack(2)

typedef struct PathInfo16
{
    WORD       RenderMode;
    BYTE       FillMode;
    BYTE       BkMode;
    LOGPEN16   Pen;
    LOGBRUSH16 Brush;
    DWORD      BkColor;
} PathInfo16;

#pragma pack()

BOOL GdipFlattenGdiPath(PLOCALDC, LPVOID*, INT*);


/****************************************************************************
*   GillesK 2001/02/12
*   Convert a PolyPolygon call to multiple Polygons calls.
*   PolyPolygons cannot be used for Postscript paths. So we need to convert
*   them to Polygon calls and wrap a Postscipt BeginPath/EndPath sequence
*   around each polygon
****************************************************************************/

BOOL ConvertPolyPolygonToPolygons(
PLOCALDC pLocalDC,
PPOINTL pptl,
PDWORD  pcptl,
DWORD   cptl,
DWORD   ccptl,
BOOL    transform
)
{
    PathInfo16 pathInfo16 = { 0, 1, TRANSPARENT,
    { PS_NULL, {0,0}, RGB(0, 0, 0)},
    {BS_HOLLOW, RGB(0, 0, 0), 0},
    RGB(0, 0, 0) } ;
    DWORD   polyCount;
    BOOL    b = TRUE; // In case there are 0 polygons
    PPOINTL buffer = NULL; 
    PPOINTS shortBuffer = NULL;
    WORD    wEscape;

    // Convert the points from POINTL to POINTS
    buffer = (PPOINTL) LocalAlloc(LMEM_FIXED, cptl * sizeof(POINTL));
    if (buffer == NULL)
    {
        return FALSE;
    }                      
    RtlCopyMemory(buffer, pptl, cptl*sizeof(POINTL));
    if (transform)
    {
        b = bXformRWorldToPPage(pLocalDC, buffer, cptl);
        if (b == FALSE)
            goto exitFreeMem;
    }

    vCompressPoints(buffer, cptl) ;
        shortBuffer = (PPOINTS) buffer;

                             
    // For each polygon in the polycount, we do a BeginPath, and EndPath
    for (polyCount = 0; polyCount < ccptl; shortBuffer += pcptl[polyCount], polyCount++)
    {
        // Emit the Postscript escape to End the Path
        if(!bEmitWin16Escape(pLocalDC, BEGIN_PATH, 0, NULL, NULL))
            goto exitFreeMem;

        // Call the Win16 routine to emit the poly to the metafile.
        b = bEmitWin16Poly(pLocalDC, (LPPOINTS) shortBuffer, (SHORT) pcptl[polyCount],
            META_POLYGON) ;

        // Emit the Postscript escape to End the Path
        if(!bEmitWin16Escape(pLocalDC, END_PATH, sizeof(pathInfo16), (LPSTR)&pathInfo16, NULL))
            goto exitFreeMem;

        // If the bEmitWin16Poly has failed, we at least want to end the path
        if (!b)
        {
            goto exitFreeMem;
        }

    }

exitFreeMem:
    if (buffer != NULL)
    {
        LocalFree((HLOCAL) buffer);
    }

    return b;

}

BOOL ConvertPathToPSClipPath(PLOCALDC pLocalDC, BOOL psOnly)
{
    INT   ihW32Br;
    LONG  lhpn32 = pLocalDC->lhpn32;
    LONG  lhbr32 = pLocalDC->lhbr32;
    WORD  wEscape;

    if( pLocalDC->iROP == R2_NOTCOPYPEN )
    {
        ihW32Br = WHITE_BRUSH | ENHMETA_STOCK_OBJECT ;
    }
    else
    {
        ihW32Br = BLACK_BRUSH | ENHMETA_STOCK_OBJECT ;
    }

    // Emit the Postscript escape to ignore the pen change
    wEscape = STARTPSIGNORE ;
    if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
        return FALSE ;

    if (DoSelectObject(pLocalDC, ihW32Br))
    {
        // Do it to the helper DC.
        DWORD oldRop = SetROP2(pLocalDC->hdcHelper, R2_COPYPEN);
        // Emit the Win16 metafile drawing order.
        if (!bEmitWin16SetROP2(pLocalDC, LOWORD(R2_COPYPEN)))
            return FALSE;

        wEscape = ENDPSIGNORE ;
        if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;

        // If we only want the path in PS then we need to save the previous one
        if (psOnly)
        {
            wEscape = CLIP_SAVE ;
            if(!bEmitWin16Escape(pLocalDC, CLIP_TO_PATH, sizeof(wEscape), (LPSTR)&wEscape, NULL))
                return FALSE ;
        }

        if(!DoRenderPath(pLocalDC, EMR_FILLPATH, psOnly))   // We need to fill the path with black
            return FALSE;

        if(pLocalDC->pbLastSelectClip == pLocalDC->pbRecord || psOnly)
        {
            wEscape = CLIP_INCLUSIVE;
            if(!bEmitWin16Escape(pLocalDC, CLIP_TO_PATH, sizeof(wEscape), (LPSTR)&wEscape, NULL))
                return FALSE;
        }

        // Emit the Postscript escape to ignore the pen change
        wEscape = STARTPSIGNORE ;
        if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;

        if(!DoSelectObject(pLocalDC, lhbr32))
            return FALSE;

        // Do it to the helper DC.
        SetROP2(pLocalDC->hdcHelper, oldRop);
        // Emit the Win16 metafile drawing order.
        if (!bEmitWin16SetROP2(pLocalDC, LOWORD(oldRop)))
            return FALSE;

        wEscape = ENDPSIGNORE ;
        if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;

    }
    return TRUE ;

}

/***************************************************************************
*  BeginPath  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoBeginPath
(
 PLOCALDC pLocalDC
 )
{
    BOOL    b ;

    // Set the global flag telling all all the geometric
    // rendering routines that we are accumulating drawing orders
    // for the path.

    pLocalDC->flags |= RECORDING_PATH ;

    // Tell the helper DC we are begining the path accumulation.

    b = BeginPath(pLocalDC->hdcHelper) ;

    // Save the position of the path if we haven't started the XOR passes
    if (pLocalDC->flags & INCLUDE_W32MF_XORPATH)
    {
        if(pLocalDC->iXORPass == NOTXORPASS)
        {
            pLocalDC->pbChange = (PBYTE) pLocalDC->pbRecord ;
            pLocalDC->lholdp32 = pLocalDC->lhpn32 ;
            pLocalDC->lholdbr32 = pLocalDC->lhbr32;
        }
    }
    ASSERTGDI((b == TRUE), "MF3216: DoBeginPath, BeginPath failed\n") ;

    return (b) ;
}

/***************************************************************************
*  EndPath  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoEndPath
(
 PLOCALDC pLocalDC
 )
{
    BOOL    b ;

    // Reset the global flag, turning off the path accumulation.

    pLocalDC->flags &= ~RECORDING_PATH ;

    b = EndPath(pLocalDC->hdcHelper) ;

    ASSERTGDI((b == TRUE), "MF3216: DoEndPath, EndPath failed\n") ;

    return (b) ;
}

/***************************************************************************
*  WidenPath  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoWidenPath
(
 PLOCALDC pLocalDC
 )
{
    BOOL    b ;

    b = WidenPath(pLocalDC->hdcHelper) ;

    ASSERTGDI((b == TRUE), "MF3216: DoWidenPath, WidenPath failed\n") ;

    return (b) ;
}

/***************************************************************************
*  SelectClipPath  - Win32 to Win16 Metafile Converter Entry Point
*
* History:
*  Tue Apr 07 17:05:37 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
**************************************************************************/

BOOL WINAPI DoSelectClipPath(PLOCALDC pLocalDC, INT iMode)
{
    INT    iROP2 ;
    BOOL   bRet = TRUE;
    WORD   wEscape;
    PathInfo16 pathInfo16 = { 0, 1, 1,
    { PS_NULL, {0,0}, 0},
    {BS_NULL, 0, 0},
    0 } ;

    BOOL   bNoClipping = bNoDCRgn(pLocalDC, DCRGN_CLIP);
    BOOL   bIgnorePS = FALSE;

    // Since we cannot do any other operations then an OR with multiple clipping regions
    // Only do the XOR if we are with a RGN_OR
    if ((iMode == RGN_COPY || iMode == RGN_AND ||
         (iMode == RGN_OR && bNoClipping)) &&
         (pLocalDC->flags & INCLUDE_W32MF_XORPATH))
    {
        if (pLocalDC->iXORPass == NOTXORPASS )
        {
            pLocalDC->iXORPass = DRAWXORPASS ;
            pLocalDC->iXORPassDCLevel = pLocalDC->iLevel ;
            iROP2 = GetROP2( pLocalDC->hdcHelper ) ;
            if( iROP2 == R2_COPYPEN || iROP2 == R2_NOTCOPYPEN )
            {
                if(!DoSaveDC(pLocalDC))
                    return FALSE;
                pLocalDC->iROP = iROP2;

                // Emit the Postscript escape to ignore the XOR
                wEscape = STARTPSIGNORE ;
                if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
                    return FALSE ;

                // Do it to the helper DC.
                SetROP2(pLocalDC->hdcHelper, R2_XORPEN);
                // Emit the Win16 metafile drawing order.
                if (!bEmitWin16SetROP2(pLocalDC, LOWORD(R2_XORPEN)))
                    return FALSE;

                MoveToEx( pLocalDC->hdcHelper, 0, 0, &(pLocalDC->pOldPosition ) ) ;
                MoveToEx( pLocalDC->hdcHelper, pLocalDC->pOldPosition.x, pLocalDC->pOldPosition.y, NULL );

                // Save this record number. When we pass again the last one will be the one that send the
                // Postscript clip path.
                pLocalDC->pbLastSelectClip = pLocalDC->pbRecord ;
                
                return bRet ;
            }
            pLocalDC->flags |= ERR_XORCLIPPATH;

            return FALSE;
        }
        else if(pLocalDC->iXORPass == DRAWXORPASS )
        {
            // Save this record number. When we pass again the last one will be the one that send the
            // Postscript clip path.
            pLocalDC->pbLastSelectClip = pLocalDC->pbRecord ;
            return TRUE;
        }
        else if( pLocalDC->iXORPass == ERASEXORPASS )
        {
            if (!ConvertPathToPSClipPath(pLocalDC, FALSE) ||
                !bEmitWin16EmitSrcCopyComment(pLocalDC, msocommentBeginSrcCopy))
            {
                return FALSE;
            }
            return TRUE;
        }
        else
        {
            ASSERT(FALSE);
        }
    }
    
    // Convert the clippath to a PS clippath
    if (ConvertPathToPSClipPath(pLocalDC, TRUE))
    {
        bIgnorePS = TRUE;
        pLocalDC->iSavePSClipPath++;
        // Emit the Postscript escape to ignore the pen change
        wEscape = STARTPSIGNORE ;
        if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;
    }

    // If there is no initial clip region and we are going to operate
    // on the initial clip region, we have to
    // create one.  Otherwise, GDI will create some random default
    // clipping region for us!

    if ((iMode == RGN_DIFF || iMode == RGN_XOR || iMode == RGN_OR)
        && bNoClipping)
    {
        HRGN hrgnDefault;

        if (!(hrgnDefault = CreateRectRgn((int) (SHORT) MINSHORT,
            (int) (SHORT) MINSHORT,
            (int) (SHORT) MAXSHORT,
            (int) (SHORT) MAXSHORT)))
        {
            ASSERTGDI(FALSE, "MF3216: CreateRectRgn failed");
            return(FALSE);
        }

        bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, hrgnDefault, RGN_COPY)
            != ERROR);
        ASSERTGDI(bRet, "MF3216: ExtSelectClipRgn failed");

        if (!DeleteObject(hrgnDefault))
            ASSERTGDI(FALSE, "MF3216: DeleteObject failed");

        if (!bRet)
            return(FALSE);
    }
    // Do it to the helper DC.
    // When we do this. It clears the path so it has to be
    // done when we are not using the path
    if(!SelectClipPath(pLocalDC->hdcHelper, iMode))
        return(FALSE);

    // Dump the clip region data.
    bRet = bDumpDCClipping(pLocalDC);

    if (bIgnorePS)
    {
        // Emit the Postscript escape to ignore the pen change
        wEscape = ENDPSIGNORE ;
        if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;
    }

    return(bRet);
}


/***************************************************************************
*  FlattenPath  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoFlattenPath
(
 PLOCALDC pLocalDC
 )
{
    BOOL    b;
    b = FlattenPath(pLocalDC->hdcHelper) ;
    ASSERTGDI((b == TRUE), "MF3216: DoFlattenPath, FlattenPath failed\n") ;

    return (b) ;
}

/***************************************************************************
*  AbortPath  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoAbortPath
(
 PLOCALDC pLocalDC
 )
{
    BOOL    b ;

    // Reset the global flag, turning off the path accumulation.

    pLocalDC->flags &= ~RECORDING_PATH ;

    b = AbortPath(pLocalDC->hdcHelper) ;

    // We cannot abort a path if we have a XORPass so return FALSE
    if (pLocalDC->flags & INCLUDE_W32MF_XORPATH)
        return FALSE ;

    ASSERTGDI((b == TRUE), "MF3216: DoAbortPath, AbortPath failed\n") ;

    return (b) ;
}

/***************************************************************************
*  CloseFigure  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoCloseFigure
(
 PLOCALDC pLocalDC
 )
{
    BOOL    b ;

    b = CloseFigure(pLocalDC->hdcHelper) ;

    ASSERTGDI((b == TRUE), "MF3216: DoCloseFigure, CloseFigure failed\n") ;

    return (b) ;
}

/***************************************************************************
*  DoRenderPath  - Common code for StrokePath, FillPath and StrokeAndFillPath.
**************************************************************************/

// Macro for copy a point in the path data.

#define MOVE_A_POINT(iDst, pjTypeDst, pptDst, iSrc, pjTypeSrc, pptSrc)  \
{                               \
    pjTypeDst[iDst] = pjTypeSrc[iSrc];              \
    pptDst[iDst]    = pptSrc[iSrc];             \
}

BOOL WINAPI DoRenderPath(PLOCALDC pLocalDC, INT mrType, BOOL psOnly)
{
    BOOL    b;
    PBYTE   pb    = (PBYTE) NULL;
    PBYTE   pbNew = (PBYTE) NULL;
    LPPOINT ppt, pptNew;
    LPBYTE  pjType, pjTypeNew;
    PDWORD  pPolyCount;
    INT     cpt, cptNew, cPolyCount;
    INT     i, j, jStart;
    LONG    lhpn32;
    LPVOID  pGdipFlatten = NULL;
    INT     count = 0;
    BOOL    transform = TRUE;
    WORD    wEscape;

    b = FALSE;              // assume failure
    ppt = NULL;
    pjType = NULL;

    // Flatten the path, to convert all the beziers into polylines.

    // Try to use GDIPlus and transform the points before hand, if we fail then
    // go back and try to do it with GDI

    if (GdipFlattenGdiPath(pLocalDC, &pGdipFlatten, &count))
    {
        ASSERT(pGdipFlatten != NULL);
        ppt    = (LPPOINT)pGdipFlatten;
        pjType = (PBYTE) (ppt + count);
        cpt = count;
        transform = FALSE;
    }
    else
    {
        if (!DoFlattenPath(pLocalDC))
        {
            RIPS("MF3216: DoRenderPath, FlattenPath failed\n");
            goto exit_DoRenderPath;
        }

        // Get the path data.

        // First get a count of the number of points.

        cpt = GetPath(pLocalDC->hdcHelper, (LPPOINT) NULL, (LPBYTE) NULL, 0);
        if (cpt == -1)
        {
            RIPS("MF3216: DoRenderPath, GetPath failed\n");
            goto exit_DoRenderPath;
        }

        // Check for empty path.

        if (cpt == 0)
        {
            b = TRUE;
            goto exit_DoRenderPath;
        }

        // Allocate memory for the path data.

        if (!(pb = (PBYTE) LocalAlloc
            (
            LMEM_FIXED,
            cpt * (sizeof(POINT) + sizeof(BYTE))
            )
            )
            )
        {
            RIPS("MF3216: DoRenderPath, LocalAlloc failed\n");
            goto exit_DoRenderPath;
        }

        // Order of assignment is important for dword alignment.

        ppt    = (LPPOINT) pb;
        pjType = (LPBYTE) (ppt + cpt);

        // Finally, get the path data.

        if (GetPath(pLocalDC->hdcHelper, ppt, pjType, cpt) != cpt)
        {
            RIPS("MF3216: DoRenderPath, GetPath failed\n");
            goto exit_DoRenderPath;
        }
    }
    // The path data is in record-time world coordinates.  They are the
    // coordinates we will use in the PolyPoly rendering functions below.
    //
    // Since we have flattened the path, the path data should only contain
    // the following types:
    //
    //   PT_MOVETO
    //   PT_LINETO
    //   (PT_LINETO | PT_CLOSEFIGURE)
    //
    // To simplify, we will close the figure explicitly by inserting points
    // and removing the (PT_LINETO | PT_CLOSEFIGURE) type from the path data.
    // At the same time, we will create the PolyPoly structure to prepare for
    // the PolyPolygon or PolyPolyline call.
    //
    // Note that there cannot be more than one half (PT_LINETO | PT_CLOSEFIGURE)
    // points since they are followed by the PT_MOVETO points (except for the
    // last point).  In addition, the first point must be a PT_MOVETO.
    //
    // We will also remove the empty figure, i.e. consecutive PT_MOVETO, from
    // the new path data in the process.

    // First, allocate memory for the new path data.

    cptNew = cpt + cpt / 2;
    if (!(pbNew = (PBYTE) LocalAlloc
        (
        LMEM_FIXED,
        cptNew * (sizeof(POINT) + sizeof(DWORD) + sizeof(BYTE))
        )
        )
        )
    {
        RIPS("MF3216: DoRenderPath, LocalAlloc failed\n");
        goto exit_DoRenderPath;
    }

    // Order of assignment is important for dword alignment.

    pptNew     = (LPPOINT) pbNew;
    pPolyCount = (PDWORD) (pptNew + cptNew);
    pjTypeNew  = (LPBYTE) (pPolyCount + cptNew);

    // Close the path explicitly.

    i = 0;
    j = 0;
    cPolyCount = 0;         // number of entries in PolyCount array
    while (i < cpt)
    {
        ASSERTGDI(pjType[i] == PT_MOVETO, "MF3216: DoRenderPath, bad pjType[]");

        // Copy everything upto the next closefigure or moveto.

        jStart = j;

        // copy the moveto
        MOVE_A_POINT(j, pjTypeNew, pptNew, i, pjType, ppt);
        i++; j++;

        if (i >= cpt)           // stop if the last point is a moveto
        {
            j--;            // don't include the last moveto
            break;
        }

        while (i < cpt)
        {
            MOVE_A_POINT(j, pjTypeNew, pptNew, i, pjType, ppt);
            i++; j++;

            // look for closefigure and moveto
            if (pjTypeNew[j - 1] != PT_LINETO)
                break;
        }

        if (pjTypeNew[j - 1] == PT_MOVETO)
        {
            i--; j--;           // restart the next figure from moveto
            if (j - jStart == 1)    // don't include consecutive moveto's
                j = jStart;     // ignore the first moveto
            else
                pPolyCount[cPolyCount++] = j - jStart;  // add one poly
        }
        else if (pjTypeNew[j - 1] == PT_LINETO)
        {               // we have reached the end of path data
            pPolyCount[cPolyCount++] = j - jStart;  // add one poly
            break;
        }
        else if (pjTypeNew[j - 1] == (PT_LINETO | PT_CLOSEFIGURE))
        {
            pjTypeNew[j - 1] = PT_LINETO;

            // Insert a PT_LINETO to close the figure.

            pjTypeNew[j] = PT_LINETO;
            pptNew[j]    = pptNew[jStart];
            j++;
            pPolyCount[cPolyCount++] = j - jStart;  // add one poly
        }
        else
        {
            ASSERTGDI(FALSE, "MF3216: DoRenderPath, unknown pjType[]");
        }
    } // while

    ASSERTGDI(j <= cptNew && cPolyCount <= cptNew,
        "MF3216: DoRenderPath, path data overrun");

    cptNew = j;

    // Check for empty path.

    if (cptNew == 0)
    {
        b = TRUE;
        goto exit_DoRenderPath;
    }

    // Now we have a path data that consists of only PT_MOVETO and PT_LINETO.
    // Furthermore, there is no "empty" figure, i.e. consecutive PT_MOVETO, in
    // the path.  We can finally render the picture with PolyPolyline or
    // PolyPolygon.

    if (mrType == EMR_STROKEPATH && !psOnly)
    {
        // Do StrokePath.

        b = DoPolyPolyline(pLocalDC, (PPOINTL) pptNew, (PDWORD) pPolyCount,
            (DWORD) cPolyCount, transform);
    }
    else // FILLPATH or PSOnly
    {
        // Setup our PS clippath
        if (pLocalDC->iXORPass == ERASEXORPASS || psOnly)
        {
            LONG lhpn32 = pLocalDC->lhpn32;
            LONG lhbr32 = pLocalDC->lhbr32;

            // Do it to the helper DC.
            DWORD oldRop = SetROP2(pLocalDC->hdcHelper, R2_NOP);
            // Emit the Win16 metafile drawing order.
            if (!bEmitWin16SetROP2(pLocalDC, LOWORD(R2_NOP)))
                goto exit_DoRenderPath;

            b = ConvertPolyPolygonToPolygons(pLocalDC, (PPOINTL) pptNew, 
                (PDWORD) pPolyCount, (DWORD) cptNew, (DWORD) cPolyCount, transform);

            if (!b)
            {
                ASSERTGDI(FALSE, "GPMF3216: DoRenderPath, PolyPolygon conversion failed");
                goto exit_DoRenderPath;
            }

            // Do it to the helper DC.
            SetROP2(pLocalDC->hdcHelper, oldRop);
            // Emit the Win16 metafile drawing order.
            if (!bEmitWin16SetROP2(pLocalDC, LOWORD(oldRop)))
                goto exit_DoRenderPath;

            wEscape = STARTPSIGNORE ;
            if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
                goto exit_DoRenderPath;
        }
        
        if (!psOnly)
        {
            // Do FillPath and StrokeAndFillPath.

            // If we are doing fill only, we need to select in a NULL pen.

            if (mrType == EMR_FILLPATH)
            {
                lhpn32 = pLocalDC->lhpn32;  // remember the previous pen
                if (!DoSelectObject(pLocalDC, ENHMETA_STOCK_OBJECT | NULL_PEN))
                {
                    ASSERTGDI(FALSE, "MF3216: DoRenderPath, DoSelectObject failed");
                    goto exit_DoRenderPath;
                }
            }

            // Do the PolyPolygon.

            b = DoPolyPolygon(pLocalDC, (PPOINTL) pptNew, (PDWORD) pPolyCount,
                (DWORD) cptNew, (DWORD) cPolyCount, transform);

            // Restore the previous pen.

            if (mrType == EMR_FILLPATH)
                if (!DoSelectObject(pLocalDC, lhpn32))
                    ASSERTGDI(FALSE, "MF3216: DoRenderPath, DoSelectObject failed");
        }

        if (pLocalDC->iXORPass == ERASEXORPASS || psOnly)
        {
            // End the PS ignore sequence
            wEscape = ENDPSIGNORE ;
            if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
                goto exit_DoRenderPath;
        }
    }


exit_DoRenderPath:

    
    // If we are doing a PSOnly path, then don't abort because we are gonna
    // use the path as a clipping region later
    if (!psOnly)
    {
        // Clear the path by calling AbortPath
        AbortPath(pLocalDC->hdcHelper);
    }
    if (pbNew)
        if (LocalFree((HANDLE) pbNew))
            RIPS("MF3216: DoRenderPath, LocalFree failed\n");
    if (pb)
        if (LocalFree((HANDLE) pb))
            RIPS("MF3216: DoRenderPath, LocalFree failed\n");

    if (pGdipFlatten)
    {
        if (LocalFree((HANDLE) pGdipFlatten))
            RIPS("MF3216: DoRenderPath, LocalFree failed\n");
    }
    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\misc.c ===
/*****************************************************************************
*
* misc - Entry points for Win32 to Win 16 converter
*
* Date: 7/1/91
* Author: Jeffrey Newman (c-jeffn)
*
* Copyright 1991 Microsoft Corp
*****************************************************************************/

#include "precomp.h"
#pragma hdrstop

extern fnGetTransform pfnGetTransform;

typedef struct EMROFFICECOMMENT
{
    EMR     emr;
    DWORD   cbData;             // Size of following fields and data
    DWORD   ident;              // GDICOMMENT_IDENTIFIER
    DWORD   iComment;           // Comment type e.g. GDICOMMENT_WINDOWS_METAFILE
} EMROFFICECOMMENT, *PEMROFFICECOMMENT;

BOOL WINAPI DoGdiCommentMultiFormats
(
 PLOCALDC pLocalDC,
 PEMRGDICOMMENT_MULTIFORMATS pemr
 );

 /***************************************************************************
 *  ExtFloodFill  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoExtFloodFill
(
 PLOCALDC    pLocalDC,
 int         x,
 int         y,
 COLORREF    crColor,
 DWORD       iMode
 )
{
    POINTL  ptl ;
    BOOL    b ;

    ptl.x = (LONG) x ;
    ptl.y = (LONG) y ;

    b = bXformRWorldToPPage(pLocalDC, &ptl, 1) ;
    if (b == FALSE)
        goto exit1 ;

    b = bEmitWin16ExtFloodFill(pLocalDC, LOWORD(ptl.x), LOWORD(ptl.y), crColor, LOWORD(iMode)) ;
exit1:
    return(b) ;

}

/***************************************************************************
*  MoveToEx  - Win32 to Win16 Metafile Converter Entry Point
*
*  NOTE ON CURRENT POSITION
*  ------------------------
*  There are only three Win16 functions that use and update the
*  current position (CP).  They are:
*
*      MoveTo
*      LineTo
*      (Ext)TextOut with TA_UPDATECP text alignment option
*
*  In Win32, CP is used in many more functions and has two
*  interpretations based on the state of the current path.
*  As a result, it is easier and more robust to rely on the
*  helper DC to keep track of the CP than doing it in the
*  converter.  To do this, we need to do the following:
*
*  1. The converter will update the CP in the helper DC in all
*     records that modify the CP.
*
*  2. The converter will keep track of the CP in the converted
*     metafile at all time.
*
*  3. In LineTo and (Ext)TextOut, the metafile CP is compared to
*     that of the helper DC.  If they are different, a MoveTo record
*     is emitted.  This is done in bValidateMetaFileCP().
*
*  4. The converter should emit a MoveTo record the first time the
*     CP is used in the converted metafile.
*
*  - HockL  July 2, 1992
**************************************************************************/
BOOL WINAPI DoMoveTo
(
 PLOCALDC  pLocalDC,
 LONG    x,
 LONG    y
 )
{
    BOOL    b ;
    POINTL  ptl ;

    // Whether we are recording for a path or acutally emitting
    // a drawing order we must pass the drawing order to the helper DC
    // so the helper can maintain the current positon.
    // If we're recording the drawing orders for a path
    // then just pass the drawing order to the helper DC.
    // Do not emit any Win16 drawing orders.
    POINTL p = {x, y};
    if (pfnSetVirtualResolution == NULL)
    {
        if (!bXformWorkhorse(&p, 1, &pLocalDC->xformRWorldToRDev))
        {
            return FALSE;
        }
    }
    b = MoveToEx(pLocalDC->hdcHelper, (INT) p.x, (INT) p.y, (LPPOINT) &ptl) ;
    if (pLocalDC->flags & RECORDING_PATH)
        return(b) ;

    // Update the CP in the converted metafile.
    b = bValidateMetaFileCP(pLocalDC, x, y) ;

    return(b) ;
}


/***************************************************************************
*  bValidateMetaFiloeCP  - Update the current position in the converted
*                          metafile.
*
*  x and y are assumed to be in the record time world coordinates.
*
**************************************************************************/
BOOL bValidateMetaFileCP(PLOCALDC pLocalDC, LONG x, LONG y)
{
    BOOL    b ;
    POINT   pt ;

    // Compute the new current position in the play time page coord.

    pt.x = x ;
    pt.y = y ;
    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &pt, 1L))
        return(FALSE);

    // No need to emit the record if the converted metafile has
    // the same CP.

    if (pLocalDC->ptCP.x == pt.x && pLocalDC->ptCP.y == pt.y)
        return(TRUE);

    // Call the Win16 routine to emit the move to the metafile.

    b = bEmitWin16MoveTo(pLocalDC, LOWORD(pt.x), LOWORD(pt.y)) ;

    // Update the mf16 current position.

    pLocalDC->ptCP = pt ;

    return(b) ;
}

/***************************************************************************
*  SaveDC  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoSaveDC
(
 PLOCALDC pLocalDC
 )
{
    BOOL    b;
    PLOCALDC pLocalDCNew;

    b = FALSE;

    // Save the helper DC's state first

    if (!SaveDC(pLocalDC->hdcHelper))
    {
        RIPS("MF3216: DoSaveDC, SaveDC failed\n");
        return(b);
    }

    // Allocate some memory for the LocalDC.

    pLocalDCNew = (PLOCALDC) LocalAlloc(LMEM_FIXED, sizeof(LOCALDC));
    if (pLocalDCNew == (PLOCALDC) NULL)
    {
        RIPS("MF3216: DoSaveDC, LocalAlloc failed\n");
        return(b);
    }

    // Copy the data from the current LocalDC to the new one just allocated.

    *pLocalDCNew = *pLocalDC;

    // Link in the new level.

    pLocalDC->pLocalDCSaved = pLocalDCNew;
    pLocalDC->iLevel++;
    
    // We don't want to restore a PS clip path unless we are doing it at the
    // same level
    pLocalDC->iSavePSClipPath = 0;

    // Emit Win16 drawing order.

    b = bEmitWin16SaveDC(pLocalDC);

    return(b);
}

/***************************************************************************
*  RestoreDC  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoRestoreDC
(
 PLOCALDC pLocalDC,
 int nSavedDC
 )
{
    BOOL     b;
    INT      iLevel;
    PLOCALDC pLocalDCNext;
    PLOCALDC pLocalDCTmp;
    BOOL     bRet;
    WORD     wEscape ;

    b = FALSE;

    // First check to make sure this is a relative save level.

    if (nSavedDC > 0)
        return(b);

    // Compute an absolute level.

    iLevel = pLocalDC->iLevel + nSavedDC;

    // The helper DC should have caught bogus levels.

    ASSERTGDI((iLevel >= 0) && ((UINT) iLevel < pLocalDC->iLevel),
        "MF3216: DoRestoreDC, Bogus RestoreDC");

    // Before restoring the DC level.. If we are in an XOR pass and we want to
    // restore the DC level to a level that is less than the Level that we started
    // the pass at, we simply treat this as the end of the pass and to the start over
    if( pLocalDC->iXORPass == DRAWXORPASS && iLevel <= pLocalDC->iXORPassDCLevel )
    {

        pLocalDC->iXORPass = OBJECTRECREATION ;
        if(!DoRemoveObjects( pLocalDC ))
            return FALSE ;

        bRet = DoMoveTo(pLocalDC, pLocalDC->pOldPosition.x, pLocalDC->pOldPosition.y) ;

        wEscape = ENDPSIGNORE;
        if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;

        wEscape = CLIP_SAVE ;
        if(!bEmitWin16Escape(pLocalDC, CLIP_TO_PATH, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;
        return TRUE ;

    }
    else if(pLocalDC->iXORPass == ERASEXORPASS && iLevel <= pLocalDC->iXORPassDCLevel )
    {
        pLocalDC->iXORPass = NOTXORPASS ;
        pLocalDC->pbChange = NULL ;

        DoSetRop2(pLocalDC, pLocalDC->iROP);

        if(!DoRestoreDC(pLocalDC, -1))
            return FALSE ;

        wEscape = CLIP_RESTORE ;
        if(!bEmitWin16Escape(pLocalDC, CLIP_TO_PATH, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;

        if (!bEmitWin16EmitSrcCopyComment(pLocalDC, msocommentEndSrcCopy))
        {
            return FALSE;
        }

        pLocalDC->iXORPassDCLevel = -1 ;
    }

    // We can't restore the DC if we are in an XOR pass
    // Restore the helper DC's state first
    // If we can restore the helper DC, we know that it is a balanced restore.
    // Otherwise, we return an error.

    if (!RestoreDC(pLocalDC->hdcHelper, nSavedDC))
        return(b);



    // Restore down to the level we want.
    wEscape = CLIP_RESTORE ;
    while(pLocalDC->iSavePSClipPath > 0)
    {
        bEmitWin16Escape(pLocalDC, CLIP_TO_PATH, sizeof(wEscape), (LPSTR)&wEscape, NULL);
        // Ignore failure in this case...
        pLocalDC->iSavePSClipPath--;
    }

    pLocalDCNext = pLocalDC->pLocalDCSaved;
    while ((UINT) iLevel < pLocalDCNext->iLevel)
    {
        pLocalDCTmp = pLocalDCNext;
        pLocalDCNext = pLocalDCNext->pLocalDCSaved;

        // For each DC that has the PSClipPath set, we need to restore a PSClipPath
        while(pLocalDCTmp->iSavePSClipPath > 0)
        {
            bEmitWin16Escape(pLocalDC, CLIP_TO_PATH, sizeof(wEscape), (LPSTR)&wEscape, NULL);
            // Ignore failure in this case...
            pLocalDCTmp->iSavePSClipPath--;
        }
        if (LocalFree(pLocalDCTmp))
            ASSERTGDI(FALSE, "MF3216: DoRestoreDC, LocalFree failed");
    }

    // Restore the state of our local DC to that level.

    // keep some of the attributes in the current DC

    pLocalDCNext->ulBytesEmitted        = pLocalDC->ulBytesEmitted;
    pLocalDCNext->ulMaxRecord           = pLocalDC->ulMaxRecord;
    pLocalDCNext->nObjectHighWaterMark  = pLocalDC->nObjectHighWaterMark;
    pLocalDCNext->pbCurrent             = pLocalDC->pbCurrent;
    pLocalDCNext->pbRecord              = pLocalDC->pbRecord;
    pLocalDCNext->pbChange              = pLocalDC->pbChange;
    pLocalDCNext->cW16ObjHndlSlotStatus = pLocalDC->cW16ObjHndlSlotStatus;
    pLocalDCNext->pW16ObjHndlSlotStatus = pLocalDC->pW16ObjHndlSlotStatus;
    pLocalDCNext->iROP                  = pLocalDC->iROP;
    pLocalDCNext->pOldPosition          = pLocalDC->pOldPosition;
    pLocalDCNext->iXORPass              = pLocalDC->iXORPass;
    pLocalDCNext->iXORPassDCLevel       = pLocalDC->iXORPassDCLevel;
    pLocalDCNext->pW16RecreationSlot    = pLocalDC->pW16RecreationSlot;

    // now restore the other attributes

    *pLocalDC = *pLocalDCNext;

    // Free the local copy of the DC.

    if (LocalFree(pLocalDCNext))
        ASSERTGDI(FALSE, "MF3216: DoRestoreDC, LocalFree failed");

    // Emit the record to the Win16 metafile.

    b = bEmitWin16RestoreDC(pLocalDC, LOWORD(nSavedDC)) ;

    return (b) ;
}

/***************************************************************************
*  SetRop2  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoSetRop2
(
 PLOCALDC  pLocalDC,
 DWORD   rop
 )
{
    BOOL    b ;

    if (pLocalDC->iXORPass == DRAWXORPASS)
    {
        // If we are drawing during an XOR pass then the only ROP we support is
        // SRCCOPY and then we set it to XOR
        if (rop == R2_COPYPEN)
        {
            rop = R2_XORPEN;
        }
        else
        {
            pLocalDC->flags |= ERR_XORCLIPPATH;
            return FALSE;
        }
    }
    // Do it to the helper DC.
    SetROP2(pLocalDC->hdcHelper, rop);

    // Emit the Win16 metafile drawing order.

    b = bEmitWin16SetROP2(pLocalDC, LOWORD(rop)) ;

    return(b) ;
}

/***************************************************************************
*  SetBkMode  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoSetBkMode
(
 PLOCALDC  pLocalDC,
 DWORD   iBkMode
 )
{
    BOOL    b ;

    // Do it to the helper DC.  It needs this in a path bracket
    // if a text string is drawn.

    SetBkMode(pLocalDC->hdcHelper, (int) iBkMode);

    // Emit the Win16 metafile drawing order.

    b = bEmitWin16SetBkMode(pLocalDC, LOWORD(iBkMode)) ;

    return(b) ;
}

/***************************************************************************
*  SetBkColor  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL APIENTRY DoSetBkColor
(
 PLOCALDC    pLocalDC,
 COLORREF    crColor
 )
{
    BOOL    b ;

    pLocalDC->crBkColor = crColor;  // used by brushes

    // Emit the Win16 metafile drawing order.

    b = bEmitWin16SetBkColor(pLocalDC, crColor) ;

    return(b) ;
}

/***************************************************************************
*  GdiComment  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoGdiComment
(
 PLOCALDC   pLocalDC,
 PEMR       pemr
 )
{
    BOOL    b;
    PEMRGDICOMMENT_PUBLIC pemrComment = (PEMRGDICOMMENT_PUBLIC) pemr;

    PEMROFFICECOMMENT pemrOffice = (PEMROFFICECOMMENT) pemr;

    if (pemrOffice->emr.nSize == sizeof(EMROFFICECOMMENT)
        && pemrOffice->ident == msosignature)
    {
        // This is not necessarily a SrcCopy comment, but an Office Comment
        return (bEmitWin16EmitSrcCopyComment(pLocalDC, LOWORD(pemrOffice->iComment)));
    }

    // If it's not a public comment, just return TRUE.
    if (pemrComment->emr.nSize < sizeof(EMRGDICOMMENT_PUBLIC)
        || pemrComment->ident != GDICOMMENT_IDENTIFIER)
        return(TRUE);

    // Handle public comments.
    // A public comment consists of a public comment identifier,
    // a comment type, plus any accompanying data.

    switch (pemrComment->iComment)
    {
    case GDICOMMENT_MULTIFORMATS:
        b = DoGdiCommentMultiFormats(pLocalDC, (PEMRGDICOMMENT_MULTIFORMATS) pemr);
        break;
    case GDICOMMENT_BEGINGROUP:
    case GDICOMMENT_ENDGROUP:
    case GDICOMMENT_WINDOWS_METAFILE:
    default:
        b = TRUE;
        break;
    }

    return(b) ;
}

BOOL WINAPI DoGdiCommentMultiFormats
(
 PLOCALDC pLocalDC,
 PEMRGDICOMMENT_MULTIFORMATS pemrcmf
 )
{
    DWORD  i;
    DWORD  cSizeOld;
    int    iBase;
    XFORM  xformNew, xformScale;
    POINTL aptlFrame[4];
    RECTL  rclFrame;
    UINT   cbwmfNew;
    SIZEL  szlDeviceNew, szlMillimetersNew;
    BOOL   bRet      = FALSE;
    PBYTE  pbwmfNew  = (PBYTE) NULL;
    HDC    hdcemfNew = (HDC) 0;
    HENHMETAFILE   hemf    = (HENHMETAFILE) 0;
    HENHMETAFILE   hemfNew = (HENHMETAFILE) 0;
    PENHMETAHEADER pemfh;
    WIN16LOGBRUSH  Win16LogBrush;
    PMETARECORD    pmr;
    VOID*          pvTemp = NULL;
#if DBG
    int    iSWO = 0;
    int    iSWE = 0;
#endif

    // We will convert the enhanced metafile format only.
    // Find the enhanced metafile data.

    for (i = 0; i < pemrcmf->nFormats; i++)
    {
        if (pemrcmf->aemrformat[i].dSignature == ENHMETA_SIGNATURE
            && pemrcmf->aemrformat[i].nVersion   <= META_FORMAT_ENHANCED)
            break;
    }

    // If we cannot find a recognized format, return failure.

    if (i >= pemrcmf->nFormats)
    {
        PUTS("MF3216: DoGdiCommentMultiFormats - no recognized format found\n");
        goto dgcmf_exit;
    }

    // Get the embedded enhanced metafile.

    hemf = SetEnhMetaFileBits((UINT) pemrcmf->aemrformat[i].cbData,
        &((PBYTE) &pemrcmf->ident)[pemrcmf->aemrformat[i].offData]);
    if (!hemf)
        goto dgcmf_exit;

    // Now the fun begins - we have to convert the enhanced metafile to
    // Windows metafile.
    // Since the multiformats record takes a logical rectangle, we have to
    // set up a proper transform for the enhanced metafile.  We do it by
    // creating a new enhanced metafile and playing the embedded metafile
    // into the new metafile with the proper transform setup.
    // In addition, the new metafile may have a different resolution than the
    // metafile.  We need to take this into account when setting up
    // the transform.

    // Get the world to device transform for the logical rectangle.

    if( pfnGetTransform != NULL )
    {
        if (!(pfnGetTransform)(pLocalDC->hdcHelper, XFORM_WORLD_TO_DEVICE, &xformNew))
            goto dgcmf_exit;
    }
    else
    {
        xformNew = xformIdentity ;
    }

    // Compute the device scales.

    szlDeviceNew.cx      = GetDeviceCaps(pLocalDC->hdcRef, HORZRES);
    szlDeviceNew.cy      = GetDeviceCaps(pLocalDC->hdcRef, VERTRES);
    szlMillimetersNew.cx = GetDeviceCaps(pLocalDC->hdcRef, HORZSIZE);
    szlMillimetersNew.cy = GetDeviceCaps(pLocalDC->hdcRef, VERTSIZE);
    pemfh = (PENHMETAHEADER) pLocalDC->pMf32Bits;

    xformScale.eM11 = ((FLOAT) szlDeviceNew.cx / (FLOAT) szlMillimetersNew.cx)
        / ((FLOAT) pemfh->szlDevice.cx / (FLOAT) pemfh->szlMillimeters.cx);
    xformScale.eM12 = 0.0f;
    xformScale.eM21 = 0.0f;
    xformScale.eM22 = ((FLOAT) szlDeviceNew.cy / (FLOAT) szlMillimetersNew.cy)
        / ((FLOAT) pemfh->szlDevice.cy / (FLOAT) pemfh->szlMillimeters.cy);
    xformScale.eDx  = 0.0f;
    xformScale.eDy  = 0.0f;

    // Compute the resulting transform to apply to the new metafile.

    if (!bCombineTransform(&xformNew, &xformNew, &xformScale))
        goto dgcmf_exit;

    // Create the new enhanced metafile.

    // Compute the new metafile frame.

    aptlFrame[0].x = pemrcmf->rclOutput.left;
    aptlFrame[0].y = pemrcmf->rclOutput.top;
    aptlFrame[1].x = pemrcmf->rclOutput.right;
    aptlFrame[1].y = pemrcmf->rclOutput.top;
    aptlFrame[2].x = pemrcmf->rclOutput.right;
    aptlFrame[2].y = pemrcmf->rclOutput.bottom;
    aptlFrame[3].x = pemrcmf->rclOutput.left;
    aptlFrame[3].y = pemrcmf->rclOutput.bottom;
    if (!bXformWorkhorse(aptlFrame, 4, &xformNew))
        goto dgcmf_exit;
    rclFrame.left   = MulDiv(100 * MIN4(aptlFrame[0].x, aptlFrame[1].x,
        aptlFrame[2].x, aptlFrame[3].x),
                 szlMillimetersNew.cx,
                 szlDeviceNew.cx);
    rclFrame.right  = MulDiv(100 * MAX4(aptlFrame[0].x, aptlFrame[1].x,
        aptlFrame[2].x, aptlFrame[3].x),
                 szlMillimetersNew.cx,
                 szlDeviceNew.cx);
    rclFrame.top    = MulDiv(100 * MIN4(aptlFrame[0].y, aptlFrame[1].y,
        aptlFrame[2].y, aptlFrame[3].y),
                 szlMillimetersNew.cy,
                 szlDeviceNew.cy);
    rclFrame.bottom = MulDiv(100 * MAX4(aptlFrame[0].y, aptlFrame[1].y,
        aptlFrame[2].y, aptlFrame[3].y),
                 szlMillimetersNew.cy,
                 szlDeviceNew.cy);

    hdcemfNew = CreateEnhMetaFileA(pLocalDC->hdcRef, (LPCSTR) NULL,
        (CONST RECT *) &rclFrame, (LPCSTR) NULL);
    if (!hdcemfNew)
        goto dgcmf_exit;

    if (!SetGraphicsMode(hdcemfNew, GM_ADVANCED))
        goto dgcmf_exit;

    // Set up the transform in the new metafile.

    if (!SetWorldTransform(hdcemfNew, &xformNew))
        goto dgcmf_exit;

    // Play the embedded metafile into the new metafile.
    // This call ensures balanced level etc.

    (void) PlayEnhMetaFile(hdcemfNew, hemf, (LPRECT) &pemrcmf->rclOutput);

    // Close the new metafile.

    hemfNew = CloseEnhMetaFile(hdcemfNew);
    hdcemfNew = (HDC) 0;        // used by clean up code below

    // Convert the new enhanced metafile to windows metafile.

    if (!(cbwmfNew = GetWinMetaFileBits(hemfNew, 0, (LPBYTE) NULL,
        MM_ANISOTROPIC, pLocalDC->hdcRef)))
        goto dgcmf_exit;

    if (!(pbwmfNew = (PBYTE) LocalAlloc(LMEM_FIXED, cbwmfNew)))
        goto dgcmf_exit;

    if (cbwmfNew != GetWinMetaFileBits(hemfNew, cbwmfNew, pbwmfNew,
        MM_ANISOTROPIC, pLocalDC->hdcRef))
        goto dgcmf_exit;

    // We now have the converted windows metafile.  We need to include it into
    // our current data stream.  There are a few things to be aware of:
    //
    // 1. Expand the object handle slot table.  The converted metafile may
    //    contain some undeleted objects.  These objects are likely
    //    the "stock" objects in the converter.  As a result, we need to
    //    expand the slot table by the number of object handles in the
    //    converted metafile.
    // 2. The object index must be changed to the current object index.
    //    We are going to do this by the lazy method, i.e. we will elevate
    //    the current object index base to one higher than the current max
    //    object index in the current data stream.  This is because Windows uses
    //    some an insane scheme for object index and this is the cheapest
    //    method.  We elevate the object index base by filling up the empty
    //    indexes with dummy objects that are freed when we are done.
    // 3. Remove the now useless comments.
    // 4. Skip header and eof.
    // 5. Set up the transform to place the embedded metafile into the data
    //    stream.  We know that the metafile bits returned by the converter
    //    contains only a SetWindowOrg and a SetWindowExt record.
    //    By implementation, we can simply remove both the SetWindowOrg and
    //    SetWindowExt records from the data stream.  The window origin and
    //    extents have been set up when we begin converting this enhanced
    //    metafile.

    // Expand the object handle slot table.

    if (((PMETAHEADER) pbwmfNew)->mtNoObjects)
    {
        cSizeOld = (DWORD) pLocalDC->cW16ObjHndlSlotStatus;
        if (cSizeOld + ((PMETAHEADER)pbwmfNew)->mtNoObjects > (UINT) (WORD) MAXWORD)
            goto dgcmf_exit;        // w16 handle index is only 16-bit

        pLocalDC->cW16ObjHndlSlotStatus += ((PMETAHEADER)pbwmfNew)->mtNoObjects;
        i = pLocalDC->cW16ObjHndlSlotStatus * sizeof(W16OBJHNDLSLOTSTATUS);

        // Allocate in a new pointer in case the allocation fails
        pvTemp = LocalReAlloc(pLocalDC->pW16ObjHndlSlotStatus, i, LMEM_MOVEABLE);
        if (pvTemp == NULL)
        {
            // Restore the old size and keep the memory...
            pLocalDC->cW16ObjHndlSlotStatus = cSizeOld;
            goto dgcmf_exit;
        }

        pLocalDC->pW16ObjHndlSlotStatus = (PW16OBJHNDLSLOTSTATUS) pvTemp;

        for (i = cSizeOld; i < pLocalDC->cW16ObjHndlSlotStatus; i++)
        {
            pLocalDC->pW16ObjHndlSlotStatus[i].use       = OPEN_AVAILABLE_SLOT;
            pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle = 0 ;
        }
    }

    // Find the new base for the object index.

    for (iBase = pLocalDC->cW16ObjHndlSlotStatus - 1; iBase >= 0; iBase--)
    {
        if (pLocalDC->pW16ObjHndlSlotStatus[iBase].use != OPEN_AVAILABLE_SLOT)
            break;
    }
    iBase++;

    // Fill up the object index table with dummy objects.

    Win16LogBrush.lbStyle = BS_SOLID;
    Win16LogBrush.lbColor = 0;
    Win16LogBrush.lbHatch = 0;

    for (i = 0; i < (DWORD) iBase; i++)
    {
        if (pLocalDC->pW16ObjHndlSlotStatus[i].use == OPEN_AVAILABLE_SLOT)
        {
            if (!bEmitWin16CreateBrushIndirect(pLocalDC, &Win16LogBrush))
                goto dgcmf_exit;
            pLocalDC->pW16ObjHndlSlotStatus[i].use = REALIZED_DUMMY;
        }
    }

    // Update the high water mark.

    if (iBase + ((PMETAHEADER) pbwmfNew)->mtNoObjects - 1 > pLocalDC->nObjectHighWaterMark)
        pLocalDC->nObjectHighWaterMark = iBase + ((PMETAHEADER) pbwmfNew)->mtNoObjects - 1;

    // Save DC states.

    if (!bEmitWin16SaveDC(pLocalDC))
        goto dgcmf_exit;

    // Enumerate the records and fix them up as necessary.

    for (pmr = (PMETARECORD) (pbwmfNew + sizeof(METAHEADER));
    pmr->rdFunction != 0;
    pmr = (PMETARECORD) ((PWORD) pmr + pmr->rdSize))
    {
        switch (pmr->rdFunction)
        {
        case META_SETWINDOWORG:
            ASSERTGDI(++iSWO <= 1,
                "MF3216: DoGdiCommentMultiFormats - unexpected SWO record\n");
            break;
        case META_SETWINDOWEXT:
            ASSERTGDI(++iSWE <= 1,
                "MF3216: DoGdiCommentMultiFormats - unexpected SWE record\n");
            break;

        case META_ESCAPE:
            if (!IS_META_ESCAPE_ENHANCED_METAFILE((PMETA_ESCAPE_ENHANCED_METAFILE) pmr))
                goto default_alt;
            break;

        case META_RESTOREDC:
            ASSERTGDI((int)(SHORT)pmr->rdParm[0] < 0,
                "MF3216: DoGdiCommentMultiFormats - bogus RestoreDC record\n");
            goto default_alt;

        case META_SELECTCLIPREGION:
            if (pmr->rdParm[0] != 0)    // allow for default clipping!
            {
                pmr->rdParm[0] += (WORD)iBase;
                pLocalDC->pW16ObjHndlSlotStatus[pmr->rdParm[0]].use = REALIZED_OBJECT;
            }
            goto default_alt;

        case META_FRAMEREGION:
        case META_FILLREGION:
            pmr->rdParm[1] += (WORD)iBase;
            pLocalDC->pW16ObjHndlSlotStatus[pmr->rdParm[1]].use = REALIZED_OBJECT;
            // fall through
        case META_PAINTREGION:
        case META_INVERTREGION:
        case META_DELETEOBJECT:
        case META_SELECTPALETTE:
        case META_SELECTOBJECT:
            pmr->rdParm[0] += (WORD)iBase;
            if (pmr->rdFunction != META_DELETEOBJECT)
                pLocalDC->pW16ObjHndlSlotStatus[pmr->rdParm[0]].use = REALIZED_OBJECT;
            else
                pLocalDC->pW16ObjHndlSlotStatus[pmr->rdParm[0]].use = OPEN_AVAILABLE_SLOT;
            // fall through
        default:
default_alt:
            if (!bEmit(pLocalDC, (PVOID) pmr, pmr->rdSize * sizeof(WORD)))
                goto dgcmf_exit;
            vUpdateMaxRecord(pLocalDC, pmr);
            break;
        }
    }

    // Restore DC states.

    if (!bEmitWin16RestoreDC(pLocalDC, (WORD) -1))
        goto dgcmf_exit;

    // Remove the dummy objects from the handle table.

    for (i = 0; i < (DWORD) iBase; i++)
    {
        if (pLocalDC->pW16ObjHndlSlotStatus[i].use == REALIZED_DUMMY)
        {
            if (!bEmitWin16DeleteObject(pLocalDC, (WORD) i))
                goto dgcmf_exit;
            pLocalDC->pW16ObjHndlSlotStatus[i].use = OPEN_AVAILABLE_SLOT;
        }
    }

    // Shrink the object handle slot table.

    if (((PMETAHEADER) pbwmfNew)->mtNoObjects)
    {
        DWORD cUndel = 0;       // number of objects not deleted
        DWORD iUndelMax = iBase - 1;    // the max undeleted object index

        for (i = iBase; i < pLocalDC->cW16ObjHndlSlotStatus; i++)
        {
            if (pLocalDC->pW16ObjHndlSlotStatus[i].use != OPEN_AVAILABLE_SLOT)
            {
                cUndel++;
                iUndelMax = i;
            }
        }

        pLocalDC->cW16ObjHndlSlotStatus = max(cSizeOld + cUndel, iUndelMax + 1);
    }

    // Everything is golden.

    bRet = TRUE;

dgcmf_exit:

    if (pbwmfNew)
        if (LocalFree(pbwmfNew))
            ASSERTGDI(FALSE, "MF3216: DoGdiCommentMultiFormats - LocalFree failed\n");

        if (hemf)
            DeleteEnhMetaFile(hemf);

        if (hdcemfNew)
            hemfNew = CloseEnhMetaFile(hdcemfNew);  // hemfNew will be deleted next

        if (hemfNew)
            DeleteEnhMetaFile(hemfNew);

        return(bRet);
}

/***************************************************************************
*  EOF  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL APIENTRY DoEOF
(
 PLOCALDC  pLocalDC
 )
{
    BOOL    b ;

    b = bEmitWin16EOF(pLocalDC) ;

    return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\preamble.c ===
/*****************************************************************************
*
* Preamble - Preamble routines for MF3216
*
* Date: 7/18/91
* Author: Jeffrey Newman (c-jeffn)
*
* Copyright 1991 Microsoft Corp
*****************************************************************************/


#include "precomp.h"
#pragma hdrstop

BOOL bSetWindowOrgAndExtToFrame(PLOCALDC pLocalDC, RECTL frame);
extern fnSetVirtualResolution pfnSetVirtualResolution;

BOOL GetFrameBounds(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header, RECTL *frameOut)
{

    FLOAT ecxPpmmPlay,        // cx pixels per millimeter play
          ecyPpmmPlay,        // cy pixels per millimeter play
          ecx01PpmmPlay,      // cx pixels per .01 millimeter play
          ecy01PpmmPlay,      // cy pixels per .01 millimeter play
          ecxPelsFrame,       // cx play-time frame in device units
          ecyPelsFrame,       // cy play-time frame in device units
          exPelsFrame,        // x play-time frame in device units
          eyPelsFrame ;       // y play-time frame in device units

    INT cxFrame,            // cx Picture Frame
        cyFrame,            // cy Picture Frame
        xFrame,             // x Picture Frame
        yFrame ;            // y Picture Frame

    SIZEL   szlFrame ;
    POINTL  ptlFrame ;

    ASSERT(frameOut != NULL);
    // Calculate the play-time (reference) pixels per millimeter.

    ecxPpmmPlay = (FLOAT) pLocalDC->cxPlayDevPels / (FLOAT) pLocalDC->cxPlayDevMM ;
    ecyPpmmPlay = (FLOAT) pLocalDC->cyPlayDevPels / (FLOAT) pLocalDC->cyPlayDevMM ;

    // Scale the pixels per millimeter to pixels per .01 millimeters.

    ecx01PpmmPlay = ecxPpmmPlay / 100.0f ;
    ecy01PpmmPlay = ecyPpmmPlay / 100.0f ;

    // Pickup the fram origin

    xFrame = pmf32header->rclFrame.left ;
    yFrame = pmf32header->rclFrame.top ;

    // Translate the frame origin to play-time-device units.

    exPelsFrame = ecx01PpmmPlay * (FLOAT) xFrame ;
    eyPelsFrame = ecy01PpmmPlay * (FLOAT) yFrame ;

    // Convert the Frame origin to play-time-page units.
    // (aka reference-logical units.)

    ptlFrame.x = (LONG) (exPelsFrame * pLocalDC->xformPDevToPPage.eM11 + 0.5f);
    ptlFrame.y = (LONG) (eyPelsFrame * pLocalDC->xformPDevToPPage.eM22 + 0.5f);

    if (!bCoordinateOverflowTest((PLONG) &ptlFrame, 2))
        return(FALSE);

    // Calculate the Frame width and height.

    cxFrame = pmf32header->rclFrame.right - pmf32header->rclFrame.left ;
    cyFrame = pmf32header->rclFrame.bottom - pmf32header->rclFrame.top ;

    if (cxFrame < 0)
    {
        ptlFrame.x += cxFrame;
        cxFrame = -cxFrame;
    }
    if (cyFrame < 0)
    {
        ptlFrame.y += cyFrame;
        cyFrame = -cyFrame;
    }

    // Convert the frame width and height into play-time-device units.
    // (aka reference-device units.)

    ecxPelsFrame = ecx01PpmmPlay * (FLOAT) cxFrame ;
    ecyPelsFrame = ecy01PpmmPlay * (FLOAT) cyFrame ;

    // Translate the play-time device units into play-time-page units.
    // (aka reference-device to reference-logical units.)
    // This is an identity transform for MM_ANISOTROPIC mode.  For other
    // fixed mapping modes, the SetWindowExt record has no effect.
    // The Frame is Inclusive-Inclusive so add 1 to make the WindowExt
    // Inclusive-Exclusive

    szlFrame.cx = (LONG) (ecxPelsFrame + 1.5f);
    szlFrame.cy = (LONG) (ecyPelsFrame + 1.5f);
    if (!bCoordinateOverflowTest((PLONG) &szlFrame, 2))
        return(FALSE);


    frameOut->left   = ptlFrame.x;
    frameOut->top    = ptlFrame.y;
    frameOut->right  = szlFrame.cx + ptlFrame.x;
    frameOut->bottom = szlFrame.cy + ptlFrame.y;
    return(TRUE);
}

/*----------------------------------------------------------------------------
*  DoHeader -  Emit the Win16 metafile header
*---------------------------------------------------------------------------*/
BOOL APIENTRY DoHeader(PLOCALDC pLocalDC, PENHMETAHEADER pemfheader)
{
    BOOL        b ;

    RECTL frameBounds;
    b = bInitHandleTableManager(pLocalDC, pemfheader) ;
    if (b == FALSE)
        goto error_exit ;

    b = bInitXformMatrices(pLocalDC, pemfheader, &frameBounds) ;
    if (b == FALSE)
        goto error_exit ;

    if (pfnSetVirtualResolution == NULL)
    {
        INT swap;
        // On Win9x create the helper DC here
        pLocalDC->hdcHelper = CreateCompatibleDC (NULL);
        if (pLocalDC->hdcHelper == (HDC) 0)
        {
            return FALSE;
        }

        pLocalDC->hbmpMem = CreateCompatibleBitmap(pLocalDC->hdcHelper,
            frameBounds.right - frameBounds.left,
            frameBounds.bottom - frameBounds.top);
        if (pLocalDC->hbmpMem == (HBITMAP) 0)
        {
            return FALSE;
        }

        SelectObject(pLocalDC->hdcHelper, pLocalDC->hbmpMem);
        frameBounds.right -= frameBounds.left;
        frameBounds.bottom -= frameBounds.top;
        frameBounds.left = frameBounds.top = 0;
    }

    // The metafile will always be memory based.

    pLocalDC->mf16Header.mtType    = MEMORYMETAFILE ;
    pLocalDC->mf16Header.mtVersion = 0x300 ;    // magic number for Win3.0
    pLocalDC->mf16Header.mtHeaderSize = sizeof (METAHEADER) / 2 ;

    // Init fields to 0.  They will be updated at the end of translation.

    pLocalDC->mf16Header.mtSize      = 0 ;
    pLocalDC->mf16Header.mtNoObjects = 0 ;
    pLocalDC->mf16Header.mtMaxRecord = 0 ;      // NOTE: We need a max record size.
    pLocalDC->mf16Header.mtNoParameters = 0 ;

    // Emit the MF16 metafile header to the metafile.

    b = bEmit(pLocalDC, &pLocalDC->mf16Header, sizeof(METAHEADER)) ;
    if (b == FALSE)
        goto error_exit ;

    if (pLocalDC->flags & INCLUDE_W32MF_COMMENT)
    {
        b = bHandleWin32Comment(pLocalDC) ;
        if (b == FALSE)
            goto error_exit ;
    }

    // Prepare the transform for the 16-bit metafile.  See comments in
    // xforms.c.

    // Emit the Win16 MapMode record

    b = bEmitWin16SetMapMode(pLocalDC, LOWORD(pLocalDC->iMapMode)) ;
    if (b == FALSE)
        goto error_exit ;

    // Set the Win16 metafile WindowExt to the size of the frame
    // in play-time device units.

    b = bSetWindowOrgAndExtToFrame(pLocalDC, frameBounds) ;
    if (b == FALSE)
    {
        RIPS("MF3216: DoHeader, bSetWindowOrgAndExtToFrame failure\n") ;
        goto error_exit ;
    }

error_exit:
    return(b) ;
}



/*----------------------------------------------------------------------------
* Calculate and Emit into the Win16 metafile a Window origin
* and extent drawing order
* that will set the Window Origin and Extent to the size of the picture  frame in
* play-time-page (reference-logical) units.
*---------------------------------------------------------------------------*/
BOOL bSetWindowOrgAndExtToFrame(PLOCALDC pLocalDC, RECTL frame)
{
    // Set the Window origin.

    if (!bEmitWin16SetWindowOrg(pLocalDC,
        (SHORT) frame.left,
        (SHORT) frame.top))
    {
        RIPS("MF3216: bEmitWin16SetWindowOrg failed\n") ;
        return(FALSE);
    }

    if (!bEmitWin16SetWindowExt(pLocalDC,
        (SHORT) (frame.right - frame.left),
        (SHORT) (frame.bottom - frame.top)))
    {
        RIPS("MF3216: bEmitWin16SetWindowExt failed\n") ;
        return(FALSE);
    }
    return(TRUE);
}


/*----------------------------------------------------------------------------
*  UpdateMf16Header - Update the metafile header with the:
*             metafile size,
*             number of objects,
*             the max record size.
*---------------------------------------------------------------------------*/
BOOL bUpdateMf16Header(PLOCALDC pLocalDC)
{
    BOOL    b ;
    INT     iCpTemp ;

    // Fill in the missing info in the Win16 metafile header.

    pLocalDC->mf16Header.mtSize      = pLocalDC->ulBytesEmitted / 2 ;
    pLocalDC->mf16Header.mtNoObjects = (WORD) (pLocalDC->nObjectHighWaterMark + 1) ;
    pLocalDC->mf16Header.mtMaxRecord = pLocalDC->ulMaxRecord ;

    // Reset the output buffer index to the beginning of the buffer.

    iCpTemp = pLocalDC->ulBytesEmitted ;
    pLocalDC->ulBytesEmitted = 0 ;

    // re-emit the Win16 metafile header.

    b = bEmit(pLocalDC, &pLocalDC->mf16Header, (DWORD) sizeof (pLocalDC->mf16Header)) ;

    pLocalDC->ulBytesEmitted = iCpTemp ;

    return (b) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\objects.c ===
/*****************************************************************************
 *
 * objects - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *
 *
 *  14-Jan-1992
 *  Jeffrey Newman
 *
 *  CR1:    14-Jan-1992 -   this entire comment and the design that it
 *                          specifies.
 *
 *  The Object system in mf3216.
 *
 *  Overview
 *
 *      The Win32 objects (represented by object handle indicies) must be
 *      mapped to Win16 objects (also represented by object handle indices).
 *      Win32 uses stock objects, Win16 does not.  MF3216 uses a scheme
 *      for lazy stock object creation.  Through lazy stock object creation
 *      no unused objects will be emitted into the Win16 metafile.
 *
 *      Objects in a Win16 metafile are maintained in an Object Table. The
 *      object table is not recorded in the Win16 metafile.  It is created at
 *      play-time. Each entry in the Win16-Object-Table is called a slot.
 *      Slots are allocated one per object.  If an object is deleted then the
 *      slot becomes available for the next object created.  The first object-
 *      slot, starting from 0, in a linear search, that is available will be
 *      used to hold the next create object request.
 *
 *      Objects in either a Win32 or a Win16 metafile are represented as an
 *      index into the Object Table.  Every object created must occupy
 *      the same slot at play-time that it would have occupied at record-time.
 *
 *      Win32 objects have an object ID (index in the handle table) recorded
 *      with them.  Win16 objects do not.
 *
 *  Data Structures
 *
 *      There are two primary data structures used in the translation of
 *      Win32 objects to Win16 objects.  Both of them are dynamically
 *      allocated arrays.  The size of these arrays are determined by
 *      estimating the number of objects required in the Win16 metafile from
 *      the size of the handle table used in the Win32 metafile.  The size of
 *      the handle table is recorded in the Win32 metafile header.
 *
 *      The data structure piW16ObjectHandleSlotStatus is used to represent
 *      the status of the Win16 handle table as it would appear at any point
 *      during the Win16 metafile playback process.  A slot is either in
 *      use or free.
 *
 *      The data structure piW32ToW16ObjectMap is a translation table
 *      from the Win32 object indicies to the Win16 object indicies.
 *      The position in the array (aka the index into the array) is the
 *      Win32 handle.  The value in this entry is the Win16 slot number
 *      for the handle.
 *
 *      The first 16 entries in piW32ToW16ObjectMap array are used for the
 *      stock objects.
 *
 *  Support Routines
 *
 *          bInitHandleTableManager
 *
 *              1]  Allocate memory for pW16ObjHndlSlotStatus and
 *                  piW32ToW16ObjectMap arrays.
 *
 *              2]  Initialize pW16ObjHndlSlotStatus and
 *                  piW32ToW16ObjectMap to empty and UNMAPPED respectively.
 *
 *              3]  Returns a TRUE if there were no problems with the
 *                  initialization, FALSE if anything went wrong.
 *
 *              4]  It is expected that this routie will be called once from
 *                  the entry level routine when translation is first started.
 *
 *          iNormalizeHandle
 *
 *              1]  The idea behind this routine is to isolate the handling
 *                  of stock object handles to one place.
 *
 *              2]  Input will be a Win32 handle index, either stock or a
 *                  standard object.
 *
 *              3]  Output will be the index of the entry in the
 *                  piW32ToW16ObjectMap table that corresponds to the W32
 *                  handle.  If an error is detected -1 is returned.
 *
 *              4]  All the stock objects will be between the range of 0
 *                  and LAST_STOCK, and all the non-stock objects will be
 *                  greater than LAST_STOCK.
 *
 *          iGetW16ObjectHandleSlot
 *
 *              1]  This routine searches the pW16ObjHndlSlotStatus array
 *                  looking for the first available open slot.
 *
 *              2]  Mark the slot found as to its intended use.
 *
 *              3]  Returns the first open slot if found, else return -1.
 *
 *              4]  In essence this routine mimics the actions of the
 *                  Win16 play-time handle allocation system, in either
 *                  Win3.0 or Win3.1
 *
 *              5]  We also keep track of the max object count here.
 *
 *          iAllocateW16Handle
 *
 *              1]  This routine actually does the handle allocation.
 *
 *              2]  It sets the entry in pW16ObjHndlSlotStatus array
 *                  for the slot allocated by iGetW16ObjectHandleSlot to
 *                  an "in-use" status (for the intended use).
 *
 *              3]  It returns a ihW16 (an index handle to the Win16 handle
 *                  table, aka the Win16 handle slot number).
 *
 *          iValidateHandle
 *
 *              1]  This routine does a lot more than validate a Win32 handle.
 *                  It does some limited error checking on the Win32 handle,
 *                  to make sure its within a reasonable range.  Then if a
 *                  Win16 handle table slot has already been allocated for
 *                  this Win32 handle it will return the Win16 handle that
 *                  was previously allocated.  Alternatively, if a Win16
 *                  handle has not been previously allocated for a Win32
 *                  STOCK handle it will allocate a W16 handle and return the
 *                  Win16 handle.  This function is called by FillRgn, FrameRgn
 *                  and SelectObject to allow lazy allocation of stock objects.
 *
 *              2]  Input is a Win32 handle, either a stock or a non-stock
 *                  handle.
 *
 *              3]  Output is a Win16 handle, this is the value in the
 *                  Win32-index of the piW32ToW16ObjectMap.  If a stock object
 *                  does not exist, it will create one.
 *
 *              4]  If there is an error a -1 is returned.
 *
 *      Doer Routines
 *
 *              All the Doers return a bool.  TRUE if everything went OK.
 *              FALSE if there were any problems.
 *
 *              NOTE: The Doers that create an object actually must do
 *              quite a bit of work to translate the object's prameters.
 *              This is in addition to managing the handle table.  The
 *              work outlined below just deals with the management of the
 *              handle table.
 *
 *          DoSelectObject
 *
 *              1]  For stock objects this is the workhorse routine.
 *
 *              2]  For normal, non-stock, objects this routine will verify
 *                  that an object has been created for this Win32 object-index.
 *                  Then it will emit a Win16SelectObject metafile record.
 *
 *              3]  For stock objects things get a little more complicated.
 *                  First this routine must make sure a Win16 object has been
 *                  created for this stock object.  If a Win16 object has not
 *                  been created yet, then it will be. After a Win16 object
 *                  is created a Win16SelectObject record will be emitted for
 *                  the object.
 *
 *          DoDeleteObject
 *
 *              1]  The object handle is checked for reasonable limits.
 *                  We will also make sure that the Win16 slot has a handle
 *                  allocated to it.  If it does not then we will return an
 *                  error.
 *
 *              2]  If this is a stock object we fail and return an error.
 *
 *              3]  If this is a non-stock object we emit a Win16DeleteObject
 *                  record.  Then we set pW16ObjHndlSlotStatus to
 *                  indicate that this slot is available.  We also set
 *                  piW32ToW16ObjectMap to -1 (UNMAPPED).
 *
 *          DoCreatePen
 *          DoExtCreatePen
 *          DoCreateBrushIndirect
 *          DoCreateMonoBrush
 *          DoCreateDIBPatternBrush
 *          DoExtCreateFont
 *
 *              1]  Make sure the Win32 handle is not already being used
 *                  for something else.  If it is return an error.
 *
 *              2]  Validate the handle for this Object.  This will return
 *                  a Win16 object table index (actually a slot number).
 *                  We really don't care what the slot number is as long
 *                  as we got one.  DoDeleteObject and DoSelectObject always
 *                  refer to handles by their Win32 object indicies, and there
 *                  is no place else where used.
 *
 *              3]  Emit a Win16CreateObject metafile record.
 *
 *
 *      Special Routines
 *
 *          bCommonRegionCode
 *          Need to list the bitblt routines that use handles also
 *
 *              1]  These routines just need to create objects in the Win16
 *                  metafile.  There are no corresponding objects in the Win32
 *                  metafile.
 *
 *              2]  Allocate a Win16 handle.
 *
 *              3]  Use the object as needed.  This includes emitting a
 *                  region or bitmap object into the Win16 metafile.
 *
 *              4]  De-allocate the object.  This include emitting a
 *                  DeleteObject record.
 *
 * CR1
 * Paths require the current pen to selected into the helperDC.
 * In order to keep track of create, select, & delete of the pen
 * object we will add an extra field to the W16ObjectHandleSlotStatus
 * array entries.  This new field will contain either a NULL handle
 * or a valid Win32 handle.  Currently only pens need to be selected
 * into the helper DC for paths, so they are the only objects whose
 * W32 handle field is not NULL.
 *
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define ABS(A)      ((A) < 0 ? (-(A)) : (A))

//  Stock objects                          Name              Stock
//                                                           Object
//                                                             ID

LOGBRUSH    albStock[] = {
    {BS_SOLID, 0x0FFFFFF, 0},           // White Brush          0
    {BS_SOLID, 0x0C0C0C0, 0},           // Ligh Grey Brush      1
    {BS_SOLID, 0x0808080, 0},           // Grey Brush           2
    {BS_SOLID, 0x0404040, 0},           // Dark Grey Brush      3
    {BS_SOLID, 0x0000000, 0},           // Black Brush          4
    {BS_HOLLOW, 0x0000000, 0}           // Hollow Brush         5
} ;

LOGPEN      alpnStock[] = {
    {PS_SOLID,  0, 0, 0x0FFFFFF},       // White Pen            6
    {PS_SOLID,  0, 0, 0x0000000},       // Black Pen            7
    {PS_NULL,   0, 0, 0x0FFFFFF}        // Null Pen             8
} ;

// Internal function prototypes.

BOOL bCreateStockObject(PLOCALDC pLocalDC, INT ihw32Norm) ;
BOOL bCreateStockFont(PLOCALDC pLocalDC, INT ihW32) ;

/***************************************************************************
 * bInitHandleTableManager - Init the Handle Table Manager.
 *
 *      1]  Allocate memory for pW16ObjHndlSlotStatus and
 *          piW32ToW16ObjectMap arrays.
 *
 *      2]  Initialize pW16ObjHndlSlotStatus and
 *          piW32ToW16ObjectMap to empty and UNMAPPED respectively.
 *
 *      3]  Returns a TRUE if there were no problems with the
 *          initialization, FALSE if anything went wrong.
 *
 *      4]  It is expected that this routie will be called once from
 *          the entry level routine when translation is first started.
 *
 **************************************************************************/
BOOL bInitHandleTableManager(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header)
{
BOOL    b ;
UINT    i ;

        b = FALSE ;

        // The total number of handles required will be the stock handles
        // plus the handles used by the Win32 metafile plus one extra
        // for temporary brush used in opaque rectangle in textout.

        pLocalDC->cW32ToW16ObjectMap = pmf32header->nHandles + (STOCK_LAST + 1) + 1;

        // Allocate storage for the translation map.

        i = pLocalDC->cW32ToW16ObjectMap * sizeof(INT) ;
        pLocalDC->piW32ToW16ObjectMap = (PINT) LocalAlloc(LMEM_FIXED, i) ;
        if (pLocalDC->piW32ToW16ObjectMap == NULL)
            goto error_exit ;

        // Initialize the W32 to W16 object map to UNMAPPED (-1).
        // Since we never will have mapping to -1 we can test for
        // -1 in the map to make sure we are not double allocating a slot.

        for (i = 0 ; i < pLocalDC->cW32ToW16ObjectMap ; i++)
            pLocalDC->piW32ToW16ObjectMap[i] = UNMAPPED ;

        // Allocate storage for the slot status tables.
        // The number of Win16 object table slot may expand during conversion
        // due to temporary bitmaps and regions.  It is my educated guess
        // that we will never need more than 5 extra slots, because we
        // only use a slot for a very short time, then free it.  We are
        // allocating 256 extra slots in the name of robustness.
    // Note that the multi-format comment record may take up some
    // of these slots and increase the high water mark for object index.
    // We need to expand the table when required.

        pLocalDC->cW16ObjHndlSlotStatus = pLocalDC->cW32ToW16ObjectMap + 256 ;
        if (pLocalDC->cW16ObjHndlSlotStatus > (UINT) (WORD) MAXWORD)
            goto error_exit ;       // w16 handle index is only 16-bit

        i = pLocalDC->cW16ObjHndlSlotStatus * sizeof(W16OBJHNDLSLOTSTATUS) ;
        pLocalDC->pW16ObjHndlSlotStatus
        = (PW16OBJHNDLSLOTSTATUS) LocalAlloc(LMEM_FIXED, i) ;
        if (pLocalDC->pW16ObjHndlSlotStatus == NULL)
            goto error_exit ;

        // Initialize the W16ObjectHandleSlotStatus to a state where every
        // handle is available.

        for (i = 0 ; i < pLocalDC->cW16ObjHndlSlotStatus ; i++)
        {
            pLocalDC->pW16ObjHndlSlotStatus[i].use       = OPEN_AVAILABLE_SLOT ;
            pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle = 0 ;
            pLocalDC->pW16ObjHndlSlotStatus[i].iXORPassCreation = NOTXORPASS ;
            pLocalDC->pW16ObjHndlSlotStatus[i].pbCreatRec = NULL ;
        }

    // Initialize the pW32hPal palette handle table.
    // This table is used to store the W32 palette handles created during
    // the conversion.

        pLocalDC->cW32hPal = pmf32header->nHandles;
    i = pLocalDC->cW32hPal * sizeof(HPALETTE);
        pLocalDC->pW32hPal = (HPALETTE *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, i) ;
    if (pLocalDC->pW32hPal == NULL)
            goto error_exit ;

    b = TRUE;

error_exit:
    if (!b)
    {
            if (pLocalDC->piW32ToW16ObjectMap)
        {
        if (LocalFree(pLocalDC->piW32ToW16ObjectMap))
            ASSERTGDI(FALSE, "MF3216: LocalFree failed");
                pLocalDC->piW32ToW16ObjectMap = (PINT) NULL;
        }

        if (pLocalDC->pW16ObjHndlSlotStatus)
        {
            if (LocalFree(pLocalDC->pW16ObjHndlSlotStatus))
                ASSERTGDI(FALSE, "MF3216: LocalFree failed");
            pLocalDC->pW16ObjHndlSlotStatus = NULL;
        }
    }

    return(b) ;
}


/***************************************************************************
 * bDeleteW16Object - Delete a W16 Object.
 *
 *  This is the routine that is called to Delete a W16 Object that has
 *  no corresponding W32 object.  Region and Bitmaps are two examples.
 **************************************************************************/
BOOL bDeleteW16Object(PLOCALDC pLocalDC, INT ihW16)
{
BOOL    b ;

    ASSERTGDI
    (
            pLocalDC->pW16ObjHndlSlotStatus[ihW16].use != OPEN_AVAILABLE_SLOT,
        "MF3216: bDeleteW16Object, bad use value"
    );

        // Mark the W16 Slot just freed as available.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].use = OPEN_AVAILABLE_SLOT ;

        // Emit a Win16 DeleteOject record for the Object

        b = bEmitWin16DeleteObject(pLocalDC, LOWORD(ihW16)) ;

        return (b) ;
}


/***************************************************************************
 * iGetW16ObjectHandleSlot - return the first W16 open slot in the handle
 *                           table.
 *
 *      1]  This routine searches the pW16ObjHndlSlotStatus array
 *          looking for the first available open slot.
 *
 *      2]  Mark the slot found as to its intended use.
 *
 *      3]  Returns the first open slot if found, else return -1.
 *
 *      4]  In essence this routine mimics the actions of the
 *          Win16 play-time handle allocation system, in either
 *          Win3.0 or Win3.1
 *
 *      5]  We also keep track of the max object count here.
 *
 **************************************************************************/
INT iGetW16ObjectHandleSlot(PLOCALDC pLocalDC, INT iIntendedUse)
{
BOOL    b ;
UINT    i ;

        b = FALSE ;

        // Search for an available slot.

        for (i = 0 ; i < pLocalDC->cW16ObjHndlSlotStatus ; i++)
        {
            if (pLocalDC->pW16ObjHndlSlotStatus[i].use == OPEN_AVAILABLE_SLOT)
            {
                b = TRUE ;
                break ;
            }
        }

        // If a slot was found then mark its intended use.
        // Also set the W32 handle that may be associated with this
        // W16 handle to NULL. (Meaning no association at this time.)

        if (b)
        {
            ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle == 0,
            "MF3216: iGetW16ObjectHandleSlot: w32Handle is not 0");

            pLocalDC->pW16ObjHndlSlotStatus[i].use       = iIntendedUse ;
            pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle = 0 ;
            pLocalDC->pW16ObjHndlSlotStatus[i].iXORPassCreation = pLocalDC->iXORPass ;
            pLocalDC->pW16ObjHndlSlotStatus[i].pbCreatRec = pLocalDC->pbRecord ;

        // Update the number of object counts.  This will be used
        // when we update the metafile header.

            if ((INT) i >= pLocalDC->nObjectHighWaterMark)
                pLocalDC->nObjectHighWaterMark = (INT) i;

            return((INT) i);
        }
        else
        {
            RIPS("MF3216: iGetW16ObjectHandleSlot, Slot not found\n") ;
            return(-1) ;
        }
}


/***************************************************************************
 * iNormalizeHandle
 *
 *  CR1 - this entire routine is part of the handle system redesign.
 *
 *     1]  The idea behind this routine is to isolate the handling
 *         of stock object handles to one place.
 *
 *     2]  Input will be a Win32 handle index, either stock or a
 *         standard object.
 *
 *     3]  Output will be the index of the entry in the
 *         piW32ToW16ObjectMap table that corresponds to the W32
 *         handle.  If an error is detected -1 is returned.
 *
 *     4]  All the stock objects will be between the range of 0
 *         and LAST_STOCK, and all the non-stock objects will be
 *         greater than LAST_STOCK.
 *
 **************************************************************************/
INT iNormalizeHandle(PLOCALDC pLocalDC, INT ihW32)
{
INT     ihW32Norm ;

        if (ihW32 & ENHMETA_STOCK_OBJECT)
        {
            ihW32Norm = ihW32 & ~ENHMETA_STOCK_OBJECT ;
            if ((UINT) ihW32Norm > STOCK_LAST)
            {
                RIPS("MF3216: iNormalizeHandle, bad stock object\n") ;
                ihW32Norm = -1 ;
            }
        }
        else
        {
            ihW32Norm = ihW32 + STOCK_LAST + 1 ;
            if ((UINT) ihW32Norm >= pLocalDC->cW32ToW16ObjectMap)
            {
                RIPS("MF3216: iNormalizeHandle, bad standard object\n") ;
                ihW32Norm = -1 ;
            }
        }

        return(ihW32Norm) ;
}


/***************************************************************************
 * iAllocateW16Handle
 *
 *  CR1 - this entire routine is part of the handle system redesign.
 *        It is to be called from the object creation routines.
 *
 *     1]  This routine actually does the handle allocation.
 *
 *     2]  It sets the entry in pW16ObjHndlSlotStatus array
 *         for the slot allocated by iGetW16ObjectHandleSlot to
 *         an "in-use" status (for the intended use).
 *
 *     3]  It returns a ihW16 (an index handle to the Win16 handle
 *         table, aka the Win16 handle slot number).
 *
 **************************************************************************/
INT iAllocateW16Handle(PLOCALDC pLocalDC, INT ihW32, INT iIntendedUse)
{
INT     ihW32Norm,
        ihW16 ;

        // Assume the worst, set up for a failed return code.

        ihW16 = -1 ;

        // Normalize the handle.

        ihW32Norm = iNormalizeHandle(pLocalDC, ihW32) ;
        if (ihW32Norm == -1)
            goto error_exit ;

        // Check for double allocation of a Win32 handle index.
        // If we find a double allocation, this would indicate an error
        // in the Win32 metafile.
        // Error out on this due to the possibility of
        // a brush being used for a bitmap, or some other wrong use of a handle.

        if (pLocalDC->piW32ToW16ObjectMap[ihW32Norm] != UNMAPPED)
        {
            RIPS("MF3216: iAllocateW16Handle, Double W32 handle allocation detected\n") ;
            goto error_exit ;
        }

        // Get a slot in the Win16 handle table.

        ihW16 = iGetW16ObjectHandleSlot(pLocalDC, iIntendedUse) ;
        if (ihW16 == -1)
            goto error_exit ;

        // Set the W32 to W16 slot mapping

        pLocalDC->piW32ToW16ObjectMap[ihW32Norm] = ihW16 ;

error_exit:
        return(ihW16) ;
}

/***************************************************************************
 * iValidateHandle
 *
 *  CR1 - this entire routine is part of the handle system redesign.
 *
 *     1]  This routine does a lot more than validate a Win32 handle.
 *         It does some limited error checking on the Win32 handle,
 *         to make sure its within a reasonable range.  Then if a
 *         Win16 handle table slot has already been allocated for
 *         this Win32 handle it will return the Win16 handle that
 *         was previously allocated.  Alternatively, if a Win16
 *         handle has not been previously allocated for a Win32
 *         STOCK handle it will allocate a W16 handle and return the
 *         Win16 handle.  This function is called by FillRgn, FrameRgn
 *         and SelectObject to allow lazy allocation of stock objects.
 *
 *     2]  Input is a Win32 handle, either a stock or a non-stock
 *         handle.
 *
 *     3]  Output is a Win16 handle, this is the value in the
 *         Win32-index of the piW32ToW16ObjectMap.  If a stock object
 *         does not exist, it will create one.
 *
 *     4]  If there is an error a -1 is returned.
 **************************************************************************/
INT iValidateHandle(PLOCALDC pLocalDC, INT ihW32)
{
INT     ihW32Norm,
        ihW16 ;

        // Assume the worst.

        ihW16 = -1 ;

        // NOTE: Normalizing the W32 handles takes care of checking
        // for a reasonable W32 handle value.

        ihW32Norm = iNormalizeHandle(pLocalDC, ihW32) ;
        if (ihW32Norm == -1)
            goto error_exit ;

        // Check the W32ToW16 map, to determine if this W32 handle has
        // already been allocated a W16 slot.

        ihW16 = pLocalDC->piW32ToW16ObjectMap[ihW32Norm] ;
        if (ihW16 == UNMAPPED)
        {
            // There is no mapping from W32 to W16.  This implies
            // that the object in question does not exist.  If this is
            // a stock object, then we will create the object at this time.
            // Alternatively, if this is a non-stock object then we have an
            // error condition.

            if ((DWORD) ihW32Norm <= STOCK_LAST)
            {
                if (bCreateStockObject(pLocalDC, ihW32))
                    ihW16 = pLocalDC->piW32ToW16ObjectMap[ihW32Norm] ;
        else
            ihW16 = -1 ;
            }
            else
            {
                RIPS("MF3216: iValidateHandle - Unmapped Standard Object\n") ;
            ihW16 = -1 ;
            }
        }

error_exit:
        return (ihW16) ;
}


/***************************************************************************
 *  DoDeleteObject  - Win32 to Win16 Metafile Converter Entry Point
 *
 *  CR1 - Most of this routine was rewritten to conform to the new
 *        objects management system.
 *
 *      1]  The object handle is checked for reasonable limits.
 *          We will also make sure that the Win16 slot has a handle
 *          allocated to it.  If it does not then we will return an
 *          error.
 *
 *      2]  If this is a stock object we fail and return an error.
 *
 *      3]  If this is a non-stock object we emit a Win16DeleteObject
 *          record.  Then we set pW16ObjHndlSlotStatus to
 *          indicate that this slot is available.  We also set
 *          piW32ToW16ObjectMap to -1 (UNMAPPED).
 *
 *      4]  If we are in the first pass of an XOR-ClipPath rendering
 *          then we verify if this object was created during this pass
 *          If the object wasn't created during this pass, we will need
 *          to recreate the object when we start the second pass so that
 *          any call to SelectObject will return with the proper object
 *          selected (GillesK)
 **************************************************************************/
BOOL WINAPI DoDeleteObject
(
PLOCALDC pLocalDC,
INT    ihObject
)
{
BOOL    b ;
INT     ihW16,
        ihW32Norm;

        // Assume the worst.

        b = FALSE ;

        // Normalize the W32 handle.

        ihW32Norm = iNormalizeHandle(pLocalDC, ihObject) ;
        if (ihW32Norm == -1)
            goto error_exit ;

        // Make sure we're not deleting a stock object.

        if ((DWORD) ihW32Norm <= STOCK_LAST)
        {
            PUTS("MF3216: DoDeleteObject, attempt to delete a stock object\n") ;
            return(TRUE);
        }

        // If this is a palette, then we do not delete the win16 object.
        // We do delete our local version of the palette.

    if (pLocalDC->pW32hPal && pLocalDC->pW32hPal[ihObject])
        {
        b = DeleteObject(pLocalDC->pW32hPal[ihObject]);
        pLocalDC->pW32hPal[ihObject] = 0;

            if (b == FALSE)
                RIPS("MF3216: DoDeleteObject - DeleteObject (hPalette) failed\n") ;
            return (b) ;
        }

        // Map the ihW32 to a ihW16 (object handle table slot).

        ihW16 = pLocalDC->piW32ToW16ObjectMap[ihW32Norm] ;
        if (ihW16 == UNMAPPED)
        {
            RIPS("MF3216: DoDeleteObject, attempt to delete a non-existent object\n");
            goto error_exit ;
        }

        // Make sure the object is one that we expect.
        // There is no region object or bitmap object in the enhanced metafiles.

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_BRUSH
           || pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_PEN
           || pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_FONT,
                 "MF3216: DoDeleteObject, Invalid Object Deletion\n") ;

        // If there was a Win32 handle associated with this Win16 handle
        // then the w32Handle field of the W16ObjHndlSlotStatus[ihW16]
        // entry in the handle slot status array will be non-null. If
        // it is non-null then we should delete the Win32 handle at this time.

        if (pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0)
        {
            if (!DeleteObject(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle))
            {
                ASSERTGDI(FALSE, "MF3216: DoDeleteObject, DeleteObject failed");
            }
            pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle = 0 ;
        }

        if( pLocalDC->iXORPass == DRAWXORPASS && pLocalDC->pW16ObjHndlSlotStatus[ihW16].iXORPassCreation != DRAWXORPASS )
        {
            // If we delete an object that was created before this pass
            // the we need to save the object creation record so that
            // we can recreate the object once this pass is over
            // We create a linked list of objects that we have to recreate.

            PW16RECREATIONSLOT pW16RecreationSlot = (PW16RECREATIONSLOT) LocalAlloc( LMEM_FIXED, sizeof( W16RECREATIONSLOT ) ) ;
            if( pW16RecreationSlot == NULL )
                goto error_exit ;

            pW16RecreationSlot->slot = ihW16 ;
            pW16RecreationSlot->pbCreatRec = pLocalDC->pW16ObjHndlSlotStatus[ihW16].pbCreatRec ;
            pW16RecreationSlot->pNext = pLocalDC->pW16RecreationSlot ;
            pLocalDC->pW16RecreationSlot = pW16RecreationSlot ;
        }

        // Mark the slot as available.
        // And set the map entry for the W32ToW16 map to unmapped.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].use = OPEN_AVAILABLE_SLOT ;
        pLocalDC->pW16ObjHndlSlotStatus[ihW16].pbCreatRec = NULL ;
        pLocalDC->piW32ToW16ObjectMap[ihW32Norm]   = UNMAPPED ;

        // Emit the delete drawing order.

        b = bEmitWin16DeleteObject(pLocalDC, LOWORD(ihW16)) ;

error_exit:
        return (b) ;
}

/***************************************************************************
 *  DoSelectObject  - Win32 to Win16 Metafile Converter Entry Point
 *
 *  CR1 - Major rewrite due to handle system redesign.
 *
 *  DoSelectObject
 *
 *      1]  For stock objects this is the workhorse routine.
 *
 *      2]  For normal, non-stock, objects this routine will verify
 *          that an object has been created for this Win32 object-index.
 *          Then it will emit a Win16SelectObject metafile record.
 *
 *      3]  For stock objects things get a little more complicated.
 *          First this routine must make sure a Win16 object has been
 *          created for this stock object.  If a Win16 object has not
 *          been created yet, then it will be. After a Win16 object
 *          is created a Win16SelectObject record will be emitted for
 *          the object.
 **************************************************************************/
BOOL WINAPI DoSelectObject
(
PLOCALDC pLocalDC,
LONG   ihObject
)
{
BOOL    b ;
INT     ihW16;

    // Assume the worst.

    b = FALSE ;

    // Make sure that the W16 object exists before we emit the
    // SelectObject record.  Stock objects may not have been created
    // and iValidateHandle will take care of creating them.

    ihW16 = iValidateHandle(pLocalDC, ihObject) ;
    if (ihW16 == -1)
        goto error_exit ;

    // Make sure the object is one that we expect.
    // There is no region object or bitmap object in the enhanced metafiles.

    ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_BRUSH
       || pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_PEN
       || pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_FONT,
             "MF3216: DoSelectObject, Invalid Object Deletion\n") ;

    // Remember the currently selected pen.  This is used in path and text.

    if (pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_PEN)
        pLocalDC->lhpn32 = ihObject;

    // Remember the currently selected brush.  This is used in text.

    if (pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_BRUSH)
        pLocalDC->lhbr32 = ihObject;

    // If there was a Win32 handle associated with this Win16 handle
    // then the w32Handle field of the W16ObjHndlSlotStatus[ihW16]
    // entry in the handle slot status array will be non-null. If
    // it is non-null then we should select the W32 object into the
    // helper DC at this time.

    if (pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0)
        SelectObject(pLocalDC->hdcHelper,
         pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle) ;

    b = bEmitWin16SelectObject(pLocalDC, LOWORD(ihW16)) ;

error_exit:
    return(b) ;
}


/***************************************************************************
 * bCreateStockObject
 **************************************************************************/
BOOL bCreateStockObject(PLOCALDC pLocalDC, INT ihW32)
{
BOOL        b ;
INT         i ;

        ASSERTGDI((ihW32 & ENHMETA_STOCK_OBJECT) != 0,
        "MF3216: bCreateStockObject, invalid stock handle");

        switch (ihW32 & ~ENHMETA_STOCK_OBJECT)
        {
            case WHITE_BRUSH:
            case LTGRAY_BRUSH:
            case GRAY_BRUSH:
            case DKGRAY_BRUSH:
            case BLACK_BRUSH:
            case NULL_BRUSH:
                b = DoCreateBrushIndirect(pLocalDC, ihW32, &albStock[ihW32 & ~ENHMETA_STOCK_OBJECT]) ;
                break ;

            case WHITE_PEN:
            case BLACK_PEN:
            case NULL_PEN:
                i = (ihW32 & ~ENHMETA_STOCK_OBJECT) - WHITE_PEN ;
                b = DoCreatePen(pLocalDC, ihW32, (PLOGPEN) &alpnStock[i]) ;
                break ;


            case OEM_FIXED_FONT:
            case ANSI_FIXED_FONT:
            case ANSI_VAR_FONT:
            case SYSTEM_FONT:
            case DEVICE_DEFAULT_FONT:
            case SYSTEM_FIXED_FONT:
            case DEFAULT_GUI_FONT:
                b = bCreateStockFont(pLocalDC, ihW32) ;
                break ;

            case DEFAULT_PALETTE:
            default:
        // Logical palettes are handled in DoSelectPalette and should
        // not get here.

                RIPS("MF3216: bCreateStockObject - Invalid Stock Object\n") ;
                b =FALSE ;
                break ;
        }

        return (b) ;
}


/***************************************************************************
* bCreateStockFont
**************************************************************************/
BOOL bCreateStockFont(PLOCALDC pLocalDC, INT ihW32)
{
    BOOL     b ;
    INT      i ;
    LOGFONTA LogFontA ;
    HANDLE   hFont ;

    b = FALSE ;

    ASSERTGDI((ihW32 & ENHMETA_STOCK_OBJECT) != 0,
        "MF3216: bCreateStockObject, invalid stock handle");

    // Get a handle to this logfont.

    hFont = GetStockObject(ihW32 & ~ENHMETA_STOCK_OBJECT) ;
    if (hFont == (HANDLE) 0)
    {
        RIPS("MF3216: bCreateStockFont, GetStockObject (font) failed\n") ;
        goto error_exit ;
    }

    // Get the logfont data.  Assume we get at least one char in the
    // facename string.

    i = GetObjectA(hFont, sizeof(LOGFONTA), &LogFontA) ;
    if (i <= (INT) offsetof(LOGFONTA,lfFaceName[0]))
    {
        PUTS("MF3216: bCreateStockFont - GetObjectW failed\n") ;
        goto error_exit ;
    }

    // Zero out the remaining logfont structure.

    for ( ; i < sizeof(LOGFONTA); i++)
        ((PBYTE) &LogFontA)[i] = 0;

    // Create a LogFont for this stock font in the Win16 metafile.

    b = DoExtCreateFont(pLocalDC,
        ihW32,
        &LogFontA);
error_exit:
    return (b) ;
}


/***************************************************************************
 *  CreateBrushIndirect  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoCreateBrushIndirect
(
PLOCALDC    pLocalDC,
INT         ihBrush,
LPLOGBRUSH  lpLogBrush
)
{
WIN16LOGBRUSH Win16LogBrush ;
BOOL          b ;
INT           ihW16 ;
LOGBRUSH      LogBrush ;

        b = FALSE ;

// Only 3 brush styles are allowed.

    if (lpLogBrush->lbStyle != BS_SOLID
     && lpLogBrush->lbStyle != BS_HATCHED
     && lpLogBrush->lbStyle != BS_HOLLOW)
            goto error_exit ;

// Make a copy of the logical brush.

        LogBrush = *lpLogBrush;

// The first 6 hatched styles map directly from Win32 to Win16.
// The remaining hatched brushes are simulated using DIB pattern
// brushes.  Note that the background color of a hatched brush
// is the current background color but that of a DIB pattern brush
// is given at create time!  We will use the current background color
// in the DIB pattern brush when it is created.  As a result, the
// output of these brushes may look different!

        if (LogBrush.lbStyle == BS_HATCHED)
        {
        switch (LogBrush.lbHatch)
        {
        case HS_HORIZONTAL:
        case HS_VERTICAL:
        case HS_FDIAGONAL:
        case HS_BDIAGONAL:
        case HS_CROSS:
        case HS_DIAGCROSS:
                break;

        default:
                RIPS("MF3216: Unknown hatched pattern\n");
        LogBrush.lbStyle = BS_SOLID;
        break;
        }
        }

// Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihBrush, REALIZED_BRUSH);
        if (ihW16 == -1)
            goto error_exit ;

// Create the w32 brush and store it in the w16 slot table.
// This brush is needed by the helper DC for BitBlt simulations.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
        = CreateBrushIndirect(lpLogBrush) ;

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
        "MF3216: CreateBrushIndirect failed");

// Assign all the Win32 brush attributes to Win16 brush attributes.

        Win16LogBrush.lbStyle = (WORD) LogBrush.lbStyle ;
        Win16LogBrush.lbColor = LogBrush.lbColor ;
        Win16LogBrush.lbHatch = (SHORT) LogBrush.lbHatch ;

// Call the Win16 routine to emit the brush to the metafile.

        b = bEmitWin16CreateBrushIndirect(pLocalDC, &Win16LogBrush) ;

error_exit:
        return(b) ;
}


/******************************Public*Routine******************************\
* CreateMonoDib
*
* This is the same as CreateBitmap except that the bits are assumed
* to be DWORD aligned and that the scans start from the bottom of the bitmap.
*
* This routine is temporary until CreateDIBitmap supports monochrome bitmaps
*
* History:
*  Wed Jul 01 11:02:24 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

HBITMAP CreateMonoDib
(
    LPBITMAPINFO pbmi,
    CONST BYTE * pjBits,
    UINT     iUsage
)
{
    HBITMAP hbm;

    ASSERTGDI(pbmi->bmiHeader.biPlanes == 1, "CreateMonoDib: bad biPlanes value");
    ASSERTGDI(pbmi->bmiHeader.biBitCount == 1, "CreateMonoDib: bad biBitCount value");

    hbm = CreateBitmap((int)  pbmi->bmiHeader.biWidth,
               (int)  pbmi->bmiHeader.biHeight,
               (UINT) 1,
               (UINT) 1,
               (CONST VOID *) NULL);
    if (!hbm)
    return(hbm);

    SetDIBits((HDC) 0, hbm, 0, (UINT) pbmi->bmiHeader.biHeight,
          (CONST VOID *) pjBits, pbmi, iUsage);

    return(hbm);
}


/***************************************************************************
 *  CreateMonoBrush  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoCreateMonoBrush
(
PLOCALDC    pLocalDC,
DWORD       ihBrush,
PBITMAPINFO pBitmapInfo,
DWORD       cbBitmapInfo,
PBYTE       pBits,
DWORD       cbBits,
DWORD       iUsage
)
{
BOOL        b ;
INT         ihW16;
DWORD       ul ;
BYTE        pbmi[sizeof(BITMAPINFOHEADER) + 2 * sizeof(RGBQUAD)];
HBITMAP     hbm;

        b = FALSE ;

// Need to make a copy of the bitmap info header,  for a few reasons
//  1] the memory mapped file is write protected.
//  2] the iUsage may be (is) use palatte indicies, and we need
//     use RGB colors.

        ((PBITMAPINFO) pbmi)->bmiHeader = pBitmapInfo->bmiHeader;

// Need to make sure the iUsage is DIB_RGB_COLORS
// and the palette is initialized to Black and White.

        ul = 0 ;
        ((PBITMAPINFO) pbmi)->bmiColors[0] = (*((RGBQUAD *) &(ul))) ;

        ul = 0x00ffffff ;
        ((PBITMAPINFO) pbmi)->bmiColors[1] = (*((RGBQUAD *) &(ul))) ;

// Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihBrush, REALIZED_BRUSH);
        if (ihW16 == -1)
            goto error_exit ;

// Create the w32 brush and store it in the w16 slot table.
// This brush is needed by the helper DC for BitBlt simulations.

    if ((hbm = CreateMonoDib
           (
               pBitmapInfo,
               (CONST BYTE *) pBits,
               (UINT) iUsage
           )
        )
       )
    {
        pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
        = CreatePatternBrush(hbm);

        if (!DeleteObject(hbm))
        ASSERTGDI(FALSE, "MF3216: DoCreateMonoBrush, DeleteObject failed");
    }

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
        "MF3216: CreatePatternBrush failed");

// Call the Win16 routine to emit the brush to the metafile.

        b = bEmitWin16CreateDIBPatternBrush(pLocalDC,
                                        (PBITMAPINFO) pbmi,
                                        sizeof(pbmi),
                                        pBits,
                                        cbBits,
                                        (WORD) DIB_RGB_COLORS,
                                        (WORD) BS_PATTERN  // Mono brush!
                       ) ;
error_exit:
        return(b) ;
}

/***************************************************************************
 *  CreateDIPatternBrush  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoCreateDIBPatternBrush
(
PLOCALDC    pLocalDC,
DWORD       ihBrush,
PBITMAPINFO pBitmapInfo,
DWORD       cbBitmapInfo,
PBYTE       pBits,
DWORD       cbBits,
DWORD       iUsage
)
{
BOOL    b;
INT     ihW16;
HBITMAP hbm;
PBYTE   pBits24;
DWORD   cbBits24;
BITMAPINFOHEADER bmih;

    hbm = (HBITMAP) 0;
    pBits24 = (PBYTE) NULL;
        b = FALSE ;

// Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihBrush, REALIZED_BRUSH);
        if (ihW16 == -1)
            goto error_exit ;

// Create the w32 brush and store it in the w16 slot table.
// We assume that the bitmap info is followed by the bits immediately,
// i.e. it is a packed dib.
// This brush is needed by the helper DC for BitBlt simulations.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
        = CreateDIBPatternBrushPt((LPVOID) pBitmapInfo, (UINT) iUsage);

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
        "MF3216: CreateDIBPatternBrushPt failed");

// We need to convert new bitmap info formats to the win3 formats.

    if (pBitmapInfo->bmiHeader.biPlanes != 1
     || pBitmapInfo->bmiHeader.biBitCount == 16
     || pBitmapInfo->bmiHeader.biBitCount == 32)
    {
        if (!(hbm = CreateDIBitmap(pLocalDC->hdcHelper,
                (LPBITMAPINFOHEADER) pBitmapInfo,
                CBM_INIT | CBM_CREATEDIB,
                pBits,
                (LPBITMAPINFO) pBitmapInfo,
                (UINT) iUsage)))
                goto error_exit ;

        bmih = *(PBITMAPINFOHEADER) pBitmapInfo;
        bmih.biPlanes       = 1;
        bmih.biBitCount     = 24;
        bmih.biCompression  = BI_RGB;
        bmih.biSizeImage    = 0;
        bmih.biClrUsed      = 0;
        bmih.biClrImportant = 0;

            cbBits24 = CJSCAN(bmih.biWidth,bmih.biPlanes,bmih.biBitCount)
                * ABS(bmih.biHeight);

        pBits24 = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBits24);
        if (pBits24 == (LPBYTE) NULL)
            goto error_exit;

        // Get bitmap info and bits in 24bpp.

        if (!GetDIBits(pLocalDC->hdcHelper,
               hbm,
               0,
               (UINT) bmih.biHeight,
               pBits24,
               (LPBITMAPINFO) &bmih,
               DIB_RGB_COLORS))
            goto error_exit;

            b = bEmitWin16CreateDIBPatternBrush(pLocalDC,
                                        (PBITMAPINFO) &bmih,
                                        sizeof(bmih),
                                        pBits24,
                                        cbBits24,
                                        (WORD) DIB_RGB_COLORS,
                                        (WORD) BS_DIBPATTERN
                       ) ;
    }
    else
    {

// Call the Win16 routine to emit the brush to the metafile.

            b = bEmitWin16CreateDIBPatternBrush(pLocalDC,
                                        pBitmapInfo,
                                        cbBitmapInfo,
                                        pBits,
                                        cbBits,
                                        (WORD) iUsage,
                                        (WORD) BS_DIBPATTERN
                       ) ;
    }

error_exit:
    if (hbm)
        DeleteObject(hbm);
    if (pBits24)
        LocalFree((HANDLE) pBits24);
        return(b) ;
}


/***************************************************************************
 * CreatePen  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoCreatePen
(
PLOCALDC    pLocalDC,
INT         ihPen,
PLOGPEN     pLogPen
)
{
EXTLOGPEN   ExtLogPen ;
BOOL        b ;

        ExtLogPen.elpPenStyle   = PS_GEOMETRIC | pLogPen->lopnStyle ;
        ExtLogPen.elpWidth      = (UINT) pLogPen->lopnWidth.x ;
        ExtLogPen.elpBrushStyle = BS_SOLID ;
        ExtLogPen.elpColor      = pLogPen->lopnColor ;
        ExtLogPen.elpNumEntries = 0 ;
        // ExtLogPen.elpHatch   = 0 ;
        // ExtLogPen.elpStyleEntry[0] = 0;

        b = DoExtCreatePen(pLocalDC, ihPen, &ExtLogPen) ;

        return (b) ;
}

/***************************************************************************
 *  ExtCreatePen  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoExtCreatePen
(
PLOCALDC    pLocalDC,
INT         ihPen,
PEXTLOGPEN  pExtLogPen
)
{
BOOL        b ;
WORD        iStyle ;
POINTS      ptsWidth ;
INT         ihW16 ;
UINT        iPenStyle ;
POINTL      ptlWidth ;
COLORREF    crColor ;

    b = FALSE;

    // Get pen style.

    iPenStyle = pExtLogPen->elpPenStyle & PS_STYLE_MASK ;
    switch(iPenStyle)
    {
        case PS_SOLID:
        case PS_DASH:
        case PS_DOT:
        case PS_DASHDOT:
        case PS_DASHDOTDOT:
        case PS_NULL:
        case PS_INSIDEFRAME:
            break ;

        case PS_ALTERNATE:
            iPenStyle = PS_DOT ;
            break ;

        case PS_USERSTYLE:
        default:
            // CR1: default to solid.
            iPenStyle = PS_SOLID ;
            break ;
    }

    // Get pen color.

    switch (pExtLogPen->elpBrushStyle)
    {
    case BS_SOLID:
    case BS_HATCHED:
        crColor   = pExtLogPen->elpColor ;
    break;

    // If the extended pen contains a hollow brush, then
    // we will emit a NULL pen.
    case BS_NULL:    // BS_HOLLOW is the same as BS_NULL
        iPenStyle = PS_NULL ;
        crColor   = 0 ;
    break;

    // Win3.x does not support pens with bitmap patterns.
    // So we will just use solid pens here.  Since we do not
    // know what pen color to use, we choose the text color.
    case BS_PATTERN:
    case BS_DIBPATTERN:
    case BS_DIBPATTERNPT:
        default:
        crColor   =  pLocalDC->crTextColor ;
    break;
    }

    // Get pen width.
    // If this is a cosmetic pen then the width is 0.

    ptlWidth.y = 0 ;
    if ((pExtLogPen->elpPenStyle & PS_TYPE_MASK) == PS_COSMETIC)
        ptlWidth.x = 0 ;
    else
        ptlWidth.x = pExtLogPen->elpWidth ;

    // Allocate the W16 handle.

    ihW16 = iAllocateW16Handle(pLocalDC, ihPen, REALIZED_PEN);
    if (ihW16 == -1)
        goto error_exit ;

    // This is where we need to create a pen for helper DC.
    // We do not select it into the helper DC at this time.

    pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
    = CreatePen((int) iPenStyle, ptlWidth.x, crColor) ;

    ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
    "MF3216: DoExtCreatePen, CreatePen failed");

    // Get pen width in play time page units.

    ptlWidth.x = (LONG) iMagnitudeXform(pLocalDC, (INT) ptlWidth.x, CX_MAG);

    // Set the Win16 pen attributes

    iStyle     = (WORD) iPenStyle  ;
    ptsWidth.x = (WORD) ptlWidth.x ;
    ptsWidth.y = (WORD) ptlWidth.y ;

    // Call the Win16 routine to emit the pen to the metafile.

    b = bEmitWin16CreatePen(pLocalDC, iStyle, &ptsWidth, crColor) ;

error_exit:
    return(b) ;
}


/***************************************************************************
 *  DoRemoveObjects  - Remove the objects that were created in the first
 *                     XOR pass
 **************************************************************************/

BOOL WINAPI DoRemoveObjects(
PLOCALDC pLocalDC
)
{
    BOOL b = TRUE ;
    UINT  i;
    INT   iNorm ;
    INT   ihW32Norm ;

    ASSERTGDI( pLocalDC->iXORPass == OBJECTRECREATION,
        "DoRemoveObject used with the wrong XOR Pass" ) ;

    // GillesK

    // We have to go through the list of 16-bit handles and delete
    // every single object that was created during this pass. This
    // is necessary to make sure that we have the exact same state
    // of objects when we restart the second pass so that no object
    // creation will fail and give wrong results.

    // Don't touch the stock objects
    for( i = STOCK_LAST + 1 ; i < pLocalDC->cW32ToW16ObjectMap ; i++ )
    {
        iNorm = pLocalDC->piW32ToW16ObjectMap[i] ;
        if( iNorm != UNMAPPED && pLocalDC->pW16ObjHndlSlotStatus[iNorm].iXORPassCreation == DRAWXORPASS )
        {

            // If there was a Win32 handle associated with this Win16 handle
            // then the w32Handle field of the W16ObjHndlSlotStatus[ihW16]
            // entry in the handle slot status array will be non-null. If
            // it is non-null then we should delete the Win32 handle at this time.

            b = DoDeleteObject( pLocalDC, i- ( STOCK_LAST + 1 ) ) ;
            if( !b )
                break ;
        }
    }

    return b ;
}


/***************************************************************************
 *  DoDeleteRecreationSlots  - Remove the recreation object slots because
 *                             they will not be used.
 **************************************************************************/

BOOL WINAPI DoDeleteRecreationSlots(
PLOCALDC pLocalDC
)
{
    BOOL b = TRUE ;

    while(pLocalDC->pW16RecreationSlot != NULL)
    {
        PW16RECREATIONSLOT l_pSlot = pLocalDC->pW16RecreationSlot ;
        pLocalDC->pW16RecreationSlot = pLocalDC->pW16RecreationSlot->pNext ;
        LocalFree(l_pSlot) ;
    }

    return b ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\text.c ===
/*****************************************************************************
 *
 * text - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

// GillesK, We don't have access to RtlUnicodeToMultiByteN so this call
// has been converted to a MultiByteToWideChar... We don't need to import
// anymore
/*
__declspec(dllimport)
ULONG
__stdcall
RtlUnicodeToMultiByteN(
    PCHAR MultiByteString,
    ULONG MaxBytesInMultiByteString,
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    );


ULONG
__stdcall
RtlUnicodeToMultiByteSize(
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    );

*/

extern fnSetVirtualResolution pfnSetVirtualResolution;

DWORD GetCodePage(HDC hdc)
{
  DWORD FAR *lpSrc = (DWORD FAR *)UIntToPtr(GetTextCharsetInfo(hdc, 0, 0));
  CHARSETINFO csi;

  TranslateCharsetInfo(lpSrc, &csi, TCI_SRCCHARSET);

  return csi.ciACP;
}


/***************************************************************************
 *  ExtTextOut  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoExtTextOut
(
PLOCALDC pLocalDC,
INT     x,                  // Initial x position
INT     y,                  // Initial y position
DWORD   flOpts,             // Options
PRECTL  prcl,               // Clipping rectangle
PWCH    pwch,               // Character array
DWORD   cch,                // Character count
PLONG   pDx,                // Inter-Character spacing
DWORD   iGraphicsMode,      // Graphics mode
INT     mrType              // Either EMR_EXTTEXTOUTW (Unicode)
                //     or EMR_EXTTEXTOUTA (Ansi)
)
{
    INT     i;
    BOOL    b;
    RECTS   rcs;
    POINTL  ptlRef;
    UINT    fTextAlign;
    WORD    fsOpts;
    PCHAR   pch, pchAlloc;
    PPOINTL pptl;
    POINTL  ptlAdjust;
    BOOL    bAdjustAlignment;
    ULONG   nANSIChars;
    PCHAR   pDBCSBuffer = NULL;
    POINTL  p = {x, y};

    pptl     = (PPOINTL) NULL;
    fsOpts   = (WORD) flOpts;
    pchAlloc = (PCHAR) NULL;
    bAdjustAlignment = FALSE;
    b        = FALSE;       // assume failure

    ASSERTGDI(mrType == EMR_EXTTEXTOUTA || mrType == EMR_EXTTEXTOUTW,
    "MF3216: DoExtTextOut: bad record type");

// We do not handle the advanced graphics mode here except when
// we are in a path!

// If we're recording the drawing orders for a path
// then just pass the drawing order to the helper DC.
// Do not emit any Win16 drawing orders.

    if (pLocalDC->flags & RECORDING_PATH)
    {
    // The helper DC is in the advanced graphics mode.  We need to set
    // it to the compatible graphics mode temporarily if necessary.

    if (iGraphicsMode != GM_ADVANCED)
        SetGraphicsMode(pLocalDC->hdcHelper, iGraphicsMode);

    if (pfnSetVirtualResolution == NULL)
    {
        if (!bXformRWorldToRDev(pLocalDC, &p, 1))
        {
            return FALSE;
        }
    }

    if (mrType == EMR_EXTTEXTOUTA)
        b = ExtTextOutA
        (
            pLocalDC->hdcHelper,
            (int)    p.x,
            (int)    p.y,
            (UINT)   flOpts,
            (LPRECT) prcl,
            (LPSTR)  pwch,
            (int)    cch,
            (LPINT)  pDx
        );
    else
        b = ExtTextOutW
        (
            pLocalDC->hdcHelper,
            (int)    p.x,
            (int)    p.y,
            (UINT)   flOpts,
            (LPRECT) prcl,
            (LPWSTR) pwch,
            (int)    cch,
            (LPINT)  pDx
        );

    // Restore the graphics mode.

    if (iGraphicsMode != GM_ADVANCED)
        SetGraphicsMode(pLocalDC->hdcHelper, GM_ADVANCED);

    return(b);
    }

// If the string uses the current position, make sure that the metafile
// has the same current position as that of the helper DC.

    fTextAlign = GetTextAlign(pLocalDC->hdcHelper);

    if (fTextAlign & TA_UPDATECP)
    {
    POINT   ptCP;

    // Update the current position in the converted metafile if
    // it is different from that of the helper DC.  See notes
    // in DoMoveTo().

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, &ptCP))
        goto exit_DoExtTextOut;

    // We don't need to update to change the clip region on the helper
    // DC in Win9x anymore because we are using a bitmap and not the
    // screen anymore. What we do need to do, is get the current position
    // of the cursor and convert it back to Logical Units... Make the
    // call on the helper DC and the convert the position back to
    // device units and save it.

    if (pfnSetVirtualResolution == NULL)
    {
       if (!bXformRDevToRWorld(pLocalDC, (PPOINTL) &ptCP, 1))
           return(b);
    }

    // Make sure that the converted metafile has the same CP as the
    // helper DC.

    if (!bValidateMetaFileCP(pLocalDC, ptCP.x, ptCP.y))
        goto exit_DoExtTextOut;

    // Initialize the XY start position.

    x = ptCP.x;
    y = ptCP.y;
    }

// Transform the XY start position.

    ptlRef.x = x;
    ptlRef.y = y;

    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &ptlRef, 1))
    goto exit_DoExtTextOut;

// If we have an opaque/clipping rectangle, transform it.
// If we have a strange transform, we will do the rectangle at this time.

    if (fsOpts & (ETO_OPAQUE | ETO_CLIPPED))
    {
    RECTL rcl;

    rcl = *prcl ;

    if (!(pLocalDC->flags & STRANGE_XFORM))
    {
        if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &rcl, 2))
        goto exit_DoExtTextOut;

        // The overflow test has been done in the xform.

        rcs.left   = (SHORT) rcl.left;
        rcs.top    = (SHORT) rcl.top;
        rcs.right  = (SHORT) rcl.right;
        rcs.bottom = (SHORT) rcl.bottom;
    }
    else
    {
        if (fsOpts & ETO_OPAQUE)
        {
        LONG     lhpn32;
        LONG     lhbr32;
        INT  ihW32Br;
        LOGBRUSH lbBkColor;

        // Remember the previous pen and brush

        lhpn32 = pLocalDC->lhpn32;
        lhbr32 = pLocalDC->lhbr32;

        if (DoSelectObject(pLocalDC, ENHMETA_STOCK_OBJECT | NULL_PEN))
        {
            lbBkColor.lbStyle = BS_SOLID;
            lbBkColor.lbColor = pLocalDC->crBkColor;
            lbBkColor.lbHatch = 0;

            // Get an unused W32 object index.

            ihW32Br = pLocalDC->cW32ToW16ObjectMap - (STOCK_LAST + 1) - 1;

                    if (DoCreateBrushIndirect(pLocalDC, ihW32Br, &lbBkColor))
            {
            if (DoSelectObject(pLocalDC, ihW32Br))
            {
                if (DoRectangle(pLocalDC, rcl.left, rcl.top, rcl.right, rcl.bottom))
                fsOpts &= ~ETO_OPAQUE;

                // Restore the previous brush.

                if (!DoSelectObject(pLocalDC, lhbr32))
                ASSERTGDI(FALSE,
                 "MF3216: DoExtTextOut, DoSelectObject failed");
            }
            if (!DoDeleteObject(pLocalDC, ihW32Br))
                ASSERTGDI(FALSE,
                "MF3216: DoExtTextOut, DoDeleteObject failed");
            }

            // Restore the previous pen.

            if (!DoSelectObject(pLocalDC, lhpn32))
            ASSERTGDI(FALSE,
                "MF3216: DoExtTextOut, DoSelectObject failed");
        }

        // Check if the rectangle is drawn.

        if (fsOpts & ETO_OPAQUE)
            goto exit_DoExtTextOut;
            }

            if (fsOpts & ETO_CLIPPED)
            {
        // Save the DC so that we can restore it when we are done

        if (!DoSaveDC(pLocalDC))
            goto exit_DoExtTextOut;

                fsOpts &= ~ETO_CLIPPED;     // need to restore dc

                if (!DoClipRect(pLocalDC, rcl.left, rcl.top,
                           rcl.right, rcl.bottom, EMR_INTERSECTCLIPRECT))
            goto exit_DoExtTextOut;
            }
    }
    }

// Convert the Unicode to Ansi.

    if (mrType == EMR_EXTTEXTOUTW)
    {
        // Get the codepage from the helperDC since the proper font and code page should have been selected.
        DWORD dwCP = GetCodePage(pLocalDC->hdcHelper);
        nANSIChars = WideCharToMultiByte(dwCP, 0, pwch, cch, NULL, 0, NULL, NULL);

        if (nANSIChars == cch)
        {
            pch = pchAlloc = (PCHAR) LocalAlloc(LMEM_FIXED, cch * sizeof(BYTE)) ;

            if (pch == (PCHAR) NULL)
            {
                RIPS("MF3216: ExtTextOut, pch LocalAlloc failed\n") ;
                goto exit_DoExtTextOut;
            }

            WideCharToMultiByte(dwCP, 0, pwch, cch, pch, cch, NULL, NULL);
        }
        else
        {
        // DBCS char string

            UINT    cjBufferSize;

            // we want DX array on a DWORD boundary

            cjBufferSize = ((nANSIChars+3)/4) * 4 * (sizeof(char) + sizeof(LONG));
            pchAlloc = pDBCSBuffer = LocalAlloc(LMEM_FIXED, cjBufferSize);

            if (pDBCSBuffer)
            {
            // start munging passed in parameters

                mrType = EMR_EXTTEXTOUTA;

                WideCharToMultiByte(dwCP, 0, pwch, cch, pDBCSBuffer, nANSIChars, NULL, NULL);

                pwch = (PWCH) pDBCSBuffer;
                pch = (PCHAR) pwch;
                cch = nANSIChars;

                if (pDx)
                {
                    ULONG ii, jj;

                    PULONG pDxTmp = (PLONG) &pDBCSBuffer[((nANSIChars+3)/4)*4];
                    for(ii=jj=0; ii < nANSIChars; ii++, jj++)
                    {
                        pDxTmp[ii] = pDx[jj];

                        // Use IsDBCSLeadByteEx to be able to specify the codepage
                        if(IsDBCSLeadByteEx(dwCP, pDBCSBuffer[ii]))
                        {
                            pDxTmp[++ii] = 0;
                        }
                    }

                    pDx = pDxTmp;
                }
            }
            else
            {
                goto exit_DoExtTextOut;
            }
        }
    }
    else
    {
        pch = (PCHAR) pwch ;
    }

// Transform the intercharacter spacing information.
// Allocate an array of (cch + 1) points to transform the points in,
// and copy the points to the array.
// ATTENTION: The following will not work if the current font has a vertical default
// baseline

    pptl = (PPOINTL) LocalAlloc(LMEM_FIXED, (cch + 1) * sizeof(POINTL));
    if (pptl == (PPOINTL) NULL)
    {
        RIPS("MF3216: ExtTextOut, pptl LocalAlloc failed\n") ;
    goto exit_DoExtTextOut;
    }

    pptl[0].x = x;
    pptl[0].y = y;
    for (i = 1; i < (INT) cch + 1; i++)
    {
    pptl[i].x = pptl[i-1].x + pDx[i-1];
    pptl[i].y = y;
    }

// If there is no rotation or shear then we can
// output the characters as a string.
// On the other hand, if there is rotation or shear then we
// have to output each character independently.

    if (!(pLocalDC->flags & STRANGE_XFORM))
    {
    // Win31 does not do text alignment correctly in some transforms.
    // It performs alignment in device space but win32 does it in the
    // notional space.  As a result, a win32 TextOut call may produce
    // different output than a similar call in win31.  We cannot
    // convert this correctly since if we make it works on win31,
    // it will not work on wow!

    PSHORT pDx16;

    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) pptl, (INT) cch + 1))
        goto exit_DoExtTextOut;

        // Convert it to the Dx array.  We do not need to compute it
    // as a vector since we have a scaling transform here.

    pDx16 = (PSHORT) pptl;
        for (i = 0; i < (INT) cch; i++)
            pDx16[i] = (SHORT) (pptl[i+1].x - pptl[i].x);

        // Emit the Win16 ExtTextOut metafile record.

        if (!bEmitWin16ExtTextOut(pLocalDC,
                                  (SHORT) ptlRef.x, (SHORT) ptlRef.y,
                                  fsOpts, &rcs, (PSTR) pch, (SHORT) cch,
                  (PWORD) pDx16))
        goto exit_DoExtTextOut;
    }
    else
    {
    // Deal with alignment in the world space.  We should really
    // do it in the notional space but with escapement and angles,
    // things gets complicated pretty easily.  We will try
    // our best to make it work in the common case.  We will not
    // worry about escapement and angles.

    ptlAdjust.x = 0;
    ptlAdjust.y = 0;

    switch (fTextAlign & (TA_LEFT | TA_RIGHT | TA_CENTER))
    {
    case TA_LEFT:           // default, no need to adjust x's
        break;
    case TA_RIGHT:          // shift the string by the string length
        bAdjustAlignment = TRUE;
        ptlAdjust.x = pptl[0].x - pptl[cch+1].x;
        break;
    case TA_CENTER:         // shift the string to the center
        bAdjustAlignment = TRUE;
        ptlAdjust.x = (pptl[0].x - pptl[cch+1].x) / 2;
        break;
    }

    // We will not adjust for the vertical alignment in the strange
    // transform case.  We cannot rotate the glyphs in any case.
#if 0
    switch (fTextAlign & (TA_TOP | TA_BOTTOM | TA_BASELINE))
    {
    case TA_TOP:            // default, no need to adjust y's
        break;
    case TA_BOTTOM:
        ptlAdjust.y = -logfont.height;
        break;
    case TA_BASELINE:
        ptlAdjust.y = -(logfont.height - logfont.baseline);
        break;
    }
#endif // 0

    // Adjust the character positions taking into account the alignment.

        for (i = 0; i < (INT) cch + 1; i++)
    {
        pptl[i].x += ptlAdjust.x;
        pptl[i].y += ptlAdjust.y;
    }

    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) pptl, (INT) cch + 1))
        goto exit_DoExtTextOut;

    // Reset the alignment since it has been accounted for.

    if (bAdjustAlignment)
            if (!bEmitWin16SetTextAlign(pLocalDC,
                (WORD) ((fTextAlign & ~(TA_LEFT | TA_RIGHT | TA_CENTER)) | TA_LEFT)))
        goto exit_DoExtTextOut;

    // Output the characters one at a time.

        for (i = 0 ; i < (INT) cch ; i++)
        {
        ASSERTGDI(!(fsOpts & (ETO_OPAQUE | ETO_CLIPPED)),
        "mf3216: DoExtTextOut: rectangle not expected");

            if (!bEmitWin16ExtTextOut(pLocalDC,
                                      (SHORT) pptl[i].x, (SHORT) pptl[i].y,
                                      fsOpts, (PRECTS) NULL,
                                      (PSTR) &pch[i], 1, (PWORD) NULL))
            goto exit_DoExtTextOut;
        }
    }

// Everything is golden.

    b = TRUE;

// Cleanup and return.

exit_DoExtTextOut:

    // Restore the alignment.

    if (bAdjustAlignment)
        (void) bEmitWin16SetTextAlign(pLocalDC, (WORD) fTextAlign);

    if ((flOpts & ETO_CLIPPED) && !(fsOpts & ETO_CLIPPED))
        (void) DoRestoreDC(pLocalDC, -1);

    if (pchAlloc)
        LocalFree((HANDLE) pchAlloc);

    if (pptl)
        LocalFree((HANDLE) pptl);

// Update the current position if the call succeeds.

    if (b)
    {
        if (fTextAlign & TA_UPDATECP)
        {
            // Update the helper DC.
             INT   iRet;
             POINTL pos;

             // We don't need to update to change the clip region on the helper
             // DC in Win9x anymore because we are using a bitmap and not the
             // screen anymore. What we do need to do, is get the current position
             // of the cursor and convert it back to Logical Units... Make the
             // call on the helper DC and the convert the position back to
             // device units and save it.

             if (pfnSetVirtualResolution == NULL)
             {
                 if (GetCurrentPositionEx(pLocalDC->hdcHelper, (LPPOINT) &pos))
                 {
                    b = bXformRDevToRWorld(pLocalDC, &pos, 1);
                    if (!b)
                    {
                        return(b);
                    }
                    MoveToEx(pLocalDC->hdcHelper, pos.x, pos.y, NULL);
                 }
             }

             // Finally, update the CP.
            if (mrType == EMR_EXTTEXTOUTA)
                ExtTextOutA
                (
                    pLocalDC->hdcHelper,
                    (int)    x,
                    (int)    y,
                    (UINT)   flOpts,
                    (LPRECT) prcl,
                    (LPSTR)  pwch,
                    (int)    cch,
                    (LPINT)  pDx
                );
            else
                ExtTextOutW
                (
                    pLocalDC->hdcHelper,
                    (int)    x,
                    (int)    y,
                    (UINT)   flOpts,
                    (LPRECT) prcl,
                    (LPWSTR) pwch,
                    (int)    cch,
                    (LPINT)  pDx
                );

            // Make the metafile CP invalid to force update
            // when it is used next time

            pLocalDC->ptCP.x = MAXLONG ;
            pLocalDC->ptCP.y = MAXLONG ;


            // Set the position in the helperDC back to Device units
            if (pfnSetVirtualResolution == NULL)
            {
                if (GetCurrentPositionEx(pLocalDC->hdcHelper, (LPPOINT) &pos))
                {
                   b = bXformRWorldToRDev(pLocalDC, &pos, 1);
                   if (!b)
                   {
                       return(b);
                   }
                   MoveToEx(pLocalDC->hdcHelper, pos.x, pos.y, NULL);
                }
            }
        }
    }

    return(b);
}


/***************************************************************************
 *  SetTextAlign  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetTextAlign
(
PLOCALDC pLocalDC,
DWORD   fMode
)
{
BOOL    b ;

    // Do it to the helper DC.  It needs this in a path bracket
    // and to update current position correctly.

    SetTextAlign(pLocalDC->hdcHelper, (UINT) fMode);

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetTextAlign(pLocalDC, LOWORD(fMode)) ;

        return(b) ;
}


/***************************************************************************
 *  SetTextColor  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetTextColor
(
PLOCALDC pLocalDC,
COLORREF    crColor
)
{
BOOL    b ;

        pLocalDC->crTextColor = crColor ;   // used by ExtCreatePen

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetTextColor(pLocalDC, crColor) ;

        return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\xforms.c ===
/*****************************************************************************
*
* xforms - Entry points for Win32 to Win 16 converter
*
* Date: 7/1/91
* Author: Jeffrey Newman (c-jeffn)
*
* Copyright 1991 Microsoft Corp
*----------------------------------------------------------------------------
*
*   September 21, 1991
*   Updated [20-Dec-1991]
*
*   Transformations in the Win32 to Win16 translator.
*
*   We are now supporting coordinate transformations from any
*   map mode to any map mode.
*
*   Where:
*        W    is the record-time-world to record-time-device xform.
*             (aka metafile-world to metafile-device.)
*        D    is the record-time device to play-time-device xform.
*             (aka metafile-device to reference-device.)
*        P    is the play-time-device to play-time-page xform.
*             (aka reference-device to reference-logical (or page).)
*
*   W is the transformation defined by the world xform, map mode, window org,
*   window extent, viewport org, and viewport extent in the
*   Win32 metafile. This transform is also known as the world to
*   device xform.
*
*   The normal composite xform is:
*
*         W D P
*        ^ ^ ^ ^
*        | | | +-  coordinate recorded in the win16 metafile.
*        | | |     play-time-page coordinates (aka reference-logical)
*        | | +---- play-time-device (reference-device) coordinates.
*        | +------ record-time device (metafile-device) coordinates.
*        +-------- world coordinates, recorded in Win32 metafile
*
*  The following comment is from Hockl's mail about transforms.
*
*   Message 11:
*   From hockl Thu Dec 19 11:50:54 1991
*   To: c-jeffn
*   Cc: johnc
*   Subject: Transform hints for the 32-16 converter
*   Date: Thu Dec 19 11:46:40 1991
*
*   Here are some transform hints for the converter:
*
*   A. Issue the following records immediately following the 16-bit header
*      record:
*
*      1. SetMapMode - use the given mapping mode, it is MM_ANISOTROPIC
*         in most cases.
*
*      2. SetWindowOrg - use the upper left coordinates of the rclFrame.
*         The coordinates are in the logical units of the reference DC.  So
*         you have to convert .01mm to the reference device coordinates, then
*         to the logical coordinates.  You can use the third transform
*         defined in B.4 below to convert device coordinates to the logical
*         coordinates of the reference device.  (Note the conversion formula
*         for LPtoDP is defined as Dx = (Lx - xWO) * xVE/xWE + xVO and so on).
*         This record is required to translate the converted picture to the
*         origin (see comments in GetMetaFileBitsEx).
*
*      3. SetWindowExt - use the extents of the rclFrame.
*      xExt = rclFrame.right - rclFrame.left;
*      yExt = rclFrame.bottom - rclFrame.top;
*         The extents are in the device units of the reference DC.  So
*         you have to convert .01mm to the reference device units.
*
*      These three records should always be generated.  Note that
*      SetWindowExt has no effect in all fixed mapping modes (e.g.
*      MM_LOENGLISH and MM_TEXT) and will have no effect when the converted
*      metafile is played.
*
*   B. Once you have issued the records, you need to use a xform helper DC
*      to convert the coordinates of all drawing orders.  To do this, you
*      need to do the following:
*
*      1. Create a xform helper DC.  This is a display info DC.
*
*      2. Call SetVirtualResolution to set the xform helper DC to that of
*         the metafile.  Use the metafile header's szlDevice and
*         szlMillimeters values to set the resolution.  This is to ensure
*         that the help DC maps the logical coordinates to the device
*         coordinates of the original metafile device.  If you reuse this
*         helper DC in conversion, make sure you initialize the transforms
*         using SetMapMode, ModifyWorldTransform, SetWindowOrgEx and
*         SetViewportOrgEx.  You can use the same code in the
*         CreateMetaFileEx function.
*
*      3. Once you have set up the xform helper DC, you should play all
*         32-bit xform calls into the helper DC.  But never emit any
*         xform records in the converter.  Everytime the xform is changed
*         in the helper DC, you need to get the world to device xform
*         (xformWDHelper) from the helper DC.  The xformWDHelper is used to
*         convert the coordinates of the drawing orders subsequently.
*         You can get it using the GetTransform(hdcHelper,XFORM_WORLD_TO_DEVICE)
*         private API.
*
*      4. To convert drawing order coordinates, you pass them through three
*         transforms.  The first is the xformWDHelper as computed above.  It
*         converts all logical coordiates into the device coordinates of
*         the original metafile device.  Note that this coordinates may
*         be different from the conversion's reference device.  For example,
*         the metafile may be created for a printer but the conversion is
*         requested for the display.  The second transform therefore scales
*         the coordinates from the metafile device to the reference device.
*         The scaled coordinates are in MM_TEXT units.  So we need the third
*         transform to convert the coordinates into the requested mapmode
*         units.  For MM_TEXT, MM_ANISOTROPIC and MM_ISOTROPIC mapmode, this
*         is the identity transform.  For the other mapmodes, this is a scale
*         transform.  The scale transform maps the device units of the
*         reference device to the logical units and can be computed using
*         szlDevice, szlMillimeters of the reference device (not the metafile
*         device!) and some predefined constants (to map millimeter to
*         english, for example).  Note that in these fixed mapping modes, the
*         y-axis goes in the opposite direction.  So make sure that the eM22
*         component of the third transform is negative.  As you can see, the
*         second and third transform never change in the duration of the
*         conversion.  So you can combine them into one to optimize computation
*         of the composite transform.  The composite transfom makes up of the
*         three transforms and is used to convert drawing order coordinates
*         into coordinates for the converted metafile.
*
*   C. To display a converted metafile in Windows 3.0, do the following before
*      calling PlayMetaFile:
*
*      1. If the mapmode is MM_ANISOTROPIC, which is 99.9% of the time, call
*         SetMapMode(MM_ANISOTROPIC), SetViewportOrigin and SetViewportExt.
*         The viewport origin defines the upper left corner of the display area
*         and the viewport origin defines the extent of the display area.  Both
*         are in device units.
*
*      2. If the mapmode is MM_ISOTROPIC, which is strange, call
*         SetMapMode(MM_ISOTROPIC), SetViewportOrigin and SetViewportExt.
*         This is almost the same as C.1 above.
*
*      3. If the mapmode is others, the metafile has a fixed physical size
*         and cannot be scaled easily without a lot of heck in the application.
*         Call SetViewportOrigin to define the upper left corner of the display
*         area.  The origin is in device coordinates.
*
*   I hope these steps are clear.  If you have any questions, feel free to
*   give me a call.
*
*       HockL
*
*
* Additions for Win9x support: GillesK 01/22/01
* To properly support Win9x, since it doesn't have a SetVirtualResolution
* function. We will create a bitmap HDC of the size of the metafile, and that
* will be our helperDC. Since the DC will start at 0,0 we translate it's origin
* to be the origin of the metafile, this is what xformDC is used for. We don't
* want to change anything in that transform and we don't support
* SetWorldTransform calls on Win9x, so to get around that we keep track of the
* current WorldToPage transform in xformW and the current PageToDevice transform
* in xformP. Everytime we use the helperDC we need to convert the logical units
* of the metafile into device units so that we don't overflow the helperDC
* bounds. And everytime we grab something from the helperDC we need to convert
* from DeviceUnits back into logical units or into WMF units. The helperDC on
* Win9x will always be in MM_TEXT and deviceUnits. The WMF that get created will
* always start at the origin to match with the origin of the helperDC. So the
* transforms that occur to convert from EMF to WMF are the following:
*
* xformW*xformP*xformDC*xformRDevToPDev*xformPDevToPPage
* \____________________/
*  xformRWorldToRDev
*
******************************************************************************/


#include "precomp.h"
#pragma hdrstop

extern fnGetTransform pfnGetTransform;
extern fnSetVirtualResolution pfnSetVirtualResolution;
extern BOOL GetFrameBounds(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header, RECTL *frameOut);

#define ABS(x) (((x) >= 0) ? (x) : (-x))

BOOL bComputeCompositeXform(PLOCALDC pLocalDC) ;
VOID vInitRecDevToPlayDevXform(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header) ;
VOID vMakeIso(PLOCALDC pLocalDC);
BOOL bInvertxform(PXFORM pxformSrc, PXFORM pxformDest);
BOOL bCalcPagexform(PMAPPING pMapping, PXFORM pxformDest);
/*
[19-Dec-1991]
A note about transformations.

  We will map into any map mode (when the converter is complete).

    We will use a helper DC to compute our transformation matrices.

      All the Win32 APIs that effect transformations or map modes
      will be sent to a helper DC.  The helper DC will return a transform
      matrix that converts from World Coordinates to Device Coordinates.
      This transformation matrix is: xformRWorldToRDev.

        xformRWorldToRDev is combined with the xformRDevToPPage matrix to produce
        the xformRWorldToPPage matrix.  All coordinates are mapped through the
        xformRWorldToPPage matrix.
*/


XFORM   xformIdentity = {(FLOAT) 1.0,
(FLOAT) 0.0,
(FLOAT) 0.0,
(FLOAT) 1.0,
(FLOAT) 0.0,
(FLOAT) 0.0 } ;


/****************************************************************************
*  Initialize all the matrices.
****************************************************************************/

// Units per millimeter array.  It must be in the order of MM_LOMETRIC,
// MM_HIMETRIC, MM_LOENGLISH, MM_HIENGLISH, MM_TWIPS.

FLOAT aeUnitsPerMM[5] = { 10.0f, 100.0f, 3.937f, 39.37f, 56.6928f };

BOOL bInitXformMatrices(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header, RECTL* frameBounds)
{
    // Init xformRDevToPDev.

    vInitRecDevToPlayDevXform(pLocalDC, pmf32header) ;

    // Init xformPDevToPPage and xformPPageToPDev.
    // (aka reference-device to reference-logical) transform.

    switch(pLocalDC->iMapMode)
    {
    case MM_TEXT:
    case MM_ANISOTROPIC:
    case MM_ISOTROPIC:
        pLocalDC->xformPDevToPPage = xformIdentity ;
        pLocalDC->xformPPageToPDev = xformIdentity ;
        break ;

    case MM_LOMETRIC:
    case MM_HIMETRIC:
    case MM_LOENGLISH:
    case MM_HIENGLISH:
    case MM_TWIPS:
        {
            FLOAT exUnitsPerPel;
            FLOAT eyUnitsPerPel;

            // Compute units per pixel.

            exUnitsPerPel = (FLOAT) pLocalDC->cxPlayDevMM
                / (FLOAT) pLocalDC->cxPlayDevPels
                * aeUnitsPerMM[pLocalDC->iMapMode - MM_LOMETRIC];

            eyUnitsPerPel = (FLOAT) pLocalDC->cyPlayDevMM
                / (FLOAT) pLocalDC-> cyPlayDevPels
                * aeUnitsPerMM[pLocalDC->iMapMode - MM_LOMETRIC];

            pLocalDC->xformPDevToPPage.eM11 = exUnitsPerPel;
            pLocalDC->xformPDevToPPage.eM12 = 0.0f;
            pLocalDC->xformPDevToPPage.eM21 = 0.0f;
            pLocalDC->xformPDevToPPage.eM22 = -eyUnitsPerPel;
            pLocalDC->xformPDevToPPage.eDx  = 0.0f;
            pLocalDC->xformPDevToPPage.eDy  = 0.0f;

            pLocalDC->xformPPageToPDev.eM11 = 1.0f / exUnitsPerPel;
            pLocalDC->xformPPageToPDev.eM12 = 0.0f;
            pLocalDC->xformPPageToPDev.eM21 = 0.0f;
            pLocalDC->xformPPageToPDev.eM22 = -1.0f / eyUnitsPerPel;
            pLocalDC->xformPPageToPDev.eDx  = 0.0f;
            pLocalDC->xformPPageToPDev.eDy  = 0.0f;
        }
        break ;
    }

    // Init xformRDevToPPage.
    // This xform is used in the SelectClipRegion code.

    if (!bCombineTransform(&pLocalDC->xformRDevToPPage,
        &pLocalDC->xformRDevToPDev,
        &pLocalDC->xformPDevToPPage))
    {
        RIPS("MF3216: InitXformMatrices, bCombineTransform failed\n");
        return(FALSE);
    }

    if (!GetFrameBounds(pLocalDC, pmf32header, frameBounds))
    {
        return FALSE;
    }

    // We are going to use the helper DC to compute the
    // Record-time-World to Record-time-Device transform.

    // Set the Helper DC virtual resolution to the Metafiles
    // resolution.
    if (pfnSetVirtualResolution != NULL)
    {
        if (!pfnSetVirtualResolution(pLocalDC->hdcHelper,
            (INT) pmf32header->szlDevice.cx,
            (INT) pmf32header->szlDevice.cy,
            (INT) pmf32header->szlMillimeters.cx,
            (INT) pmf32header->szlMillimeters.cy))
        {
            RIPS("MF3216: InitXformMatrices, SetVirtualResolution failed \n") ;
            return(FALSE);
        }
    }
    else
    {
        // We should be in an OS that doesn't support SetVirtualResolution
        // such as Win9x... Compute what is necessary...
        // From the mf3216 from Win98

        pLocalDC->xformRWorldToRDev = xformIdentity ;
        pLocalDC->xformRDevToRWorld = xformIdentity ;
        pLocalDC->xformW = xformIdentity ;
        pLocalDC->xformP = xformIdentity ;
        pLocalDC->xformDC = xformIdentity;
        pLocalDC->xformDC.eDx = (float) -frameBounds->left;
        pLocalDC->xformDC.eDy = (float) -frameBounds->top;
        pLocalDC->map.iMapMode = MM_TEXT;
        pLocalDC->map.iWex = 1;
        pLocalDC->map.iWey = 1;
        pLocalDC->map.iVex = 1;
        pLocalDC->map.iVey = 1;

        // pLocalDC->map.iWox = 0; // LocalDC is zero-initialized.
        // pLocalDC->map.iWoy = 0;
        // pLocalDC->map.iVox = 0;
        // pLocalDC->map.iVoy = 0;
    }
    // Init other matrices.

    return(bComputeCompositeXform(pLocalDC));
}

/****************************************************************************
*  Initialize the Record-time to Play-time scalers. (xformRDevToPDev)
****************************************************************************/
VOID vInitRecDevToPlayDevXform(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header)
{
    FLOAT   ecxRecDevPels,
        ecyRecDevPels,
        ecxRecDevMM,
        ecyRecDevMM,
        ecxPlayDevPels,
        ecyPlayDevPels,
        ecxPlayDevMM,
        ecyPlayDevMM,
        exMillsPerPelRec,
        eyMillsPerPelRec,
        exMillsPerPelPlay,
        eyMillsPerPelPlay ;


    // Pickup the physical dimensions of the record-time
    // device, both in pels and millimeters.
    // Converts them to floats

    ecxRecDevPels = (FLOAT) pmf32header->szlDevice.cx ;
    ecyRecDevPels = (FLOAT) pmf32header->szlDevice.cy ;
    ecxRecDevMM   = (FLOAT) pmf32header->szlMillimeters.cx ;
    ecyRecDevMM   = (FLOAT) pmf32header->szlMillimeters.cy ;


    // convert the Play-time device dimensions to floats.
    if (pLocalDC->hdcRef == NULL)
    {
        pLocalDC->cxPlayDevPels = pmf32header->szlDevice.cx ;
        pLocalDC->cyPlayDevPels = pmf32header->szlDevice.cy ;
        pLocalDC->cxPlayDevMM   = pmf32header->szlMillimeters.cx ;
        pLocalDC->cyPlayDevMM   = pmf32header->szlMillimeters.cy ;
    }

    ecxPlayDevPels = (FLOAT) pLocalDC->cxPlayDevPels ;
    ecyPlayDevPels = (FLOAT) pLocalDC->cyPlayDevPels ;
    ecxPlayDevMM   = (FLOAT) pLocalDC->cxPlayDevMM ;
    ecyPlayDevMM   = (FLOAT) pLocalDC->cyPlayDevMM ;

    // Calucalte the pels per millimeter for both the record-time
    // and play-time devices.

    exMillsPerPelRec = ecxRecDevMM / ecxRecDevPels ;
    eyMillsPerPelRec = ecyRecDevMM / ecyRecDevPels ;

    exMillsPerPelPlay = ecxPlayDevMM / ecxPlayDevPels ;
    eyMillsPerPelPlay = ecyPlayDevMM / ecyPlayDevPels ;

    // Init the Record-time-device to the Play-time-device transform.
    // aka  the Metafile-device to the Reference-device transform.

    pLocalDC->xformRDevToPDev.eM11 = exMillsPerPelRec / exMillsPerPelPlay ;
    pLocalDC->xformRDevToPDev.eM12 = (FLOAT) 0.0 ;
    pLocalDC->xformRDevToPDev.eDx  = (FLOAT) 0.0 ;
    pLocalDC->xformRDevToPDev.eM21 = (FLOAT) 0.0 ;
    pLocalDC->xformRDevToPDev.eM22 = eyMillsPerPelRec / eyMillsPerPelPlay ;
    pLocalDC->xformRDevToPDev.eDy  = (FLOAT) 0.0 ;

    return;
}


#if 0
/***************************************************************************
* vInvertMatrix - Invert a matrix
**************************************************************************/
VOID vInvertMatrix(PXFORM pxformSrc, PINVERSMATRIX pinvxfm)
{
    FLOAT   eM11, eM12, eM21, eM22, eDx, eDy,
        detA ;

    // dereference the matrix elements, just to make the rest of this
    // routine more readable.

    eM11 = pxformSrc->eM11 ;
    eM12 = pxformSrc->eM12 ;
    eM21 = pxformSrc->eM21 ;
    eM22 = pxformSrc->eM22 ;
    eDx  = pxformSrc->eDx ;
    eDy  = pxformSrc->eDy ;

    // First determine the determinant of the source matrix.

    detA = (eM11 * eM22) - (eM11 * eDy) ;

    pinvxfm->a1 = eM22 / detA ;
    pinvxfm->a2 = -(eM21 / detA) ;
    pinvxfm->a3 = ((eM21 * eDy) - (eDx * eM22)) / detA ;
    pinvxfm->b1 = -(eM12 / detA) ;
    pinvxfm->b2 = eM11 / detA ;
    pinvxfm->b3 = -(((eM11 * eDy) - (eDx * eM12)) / detA) ;
    pinvxfm->c1 = (FLOAT) 0.0 ;
    pinvxfm->c2 = (FLOAT) 0.0 ;
    pinvxfm->c3 = ((eM11 * eM22) - (eM21 * eM12)) / detA ;

    // This is just for testing.

    pinvxfm->a1 = pxformSrc->eM11 ;
    pinvxfm->a2 = pxformSrc->eM12 ;
    pinvxfm->a3 = (FLOAT) 0.0 ;
    pinvxfm->b1 = pxformSrc->eM21 ;
    pinvxfm->b2 = pxformSrc->eM22 ;
    pinvxfm->b3 = (FLOAT) 0.0 ;
    pinvxfm->c1 = pxformSrc->eDx ;
    pinvxfm->c2 = pxformSrc->eDy ;
    pinvxfm->c3 = (FLOAT) 1.0 ;

    return ;

}
#endif // 0


/***************************************************************************
* XformPDevToPPage  - Do a transform on the array of points passed in.
*
*                     This does the play-time (reference) device to
*                     play-time (reference) page (logical) transformation.
**************************************************************************/
BOOL bXformPDevToPPage(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount)
{
    BOOL    b ;

    b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformPDevToPPage) ;

    return (b) ;
}


/***************************************************************************
* XformPPageToPDev  - Do a transform on the array of points passed in.
*
*                     This does the play-time (reference) page (logical) to
*                     play-time (reference) device transformation.
**************************************************************************/
BOOL bXformPPageToPDev(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount)
{
    BOOL    b ;

    b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformPPageToPDev) ;

    return (b) ;
}


/***************************************************************************
* XformRWorldToRDev  - Do a transform on the array of points passed in.
*
*                      This does the Record-time (metafile) world to
*                      record-time device translation.
**************************************************************************/
BOOL bXformRWorldToRDev(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount)
{
    BOOL    b ;

    b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformRWorldToRDev) ;

    return (b) ;
}


/***************************************************************************
* XformRDevToRWorld  - Do a transform on the array of points passed in.
*
*                      This does the Record-device (metafile) world to
*                      record-time world translation.
**************************************************************************/
BOOL bXformRDevToRWorld(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount)
{
    BOOL    b ;

    b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformRDevToRWorld) ;

    return (b) ;
}


/***************************************************************************
* XformRWorldToPPage - Do a transform on the array of points passed in.
*
*            This is the workhorse translation routine.
*            This translates from record-time-world (aka metafile-world)
*            to record-time-device (aka metafile-device)  then from
*            record-time-device (aka metafile-device) to play-time-device
*            (aka reference-device) then from play-time-device
*            (aka reference-device) to play-time-page (reference-logical)
*            space.
**************************************************************************/
BOOL bXformRWorldToPPage(PLOCALDC pLocalDC, PPOINTL aptl, DWORD nCount)
{
    BOOL    b ;

    b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformRWorldToPPage) ;

    return (b) ;
}


/***************************************************************************
* bXformWorkhorse - Transformation Workhorse.
**************************************************************************/
BOOL bXformWorkhorse(PPOINTL aptl, DWORD nCount, PXFORM pXform)
{
    INT     i ;
    FLOAT   x, y, fx, fy ;
    BOOL    b ;

    for (i = 0 ; i < (INT) nCount ; i++)
    {
        x = (FLOAT) aptl[i].x ;
        y = (FLOAT) aptl[i].y ;
        fx = (x * pXform->eM11 + y * pXform->eM21 + pXform->eDx) ;
        fy = (x * pXform->eM12 + y * pXform->eM22 + pXform->eDy) ;
        aptl[i].x = (LONG) (fx + ((fx < 0.0) ? -0.5f : 0.5f)) ;
        aptl[i].y = (LONG) (fy + ((fy < 0.0) ? -0.5f : 0.5f)) ;
    }

    // Do the coordinate overflow detection.

    b = bCoordinateOverflowTest((PLONG) aptl, nCount * 2) ;

    return (b) ;

}

/***************************************************************************
* vXformWorkhorseFloat - Transformation Workhorse.
**************************************************************************/
VOID vXformWorkhorseFloat(PPOINTFL aptfl, UINT nCount, PXFORM pXform)
{
    UINT    i ;
    FLOAT   x, y ;

    for (i = 0 ; i < nCount ; i++)
    {
        x = aptfl[i].x ;
        y = aptfl[i].y ;
        aptfl[i].x = x * pXform->eM11 + y * pXform->eM21 + pXform->eDx;
        aptfl[i].y = x * pXform->eM12 + y * pXform->eM22 + pXform->eDy;
    }
}

/*****************************************************************************
* iMagnitudeXform - Transform the magnitude of a number from
*                   Record-time-World to Play-time-Page coordinate space.
*****************************************************************************/
INT iMagnitudeXform (PLOCALDC pLocalDC, INT value, INT iType)
{
    PXFORM  pxform ;
    INT     iRet ;

    pxform = &(pLocalDC->xformRWorldToPPage) ;

    iRet = iMagXformWorkhorse (value, pxform, iType) ;

    return (iRet) ;
}

/*****************************************************************************
* iMagXformWorkhorse - get the magnitude component of a translated vector
*****************************************************************************/
INT iMagXformWorkhorse (INT value, PXFORM pxform, INT iType)
{
    POINTFL aptfl[2] ;
    FLOAT   x1, y1, x2, y2;
    double  emag ;

    // Create a vector, from (0,0) to the point.

    aptfl[0].x = 0.0f ;
    aptfl[0].y = 0.0f ;

    if (iType == CX_MAG)
    {
        aptfl[1].x = (FLOAT) value ;
        aptfl[1].y = 0.0f ;
    }
    else
    {
        aptfl[1].x = 0.0f ;
        aptfl[1].y = (FLOAT) value ;
    }

    vXformWorkhorseFloat(aptfl, 2, pxform);

    // Now get the magnitude

    x1 = aptfl[0].x ;
    y1 = aptfl[0].y ;
    x2 = aptfl[1].x ;
    y2 = aptfl[1].y ;

    emag = sqrt((double) ((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))) ;

    return((INT) (emag + (double) 0.5f));
}


/*****************************************************************************
* bRotationTest -
*        return -  TRUE if there is a rotation or shear in this xform
*                  FALSE if there is none.
*****************************************************************************/
BOOL bRotationTest(PXFORM pxform)
{
    BOOL    b ;

    if (   (pxform->eM12 != (FLOAT) 0.0)
        || (pxform->eM21 != (FLOAT) 0.0)
        )
    {
        b = TRUE ;
    }
    else
    {
        b = FALSE ;
    }

    return(b) ;
}

/***************************************************************************
*  SetMapMode  - Win32 to Win16 Metafile Converter Entry Point
*
*  All the map mode translations are done by the helper DC.
*  The Helper DC always transforms to device, then we combine the
*  MetafileWorldToDevice with the DeviceToPage transform.
*  This becomes the Win32 to Win16 transform.
*
*  Some of the metafiles converted from Win16 to Win32 do not
*  define a Viewport extent.  Since the Isotropic and AnIsotropic
*  map modes are undefined if either the Viewport Extent or the Window
*  Extent are undefined we will default the Viewport extent to the
*  device extent in the Win32 metafile header.
*
*  Since we might not have set a Virtual Resolution... We might have
*  to calcultate the MapMode information ourselves. (GillesK)
**************************************************************************/
BOOL WINAPI DoSetMapMode
(
PLOCALDC pLocalDC,
DWORD    ulMapMode
)
{
    BOOL    b ;
    INT iMapMode = (INT) ulMapMode;

    if (iMapMode < MM_MIN || iMapMode > MM_MAX)
    {
        RIPS("MF3216: DoSetMapMode() - invalid map mode.");
        return FALSE;
    }

    if (pfnSetVirtualResolution != NULL)
    {
        if (!SetMapMode(pLocalDC->hdcHelper, ulMapMode))
        {
            ASSERTGDI(FALSE, "MF3216: DoSetMapMode failed\n");
            return(FALSE);
        }
    }
    else
    {
        PENHMETAHEADER pEmfHeader = (PENHMETAHEADER) pLocalDC->pMf32Bits;
        if (iMapMode == pLocalDC->map.iMapMode && iMapMode != MM_ISOTROPIC)
            return TRUE;

        switch (iMapMode) {
        case MM_TEXT:
            pLocalDC->map.iWex = 1;
            pLocalDC->map.iWey = 1;
            pLocalDC->map.iVex = 1;
            pLocalDC->map.iVey = 1;
            break;
        case MM_ISOTROPIC:
        case MM_LOMETRIC:
            pLocalDC->map.iWex = 10 * pEmfHeader->szlMillimeters.cx;
            pLocalDC->map.iWey = 10 * pEmfHeader->szlMillimeters.cy;
            pLocalDC->map.iVex =  pEmfHeader->szlDevice.cx;
            pLocalDC->map.iVey = -pEmfHeader->szlDevice.cy;
            break;
        case MM_HIMETRIC:
            pLocalDC->map.iWex = 100 * pEmfHeader->szlMillimeters.cx;
            pLocalDC->map.iWey = 100 * pEmfHeader->szlMillimeters.cy;
            pLocalDC->map.iVex =  pEmfHeader->szlDevice.cx;
            pLocalDC->map.iVey = -pEmfHeader->szlDevice.cy;
            break;
        case MM_LOENGLISH:
            pLocalDC->map.iWex = 1000 * pEmfHeader->szlMillimeters.cx;
            pLocalDC->map.iWey = 1000 * pEmfHeader->szlMillimeters.cy;
            pLocalDC->map.iVex =  254 * pEmfHeader->szlDevice.cx;
            pLocalDC->map.iVey = -254 * pEmfHeader->szlDevice.cy;
            break;
        case MM_HIENGLISH:
            pLocalDC->map.iWex = 10000 * pEmfHeader->szlMillimeters.cx;
            pLocalDC->map.iWey = 10000 * pEmfHeader->szlMillimeters.cy;
            pLocalDC->map.iVex =  254 * pEmfHeader->szlDevice.cx;
            pLocalDC->map.iVey = -254 * pEmfHeader->szlDevice.cy;
            break;
        case MM_TWIPS:
            pLocalDC->map.iWex = 14400 * pEmfHeader->szlMillimeters.cx;
            pLocalDC->map.iWey = 14400 * pEmfHeader->szlMillimeters.cy;
            pLocalDC->map.iVex =  254 * pEmfHeader->szlDevice.cx;
            pLocalDC->map.iVey = -254 * pEmfHeader->szlDevice.cy;
            break;
        case MM_ANISOTROPIC:
            break;
        default:
            break;
        }
    }
    pLocalDC->map.iMapMode = iMapMode;

    b = bComputeCompositeXform(pLocalDC) ;

    return (b) ;
}


/***************************************************************************
*  ScaleWindowsExtEx  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoScaleWindowExt
(
 PLOCALDC pLocalDC,
 INT      Xnum,
 INT      Xdenom,
 INT      Ynum,
 INT      Ydenom
 )
{
    BOOL    b ;
    INT   xOrg, yOrg;

    // Set the Windows extent
    if (pfnSetVirtualResolution != NULL)
    {
        if (!ScaleWindowExtEx(pLocalDC->hdcHelper,
            Xnum, Xdenom,
            Ynum, Ydenom,
            (LPSIZE) 0))
        {
            ASSERTGDI(FALSE, "MF3216: DoScaleWindowExt failed\n");
            return(FALSE);
        }
    }
    else
    {
        if (pLocalDC->map.iMapMode <= MM_MAX_FIXEDSCALE)
            return FALSE;


        // Get the window or viewport extents.
        xOrg = pLocalDC->map.iWex;
        yOrg = pLocalDC->map.iWey;

        xOrg = MulDiv(xOrg, Xnum, Xdenom);
        yOrg = MulDiv(yOrg, Ynum, Ydenom);
        if (!xOrg || !yOrg)
            return FALSE;

        // Set the window or viewport extents.
        pLocalDC->map.iWex = xOrg;
        pLocalDC->map.iWey = yOrg;
    }

    b = bComputeCompositeXform(pLocalDC) ;

    return (b) ;
}

/***************************************************************************
*  ScaleViewportExtEx  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoScaleViewportExt
(
 PLOCALDC pLocalDC,
 INT      Xnum,
 INT      Xdenom,
 INT      Ynum,
 INT      Ydenom
 )
{
    BOOL    b ;
    INT   xOrg, yOrg;

    if (pfnSetVirtualResolution != NULL)
    {
        // Set the viewport extent
        if (!ScaleViewportExtEx(pLocalDC->hdcHelper,
            Xnum, Xdenom,
            Ynum, Ydenom,
            (LPSIZE) 0))
        {
            ASSERTGDI(FALSE, "MF3216: DoScaleViewportExt failed\n");
            return(FALSE);
        }
    }
    else
    {
        if (pLocalDC->map.iMapMode <= MM_MAX_FIXEDSCALE)
            return FALSE;

        // Set the viewport extent
        xOrg = pLocalDC->map.iVex;
        yOrg = pLocalDC->map.iVey;

        xOrg = MulDiv(xOrg, Xnum, Xdenom);
        yOrg = MulDiv(yOrg, Ynum, Ydenom);
        if (!xOrg || !yOrg)
            return FALSE;

        // Set the window or viewport extents.
        pLocalDC->map.iVex = xOrg;
        pLocalDC->map.iVey = yOrg;
    }

    b = bComputeCompositeXform(pLocalDC) ;

    return (b) ;
}

/***************************************************************************
*  SetViewportExtEx  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoSetViewportExt
(
 PLOCALDC pLocalDC,
 int     x,
 int     y
 )
{
    BOOL    b ;

    if (pfnSetVirtualResolution != NULL)
    {
        // Set the viewport extent
        if (!SetViewportExtEx(pLocalDC->hdcHelper, x, y, (LPSIZE) 0))
        {
            ASSERTGDI(FALSE, "MF3216: DoSetViewportExt failed\n");
            return(FALSE);
        }
    }
    else
    {
        if (pLocalDC->map.iMapMode <= MM_MAX_FIXEDSCALE)
            return FALSE;

        if (!x || !y)
            return FALSE;

        // Set the window or viewport extents
        pLocalDC->map.iVex = x;
        pLocalDC->map.iVey = y;
    }

    b = bComputeCompositeXform(pLocalDC) ;

    return (b) ;
}

/***************************************************************************
*  SetViewportOrgEx  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoSetViewportOrg
(
 PLOCALDC pLocalDC,
 int     x,
 int     y
 )
{
    BOOL    b ;

    // Set the viewport origin

    if (pfnSetVirtualResolution != NULL)
    {
        if (!SetViewportOrgEx(pLocalDC->hdcHelper, x, y, (LPPOINT) 0))
        {
            ASSERTGDI(FALSE, "MF3216: DoSetViewportOrg failed\n");
            return(FALSE);
        }
    }
    else
    {
        pLocalDC->map.iVox = x;
        pLocalDC->map.iVoy = y;
    }

    b = bComputeCompositeXform(pLocalDC) ;

    return (b) ;
}

/***************************************************************************
*  SetWindowExtEx  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoSetWindowExt
(
 PLOCALDC pLocalDC,
 int     x,
 int     y
 )
{
    BOOL    b ;

    // Set the window extent

    if (pfnSetVirtualResolution != NULL)
    {
        if (!SetWindowExtEx(pLocalDC->hdcHelper, x, y, (LPSIZE) 0))
        {
            ASSERTGDI(FALSE, "MF3216: DoSetWindowExt failed\n");
            return(FALSE);
        }
    }
    else
    {
        if (pLocalDC->map.iMapMode <= MM_MAX_FIXEDSCALE)
            return FALSE;

        if (!x || !y)
            return FALSE;

        // Set the window or viewport extents
        pLocalDC->map.iWex = x;
        pLocalDC->map.iWey = y;
    }
    b = bComputeCompositeXform(pLocalDC) ;

    return (b) ;
}

/***************************************************************************
*  SetWindowOrgEx  - Win32 to Win16 Metafile Converter Entry Point
*
*  Since we will always record TWIPS in the Win16 metafile,
*  we will transform the WindowOrg from the current MapMode to
*  TWIPS. Then we will set the Dx and Dy elements of the Viewport
*  transformation matrix.
*
**************************************************************************/
BOOL WINAPI DoSetWindowOrg
(
 PLOCALDC pLocalDC,
 int     x,
 int     y
 )
{
    BOOL    b ;

    if (pfnSetVirtualResolution != NULL)
    {
        // Set the window origin

        if (!SetWindowOrgEx(pLocalDC->hdcHelper, x, y, (LPPOINT) 0))
        {
            ASSERTGDI(FALSE, "MF3216: DoSetWindowOrg failed\n");
            return(FALSE);
        }
    }
    else
    {
        // Set the window origin
        pLocalDC->map.iWox = x;
        pLocalDC->map.iWoy = y;
    }

    b = bComputeCompositeXform(pLocalDC) ;

    return (b) ;
}

/***************************************************************************
*  SetWorldTransform  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoSetWorldTransform
(
 PLOCALDC  pLocalDC,
 PXFORM  pxf
 )
{
    BOOL    b ;


    if (pfnSetVirtualResolution != NULL)
    {
        // Set the world xform in the helper DC.

        if (!SetWorldTransform(pLocalDC->hdcHelper, pxf))
        {
            ASSERTGDI(FALSE, "MF3216: DoSetWorldTransform failed\n");
            return(FALSE);
        }
    }
    else
    {
#ifdef DEBUG
        if (bRotationTest(pxf))
            WARNING("MF3216: DoSetWorldTransform() - World transform not simple.");
#endif // DEBUG
        pLocalDC->xformW = *pxf ;
    }

    b = bComputeCompositeXform(pLocalDC) ;

    return (b) ;
}

/***************************************************************************
*  ModifyWorldTransform  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoModifyWorldTransform
(
 PLOCALDC pLocalDC,
 PXFORM   pxf,
 DWORD    imode
 )
{
    BOOL    b = TRUE;

    if (pfnSetVirtualResolution != NULL)
    {
        // Set the world xform in the helper DC.

        if (!ModifyWorldTransform(pLocalDC->hdcHelper, pxf, imode))
        {
            ASSERTGDI(FALSE, "MF3216: DoModifyWorldTransform failed\n");
            return(FALSE);
        }
    }
    else
    {
        switch (imode)
        {
        case MWT_IDENTITY:
            pLocalDC->xformW = xformIdentity;
            break;

        case MWT_LEFTMULTIPLY:
        case MWT_RIGHTMULTIPLY:
#ifdef DEBUG
            if (bRotationTest(pxf))
                WARNING("MF3216: DoSetWorldTransform() - World transform not simple.");
#endif // DEBUG

            if (imode == MWT_LEFTMULTIPLY)
                b &= bCombineTransform(&pLocalDC->xformW,
                pxf,
                &pLocalDC->xformW);
            else
                b &= bCombineTransform(&pLocalDC->xformW,
                &pLocalDC->xformW,
                pxf);
            break;

        default:
            break;
        }
    }

    b &= bComputeCompositeXform(pLocalDC) ;

    return (b) ;
}


/****************************************************************************
* bComputeCompositeXform - Compute the composite Xforms.
*
* The following transforms are re-computed:
*
*  xformRWorldToRDev
*  xformRDevToRWorld
*  xformRWorldToPPage
*
****************************************************************************/
BOOL bComputeCompositeXform(PLOCALDC pLocalDC)
{
    BOOL    b ;

    // Recompute xformRWorldToRDev.
    // Get the record-time world to record-time device xform
    // from the helper DC

    if(pfnSetVirtualResolution != NULL)
    {
        ASSERTGDI(pfnGetTransform != NULL, "gpmf3216: bComputeCompositeXform, missing function pointer") ;

        b = (pfnGetTransform)(pLocalDC->hdcHelper,
            XFORM_WORLD_TO_DEVICE,
            &pLocalDC->xformRWorldToRDev) ;
        if (b == FALSE)
        {
            RIPS("MF3216: bComputeCompositeXform - GetTransform (RWorld to RDev) failed \n") ;
               goto error_exit ;
        }

        // Recompute xformRDevToRWorld.
        // Get the record-time-device to record-time-world xform

        b = (pfnGetTransform)(pLocalDC->hdcHelper,
            XFORM_DEVICE_TO_WORLD,
            &pLocalDC->xformRDevToRWorld) ;
        if (b == FALSE)
        {
            RIPS("MF3216: bComputeCompositeXform - GetTransform (RDev To RWorld) failed \n") ;
            goto error_exit ;
        }
    }
    else
    {
        if (pLocalDC->map.iMapMode == MM_ISOTROPIC)
        {
            vMakeIso(pLocalDC);
        }
        b = bCalcPagexform(&pLocalDC->map, &pLocalDC->xformP);
        if (!b)
        {
            ASSERTGDI(0, "MF3216: bComputeCompositeExform() - bCalcPageExform() failed.");
            goto error_exit;
        }
        b = bCombineTransform(&pLocalDC->xformRWorldToRDev,
            &pLocalDC->xformW,
            &pLocalDC->xformP);
        if (!b)
        {
            ASSERTGDI(0, "MF3216: bComputeCompositeExform() - bCombineExform() failed.");
            goto error_exit;
        }

        b = bCombineTransform(&pLocalDC->xformRWorldToRDev,
            &pLocalDC->xformRWorldToRDev,
            &pLocalDC->xformDC);
        if (!b)
        {
            ASSERTGDI(0, "MF3216: bComputeCompositeExform() - bCombineExform() failed.");
            goto error_exit;
        }

        b = bInvertxform(&pLocalDC->xformRWorldToRDev,
            &pLocalDC->xformRDevToRWorld);
        if (!b)
        {
            ASSERTGDI(0, "MF3216: bComputeCompositeExform() - bInvertExform() failed.");
            goto error_exit;
        }
    }


    // Recompute xformRWorldToPPage.
    b = bCombineTransform(&pLocalDC->xformRWorldToPPage,
        &pLocalDC->xformRWorldToRDev,
        &pLocalDC->xformRDevToPPage);
    if (b == FALSE)
    {
        RIPS("MF3216: bComputeCompositeXform - bCombineTransform failed\n");
        goto error_exit ;
    }

    // Recompute transform flags.

    if (pLocalDC->xformRWorldToRDev.eM12 != (FLOAT) 0.0
        || pLocalDC->xformRWorldToRDev.eM21 != (FLOAT) 0.0)
    {
        ASSERTGDI(pfnGetTransform != NULL, "gpmf3216: bComputeCompositeXform - Win95 has strange XForm" ) ;
        pLocalDC->flags |= STRANGE_XFORM ;
    }
    else
        pLocalDC->flags &= ~STRANGE_XFORM ;

error_exit:
    return(b) ;
}

/***************************************************************************
*  bCoordinateOverflowTest - Test for 1 16 bit coordinate overflow
*
*  RETURNS:    FALSE if there is a coordinate overflow
*              TRUE   if  there is no overflow.
**************************************************************************/
BOOL bCoordinateOverflowTest(PLONG pCoordinates, INT nCount)
{
    BOOL    b ;
    INT     i, j ;

    b = TRUE ;
    for (i = 0 ; i < nCount ; i++)
    {

        j = pCoordinates[i] ;
        if (j < -32768 || j > 32767)
        {
            b = FALSE ;
            SetLastError(ERROR_ARITHMETIC_OVERFLOW);
            WARNING(("MF3216: bCoordinateOverflowTest, coordinate overflow\n"));
            break ;
        }
    }

    return(b) ;
}


/***************************************************************************
* vMakeIso
*
* !!! We don't know the aspect ratio of the record device.  It's not
* stored in the EMF.  NT's SetVirtualResolution() doesn't take an aspect
* ratio as a parameter so it either ignores it or leaves it the display
* aspect ratio.  We'll ignore it.
**************************************************************************/

void vMakeIso(PLOCALDC pLocalDC)
{
    int iScaledVex, iScaledVey, iAbsVey;

    iScaledVex = MulDiv(pLocalDC->map.iVex, pLocalDC->map.iWey,
        pLocalDC->map.iWex);
    iScaledVex = ABS(iScaledVex);
    iAbsVey = ABS(pLocalDC->map.iVey);

    if (iAbsVey >= iScaledVex)
    {
        if (pLocalDC->map.iVey > 0)
            pLocalDC->map.iVey =  iScaledVex;
        else
            pLocalDC->map.iVey = -iScaledVex;
    }
    else
    {
        iScaledVey = MulDiv(pLocalDC->map.iVey, pLocalDC->map.iWex,
            pLocalDC->map.iWey);
        iScaledVey = ABS(iScaledVey);
        if (pLocalDC->map.iVex > 0)
            pLocalDC->map.iVex =  iScaledVey;
        else
            pLocalDC->map.iVex = -iScaledVey;
    }
}

/***************************************************************************
* bInvertxform - Invert an XFORM
*
*    Assumes:    M = [m11  0    0]  so M' = [1/m11     0         0]
*                    [0    m22  0]          [0         1/m22     0]
*                    [m31  m32  1]          [-m31/m11  -m32/m22  1]
*
**************************************************************************/

BOOL bInvertxform(PXFORM pxformSrc, PXFORM pxformDest)
{
    FLOAT    fOne, f;
    BOOL     bRet;

    if( pxformSrc->eM11 == 0.0 || pxformSrc->eM22 == 0.0 )
    {
        return FALSE ;
    }

    pxformDest->eM11 = 1.0f / pxformSrc->eM11 ;
    pxformDest->eM22 = 1.0f / pxformSrc->eM22 ;
    pxformDest->eDx = -pxformSrc->eDx / pxformSrc->eM11 ;
    pxformDest->eDy = -pxformSrc->eDy / pxformSrc->eM22 ;

    return TRUE ;
}


/*---------------------------Public-Routine------------------------------*
* bCalcPageExform
*
*   Calculates the page transform given a mapping structure.
*
*               p11 = Vex / Wex
*               p22 = Vey / Wey
*               p31 = Vox - Wox * Vex / Wex
*               p32 = Voy - Woy * Vey / Wey
*
* Arguments:
*       IN      pmap    the MAPPING structure
*       OUT     pex     the destination EXFORM
* Returns:
*       EAX = 1 if success
* Error Returns:
*       EAX = 0 if overflow
* Calls:
*       ltoef, divff, mulff, eftofx
* History:
*       1 January 1994  -by-    Raymond E. Endres [rayen]
* Wrote it.
*-----------------------------------------------------------------------*/
BOOL bCalcPagexform(PMAPPING pMapping, PXFORM pxformDest)
{
    if(pMapping->iWex == 0 || pMapping->iWey == 0)
        return FALSE;

    pxformDest->eM11 = (FLOAT) pMapping->iVex / pMapping->iWex ;
    pxformDest->eM22 = (FLOAT) pMapping->iVey / pMapping->iWey ;
    pxformDest->eDx = (FLOAT) pMapping->iVox - pMapping->iWox * pxformDest->eM11 ;
    pxformDest->eDy = (FLOAT) pMapping->iVoy - pMapping->iWoy * pxformDest->eM22 ;

    return TRUE ;
}


BOOL bCombineTransform(
  LPXFORM lpxformResult,  // combined transformation
  CONST XFORM *lpxform1,  // first transformation
  CONST XFORM *lpxform2   // second transformation
)
{
    if (pfnSetVirtualResolution != NULL)
    {
        return CombineTransform(lpxformResult, lpxform1, lpxform2);
    }
    else
    {
        lpxformResult->eDx = lpxform1->eDx*lpxform2->eM11 + lpxform2->eDx ;
        lpxformResult->eDy = lpxform1->eDy*lpxform2->eM22 + lpxform2->eDy ;
        lpxformResult->eM11 = lpxform1->eM11 * lpxform2->eM11 ;
        lpxformResult->eM22 = lpxform1->eM22 * lpxform2->eM22 ;
    }

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\regions.c ===
/*****************************************************************************
 *
 * regions - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *
 * NOTES:
 *
        When there are no embedded metafiles we need to do the following:

            1]  Read the metafile data from the Win32 metafile.  This
                is done by the handler routines that in turn call these
                routines.

            2]  Translate the Win32 metafile data into Win16 metafile data.

                The region data for FillRgn, FrameRgn, InvertRgn, and PaintRgn
                are in record-time world coordinates. The region data for
                these region API's will have to be translated from record-time
                -world coordinates to play-time-page coordinates
                (XFORM_WORLD_TO_PAGE). The helperDC will be used for
                this transformation.

                The region data for SelectClipRgn and OffsetClipRgn are in
                record-time device coordinates.  The region data for these
                APIs will be translated from record-time-device coordinates
                to play-time-device coordinates.

            3]  Emit a Win16 create region metafile record.

            4]  Select the newly created region into the metafile.

            5]  Do the region function (FillRegion, FrameRegion, ...).
                This means emit a FillRegion or FrameRegion drawing order
                into the Win16 metafile.

            6]  Emit a Delete Region drawing order.

            7]  Clean up all the memory resources used.

        When there are embedded metafiles things get a little more  complicated.
        Most of the complications are hidden in PlayMetafile record processing.
        Items 1 thru 3 will be handled by the PlayMetafile Doer.

            1]  We need to keep the region from the previous DC level.
                This can be done by the helper DC (SaveDC).  We will have to
                do a GetClipRgn and a SelectMetaRgn.  A MetaRgn is the clip
                region from the previous level.

            2]  We will have to intersect any clip regions from the current
                level with any clip regions from the previous level. This can
                be done by the helper DC (using the hrgnMeta & ExtCombineRegion)

            3]  When we pop out from this level we will have to restore the
                previous saved region. This can be done by the helper DC.
                (RestoreDC).

        Since we do not know whether or not there will be an embedded metafile
        in the metafile we are currently processing we will always shadow
        the Clip Region call into the helper DC.


 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop




BOOL bEmitWin3Region(PLOCALDC pLocalDC, HRGN hrgn);

extern fnSetVirtualResolution pfnSetVirtualResolution;

#define MIN_RGN_COORD16 -30000
#define MAX_RGN_COORD16  30000

/***************************************************************************
* DoDrawRgn
*
*  CR1: This routine was added as part of the handle manager change.
*       I noticed that almost all of the Region Rendering code was
*       the same.
**************************************************************************/
BOOL APIENTRY DoDrawRgn
(
 PLOCALDC  pLocalDC,
 INT       ihBrush,
 INT       nWidth,
 INT       nHeight,
 INT       cRgnData,
 LPRGNDATA pRgnData,
 INT       mrType
 )
{
    BOOL    b ;
    HRGN    hrgn = (HRGN) 0;
    INT     ihW16Rgn = -1,
        ihW16Brush = -1;

    b = FALSE ;

    // Translate the Win32 region data from Metafile-World to
    // Referencd-Page space.
    // This is done by ExtCreateRegion's xform.  The returned region
    // is transformed.

    hrgn = ExtCreateRegion(&pLocalDC->xformRWorldToPPage, cRgnData,
        (LPRGNDATA) pRgnData);
    if (!hrgn)
    {
        RIPS("MF3216: DoDrawRgn, ExtCreateRegion failed\n") ;
        goto error_exit ;
    }

    // Allocate a handle for the region.
    // This is different from a normal handle allocation, because
    // there is no region handle in Win32.  We are using one of our
    // extra slots here.

    ihW16Rgn = iGetW16ObjectHandleSlot(pLocalDC, REALIZED_REGION) ;
    if (ihW16Rgn == -1)
        goto error_exit ;

    // Emit a Win16 create region record for the region.

    if (!bEmitWin3Region(pLocalDC, hrgn))
    {
        RIPS("MF3216: DoDrawRgn, bEmitWin3Region failed\n") ;
        goto error_exit ;
    }

    // Translate the W32 Brush object index to a W16 Brush object index.

    if (ihBrush)
    {
        // Make sure that the W16 object exists.  Stock brushes may not
        // have been created and iValidateHandle will take care of creating
        // them.

        ihW16Brush = iValidateHandle(pLocalDC, ihBrush) ;
        if (ihW16Brush == -1)
            goto error_exit ;
    }

    // Emit the Region Record depending upon the function type.

    switch (mrType)
    {
    case EMR_FILLRGN:
        if(ihW16Brush == -1)
            goto error_exit;
        b = bEmitWin16FillRgn(pLocalDC,
            LOWORD(ihW16Rgn),
            LOWORD(ihW16Brush)) ;
        break ;

    case EMR_FRAMERGN:
        nWidth  = iMagnitudeXform (pLocalDC, nWidth, CX_MAG) ;
        nHeight = iMagnitudeXform (pLocalDC, nHeight, CY_MAG) ;
        if(ihW16Brush == -1)
            goto error_exit;

        b = bEmitWin16FrameRgn(pLocalDC,
            LOWORD(ihW16Rgn),
            LOWORD(ihW16Brush),
            LOWORD(nWidth),
            LOWORD(nHeight)) ;
        break ;

    case EMR_INVERTRGN:
        b = bEmitWin16InvertRgn(pLocalDC,
            LOWORD(ihW16Rgn)) ;
        break ;

    case EMR_PAINTRGN:
        b = bEmitWin16PaintRgn(pLocalDC,
            LOWORD(ihW16Rgn)) ;
        break ;

    default:
        RIPS("MF3216: DoDrawRgn, unknown type\n") ;
        break ;
    }

error_exit:
    // Delete the W16 Region Object.

    if (ihW16Rgn != -1)
        bDeleteW16Object(pLocalDC, ihW16Rgn) ;

    if (hrgn)
        DeleteObject(hrgn) ;

    return(b) ;
}


/***************************************************************************
*  ExtSelectClipRgn  - Win32 to Win16 Metafile Converter Entry Point
*
* History:
*  Tue Apr 07 17:05:37 1992    -by-    Hock San Lee    [hockl]
* Wrote it.
**************************************************************************/

BOOL WINAPI DoExtSelectClipRgn
(
 PLOCALDC  pLocalDC,
 INT       cRgnData,
 LPRGNDATA pRgnData,
 INT       iMode
 )
{
    HANDLE hrgn;
    BOOL   bRet;
    BOOL   bNoClipRgn ;
    WORD   wEscape ;

    if(pLocalDC->iXORPass == DRAWXORPASS)
    {
        pLocalDC->iXORPass = OBJECTRECREATION ;
        bRet = DoRemoveObjects( pLocalDC ) ;
        if( !bRet )
            return bRet ;

        //Restore the DC to the same level that it was in when we started the
        //XOR pass

        bRet = DoRestoreDC(pLocalDC, pLocalDC->iXORPassDCLevel - pLocalDC->iLevel);

        bRet = DoMoveTo(pLocalDC, pLocalDC->pOldPosition.x, pLocalDC->pOldPosition.y) ;

        wEscape = ENDPSIGNORE;
        if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;

        wEscape = CLIP_SAVE ;
        if(!bEmitWin16Escape(pLocalDC, CLIP_TO_PATH, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;

        return bRet;
    }
    else if(pLocalDC->iXORPass == ERASEXORPASS)
    {
        pLocalDC->iXORPass = NOTXORPASS ;
        pLocalDC->pbChange = NULL ;
        bRet = DoSetRop2(pLocalDC, pLocalDC->iROP);

        //bRet = DoRestoreDC(pLocalDC, -1);

        wEscape = CLIP_RESTORE ;
        if(!bEmitWin16Escape(pLocalDC, CLIP_TO_PATH, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;

        if (!bEmitWin16EmitSrcCopyComment(pLocalDC, msocommentEndSrcCopy))
        {
            return FALSE;
        }
        return bRet ;
    }


    bNoClipRgn = bNoDCRgn(pLocalDC, DCRGN_CLIP);

    // Do it to the helper DC.

    // Restore the PS clippath
    wEscape = CLIP_RESTORE ;
    while(pLocalDC->iSavePSClipPath > 0)
    {
        bEmitWin16Escape(pLocalDC, CLIP_TO_PATH, sizeof(wEscape), (LPSTR)&wEscape, NULL);
        pLocalDC->iSavePSClipPath--;
    }

    if (cRgnData == 0)      // default clipping
    {
        ASSERTGDI(iMode == RGN_COPY, "MF3216: DoExtSelectClipRgn: bad iMode\n");

        // No work if no previous clip region.

        if (bNoClipRgn)
            return(TRUE);

        bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, (HRGN)0, iMode) != ERROR);

        return(bW16Emit1(pLocalDC, META_SELECTCLIPREGION, 0));
    }
    else
    {
        // If there is no initial clip region and we are going to operate
        // on the initial clip region, we have to
        // create one.  Otherwise, GDI will create some random default
        // clipping region for us!

        if (bNoClipRgn
            && (iMode == RGN_DIFF || iMode == RGN_XOR || iMode == RGN_OR))
        {
            HRGN hrgnDefault;

            if (!(hrgnDefault = CreateRectRgn((int) (SHORT) MINSHORT,
                (int) (SHORT) MINSHORT,
                (int) (SHORT) MAXSHORT,
                (int) (SHORT) MAXSHORT)))
            {
                ASSERTGDI(FALSE, "MF3216: CreateRectRgn failed");
                return(FALSE);
            }

            bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, hrgnDefault, RGN_COPY)
                != ERROR);
            ASSERTGDI(bRet, "MF3216: ExtSelectClipRgn failed");

            if (!DeleteObject(hrgnDefault))
                ASSERTGDI(FALSE, "MF3216: DeleteObject failed");

            if (!bRet)
                return(FALSE);
        }

        // Create a region from the region data passed in.

        if (pfnSetVirtualResolution != NULL)
        {
            if (!(hrgn = ExtCreateRegion((LPXFORM) NULL, cRgnData, pRgnData)))
            {
                RIPS("MF3216: DoExtSelectClipRgn, Create region failed\n");
                return(FALSE);
            }
        }
        else
        {
            if (pRgnData->rdh.rcBound.left > pRgnData->rdh.rcBound.right ||
                pRgnData->rdh.rcBound.top > pRgnData->rdh.rcBound.bottom )
            {
                RIPS("MF3216: DoExtSelectClipRgn, Create region failed\n");
                return(FALSE);
            }
            // We need to create the region in Device Units for the helper DC
            // therefore add the xformDC to the transform
            if (!(hrgn = ExtCreateRegion(&pLocalDC->xformDC, cRgnData, pRgnData)))
            {
                RIPS("MF3216: DoExtSelectClipRgn, Create region failed\n");
                return(FALSE);
            }
        }

        bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, hrgn, iMode) != ERROR);

        ASSERTGDI(bRet, "MF3216: ExtSelectClipRgn failed\n");

        if (!DeleteObject(hrgn))
            RIPS("MF3216: DeleteObject failed\n");
    }

    // dump the clip region data.

    if (bRet)
        return(bDumpDCClipping(pLocalDC));
    else
        return(FALSE);
}


/***************************************************************************
*  SetMetaRgn  - Win32 to Win16 Metafile Converter Entry Point
*
* History:
*  Tue Apr 07 17:05:37 1992    -by-    Hock San Lee    [hockl]
* Wrote it.
**************************************************************************/

BOOL WINAPI DoSetMetaRgn(PLOCALDC pLocalDC)
{
    // No work if the clip region does not exist.

    if (bNoDCRgn(pLocalDC, DCRGN_CLIP))
        return(TRUE);

    // Do it to the helper DC.

    if (!SetMetaRgn(pLocalDC->hdcHelper))
        return(FALSE);

    // Dump the clip region data.

    return(bDumpDCClipping(pLocalDC));
}


/***************************************************************************
*  OffsetClipRgn  - Win32 to Win16 Metafile Converter Entry Point
*
* History:
*  Tue Apr 07 17:05:37 1992    -by-    Hock San Lee    [hockl]
* Wrote it.
**************************************************************************/

BOOL WINAPI DoOffsetClipRgn(PLOCALDC pLocalDC, INT x, INT y)
{
    POINTL aptl[2];
    BOOL   b;

    // Do it to the helper DC.
    POINTL p[2] = {0, 0, x, y};
    if (pfnSetVirtualResolution == NULL)
    {
        if (!bXformWorkhorse(p, 2, &pLocalDC->xformRWorldToRDev))
        {
            return FALSE;
        }
        // We just want the scale factor of the WorldToDevice Transform
        p[1].x -= p[0].x;
        p[1].y -= p[0].y;
    }

    if (!OffsetClipRgn(pLocalDC->hdcHelper, p[1].x, p[1].y))
        return(FALSE);

    // Dump region if the meta region exists.
    // We don't offset the meta region!

    if (!bNoDCRgn(pLocalDC, DCRGN_META))
        return(bDumpDCClipping(pLocalDC));

    // Translate the record-time world offsets to play-time page offsets.

    aptl[0].x = 0;
    aptl[0].y = 0;
    aptl[1].x = x;
    aptl[1].y = y;

    if (!bXformRWorldToPPage(pLocalDC, aptl, 2))
        return(FALSE);

    aptl[1].x -= aptl[0].x;
    aptl[1].y -= aptl[0].y;

    b = bEmitWin16OffsetClipRgn(pLocalDC, (SHORT) aptl[1].x, (SHORT) aptl[1].y);
    ASSERTGDI(b, "MF3216: DoOffsetClipRgn, bEmitWin16OffsetClipRgn failed\n");

    return(b) ;
}


/***************************************************************************
*  bNoDCRgn  - Return TRUE if the dc clip region does not exist.
*                Otherwise, return FALSE.
*  This is TEMPORARY only.  Get gdi to provide this functionality.
**************************************************************************/

BOOL bNoDCRgn(PLOCALDC pLocalDC, INT iType)
{
    BOOL  bRet = FALSE;     // assume the dc region exists
    HRGN  hrgnTmp;

    ASSERTGDI(iType == DCRGN_CLIP || iType == DCRGN_META,
        "MF3216: bNoDCRgn, bad iType\n");

    if (!(hrgnTmp = CreateRectRgn(0, 0, 0, 0)))
    {
        ASSERTGDI(FALSE, "MF3216: bNoDCRgn, CreateRectRgn failed\n");
        return(bRet);
    }

    switch (GetRandomRgn(pLocalDC->hdcHelper,
        hrgnTmp,
        iType == DCRGN_CLIP ? 1 : 2
        )
        )
    {
    case -1:    // error
        ASSERTGDI(FALSE, "GetRandomRgn failed");
        break;
    case 0: // no dc region
        bRet = TRUE;
        break;
    case 1: // has dc region
        break;
    }

    if (!DeleteObject(hrgnTmp))
        ASSERTGDI(FALSE, "DeleteObject failed");

    return(bRet);
}

/***************************************************************************
*  bDumpDCClipping - Dump the DC clipping regions.
*
* History:
*  Tue Apr 07 17:05:37 1992    -by-    Hock San Lee    [hockl]
* Wrote it.
**************************************************************************/

BOOL bDumpDCClipping(PLOCALDC pLocalDC)
{
    BOOL      bRet            = FALSE;      // assume failure
    HRGN      hrgnRDev        = (HRGN) 0;
    HRGN      hrgnPPage       = (HRGN) 0;
    HRGN      hrgnPPageBounds = (HRGN) 0;
    LPRGNDATA lprgnRDev       = (LPRGNDATA) NULL;
    LPRGNDATA lprgnPPage      = (LPRGNDATA) NULL;
    DWORD     cRgnData;
    INT       i;
    INT       nrcl;
    PRECTL    prcl;
    RECTL     rclPPage;
    XFORM       xform;

    // Since clipping region is not scalable in Win30, we do not emit
    // SelectClipRgn record.  Instead, we set the clipping to the default, i.e.
    // no clipping, and then emit the scalable IntersectClipRect/ExcludeClipRect
    // records to exclude clipping region.  This will allow the win30 metafiles
    // to be scalable.

    // First, emit a default clipping region.

    // On Win3.x, the META_SELECTCLIPREGION record only works if it has
    // a NULL handle.  The Win3x metafile driver does not translate the
    // region handle at playback time!

    if (!bW16Emit1(pLocalDC, META_SELECTCLIPREGION, 0))
        goto ddcc_exit;

    // Now find the clip and meta regions to be excluded from the default
    // clipping region.

    if (!(hrgnRDev = CreateRectRgn(0, 0, 0, 0)))
        goto ddcc_exit;

    switch (GetRandomRgn(pLocalDC->hdcHelper, hrgnRDev, 3)) // meta and clip
    {
    case -1:    // error
        ASSERTGDI(FALSE, "GetRandomRgn failed");
        goto ddcc_exit;
    case 0: // no clip region, we are done
        bRet = TRUE;
        goto ddcc_exit;
    case 1: // has clip region
        break;
    }

    // Get the clip region data.
    // First query the size of the buffer required to hold the clip region data.

    if (!(cRgnData = GetRegionData(hrgnRDev, 0, (LPRGNDATA) NULL)))
        goto ddcc_exit;

    // Allocate the memory for the clip region data buffer.

    if (!(lprgnRDev = (LPRGNDATA) LocalAlloc(LMEM_FIXED, cRgnData)))
        goto ddcc_exit;

    // Get clip region data.

    if (GetRegionData(hrgnRDev, cRgnData, lprgnRDev) != cRgnData)
        goto ddcc_exit;

    // Create the clip region in the playtime page space.
    if (!(hrgnPPage = ExtCreateRegion(&pLocalDC->xformRDevToPPage, cRgnData, lprgnRDev)))
        goto ddcc_exit;

    // Get the bounding box for the playtime clip region in page space.

    if (GetRgnBox(hrgnPPage, (LPRECT) &rclPPage) == ERROR)
        goto ddcc_exit;

    // Bound it to 16-bit.

    rclPPage.left   = max(MIN_RGN_COORD16,rclPPage.left);
    rclPPage.top    = max(MIN_RGN_COORD16,rclPPage.top);
    rclPPage.right  = min(MAX_RGN_COORD16,rclPPage.right);
    rclPPage.bottom = min(MAX_RGN_COORD16,rclPPage.bottom);

    // Set the bounding box as the bounds for the clipping.

    if (!bEmitWin16IntersectClipRect(pLocalDC,
        (SHORT) rclPPage.left,
        (SHORT) rclPPage.top,
        (SHORT) rclPPage.right,
        (SHORT) rclPPage.bottom))
        goto ddcc_exit;

    // Create the bounding region.

    if (!(hrgnPPageBounds = CreateRectRgn(rclPPage.left,
        rclPPage.top,
        rclPPage.right,
        rclPPage.bottom)))
        goto ddcc_exit;

    // Exclude the regions in playtime page space.

    if (CombineRgn(hrgnPPage, hrgnPPageBounds, hrgnPPage, RGN_DIFF) == ERROR)
        goto ddcc_exit;

    // Finally, exclude the rectangles from the bounding box.

    if (!(cRgnData = GetRegionData(hrgnPPage, 0, (LPRGNDATA) NULL)))
        goto ddcc_exit;

    if (!(lprgnPPage = (LPRGNDATA) LocalAlloc(LMEM_FIXED, cRgnData)))
        goto ddcc_exit;

    if (GetRegionData(hrgnPPage, cRgnData, lprgnPPage) != cRgnData)
        goto ddcc_exit;

    // Get the number of rectangles in the transformed region.

    nrcl = lprgnPPage->rdh.nCount;
    prcl = (PRECTL) lprgnPPage->Buffer;

    // Emit a series of Exclude Clip Rectangle Metafile records.

    for (i = 0 ; i < nrcl; i++)
    {
        ASSERTGDI(prcl[i].left   >= MIN_RGN_COORD16
            && prcl[i].top    >= MIN_RGN_COORD16
            && prcl[i].right  <= MAX_RGN_COORD16
            && prcl[i].bottom <= MAX_RGN_COORD16,
            "MF3216: bad coord");

        if (!bEmitWin16ExcludeClipRect(pLocalDC,
            (SHORT) prcl[i].left,
            (SHORT) prcl[i].top,
            (SHORT) prcl[i].right,
            (SHORT) prcl[i].bottom))
            goto ddcc_exit;
    }

    bRet = TRUE;            // we are golden!

    // Cleanup all the resources used.

ddcc_exit:

    if (hrgnRDev)
        DeleteObject(hrgnRDev);

    if (hrgnPPage)
        DeleteObject(hrgnPPage);

    if (hrgnPPageBounds)
        DeleteObject(hrgnPPageBounds);

    if (lprgnRDev)
        LocalFree(lprgnRDev);

    if (lprgnPPage)
        LocalFree(lprgnPPage);

    return(bRet) ;
}

/***************************************************************************
* Emit a 16-bit CreateRegion record for the given region.
*
* This code is copied from the 16-bit metafile driver in gdi.
*
**************************************************************************/

WIN3REGION w3rgnEmpty =
{
    0,              // nextInChain
        6,              // ObjType
        0x2F6,          // ObjCount
        sizeof(WIN3REGION) - sizeof(SCAN) + 2,
        // cbRegion
        0,              // cScans
        0,              // maxScan
    {0,0,0,0},      // rcBounding
    {0,0,0,{0,0},0} // aScans[]
};

BOOL bEmitWin3Region(PLOCALDC pLocalDC, HRGN hrgn)
{
/*
* in win2, METACREATEREGION records contained an entire region object,
* including the full header.  this header changed in win3.
*
* to remain compatible, the region records will be saved with the
* win2 header.  here we save our region with a win2 header.
    */
    PWIN3REGION lpw3rgn;
    DWORD       cbNTRgnData;
    DWORD       curRectl;
    WORD        cScans;
    WORD        maxScanEntry;
    WORD        curScanEntry;
    DWORD       cbw3data;
    PRGNDATA    lprgn;
    LPRECT      lprc;
    PSCAN       lpScan;
    BOOL    bRet;

    ASSERTGDI(hrgn, "MF3216: bEmitWin3Region, hrgn is NULL");

    // Get the NT Region Data
    cbNTRgnData = GetRegionData(hrgn, 0, NULL);
    if (cbNTRgnData == 0)
        return(FALSE);

    lprgn = (PRGNDATA) LocalAlloc(LMEM_FIXED, cbNTRgnData);
    if (!lprgn)
        return(FALSE);

    cbNTRgnData = GetRegionData(hrgn, cbNTRgnData, lprgn);
    if (cbNTRgnData == 0)
    {
        LocalFree((HANDLE) lprgn);
        return(FALSE);
    }

    // Handle the empty region.

    if (!lprgn->rdh.nCount)
    {
        bRet = bEmitWin16CreateRegion(pLocalDC, sizeof(WIN3REGION) - sizeof(SCAN), (PVOID) &w3rgnEmpty);

        LocalFree((HANDLE)lprgn);
        return(bRet);
    }

    lprc = (LPRECT)lprgn->Buffer;

    // Create the Windows 3.x equivalent

    // worst case is one scan for each rect
    cbw3data = 2*sizeof(WIN3REGION) + (WORD)lprgn->rdh.nCount*sizeof(SCAN);

    lpw3rgn = (PWIN3REGION)LocalAlloc(LMEM_FIXED, cbw3data);
    if (!lpw3rgn)
    {
        LocalFree((HANDLE) lprgn);
        return(FALSE);
    }

    // Grab the bounding rect.
    lpw3rgn->rcBounding.left   = (SHORT)lprgn->rdh.rcBound.left;
    lpw3rgn->rcBounding.right  = (SHORT)lprgn->rdh.rcBound.right;
    lpw3rgn->rcBounding.top    = (SHORT)lprgn->rdh.rcBound.top;
    lpw3rgn->rcBounding.bottom = (SHORT)lprgn->rdh.rcBound.bottom;

    cbw3data = sizeof(WIN3REGION) - sizeof(SCAN) + 2;

    // visit all the rects
    curRectl     = 0;
    cScans       = 0;
    maxScanEntry = 0;
    lpScan       = lpw3rgn->aScans;

    while(curRectl < lprgn->rdh.nCount)
    {
        LPWORD  lpXEntry;
        DWORD   cbScan;

        curScanEntry = 0;       // Current X pair in this scan

        lpScan->scnPntTop    = (WORD)lprc[curRectl].top;
        lpScan->scnPntBottom = (WORD)lprc[curRectl].bottom;

        lpXEntry = (LPWORD) lpScan->scnPntsX;

        // handle rects on this scan
        do
        {
            lpXEntry[curScanEntry + 0] = (WORD)lprc[curRectl].left;
            lpXEntry[curScanEntry + 1] = (WORD)lprc[curRectl].right;
            curScanEntry += 2;
            curRectl++;
        } while ((curRectl < lprgn->rdh.nCount)
            && (lprc[curRectl-1].top    == lprc[curRectl].top)
            && (lprc[curRectl-1].bottom == lprc[curRectl].bottom)
            );

        lpScan->scnPntCnt      = curScanEntry;
        lpXEntry[curScanEntry] = curScanEntry;  // Count also follows Xs
        cScans++;

        if (curScanEntry > maxScanEntry)
            maxScanEntry = curScanEntry;

        // account for each new scan + each X1 X2 Entry but the first
        cbScan = sizeof(SCAN)-(sizeof(WORD)*2) + (curScanEntry*sizeof(WORD));
        cbw3data += cbScan;
        lpScan = (PSCAN)(((LPBYTE)lpScan) + cbScan);
    }

    // Initialize the header
    lpw3rgn->nextInChain = 0;
    lpw3rgn->ObjType = 6;           // old Windows OBJ_RGN identifier
    lpw3rgn->ObjCount= 0x2F6;       // any non-zero number
    lpw3rgn->cbRegion = (WORD)cbw3data;   // don't count type and next
    lpw3rgn->cScans = cScans;
    lpw3rgn->maxScan = maxScanEntry;

    bRet = bEmitWin16CreateRegion(pLocalDC, cbw3data-2, (PVOID) lpw3rgn);

    if (LocalFree((HANDLE)lprgn))
        ASSERTGDI(FALSE, "bEmitWin3Region: LocalFree(lprgn) Failed\n");
    if (LocalFree((HANDLE)lpw3rgn))
        ASSERTGDI(FALSE, "bEmitWin3Region: LocalFree(lpw3rgn) Failed\n");

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\rects.c ===
/*****************************************************************************
 *
 * rects - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

extern fnSetVirtualResolution pfnSetVirtualResolution;

/***************************************************************************
 *  Rectangle  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoRectangle
(
PLOCALDC pLocalDC,
int    x1,
int    y1,
int    x2,
int    y2
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, 0, 0, 0, 0, EMR_RECTANGLE) ;

        return(b) ;
}


/***************************************************************************
 *  RoundRect  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoRoundRect
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, x3, y3, 0, 0, EMR_ROUNDRECT);

        return(b) ;
}


void FixOverflow (int * value)
{
    if (*value > 32767)
    {
        *value = 32767;
    }
    else if (*value < -32768)
    {
        *value = -32768;
    }
}

/***************************************************************************
 *  IntersectClipRect/ExcludeClipRect - Win32 to Win16 Metafile Converter
 *  Entry Point
 **************************************************************************/

BOOL WINAPI DoClipRect
(
PLOCALDC pLocalDC,
INT xLeft,
INT yTop,
INT xRight,
INT yBottom,
INT mrType
)
{
    BOOL    bNoClipRgn ;
    POINTL  aptl[2] ;
    INT temp;

    // Do it to the helper DC.

    // If there is no initial clip region, we have to
    // create one.  Otherwise, GDI will create some random default
    // clipping region for us!

    bNoClipRgn = bNoDCRgn(pLocalDC, DCRGN_CLIP);

    if (bNoClipRgn)
    {
        BOOL bRet;
        HRGN hrgnDefault;

        if (!(hrgnDefault = CreateRectRgn((int) (SHORT) MINSHORT,
                          (int) (SHORT) MINSHORT,
                          (int) (SHORT) MAXSHORT,
                          (int) (SHORT) MAXSHORT)))
        {
        ASSERTGDI(FALSE, "MF3216: CreateRectRgn failed");
            return(FALSE);
        }

        bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, hrgnDefault, RGN_COPY)
            != ERROR);
        ASSERTGDI(bRet, "MF3216: ExtSelectClipRgn failed");

        if (!DeleteObject(hrgnDefault))
        ASSERTGDI(FALSE, "MF3216: DeleteObject failed");

        if (!bRet)
        return(FALSE);
    }

    // Do the simple case.
    // Are they inclusive-exclusive?!
    // Make it inclusive-inclusive, and then transform
    // then make it back to inclusive-exclusive

    aptl[0].x = xLeft;
    aptl[0].y = yTop ;
    aptl[1].x = xRight;
    aptl[1].y = yBottom;

    if (aptl[0].x > aptl[1].x)
    {
        temp = aptl[0].x;
        aptl[0].x = aptl[1].x;
        aptl[1].x = temp;
    }

    if (aptl[0].y > aptl[1].y)
    {
        temp = aptl[0].y;
        aptl[0].y = aptl[1].y;
        aptl[1].y = temp;
    }

    aptl[1].x--;
    aptl[1].y--;

    {
        POINTL ppts[2] = {aptl[0].x, aptl[0].y, aptl[1].x, aptl[1].y};
        if (pfnSetVirtualResolution == NULL)
        {
            if (!bXformWorkhorse(ppts, 2, &pLocalDC->xformRWorldToRDev))
            {
                return FALSE;
            }
            // Verify rectangle ordering and check off-by-1 error!
            if (ppts[0].x > ppts[1].x)
            {
                temp = ppts[0].x;
                ppts[0].x = ppts[1].x;
                ppts[1].x = temp;
            }

            if (ppts[0].y > ppts[1].y)
            {
                temp = ppts[0].y;
                ppts[0].y = ppts[1].y;
                ppts[1].y = temp;
            }
        }

        ppts[1].x++;
        ppts[1].y++;

        switch(mrType)
        {
        case EMR_INTERSECTCLIPRECT:
            if (!IntersectClipRect(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y))
                return(FALSE);
            break;

        case EMR_EXCLUDECLIPRECT:
            if (!ExcludeClipRect(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y))
                return(FALSE);
            break;

        default:
            ASSERTGDI(FALSE, "MF3216: DoClipRect, bad mrType\n");
            break;
        }
    }


    // Dump the clip region data if there is a strange xform.
    // Even if there is a clipping region, when playing back the WMF, we
    // will already have a clip rect and we will simply want to intersect
    // or exclude the new region.

    if (pLocalDC->flags & STRANGE_XFORM)
        return(bDumpDCClipping(pLocalDC));

    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) aptl, 2))
        return(FALSE);


    if (!bCoordinateOverflowTest((PLONG) aptl, 4))
    {
        RIPS("MF3216: coord overflow");
        FixOverflow (&(aptl[0].x));
        FixOverflow (&(aptl[0].y));
        FixOverflow (&(aptl[1].x));
        FixOverflow (&(aptl[1].y));
    }

    // Verify rectangle ordering and check off-by-1 error!
    if (aptl[0].x > aptl[1].x)
    {
        temp = aptl[0].x;
        aptl[0].x = aptl[1].x;
        aptl[1].x = temp;
    }

    if (aptl[0].y > aptl[1].y)
    {
        temp = aptl[0].y;
        aptl[0].y = aptl[1].y;
        aptl[1].y = temp;
    }

    aptl[1].x++;
    aptl[1].y++;


    if (mrType == EMR_INTERSECTCLIPRECT)
        return(bEmitWin16IntersectClipRect(pLocalDC,
                                           (SHORT) aptl[0].x,
                                           (SHORT) aptl[0].y,
                                           (SHORT) aptl[1].x,
                                           (SHORT) aptl[1].y));
    else
        return(bEmitWin16ExcludeClipRect(pLocalDC,
                                           (SHORT) aptl[0].x,
                                           (SHORT) aptl[0].y,
                                           (SHORT) aptl[1].x,
                                           (SHORT) aptl[1].y));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\win16api.c ===
/****************************************************************************
 *
 *  Win16 Metafile emitter routines
 *
 *  Date:   7/19/91
 *  Author: Jeffrey Newman (c-jeffn)
 *
 ***************************************************************************/

#include "precomp.h"
#pragma hdrstop

WORD GetSizeOfColorTable (LPBITMAPINFOHEADER lpDIBInfo);

/****************************************************************************
 * bW16Emit0 - This is the base routine to emit a Win16 drawing order
 *             with 0 parameters.
 ***************************************************************************/
BOOL bW16Emit0
(
PLOCALDC   pLocalDC,
WORD       RecordID
)
{
BOOL        b;
METARECORD0 mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = RecordID;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit1 - This is the base routine to emit a Win16 drawing order
 *             with 1 parameter.
 ***************************************************************************/
BOOL bW16Emit1
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1
)
{
BOOL        b;
METARECORD1 mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = RecordID;
    mr.rdParm[0]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit2 - This is the base routine to emit a Win16 drawing order
 *             with 2 parameters.
 ***************************************************************************/
BOOL bW16Emit2
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2
)
{
BOOL        b;
METARECORD2 mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = RecordID;
    mr.rdParm[0]  = x2;
    mr.rdParm[1]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit4 - This is the base routine to emit a Win16 drawing order
 *             with 4 parameters.
 ***************************************************************************/
BOOL bW16Emit4
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4
)
{
BOOL        b;
METARECORD4 mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = RecordID;
    mr.rdParm[0]  = x4;
    mr.rdParm[1]  = x3;
    mr.rdParm[2]  = x2;
    mr.rdParm[3]  = x1;

    b = bEmit(pLocalDC, &mr, sizeof(mr));

    // Update the global max record size.

    vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

    return(b);
}

/****************************************************************************
 * bW16Emit5 - This is the base routine to emit a Win16 drawing order
 *             with 5 parameters.
 ***************************************************************************/
BOOL bW16Emit5
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4,
WORD       x5
)
{
BOOL        b;
METARECORD5 mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = RecordID;
    mr.rdParm[0]  = x5;
    mr.rdParm[1]  = x4;
    mr.rdParm[2]  = x3;
    mr.rdParm[3]  = x2;
    mr.rdParm[4]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit6 - This is the base routine to emit a Win16 drawing order
 *             with 6 parameters.
 ***************************************************************************/
BOOL bW16Emit6
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4,
WORD       x5,
WORD       x6
)
{
BOOL        b;
METARECORD6 mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = RecordID;
    mr.rdParm[0]  = x6;
    mr.rdParm[1]  = x5;
    mr.rdParm[2]  = x4;
    mr.rdParm[3]  = x3;
    mr.rdParm[4]  = x2;
    mr.rdParm[5]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit8 - This is the base routine to emit a Win16 drawing order
 *             with 8 parameters.
 ***************************************************************************/
BOOL bW16Emit8
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4,
WORD       x5,
WORD       x6,
WORD       x7,
WORD       x8
)
{
BOOL        b;
METARECORD8 mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = RecordID;
    mr.rdParm[0]  = x8;
    mr.rdParm[1]  = x7;
    mr.rdParm[2]  = x6;
    mr.rdParm[3]  = x5;
    mr.rdParm[4]  = x4;
    mr.rdParm[5]  = x3;
    mr.rdParm[6]  = x2;
    mr.rdParm[7]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit9 - This is the base routine to emit a Win16 drawing order
 *             with 9 parameters.
 ***************************************************************************/
BOOL bW16Emit9
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4,
WORD       x5,
WORD       x6,
WORD       x7,
WORD       x8,
WORD       x9
)
{
BOOL        b;
METARECORD9 mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = RecordID;
    mr.rdParm[0]  = x9;
    mr.rdParm[1]  = x8;
    mr.rdParm[2]  = x7;
    mr.rdParm[3]  = x6;
    mr.rdParm[4]  = x5;
    mr.rdParm[5]  = x4;
    mr.rdParm[6]  = x3;
    mr.rdParm[7]  = x2;
    mr.rdParm[8]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * CreateFontIndirect - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreateFontIndirect
(
PLOCALDC       pLocalDC,
LPWIN16LOGFONT lpWin16LogFont
)
{
BOOL    b;
METARECORD_CREATEFONTINDIRECT mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = META_CREATEFONTINDIRECT;
    mr.lf16       = *lpWin16LogFont;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * Polyline/Polygon - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16Poly
(
PLOCALDC pLocalDC,
LPPOINTS ppt,
SHORT    cpt,
WORD     metaType
)
{
BOOL    b ;
WORD    nSize ;
METARECORD_POLY mr;

        // Caculate the size of the points array

        nSize = (WORD) (cpt * sizeof(POINTS));

        // Build up the header of the Win16 poly record

    mr.rdSize     = (sizeof(mr) + nSize) / sizeof(WORD);
    mr.rdFunction = metaType;
    mr.cpt        = cpt;

        // Emit the Header, then if it succeds emit the points.

        b = bEmit(pLocalDC, &mr, sizeof(mr));
        if (b)
        {
            b = bEmit(pLocalDC, ppt, nSize);
        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * PolyPolygon - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16PolyPolygon
(
PLOCALDC pLocalDC,
PPOINTS  ppt,
PWORD    pcpt,
WORD     cpt,
WORD     ccpt
)
{
BOOL    b ;
WORD    nSize ;
METARECORD_POLYPOLYGON mr;

        nSize  = cpt * sizeof(POINTS);
        nSize += ccpt * sizeof(WORD);
        nSize += sizeof(mr);

        // Build up the header of the Win16 polyline record

    mr.rdSize     = nSize / sizeof(WORD);
    mr.rdFunction = META_POLYPOLYGON;
    mr.ccpt       = ccpt;

        // Emit the Header, then if it succeds emit the Point counts,
        // then if it succeds emit the points.

        b = bEmit(pLocalDC, &mr, sizeof(mr));
        if (b)
        {
            b = bEmit(pLocalDC, pcpt, ccpt * sizeof(WORD));
            if (b)
            {
                b = bEmit(pLocalDC, ppt, cpt * sizeof(POINTS));
            }

        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * StretchBlt - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16StretchBlt
(
  PLOCALDC pLocalDC,
  SHORT    x,
  SHORT    y,
  SHORT    cx,
  SHORT    cy,
  SHORT    xSrc,
  SHORT    ySrc,
  SHORT    cxSrc,
  SHORT    cySrc,
  DWORD    rop,
  PBITMAPINFO lpbmi,
  DWORD       cbbmi,
  PBYTE    lpBits,
  DWORD    cbBits
)
{
BOOL        b ;
DWORD       nSize ;
METARECORD_DIBSTRETCHBLT mr;
DWORD       clrUsed;
WORD        clrTableSize;
WORD        newClrTableSize;
PBITMAPINFO lpnewbmi;
DWORD       newcbbmi;

    // Need to make real sure the plane count is 1,
    // otherwise this is not a DIB.

    if (lpbmi->bmiHeader.biPlanes != 1)
    {
        RIPS("MF3216: bEmitWin16StretchBlt, Invalid biPlanes in DIB\n") ;
        return (FALSE) ;
    }

    lpnewbmi = NULL;
    newcbbmi = 0;
    // Some programs don't work well with ClrUsed so always fill the palette
    clrTableSize = GetSizeOfColorTable((LPBITMAPINFOHEADER)lpbmi);
    clrUsed = lpbmi->bmiHeader.biClrUsed;
    lpbmi->bmiHeader.biClrUsed = 0;
    newClrTableSize = GetSizeOfColorTable((LPBITMAPINFOHEADER)lpbmi);
    if (newClrTableSize != clrTableSize)
    {
        // It can happen that we are passed a color table bigger then we
        // expect. So only copy the size of the new colortable
        newcbbmi = lpbmi->bmiHeader.biSize + newClrTableSize;
        lpnewbmi = (PBITMAPINFO) LocalAlloc(LMEM_FIXED, newcbbmi);
        if (lpnewbmi != NULL)
        {
            // Copy the old header and fill the rest of the palette with 0
            memcpy((void*) lpnewbmi, (void*)lpbmi, min(cbbmi, newcbbmi));
            if (newcbbmi > cbbmi)
            {
                memset((void*) (((char*)lpnewbmi) + cbbmi), 0, newcbbmi - cbbmi);
            }
            lpbmi = lpnewbmi;
            cbbmi = newcbbmi;
        }

    }

    // Create the static portion of the
    // Win 3.0 StretchBlt metafile record.

    nSize = sizeof(mr) + cbbmi + cbBits;

    mr.rdSize     = nSize / sizeof(WORD);
    mr.rdFunction = META_DIBSTRETCHBLT;
    mr.rop        = rop;
    mr.cySrc      = cySrc;
    mr.cxSrc      = cxSrc;
    mr.ySrc       = ySrc;
    mr.xSrc       = xSrc;
    mr.cy         = cy;
    mr.cx         = cx;
    mr.y          = y;
    mr.x          = x;

    b = bEmit(pLocalDC, &mr, sizeof(mr));
    if (b)
    {
        // Emit the bitmap info

        b = bEmit(pLocalDC, lpbmi, cbbmi);
        if (b)
        {
            // Emit the actual bits, if any.
            b = bEmit(pLocalDC, lpBits, cbBits);
        }
    }

    // Update the global max record size.

    vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

    if (lpnewbmi != NULL)
    {
        LocalFree((HLOCAL) lpnewbmi);
    }

    return(b);
}

/****************************************************************************
 * ExtTextOut - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16ExtTextOut
(
PLOCALDC pLocalDC,
SHORT    x,
SHORT    y,
WORD     fwOpts,
PRECTS   prcts,
PSTR     ach,
SHORT    nCount,
PWORD    lpDx
)
{
BOOL    b ;
DWORD   i, nBaseRecord ;
WORD    awRecord[11] ;


        // Calculate the size of the record

        i = ((WORD) nCount + 1) / 2 * 2;   // i = size of string in bytes
    if (lpDx)
            i += (WORD) nCount * sizeof(WORD); // add in size of Dx vector
        i += sizeof(awRecord);             // add in size of basic record
        if (!(fwOpts & (ETO_OPAQUE | ETO_CLIPPED)))
            i -= sizeof(RECTS);            // adjust for a rectangle being present
        i /= sizeof(WORD) ;                // change to word count

        // Set the record size, type,
        // x & y position, character count, and options.

        awRecord[0] = LOWORD(i) ;
        awRecord[1] = HIWORD(i) ;
        awRecord[2] = META_EXTTEXTOUT ;
        awRecord[3] = y ;
        awRecord[4] = x ;
        awRecord[5] = nCount ;
        awRecord[6] = fwOpts ;

        // Only if there is a opaque / clipping rectangle present
        // do we copy it over, other wise it is nonexistent.
        // We need to adjust the size of the Record emitted based upon
        // the existence of the opaque / clipping rectangle.

        nBaseRecord = 7 * sizeof(WORD) ;
        if (fwOpts & (ETO_OPAQUE | ETO_CLIPPED))
        {
            awRecord[7] = prcts->left ;
            awRecord[8] = prcts->top ;
            awRecord[9] = prcts->right ;
            awRecord[10] = prcts->bottom ;

            nBaseRecord += 4 * sizeof(WORD) ;
        }

        // Emit the record.

        b = bEmit(pLocalDC, awRecord, nBaseRecord) ;
        if (b)
        {
            // Emit the character string.

            i = ((WORD) nCount + 1) / 2 * 2 ;
            b = bEmit(pLocalDC, ach, i) ;
            if (b)
            {
        if (lpDx)
        {
                    // Emit the intercharacter spacing array

                    i = (WORD) (nCount * sizeof(WORD)) ;
                    b = bEmit(pLocalDC, lpDx, i) ;
                }
            }
        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) awRecord) ;

        return(b) ;
}

/****************************************************************************
 * Create Region - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreateRegion
(
PLOCALDC pLocalDC,
DWORD    cbRgn,
PVOID    pRgn
)
{
BOOL        b;
METARECORD0 mr;

    mr.rdSize     = (sizeof(mr) + cbRgn) / sizeof(WORD);
    mr.rdFunction = META_CREATEREGION;

    // Emit the header.

        b = bEmit(pLocalDC, &mr, sizeof(mr));

    // Emit the region data.

    b = bEmit(pLocalDC, pRgn, cbRgn);

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * SetPaletteEntries - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16SetPaletteEntries
(
PLOCALDC       pLocalDC,
DWORD          iStart,
DWORD          cEntries,
LPPALETTEENTRY pPalEntries
)
{
BOOL    b ;
DWORD   cbPalEntries ;
METARECORD_SETPALENTRIES mr;

        cbPalEntries = cEntries * sizeof(PALETTEENTRY);

    mr.rdSize     = (sizeof(mr) + cbPalEntries) / sizeof(WORD);
    mr.rdFunction = META_SETPALENTRIES;
    mr.iStart     = (WORD) iStart;
    mr.cEntries   = (WORD) cEntries;

        // Emit the header.

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Emit the actual palette entries.

        b = bEmit(pLocalDC, pPalEntries, cbPalEntries) ;

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * CreatePalette - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreatePalette
(
PLOCALDC     pLocalDC,
LPLOGPALETTE lpLogPal
)
{
BOOL    b;
DWORD   cbLogPal;
METARECORD0 mr;

        cbLogPal  = sizeof(LOGPALETTE) - sizeof(PALETTEENTRY)
            + lpLogPal->palNumEntries * sizeof(PALETTEENTRY) ;

    mr.rdSize     = (sizeof(mr) + cbLogPal) / sizeof(WORD);
    mr.rdFunction = META_CREATEPALETTE;

        // Emit the header.

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Emit the actual logpalette.

        b = bEmit(pLocalDC, lpLogPal, cbLogPal);

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return (b) ;
}

/****************************************************************************
 * CreateBrushIndirect - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreateBrushIndirect
(
PLOCALDC        pLocalDC,
LPWIN16LOGBRUSH lpLogBrush16
)
{
BOOL    b;
METARECORD_CREATEBRUSHINDIRECT mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = META_CREATEBRUSHINDIRECT;
    mr.lb16       = *lpLogBrush16;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * CreateDIPatternBrush - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreateDIBPatternBrush
(
PLOCALDC    pLocalDC,
PBITMAPINFO pBitmapInfo,
DWORD       cbBitmapInfo,
PBYTE       pBits,
DWORD       cbBits,
WORD        iUsage,
WORD        iType
)
{
BOOL    b ;
METARECORD_DIBCREATEPATTERNBRUSH mr;

    mr.rdSize     = (sizeof(mr) + cbBitmapInfo + cbBits + 1) / sizeof(WORD);
    mr.rdFunction = META_DIBCREATEPATTERNBRUSH;
    mr.iType      = iType;
    mr.iUsage     = iUsage;

// On NT, the packed DIB is dword aligned.  But on win3x, it is word aligned.
// Therefore, we emit the bitmap info followed by the bitmap bits in two
// separate stages.

        ASSERTGDI(cbBitmapInfo % 2 == 0,
        "MF3216: bEmitWin16CreateDIBPatternBrush, bad bitmap info size");

        // Emit the static portion of the record.

        b = bEmit(pLocalDC, &mr, sizeof(mr));
        if (b == FALSE)
            goto error_exit ;

        // Emit the bitmap info.

        b = bEmit(pLocalDC, pBitmapInfo, cbBitmapInfo) ;
        if (b == FALSE)
            goto error_exit ;

        // Emit the bitmap bits.

        b = bEmit(pLocalDC, pBits, (cbBits + 1) / sizeof(WORD) * sizeof(WORD)) ;

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

error_exit:
        return(b);
}

/****************************************************************************
 * CreatePen - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreatePen
(
PLOCALDC pLocalDC,
WORD     iPenStyle,
PPOINTS  pptsWidth,
COLORREF crColor
)
{
BOOL    b;
METARECORD_CREATEPENINDIRECT mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = META_CREATEPENINDIRECT;
    mr.lopn16.lopnStyle = iPenStyle;
    mr.lopn16.lopnWidth = *pptsWidth;
    mr.lopn16.lopnColor = crColor;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

//#if 0
/****************************************************************************
 * Escape - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16Escape
(
PLOCALDC pLocalDC,
SHORT    wEscape,
SHORT    wCount,
LPSTR    lpInData,
LPSTR    lpOutData
)
{
BOOL    b ;
METARECORD_ESCAPE mr;

        NOTUSED(lpOutData) ;

        // Init the type & length field of the metafile record.
        // Then emit the header of the escape record to the Win16 metafile.

    mr.rdSize     = (sizeof(mr) + (WORD) wCount) / sizeof(WORD);
    mr.rdFunction = META_ESCAPE;
    mr.wEscape    = wEscape;
    mr.wCount     = (WORD) wCount;

        b = bEmit(pLocalDC, &mr, sizeof(mr));
        if (b)
        {
            // Emit the actual data.
            b = bEmit(pLocalDC, lpInData, (DWORD) (WORD) wCount) ;
        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}
//#endif // 0

/****************************************************************************
 * Escape - Win16 Metafile Emitter for enhanced metafile comment
 ***************************************************************************/
BOOL bEmitWin16EscapeEnhMetaFile
(
  PLOCALDC pLocalDC,
  PMETARECORD_ESCAPE pmfe,
  LPBYTE   lpEmfData
)
{
BOOL    b ;
PMETA_ESCAPE_ENHANCED_METAFILE pmfeEnhMF = (PMETA_ESCAPE_ENHANCED_METAFILE) pmfe;

        // Emit the header of the escape record to the Win16 metafile.

        b = bEmit(pLocalDC, (PVOID) pmfeEnhMF, sizeof(META_ESCAPE_ENHANCED_METAFILE));
        if (b)
        {
            // Emit the enhanced metafile data.
            b = bEmit(pLocalDC, lpEmfData, pmfeEnhMF->cbCurrent);
        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) pmfeEnhMF);

        return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\gpmf3216\win16api.h ===
/****************************************************************************
 *
 *  Win16 Emitter Routines header file
 *
 *  Date:   7/18/91
 *  Author: Jeffrey Newman (c-jeffn)
 *
 ***************************************************************************/

#ifndef _WIN16_MF3216_
#define _WIN16_MF3216_

#pragma pack(1)

#define msosignature            0x50504E54 // Office/Escher signature
#define msocommentBeginSrcCopy  0x0106
#define msocommentEndSrcCopy    0x0107

typedef struct tagRECTS {
    SHORT 	left;
    SHORT 	top;
    SHORT 	right;
    SHORT 	bottom;
} RECTS, *PRECTS;

typedef struct tagWIN16LOGPEN {
    WORD     lopnStyle;
    POINTS   lopnWidth;
    COLORREF lopnColor;
} WIN16LOGPEN, *LPWIN16LOGPEN;

typedef struct tagWIN16LOGBRUSH
  {
    WORD	lbStyle;
    DWORD	lbColor;
    SHORT       lbHatch;
  } WIN16LOGBRUSH, *LPWIN16LOGBRUSH;

typedef struct tagWIN16LOGFONT
{
    SHORT     lfHeight;
    SHORT     lfWidth;
    SHORT     lfEscapement;
    SHORT     lfOrientation;
    SHORT     lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    BYTE      lfFaceName[LF_FACESIZE];
} WIN16LOGFONT, *LPWIN16LOGFONT;

typedef struct tagMETARECORD0 {
    DWORD rdSize;
    WORD  rdFunction;
} METARECORD0;

// Define METARECORD1 through METARECORD9.

#define METARECORD_(n)				\
	typedef struct tagMETARECORD##n {	\
	    DWORD rdSize;			\
	    WORD  rdFunction;			\
	    WORD  rdParm[n];			\
	} METARECORD##n

METARECORD_(1);
METARECORD_(2);
METARECORD_(3);
METARECORD_(4);
METARECORD_(5);
METARECORD_(6);
METARECORD_(7);
METARECORD_(8);
METARECORD_(9);

typedef struct tagMETARECORD_CREATEFONTINDIRECT {
    DWORD rdSize;
    WORD  rdFunction;
    WIN16LOGFONT lf16;
} METARECORD_CREATEFONTINDIRECT;

typedef struct tagMETARECORD_CREATEPENINDIRECT {
    DWORD rdSize;
    WORD  rdFunction;
    WIN16LOGPEN lopn16;
} METARECORD_CREATEPENINDIRECT;

typedef struct tagMETARECORD_CREATEBRUSHINDIRECT {
    DWORD rdSize;
    WORD  rdFunction;
    WIN16LOGBRUSH lb16;
} METARECORD_CREATEBRUSHINDIRECT;

typedef struct tagMETARECORD_DIBCREATEPATTERNBRUSH {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  iType;
    WORD  iUsage;
} METARECORD_DIBCREATEPATTERNBRUSH;

typedef struct tagMETARECORD_POLY {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  cpt;
} METARECORD_POLY;

typedef struct tagMETARECORD_POLYPOLYGON {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  ccpt;
} METARECORD_POLYPOLYGON;

typedef struct tagMETARECORD_DIBSTRETCHBLT {
    DWORD rdSize;
    WORD  rdFunction;
    DWORD rop;
    SHORT cySrc;
    SHORT cxSrc;
    SHORT ySrc;
    SHORT xSrc;
    SHORT cy;
    SHORT cx;
    SHORT y;
    SHORT x;
} METARECORD_DIBSTRETCHBLT;

typedef struct tagMETARECORD_SETPALENTRIES {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  iStart;
    WORD  cEntries;
} METARECORD_SETPALENTRIES;

typedef struct tagMETARECORD_ESCAPE {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  wEscape;
    WORD  wCount;
} METARECORD_ESCAPE, *PMETARECORD_ESCAPE;

#pragma pack()

#define bEmitWin16EOF(pLocalDC)                                            \
                   bW16Emit0(pLocalDC, 0)

#define bEmitWin16RealizePalette(pLocalDC)                                 \
                   bW16Emit0(pLocalDC, META_REALIZEPALETTE)

#define bEmitWin16SaveDC(pLocalDC)                                         \
                   bW16Emit0(pLocalDC, META_SAVEDC)

#define bEmitWin16SetTextAlign(pLocalDC, wFlags)                           \
                   bW16Emit1(pLocalDC, META_SETTEXTALIGN, wFlags)

#define bEmitWin16SetStretchBltMode(pLocalDC, iStretchMode)                \
                   bW16Emit1(pLocalDC, META_SETSTRETCHBLTMODE, iStretchMode)

#define bEmitWin16SetROP2(pLocalDC, nDrawMode)                             \
                   bW16Emit1(pLocalDC, META_SETROP2, nDrawMode)

#define bEmitWin16SetPolyFillMode(pLocalDC, iPolyFillMode)                 \
                   bW16Emit1(pLocalDC, META_SETPOLYFILLMODE, iPolyFillMode)

#define bEmitWin16SetBkMode(pLocalDC, iBkMode)                             \
                   bW16Emit1(pLocalDC, META_SETBKMODE, iBkMode)

#define bEmitWin16SelectPalette(pLocalDC, ihObject)                        \
                   bW16Emit1(pLocalDC, META_SELECTPALETTE, ihObject)

#define bEmitWin16SelectObject(pLocalDC, ihObject)                         \
                   bW16Emit1(pLocalDC, META_SELECTOBJECT, ihObject)

#define bEmitWin16DeleteObject(pLocalDC, ihObject)                         \
                   bW16Emit1(pLocalDC, META_DELETEOBJECT, ihObject)

#define bEmitWin16SetMapMode(pLocalDC, iMapMode)                           \
                   bW16Emit1(pLocalDC, META_SETMAPMODE, iMapMode)

#define bEmitWin16PaintRgn(pLocalDC, ihRgn)                                \
                   bW16Emit1(pLocalDC, META_PAINTREGION, ihRgn)

#define bEmitWin16InvertRgn(pLocalDC, ihRgn)                               \
                   bW16Emit1(pLocalDC, META_INVERTREGION, ihRgn)

#define bEmitWin16RestoreDC(pLocalDC, nSavedDC)                            \
                   bW16Emit1(pLocalDC, META_RESTOREDC, nSavedDC)

#define bEmitWin16ResizePalette(pLocalDC, cEntries) 	                   \
                   bW16Emit1(pLocalDC, META_RESIZEPALETTE, cEntries)

#define bEmitWin16SetTextColor(pLocalDC, crColor)                          \
                   bW16Emit2(pLocalDC, META_SETTEXTCOLOR,                  \
                             HIWORD(crColor), LOWORD(crColor))

#define bEmitWin16SetMapperFlags(pLocalDC, dwFlags)                        \
                   bW16Emit2(pLocalDC, META_SETMAPPERFLAGS,                \
                             HIWORD(dwFlags), LOWORD(dwFlags))

#define bEmitWin16SetBkColor(pLocalDC, crColor)                            \
                   bW16Emit2(pLocalDC, META_SETBKCOLOR,                    \
                             HIWORD(crColor), LOWORD(crColor))

#define bEmitWin16SetWindowOrg(pLocalDC, x, y)                             \
                   bW16Emit2(pLocalDC, META_SETWINDOWORG, x, y)

#define bEmitWin16SetWindowExt(pLocalDC, x, y)                             \
                   bW16Emit2(pLocalDC, META_SETWINDOWEXT, x, y)

#define bEmitWin16SetViewportOrg(pLocalDC, x, y)                           \
                   bW16Emit2(pLocalDC, META_SETVIEWPORTORG, x, y)

#define bEmitWin16SetViewportExt(pLocalDC, x, y)                           \
                   bW16Emit2(pLocalDC, META_SETVIEWPORTEXT, x, y)

#define bEmitWin16OffsetClipRgn(pLocalDC, x, y)                            \
                   bW16Emit2(pLocalDC, META_OFFSETCLIPRGN, x, y)

#define bEmitWin16FillRgn(pLocalDC, ihRgn, ihBrush)                        \
                   bW16Emit2(pLocalDC, META_FILLREGION, ihBrush, ihRgn)

#define bEmitWin16MoveTo(pLocalDC, x, y)                                   \
                   bW16Emit2(pLocalDC, META_MOVETO, x, y)

#define bEmitWin16LineTo(pLocalDC, x, y)                                   \
                   bW16Emit2(pLocalDC, META_LINETO, x, y)

#define bEmitWin16FrameRgn(pLocalDC, ihRgn, ihBrush, nWidth, nHeight)      \
                   bW16Emit4(pLocalDC, META_FRAMEREGION,                   \
                             nWidth, nHeight, ihBrush, ihRgn)

#define bEmitWin16ExcludeClipRect(pLocalDC, xLeft, yTop, xRight, yBottom)  \
                   bW16Emit4(pLocalDC, META_EXCLUDECLIPRECT,               \
                             xLeft, yTop, xRight, yBottom)

#define bEmitWin16IntersectClipRect(pLocalDC, xLeft, yTop, xRight, yBottom)\
                   bW16Emit4(pLocalDC, META_INTERSECTCLIPRECT,             \
                             xLeft, yTop, xRight, yBottom)

#define bEmitWin16SetPixel(pLocalDC, x, y, crColor)                        \
                   bW16Emit4(pLocalDC, META_SETPIXEL, x, y,                \
                             HIWORD(crColor), LOWORD(crColor))

#define bEmitWin16ExtFloodFill(pLocalDC, x, y, crColor, iMode)             \
                   bW16Emit5(pLocalDC, META_EXTFLOODFILL, x, y,            \
                             HIWORD(crColor), LOWORD(crColor), iMode)

#define bEmitWin16Rectangle(pLocalDC, x1, y1, x2, y2)                      \
                   bW16Emit4(pLocalDC, META_RECTANGLE, x1, y1, x2, y2)

#define bEmitWin16Ellipse(pLocalDC, x1, y1, x2, y2)                        \
                   bW16Emit4(pLocalDC, META_ELLIPSE, x1, y1, x2, y2)

#define bEmitWin16RoundRect(pLocalDC, x1, y1, x2, y2, x3, y3)              \
                   bW16Emit6(pLocalDC, META_ROUNDRECT, x1, y1, x2, y2, x3, y3)

#define bEmitWin16Arc(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4)            \
                   bW16Emit8(pLocalDC, META_ARC,                           \
                             x1, y1, x2, y2, x3, y3, x4, y4)

#define bEmitWin16Chord(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4)          \
                   bW16Emit8(pLocalDC, META_CHORD,                         \
                             x1, y1, x2, y2, x3, y3, x4, y4)

#define bEmitWin16Pie(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4)            \
                   bW16Emit8(pLocalDC, META_PIE,                           \
                             x1, y1, x2, y2, x3, y3, x4, y4)

#define bEmitWin16BitBltNoSrc(pLocalDC, x, y, cx, cy, rop)		   \
                   bW16Emit9(pLocalDC, META_DIBBITBLT,                     \
                             x, y, cx, cy, 0, 0, 0, HIWORD(rop), LOWORD(rop))
                             
#define bEmitWin16EmitSrcCopyComment(pLocalDC, code)                \
                    bW16Emit5(pLocalDC, META_ESCAPE, code, HIWORD(msosignature),\
                    LOWORD(msosignature), 0x0006, MFCOMMENT)

BOOL bW16Emit0
(
PLOCALDC pLocalDC,
WORD     RecordID
) ;

BOOL bW16Emit1
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1
) ;

BOOL bW16Emit2
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2
) ;

BOOL bW16Emit4
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4
) ;

BOOL bW16Emit5
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4,
WORD     x5
) ;

BOOL bW16Emit6
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4,
WORD     x5,
WORD     x6
) ;

BOOL bW16Emit8
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4,
WORD     x5,
WORD     x6,
WORD     x7,
WORD     x8
) ;

BOOL bW16Emit9
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4,
WORD     x5,
WORD     x6,
WORD     x7,
WORD     x8,
WORD     x9
) ;

BOOL bEmitWin16CreateFontIndirect
(
  PLOCALDC pLocalDC,
  LPWIN16LOGFONT lpWin16LogFont
) ;

BOOL bEmitWin16Poly
(
  PLOCALDC pLocalDC,
  LPPOINTS ppt,
  SHORT    cpt,
  WORD     metaType
) ;

BOOL bEmitWin16PolyPolygon
(
  PLOCALDC pLocalDC,
  PPOINTS  ppt,
  PWORD    pcpt,
  WORD     cpt,
  WORD     ccpt
) ;

BOOL bEmitWin16StretchBlt
(
  PLOCALDC pLocalDC,
  SHORT    x,
  SHORT    y,
  SHORT    cx,
  SHORT    cy,
  SHORT    xSrc,
  SHORT    ySrc,
  SHORT    cxSrc,
  SHORT    cySrc,
  DWORD    rop,
  PBITMAPINFO lpbmi,
  DWORD       cbbmi,
  PBYTE    lpBits,
  DWORD    cbBits
) ;

BOOL bEmitWin16ExtTextOut
(
  PLOCALDC pLocalDC,
  SHORT    x,
  SHORT    y,
  WORD     fwOpts,
  PRECTS   prcts,
  PSTR     ach,
  SHORT    nCount,
  PWORD    lpDx
) ;

BOOL bEmitWin16CreateRegion
(
PLOCALDC pLocalDC,
DWORD    cbRgn,
PVOID    pRgn
) ;

BOOL bEmitWin16SetPaletteEntries
(
PLOCALDC        pLocalDC,
DWORD           iStart,
DWORD           cEntries,
LPPALETTEENTRY  pPalEntries
) ;

BOOL bEmitWin16CreatePalette
(
PLOCALDC     pLocalDC,
LPLOGPALETTE lpLogPal
) ;

BOOL bEmitWin16CreateBrushIndirect
(
  PLOCALDC        pLocalDC,
  LPWIN16LOGBRUSH lpLogBrush16
) ;

BOOL bEmitWin16CreateDIBPatternBrush
(
  PLOCALDC    pLocalDC,
  PBITMAPINFO pBitmapInfo,
  DWORD       cbBitmapInfo,
  PBYTE       pBits,
  DWORD       cbBits,
  WORD        iUsage,
  WORD        iType
) ;

BOOL bEmitWin16CreatePen
(
  PLOCALDC pLocalDC,
  WORD     iPenStyle,
  PPOINTS  pptsWidth,
  COLORREF crColor
) ;

BOOL bEmitWin16Escape
(
PLOCALDC pLocalDC,
SHORT    wEscape,
SHORT    wCount,
LPSTR    lpInData,
LPSTR    lpOutData
) ;

BOOL bEmitWin16EscapeEnhMetaFile
(
  PLOCALDC pLocalDC,
  PMETARECORD_ESCAPE pmfeEnhMF,
  LPBYTE   lpEmfData
) ;
#endif // _WIN16_MF3216_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\precomp.hpp ===
#include <stddef.h>
#include <math.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>

#include <windows.h>

#include <objbase.h>
#include <ddraw.h>
#include <icm.h>

#include "..\Runtime\Runtime.hpp"

#include "imaging.h"
#include "comutils.hpp"
#include "imgutils.hpp"
#include "memstream.hpp"
#include "filestream.hpp"
#include "mmx.hpp"
#include "colorpal.hpp"
#include "decodedimg.hpp"
#include "bitmap.hpp"
#include "recolor.hpp"
#include "..\Render\FormatConverter.hpp"
#include "imgfactory.hpp"
#include "codecmgr.hpp"
#include "resample.hpp"
#include "imgrsrc.h"
#include "icmdll.hpp"

#include "..\common\monitors.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\bitmap.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   bitmap.hpp
*
* Abstract:
*
*   GpMemoryBitmap class declarations
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _BITMAP_HPP
#define _BITMAP_HPP

#include "propertyutil.hpp"

//--------------------------------------------------------------------------
// Information about various pixel data formats we support
//--------------------------------------------------------------------------

struct PixelFormatDescription
{
    BYTE Abits;
    BYTE Rbits;
    BYTE Gbits;
    BYTE Bbits;
    PixelFormatID pixelFormat;
};

extern const PixelFormatDescription PixelFormatDescs[];


// Make sure that we only accept a valid pixelformat
inline PixelFormatID 
MaskPixelFormat(PixelFormatID pixel)
{
    return (PixelFormatID)(pixel & 0xffffff);
}

// Extract the index field from the pixel format ID

inline UINT
GetPixelFormatIndex(
    PixelFormatID pixfmt
    )
{
    return pixfmt & 0xff;
}

// Check if a pixel format ID is valid

inline BOOL
IsValidPixelFormat(
    PixelFormatID pixfmt
    )
{
    UINT index = GetPixelFormatIndex(pixfmt);

    return index < PIXFMT_MAX &&
           PixelFormatDescs[index].pixelFormat == (pixfmt & 0xffffff);
}

// Determine if the pixel format is supported by GDI

inline BOOL
IsGDIPixelFormat(
    PixelFormatID pixfmt
    )
{
    return (pixfmt & PIXFMTFLAG_GDI) != 0;
}

// Whether the pixel format can have alpha

inline BOOL
CanHaveAlpha(
    PixelFormatID pixfmt,
    const ColorPalette* pal
    )
{
    return IsAlphaPixelFormat(pixfmt) ||
           IsIndexedPixelFormat(pixfmt);
//           pal && (pal->Flags & PALFLAG_HASALPHA);
}

// Scanline stride for our internal bitmaps are always multiples of 4

#define STRIDE_ALIGNMENT(x) (((x) + 3) & ~3)

inline UINT
CalcScanlineStride(
    UINT width,
    UINT pixsize
    )
{
    return STRIDE_ALIGNMENT((width * pixsize + 7) >> 3);
}

// Convert pixel unit to 0.01mm unit

inline INT
Pixel2HiMetric(
    INT pixels,
    double dpi
    )
{
    return (INT) (pixels * 2540.0 / dpi + 0.5);
}

// Convert 0.01mm unit to pixel unit

inline INT
HiMetric2Pixel(
    INT himetric,
    double dpi
    )
{
    return (INT) (himetric * dpi / 2540.0 + 0.5);
}

enum ColorAdjustType;

//--------------------------------------------------------------------------
// GpMemoryBitmap class
//--------------------------------------------------------------------------

class GpRecolor;
class GpDecodedImage;

class GpMemoryBitmap :
            public IBitmapImage,
            public IImage,
            public IImageSink,
            public IBasicBitmapOps,
            public BitmapData
{
    friend class GpBitmapDecodeSink;
    friend class GpBitmap;
    friend class CopyOnWriteBitmap;
    

public:


    //------------------------------------------------------------
    // Public constructors/destructors used internally
    // by ourselves
    //------------------------------------------------------------

    GpMemoryBitmap();
    virtual ~GpMemoryBitmap();

    // Initialize a new bitmap image object of the specified
    // dimension and pixel format.

    HRESULT
    InitNewBitmap(
        IN UINT width,
        IN UINT height,
        IN PixelFormatID pixelFormat,
        BOOL clear = FALSE
        );

    // Initialize a new bitmap image with an IImage object

    HRESULT
    InitImageBitmap(
        IN IImage* image,
        IN UINT width,
        IN UINT height,
        IN PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        IN DrawImageAbort callback = NULL,
        IN VOID* callbackData = NULL
        );

    // Initialize a new bitmap image object with
    // user-supplied memory buffer

    HRESULT
    InitMemoryBitmap(
        IN BitmapData* bitmapData
        );

    // Initialize a new bitmap image object as
    // a wrapper around a direct draw surface.

    HRESULT
    InitDirectDrawBitmap(
        IN IDirectDrawSurface7 * suface
        );

    // Create a new bitmap image object from an IImage object

    static HRESULT
    CreateFromImage(
        IN IImage* image,
        IN UINT width,
        IN UINT height,
        IN PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT GpMemoryBitmap** bmp,
        IN DrawImageAbort callback = NULL,
        IN VOID* callbackData = NULL
        );

    // Save the bitmap object to a stream

    HRESULT
    SaveToStream(
        IN IStream* stream,
        IN CLSID* clsidEncoder,
        IN EncoderParameters* encoderParams,
        IN BOOL fSpecialJPEG,
        OUT IImageEncoder** ppEncoderPtr,
        IN GpDecodedImage* pImageSrc = NULL
        );

    // Save the bitmap object to a stream

    HRESULT
    SaveToFile(
        IN const WCHAR* filename,
        IN CLSID* clsidEncoder,
        IN EncoderParameters* encoderParams,
        IN BOOL fSpecialJPEG,
        OUT IImageEncoder** ppEncoderPtr,
        IN GpDecodedImage* pImageSrc = NULL
        );

    // Append the bitmap object to current encoder object

    HRESULT
    SaveAppend(
        IN const EncoderParameters* encoderParams,
        IN IImageEncoder* destEncoderPtr,
        IN GpDecodedImage* pImageSrc = NULL
        );

    // Get the encoder parameter list size

    HRESULT
    GetEncoderParameterListSize(
        IN  CLSID* clsidEncoder,
        OUT UINT* size
        );

    // Get the encoder parameter list
    
    HRESULT
    GetEncoderParameterList(
        IN CLSID* clsidEncoder,
        IN UINT size,
        OUT EncoderParameters* pBuffer
        );

    // Color adjustment

    HRESULT
    PerformColorAdjustment(
        IN GpRecolor* recolor,
        IN ColorAdjustType type,
        IN DrawImageAbort callback,
        IN VOID* callbackData
        );

    STDMETHOD(GetPropertyCount)(
        OUT UINT*   numOfProperty
        );

    STDMETHOD(GetPropertyIdList)(
        IN UINT numOfProperty,
        IN OUT PROPID* list
        );

    STDMETHOD(GetPropertyItemSize)(
        IN PROPID propId, 
        OUT UINT* size
        );

    STDMETHOD(GetPropertyItem)(
        IN PROPID            propId,
        IN UINT              propSize,
        IN OUT PropertyItem* buffer
        );

    STDMETHOD(GetPropertySize)(
        OUT UINT* totalBufferSize,
        OUT UINT* numProperties
        );

    STDMETHOD(GetAllPropertyItems)(
        IN UINT totalBufferSize,
        IN UINT numProperties,
        IN OUT PropertyItem* allItems
        );

    STDMETHOD(RemovePropertyItem)(
        IN PROPID   propId
        );

    STDMETHOD(SetPropertyItem)(
        IN PropertyItem item
        );

    //------------------------------------------------------------
    // Public IImage interface methods
    //------------------------------------------------------------

    // Overwritten QueryInterface method

    STDMETHOD(QueryInterface)(
        REFIID riid,
        VOID** ppv
        );

    // Increment reference count

    STDMETHOD_(ULONG, AddRef)(VOID)
    {
        return InterlockedIncrement(&comRefCount);
    }

    // Decrement reference count

    STDMETHOD_(ULONG, Release)(VOID)
    {
        ULONG count = InterlockedDecrement(&comRefCount);

        if (count == 0)
            delete this;

        return count;
    }

    // Get the device-independent physical dimension of the image
    //  in unit of 0.01mm

    STDMETHOD(GetPhysicalDimension)(
        OUT SIZE* size
        );

    // Get basic image information

    STDMETHOD(GetImageInfo)(
        OUT ImageInfo* imageInfo
        );

    // Set image flags

    STDMETHOD(SetImageFlags)(
        IN UINT flags
        );
 
    // Display the image in a GDI device context

    STDMETHOD(Draw)(
        IN HDC hdc,
        IN const RECT* dstRect,
        IN OPTIONAL const RECT* srcRect
        );

    // Push image data into an IImageSink

    STDMETHOD(PushIntoSink)(
        IN IImageSink* sink
        );

    // Get a thumbnail representation for the image object

    STDMETHOD(GetThumbnail)(
        IN OPTIONAL UINT thumbWidth,
        IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage
        );

    //------------------------------------------------------------
    // Public IBitmapImage interface methods
    //------------------------------------------------------------

    // Get bitmap dimensions in pixels

    STDMETHOD(GetSize)(
        OUT SIZE* size
        );

    // Get bitmap pixel format

    STDMETHOD(GetPixelFormatID)(
        OUT PixelFormatID* pixelFormat
        )
    {
        ASSERT(IsValid());

        *pixelFormat = this->PixelFormat;
        return S_OK;
    }

    // Access bitmap data in native pixel format

    STDMETHOD(LockBits)(
        IN const RECT* rect,
        IN UINT flags,
        IN PixelFormatID pixelFormat,
        OUT BitmapData* lockedBitmapData
        );

    STDMETHOD(UnlockBits)(
        IN const BitmapData* lockedBitmapData
        );

    // Set/get palette associated with the bitmap image

    STDMETHOD(GetPalette)(
        OUT ColorPalette** palette
        );

    STDMETHOD(SetPalette)(
        IN const ColorPalette* palette
        );

    //------------------------------------------------------------
    // Public IImageSInk interface methods
    //------------------------------------------------------------

    // Begin the sink process

    STDMETHOD(BeginSink)(
        IN OUT ImageInfo* imageInfo,
        OUT OPTIONAL RECT* subarea
        );

    // End the sink process

    STDMETHOD(EndSink)(
        IN HRESULT statusCode
        );

    // Ask the sink to allocate pixel data buffer

    STDMETHOD(GetPixelDataBuffer)(
        IN const RECT* rect,
        IN PixelFormatID pixelFormat,
        IN BOOL lastPass,
        OUT BitmapData* bitmapData
        );

    // Give the sink pixel data and release data buffer

    STDMETHOD(ReleasePixelDataBuffer)(
        IN const BitmapData* bitmapData
        );

    // Push pixel data

    STDMETHOD(PushPixelData)(
        IN const RECT* rect,
        IN const BitmapData* bitmapData,
        IN BOOL lastPass
        );

    // Push raw image data

    STDMETHOD(PushRawData)(
        IN const VOID* buffer,
        IN UINT bufsize
        );

    STDMETHOD(NeedTransform)(
        OUT UINT* rotation
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(NeedRawProperty)(void *pSrc)
    {
        // GpMemoryBitmap can't handle raw property

        return E_FAIL;
    }
    
    STDMETHOD(PushRawInfo)(
        IN OUT void* info
        )
    {
        return E_NOTIMPL;
    }
    
    STDMETHOD(GetPropertyBuffer)(
        IN     UINT            uiTotalBufferSize,
        IN OUT PropertyItem**  ppBuffer
        )
    {
        return E_NOTIMPL;
    }
    
    STDMETHOD(PushPropertyItems)(
        IN UINT             numOfItems,
        IN UINT             uiTotalBufferSize,
        IN PropertyItem*    item,
        IN BOOL             fICCProfileChanged
        )
    {
        return E_NOTIMPL;
    }
    
    //------------------------------------------------------------
    // Public IBasicBitmapOps interface methods
    //------------------------------------------------------------

    // Clone an area of the bitmap image

    STDMETHOD(Clone)(
        IN OPTIONAL const RECT* rect,
        OUT IBitmapImage** outbmp,
        BOOL    bNeedCloneProperty
        );

    // Flip the bitmap image in x- and/or y-direction

    STDMETHOD(Flip)(
        IN BOOL flipX,
        IN BOOL flipY,
        OUT IBitmapImage** outbmp
        );

    // Resize the bitmap image

    STDMETHOD(Resize)(
        IN UINT newWidth,
        IN UINT newHeight,
        IN PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT IBitmapImage** outbmp
        );

    // Rotate the bitmap image by the specified angle

    STDMETHOD(Rotate)(
        IN FLOAT angle,
        IN InterpolationHint hints,
        OUT IBitmapImage** outbmp
        );

    // Adjust the brightness of the bitmap image

    STDMETHOD(AdjustBrightness)(
        IN FLOAT percent
        );

    // Adjust the contrast of the bitmap image

    STDMETHOD(AdjustContrast)(
        IN FLOAT shadow,
        IN FLOAT highlight
        );

    // Adjust the gamma of the bitmap image

    STDMETHOD(AdjustGamma)(
        IN FLOAT gamma
        );

    //------------------------------------------------------------
    // Public methods used internally by ourselves
    //------------------------------------------------------------

    // Check if the image object is in valid state

    BOOL IsValid() const
    {
        return (Scan0 != NULL ||
                (creationFlag == CREATEDFROM_DDRAWSURFACE &&
                 ddrawSurface != NULL));
    }

    HRESULT
    SetResolution(REAL Xdpi, REAL Ydpi)
    {
        HRESULT hr = S_OK;

        if ((Xdpi > 0.0) && (Ydpi > 0.0))
        {
            xdpi = static_cast<double>(Xdpi);
            ydpi = static_cast<double>(Ydpi);
        }
        else
        {
            hr = E_INVALIDARG;
        }

        return hr;
    }

    // Indicate the type of alpha in the bitmap

    // !!! TO DO: after we remove imaging.dll, we should remove these and use
    // the DpTransparency flags instead

    enum
    {
        ALPHA_UNKNOWN,
        ALPHA_COMPLEX,
        ALPHA_SIMPLE,
        ALPHA_OPAQUE,
        ALPHA_NEARCONSTANT,
        ALPHA_NONE
    };

    HRESULT SetMinMaxAlpha (BYTE minAlpha, BYTE maxAlpha);
    HRESULT GetMinMaxAlpha (BYTE* minAlpha, BYTE* maxAlpha);

    HRESULT GetAlphaHint(INT* alphaHint);
    HRESULT SetAlphaHint(INT alphaHint);

    HRESULT SetSpecialJPEG(GpDecodedImage *pImgSrc);

protected:

    // Allocate/free pixel data buffer

    static BOOL
    AllocBitmapData(
        UINT width,
        UINT height,
        PixelFormatID pixelFormat,
        BitmapData* bmpdata,
        INT *alphaFlags,
        BOOL clear = FALSE
        );

    static VOID
    FreeBitmapData(
        const BitmapData* bmpdata
        );

private:

    // Indicate how a bitmap object was created

    enum
    {
        CREATEDFROM_NONE,
        CREATEDFROM_NEW,
        CREATEDFROM_IMAGE,
        CREATEDFROM_USERBUF,
        CREATEDFROM_DDRAWSURFACE
    };

    LONG comRefCount;           // COM object reference count
    GpLockable objectLock;      // object busy lock
    LONG bitsLock;              // whether the pixel data has been locked
    double xdpi, ydpi;          // resolution
    INT creationFlag;           // how was the bitmap object created
    UINT cacheFlags;            // image flags
    ColorPalette *colorpal;     // color palette
    RECT lockedArea;            // area that has been locked
    IPropertySetStorage *propset; // bitmap image properties
    IDirectDrawSurface7 *ddrawSurface; // direct draw surface
    PROFILE *sourceFProfile;    // source color profile for the front end.
                                // usually extracted from the embedded image profile.
    INT alphaTransparency;

    BYTE minAlpha;
    BYTE maxAlpha;

    // Support DrawImage abort

    DrawImageAbort callback;
    VOID* callbackData;

    // Property related private members
    
    InternalPropertyItem    PropertyListHead;
    InternalPropertyItem    PropertyListTail;
    UINT                    PropertyListSize;
    UINT                    PropertyNumOfItems;
    
    IImageDecoder           *JpegDecoderPtr;    // Pointer to source decoder

    HRESULT
    AllocBitmapMemory(
        UINT width,
        UINT height,
        PixelFormatID pixelFormat,
        BOOL clear = FALSE
        );

    VOID FreeBitmapMemory();

    // Determine if a specified rectangle is a valid subarea of the image

    BOOL
    ValidateImageArea(
        RECT* dstrect,
        const RECT* srcrect
        )
    {
        if (srcrect == NULL)
        {
            dstrect->left = dstrect->top = 0;
            dstrect->right = Width;
            dstrect->bottom = Height;
        }
        else
        {
            if (srcrect->left < 0 ||
                srcrect->right < 0 ||
                srcrect->left >= srcrect->right ||
                srcrect->right > (INT) Width ||
                srcrect->top >= srcrect->bottom ||
                srcrect->bottom > (INT) Height)
            {
                return FALSE;
            }

            *dstrect = *srcrect;
        }

        return TRUE;
    }

    // Helper functions for locking/unlocking ddraw surface
    HRESULT LockDirectDrawSurface();
    HRESULT UnlockDirectDrawSurface();

    // Internal implementation of IBitmapImage::LockBits and 
    // IBitmapImage::UnlockBits methods. We assume the parameter
    // validation and other house-keeping chores have already been done.

    HRESULT
    InternalLockBits(
        const RECT* rect,
        UINT flags,
        PixelFormatID pixfmt,
        BitmapData* lockedData
        );
    
    HRESULT
    InternalUnlockBits(
        const RECT* rect,
        const BitmapData* lockedData
        );

    // Draw the bitmap using GDI calls

    HRESULT
    DrawWithGDI(
        HDC hdc,
        const RECT* dstRect,
        RECT* srcRect
        );

    // Draw the bitmap by creating temporary canonical bitmap

    HRESULT
    DrawCanonical(
        HDC hdc,
        const RECT* dstRect,
        RECT* srcRect
        );

    // Compose a BitmapData structure for the specified
    // area of the bitmap image.

    VOID
    GetBitmapAreaData(
        const RECT* rect,
        BitmapData* bmpdata
        )
    {
        bmpdata->Width = rect->right - rect->left;
        bmpdata->Height = rect->bottom - rect->top;
        bmpdata->PixelFormat = PixelFormat;
        bmpdata->Stride = Stride;
        bmpdata->Reserved = 0;

        bmpdata->Scan0 = (BYTE*) Scan0 +
                         rect->top * Stride +
                         (rect->left * GetPixelFormatSize(PixelFormat) >> 3);
    }

    // Copy palette, flags, etc.

    HRESULT
    CopyPaletteFlagsEtc(
        const GpMemoryBitmap* srcbmp
        )
    {
        HRESULT hr;

        // Copy color palette, if any

        if (srcbmp->colorpal)
        {
            hr = this->SetPalette(srcbmp->colorpal);

            if (FAILED(hr))
                return hr;
        }

        // Copy flags, etc.
        //  !!! TODO

        return S_OK;
    }

    // Perform point operation on a bitmap image

    HRESULT
    PerformPointOps(
        const BYTE lut[256]
        );

    // Get the current palette associated with the bitmap image

    const ColorPalette*
    GetCurrentPalette() const
    {
        if (colorpal)
            return colorpal;
        else if (IsIndexedPixelFormat(PixelFormat))
            return GetDefaultColorPalette(PixelFormat);
        else
            return NULL;
    }

    // Set the state needed to support DrawImage abort and color adjust

    VOID
    SetDrawImageSupport(
        IN DrawImageAbort newCallback,
        IN VOID* newCallbackData
        )
    {
        callback = newCallback;
        callbackData = newCallbackData;
    }

    // Save image property items to the destination sink

    HRESULT
    SavePropertyItems(
        IN GpDecodedImage* pImageSrc,
        IImageSink* pEncodeSink
        );

    HRESULT
    SetJpegQuantizationTable(
        IN IImageEncoder* pEncoder
        );

    // Copy all the property items from current GpMemoryBitmap to the dst object

    HRESULT
    ClonePropertyItems(
        IN GpMemoryBitmap* dstBmp
        );
};

//
// Map COLORREF values to ARGB values
//

inline ARGB COLORREFToARGB(COLORREF color)
{
    return (ARGB) 0xff000000 |
           ((ARGB) (color & 0xff) << 16) |
           ((ARGB) color & 0x00ff00) |
           ((ARGB) (color >> 16) & 0xff);
}

//
// Map ARGB values to COLORREF values
//

inline COLORREF ARGBToCOLORREF(ARGB argb)
{
    //  alpha component is simply ignored
    return (COLORREF)(((argb >> 16) & 0xff) | 
                      (argb & 0x0000ff00) | 
                      ((argb & 0xff) << 16));
}

//
// Flag bits for BitmapData.bmpdataFlags field
//  low-word = ImageLockMode
//  high-word = flag bits below
//

enum
{
    BMPDATA_MALLOC = 0x00010000,
    BMPDATA_VALLOC = 0x00020000,

    BMPDATA_ALLOCMASK = BMPDATA_MALLOC|BMPDATA_VALLOC,
    BMPDATA_LOCKMODEMASK = 0xffff,
};

//
// Perform pixel data format conversion
//

HRESULT
ConvertBitmapData(
    const BitmapData* dstbmp,
    const ColorPalette* dstpal,
    const BitmapData* srcbmp,
    const ColorPalette* srcpal
    );

HRESULT
ConvertBitmapDataSrcUnaligned(
    const BitmapData* dstbmp,
    const ColorPalette* dstpal,
    const BitmapData* srcbmp,
    const ColorPalette* srcpal,
    UINT startBit
    );

HRESULT
ConvertBitmapDataDstUnaligned(
    const BitmapData* dstbmp,
    const ColorPalette* dstpal,
    const BitmapData* srcbmp,
    const ColorPalette* srcpal,
    UINT startBit
    );

#endif // !_BITMAP_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\sources.inc ===
!ifndef GDIPROOT
GDIPROOT=$(ADVCORE_PATH)\gdiplus
!endif

!include $(GDIPROOT)\sources.inc

GDIPIMG=$(GDIPROOT)\engine\imaging
INCLUDES=\
    $(INCLUDES);\
    $(BASE_INC_PATH);\
    $(GDIPIMG)\api;\
    $(GDIPROOT)\sdkinc;\
    $(GDIPROOT)\privinc;..;.\

MAJORCOMP=windows
MINORCOMP=gdiplus

CHICAGO_PRODUCT=1

## SubSystem must be 4.00 to load on Win95

SUBSYSTEM_VERSION=4.00

C_DEFINES=$(C_DEFINES) -DWINVER=0x0500

# The imaging code has 3 targets - IMAGING.DLL, GDIPLUS.DLL and GDIPSTAT.LIB
#
# All 3 link to the files listed in LIBIMAGINGLIBS,
# but only GDIPLUS.DLL and IMAGING.DLL link to the ones in IMAGINGLIBS.

LIBIMAGINGLIBS=\
    $(GDIPIMG)\bmp\$(O)\bmp.lib \
    $(GDIPIMG)\jpeg\lib\$(O)\jpeg.lib \
    $(GDIPIMG)\jpeg\libjpegmem\$(O)\jpegmem.lib \
    $(GDIPIMG)\gif\lib\$(O)\gif.lib \
    $(GDIPIMG)\gif\liblzw\$(O)\liblzw.lib \
    $(GDIPIMG)\png\lib\$(O)\png.lib \
    $(GDIPIMG)\emf\$(O)\emf.lib \
    $(GDIPIMG)\wmf\$(O)\wmf.lib \
    $(GDIPIMG)\off_tiff\lib\$(O)\tiff.lib \
    $(GDIPIMG)\off_tiff\libtiff\$(O)\libtiff.lib \
    $(GDIPIMG)\ico\$(O)\ico.lib \
    $(GDIPIMG)\api\$(O)\imageapi.lib

    
IMAGINGLIBS=\
    $(LIBIMAGINGLIBS) \
    $(GDIPIMG)\png\libpng\$(O)\libpng.lib \
    $(BASE_LIB_PATH)\zlib.lib \
    $(GDIPIMG)\jpeg\libjpeg\lib\$(O)\jpegfull.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\codecmgr.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   codecmgr.hpp
*
* Abstract:
*
*   Codec management functions
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _CODECMGR_HPP
#define _CODECMGR_HPP

//
// Various data structures for maintaining the cache of codecs
//
typedef HRESULT (*CreateCodecInstanceProc)(REFIID, VOID**);

struct CachedCodecInfo : public ImageCodecInfo
{
    CachedCodecInfo* next;
    CachedCodecInfo* prev;
    UINT structSize;
    CreateCodecInstanceProc creationProc;
};

extern CachedCodecInfo* CachedCodecs;      // cached list of codecs
extern BOOL CodecCacheUpdated;             // when cachedcode list has been udpated

//
// Get a decoder object that can process the specified data stream
//

HRESULT
CreateDecoderForStream(
    IStream* stream,
    IImageDecoder** decoder,
    DecoderInitFlag flags
    );

//
// Get an encoder parameter list size
//
HRESULT
CodecGetEncoderParameterListSize(
    const CLSID* clsid,
    UINT*   size
    );

//
// Get an encoder parameter list
//
HRESULT
CodecGetEncoderParameterList(
    const CLSID*    clsid,
    const IN UINT   size,
    OUT EncoderParameters*  pBuffer
    );

//
// Get an encoder object to output to the specified stream
//

HRESULT
CreateEncoderToStream(
    const CLSID* clsid,
    IStream* stream,
    IImageEncoder** encoder
    );

//
// Initialize cached list of decoders and encoders
// by reading information out of the registry.
//

VOID ReloadCachedCodecInfo();

//
// Free any cached information about installed codecs
//

VOID
FreeCachedCodecInfo(
    UINT flags
    );

//
// Get the list of installed codecs
//

HRESULT
GetInstalledCodecs(
    UINT* count,
    ImageCodecInfo** codecs,
    UINT selectionFlag
    );

//
// Install a codec: save relevant information into the registry
//

HRESULT
InstallCodec(
    const ImageCodecInfo* codecInfo
    );

// Uninstall a codec

HRESULT
UninstallCodec(
    const WCHAR* codecName,
    UINT flags
    );

#endif // !_CODECMGR_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\bitmap.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   bitmap.cpp
*
* Abstract:
*
*   Implementation of Bitmap class:
*       basic operations such as constructors/destructor
*       IBitmapImage methods
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "propertyutil.hpp"

#include "..\..\render\srgb.hpp"

//
// Information about various pixel data formats
//

const struct PixelFormatDescription PixelFormatDescs[PIXFMT_MAX] =
{
    {  0,  0,  0,  0, PIXFMT_UNDEFINED       },
    {  0,  0,  0,  0, PIXFMT_1BPP_INDEXED    },
    {  0,  0,  0,  0, PIXFMT_4BPP_INDEXED    },
    {  0,  0,  0,  0, PIXFMT_8BPP_INDEXED    },
    {  0,  0,  0,  0, PIXFMT_16BPP_GRAYSCALE },
    {  0,  5,  5,  5, PIXFMT_16BPP_RGB555    },
    {  0,  5,  6,  5, PIXFMT_16BPP_RGB565    },
    {  1,  5,  5,  5, PIXFMT_16BPP_ARGB1555  },
    {  0,  8,  8,  8, PIXFMT_24BPP_RGB       },
    {  0,  8,  8,  8, PIXFMT_32BPP_RGB       },
    {  8,  8,  8,  8, PIXFMT_32BPP_ARGB      },
    {  8,  8,  8,  8, PIXFMT_32BPP_PARGB     },
    {  0, 16, 16, 16, PIXFMT_48BPP_RGB       },
    { 16, 16, 16, 16, PIXFMT_64BPP_ARGB      },
    { 16, 16, 16, 16, PIXFMT_64BPP_PARGB     }
};

typedef HRESULT (WINAPI *ALPHABLENDFUNCTION)(HDC hdcDest,
                                             int nXOriginDest,
                                             int nYOriginDest,
                                             int nWidthDest,
                                             int hHeightDest,
                                             HDC hdcSrc,
                                             int nXOriginSrc,
                                             int nYOriginSrc,
                                             int nWidthSrc,
                                             int nHeightSrc,
                                             BLENDFUNCTION blendFunction
                                             );

BOOL                fHasLoadedMSIMG32 = FALSE;
HINSTANCE           g_hInstMsimg32 = NULL;
ALPHABLENDFUNCTION  pfnAlphaBlend = (ALPHABLENDFUNCTION)NULL;

ALPHABLENDFUNCTION
GetAlphaBlendFunc()
{
    // This is the first time we call this function. First we need to acquire
    // global critical section to protect 2+ threads calling this function at
    // the same time

    ImagingCritSec critsec;

    if ( fHasLoadedMSIMG32 == TRUE )
    {
        // We have already loaded

        return pfnAlphaBlend;
    }

    // Do a check again just to prevent this scenario:
    // 2+ threads calling this function at the same time. At that time, we
    // haven't call LoadLibrary() yet. So 1 thread get the critical section and
    // falls through doing the load. The others are blocked at above function
    // call. So when the 1st one finished. The flag should be set to TRUE and
    // we should return immediately.

    if ( fHasLoadedMSIMG32 == TRUE )
    {
        // The first thread has already loaded the dll. Just return here

        return pfnAlphaBlend;
    }

    g_hInstMsimg32 = LoadLibraryA("msimg32.dll");
    
    if ( g_hInstMsimg32 )
    {
        pfnAlphaBlend = (ALPHABLENDFUNCTION)GetProcAddress(g_hInstMsimg32,
                                                           "AlphaBlend");
    }

    // No matter fail or succeed, we always set this flag to TRUE

    fHasLoadedMSIMG32 = TRUE;

    return pfnAlphaBlend;
}// GetAlphaBlendFunc()

/**************************************************************************\
*
* Function Description:
*
*   Implementation of QueryInterface method
*
* Arguments:
*
*   riid - Specifies the interface ID to be queried
*   ppv - Returns a pointer to the interface found
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IBitmapImage)
        *ppv = static_cast<IBitmapImage*>(this);
    else if (riid == IID_IImage)
        *ppv = static_cast<IImage*>(this);
    else if (riid == IID_IUnknown)
        *ppv = static_cast<IUnknown*>(static_cast<IBitmapImage*>(this));
    else if (riid == IID_IBasicBitmapOps)
        *ppv = static_cast<IBasicBitmapOps*>(this);
    else if (riid == IID_IImageSink)
        *ppv = static_cast<IImageSink*>(this);
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Create a new GpMemoryBitmap object and
*   intializes it to its default state
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

GpMemoryBitmap::GpMemoryBitmap()
{
    // Initialize the bitmap object to its default state

    Scan0 = NULL;
    Width = Height = 0;
    Stride = 0;
    PixelFormat = PIXFMT_UNDEFINED;
    Reserved = 0;
    comRefCount = 1;
    bitsLock = -1;

    // Start: [Bug 103296]
    // Change this code to use Globals::DesktopDpiX and Globals::DesktopDpiY
    HDC hdc;
    hdc = ::GetDC(NULL);
    if ((hdc == NULL) || 
        ((xdpi = (REAL)::GetDeviceCaps(hdc, LOGPIXELSX)) <= 0) ||
        ((ydpi = (REAL)::GetDeviceCaps(hdc, LOGPIXELSY)) <= 0))
    {
        WARNING(("GetDC or GetDeviceCaps failed"));
        xdpi = DEFAULT_RESOLUTION;
        ydpi = DEFAULT_RESOLUTION;
    }
    ::ReleaseDC(NULL, hdc);
    // End: [Bug 103296]

    creationFlag = CREATEDFROM_NONE;
    cacheFlags = IMGFLAG_NONE;
    colorpal = NULL;
    propset = NULL;
    ddrawSurface = NULL;
    sourceFProfile = NULL;
    alphaTransparency = ALPHA_UNKNOWN;

    // Initialize the state used to support DrawImage abort and color adjust

    callback = NULL;
    callbackData = NULL;


    // Property item stuff

    PropertyListHead.pPrev = NULL;
    PropertyListHead.pNext = &PropertyListTail;
    PropertyListHead.id = 0;
    PropertyListHead.length = 0;
    PropertyListHead.type = 0;
    PropertyListHead.value = NULL;

    PropertyListTail.pPrev = &PropertyListHead;
    PropertyListTail.pNext = NULL;
    PropertyListTail.id = 0;
    PropertyListTail.length = 0;
    PropertyListTail.type = 0;
    PropertyListTail.value = NULL;
    
    PropertyListSize = 0;
    PropertyNumOfItems = 0;
    
    JpegDecoderPtr = NULL;

    // Increment global COM component count

    IncrementComComponentCount();
}


/**************************************************************************\
*
* Function Description:
*
*   GpMemoryBitmap object destructor
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

GpMemoryBitmap::~GpMemoryBitmap()
{
    // Delete the color palette object, if any

    if ( NULL != colorpal )
    {
        GpFree(colorpal);
    }

    // If we have a pointer to the source image, release it

    if (JpegDecoderPtr)
    {
        JpegDecoderPtr->Release();
    }

    // Free memory for the bitmap pixel data, if needed

    FreeBitmapMemory();

    // Decrement global COM component count

    DecrementComComponentCount();

    if (propset)
        propset->Release();

    if(ddrawSurface)
    {
        if(Scan0 != NULL)
        {
            WARNING(("Direct draw surfaces was locked at bitmap deletion"));
            UnlockDirectDrawSurface();
        }
        ddrawSurface->Release();
    }

    // Free all the cached property items if we have allocated them

    if ( PropertyNumOfItems > 0 )
    {
        InternalPropertyItem*   pTempCurrent = PropertyListHead.pNext;
        InternalPropertyItem*   pTempNext = NULL;
        
        for ( int i = 0; 
              ((i < (INT)PropertyNumOfItems) && (pTempCurrent != NULL)); ++i )
        {
            pTempNext = pTempCurrent->pNext;

            GpFree(pTempCurrent->value);
            GpFree(pTempCurrent);

            pTempCurrent = pTempNext;
        }
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Allocate pixel data buffer for the bitmap object
*
* Arguments:
*
*   width, height    - Specifies the bitmap dimension
*   pixfmt           - Specifies the pixel foformat
*   [IN/OUT] bmpdata - The bitmap data structure
*   clear            - TRUE if we must clear the bitmap
*
* Notes:
*   bmpdata->Reserved must be set to zero on entry to this function
*   or at least have the highword clear (memory allocation flags).
*
*   If clear is TRUE, the bitmap is filled with zero (for palettized formats
*   and formats without an alpha channel) or opaque black (if there's an 
*   alpha channel).
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

BOOL
GpMemoryBitmap::AllocBitmapData(
    UINT width,
    UINT height,
    PixelFormatID pixfmt,
    BitmapData* bmpdata,
    INT *alphaFlags,
    BOOL clear
    )
{
    ASSERT(IsValidPixelFormat(pixfmt));
    ASSERT(width > 0 && height > 0);

    // Reserved should be set to zero before calling this function.
    // This field has bits ORed into it to track how the memory was allocated
    // and if extraneous bits are set, this will free the memory incorrectly.
    // NOTE: this is an overagressive check - we could get away with asserting
    // that none of the memory alloc flags are set.

    ASSERT((bmpdata->Reserved & ~BMPDATA_LOCKMODEMASK) == 0);

    // Allocate memory using a simple heuristic:
    //  use VirtualAlloc if the buffer size is larger than 64KB
    //  use malloc otherwise
    //
    // NOTE: The initial content of the bitmap is undefined.

    UINT stride = CalcScanlineStride(width, GetPixelFormatSize(pixfmt));
    UINT size = stride*height;

    if (size < OSInfo::VAllocChunk)
    {
        bmpdata->Reserved |= BMPDATA_MALLOC;
        bmpdata->Scan0 = GpMalloc(size);
    }
    else
    {
        bmpdata->Reserved |= BMPDATA_VALLOC;

        #if PROFILE_MEMORY_USAGE
        MC_LogAllocation(size);
        #endif

        bmpdata->Scan0 = VirtualAlloc(
                            NULL,
                            size,
                            MEM_RESERVE|MEM_COMMIT,
                            PAGE_READWRITE);
    }

    // Check if memory allocation failed

    if (bmpdata->Scan0 == NULL)
    {
        WARNING(("Failed to allocate bitmap data"));

        bmpdata->Reserved &= ~BMPDATA_ALLOCMASK;
        return FALSE;
    }

    // Check if memory needs to be initialized

    if (clear)
    {
        // [agodfrey] Hot fix for WFC. I've commented out the
        // 'clear to opaque black' until we give WFC a 'clear' API.
        #if 0
            if (IsAlphaPixelFormat(pixfmt))
            {
                // For formats with an alpha channel, we fill with
                // opaque black. If we do this, the caller can know that an
                // initialized bitmap has no transparent pixels, making it easier
                // to track when transparent pixels are written into the image.
                //
                // We want to track this so that we can apply optimizations when
                // we know there are no transparent pixels.

                UINT x,y;
                BYTE *dataPtr = static_cast<BYTE *>(bmpdata->Scan0);

                switch (pixfmt)
                {
                case PIXFMT_32BPP_ARGB:
                case PIXFMT_32BPP_PARGB:
                    for (y=0; y<height; y++)
                    {
                        ARGB *scanPtr = reinterpret_cast<ARGB *>(dataPtr);
                        for (x=0; x<width; x++)
                        {
                            *scanPtr++ = 0xff000000;
                        }
                        dataPtr += stride;
                    }
                    break;

                case PIXFMT_64BPP_ARGB:
                case PIXFMT_64BPP_PARGB:
                    sRGB::sRGB64Color c;
                    c.r = c.g = c.b = 0;
                    c.argb = sRGB::SRGB_ONE;

                    for (y=0; y<height; y++)
                    {
                        ARGB64 *scanPtr = reinterpret_cast<ARGB64 *>(dataPtr);
                        for (x=0; x<width; x++)
                        {
                            *scanPtr++ = c.argb;
                        }
                        dataPtr += stride;
                    }
                    break;

                case PIXFMT_16BPP_ARGB1555:
                    for (y=0; y<height; y++)
                    {
                        UINT16 *scanPtr = reinterpret_cast<UINT16 *>(dataPtr);
                        for (x=0; x<width; x++)
                        {
                            *scanPtr++ = 0x8000;
                        }
                        dataPtr += stride;
                    }
                    break;

                default:
                    // This switch statement needs to handle all formats that have
                    // alpha. If we get here, we've forgotten a format.

                    RIP(("Unhandled format has alpha"));

                    break;
                }
                if (alphaFlags)
                    *alphaFlags = ALPHA_OPAQUE;
            }
            else
            {
                memset(bmpdata->Scan0, 0, size);
                if (alphaFlags)
                    *alphaFlags = ALPHA_NONE;
            }

        #else

            memset(bmpdata->Scan0, 0, size);

            if (alphaFlags)
            {
                if (IsAlphaPixelFormat(pixfmt))
                    *alphaFlags = ALPHA_SIMPLE;
                else if (IsIndexedPixelFormat(pixfmt))
                    *alphaFlags = ALPHA_UNKNOWN;
                else
                    *alphaFlags = ALPHA_NONE;
            }

        #endif
    }

    bmpdata->Width = width;
    bmpdata->Height = height;
    bmpdata->Stride = stride;
    bmpdata->PixelFormat = pixfmt;

    return TRUE;
}

HRESULT
GpMemoryBitmap::AllocBitmapMemory(
    UINT width,
    UINT height,
    PixelFormatID pixfmt,
    BOOL clear
    )
{
    ASSERT(Scan0 == NULL);

    BitmapData* bmpdata = this;

    return AllocBitmapData(width, height, pixfmt, bmpdata, &alphaTransparency, clear) ?
                S_OK :
                E_OUTOFMEMORY;
}


/**************************************************************************\
*
* Function Description:
*
*   Free pixel data buffer associated with the bitmap object
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpMemoryBitmap::FreeBitmapData(
    const BitmapData* bmpdata
    )
{
    UINT_PTR flags = bmpdata->Reserved;

    if (flags & BMPDATA_MALLOC)
    {
        // Pixel data buffer was allocated
        // by calling runtime function malloc()

        GpFree(bmpdata->Scan0);
    }
    else if (flags & BMPDATA_VALLOC)
    {
        // Pixel data buffer was allocated
        // by calling win32 API VirtualAlloc

        VirtualFree(bmpdata->Scan0, 0, MEM_RELEASE);
    }
}

VOID
GpMemoryBitmap::FreeBitmapMemory()
{
    FreeBitmapData(static_cast<BitmapData*>(this));

    Reserved &= ~BMPDATA_ALLOCMASK;
    Scan0 = NULL;
}


/**************************************************************************\
*
* Function Description:
*
*   Initialize a new bitmap image object of the specified
*   dimension and pixel format.
*
* Arguments:
*
*   width, height - Specifies the desired bitmap size, in pixels
*   pixfmt - Specifies the desired pixel data format
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::InitNewBitmap(
    IN UINT width,
    IN UINT height,
    IN PixelFormatID pixfmt,
    IN BOOL clear
    )
{
    ASSERT(creationFlag == CREATEDFROM_NONE);

    // Validate input parameters

    if (width == 0 ||
        height == 0 ||
        width > INT_MAX / 64 ||
        height >= INT_MAX / width ||
        !IsValidPixelFormat(pixfmt))
    {
        WARNING(("Invalid parameters in InitNewBitmap"));
        return E_INVALIDARG;
    }

    // Allocate pixel data buffer

    HRESULT hr;

    hr = AllocBitmapMemory(width, height, pixfmt, clear);

    if (SUCCEEDED(hr))
        creationFlag = CREATEDFROM_NEW;

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Initialize a new bitmap image with an IImage object
*
* Arguments:
*
*   image - Pointer to the source IImage object
*   width, height - Desired bitmap dimension
*       0 means the same dimension as the source
*   pixfmt - Desired pixel format
*       PIXFMT_DONTCARE means the same pixel format as the source
*   hints - Specifies interpolation hints
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::InitImageBitmap(
    IN IImage* image,
    IN UINT width,
    IN UINT height,
    IN PixelFormatID pixfmt,
    IN InterpolationHint hints,
    IN DrawImageAbort callback,
    IN VOID* callbackData
    )
{
    ASSERT(creationFlag == CREATEDFROM_NONE);

    // Validate input parameters

    if (pixfmt != PIXFMT_DONTCARE && !IsValidPixelFormat(pixfmt) ||
        width == 0 && height != 0 ||
        height == 0 && width != 0)
    {
        return E_INVALIDARG;
    }

    // Remember optional parameters

    this->Width = width;
    this->Height = height;
    this->PixelFormat = pixfmt;

    GpBitmapScaler* scaler = NULL;
    IImageSink* sink = static_cast<IImageSink*>(this);

    HRESULT hr;

    if ( width == 0 && height == 0)
    {
        // The caller didn't specify a new dimension:
        //  sink source image data directly into this bitmap
    }
    else
    {
        ImageInfo imageInfo;
        hr = image->GetImageInfo(&imageInfo);

        // !!!TODO, what if GetImageInfo() call failed? Say, the source image is
        // bad. Shall we continue to create a scaler for it?

        if (SUCCEEDED(hr) && (imageInfo.Flags & IMGFLAG_SCALABLE))
        {
            // The caller specified a new dimension
            // and the source image is scalable:
            //  sink directly into this bitmap
        }
        else
        {
            // Otherwise, we need to layer a bitmap scaler sink
            // on top of this bitmap. Use default interpolation
            // algorithm here.

            scaler = new GpBitmapScaler(sink, width, height, hints);

            if (!scaler)
                return E_OUTOFMEMORY;

            sink = static_cast<IImageSink*>(scaler);
        }

        // GpmemoryBitmap should have the same image info flag as the source

        cacheFlags = imageInfo.Flags;
    }

    // Set the special DrawImage state.

    SetDrawImageSupport(callback, callbackData);

    // Ask the source image to push data into the sink

    hr = image->PushIntoSink(sink);

    if (SUCCEEDED(hr))
    {
        creationFlag = CREATEDFROM_IMAGE;
    }

    // Reset the special DrawImage state.

    SetDrawImageSupport(NULL, NULL);

    // Set the alpha hint.

    if (CanHaveAlpha(this->PixelFormat, this->colorpal))
    {
        // Exception: destination 16bpp ARGB 1555 can stay ALPHA_SIMPLE.

        if (this->PixelFormat == PIXFMT_16BPP_ARGB1555)
            alphaTransparency = ALPHA_SIMPLE;
        else
            alphaTransparency = ALPHA_UNKNOWN;
    }
    else
        alphaTransparency = ALPHA_NONE;

    delete scaler;
    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Create a new bitmap image object from an IImage object
*
* Arguments:
*
*   image -
*   width -
*   height -
*   pixfmt -
*   hints - Same as for the instance method InitImageBitmap.
*   bmp - Return a pointer to the newly created bitmap image object.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::CreateFromImage(
    IN IImage* image,
    IN UINT width,
    IN UINT height,
    IN PixelFormatID pixfmt,
    IN InterpolationHint hints,
    OUT GpMemoryBitmap** bmp,
    IN DrawImageAbort callback,
    IN VOID* callbackData
    )
{
    GpMemoryBitmap* newbmp = new GpMemoryBitmap();

    if (newbmp == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = newbmp->InitImageBitmap(
        image, 
        width, 
        height, 
        pixfmt, 
        hints,
        callback, 
        callbackData
    );

    if (SUCCEEDED(hr))
    {
        *bmp = newbmp;
    }
    else
    {
        delete newbmp;
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Initialize a new bitmap image object with
*   user-supplied memory buffer
*
* Arguments:
*
*   bitmapData - Information about user-supplied memory buffer
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::InitMemoryBitmap(
    IN BitmapData* bitmapData
    )
{
    ASSERT(creationFlag == CREATEDFROM_NONE);

    // Validate input parameters

    if (bitmapData == NULL ||
        bitmapData->Width == 0 ||
        bitmapData->Height == 0 ||
        (bitmapData->Stride & 3) != 0 ||
        bitmapData->Scan0 == NULL ||
        !IsValidPixelFormat(bitmapData->PixelFormat) ||
        bitmapData->Reserved != 0)
    {
        return E_INVALIDARG;
    }

    // Copy the specified bitmap data buffer information

    *((BitmapData*) this) = *bitmapData;
    creationFlag = CREATEDFROM_USERBUF;

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*   Given a pointer to a direct draw pixel format structure return
*   an appropriate PixelFormatID if possible otherwise return
*   PIXFMT_UNDEFINED.
*
* Arguments:
*
*   pfmt - pointer to DDPIXELFORMAT structure
*
* Return Value:
*
*   PixelFormatID
*
* History:
*
*   10/1/1999 bhouse    Created it.
*
\**************************************************************************/

PixelFormatID DDPixelFormatToPixelFormatID(DDPIXELFORMAT * pfmt)
{
    PixelFormatID   id = PIXFMT_UNDEFINED;

    if(pfmt->dwFlags & (DDPF_FOURCC | DDPF_ALPHA | DDPF_BUMPLUMINANCE |
                        DDPF_BUMPDUDV | DDPF_COMPRESSED | DDPF_LUMINANCE |
                        DDPF_PALETTEINDEXED2 | DDPF_RGBTOYUV |
                        DDPF_STENCILBUFFER | DDPF_YUV | DDPF_ZBUFFER |
                        DDPF_ZPIXELS))
    {
        // we don't support it
    }
    else if(pfmt->dwFlags & DDPF_PALETTEINDEXED1)
    {
        id = PIXFMT_1BPP_INDEXED;
    }
    else if(pfmt->dwFlags & DDPF_PALETTEINDEXED4)
    {
        id = PIXFMT_4BPP_INDEXED;
    }
    else if(pfmt->dwFlags & DDPF_PALETTEINDEXED8)
    {
        id = PIXFMT_8BPP_INDEXED;
    }
    else if(pfmt->dwFlags & DDPF_RGB)
    {
        switch(pfmt->dwRGBBitCount)
        {
        case 16:
            {
                if(pfmt->dwRBitMask == 0xF800 &&
                   pfmt->dwGBitMask == 0x07E0 &&
                   pfmt->dwBBitMask == 0x001F)
                {
                    id = PIXFMT_16BPP_RGB565;
                }
                else if(pfmt->dwRBitMask == 0x7C00 &&
                        pfmt->dwGBitMask == 0x03E0 &&
                        pfmt->dwBBitMask == 0x001F)
                {
                    id = PIXFMT_16BPP_RGB555;
                }
                else if (pfmt->dwRBitMask == 0x7C00 &&
                         pfmt->dwGBitMask == 0x03E0 &&
                         pfmt->dwBBitMask == 0x001F &&
                         pfmt->dwRGBAlphaBitMask == 0x8000)
                {
                    id = PIXFMT_16BPP_ARGB1555;
                }
            }
            break;
        case 24:
            {
                if(pfmt->dwRBitMask == 0xFF0000 &&
                   pfmt->dwGBitMask == 0xFF00 &&
                   pfmt->dwBBitMask == 0xFF)
                {
                    id = PIXFMT_24BPP_RGB;
                }
            }
            break;
        case 32:
            {
                if(pfmt->dwRBitMask == 0xFF0000 &&
                   pfmt->dwGBitMask == 0xFF00 &&
                   pfmt->dwBBitMask == 0xFF)
                {
                    if(pfmt->dwFlags & DDPF_ALPHAPIXELS)
                    {
                        if(pfmt->dwRGBAlphaBitMask == 0xFF000000)
                        {
                            if(pfmt->dwFlags & DDPF_ALPHAPREMULT)
                                id = PIXFMT_32BPP_PARGB;
                            else
                                id = PIXFMT_32BPP_ARGB;
                        }
                    }
                    else
                    {
                        id = PIXFMT_32BPP_RGB;
                    }

                }
            }
            break;
        }

    }

    return id;
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize a new bitmap image object with
*   a user-supplied direct draw surface
*
* Arguments:
*
*   surface - Reference to a direct draw suface
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::InitDirectDrawBitmap(
    IN IDirectDrawSurface7 * surface
    )
{
    ASSERT(creationFlag == CREATEDFROM_NONE);

    // Validate input parameters

    if (surface == NULL)
    {
        return E_INVALIDARG;
    }

    // Validate surface

    HRESULT hr;
    DDSURFACEDESC2 ddsd;

    memset(&ddsd, 0, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    hr = surface->GetSurfaceDesc(&ddsd);

    if(hr != DD_OK)
    {
        WARNING(("Can not get surface description"));
        return E_INVALIDARG;
    }

    if(ddsd.dwWidth <= 0)
    {
        WARNING(("Unsupported surface width"));
        return E_INVALIDARG;
    }

    Width = ddsd.dwWidth;

    if(ddsd.dwHeight <= 0)
    {
        WARNING(("Unsupported surface height"));
        return E_INVALIDARG;
    }

    Height = ddsd.dwHeight;

    if(ddsd.lPitch & 3)
    {
        // QUESTION: Why do we require pitch to be a multiple of a four bytes?
        WARNING(("Unsupported surface pitch"));
        return E_INVALIDARG;
    }

    // Stride can change when we lock the surface
    // Stride = ddsd.lPitch;

    // Map Direct Draw pixel format to image pixel format

    PixelFormat = DDPixelFormatToPixelFormatID(&ddsd.ddpfPixelFormat);

    if(PixelFormat == PIXFMT_UNDEFINED)
    {
        WARNING(("Unsupported surface pixel format"));
        return E_INVALIDARG;
    }

    surface->AddRef();

    // QUESTION: Do we need this?  Overkill?

    Stride = 0;
    Scan0 = NULL;

    ddrawSurface = surface;
    creationFlag = CREATEDFROM_DDRAWSURFACE;

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the encoder parameter list size from an encoder object specified by
*   input clsid
*
* Arguments:
*
*   clsid - Specifies the encoder class ID
*   size--- The size of the encoder parameter list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/22/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetEncoderParameterListSize(
    IN  CLSID* clsidEncoder,
    OUT UINT* size
    )
{
    return CodecGetEncoderParameterListSize(clsidEncoder, size);    
}// GetEncoderParameterListSize()

/**************************************************************************\
*
* Function Description:
*
*   Get the encoder parameter list from an encoder object specified by
*   input clsid
*
* Arguments:
*
*   clsid --- Specifies the encoder class ID
*   size----- The size of the encoder parameter list
*   pBuffer-- Buffer for storing the list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/22/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetEncoderParameterList(
    IN CLSID* clsidEncoder,
    IN UINT size,
    OUT EncoderParameters* pBuffer
    )
{
    return CodecGetEncoderParameterList(clsidEncoder, size, pBuffer);
}// GetEncoderParameterList()

/**************************************************************************\
*
* Function Description:
*
*   Save image property items to the destination sink
*
* Arguments:
*
*   pImageSrc   --- [IN]Pointer to the source image object
*   pEncodeSink---- [IN]Pointer to the sink we are pushing to
*
* Return Value:
*
*   Status code
*
* Note:
*   This is a private method. So we don't need to do input parameter
*   validation since the caller should do this for us.
*
* Revision History:
*
*   09/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SavePropertyItems(
    IN GpDecodedImage* pImageSrc,
    IImageSink* pEncodeSink
    )
{
    // Check if the sink needs property stuff.
    // If the sink can save property and we have either the source
    // image pointer or we have property items stored in this
    // GpMemoryBitmap object, then we push the property items first
    // Note: it is not right that we have property items stored in
    // this GpMemoryBitmap object and we also have the source image
    // pointer

    HRESULT hResult = S_OK;

    // If the save operation is between two JPEG images (src and dest are JPEG),
    // then we need to establish a link between decoder and encoder so that
    // the encoder can copy application headers from the decoder and save it in
    // the new image

    void *pRawInfo = NULL;

    if (JpegDecoderPtr)
    {
        hResult = JpegDecoderPtr->GetRawInfo(&pRawInfo);
    }

    if (FAILED(hResult))
    {
        return hResult;
    }

    if ( ((pImageSrc != NULL ) || (PropertyNumOfItems > 0) )
         &&(pEncodeSink->NeedRawProperty(pRawInfo) == S_OK) )
    {
        UINT    uiTotalBufferSize = 0;
        UINT    uiNumOfItems = 0;

        if ( pImageSrc != NULL )
        {
            hResult = pImageSrc->GetPropertySize(&uiTotalBufferSize,
                                                 &uiNumOfItems);
        }
        else
        {
            hResult = GetPropertySize(&uiTotalBufferSize,
                                      &uiNumOfItems);
        }

        if ( FAILED(hResult) )
        {
            WARNING(("::SaveToStream--GetPropertySize() failed"));
            return hResult;
        }

        // Move all the property items to the sink if there is any

        if (uiNumOfItems > 0)
        {
            PropertyItem*   pBuffer = NULL;

            // Ask the destination to provide the memory

            hResult = pEncodeSink->GetPropertyBuffer(uiTotalBufferSize,
                                                     &pBuffer);                        
            if ( FAILED(hResult) )
            {
                WARNING(("GpMemoryBmp::Save-GetPropertyBuffer failed"));
                return hResult;
            }

            // if GetPropertyBuffer succeeded, pBuffer must be set

            ASSERT(pBuffer != NULL);

            // Get all the property items from the source

            if ( pImageSrc != NULL )
            {
                hResult = pImageSrc->GetAllPropertyItems(
                                                        uiTotalBufferSize,
                                                        uiNumOfItems,
                                                        pBuffer);
            }
            else
            {
                hResult = GetAllPropertyItems(uiTotalBufferSize,
                                              uiNumOfItems,
                                              pBuffer);
            }

            if ( hResult != S_OK )
            {
                WARNING(("GpMemoryBmp::Save-GetAllPropertyItems fail"));
                return hResult;
            }

            // Push all property items to destination

            hResult = pEncodeSink->PushPropertyItems(uiNumOfItems,
                                                     uiTotalBufferSize,
                                                     pBuffer,
                                                     FALSE  // No ICC change
                                                     );
        }
    }// If the sink needs raw property

    return hResult;
}// SavePropertyItems()

HRESULT
GpMemoryBitmap::SetJpegQuantizationTable(
    IN IImageEncoder* pEncoder
    )
{
    UINT    uiLumTableSize = 0;
    UINT    uiChromTableSize = 0;
    EncoderParameters* pMyEncoderParams = NULL;

    HRESULT hResult = GetPropertyItemSize(PropertyTagLuminanceTable,
                                          &uiLumTableSize);

    if ( FAILED(hResult) || (uiLumTableSize == 0) )
    {
        // This image doesn't have luminance table or something is
        // wrong.

        WARNING(("GpMemoryBitmap::SetJpegQuantizationTable-No luminance tbl"));
        return hResult;
    }

    // Note: For a gray scale JPEG, it doesn't have a chrominance table. So the
    // function call below might return failure. But this is OK.

    hResult = GetPropertyItemSize(PropertyTagChrominanceTable,
                                  &uiChromTableSize);

    if ( FAILED(hResult) )
    {
        // Some codecs fail and set uiChromTableSize to a bogus value,
        // so we re-initialize it here

        uiChromTableSize = 0;
    }

    // Find luminance and chrominance table

    PropertyItem*   pLumTable = (PropertyItem*)GpMalloc(uiLumTableSize);
    if ( pLumTable == NULL )
    {
        WARNING(("GpMemoryBitmap::SetJpegQuantizationTable---Out of memory"));

        hResult = E_OUTOFMEMORY;
        goto CleanUp;
    }
    
    hResult = GetPropertyItem(PropertyTagLuminanceTable,
                              uiLumTableSize, pLumTable);
    if ( FAILED(hResult) )
    {
        WARNING(("GpMemoryBitmap::SetJpegQuantizationTable-No luminance tbl"));
        goto CleanUp;        
    }

    PropertyItem*   pChromTable = NULL;

    if ( uiChromTableSize != 0 )
    {
        pChromTable = (PropertyItem*)GpMalloc(uiChromTableSize);
        if ( pChromTable == NULL )
        {
            WARNING(("GpMemoryBitmap::SetJpegQuantizationTable-Out of memory"));

            hResult = E_OUTOFMEMORY;
            goto CleanUp;
        }
        
        hResult = GetPropertyItem(PropertyTagChrominanceTable,
                                  uiChromTableSize, pChromTable);
        if ( FAILED(hResult) )
        {
            WARNING(("GpMemBitmap::SetJpegQuantizationTable-No chrom table"));
            goto CleanUp;
        }
    }

    pMyEncoderParams = (EncoderParameters*)
                               GpMalloc( sizeof(EncoderParameters)
                                        + 2 * sizeof(EncoderParameter));

    if ( pMyEncoderParams == NULL )
    {
        WARNING(("GpMemoryBitmap::SetJpegQuantizationTable---Out of memory"));
        hResult = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // Note: the size for a luminance table and chrominance table should always
    // be 64, that is, pLumTable->length / sizeof(UINT16) == 64. Here, just for
    // save reason, we don't hard-coded it as 64. But the lower level JPEG
    // SetEncoderParameters() will fail and print out warning message if the
    // size is not 64

    pMyEncoderParams->Parameter[0].Guid = ENCODER_LUMINANCE_TABLE;
    pMyEncoderParams->Parameter[0].NumberOfValues = pLumTable->length
                                                  / sizeof(UINT16);
    pMyEncoderParams->Parameter[0].Type = EncoderParameterValueTypeShort;
    pMyEncoderParams->Parameter[0].Value = (VOID*)(pLumTable->value);
    pMyEncoderParams->Count = 1;

    if ( uiChromTableSize != 0 )
    {
        pMyEncoderParams->Parameter[1].Guid = ENCODER_CHROMINANCE_TABLE;
        pMyEncoderParams->Parameter[1].NumberOfValues = pChromTable->length
                                                      / sizeof(UINT16);
        pMyEncoderParams->Parameter[1].Type = EncoderParameterValueTypeShort;
        pMyEncoderParams->Parameter[1].Value = (VOID*)(pChromTable->value);
        pMyEncoderParams->Count++;
    }

    hResult = pEncoder->SetEncoderParameters(pMyEncoderParams);
    
CleanUp:
    if ( pLumTable != NULL )
    {
        GpFree(pLumTable);
    }

    if ( pChromTable != NULL )
    {
        GpFree(pChromTable);
    }

    if ( pMyEncoderParams != NULL )
    {
        GpFree(pMyEncoderParams);
    }

    return hResult;
}// SetJpegQuantizationTable()

/**************************************************************************\
*
* Function Description:
*
*   Get the bitmap image to the specified stream.
*
* Arguments:
*
*   stream -------- Target stream
*   clsidEncoder -- Specifies the CLSID of the encoder to use
*   encoderParams - Optional parameters to pass to the encoder before
*                   starting encoding
*   ppEncoderPtr -- [OUT]Pointer to the encoder object 
*   pImageSrc   --- [IN]Pointer to the source image object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SaveToStream(
    IN IStream* stream,
    IN CLSID* clsidEncoder,
    IN EncoderParameters* encoderParams,
    IN BOOL fSpecialJPEG,
    OUT IImageEncoder** ppEncoderPtr,
    IN GpDecodedImage* pImageSrc
    )
{
    if ( ppEncoderPtr == NULL )
    {
        WARNING(("GpMemoryBitmap::SaveToStream---Invalid input arg"));
        return E_INVALIDARG;
    }

    // Get an image encoder.

    IImageEncoder* pEncoder = NULL;

    HRESULT hResult = CreateEncoderToStream(clsidEncoder, stream, &pEncoder);
    if ( SUCCEEDED(hResult) )
    {
        // Return the pointer to encoder back to caller

        *ppEncoderPtr = pEncoder;

        // Pass encode parameters to the encoder.
        // MUST do this before getting the sink interface.

        if ( encoderParams != NULL )
        {
            hResult = pEncoder->SetEncoderParameters(encoderParams);
        }

        if ( SUCCEEDED(hResult) || ( hResult == E_NOTIMPL) )
        {
            if ( fSpecialJPEG == TRUE )
            {
                // Set JPEG quantization table

                hResult = SetJpegQuantizationTable(pEncoder);

                if ( FAILED(hResult) )
                {
                    WARNING(("GpMemBitmap::SetJpegQuantizationTable-Failed"));
                    return hResult;
                }
            }

            // Get an image sink from the encoder.

            IImageSink* pEncodeSink = NULL;

            hResult = pEncoder->GetEncodeSink(&pEncodeSink);
            if ( SUCCEEDED(hResult) )
            {
                hResult = SavePropertyItems(pImageSrc, pEncodeSink);
                if ( SUCCEEDED(hResult) )
                {
                    // Push bitmap into the encoder sink.

                    hResult = this->PushIntoSink(pEncodeSink);
                }

                pEncodeSink->Release();
            }// Succeed in getting an encoder sink
        }
    }// Succeed in getting an encoder

    return hResult;
}// SaveToStream()

/**************************************************************************\
*
* Function Description:
*
*   Get the bitmap image to the specified stream.
*
* Arguments:
*
*   stream - Target stream
*   clsidEncoder - Specifies the CLSID of the encoder to use
*   encoderParams - Optional parameters to pass to the encoder before
*                   starting encoding
*   ppEncoderPtr -- [OUT]Pointer to the encoder object 
*   pImageSrc   --- [IN]Pointer to the source image object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SaveToFile(
    IN const WCHAR* filename,
    IN CLSID* clsidEncoder,
    IN EncoderParameters* encoderParams,
    IN BOOL fSpecialJPEG,
    OUT IImageEncoder** ppEncoderPtr,
    IN GpDecodedImage* pImageSrc
    )
{
    IStream* stream = NULL;

    HRESULT hResult = CreateStreamOnFileForWrite(filename, &stream);

    if ( SUCCEEDED(hResult) )
    {
        hResult = SaveToStream(stream, clsidEncoder,
                               encoderParams, fSpecialJPEG, ppEncoderPtr,
                               pImageSrc);
        stream->Release();
    }

    return hResult;
}// SaveToFile()

/**************************************************************************\
*
* Function Description:
*
* Append current GpMemoryBitmap object to current encoder object
*
* Note: this call will happen under following scenario:
*   The source image is a multi-frame image (TIFF, GIF). The caller is
*   navigating among the pages and append the current page to the file for
*   saving
*
* Arguments:
*
*   encoderParams - Optional parameters to pass to the encoder before
*                   starting encoding
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   04/21/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SaveAppend(
    IN const EncoderParameters* encoderParams,
    IN IImageEncoder* destEncoderPtr,
    IN GpDecodedImage* pImageSrc
    )
{
    // The dest encoder pointer can't be NULL. Otherwise, it is a failure

    if ( destEncoderPtr == NULL )
    {
        WARNING(("GpMemoryBitmap::SaveAppend---Called without an encoder"));
        return E_FAIL;
    }

    HRESULT hResult = S_OK;

    // Pass encode parameters to the encoder.
    // MUST do this before getting the sink interface.

    if ( encoderParams != NULL )
    {
        hResult = destEncoderPtr->SetEncoderParameters(encoderParams);
    }

    // Note: it is OK that an encoder might not implement SetEncoderParameters()

    if ( (hResult == S_OK) || (hResult == E_NOTIMPL) )
    {
        // Get an image sink from the encoder.
    
        IImageSink*  pEncodeSink = NULL;

        hResult = destEncoderPtr->GetEncodeSink(&pEncodeSink);
        if ( SUCCEEDED(hResult) )
        {
            hResult = SavePropertyItems(pImageSrc, pEncodeSink);
            if ( FAILED(hResult) )
            {
                WARNING(("GpMemoryBmp:Save-SavePropertyItems() failed"));
                return hResult;
            }
            
            // Push bitmap into the encoder sink.

            hResult = this->PushIntoSink(pEncodeSink);

            pEncodeSink->Release();
        }
    }

    return hResult;
}// SaveAppend()

/**************************************************************************\
*
* Function Description:
*
*   Get the device-independent physical dimension of the image
*   in unit of 0.01mm
*
* Arguments:
*
*   size - Buffer for returning physical dimension information
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetPhysicalDimension(
    OUT SIZE* size
    )
{
    if ( !IsValid() )
    {
        return E_FAIL;
    }

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    // Convert to 0.01mm units

    size->cx = Pixel2HiMetric(Width, xdpi);
    size->cy = Pixel2HiMetric(Height, ydpi);

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Get basic information about the bitmap image object
*
* Arguments:
*
*   imageInfo - Buffer for returning basic image info
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetImageInfo(
    OUT ImageInfo* imageInfo
    )
{
    if ( !IsValid() )
    {
        return E_FAIL;
    }

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    imageInfo->RawDataFormat = IMGFMT_MEMORYBMP;
    imageInfo->PixelFormat = PixelFormat;
    imageInfo->Width = imageInfo->TileWidth = Width;
    imageInfo->Height = imageInfo->TileHeight = Height;
    imageInfo->Xdpi = xdpi;
    imageInfo->Ydpi = ydpi;

    UINT flags = cacheFlags;

    if (CanHaveAlpha(PixelFormat, colorpal))
        flags |= IMGFLAG_HASALPHA;

    imageInfo->Flags = flags;
    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Set image flags
*
* Arguments:
*
*   flags - Specifies the new image flags
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SetImageFlags(
    IN UINT flags
    )
{
    if ( !IsValid() )
    {
        return E_FAIL;
    }

#if 0
    // Only the top half is settable
    // Note: [minliu] This is not right. Flags like SINKFLAG_TOPDOWN which is
    // defined as 0x0001000, SinkFlagsMultipass also has bottom half.

    if (flags & 0xffff)
        return E_INVALIDARG;
#endif

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    // !!! TODO
    //  Need to honor IMGFLAG_READONLY in other methods.

    cacheFlags = flags;
    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Display the image in a GDI device context
*
* Arguments:
*
*   hdc - Specifies the destination device context to draw into
*   dstRect - Specifies the area on the destination DC
*   srcRect - Specifies the source area in the bitmap image
*       NULL means the entire bitmap
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::Draw(
    IN HDC hdc,
    IN const RECT* dstRect,
    IN OPTIONAL const RECT* srcRect
    )
{
    HRESULT hr;

    hr = LockDirectDrawSurface();

    if(SUCCEEDED(hr))
    {
        if ( !IsValid() )
        {
            UnlockDirectDrawSurface();
            
            return E_FAIL;
        }

        // Lock the current bitmap object
        // and validate source rectangle

        RECT r, subarea;
        GpLock lock(&objectLock);

        if (lock.LockFailed())
            return IMGERR_OBJECTBUSY;

        // The source rectangle is in 0.01mm unit.
        //  So we need to convert it to pixel unit here.

        if (srcRect)
        {
            r.left = HiMetric2Pixel(srcRect->left, xdpi);
            r.right = HiMetric2Pixel(srcRect->right, xdpi);
            r.top = HiMetric2Pixel(srcRect->top, ydpi);
            r.bottom = HiMetric2Pixel(srcRect->bottom, ydpi);

            srcRect = &r;
        }

        if (!ValidateImageArea(&subarea, srcRect))
        {
            WARNING(("Invalid source rectangle in Draw"));
            hr = E_INVALIDARG;
        }
        else
        {
            // Call GDI to do the drawing if the pixel format
            // is directly supported by GDI. Otherwise, we first
            // convert the pixel format into the canonical 32bpp
            // ARGB format and then call GDI.

            hr = IsGDIPixelFormat(PixelFormat) ?
                        DrawWithGDI(hdc, dstRect, &subarea) :
                        DrawCanonical(hdc, dstRect, &subarea);
        }

        UnlockDirectDrawSurface();
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Draw the bitmap into a GDI device context
*   by directly calling GDI APIs.
*
* Arguments:
*
*   hdc - Specifies the destination device context to draw into
*   dstRect - Specifies the area on the destination DC
*   srcRect - Specifies the source area in the bitmap image
*
* Return Value:
*
*   Status code
*
* Notes:
*
*   We assume the current bitmap object is already marked busy.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::DrawWithGDI(
    HDC hdc,
    const RECT* dstRect,
    RECT* srcRect
    )
{
    // !!! TODO
    // Check if the bitmap can potentially have alpha information

    // Figure out if the bitmap is bottom-up
    // and if its scanline stride satisfies GDI requirement.
    // GDI scanlines are always rounded up to multiples of DWORDs.

    HRESULT hr = S_OK;
    UINT pixsize;
    INT gdiStride, srcStride;
    INT w, h;
    BYTE* dataptr;

    pixsize = GetPixelFormatSize(PixelFormat);
    if ( pixsize == 0 )
    {
        return E_FAIL;
    }

    gdiStride = (((pixsize * Width + 7) >> 3) + 3) & ~3;
    w = Width;
    h = Height;
    srcStride = Stride;
    BOOL    fHasAlpha = FALSE;

    INT srcRectTop;
    if (srcStride > 0)
    {
        // Top-down bitmap

        h = -h;
        dataptr = (BYTE*) Scan0;

        // For top-down bitmaps, StretchDIBits YSrc argument is actually
        // the distance from the bottom of the image

        srcRectTop = Height - srcRect->bottom;
    }
    else
    {
        // Bottom-up bitmap

        srcStride = -srcStride;
        dataptr = (BYTE*) Scan0 + (Height-1) * Stride;
        srcRectTop = srcRect->top;
    }

    if (srcStride != gdiStride)
    {
        ASSERT(srcStride > gdiStride);
        w = 8 * gdiStride / pixsize;
    }

    // Compose a GDI BITMAPINFO structure corresponding
    // to the pixel format of the current bitmap object.

    struct {
        BITMAPINFOHEADER bmih;
        ARGB colors[256];
    } bmpinfo;

    ZeroMemory(&bmpinfo.bmih, sizeof(bmpinfo.bmih));

    bmpinfo.bmih.biSize = sizeof(bmpinfo.bmih);
    bmpinfo.bmih.biWidth = w;
    bmpinfo.bmih.biHeight = h;
    bmpinfo.bmih.biPlanes = 1;
    bmpinfo.bmih.biBitCount = (WORD) pixsize;
    bmpinfo.bmih.biCompression = BI_RGB;

    if (IsIndexedPixelFormat(PixelFormat))
    {
        const ColorPalette* pal = GetCurrentPalette();
        if ( pal == NULL )
        {
            return E_FAIL;
        }

        
        // If the palette has alpha in it, we need to set fHasAlpha to TRUE so
        // that we will use AlphaBlend to draw this image later.
        // Note: we don't need to fill "bmpinfo.colors" any more since we will
        // convert the image to a 32 BPP ARGB later

        if ( pal->Flags & PALFLAG_HASALPHA )
        {
            fHasAlpha = TRUE;

            // AlphaBlend doesn't support indexed format. We will have to
            // convert it to 32 BPP later. So change the bit count here to 32

            bmpinfo.bmih.biBitCount = 32;
        }
        else
        {
            GpMemcpy(bmpinfo.colors,
                     pal->Entries,
                     pal->Count * sizeof(ARGB));
        }
    }
    else if (pixsize == 16)
    {
        // 16bpp pixel formats are handled as GDI bit-field formats

        bmpinfo.bmih.biCompression = BI_BITFIELDS;

        if (PixelFormat == PIXFMT_16BPP_RGB565)
        {
            bmpinfo.colors[0] = 0x1f << 11;
            bmpinfo.colors[1] = 0x3f << 5;
            bmpinfo.colors[2] = 0x1f;
        }
        else if ( PixelFormat == PIXFMT_16BPP_ARGB1555 )
        {
            // AlphaBlend doesn't support 16BPP ARGB format. We will have to
            // convert it to 32 BPP later. So change the bit count here to 32
            // Note: It is very important to set biCompression as BI_RGB. That
            // means we don't need a palette when we call CreateDIBSection

            bmpinfo.bmih.biBitCount = 32;
            bmpinfo.bmih.biCompression = BI_RGB;
        }
        else
        {
            bmpinfo.colors[0] = 0x1f << 10;
            bmpinfo.colors[1] = 0x1f << 5;
            bmpinfo.colors[2] = 0x1f;
        }
    }

    // First check if we have alpha blend function on this system or not

    ALPHABLENDFUNCTION myAlphaBlend = GetAlphaBlendFunc();

    // !!!TODO, we need to let 64_BPP_ARGB falls into this path as well
    
    if ( (myAlphaBlend != NULL )
       &&( (PixelFormat == PIXFMT_32BPP_ARGB)
         ||(PixelFormat == PIXFMT_16BPP_ARGB1555)
         ||(fHasAlpha == TRUE) ) )
    {
        HDC     hMemDC = CreateCompatibleDC(hdc);

        if ( hMemDC == NULL )
        {
            WARNING(("CreateCompatibleDC failed"));
            goto handle_err;
        }

        // Create a 32 BPP DIB section

        VOID*   myBits;
        HBITMAP hBitMap = CreateDIBSection(hMemDC,
                                           (BITMAPINFO*)&bmpinfo,
                                           DIB_RGB_COLORS,
                                           &myBits,
                                           NULL,
                                           0);

        if ( hBitMap == NULL )
        {
            WARNING(("CreateDIBSection failed"));
            goto handle_err;
        }

        // Source image has alpha in it. We have to call AlphaBlend() to draw it
        // But before that, we have to convert our ARGB format to a
        // pre-multiplied ARGB format since GDI only knows the later format

        if ( PixelFormat == PIXFMT_32BPP_ARGB )
        {
            // Set the bits in the DIB

            ARGB*   pSrcBits = (ARGB*)dataptr;
            ARGB*   pDstBits = (ARGB*)myBits;

            for ( UINT i = 0; i < Height; ++ i )
            {
                for ( UINT j = 0; j < Width; ++j )
                {
                    *pDstBits++ = Premultiply(*pSrcBits++);
                }
            }        
        }// 32 BPP ARGB to PARGB
        else if ( PixelFormat == PIXFMT_16BPP_ARGB1555 )
        {
            UINT16* pui16Bits = (UINT16*)dataptr;
            ARGB*   pDest = (ARGB*)myBits;

            for ( UINT i = 0; i < Height; ++ i )
            {
                for ( UINT j = 0; j < Width; ++j )
                {
                    // If the 1st bits is 0, then the whole 16 bits set to 0
                    // if it is 1, we don't need to do anything for the rest
                    // 15 bits

                    if ( ((*pui16Bits) & 0x8000) == 0 )
                    {
                        *pDest++ = 0;
                    }
                    else
                    {
                        ARGB v = *pui16Bits;
                        ARGB r = (v >> 10) & 0x1f;
                        ARGB g = (v >>  5) & 0x1f;
                        ARGB b = (v      ) & 0x1f;

                        *pDest++ = ALPHA_MASK
                                 | (r << RED_SHIFT)
                                 | (g << GREEN_SHIFT)
                                 | (b << BLUE_SHIFT);
                    }

                    pui16Bits++;
                }
            }
        }// 16 BPP ARGB to PARGB
        else
        {
            // AlphaBlend only supports 32 ARGB format. So we have to do a
            // conversion here
            // Make a BitmapData structure to do a format conversion

            BitmapData srcBitmapData;

            srcBitmapData.Scan0 = Scan0;
            srcBitmapData.Width = Width;
            srcBitmapData.Height = Height;
            srcBitmapData.PixelFormat = PixelFormat;
            srcBitmapData.Reserved = 0;
            srcBitmapData.Stride = Stride;

            BitmapData dstBitmapData;

            dstBitmapData.Scan0 = myBits;
            dstBitmapData.Width = Width;
            dstBitmapData.Height = Height;
            dstBitmapData.PixelFormat = PIXFMT_32BPP_ARGB;
            dstBitmapData.Reserved = 0;
            dstBitmapData.Stride = (Width << 2);
            
            // Get the source palette

            const ColorPalette* pal = GetCurrentPalette();

            // Since we are not allowed to modify the source palette, we have to
            // make a COPY of it. Here "FALSE" is to tell the function use
            // GpMalloc to allocate memory

            ColorPalette* pModifiedPal = CloneColorPalette(pal, FALSE);
            if ( pModifiedPal == NULL )
            {
                goto handle_err;
            }

            for ( UINT i = 0; i < pal->Count; ++i )
            {
                // A palette entry is in ARGB format. If the alpha value not
                // equals to 255, that means it is translucent. We have to
                // pre-multiply the pixel value

                if ( (pal->Entries[i] & 0xff000000) != 0xff000000 )
                {                    
                    pModifiedPal->Entries[i] = Premultiply(pal->Entries[i]);
                }
            }
            
            // Do the data conversion.

            hr = ConvertBitmapData(&dstBitmapData,
                                   NULL,
                                   &srcBitmapData,
                                   pModifiedPal);

            GpFree(pModifiedPal);

            if ( !SUCCEEDED(hr) )
            {
                WARNING(("MemBitmap::DrawWithGDI--ConvertBitmapData fail"));
                goto handle_err;
            }
        }// Indexed case

        HBITMAP hOldBitMap = (HBITMAP)SelectObject(hMemDC, hBitMap);

        if ( hOldBitMap == NULL )
        {
            WARNING(("SelectObject failed"));
            goto handle_err;
        }

        BLENDFUNCTION   myBlendFunction;

        myBlendFunction.BlendOp = AC_SRC_OVER;
        myBlendFunction.BlendFlags = 0;
        myBlendFunction.SourceConstantAlpha = 255;  //use per-pixel alpha values
        myBlendFunction.AlphaFormat = AC_SRC_ALPHA;

        if ( myAlphaBlend(hdc,
                          dstRect->left,
                          dstRect->top,
                          dstRect->right - dstRect->left,
                          dstRect->bottom - dstRect->top,
                          hMemDC,
                          srcRect->left,
                          srcRect->top,
                          srcRect->right - srcRect->left,
                          srcRect->bottom - srcRect->top,
                          myBlendFunction) == GDI_ERROR )
        {
            WARNING(("AlphaBlend failed"));
            goto handle_err;
        }

        // Free the resource

        SelectObject(hMemDC, hOldBitMap);
        
        DeleteObject(hBitMap);
        DeleteDC(hMemDC);
    }
    else
    {
        // Call GDI to do the drawing

        if (StretchDIBits(
                hdc,
                dstRect->left,
                dstRect->top,
                dstRect->right - dstRect->left,
                dstRect->bottom - dstRect->top,
                srcRect->left,
                srcRectTop,
                srcRect->right - srcRect->left,
                srcRect->bottom - srcRect->top,
                dataptr,
                (BITMAPINFO*) &bmpinfo,
                DIB_RGB_COLORS,
                SRCCOPY) == GDI_ERROR)
        {
            WARNING(("StretchDIBits failed"));

            goto handle_err;
        }
    }

    return hr;

handle_err:
    DWORD err = GetLastError();

    hr = HRESULT_FROM_WIN32(err);

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Draw the bitmap into a GDI device context
*   by creating a temporary bitmap in 32bpp ARGB canonical format
*   and then call GDI calls.
*
* Arguments:
*
*   hdc - Specifies the destination device context to draw into
*   dstRect - Specifies the area on the destination DC
*   srcRect - Specifies the source area in the bitmap image
*
* Return Value:
*
*   Status code
*
* Notes:
*
*   We assume the current bitmap object is already marked busy.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::DrawCanonical(
    HDC hdc,
    const RECT* dstRect,
    RECT* srcRect
    )
{
    // Create a temporary bitmap in 32bpp ARGB canonical pixel format

    GpMemoryBitmap bmpcopy;
    HRESULT hr;
    RECT rect;

    rect.left = rect.top = 0;
    rect.right = srcRect->right - srcRect->left;
    rect.bottom = srcRect->bottom - srcRect->top;

    hr = bmpcopy.InitNewBitmap(rect.right, rect.bottom, PIXFMT_32BPP_ARGB);

    // Convert from current pixel format into 32bpp ARGB

    if (SUCCEEDED(hr))
    {
        BitmapData bmpdata;

        bmpcopy.GetBitmapAreaData(&rect, &bmpdata);

        hr = InternalLockBits(
                srcRect,
                IMGLOCK_READ|IMGLOCK_USERINPUTBUF,
                PIXFMT_32BPP_ARGB,
                &bmpdata);

        if (SUCCEEDED(hr))
            InternalUnlockBits(srcRect, &bmpdata);

    }

    // Draw the temporary bitmap
    rect.left = Pixel2HiMetric(rect.left, xdpi);
    rect.right = Pixel2HiMetric(rect.right, xdpi);
    rect.top = Pixel2HiMetric(rect.top, ydpi);
    rect.bottom = Pixel2HiMetric(rect.bottom, ydpi);

    if (SUCCEEDED(hr))
        hr = bmpcopy.Draw(hdc, dstRect, &rect);

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Push image data into an IImageSink
*
* Arguments:
*
*   sink - The sink for receiving bitmap image data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::PushIntoSink(
    IN IImageSink* sink
    )
{
    if ( !IsValid() )
    {
        return E_FAIL;
    }

    // Lock the bitmap object

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    ImageInfo imageinfo;
    RECT subarea, bandRect;
    BitmapData bmpdata;
    HRESULT hr;

    imageinfo.RawDataFormat = IMGFMT_MEMORYBMP;
    imageinfo.PixelFormat = PixelFormat;
    imageinfo.Width = imageinfo.TileWidth = Width;
    imageinfo.Height = imageinfo.TileHeight = Height;
    imageinfo.Xdpi = xdpi;
    imageinfo.Ydpi = ydpi;

    imageinfo.Flags = SINKFLAG_TOPDOWN | SINKFLAG_FULLWIDTH;

    // Check if the image in the memory has alpha or not. If YES, set the
    // HASALPHA flag, before we push it into the sink.
    // Note: We should use CanHaveAlpha() here. But since this function is
    // broken for indexed format, we have to check it explicitly here.
    // Note: Inside CanHaveAlpha(), for an index pixel format, it should check
    // if it has PALFLAG_HASALPHA flag set before it can claim it has alpha.
    // See Windows bug#392927 to see what will happen if we don't set this flag
    // correctly.

    if ( IsAlphaPixelFormat(PixelFormat) ||
         ( IsIndexedPixelFormat(PixelFormat) &&
           colorpal &&
           (colorpal->Flags & PALFLAG_HASALPHA) ) )
    {
        imageinfo.Flags |= SINKFLAG_HASALPHA;
    }

    // Negotiate the parameters with the sink

    hr = sink->BeginSink(&imageinfo, &subarea);

    if (FAILED(hr))
        return hr;

    // Validate subarea information returned by the sink

    PixelFormatID pixfmt = imageinfo.PixelFormat;

    if (!ValidateImageArea(&bandRect, &subarea) ||
        !IsValidPixelFormat(pixfmt) ||
        imageinfo.TileHeight == 0)
    {
        hr = E_UNEXPECTED;
        goto exitPushIntoSink;
    }

    // Give the sink our color palette, if any

    const ColorPalette* pal;

    if (pal = GetCurrentPalette())
    {
        hr = sink->SetPalette(pal);

        if (FAILED(hr))
            goto exitPushIntoSink;
    }

    if (PixelFormat == pixfmt)
    {
        // Fast path: the sink can take our native pixel format
        // Just give our bitmap data to the sink in one shot.

        GetBitmapAreaData(&bandRect, &bmpdata);
        hr = sink->PushPixelData(&bandRect, &bmpdata, TRUE);
    }
    else
    {
        // Give data to the sink one band at a time
        // and perform pixel format conversion too

        INT ymax = bandRect.bottom;
        INT w = bandRect.right - bandRect.left;
        INT dh = imageinfo.TileHeight;

        // Throttle memory usage by limiting band size

        INT lineSize = (w * GetPixelFormatSize(pixfmt) + 7) / 8;
        INT maxBand = OSInfo::VAllocChunk * 4 / lineSize;

        if (dh > maxBand)
            dh = maxBand;

        // Allocate a temporary buffer large enough for one band

        bmpdata.Reserved = 0;

        if (!AllocBitmapData(w, dh, pixfmt, &bmpdata, NULL))
        {
            hr = E_OUTOFMEMORY;
            goto exitPushIntoSink;
        }

        BitmapData tempData = bmpdata;

        do
        {
            // Check for abort.

            if (callback && ((*callback)(callbackData)))
            {
                hr = IMGERR_ABORT;
                break;
            }

            // Get pixel data for the current band

            bandRect.bottom = bandRect.top + dh;

            if (bandRect.bottom > ymax)
                bandRect.bottom = ymax;

            hr = InternalLockBits(
                    &bandRect,
                    IMGLOCK_READ|IMGLOCK_USERINPUTBUF,
                    pixfmt,
                    &tempData);

            if (SUCCEEDED(hr))
            {
                // Push the current band to the sink

                hr = sink->PushPixelData(&bandRect, &tempData, TRUE);
                InternalUnlockBits(&bandRect, &tempData);
            }

            if (FAILED(hr))
                break;

            // Move on to the next band

            bandRect.top += dh;
        }
        while (bandRect.top < ymax);

        FreeBitmapData(&bmpdata);
    }

exitPushIntoSink:

    return sink->EndSink(hr);
}


/**************************************************************************\
*
* Function Description:
*
*   Get bitmap dimensions in pixels
*
* Arguments:
*
*   size - Buffer for returning bitmap size
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetSize(
    OUT SIZE* size
    )
{
    if ( !IsValid() )
    {
        return E_FAIL;
    }

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    size->cx = Width;
    size->cy = Height;
    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Access bitmap pixel data
*
* Arguments:
*
*   rect - Specifies the area of the bitmap to be accessed
*       NULL means the entire bitmap
*   flags - Misc. lock flags
*   pixfmt - Specifies the desired pixel data format
*   lockedBitmapData - Return information about the locked pixel data
*
* Return Value:
*
*   Status code
*
* Notes:
*
*   If IMGLOCK_USERINPUTBUF bit of flags is set, then the caller must
*   also initialize the scan0 and stride fields of lockedBitmapData.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::LockBits(
    IN const RECT* rect,
    IN UINT flags,
    IN PixelFormatID pixfmt,
    OUT BitmapData* lockedBitmapData
    )
{
    if ( !IsValid() )
    {
        return E_FAIL;
    }

    // Validate input parameters

    if (pixfmt != PIXFMT_DONTCARE && !IsValidPixelFormat(pixfmt) ||
        (flags & ~BMPDATA_LOCKMODEMASK) != 0 ||
        !lockedBitmapData ||
        (flags & IMGLOCK_USERINPUTBUF) && !lockedBitmapData->Scan0)
    {
        WARNING(("Invalid parameters in LockBits"));
        return E_INVALIDARG;
    }

    // Lock the current bitmap object

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    // We can only have one lock at a time
    // Validate the specified lock area, if any

    HRESULT hr;

    if (InterlockedIncrement(&bitsLock) != 0)
        hr = IMGERR_BADLOCK;
    else if (!ValidateImageArea(&lockedArea, rect))
    {
        WARNING(("Invalid bitmap area in LockBits"));
        hr = E_INVALIDARG;
    }
    else
        hr = InternalLockBits(&lockedArea, flags, pixfmt, lockedBitmapData);

    if (FAILED(hr))
        InterlockedDecrement(&bitsLock);

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Internal implementation of IBitmapImage::LockBits method.
*   We assume parameter validation and internal house-keeping chores
*   (object locks, etc.) have already been done.
*
* Arguments:
*
*   Same as for LockBits.
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::InternalLockBits(
    const RECT* rect,
    UINT flags,
    PixelFormatID pixfmt,
    BitmapData* lockedData
    )
{
    HRESULT hr;

    if((hr = LockDirectDrawSurface()) != S_OK)
        return hr;

    // Composite a BitmapData structure for 
    // the specified area of the bitmap image

    BitmapData bmpdata;

    GetBitmapAreaData(rect, &bmpdata);

    // Make sure the left side of the locked area
    // is aligned on a byte boundary

    UINT pixsize;
    UINT startBit;

    if (pixfmt == PIXFMT_DONTCARE)
        pixfmt = PixelFormat;

    pixsize = GetPixelFormatSize(pixfmt);
    startBit = GetPixelFormatSize(PixelFormat) * rect->left & 7;

    lockedData->Width = bmpdata.Width;
    lockedData->Height = bmpdata.Height;
    lockedData->PixelFormat = pixfmt;
    lockedData->Reserved = flags;

    // Fast case: the requested pixel format is the same
    // as our internal pixel format AND the left side of
    // the locked area is byte-aligned.

    if (pixfmt == PixelFormat && startBit == 0)
    {
        if (! (flags & IMGLOCK_USERINPUTBUF))
        {
            // Return a pointer directly to our
            // internal bitmap pixel data buffer

            lockedData->Scan0 = bmpdata.Scan0;
            lockedData->Stride = bmpdata.Stride;
        }
        else if (flags & IMGLOCK_READ)
        {
            //
            // Use the caller-supplied buffer
            //

            const BYTE* s = (const BYTE*) bmpdata.Scan0;
            BYTE* d = (BYTE*) lockedData->Scan0;
            UINT bytecnt = (bmpdata.Width * pixsize + 7) >> 3;
            UINT y = bmpdata.Height;

            while (y--)
            {
                memcpy(d, s, bytecnt);
                s += bmpdata.Stride;
                d += lockedData->Stride;
            }
        }

        return S_OK;
    }

    // Slow case: the requested pixel format doesn't match
    // the native pixel format of the bitmap image.
    // We allocate a temporary buffer if the caller didn't
    // provide one and do format conversion.

    if (! (flags & IMGLOCK_USERINPUTBUF) &&
        ! AllocBitmapData(bmpdata.Width, bmpdata.Height, pixfmt, lockedData, NULL))
    {
        UnlockDirectDrawSurface();
        return E_OUTOFMEMORY;
    }

    // If locking for write only, then don't need to read source pixels.
    // NOTE: The initial content of the locked bitmap data is undefined.

    if (! (flags & IMGLOCK_READ))
        return S_OK;

    if (startBit == 0)
    {
        // Perform format conversion on source pixel data

        hr = ConvertBitmapData(
                lockedData,
                colorpal,
                &bmpdata,
                colorpal);
    }
    else
    {
        // Very slow case: the left side of the locked area
        // is NOT byte-aligned. 

        hr = ConvertBitmapDataSrcUnaligned(
                lockedData,
                colorpal,
                &bmpdata,
                colorpal,
                startBit);
    }

    if (FAILED(hr))
    {
        FreeBitmapData(lockedData);
        UnlockDirectDrawSurface();
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Unlock an area of the bitmap previously locked by a LockBits call
*
* Arguments:
*
*   lockedBitmapData - Information returned by a previous LockBits call
*       Must not have been modified since LockBits returned.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::UnlockBits(
    IN const BitmapData* lockedBitmapData
    )
{
    if ( !IsValid() )
    {
        return E_FAIL;
    }

    // Lock the current bitmap object

    HRESULT hr;
    GpLock lock(&objectLock);

    if (lock.LockFailed())
        hr = IMGERR_OBJECTBUSY;
    else if (lockedBitmapData == NULL)
        hr = E_INVALIDARG;
    else if (bitsLock != 0)
        hr = IMGERR_BADUNLOCK;
    else
    {
        hr = InternalUnlockBits(&lockedArea, lockedBitmapData);
        InterlockedDecrement(&bitsLock);
    }

    return hr;
}

HRESULT
GpMemoryBitmap::InternalUnlockBits(
    const RECT* rect,
    const BitmapData* lockedData
    )
{
    HRESULT hr;
    UINT_PTR flags = lockedData->Reserved;

    if (flags & IMGLOCK_WRITE)
    {
        if (flags & (BMPDATA_ALLOCMASK | IMGLOCK_USERINPUTBUF))
        {
            // Composite a BitmapData structure for
            // the specified area of the bitmap image

            BitmapData bmpdata;
            GetBitmapAreaData(rect, &bmpdata);

            UINT startBit;

            startBit = GetPixelFormatSize(PixelFormat) * rect->left & 7;

            if (startBit == 0)
            {
                // The left column of the locked area is byte-aligned

                hr = ConvertBitmapData(
                        &bmpdata,
                        colorpal,
                        lockedData,
                        colorpal);
            }
            else
            {
                // The left column of the locked area is NOT byte-aligned.

                hr = ConvertBitmapDataDstUnaligned(
                        &bmpdata,
                        colorpal,
                        lockedData,
                        colorpal,
                        startBit);
            }
        }
        else
            hr = S_OK;

        // if the destination has alpha and the locked format has alpha,
        // then lockbits may have caused the alpha data to change

        if (CanHaveAlpha(PixelFormat, colorpal) &&
            (IsAlphaPixelFormat(lockedData->PixelFormat) || 
             IsIndexedPixelFormat(lockedData->PixelFormat)))
        {
            if (this->PixelFormat == PIXFMT_16BPP_ARGB1555)
            {
                alphaTransparency = ALPHA_SIMPLE;
            }
            else
            {
                alphaTransparency = ALPHA_UNKNOWN;
            }
        }
        else
        {
            alphaTransparency = ALPHA_NONE;
        }
    }
    else
        hr = S_OK;

    // Always free any temporary buffer we allocated during LockBits
    // whether or not unlock was successful.

    FreeBitmapData(lockedData);

    // Always unlock the direct draw surface

    UnlockDirectDrawSurface();

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Set color palette associated with the bitmap image
*
* Arguments:
*
*   palette - Specifies the new color palette
*       NULL to remove an existing palette associated with the image.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SetPalette(
    IN const ColorPalette* palette
    )
{
    // Validate input parameters

    if ( palette == NULL )
    {
        WARNING(("Invalid parameter in SetPalette"));
        return E_INVALIDARG;
    }

    // Make a copy of the input color palette

    ColorPalette* newpal = CloneColorPalette(palette);

    if (newpal == NULL)
        return E_OUTOFMEMORY;

    // Lock the current bitmap object

    GpLock lock(&objectLock);

    if (lock.LockFailed())
    {
        GpFree(newpal);
        return IMGERR_OBJECTBUSY;
    }


    // !!! [asecchia] what does it mean to set a palette on a non
    // palettized image.

    // Free the old palette, if any
    // and select the new palette into the bitmap object
    if ( NULL != this->colorpal )
    {
        GpFree(this->colorpal);
    }

    this->colorpal = newpal;

    // Compute transparancy hint from palette
    alphaTransparency = ALPHA_OPAQUE;
    for (UINT i = 0; i < newpal->Count; i++)
    {
        ARGB argb = newpal->Entries[i] & 0xff000000;

        if (argb != 0xff000000)
        {
            if (argb == 0)
                alphaTransparency = ALPHA_SIMPLE;
            else
            {
                alphaTransparency = ALPHA_COMPLEX;
                break;
            }
        }
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Get color palette associated with the bitmap image
*
* Arguments:
*
*   palette - Returns a pointer to a copy of the color palette
*       associated with the current image
*
* Return Value:
*
*   Status code
*
* Notes:
*
*   If a palette is returned to the caller, the caller is then
*   responsible to free the memory afterwards by calling CoTaskMemFree.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetPalette(
    OUT ColorPalette** palette
    )
{
    HRESULT hr;

    *palette = NULL;

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        hr = IMGERR_OBJECTBUSY;
    else
    {
        const ColorPalette* pal = GetCurrentPalette();
        
        if (pal == NULL)
            hr = IMGERR_NOPALETTE;
        else if ((*palette = CloneColorPalette(pal, TRUE)) == NULL)
            hr = E_OUTOFMEMORY;
        else
            hr = S_OK;
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Begin sinking source image data into the bitmap object
*
* Arguments:
*
*   imageInfo - For negotiating data transfer parameters with the source
*   subarea - For returning subarea information
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::BeginSink(
    IN OUT ImageInfo* imageInfo,
    OUT OPTIONAL RECT* subarea
    )
{
    // We only access in-memory pixel data

    imageInfo->RawDataFormat = IMGFMT_MEMORYBMP;

    // Negotiate pixel format

    PixelFormatID pixfmt;

    if ((pixfmt = PixelFormat) == PIXFMT_DONTCARE)
        pixfmt = imageInfo->PixelFormat;

    if (!IsValidPixelFormat(pixfmt))
        return E_INVALIDARG;

    // Indicate whether we can support alpha

    if (IsAlphaPixelFormat(pixfmt) || IsIndexedPixelFormat(pixfmt))
        imageInfo->Flags |= SINKFLAG_HASALPHA;
    else
        imageInfo->Flags &= ~SINKFLAG_HASALPHA;

    // Check if we can support composite semantics

    if (!IsValid())
        imageInfo->Flags &= ~SINKFLAG_COMPOSITE;

    // We don't support multi-pass for now. MINLIU 08/22/00
    // This fixes a bunch of GIF problems.

    imageInfo->Flags &= ~SINKFLAG_MULTIPASS;

    // Negotiate bitmap dimension

    BOOL noCurDimension = (Width == 0 && Height == 0);
    BOOL srcScalable = (imageInfo->Flags & SINKFLAG_SCALABLE);

    if (noCurDimension && srcScalable)
    {
        // Current bitmap is empty and source is scalable:
        //  use the source dimension and sink's resolution

        Width = imageInfo->Width;
        Height = imageInfo->Height;

        imageInfo->Xdpi = xdpi;
        imageInfo->Ydpi = ydpi;
    }
    else if (noCurDimension ||
             Width == imageInfo->Width && Height == imageInfo->Height)
    {
        // Current image is empty:
        //  use the source dimension and resolution

        ASSERT(!noCurDimension || Scan0 == NULL);

        Width = imageInfo->Width;
        Height = imageInfo->Height;
        xdpi = imageInfo->Xdpi;
        ydpi = imageInfo->Ydpi;
    }
    else if (srcScalable)
    {
        // Source is scalable and sink has a preferred dimension
        //  use the sink's preferred dimension

        xdpi = imageInfo->Xdpi * Width / imageInfo->Width;
        ydpi = imageInfo->Ydpi * Height / imageInfo->Height;

        imageInfo->Width = Width;
        imageInfo->Height = Height;
        imageInfo->Xdpi = xdpi;
        imageInfo->Ydpi = ydpi;
    }
    else
    {
        // Source is not scalable and sink has a preferred dimension
        return E_INVALIDARG;
    }

    // Allocate bitmap memory buffer

    if (!IsValid())
    {
        HRESULT hr = AllocBitmapMemory(Width, Height, pixfmt);

        if (FAILED(hr))
            return hr;
    }

    // We always want the whole source image

    if (subarea)
    {
        subarea->left = subarea->top = 0;
        subarea->right = Width;
        subarea->bottom = Height;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   End the sink process
*
* Arguments:
*
*   statusCode - Last status code
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::EndSink(
    HRESULT statusCode
    )
{
    return statusCode;
}


/**************************************************************************\
*
* Function Description:
*
*   Ask the sink to allocate pixel data buffer
*
* Arguments:
*
*   rect - Specifies the interested area of the bitmap
*   pixelFormat - Specifies the desired pixel format
*   lastPass - Whether this the last pass over the specified area
*   bitmapData - Returns information about pixel data buffer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetPixelDataBuffer(
    IN const RECT* rect,
    IN PixelFormatID pixelFormat,
    IN BOOL lastPass,
    OUT BitmapData* bitmapData
    )
{
    ASSERT(bitmapData);

    if (IsValid())
        return LockBits(rect, IMGLOCK_WRITE, pixelFormat, bitmapData);
    else
        return E_UNEXPECTED;
}


/**************************************************************************\
*
* Function Description:
*
*   Give the sink pixel data and release data buffer
*
* Arguments:
*
*   bitmapData - Buffer filled by previous GetPixelDataBuffer call
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::ReleasePixelDataBuffer(
    IN const BitmapData* bitmapData
    )
{
    ASSERT(bitmapData);

    if (IsValid())
        return UnlockBits(bitmapData);
    else
        return E_UNEXPECTED;
}


/**************************************************************************\
*
* Function Description:
*
*   Push pixel data into the bitmap object
*
* Arguments:
*
*   rect - Specifies the affected area of the bitmap 
*   bitmapData - Info about the pixel data being pushed
*   lastPass - Whether this is the last pass over the specified area
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::PushPixelData(
    IN const RECT* rect,
    IN const BitmapData* bitmapData,
    IN BOOL lastPass
    )
{
    ASSERT(bitmapData);

    if (bitmapData->PixelFormat == PIXFMT_DONTCARE)
        return E_INVALIDARG;

    // Lock the bitmap object

    HRESULT hr;
    RECT area;
    GpLock lock(&objectLock);

    if (lock.LockFailed())
        hr = IMGERR_OBJECTBUSY;
    else if (!IsValid())
        hr = E_UNEXPECTED;
    else if (!ValidateImageArea(&area, rect))
        hr = E_INVALIDARG;
    else
    {
        BitmapData tempData = *bitmapData;
    
        // Push pixel data into the bitmap
    
        hr = InternalLockBits(
                &area,
                IMGLOCK_WRITE|IMGLOCK_USERINPUTBUF,
                tempData.PixelFormat,
                &tempData);
    
        if (SUCCEEDED(hr))
            hr = InternalUnlockBits(&area, &tempData);

    }
    
    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Push raw image data into the bitmap
*
* Arguments:
*
*   buffer - Pointer to image data buffer
*   bufsize - Size of the data buffer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::PushRawData(
    IN const VOID* buffer,
    IN UINT bufsize
    )
{
    // We don't support raw image data transfer.
    // The only format we support is in-memory pixel data.

    return E_NOTIMPL;
}


/**************************************************************************\
*
* Function Description:
*
*   Get a thumbnail representation for the image object
*
* Arguments:
*
*   thumbWidth, thumbHeight - Specifies the desired thumbnail size in pixels
*   thumbImage - Return a pointer to the thumbnail image
*       The caller should Release it after using it.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetThumbnail(
    IN OPTIONAL UINT thumbWidth,
    IN OPTIONAL UINT thumbHeight,
    OUT IImage** thumbImage
    )
{
    if (thumbWidth == 0 && thumbHeight == 0)
        thumbWidth = thumbHeight = DEFAULT_THUMBNAIL_SIZE;

    if (thumbWidth && !thumbHeight ||
        !thumbWidth && thumbHeight)
    {
        return E_INVALIDARG;
    }

    // Generate the thumbnail using the averaging interpolation algorithm

    HRESULT hr;
    GpMemoryBitmap* bmp;

    hr = GpMemoryBitmap::CreateFromImage(
                        this,
                        thumbWidth,
                        thumbHeight,
                        PIXFMT_DONTCARE,
                        INTERP_AVERAGING,
                        &bmp);

    if (SUCCEEDED(hr))
    {
        hr = bmp->QueryInterface(IID_IImage, (VOID**) thumbImage);
        bmp->Release();
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Lock and update appropriate class member data if the direct draw 
*   suface referenced by the bitmap exists.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::LockDirectDrawSurface(void)
{
    HRESULT hr = S_OK;

    if(creationFlag == CREATEDFROM_DDRAWSURFACE)
    {
        ASSERT(ddrawSurface != NULL);
        ASSERT(Scan0 == NULL);

        DDSURFACEDESC2 ddsd;
        
        memset(&ddsd, 0, sizeof(ddsd));
        ddsd.dwSize = sizeof(ddsd);
        hr = ddrawSurface->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL);

        if(hr == DD_OK)
        {
            ASSERT(ddsd.lpSurface != NULL);
            ASSERT(!(ddsd.lPitch & 3));
            Scan0 = ddsd.lpSurface;
            Stride = ddsd.lPitch;
        }
        else
        {
            WARNING(("Unable to lock direct draw suface"));
        }

    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Unlock the direct draw suface referenced by the bitmap if it exists.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::UnlockDirectDrawSurface(void)
{
    HRESULT hr = S_OK;

    if(creationFlag == CREATEDFROM_DDRAWSURFACE)
    {
        ASSERT(Scan0 != NULL);

        hr = ddrawSurface->Unlock(NULL);
        Scan0 = NULL;
        Stride = 0;

        if(hr != DD_OK)
        {
            WARNING(("Error unlocking direct draw surface"));
        }
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Retrieves the transparency of the GpMemoryBitmap.
*
* Arguments:
*
*   transparency - return buffer for the transparency hint
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetAlphaHint(INT* alphaHint)
{
    HRESULT hr = S_OK;

    *alphaHint = alphaTransparency;

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Sets the transparency of the GpMemoryBitmap.
*
* Arguments:
*
*   transparency - new transparency hint
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SetAlphaHint(INT alphaHint)
{
    HRESULT hr = S_OK;

    alphaTransparency = alphaHint;

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the counter of property items in the image
*
* Arguments:
*
*   [OUT]numOfProperty - The number of property items in the image
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   09/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetPropertyCount(
    OUT UINT*   numOfProperty
    )
{
    if ( numOfProperty == NULL )
    {
        WARNING(("GpMemoryBitmap::GetPropertyCount---Invalid input parameter"));
        return E_INVALIDARG;
    }

    // Note: we don't need to check if there is a property in this
    // GpMemoryBitmap object or not.
    // If it doesn't have one, we will return zero (initialized in constructor).
    // Otherwise, return the real counter

    *numOfProperty = PropertyNumOfItems;

    return S_OK;
}// GetPropertyCount()

/**************************************************************************\
*
* Function Description:
*
*   Get a list of property IDs for all the property items in the image
*
* Arguments:
*
*   [IN]  numOfProperty - The number of property items in the image
*   [OUT] list----------- A memory buffer the caller provided for storing the
*                         ID list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   09/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetPropertyIdList(
    IN UINT numOfProperty,
  	IN OUT PROPID* list
    )
{
    if ( (numOfProperty != PropertyNumOfItems) || (list == NULL) )
    {
        WARNING(("GpMemoryBitmap::GetPropertyIdList--invalid parameters"));
        return E_INVALIDARG;
    }

    if ( PropertyNumOfItems == 0 )
    {
        // This is OK since there is no property in this image

        return S_OK;
    }
    
    // Coping list IDs from our internal property item list

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    for ( int i = 0;
         (  (i < (INT)PropertyNumOfItems) && (pTemp != NULL)
         && (pTemp != &PropertyListTail));
         ++i )
    {
        list[i] = pTemp->id;
        pTemp = pTemp->pNext;
    }

    return S_OK;
}// GetPropertyIdList()

/**************************************************************************\
*
* Function Description:
*
*   Get the size, in bytes, of a specific property item, specified by the
*   property ID
*
* Arguments:
*
*   [IN]propId - The ID of a property item caller is interested
*   [OUT]size--- Size of this property item, in bytes
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   09/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetPropertyItemSize(
    IN PROPID propId,
    OUT UINT* size
    )
{
    if ( size == NULL )
    {
        WARNING(("GpMemoryBitmap::GetPropertyItemSize--size is NULL"));
        return E_INVALIDARG;
    }

    if ( PropertyNumOfItems < 1 )
    {
        // No property item exist in this GpMemoryBitmap object

        WARNING(("GpMemoryBitmap::GetPropertyItemSize---No property exist"));
        return E_FAIL;
    }

    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    while ( (pTemp->pNext != NULL) && (pTemp->id != propId) )
    {
        pTemp = pTemp->pNext;
    }

    if ( pTemp->pNext == NULL )
    {
        // This ID doesn't exist

        WARNING(("MemBitmap::GetPropertyItemSize-Required item doesn't exist"));
        return IMGERR_PROPERTYNOTFOUND;
    }

    // The size of an property item should be "The size of the item structure
    // plus the size for the value

    *size = pTemp->length + sizeof(PropertyItem);

    return S_OK;
}// GetPropertyItemSize()

/**************************************************************************\
*
* Function Description:
*
*   Get a specific property item, specified by the prop ID.
*
* Arguments:
*
*   [IN]propId -- The ID of the property item caller is interested
*   [IN]propSize- Size of the property item. The caller has allocated these
*                 "bytes of memory" for storing the result
*   [OUT]pItemBuffer- A memory buffer for storing this property item
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   09/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetPropertyItem(
    IN  PROPID              propId,
    IN  UINT                propSize,
    IN  OUT PropertyItem*   pItemBuffer
    )
{
    if ( pItemBuffer == NULL )
    {
        WARNING(("GpMemoryBitmap::GetPropertyItem--Input buffer is NULL"));
        return E_INVALIDARG;
    }

    if ( PropertyNumOfItems < 1 )
    {
        // No property item exist in this GpMemoryBitmap object

        WARNING(("GpMemoryBitmap::GetPropertyItem---No property exist"));
        return E_FAIL;
    }

    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;
    UNALIGNED BYTE*   pOffset = (BYTE*)pItemBuffer + sizeof(PropertyItem);

    while ( (pTemp->pNext != NULL) && (pTemp->id != propId) )
    {
        pTemp = pTemp->pNext;
    }

    if ( pTemp->pNext == NULL )
    {
        // This ID doesn't exist in the list

        WARNING(("GpMemBitmap::GetPropertyItem---Require item doesn't exist"));
        return IMGERR_PROPERTYNOTFOUND;
    }
    else if ( (pTemp->length + sizeof(PropertyItem)) != propSize )
    {
        WARNING(("GpMemBitmap::GetPropertyItem---Invalid input propsize"));
        return E_FAIL;
    }

    // Found the ID in the list and return the item

    pItemBuffer->id = pTemp->id;
    pItemBuffer->length = pTemp->length;
    pItemBuffer->type = pTemp->type;
    pItemBuffer->value = pOffset;

    GpMemcpy(pOffset, pTemp->value, pTemp->length);

    return S_OK;
}// GetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Get the size of ALL property items in the image
*
* Arguments:
*
*   [OUT]totalBufferSize-- Total buffer size needed, in bytes, for storing all
*                          property items in the image
*   [OUT]numOfProperty --- The number of property items in the image
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   09/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetPropertySize(
    OUT UINT* totalBufferSize,
    OUT UINT* numProperties
    )
{
    if ( (totalBufferSize == NULL) || (numProperties == NULL) )
    {
        WARNING(("GpMemoryBitmap::GetPropertySize--invalid inputs"));
        return E_INVALIDARG;
    }

    // Note: we don't need to check if there is a property in this
    // GpMemoryBitmap object or not.
    // If it doesn't have one, we will return zero (initialized in constructor).
    // Otherwise, return the real counter
    
    *numProperties = PropertyNumOfItems;

    // Total buffer size should be list value size plus the total header size

    *totalBufferSize = PropertyListSize
                     + PropertyNumOfItems * sizeof(PropertyItem);

    return S_OK;
}// GetPropertySize()

/**************************************************************************\
*
* Function Description:
*
*   Get ALL property items in the image
*
* Arguments:
*
*   [IN]totalBufferSize-- Total buffer size, in bytes, the caller has allocated
*                         memory for storing all property items in the image
*   [IN]numOfProperty --- The number of property items in the image
*   [OUT]allItems-------- A memory buffer caller has allocated for storing all
*                         the property items
*
*   Note: "allItems" is actually an array of PropertyItem
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   09/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    IN OUT PropertyItem* allItems
    )
{
    // Figure out total property header size first

    UINT    uiHeaderSize = PropertyNumOfItems * sizeof(PropertyItem);

    if ( (totalBufferSize != (uiHeaderSize + PropertyListSize))
       ||(numProperties != PropertyNumOfItems)
       ||(allItems == NULL) )
    {
        WARNING(("GpMemoryBitmap::GetPropertyItems--invalid inputs"));
        return E_INVALIDARG;
    }

    if ( PropertyNumOfItems < 1 )
    {
        // No property item exist in this GpMemoryBitmap object

        WARNING(("GpMemoryBitmap::GetAllPropertyItems---No property exist"));
        return E_FAIL;
    }

    // Loop through our cache list and assigtn the result out

    InternalPropertyItem*   pTempSrc = PropertyListHead.pNext;
    PropertyItem*           pTempDst = allItems;
    UNALIGNED BYTE*         pOffSet = (UNALIGNED BYTE*)allItems + uiHeaderSize;
        
    for ( int i = 0; i < (INT)PropertyNumOfItems; ++i )
    {
        pTempDst->id = pTempSrc->id;
        pTempDst->length = pTempSrc->length;
        pTempDst->type = pTempSrc->type;
        pTempDst->value = (void*)pOffSet;

        GpMemcpy(pOffSet, pTempSrc->value, pTempSrc->length);

        pOffSet += pTempSrc->length;
        pTempSrc = pTempSrc->pNext;
        pTempDst++;
    }
    
    return S_OK;
}// GetAllPropertyItems()

/**************************************************************************\
*
* Function Description:
*
*   Remove a specific property item, specified by the prop ID.
*
* Arguments:
*
*   [IN]propId -- The ID of the property item to be removed
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   09/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::RemovePropertyItem(
    IN PROPID   propId
    )
{
    if ( PropertyNumOfItems < 1 )
    {
        WARNING(("GpMemoryBitmap::RemovePropertyItem--No property item exist"));
        return E_FAIL;
    }

    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    while ( (pTemp->pNext != NULL) && (pTemp->id != propId) )
    {
        pTemp = pTemp->pNext;
    }

    if ( pTemp->pNext == NULL )
    {
        // Item not found

        WARNING(("GpMemoryBitmap::RemovePropertyItem-Property item not found"));
        return IMGERR_PROPERTYNOTFOUND;
    }

    // Found the item in the list. Remove it

    PropertyNumOfItems--;
    PropertyListSize -= pTemp->length;
        
    RemovePropertyItemFromList(pTemp);
       
    // Remove the item structure

    GpFree(pTemp);

    return S_OK;
}// RemovePropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Set a property item, specified by the propertyitem structure. If the item
*   already exists, then its contents will be updated. Otherwise a new item
*   will be added
*
* Arguments:
*
*   [IN]item -- A property item the caller wants to set
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   09/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SetPropertyItem(
    IN PropertyItem item
    )
{
    InternalPropertyItem*   pTemp = PropertyListHead.pNext;
        
    // There are property items in the list.
    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    while ( (pTemp->pNext != NULL) && (pTemp->id != item.id) )
    {
        pTemp = pTemp->pNext;
    }

    if ( pTemp->pNext == NULL )
    {
        // This item doesn't exist in the list, add it into the list
        
        PropertyNumOfItems++;
        PropertyListSize += item.length;
        
        if ( AddPropertyList(&PropertyListTail,
                             item.id,
                             item.length,
                             item.type,
                             item.value) != S_OK )
        {
            WARNING(("GpMemBitmap::SetPropertyItem-AddPropertyList() failed"));
            return E_FAIL;
        }
    }
    else
    {
        // This item already exists in the link list, update the info
        // Update the size first

        PropertyListSize -= pTemp->length;
        PropertyListSize += item.length;
        
        // Free the old item

        GpFree(pTemp->value);

        pTemp->length = item.length;
        pTemp->type = item.type;

        pTemp->value = GpMalloc(item.length);
        if ( pTemp->value == NULL )
        {
            // Since we already freed the old item, we should set its length to
            // 0 before return

            pTemp->length = 0;
            WARNING(("GpMemBitmap::SetPropertyItem-Out of memory"));
            return E_OUTOFMEMORY;
        }

        GpMemcpy(pTemp->value, item.value, item.length);
    }

    return S_OK;
}// SetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Sets the min/max alpha of the GpMemoryBitmap.
*
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SetMinMaxAlpha(BYTE minA, BYTE maxA)
{
    HRESULT hr = S_OK;

    minAlpha = minA;
    maxAlpha = maxA;

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Gets the min/max alpha of the GpMemoryBitmap.
*
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetMinMaxAlpha(BYTE* minA, BYTE* maxA)
{
    HRESULT hr = S_OK;

    *minA = minAlpha;
    *maxA = maxAlpha;

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Get a pointer of the decoder.
*   The main purpose for this function is to get a pointer to the JPEg decoder
*   so that we can get information from the JPEG decoder and pass it to the
*   JPEG encoder. This way, we can preserve all the private application headers.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SetSpecialJPEG(
    GpDecodedImage *pImgSrc         // Pointer to the DecodedImage, the source
    )
{
    HRESULT hr = E_INVALIDARG;

    if (pImgSrc)
    {
        ImageInfo imgInfo;
        hr = pImgSrc->GetImageInfo(&imgInfo);

        if (SUCCEEDED(hr))
        {
            // Check if the source is JPEG or not

            if (imgInfo.RawDataFormat == IMGFMT_JPEG)
            {
                // If we already have a pointer to the JPEG decoder somewhow,
                // release it first

                if (JpegDecoderPtr)
                {
                    JpegDecoderPtr->Release();
                    JpegDecoderPtr = NULL;
                }

                // Get the decoder pointer

                hr = pImgSrc->GetDecoderPtr(&JpegDecoderPtr);
                if (SUCCEEDED(hr))
                {
                    JpegDecoderPtr->AddRef();
                }
            }
            else
            {
                // Valid only the source is JPEG image

                hr = E_INVALIDARG;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\basicops.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   basicops.cpp
*
* Abstract:
*
*   Implementation of IBasicImageOps interface
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Clone image property items from current object to the destination object
*
* Arguments:
*
*   dstBmp   --- [IN]Pointer to the destination GpMemoryBitmap object
*
* Return Value:
*
*   Status code
*
* Note:
*   This is a private method. So we don't need to do input parameter
*   validation since the caller should do this for us.
*
* Revision History:
*
*   09/08/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::ClonePropertyItems(
    IN GpMemoryBitmap* dstBmp
    )
{
    if ( PropertyNumOfItems < 1 )
    {
        // No property

        return S_OK;
    }

    // PropertyListHead and PropertyListTail are always uninitialized and
    // therefore we have to skip the first one and make the loop skip the 
    // last one.
    
    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    while ( pTemp->pNext != NULL )
    {
        // Add current item into the destination property item list
        
        if ( AddPropertyList(&(dstBmp->PropertyListTail),
                             pTemp->id,
                             pTemp->length,
                             pTemp->type,
                             pTemp->value) != S_OK )
        {
            WARNING(("MemBitmap::ClonePropertyItems-AddPropertyList() failed"));
            return E_FAIL;
        }
        
        pTemp = pTemp->pNext;
    }

    dstBmp->PropertyNumOfItems = PropertyNumOfItems;
    dstBmp->PropertyListSize = PropertyListSize;
    
    return S_OK;
}// ClonePropertyItems()

/**************************************************************************\
*
* Function Description:
*
*   Clone an area of the bitmap image
*
* Arguments:
*
*   rect - Specifies the image area to be cloned
*          NULL means the entire image
*   outbmp - Returns a pointer to the cloned bitmap image
*   bNeedCloneProperty--Flag caller passes in to indicate if this method
*                       should clone property or not
*
* Return Value:
*
*   Status code
*
* Note: if it is a partial clone, the caller should not ask cloning
*       property items. Otherwise, there will be inconsistency in the image
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::Clone(
    IN OPTIONAL const RECT* rect,
    OUT IBitmapImage** outbmp,
    BOOL    bNeedCloneProperty
    )
{
    ASSERT(IsValid());

    *outbmp = NULL;

    // Lock the current bitmap object and validate source rectangle

    GpLock lock(&objectLock);
    HRESULT hr;
    RECT area;
    GpMemoryBitmap* bmp;

    if (lock.LockFailed())
    {
        WARNING(("GpMemoryBitmap::Clone---Object busy"));
        hr = IMGERR_OBJECTBUSY;
    }
    else if (!ValidateImageArea(&area, rect))
    {
        WARNING(("GpMemoryBitmap::Clone---Invalid clone area"));
        hr = E_INVALIDARG;
    }
    else if ((bmp = new GpMemoryBitmap()) == NULL)
    {
        WARNING(("GpMemoryBitmap::Clone---Out of memory"));
        hr = E_OUTOFMEMORY;
    }
    else
    {
        UINT w = area.right - area.left;
        UINT h = area.bottom - area.top;
        RECT r = { 0, 0, w, h };
        BitmapData bmpdata;

        // Initialize the new bitmap image object

        hr = bmp->InitNewBitmap(w, h, PixelFormat);

        if (SUCCEEDED(hr))
        {
            // Copy pixel data from the current bitmap image object
            // to the new bitmap image object.

            bmp->GetBitmapAreaData(&r, &bmpdata);

            hr = InternalLockBits(&area,
                                  IMGLOCK_READ|IMGLOCK_USERINPUTBUF,
                                  PixelFormat,
                                  &bmpdata);

            if (SUCCEEDED(hr))
            {
                InternalUnlockBits(&r, &bmpdata);
            }
                
            // Clone color palettes, flags, etc.

            if (SUCCEEDED(hr))
            {
                // Copy DPI info.

                bmp->xdpi = this->xdpi;
                bmp->ydpi = this->ydpi;
                
                hr = bmp->CopyPaletteFlagsEtc(this);                
            }

            // Clone all the property items if there is any and the caller wants
            // to
            
            if ( SUCCEEDED(hr)
               &&(bNeedCloneProperty == TRUE)
               &&(PropertyNumOfItems > 0) )
            {
                hr = ClonePropertyItems(bmp);
            }
        }

        if (SUCCEEDED(hr))
        {
            *outbmp = bmp;
        }
        else
        {
            delete bmp;
        }
    }

    return hr;
}// Clone()


/**************************************************************************\
*
* Function Description:
*
*   Functions for flipping a scanline
*
* Arguments:
*
*   dst - Pointer to the destination scanline
*   src - Pointer to the source scanline
*   count - Number of pixels
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID _FlipXNone(BYTE* dst, const BYTE* src, UINT count)
{
    memcpy(dst, src, count);
}

BYTE byteRev[] = {0x0, 0x8, 0x4, 0xc,
                  0x2, 0xa, 0x6, 0xe,
                  0x1, 0x9, 0x5, 0xd,
                  0x3, 0xb, 0x7, 0xf};
// Given a byte as input, return the byte resulting from reversing the bits
// of the input byte.
BYTE ByteReverse (BYTE bIn)
{
    BYTE bOut;  // return value

    bOut =
        (byteRev[ (bIn & 0xf0) >> 4 ]) |
        (byteRev[ (bIn & 0x0f)] << 4) ;

    return bOut;
}

// these masks are used in the shift left phase of FlipX1bpp
BYTE maskLeft[]  = {0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f};
BYTE maskRight[] = {0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80};

VOID _FlipX1bpp(BYTE* dst, const BYTE* src, UINT count)
{
    UINT iByte; // byte within the scan line

    if (count == 0)
    {
        return;
    }

    // The algorithm for 1 bpp flip is:
    // 1. Reverse the order of the bytes in the scan line.
    // 2. Reverse the bits within each byte of the scan line.
    // 3. Shift the bits of the scan line to be aligned on the left.

    UINT numBytes = (count + 7) / 8;    // number of bytes in the scan line

    // Step 1
    for (iByte = 0; iByte < numBytes; iByte++)
    {
        dst[iByte] = src[numBytes - 1 - iByte];
    }

    // Step 2
    for (iByte = 0; iByte < numBytes; iByte++)
    {
        dst[iByte] = ByteReverse(dst[iByte]);
    }

    // Step 3
    UINT extraBits = count & 0x07;  // count mod 8
    BYTE maskL = maskLeft[extraBits];
    BYTE maskR = maskRight[extraBits];
    for (iByte = 0; iByte < numBytes - 1; iByte++)
    {
        dst[iByte] =
            ((dst[iByte]   & maskL) << (8 - extraBits)) |
            ((dst[iByte+1] & maskR) >> (extraBits)) ;
    }
    // last byte: iByte = numBytes-1
    dst[iByte] = ((dst[iByte]   & maskL) << (8 - extraBits));
}

VOID _FlipX4bpp(BYTE* dst, const BYTE* src, UINT count)
{
    // if the number of pixels in the scanline is odd, we have to deal with
    // nibbles across byte boundaries.
    if (count % 2)
    {
        BYTE temp;

        dst += (count / 2);

        // Handle the last dst byte
        *dst = *src & 0xf0;
        dst--;
        count--;
        // ASSERT: count is now even.
        while (count)
        {
            *dst = (*src & 0x0f) | (*(src+1) & 0xf0);
            src++;
            dst--;
            count -= 2;
        }
    }
    else
    {
        dst += (count / 2) - 1;

        // ASSERT: count is even.
        while (count)
        {
            *dst = *src;
            *dst = ((*dst & 0xf0) >> 4) | ((*dst & 0x0f) << 4);
            dst--;
            src++;
            count -= 2;
        }
    }
}

VOID _FlipX8bpp(BYTE* dst, const BYTE* src, UINT count)
{
    dst += count;

    while (count--)
        *--dst = *src++;
}

VOID _FlipX16bpp(BYTE* dst, const BYTE* src, UINT count)
{
    WORD* d = (WORD*) dst;
    const WORD* s = (const WORD*) src;

    d += count;

    while (count--)
        *--d = *s++;
}

VOID _FlipX24bpp(BYTE* dst, const BYTE* src, UINT count)
{
    dst += 3 * (count-1);

    while (count--)
    {
        dst[0] = src[0];
        dst[1] = src[1];
        dst[2] = src[2];

        src += 3;
        dst -= 3;
    }
}

VOID _FlipX32bpp(BYTE* dst, const BYTE* src, UINT count)
{
    DWORD* d = (DWORD*) dst;
    const DWORD* s = (const DWORD*) src;

    d += count;

    while (count--)
        *--d = *s++;
}

/**************************************************************************\
*
* Function Description:
*
*   Flip a 48 BPP bitmap horizontally
*
* Arguments:
*
*   dst ----------- Pointer to destination image data
*   src ----------- Pointer to source image data
*   count --------- Number of pixels in a line
*
* Return Value:
*
*   NONE
*
* Revision History:
*
*   10/10/2000 minliu
*       Wrote it.
*
\**************************************************************************/

VOID
_FlipX48bpp(
    BYTE* dst,
    const BYTE* src,
    UINT count
    )
{
    // dst pointer points to the last pixel in the line

    dst += 6 * (count - 1);

    // Loop through each pixel in this line

    while (count--)
    {
        GpMemcpy(dst, src, 6);

        // Each pixel takes 6 bytes. Move to next pixel. src move left to right
        // and dst move right to left

        src += 6;
        dst -= 6;
    }
}// _FlipX48bpp()

/**************************************************************************\
*
* Function Description:
*
*   Flip a 64 BPP bitmap horizontally
*
* Arguments:
*
*   dst ----------- Pointer to destination image data
*   src ----------- Pointer to source image data
*   count --------- Number of pixels in a line
*
* Return Value:
*
*   NONE
*
* Revision History:
*
*   10/10/2000 minliu
*       Wrote it.
*
\**************************************************************************/

VOID
_FlipX64bpp(
    BYTE* dst,
    const BYTE* src,
    UINT count
    )
{
    // dst pointer points to the last pixel in the line
    
    dst += 8 * (count - 1);

    // Loop through each pixel in this line
    
    while (count--)
    {
        GpMemcpy(dst, src, 8);

        // Each pixel takes 8 bytes. Move to next pixel. src move left to right
        // and dst move right to left
        
        src += 8;
        dst -= 8;
    }
}// _FlipX64bpp()

/**************************************************************************\
*
* Function Description:
*
*   Flip the bitmap image in x- and/or y-direction
*
* Arguments:
*
*   flipX - Whether to flip horizontally
*   flipY - Whether to flip vertically
*   outbmp - Returns a pointer to the flipped bitmap image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::Flip(
    IN BOOL flipX,
    IN BOOL flipY,
    OUT IBitmapImage** outbmp
    )
{
    // If no flipping is involved, just call Clone (including the property)

    if ( !flipX && !flipY )
    {
        return this->Clone(NULL, outbmp, TRUE);
    }

    ASSERT(IsValid());

    *outbmp = NULL;

    // Lock the current bitmap object
    // and validate source rectangle

    GpLock lock(&objectLock);
    HRESULT hr;
    GpMemoryBitmap* bmp = NULL;

    if (lock.LockFailed())
    {
        hr = IMGERR_OBJECTBUSY;
    }
    else if ((bmp = new GpMemoryBitmap()) == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = bmp->InitNewBitmap(Width, Height, PixelFormat);

        if (FAILED(hr))
        {
            goto exitFlip;
        }

        UINT pixsize = GetPixelFormatSize(PixelFormat);
        UINT count = Width;
        VOID (*flipxProc)(BYTE*, const BYTE*, UINT);

        if (!flipX)
        {
            count = (Width * pixsize + 7) / 8;
            flipxProc = _FlipXNone;
        }
        else switch (pixsize)
        {
        case 1:
            flipxProc = _FlipX1bpp;
            break;

        case 4:
            flipxProc = _FlipX4bpp;
            break;

        case 8:
            flipxProc = _FlipX8bpp;
            break;

        case 16:
            flipxProc = _FlipX16bpp;
            break;

        case 24:
            flipxProc = _FlipX24bpp;
            break;

        case 32:
            flipxProc = _FlipX32bpp;
            break;

        case 48:
            flipxProc = _FlipX48bpp;
            break;

        case 64:
            flipxProc = _FlipX64bpp;
            break;

        default:
            WARNING(("Flip: pixel format not yet supported"));

            hr = E_NOTIMPL;
            goto exitFlip;
        }

        // Do the flipping

        const BYTE* src = (const BYTE*) this->Scan0;
        BYTE* dst = (BYTE*) bmp->Scan0;
        INT dstinc = bmp->Stride;

        if (flipY)
        {
            dst += (Height - 1) * dstinc;
            dstinc = -dstinc;
        }

        for (UINT y = 0; y < Height; y++ )
        {
            flipxProc(dst, src, count);
            src += this->Stride;
            dst += dstinc;
        }

        // Clone color palettes, flags, etc.

        // Copy DPI info.

        bmp->xdpi = this->xdpi;
        bmp->ydpi = this->ydpi;
        
        hr = bmp->CopyPaletteFlagsEtc(this);
    }

exitFlip:

    if ( SUCCEEDED(hr) )
    {
        *outbmp = bmp;
    }
    else
    {
        delete bmp;
    }

    return hr;
}// Flip()

/**************************************************************************\
*
* Function Description:
*
*   Resize the bitmap image
*
* Arguments:
*
*   newWidth - Specifies the new bitmap width
*   newHeight - Specifies the new bitmap height
*   pixfmt - Specifies the new bitmap pixel format
*   hints - Specifies which interpolation method to use
*   outbmp - Returns a pointer to the resized bitmap image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::Resize(
    IN UINT newWidth,
    IN UINT newHeight,
    IN PixelFormatID pixfmt,
    IN InterpolationHint hints,
    OUT IBitmapImage** outbmp
    )
{
    ASSERT(IsValid());

    *outbmp = NULL;

    // Validate input parameters

    if (newWidth == 0 || newHeight == 0)
        return E_INVALIDARG;

    HRESULT hr;
    GpMemoryBitmap* bmp;

    hr = GpMemoryBitmap::CreateFromImage(
                this,
                newWidth,
                newHeight,
                pixfmt,
                hints,
                &bmp);

    if (SUCCEEDED(hr))
        *outbmp = bmp;
    
    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Functions for rotating bitmap 90 degrees or 270 degrees
*
* Arguments:
*
*   dst - Destination bitmap image data
*   src - Source bitmap image data
*   Sinc - direction to increment the source within a scanline (+1 or -1)
*   sinc - direction and amount to increment the source per scanline
*
*   For a rotation of 90 degrees, src should be set to the beginning of the last
*   scanline, Sinc should be set to +1, and sinc should be set to -Stride of a src scanline.
*
*   For a rotation of 270 degrees, src should be set to the beginning of scanline 0,
*   Sinc should be set to -1, and sinc should be set to +Stride of a src scanline.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

#define _ROTATETMPL(name, T)                                \
                                                            \
VOID                                                        \
name(                                                       \
    BitmapData* dst,                                        \
    const BYTE UNALIGNED* src,                              \
    INT Sinc,                                               \
    INT sinc                                                \
    )                                                       \
{                                                           \
    T* D = (T*) dst->Scan0;                                 \
    const T* S = (const T*) src;                            \
    UINT y = dst->Height;                                   \
    INT Dinc = dst->Stride / sizeof(T);                     \
                                                            \
    sinc /= sizeof(T);                                      \
                                                            \
    if (Sinc < 0)                                           \
        S += (y - 1);                                       \
                                                            \
    while (y--)                                             \
    {                                                       \
        T* d = D;                                           \
        const T* s = S;                                     \
        UINT x = dst->Width;                                \
                                                            \
        while (x--)                                         \
        {                                                   \
            *d++ = *s;                                      \
            s += sinc;                                      \
        }                                                   \
                                                            \
        D += Dinc;                                          \
        S += Sinc;                                          \
    }                                                       \
}

_ROTATETMPL(_Rotate8bpp, BYTE)
_ROTATETMPL(_Rotate16bpp, WORD)
_ROTATETMPL(_Rotate32bpp, DWORD)


VOID
_Rotate1bpp(
    BitmapData* dst,
    const BYTE UNALIGNED* src,
    INT Sinc,
    INT sinc
    )
{

    UINT iAngle = 0;
    BYTE UNALIGNED* dstRowTemp = static_cast<BYTE UNALIGNED*>(dst->Scan0);
    BYTE UNALIGNED* dstColTemp = static_cast<BYTE UNALIGNED*>(dst->Scan0);
    UINT dstY = dst->Height;    // number of destination rows we need to output
    UINT dstX = dst->Width / 8;
    UINT extraDstRowBits = dst->Width % 8;
    UINT dstRow = 0;        // the destination row we are working on
    UINT dstColByte = 0;    // the byte within the destination row we are working on
    BYTE UNALIGNED* topSrc;       // the top of the source bitmap
    INT srcStride = abs(sinc);
    UINT srcRow;    // which source row we are reading
    UINT srcByte;   // which byte within the source row we are reading
    UINT srcBit;    // which bit within the source byte we are reading

    if (Sinc == 1)
    {
        iAngle = 90;
    }
    else
    {
        ASSERT (Sinc == -1);
        iAngle = 270;
    }

    topSrc = const_cast<BYTE UNALIGNED*>(src);
    topSrc = (iAngle == 270) ? topSrc : (topSrc + sinc * ((INT)dst->Width - 1));

    // This code is pretty brute force, but it is fairly simple.
    // We should change the algorithm if performance is a problem.
    // The algorithm is: for each destination byte (starting at the upper
    // left corner of the destination and moving left to right, top to bottom),
    // grab the appropriate bytes from the source.  To avoid accessing memory
    // out of bounds of the source, we need to handle the last x mod 8 bits
    // at the end of the destination row.
    if (iAngle == 90)
    {
        for (dstRow = 0; dstRow < dstY; dstRow++)
        {
            srcByte = dstRow / 8;   // byte within the source row
            srcBit = 7 - (dstRow & 0x07);     // which source bit we need to mask
            for (dstColByte = 0; dstColByte < dstX; dstColByte++)
            {
                srcRow = (dst->Width - 1) - (dstColByte * 8);   // the first source row corresponding to the dest byte
                *dstColTemp =
                    (((topSrc[(srcRow - 0) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 7) |
                    (((topSrc[(srcRow - 1) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 6) |
                    (((topSrc[(srcRow - 2) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 5) |
                    (((topSrc[(srcRow - 3) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 4) |
                    (((topSrc[(srcRow - 4) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 3) |
                    (((topSrc[(srcRow - 5) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 2) |
                    (((topSrc[(srcRow - 6) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 1) |
                    (((topSrc[(srcRow - 7) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 0)
                    ;
                dstColTemp++;
            }
            // Handle the last few bits on the row
            // ASSERT: dstColTemp is pointing to the last byte on the destination row
            if (extraDstRowBits)
            {
                UINT extraBit;
                *dstColTemp = 0;
                srcRow = (dst->Width - 1) - (dstColByte * 8);    // the first source row corresponding to the dest byte
                for (extraBit = 0 ; extraBit < extraDstRowBits; extraBit++)
                {
                    *dstColTemp |=
                        (((topSrc[(srcRow - extraBit) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << (7 - extraBit))
                        ;
                }
            }
            dstRowTemp += dst->Stride;
            dstColTemp = dstRowTemp;
        }
    }
    else
    {
        ASSERT (iAngle == 270);
        for (dstRow = 0; dstRow < dstY; dstRow++)
        {
            srcByte =  ((dstY - 1) - dstRow) / 8;   // byte within the source row
            srcBit = 7 - (((dstY - 1) - dstRow) & 0x07);    // which source bit we need to mask
            for (dstColByte = 0; dstColByte < dstX; dstColByte++)
            {
                srcRow = dstColByte * 8;    // the first source row corresponding to the dest byte
                *dstColTemp =
                    (((topSrc[(srcRow + 0) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 7) |
                    (((topSrc[(srcRow + 1) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 6) |
                    (((topSrc[(srcRow + 2) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 5) |
                    (((topSrc[(srcRow + 3) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 4) |
                    (((topSrc[(srcRow + 4) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 3) |
                    (((topSrc[(srcRow + 5) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 2) |
                    (((topSrc[(srcRow + 6) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 1) |
                    (((topSrc[(srcRow + 7) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 0)
                    ;
                dstColTemp++;
            }
            // Handle the last few bits on the row
            // ASSERT: dstColTemp is pointing to the last byte on the destination row
            if (extraDstRowBits)
            {
                UINT extraBit;
                *dstColTemp = 0;
                srcRow = dstColByte * 8;    // the first source row corresponding to the dest byte
                for (extraBit = 0 ; extraBit < extraDstRowBits; extraBit++)
                {
                    *dstColTemp |=
                        (((topSrc[(srcRow + extraBit) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << (7 - extraBit))
                        ;
                }
            }
            dstRowTemp += dst->Stride;
            dstColTemp = dstRowTemp;
        }
    }

}


VOID
_Rotate4bpp(
    BitmapData* dst,
    const BYTE UNALIGNED* src,
    INT Sinc,
    INT sinc
    )
{
    const BYTE* tempSrc;
    BYTE UNALIGNED* Dst;
    UINT dstY = dst->Height;
    UINT dstX;  // used to hold the current pixel of the dst;
    BOOL bOddPixelsInScanline = (dstY % 2);
    UINT iAngle = (Sinc > 0) ? 90 : 270;

    // if the number of pixels in a src scanline is odd, handle the last
    // src nibble separately.
    if (bOddPixelsInScanline)
    {
        tempSrc = src + (dstY / 2);  // point to the byte that contains the "odd" nibble.

        Dst = (BYTE UNALIGNED*) dst->Scan0;
        if (iAngle == 90)
        {
            Dst += (((INT)dstY - 1) * dst->Stride);
        }

        // ASSERT: 
        // if we process src pixels backwards in the scanline (i.e., we are
        // rotating 270 degrees), then dst points to the first scanline.
        // if we process src pixels forwards in the scanline (i.e., we are
        // rotating 90 degrees), then dst points to the last scanline.

        dstX = dst->Width;
        while (dstX)
        {
            // take the high order nibble of the Src and deposit it
            // into the high order nibble of the Dst
            *Dst = *tempSrc & 0xf0;
            tempSrc += sinc;
            dstX--;
            if (!dstX)
                break;

            // take the high order nibble of the Src and deposit it
            // into the low order nibble of the Dst
            *Dst |= (*tempSrc & 0xf0) >> 4;
            tempSrc += sinc;
            dstX--;

            Dst++;
        }
        dstY--;
    }

    tempSrc = src;
    Dst = (BYTE UNALIGNED*) dst->Scan0;

    // start at the end of src scanline if the angle is 270,
    // excluding the last nibble if dstY is odd.
    // Also, if we have an odd number of pixels in a src scanline, start Dst
    // at the second scanline, since the first dst scanline was handled above.
    if (iAngle == 270)
    {
        tempSrc = src + (dstY / 2) - 1;
        if (bOddPixelsInScanline)
        {
            Dst += dst->Stride;
        }
    }

    // Handle the rest of the scanlines.  The following code is pretty brute force.
    // It handles 90 degrees and 270 degrees separately, because in the 90 degree
    // case, we need to process the high src nibbles within a src byte first, whereas
    // in the 270 case, we need to process the low nibbles first.
    if (iAngle == 90)
    {
        while (dstY)
        {
            BYTE* d = Dst;
            const BYTE* s = tempSrc;
            dstX = dst->Width;        

            while (dstX)
            {
                // take the high order nibble of the Src and deposit it
                // into the high order nibble of the Dst
                *d = *s & 0xf0;
                s += sinc;
                dstX--;
                if (!dstX)
                    break;
            
                // take the high order nibble of the Src and deposit it
                // into the low order nibble of the Dst
                *d |= (*s & 0xf0) >> 4;
                s += sinc;
                dstX--;

                d++;
            }
            dstY--;
            if (!dstY)
                break;

            Dst += dst->Stride;
            d = Dst;
            s = tempSrc;
            dstX = dst->Width;        

            while (dstX)
            {
                // take the low order nibble of the Src and deposit it
                // into the high order nibble of the Dst
                *d = (*s & 0x0f) << 4;
                s += sinc;
                dstX--;
                if (!dstX)
                    break;
            
                // take the low order nibble of the Src and deposit it
                // into the low order nibble of the Dst
                *d |= *s & 0x0f;
                s += sinc;
                dstX--;

                d++;
            }
            dstY--;

            Dst += dst->Stride;
            tempSrc += Sinc;
        }
    }
    else
    {
        // ASSERT: iAngle == 270
        while (dstY)
        {
            BYTE* d = Dst;
            const BYTE* s = tempSrc;
            dstX = dst->Width;        

            while (dstX)
            {
                // take the low order nibble of the Src and deposit it
                // into the high order nibble of the Dst
                *d = (*s & 0x0f) << 4;
                s += sinc;
                dstX--;
                if (!dstX)
                    break;
            
                // take the low order nibble of the Src and deposit it
                // into the low order nibble of the Dst
                *d |= *s & 0x0f;
                s += sinc;
                dstX--;

                d++;
            }
            dstY--;
            if (!dstY)
                break;

            Dst += dst->Stride;
            d = Dst;
            s = tempSrc;
            dstX = dst->Width;        

            while (dstX)
            {
                // take the high order nibble of the Src and deposit it
                // into the high order nibble of the Dst
                *d = *s & 0xf0;
                s += sinc;
                dstX--;
                if (!dstX)
                    break;
            
                // take the high order nibble of the Src and deposit it
                // into the low order nibble of the Dst
                *d |= (*s & 0xf0) >> 4;
                s += sinc;
                dstX--;

                d++;
            }
            dstY--;

            Dst += dst->Stride;
            tempSrc += Sinc;
        }

    }
}


VOID
_Rotate24bpp(
    BitmapData* dst,
    const BYTE UNALIGNED* S,
    INT Sinc,
    INT sinc
    )
{
    BYTE UNALIGNED* D = (BYTE UNALIGNED*) dst->Scan0;
    UINT y = dst->Height;

    // start at the end of src scanline if direction is -1 within a scanline
    if (Sinc < 0)
        S += 3 * (y - 1);

    Sinc *= 3;

    while (y--)
    {
        BYTE* d = D;
        const BYTE UNALIGNED* s = S;
        UINT x = dst->Width;

        while (x--)
        {
            d[0] = s[0];
            d[1] = s[1];
            d[2] = s[2];

            d += 3;
            s += sinc;
        }

        D += dst->Stride;
        S += Sinc;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Functions for rotating a 48 BPP bitmap 90 degrees or 270 degrees
*
* Arguments:
*
*   dstBmp  ----------- Destination bitmap image data
*   srcData ----------- Source bitmap image data
*   iLineIncDirection - Direction to increment the source (+1 or -1)
*   iSrcStride -------- Direction and amount to increment the source per
*                       scanline. If the stride is negative, it means we are
*                       moving bottom up
*
*   Note to caller:
*       For a rotation of 90 degrees, "srcData" should be set to the beginning
*   of the last scanline, "iLineIncDirection" should be set to +1, and
*   "iSrcStride" should be set to -Stride of a src scanline.
*
*   For a rotation of 270 degrees, "srcData" should be set to the beginning of
*   scanline 0, "iLineIncDirection" should be set to -1, and "iSrcStride" should
*   be set to +Stride of a src scanline.
*
* Return Value:
*
*   NONE
*
* Revision History:
*
*   10/10/2000 minliu
*       Wrote it.
*
\**************************************************************************/

VOID
_Rotate48bpp(
    BitmapData* dstBmp,
    const BYTE UNALIGNED* srcData,
    INT         iLineIncDirection,
    INT         iSrcStride
    )
{
    UINT        uiCurrentLine = dstBmp->Height;
    const BYTE UNALIGNED* pSrcData = srcData;

    // Start at the end of src scanline if direction is < 0 (rotate 270)

    if ( iLineIncDirection < 0 )
    {
        pSrcData += 6 * (uiCurrentLine - 1);
    }

    iLineIncDirection *= 6;     // 6 bytes for each 48 bpp pixel

    BYTE*       pDstLine = (BYTE UNALIGNED*)dstBmp->Scan0;
    
    // Rotate line by line

    while ( uiCurrentLine-- )
    {
        BYTE* dstPixel = pDstLine;
        const BYTE UNALIGNED* srcPixel = pSrcData;
        UINT x = dstBmp->Width;

        // Move one pixel at a time horizontally

        while ( x-- )
        {
            // Copy 6 bytes from source to dest

            GpMemcpy(dstPixel, srcPixel, 6);

            // Move dst one pixel to the next (6 bytes)

            dstPixel += 6;

            // Move src pointer to the next line

            srcPixel += iSrcStride;
        }

        // Move dest to the next line

        pDstLine += dstBmp->Stride;

        // Move src to one pixel to the right (rotate 90) or to the left (270)

        pSrcData += iLineIncDirection;
    }
}// _Rotate48bpp()

/**************************************************************************\
*
* Function Description:
*
*   Functions for rotating a 64 BPP bitmap 90 degrees or 270 degrees
*
* Arguments:
*
*   dstBmp  ----------- Destination bitmap image data
*   srcData ----------- Source bitmap image data
*   iLineIncDirection - Direction to increment the source (+1 or -1)
*   iSrcStride -------- Direction and amount to increment the source per
*                       scanline. If the stride is negative, it means we are
*                       moving bottom up
*
*   Note to caller:
*       For a rotation of 90 degrees, "srcData" should be set to the beginning
*   of the last scanline, "iLineIncDirection" should be set to +1, and
*   "iSrcStride" should be set to -Stride of a src scanline.
*
*   For a rotation of 270 degrees, "srcData" should be set to the beginning of
*   scanline 0, "iLineIncDirection" should be set to -1, and "iSrcStride" should
*   be set to +Stride of a src scanline.
*
* Return Value:
*
*   NONE
*
* Revision History:
*
*   10/10/2000 minliu
*       Wrote it.
*
\**************************************************************************/

VOID
_Rotate64bpp(
    BitmapData* dstBmp,
    const BYTE UNALIGNED* srcData,
    INT         iLineIncDirection,
    INT         iSrcStride
    )
{
    UINT        uiCurrentLine = dstBmp->Height;
    const BYTE UNALIGNED* pSrcData = srcData;

    // Start at the end of src scanline if direction is < 0, (rotate 270)

    if ( iLineIncDirection < 0 )
    {
        pSrcData += 8 * (uiCurrentLine - 1);
    }

    iLineIncDirection *= 8;     // 8 bytes for each 64 bpp pixel

    BYTE UNALIGNED* pDstLine = (BYTE UNALIGNED*)dstBmp->Scan0;
    
    // Rotate line by line

    while ( uiCurrentLine-- )
    {
        BYTE* dstPixel = pDstLine;
        const BYTE UNALIGNED* srcPixel = pSrcData;
        UINT x = dstBmp->Width;

        // Move one pixel at a time horizontally

        while ( x-- )
        {
            // Copy 8 bytes from source to dest

            GpMemcpy(dstPixel, srcPixel, 8);

            // Move dst one pixel to the next (8 bytes)

            dstPixel += 8;

            // Move src pointer to the next line

            srcPixel += iSrcStride;
        }

        // Move dest to the next line

        pDstLine += dstBmp->Stride;
        
        // Move src to one pixel to the right (rotate 90) or to the left (270)

        pSrcData += iLineIncDirection;
    }
}// _Rotate64bpp()

/**************************************************************************\
*
* Function Description:
*
*   Rotate the bitmap image by the specified angle
*
* Arguments:
*
*   angle - Specifies the rotation angle, in degrees
*   hints - Specifies which interpolation method to use
*   outbmp - Returns a pointer to the rotated bitmap image
*
* Return Value:
*
*   Status code
*
* Notes:
*
*   Currently we only support 90-degree rotations.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::Rotate(
    IN FLOAT angle,
    IN InterpolationHint hints,
    OUT IBitmapImage** outbmp
    )
{
    // Get the integer angle

    INT iAngle = (INT) angle;

    iAngle %= 360;

    if ( iAngle < 0 )
    {
        iAngle += 360;
    }

    switch (iAngle)
    {
    case 0:
    case 360:
        return this->Clone(NULL, outbmp, TRUE);
        break;

    case 180:
        return this->Flip(TRUE, TRUE, outbmp);
        break;

    case 90:
    case 270:
        break;
    
    default:
        return E_NOTIMPL;
    }

    // Lock the current bitmap image
    // and create the new bitmap image

    ASSERT(IsValid());

    *outbmp = NULL;

    GpLock lock(&objectLock);
    HRESULT hr;
    GpMemoryBitmap* bmp = NULL;

    if ( lock.LockFailed() )
    {
        hr = IMGERR_OBJECTBUSY;
    }
    else if ((bmp = new GpMemoryBitmap()) == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = bmp->InitNewBitmap(Height, Width, PixelFormat);

        if (FAILED(hr))
        {
            goto exitRotate;
        }

        ASSERT(bmp->Width == this->Height &&
               bmp->Height == this->Width);

        VOID (*rotateProc)(BitmapData*, const BYTE UNALIGNED*, INT, INT);

        switch (GetPixelFormatSize(PixelFormat))
        {
        case 1:
            rotateProc = _Rotate1bpp;
            break;

        case 4:
            rotateProc = _Rotate4bpp;
            break;

        case 8:
            rotateProc = _Rotate8bpp;
            break;

        case 16:
            rotateProc = _Rotate16bpp;
            break;

        case 24:
            rotateProc = _Rotate24bpp;
            break;

        case 32:
            rotateProc = _Rotate32bpp;
            break;

        case 48:
            rotateProc = _Rotate48bpp;
            break;

        case 64:
            rotateProc = _Rotate64bpp;
            break;

        default:

            WARNING(("Rotate: pixel format not yet supported"));
            
            hr = E_NOTIMPL;
            goto exitRotate;
        }

        // Do the rotation

        const BYTE UNALIGNED* src = (const BYTE UNALIGNED*) this->Scan0;
        INT sinc = this->Stride;
        INT Sinc;

        if ( iAngle == 90 )
        {
            // clockwise
            
            src += sinc * ((INT)this->Height - 1);
            Sinc = 1;
            sinc = -sinc;
        }
        else
        {
            Sinc = -1;
        }

        rotateProc(bmp, src, Sinc, sinc);

        // Copy DPI info.
        // Note: when the code falls here, we know it is either 90 or -90 degree
        // rotation. So the DPI value should be swapped

        bmp->xdpi = this->ydpi;
        bmp->ydpi = this->xdpi;

        // Clone color palettes, flags, etc.

        hr = bmp->CopyPaletteFlagsEtc(this);
    }

exitRotate:

    if ( SUCCEEDED(hr) )
    {
        *outbmp = bmp;
    }
    else
    {
        delete bmp;
    }

    return hr;
}// Rotate()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\codecmgr.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   codecmgr.cpp
*
* Abstract:
*
*   Image codec management functions
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "codecmgr.hpp"

extern BOOL SuppressExternalCodecs;

//
// Various data structures for maintaining the cache of codecs
//

static DWORD LastCheckRegTime;      // when was registry last checked
static DWORD SystemRegCookie;       // cookie value in the system hive
static DWORD UserRegCookie;         // cookie value in the user hive
static DWORD MaxSigSize;            // max signature size for all decoders
BOOL CodecCacheUpdated;      // whether codec cache was updated
CachedCodecInfo* CachedCodecs;      // cached list of codecs

// How frequently we recheck the registry: at most every 30 seconds

#define CHECKREG_INTERVAL 30000

// The root registry key under which we keep information
//  under either HKLM or HKCU

#define REGSTR_CODECROOT \
        L"Software\\Microsoft\\Imaging\\Codecs"

// Last update cookie value

#define REGSTR_LASTCOOKIE           L"_LastCookie"

// Registry value entries for each installed codec

#define REGSTR_CODEC_INFOSIZE       L"_InfoSize"
#define REGSTR_CODEC_CLSID          L"CLSID"
#define REGSTR_CODEC_DLLNAME        L"DLLNAME"
#define REGSTR_CODEC_FORMATID       L"Format ID"
#define REGSTR_CODEC_FORMATDESC     L"File Type Description"
#define REGSTR_CODEC_FILENAMEEXT    L"Filename Extension"
#define REGSTR_CODEC_MIMETYPE       L"MIME Type"
#define REGSTR_CODEC_VERSION        L"Version"
#define REGSTR_CODEC_FLAGS          L"Flags"
#define REGSTR_CODEC_SIGCOUNT       L"Signature Count"
#define REGSTR_CODEC_SIGSIZE        L"Signature Size"
#define REGSTR_CODEC_SIGPATTERN     L"Signature Pattern"
#define REGSTR_CODEC_SIGMASK        L"Signature Mask"

// Insert a new node into the head of cached codec info list

inline VOID
InsertCachedCodecInfo(
    CachedCodecInfo* info
    )
{
    info->prev = NULL;
    info->next = CachedCodecs;

    if (CachedCodecs)
        CachedCodecs->prev = info;

    CachedCodecs = info;
    CodecCacheUpdated = TRUE;
}

// Delete a list from the cached codec info list

inline VOID
DeleteCachedCodecInfo(
    CachedCodecInfo* info
    )
{
    CachedCodecInfo* next = info->next;

    if (info == CachedCodecs)
        CachedCodecs = next;

    if (next)
        next->prev = info->prev;

    if (info->prev)
        info->prev->next = next;

    GpFree(info);
    CodecCacheUpdated = TRUE;
}

// Force a reload of cached codec information from registry

inline VOID
ForceReloadCachedCodecInfo()
{
    LastCheckRegTime = GetTickCount() - CHECKREG_INTERVAL;
}

// Doing a blocking read on a stream

inline HRESULT
BlockingReadStream(
    IStream* stream,
    VOID* buf,
    UINT size,
    UINT* bytesRead
    )
{
    HRESULT hr = S_OK;
    ULONG n;

    *bytesRead = 0;

    while (size)
    {
        n = 0;
        hr = stream->Read(buf, size, &n);
        *bytesRead += n;

        if (hr != E_PENDING)
            break;

        size -= n;
        buf = (BYTE*) buf + n;
        Sleep(0);
    }

    return hr;
}

// Doing a blocking relative seek on a stream

inline HRESULT
BlockingSeekStreamCur(
    IStream* stream,
    INT offset,
    ULARGE_INTEGER* pos
    )
{
    HRESULT hr;
    LARGE_INTEGER move;

    move.QuadPart = offset;

    for (;;)
    {
        hr = stream->Seek(move, STREAM_SEEK_CUR, pos);

        if (hr != E_PENDING)
            return hr;

        Sleep(0);
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Free cached information about codecs
*
* Arguments:
*
*   classFlags - Which classes of codecs are affected
*       built-in
*       system-wide
*       per-user
*
* Return Value:
*
*   NONE
*
* Notes:
*
*   We assume the caller has already taken care of
*   the imaging critical section here.
*
\**************************************************************************/

VOID
FreeCachedCodecInfo(
    UINT classFlags
    )
{
    CachedCodecInfo* cur = CachedCodecs;

    // Loop through the list of cached codecs

    while (cur != NULL)
    {
        CachedCodecInfo* next = cur->next;

        // Free the current node

        if (cur->Flags & classFlags)
            DeleteCachedCodecInfo(cur);

        // Move on to the next node

        cur = next;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Initialize cached information about built-in codecs
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

// BMP file header signature information

#include "bmp\bmpcodec.hpp"

#define BMPVERSION  1
#define BMPSIGCOUNT 1
#define BMPSIGSIZE  2

// The BMP signature is taken from the BITMAPFILEHEADER structure.
// Initially I set the signature to require zeros for the bfReserved1
// and bfReserved2 fields.  However, there exist BMP files with non-zero
// values in these fields and so the signature now only looks for the "BM"
// characters in the bfType field.

const BYTE BMPHeaderPattern[BMPSIGCOUNT*BMPSIGSIZE] =
{
    0x42, 0x4D        // bfType = 'BM'
};

const BYTE BMPHeaderMask[BMPSIGCOUNT*BMPSIGSIZE] =
{
    0xff, 0xff
};

const CLSID BmpCodecClsID =
{
    0x557cf400,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

// Create an instance of BMP codec object

HRESULT CreateBmpCodecInstance(REFIID iid, VOID** codec)
{
    HRESULT hr;
    GpBmpCodec *bmpCodec = new GpBmpCodec();

    if (bmpCodec != NULL)
    {
        hr = bmpCodec->QueryInterface(iid, codec);
        bmpCodec->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *codec = NULL;
    }

    return hr;
}

// JPEG file header signature information

#include "jpeg\jpgcodec.hpp"

#define JPEGVERSION     1
#define JPEGSIGCOUNT    1
#define JPEGSIGSIZE     2

const BYTE JPEGHeaderPattern[JPEGSIGCOUNT*JPEGSIGSIZE] =
{
    0xff, 0xd8
};

const BYTE JPEGHeaderMask[JPEGSIGCOUNT*JPEGSIGSIZE] =
{
    0xff, 0xff
};

const CLSID JpegCodecClsID =
{
    0x557cf401,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

// Create an instance of JPG codec object

HRESULT CreateJpegCodecInstance(REFIID iid, VOID** codec)
{
    HRESULT hr;
    GpJpegCodec *jpegCodec = new GpJpegCodec();

    if (jpegCodec != NULL)
    {
        hr = jpegCodec->QueryInterface(iid, codec);
        jpegCodec->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *codec = NULL;
    }

    return hr;
}

#ifndef _BUILD_EXTERNAL_GIF

// GIF file header signature information

#include "gif\gifcodec.hpp"
#include "gif\gifconst.cpp"

// Create an instance of GIF codec object

HRESULT CreateGifCodecInstance(REFIID iid, VOID** codec)
{
    HRESULT hr;
    GpGifCodec *gifCodec = new GpGifCodec();

    if (gifCodec != NULL)
    {
        hr = gifCodec->QueryInterface(iid, codec);
        gifCodec->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *codec = NULL;
    }

    return hr;
}

#endif // !_BUILD_EXTERNAL_GIF

// EMF file header signature information

#include "emf\emfcodec.hpp"

#define EMFVERSION  1
#define EMFSIGCOUNT 1
#define EMFSIGSIZE  44

const BYTE EMFHeaderPattern[EMFSIGCOUNT*EMFSIGSIZE] =
{
    0, 0, 0, 0,  // iType

    0, 0, 0, 0,  // nSize

    0, 0, 0, 0,  // rclBounds
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,

    0, 0, 0, 0,  // rclFrame
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,

    0x20, 0x45, 0x4D, 0x46 // dSignature = ENHMETA_SIGNATURE
};

const BYTE EMFHeaderMask[EMFSIGCOUNT*EMFSIGSIZE] =
{
    0, 0, 0, 0,  // iType

    0, 0, 0, 0,  // nSize

    0, 0, 0, 0,  // rclBounds
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,

    0, 0, 0, 0,  // rclFrame
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,

    0xff, 0xff, 0xff, 0xff // dSignature
};

const CLSID EMFCodecClsID =
{
    0x557cf403,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

// Create an instance of EMF codec object

HRESULT CreateEMFCodecInstance(REFIID iid, VOID** codec)
{
    // We should never use the EMF codecs. The Metafile object is the proper
    // to create a metafile so always fail this call

    *codec = NULL;
    return E_FAIL;
}


// WMF file header signature information

#include "wmf\wmfcodec.hpp"

#define WMFVERSION  1
#define WMFSIGCOUNT 1
#define WMFSIGSIZE  4

const BYTE WMFHeaderPattern[WMFSIGCOUNT*WMFSIGSIZE] =
{
    0xD7, 0xCD, 0xC6, 0x9A
};

const BYTE WMFHeaderMask[WMFSIGCOUNT*WMFSIGSIZE] =
{
    0xff, 0xff, 0xff, 0xff
};

const CLSID WMFCodecClsID =
{
    0x557cf404,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

// Create an instance of WMF codec object

HRESULT CreateWMFCodecInstance(REFIID iid, VOID** codec)
{
    // We should never use the EMF codecs. The Metafile object is the proper
    // to create a metafile so always fail this call

    *codec = NULL;
    return E_FAIL;
}

// TIFF file header signature information

#include "off_tiff\tiffcodec.hpp"

#define TIFFVERSION     1
#define TIFFSIGCOUNT    2
#define TIFFSIGSIZE     2

const BYTE TIFFHeaderPattern[TIFFSIGCOUNT * TIFFSIGSIZE] =
{
    0x49, 0x49,       // bfType = '0x4949H' little endian
    0x4D, 0x4D        // bfType = '0x4D4DH' big endian
};

const BYTE TIFFHeaderMask[TIFFSIGCOUNT * TIFFSIGSIZE] =
{
    0xff, 0xff,
    0xff, 0xff
};

const CLSID TiffCodecClsID =
{
    0x557cf405,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

// Create an instance of TIFF codec object

HRESULT CreateTiffCodecInstance(REFIID iid, VOID** codec)
{
    HRESULT hr;
    GpTiffCodec *tiffCodec = new GpTiffCodec();

    if ( tiffCodec != NULL )
    {
        hr = tiffCodec->QueryInterface(iid, codec);
        tiffCodec->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *codec = NULL;
    }

    return hr;
}

// PNG file header signature information

#include "png\pngcodec.hpp"

#define PNGVERSION  1
#define PNGSIGCOUNT 1
#define PNGSIGSIZE  8

const BYTE PNGHeaderPattern[PNGSIGCOUNT*PNGSIGSIZE] =
{
    137, 80, 78, 71, 13, 10, 26, 10
};

const BYTE PNGHeaderMask[PNGSIGCOUNT*PNGSIGSIZE] =
{
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

const CLSID PngCodecClsID =
{
    0x557cf406,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

// Create an instance of PNG codec object

HRESULT CreatePngCodecInstance(REFIID iid, VOID** codec)
{
    HRESULT hr;
    GpPngCodec *pngCodec = new GpPngCodec();

    if (pngCodec != NULL)
    {
        hr = pngCodec->QueryInterface(iid, codec);
        pngCodec->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *codec = NULL;
    }

    return hr;
}


// ICO (icon) file header signature information

#include "ico\icocodec.hpp"

#define ICOVERSION  1
#define ICOSIGCOUNT 1
#define ICOSIGSIZE  4

const BYTE ICOHeaderPattern[ICOSIGCOUNT*ICOSIGSIZE] =
{
    0, 0, 1, 0
};

const BYTE ICOHeaderMask[ICOSIGCOUNT*ICOSIGSIZE] =
{
    0xff, 0xff, 0xff, 0xff
};

const CLSID IcoCodecClsID =
{
    0x557cf407,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

// Create an instance of ICO codec object

HRESULT CreateIcoCodecInstance(REFIID iid, VOID** codec)
{
    HRESULT hr;
    GpIcoCodec *icoCodec = new GpIcoCodec();

    if (icoCodec != NULL)
    {
        hr = icoCodec->QueryInterface(iid, codec);
        icoCodec->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *codec = NULL;
    }

    return hr;
}


//!!!TODO: Office cannot use resource strings, so built-in codecs will
//!!!      have hardcoded strings for now.  Need to figure out how to
//!!!      make these localizable (maybe hardcoded for gdipstat.lib,
//!!!      resource strings for gdiplus.dll?).
//#define USE_RESOURCE_STRINGS

struct
{
    const GUID* Clsid;
    const GUID* FormatID;
    #if defined(USE_RESOURCE_STRINGS)
        INT CodecNameId;
        INT FormatDescriptionId;
        INT FilenameExtensionId;
        INT MimeTypeId;
    #else
        WCHAR *CodecNameStr;
        WCHAR *FormatDescriptionStr;
        WCHAR *FilenameExtensionStr;
        WCHAR *MimeTypeStr;
    #endif
    DWORD Version;
    DWORD Flags;
    DWORD SigCount;
    DWORD SigSize;
    const BYTE* SigPattern;
    const BYTE* SigMask;
    CreateCodecInstanceProc creationProc;
}
const BuiltinCodecs[] =
{
    // Built-in BMP encoder / decoder

    {
        &BmpCodecClsID,
        &IMGFMT_BMP,

        #if defined(USE_RESOURCE_STRINGS)
            IDS_BMP_CODECNAME,
            IDS_BMP_FORMATDESC,
            IDS_BMP_FILENAMEEXT,
            IDS_BMP_MIMETYPE,
        #else
            L"Built-in BMP Codec",
            L"BMP",
            L"*.BMP;*.DIB;*.RLE",
            L"image/bmp",
        #endif
        BMPVERSION,
        IMGCODEC_ENCODER |
            IMGCODEC_DECODER |
            IMGCODEC_SUPPORT_BITMAP,
        BMPSIGCOUNT,
        BMPSIGSIZE,
        BMPHeaderPattern,
        BMPHeaderMask,
        CreateBmpCodecInstance
    },

    // Built-in JPEG encoder / decoder

    {
        &JpegCodecClsID,
        &IMGFMT_JPEG,

        #if defined(USE_RESOURCE_STRINGS)
            IDS_JPEG_CODECNAME,
            IDS_JPEG_FORMATDESC,
            IDS_JPEG_FILENAMEEXT,
            IDS_JPEG_MIMETYPE,
        #else
            L"Built-in JPEG Codec",
            L"JPEG",
            L"*.JPG;*.JPEG;*.JPE;*.JFIF",
            L"image/jpeg",
        #endif
        JPEGVERSION,
        IMGCODEC_ENCODER |
            IMGCODEC_DECODER |
            IMGCODEC_SUPPORT_BITMAP,
        JPEGSIGCOUNT,
        JPEGSIGSIZE,
        JPEGHeaderPattern,
        JPEGHeaderMask,
        CreateJpegCodecInstance
    },

    #ifndef _BUILD_EXTERNAL_GIF

    // Built-in GIF encoder / decoder

    {
        &GifCodecClsID,
        &IMGFMT_GIF,

        #if defined(USE_RESOURCE_STRINGS)
            IDS_GIF_CODECNAME,
            IDS_GIF_FORMATDESC,
            IDS_GIF_FILENAMEEXT,
            IDS_GIF_MIMETYPE,
        #else
            L"Built-in GIF Codec",
            L"GIF",
            L"*.GIF",
            L"image/gif",
        #endif
        GIFVERSION,
        IMGCODEC_ENCODER |
            IMGCODEC_DECODER |
            IMGCODEC_SUPPORT_BITMAP,
        GIFSIGCOUNT,
        GIFSIGSIZE,
        GIFHeaderPattern,
        GIFHeaderMask,
        CreateGifCodecInstance
    },

    #endif // !_BUILD_EXTERNAL_GIF

    // Built-in EMF encoder / decoder

    {
        &EMFCodecClsID,
        &IMGFMT_EMF,

        #if defined(USE_RESOURCE_STRINGS)
            IDS_EMF_CODECNAME,
            IDS_EMF_FORMATDESC,
            IDS_EMF_FILENAMEEXT,
            IDS_EMF_MIMETYPE,
        #else
            L"Built-in EMF Codec",
            L"EMF",
            L"*.EMF",
            L"image/x-emf",
        #endif
        EMFVERSION,
        IMGCODEC_DECODER |
            IMGCODEC_SUPPORT_BITMAP,
        EMFSIGCOUNT,
        EMFSIGSIZE,
        EMFHeaderPattern,
        EMFHeaderMask,
        CreateEMFCodecInstance
    },

    // Built-in WMF encoder / decoder

    {
        &WMFCodecClsID,
        &IMGFMT_WMF,

        #if defined(USE_RESOURCE_STRINGS)
            IDS_WMF_CODECNAME,
            IDS_WMF_FORMATDESC,
            IDS_WMF_FILENAMEEXT,
            IDS_WMF_MIMETYPE,
        #else
            L"Built-in WMF Codec",
            L"WMF",
            L"*.WMF",
            L"image/x-wmf",
        #endif
        WMFVERSION,
        IMGCODEC_DECODER |
            IMGCODEC_SUPPORT_BITMAP,
        WMFSIGCOUNT,
        WMFSIGSIZE,
        WMFHeaderPattern,
        WMFHeaderMask,
        CreateWMFCodecInstance
    },

    // Built-in TIFF encoder / decoder

    {
        &TiffCodecClsID,
        &IMGFMT_TIFF,

        #if defined(USE_RESOURCE_STRINGS)
            IDS_TIFF_CODECNAME,
            IDS_TIFF_FORMATDESC,
            IDS_TIFF_FILENAMEEXT,
            IDS_TIFF_MIMETYPE,
        #else
            L"Built-in TIFF Codec",
            L"TIFF",
            L"*.TIF;*.TIFF",
            L"image/tiff",
        #endif
        TIFFVERSION,
        IMGCODEC_ENCODER |
            IMGCODEC_DECODER |
            IMGCODEC_SUPPORT_BITMAP,
        TIFFSIGCOUNT,
        TIFFSIGSIZE,
        TIFFHeaderPattern,
        TIFFHeaderMask,
        CreateTiffCodecInstance
    },

    // Built-in PNG encoder / decoder

    {
        &PngCodecClsID,
        &IMGFMT_PNG,

        #if defined(USE_RESOURCE_STRINGS)
            IDS_PNG_CODECNAME,
            IDS_PNG_FORMATDESC,
            IDS_PNG_FILENAMEEXT,
            IDS_PNG_MIMETYPE,
        #else
            L"Built-in PNG Codec",
            L"PNG",
            L"*.PNG",
            L"image/png",
        #endif
        PNGVERSION,
        IMGCODEC_ENCODER |
            IMGCODEC_DECODER |
            IMGCODEC_SUPPORT_BITMAP,
        PNGSIGCOUNT,
        PNGSIGSIZE,
        PNGHeaderPattern,
        PNGHeaderMask,
        CreatePngCodecInstance
    },

    // Built-in ICO decoder

    {
        &IcoCodecClsID,
        &IMGFMT_ICO,

        #if defined(USE_RESOURCE_STRINGS)
            IDS_ICO_CODECNAME,
            IDS_ICO_FORMATDESC,
            IDS_ICO_FILENAMEEXT,
            IDS_ICO_MIMETYPE,
        #else
            L"Built-in ICO Codec",
            L"ICO",
            L"*.ICO",
            L"image/x-icon",
        #endif
        ICOVERSION,
        IMGCODEC_DECODER |
            IMGCODEC_SUPPORT_BITMAP,
        ICOSIGCOUNT,
        ICOSIGSIZE,
        ICOHeaderPattern,
        ICOHeaderMask,
        CreateIcoCodecInstance
    }

};

#if defined(USE_RESOURCE_STRINGS)
    #define LOADRSRCSTR(_f)                             \
            WCHAR _f##Str[MAX_PATH];                    \
            INT _f##Len;                                \
            _f##Len = _LoadString(                      \
                        DllInstance,                    \
                        BuiltinCodecs[index]._f##Id,    \
                        _f##Str,                        \
                        MAX_PATH);                      \
            if (_f##Len <= 0) continue;                 \
            _f##Len = (_f##Len + 1) * sizeof(WCHAR)
#else
    #define LOADRSRCSTR(_f)                                         \
            WCHAR _f##Str[MAX_PATH];                                \
            INT _f##Len;                                            \
            _f##Len = UnicodeStringLength(BuiltinCodecs[index]._f##Str);         \
            if (_f##Len <= 0) continue;                             \
            _f##Len = (_f##Len + 1) * sizeof(WCHAR);                \
            memcpy(_f##Str, BuiltinCodecs[index]._f##Str, _f##Len)
#endif

#define COPYRSRCSTR(_f)                             \
        cur->_f = (const WCHAR*) buf;               \
        memcpy(buf, _f##Str, _f##Len);              \
        buf += _f##Len

VOID
InitializeBuiltinCodecs()
{
    TRACE(("Entering InitializeBuiltinCodecs...\n"));

    INT index = sizeof(BuiltinCodecs) / sizeof(BuiltinCodecs[0]);

    while (index--)
    {
        // Load resource strings

        LOADRSRCSTR(CodecName);
        LOADRSRCSTR(FormatDescription);
        LOADRSRCSTR(FilenameExtension);
        LOADRSRCSTR(MimeType);

        // Compute the total size of the codec info

        UINT sigBytes = BuiltinCodecs[index].SigCount *
                        BuiltinCodecs[index].SigSize;

        UINT size = sizeof(CachedCodecInfo) +
                    CodecNameLen +
                    FormatDescriptionLen +
                    FilenameExtensionLen +
                    MimeTypeLen +
                    2*sigBytes;

        size = ALIGN16(size);

        // Allocate memory

        BYTE* buf = (BYTE*) GpMalloc(size);

        if ( buf == NULL )
            continue;

        // Fill out CachedCodecInfo structure

        CachedCodecInfo* cur = (CachedCodecInfo*) buf;
        cur->structSize = size;
        buf += sizeof(CachedCodecInfo);

        cur->Clsid = *BuiltinCodecs[index].Clsid;
        cur->FormatID = *BuiltinCodecs[index].FormatID;

        COPYRSRCSTR(CodecName);
        COPYRSRCSTR(FormatDescription);
        COPYRSRCSTR(FilenameExtension);
        COPYRSRCSTR(MimeType);

        cur->DllName = NULL;
        cur->Flags = BuiltinCodecs[index].Flags | IMGCODEC_BUILTIN;
        cur->Version = BuiltinCodecs[index].Version;
        cur->creationProc = BuiltinCodecs[index].creationProc;
        cur->SigCount = BuiltinCodecs[index].SigCount;
        cur->SigSize = BuiltinCodecs[index].SigSize;

        if (sigBytes)
        {
            cur->SigPattern = buf;
            memcpy(buf, BuiltinCodecs[index].SigPattern, sigBytes);
            buf += sigBytes;

            cur->SigMask = buf;
            memcpy(buf, BuiltinCodecs[index].SigMask, sigBytes);
            buf += sigBytes;
        }
        else
            cur->SigPattern = cur->SigMask = NULL;

        TRACE(("  %ws\n", cur->CodecName));

        InsertCachedCodecInfo(cur);
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Reload information about installed codecs from the registry
*
* Arguments:
*
*   hiveKey - Handle to the registry hive
*   regkeyStr - Root key where we kept info about installed codecs
*   cookie - The last cookie value we read out of the registry
*   classFlags - Specifies the class of codecs
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

#define ISOK(s)     ((s) == ERROR_SUCCESS)
#define ISERR(s)    ((s) != ERROR_SUCCESS)

#define GETREGDWORD(hkey, regstr, val)                              \
        if (ISERR(_RegGetDWORD(hkey, regstr, &val)))                \
            return FALSE

#define GETREGGUID(hkey, regstr, val)                               \
        if (ISERR(_RegGetBinary(hkey, regstr, &val, sizeof(GUID)))) \
            return FALSE

#define GETREGSTR(hkey, regstr, buf)                                \
        if (ISERR(_RegGetString(hkey, regstr, (WCHAR*) p, size)))   \
            return FALSE;                                           \
        buf = (const WCHAR*) p;                                     \
        n = SizeofWSTR(buf);                                        \
        if (size < n)                                               \
            return FALSE;                                           \
        p += n;                                                     \
        size -= n

#define GETREGBIN(hkey, regstr, buf, _n)                            \
        if (ISERR(_RegGetBinary(hkey, regstr, p, _n)))              \
            return FALSE;                                           \
        buf = p;                                                    \
        if (size < n)                                               \
            return FALSE;                                           \
        p += _n;                                                    \
        size -= _n

BOOL
ReadCodecRegValues(
    const WCHAR* codecName,
    HKEY hkey,
    CachedCodecInfo* info,
    UINT size
    )
{
    ASSERT(size > sizeof(CachedCodecInfo) &&
           size == ALIGN16(size));

    ZeroMemory(info, sizeof(CachedCodecInfo));

    info->structSize = size;
    size -= sizeof(CachedCodecInfo);

    // Copy codec name string

    BYTE* p = (BYTE*) info + sizeof(CachedCodecInfo);
    UINT n = SizeofWSTR(codecName);

    if (size < n)
        return FALSE;

    memcpy(p, codecName, n);
    info->CodecName = (const WCHAR*) p;
    size -= n;
    p += n;

    // Read the following values:
    //  codec COM object class ID
    //  file format identifier
    //  codec flags

    GETREGGUID(hkey, REGSTR_CODEC_CLSID, info->Clsid);
    GETREGGUID(hkey, REGSTR_CODEC_FORMATID, info->FormatID);
    GETREGDWORD(hkey, REGSTR_CODEC_VERSION, info->Version);
    GETREGDWORD(hkey, REGSTR_CODEC_FLAGS, info->Flags);

    // we only support version 1 codecs for now

    if (info->Version != 1)
        return FALSE;

    // Only the low-word of the codec flags is meaningfully persisted

    info->Flags &= 0xffff;

    // Read various string information
    //  dll name
    //  file type description
    //  filename extension
    //  mime type

    GETREGSTR(hkey, REGSTR_CODEC_DLLNAME, info->DllName);
    GETREGSTR(hkey, REGSTR_CODEC_FORMATDESC, info->FormatDescription);
    GETREGSTR(hkey, REGSTR_CODEC_FILENAMEEXT, info->FilenameExtension);
    GETREGSTR(hkey, REGSTR_CODEC_MIMETYPE, info->MimeType);

    // Read magic header pattern and mask information for decoders.
    // NOTE: This should be done last to avoid alignment problems.

    if (info->Flags & IMGCODEC_DECODER)
    {
        GETREGDWORD(hkey, REGSTR_CODEC_SIGCOUNT, info->SigCount);
        GETREGDWORD(hkey, REGSTR_CODEC_SIGSIZE, info->SigSize);

        n = info->SigCount * info->SigSize;

        if (n == 0 || 2*n > size)
            return FALSE;

        GETREGBIN(hkey, REGSTR_CODEC_SIGPATTERN, info->SigPattern, n);
        GETREGBIN(hkey, REGSTR_CODEC_SIGMASK, info->SigMask, n);
    }

    return TRUE;
}

VOID
ReloadCodecInfoFromRegistry(
    HKEY hiveKey,
    const WCHAR* regkeyStr,
    DWORD* cookie,
    UINT classFlags
    )
{
    // Open the root registry key

    HKEY hkeyRoot;

    if (ISERR(_RegOpenKey(hiveKey, regkeyStr, KEY_READ, &hkeyRoot)))
        return;

    // Read the cookie value in the root registry key

    DWORD newCookie;

    if (ISERR(_RegGetDWORD(hkeyRoot, REGSTR_LASTCOOKIE, &newCookie)))
        newCookie = 0;

    // Cookie hasn't changed, we don't need to do anything

    if (newCookie == *cookie)
    {
        RegCloseKey(hkeyRoot);
        return;
    }

    *cookie = newCookie;

    // Enumerate subkeys - one for each codec

    WCHAR subkeyStr[MAX_PATH];
    DWORD keyIndex = 0;

    while (ISOK(_RegEnumKey(hkeyRoot, keyIndex, subkeyStr)))
    {
        keyIndex++;

        // Open the subkey for the next codec

        HKEY hkeyCodec;

        if (ISERR(_RegOpenKey(hkeyRoot, subkeyStr, KEY_READ, &hkeyCodec)))
            continue;

        // Figure out how big a buffer we need to hold information
        // about the this codec. And then allocate enough memory.

        CachedCodecInfo* cur = NULL;
        DWORD infosize;

        if (ISOK(_RegGetDWORD(hkeyCodec, REGSTR_CODEC_INFOSIZE, &infosize)) &&
            infosize > sizeof(CachedCodecInfo) &&
            infosize == ALIGN16(infosize) &&
            (cur = (CachedCodecInfo*) GpMalloc(infosize)) &&
            ReadCodecRegValues(subkeyStr, hkeyCodec, cur, infosize))
        {
            // Insert the new codec info at the head of the list

            cur->Flags |= classFlags;
            InsertCachedCodecInfo(cur);
        }
        else
        {
            // Wasn't able to read codec info from registry

            GpFree(cur);
        }

        RegCloseKey(hkeyCodec);
    }

    RegCloseKey(hkeyRoot);
}


/**************************************************************************\
*
* Function Description:
*
*   Initialize cached list of decoders and encoders
*   by reading information out of the registry
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
* Notes:
*
*   We assume the caller has already taken care of
*   the imaging critical section here.
*
\**************************************************************************/

VOID
ReloadCachedCodecInfo()
{
    TRACE(("Entering ReloadCachedCodecInfo...\n"));

    BOOL checkReg;

    CodecCacheUpdated = FALSE;

    if (CachedCodecs == NULL)
    {
        // This is the very first time ReloadCachedCodecInfo is called.
        // So initialize built-in codecs here.

        InitializeBuiltinCodecs();

        // Make sure we reload registry info

        checkReg = TRUE;
    }
    else
    {
        // Now check to see if it's time to check yet

        DWORD gap = GetTickCount() - LastCheckRegTime;
        checkReg = gap >= CHECKREG_INTERVAL;
    }

    if (!checkReg)
        return;

    if (!SuppressExternalCodecs)
    {
        // Reload info about system-wide codecs from the registry
    
        ReloadCodecInfoFromRegistry(
            HKEY_LOCAL_MACHINE,
            REGSTR_CODECROOT,
            &SystemRegCookie,
            IMGCODEC_SYSTEM);
    
        // Reload info about per-user codecs from the registry
    
        ReloadCodecInfoFromRegistry(
            HKEY_CURRENT_USER,
            REGSTR_CODECROOT,
            &UserRegCookie,
            IMGCODEC_USER);
    }

    // Recalculate maximum magic header size for all codecs

    if (CodecCacheUpdated)
    {
        DWORD maxsize = 0;
        CachedCodecInfo* cur = CachedCodecs;

        while (cur)
        {
            VERBOSE((
                "Codec: %ws\n"
                "    DllName: %ws\n"
                "    Version = 0x%x\n"
                "    flags = 0x%x\n"
                "    format = %ws\n"
                "    ext = %ws",
                cur->CodecName,
                cur->DllName,
                cur->Version,
                cur->Flags,
                cur->FormatDescription,
                cur->FilenameExtension));

            if (cur->SigSize > maxsize)
                maxsize = cur->SigSize;

            cur = cur->next;
        }

        MaxSigSize = maxsize;
        CodecCacheUpdated = FALSE;
    }

    LastCheckRegTime = GetTickCount();
}


/**************************************************************************\
*
* Function Description:
*
*   Install a codec: save relevant information into the registry
*
* Arguments:
*
*   codecInfo - Information about the codec to be installed
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

#define IMGCODEC_CLASSMASKS (IMGCODEC_BUILTIN|IMGCODEC_SYSTEM|IMGCODEC_USER)

#define SETREGDWORD(hkey, regstr, val)                              \
        status = _RegSetDWORD(hkey, regstr, val);                   \
        if (ISERR(status)) goto exitLabel

#define SETREGGUID(hkey, regstr, val)                               \
        status = _RegSetBinary(hkey, regstr, &val, sizeof(GUID));   \
        if (ISERR(status)) goto exitLabel

#define SETREGSTR(hkey, regstr, buf)                                \
        status = _RegSetString(hkey, regstr, buf);                  \
        if (ISERR(status)) goto exitLabel

#define SETREGBIN(hkey, regstr, buf, size)                          \
        status = _RegSetBinary(hkey, regstr, buf, size);            \
        if (ISERR(status)) goto exitLabel



HRESULT
InstallCodec(
    const ImageCodecInfo* codecInfo
    )
{
    // Validate input parameters

    if (!codecInfo ||
        !codecInfo->CodecName ||
        !codecInfo->DllName ||
        !codecInfo->Version ||
        !codecInfo->FormatDescription ||
        !codecInfo->FilenameExtension ||
        !codecInfo->MimeType)
    {
        return E_INVALIDARG;
    }

    UINT flags = codecInfo->Flags & IMGCODEC_CLASSMASKS;
    DWORD sigBytes = codecInfo->SigCount * codecInfo->SigSize;
    HKEY hive;

    if (flags == IMGCODEC_SYSTEM)
        hive = HKEY_LOCAL_MACHINE;
    else if (flags == IMGCODEC_USER)
        hive = HKEY_CURRENT_USER;
    else
        return E_INVALIDARG;

    flags = codecInfo->Flags & (IMGCODEC_ENCODER|IMGCODEC_DECODER);

    if ((flags == 0) ||
        (flags & IMGCODEC_DECODER) && !sigBytes ||
        sigBytes && (!codecInfo->SigPattern || !codecInfo->SigMask))
    {
        return E_INVALIDARG;
    }

    // Open the root registry key

    HKEY hkeyRoot = NULL;
    HKEY hkey = NULL;
    LONG status;

    status = _RegCreateKey(hive, REGSTR_CODECROOT, KEY_ALL_ACCESS, &hkeyRoot);

    if (ISERR(status))
        goto exitLabel;

    // Update the cookie value under the root registry key

    DWORD cookie;

    if (ISERR(_RegGetDWORD(hkeyRoot, REGSTR_LASTCOOKIE, &cookie)))
        cookie = 0;

    cookie++;

    SETREGDWORD(hkeyRoot, REGSTR_LASTCOOKIE, cookie);

    // Create the subkey corresponding to the new codec.
    // If the subkey already exists, then just open it.

    status = _RegCreateKey(
                hkeyRoot,
                codecInfo->CodecName,
                KEY_ALL_ACCESS,
                &hkey);

    if (ISERR(status))
        goto exitLabel;

    // Figure out the total size of codec info

    UINT size;

    size = sizeof(CachedCodecInfo) +
           SizeofWSTR(codecInfo->CodecName) +
           SizeofWSTR(codecInfo->DllName) +
           SizeofWSTR(codecInfo->FormatDescription) +
           SizeofWSTR(codecInfo->FilenameExtension) +
           SizeofWSTR(codecInfo->MimeType) +
           2*sigBytes;

    size = ALIGN16(size);

    SETREGDWORD(hkey, REGSTR_CODEC_INFOSIZE, size);

    // Save codec flags, class ID, and file format ID
    // and magic file header information, if any

    SETREGDWORD(hkey, REGSTR_CODEC_VERSION, codecInfo->Version);
    SETREGDWORD(hkey, REGSTR_CODEC_FLAGS, codecInfo->Flags);
    SETREGGUID(hkey, REGSTR_CODEC_CLSID, codecInfo->Clsid);
    SETREGGUID(hkey, REGSTR_CODEC_FORMATID, codecInfo->FormatID);

    if (sigBytes)
    {
        SETREGDWORD(hkey, REGSTR_CODEC_SIGCOUNT, codecInfo->SigCount);
        SETREGDWORD(hkey, REGSTR_CODEC_SIGSIZE, codecInfo->SigSize);
        SETREGBIN(hkey, REGSTR_CODEC_SIGPATTERN, codecInfo->SigPattern, sigBytes);
        SETREGBIN(hkey, REGSTR_CODEC_SIGMASK, codecInfo->SigMask, sigBytes);
    }

    // Save string information:
    //  file format description
    //  filename extension
    //  MIME type

    SETREGSTR(hkey, REGSTR_CODEC_DLLNAME, codecInfo->DllName);
    SETREGSTR(hkey, REGSTR_CODEC_FORMATDESC, codecInfo->FormatDescription);
    SETREGSTR(hkey, REGSTR_CODEC_FILENAMEEXT, codecInfo->FilenameExtension);
    SETREGSTR(hkey, REGSTR_CODEC_MIMETYPE, codecInfo->MimeType);

    // Force a reload of cached codec information from registry

    ForceReloadCachedCodecInfo();

exitLabel:

    if (hkey)
        RegCloseKey(hkey);

    if (hkeyRoot)
        RegCloseKey(hkeyRoot);

    return (status == ERROR_SUCCESS) ?
                S_OK :
                HRESULT_FROM_WIN32(status);
}


/**************************************************************************\
*
* Function Description:
*
*   Uninstall a codec
*
* Arguments:
*
*   codecName - Name of the codec to be uninstalled
*   flags - Uninstall system-wide or per-user codec
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
UninstallCodec(
    const WCHAR* codecName,
    UINT flags
    )
{
    // Validate input parameters

    if (!codecName ||
        flags != IMGCODEC_USER && flags != IMGCODEC_SYSTEM)
    {
        return E_INVALIDARG;
    }

    // Open the root registry key

    HKEY hive, hkeyRoot;
    LONG status;

    hive = (flags == IMGCODEC_USER) ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;
    status = _RegOpenKey(hive, REGSTR_CODECROOT, KEY_ALL_ACCESS, &hkeyRoot);

    if (ISERR(status))
        return HRESULT_FROM_WIN32(status);

    // Update the cookie value under the root registry key

    DWORD cookie;

    if (ISERR(_RegGetDWORD(hkeyRoot, REGSTR_LASTCOOKIE, &cookie)))
        cookie = 0;

    cookie++;
    SETREGDWORD(hkeyRoot, REGSTR_LASTCOOKIE, cookie);

    // Delete the subkey corresponding to the specified decoder

    status = RecursiveDeleteRegKey(hkeyRoot, codecName);

    // Force a reload of cached codec information from registry

    ForceReloadCachedCodecInfo();

exitLabel:

    RegCloseKey(hkeyRoot);

    return (status == ERROR_SUCCESS) ?
                S_OK :
                HRESULT_FROM_WIN32(status);
}

/**************************************************************************\
*
* Function Description:
*
*   Our own fake CoCreateInstance
*
* Arguments:
*
*   clsId - CLSID of the codec DLL installed
*   DllName - Dll name
*   iid - whether we want decoder or encoder
*   codec - pointer to the decoder/encoder we are returning
*
* Return Value:
*
*   status code
*
\**************************************************************************/
HRESULT MyCreateInstance(WCHAR* DllName, REFIID iid, VOID** codec)
{
    HINSTANCE h;
    HRESULT   hr = IMGERR_FAILLOADCODEC;;

    if ((h = LoadLibrary(DllName)) != NULL)
    {
        CreateCodecInstanceProc CreateCodecInstance;

        if ((CreateCodecInstance = 
             (CreateCodecInstanceProc)GetProcAddress(h, "CreateCodecInstance")) != NULL)
        {
            hr = CreateCodecInstance(iid, codec);
            return hr;
        }
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Find a decoder that recognizes the specified header signature
*
* Arguments:
*
*   sigbuf - Pointer to file header data
*   sigsize - Size of file header data buffer
*   classMask - Specifies the specific class of decoders to look for
*
* Return Value:
*
*   Pointer to the CachedCodecInfo structure corresponding to
*   the decoder found. NULL if nothing is found.
*
* Note:
*
*   The caller should be holding the global imaging critical section.
*
\**************************************************************************/

CachedCodecInfo*
FindDecoderWithHeader(
    const VOID* sigbuf,
    UINT sigsize,
    UINT classMask
    )
{
    CachedCodecInfo* cur;
    const BYTE* srcdata = (const BYTE*) sigbuf;

    for (cur = CachedCodecs; cur; cur = cur->next)
    {

        if (!(cur->Flags & IMGCODEC_DECODER) ||
            (cur->Flags & classMask) != classMask ||
            cur->SigSize > sigsize)
        {
            continue;
        }

        // Try to find a matching decoder based on
        // information in the file header.

        const BYTE* pat = cur->SigPattern;
        const BYTE* mask = cur->SigMask;
        UINT n = min(sigsize, cur->SigSize);
        UINT j = cur->SigCount;
        UINT i;

        while (j--)
        {
            for (i=0; i < n; i++)
            {
                if ((srcdata[i] & mask[i]) != pat[i])
                    break;
            }

            if (i == n)
                return cur;

            pat += cur->SigSize;
            mask += cur->SigSize;
        }
    }

    return NULL;
}


/**************************************************************************\
*
* Function Description:
*
*   Get a decoder object that can process the specified data stream
*
* Arguments:
*
*   stream - Specifies the input data stream
*   decoder - If the call is successful, return a pointer to
*       an initialized IImageDecoder object
*   flags - Misc. flags
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
CreateDecoderForStream(
    IStream* stream,
    IImageDecoder** decoder,
    DecoderInitFlag flags
    )
{
    // Reload cached codec information if necessary
    //  and figure out the maximum magic header size

    UINT sigsize, bytesRead;
    BYTE stackbuf[64];
    GpTempBuffer sigbuf(stackbuf, sizeof(stackbuf));

    {
        // Acquire global critical section

        ImagingCritSec critsec;

        ReloadCachedCodecInfo();
        sigsize = MaxSigSize;
    }

    if (sigsize == 0)
        return IMGERR_CODECNOTFOUND;
    else if (!sigbuf.Realloc(sigsize))
        return E_OUTOFMEMORY;

    // Seek the stream back to the beginning.
    // Note: This is also a check to see if the input stream is seekable or not.
    // For some net streams, it might not be seekable.

    HRESULT hr;

    LARGE_INTEGER   move;

    move.QuadPart = 0;

    hr = stream->Seek(move, STREAM_SEEK_SET, NULL);

    // !!! TODO: Some stream implementation return 0x0000007e, not as the
    // conventional 0x8000xxxx return code. WFC stream class is an example. So
    // we might need to check if (hr == S_OK) here, instead of FAILED(hr)

    if (FAILED(hr))
    {
        // !!! TODO
        // The stream is not seekable. We need to wrap a seekable interface
        // around it.

        WARNING(("Non-seekable stream in CreateDecoderForStream"));
        return hr;
    }

    // Read the magic header info and
    //  move the seek pointer back to its initial position

    VOID* p = sigbuf.GetBuffer();

    hr = BlockingReadStream(stream, p, sigsize, &bytesRead);

    if (bytesRead == 0)
        return FAILED(hr) ? hr : E_FAIL;

    hr = BlockingSeekStreamCur(stream, - (INT) bytesRead, NULL);

    if (FAILED(hr))
        return hr;

    CreateCodecInstanceProc creationProc;
    CLSID clsid;
    WCHAR* DllName;
    CachedCodecInfo* found = NULL;

    {
        // Acquire global critical section

        ImagingCritSec critsec;

        // Check if the caller want to get to built-in decoders first

        if (flags & DECODERINIT_BUILTIN1ST)
            found = FindDecoderWithHeader(p, bytesRead, IMGCODEC_BUILTIN);

        if (!found)
            found = FindDecoderWithHeader(p, bytesRead, 0);

        if (found && !(creationProc = found->creationProc))
        {
            clsid = found->Clsid;
            DllName = (WCHAR*)found->DllName;
        }
    }

    if (!found)
        return IMGERR_CODECNOTFOUND;

    // Create an instance of image decoder

    IImageDecoder* codec;

    if (creationProc)
    {
        // Built-in decoder

        hr = creationProc(IID_IImageDecoder, (VOID**) &codec);
    }
    else
    {
        // External decoder

        hr = MyCreateInstance(
                DllName,
                IID_IImageDecoder,
                (VOID**) &codec);
    }

    if (FAILED(hr))
        return hr;

    // Initialize the decoder with input data stream

    hr = codec->InitDecoder(stream, flags);

    if (SUCCEEDED(hr))
    {
        *decoder = codec;
    }
    else
    {
        // Terminate the decoder first so that the codec can do all the clean
        // up and resource free. Then release the codec

        codec->TerminateDecoder();
        codec->Release();
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the encoder parameter list size from an encoder object specified by
*   input clsid
*
* Arguments:
*
*   clsid - Specifies the encoder class ID
*   size--- The size of the encoder parameter list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/22/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
CodecGetEncoderParameterListSize(
    const CLSID* clsid,
    UINT*   size
    )
{
    BOOL bFound = FALSE;
    WCHAR* DllName;

    CreateCodecInstanceProc creationProc;

    {
        // Acquire global critical section

        ImagingCritSec critsec;

        ReloadCachedCodecInfo();

        // Check if we have an encoder with the specified class ID

        CachedCodecInfo* curCodec;

        for ( curCodec = CachedCodecs;
              curCodec != NULL;
              curCodec = curCodec->next)
        {
            if ( (curCodec->Flags & IMGCODEC_ENCODER)
               &&(curCodec->Clsid == *clsid) )
            {
                bFound = TRUE;
                DllName = (WCHAR*)curCodec->DllName;
                creationProc = curCodec->creationProc;

                break;
            }
        }
    }

    if ( bFound == FALSE )
    {
        return IMGERR_CODECNOTFOUND;
    }

    // Create an instance of image encoder

    IImageEncoder* pEncoder;
    HRESULT hResult;

    if ( creationProc )
    {
        // Built-in encoder

        hResult = creationProc(IID_IImageEncoder, (VOID**)&pEncoder);
    }
    else
    {
        // External encoder

        hResult = MyCreateInstance(DllName, IID_IImageEncoder,(VOID**)&pEncoder);
    }

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Initialize the decoder with input data stream

    hResult = pEncoder->GetEncoderParameterListSize(size);

    pEncoder->Release();

    return hResult;
}// CodecGetEncoderParameterListSize()

/**************************************************************************\
*
* Function Description:
*
*   Get the encoder parameter list from an encoder object specified by
*   input clsid
*
* Arguments:
*
*   clsid - Specifies the encoder class ID
*   size--- The size of the encoder parameter list
*   Params--List of encoder parameters
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/22/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
CodecGetEncoderParameterList(
    const CLSID*    clsid,
    const IN UINT   size,
    OUT EncoderParameters*  pBuffer
    )
{
    BOOL bFound = FALSE;
    WCHAR* DllName;

    CreateCodecInstanceProc creationProc;

    {
        // Acquire global critical section

        ImagingCritSec critsec;

        ReloadCachedCodecInfo();

        // Check if we have an encoder with the specified class ID

        CachedCodecInfo* curCodec;

        for ( curCodec = CachedCodecs;
              curCodec != NULL;
              curCodec = curCodec->next)
        {
            if ( (curCodec->Flags & IMGCODEC_ENCODER)
               &&(curCodec->Clsid == *clsid) )
            {
                bFound = TRUE;
                DllName = (WCHAR*)curCodec->DllName;
                creationProc = curCodec->creationProc;

                break;
            }
        }
    }

    if ( bFound == FALSE )
    {
        return IMGERR_CODECNOTFOUND;
    }

    // Create an instance of image encoder

    IImageEncoder* pEncoder;
    HRESULT hResult;

    if ( creationProc )
    {
        // Built-in encoder

        hResult = creationProc(IID_IImageEncoder, (VOID**)&pEncoder);
    }
    else
    {
        // External encoder

        hResult = MyCreateInstance(DllName, IID_IImageEncoder,(VOID**)&pEncoder);
    }

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Initialize the decoder with input data stream

    hResult = pEncoder->GetEncoderParameterList(size, pBuffer);

    pEncoder->Release();

    return hResult;
}// CodecGetEncoderParameterList()

/**************************************************************************\
*
* Function Description:
*
*   Get an encoder object to output to the specified stream
*
* Arguments:
*
*   clsid - Specifies the encoder class ID
*   stream - Specifies the output data stream
*   encoder - If the call is successful, return a pointer to
*       an initialized IImageEncoder object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
CreateEncoderToStream(
    const CLSID* clsid,
    IStream* stream,
    IImageEncoder** encoder
    )
{
    BOOL found = FALSE;
    WCHAR* DllName;
    BOOL needSeekable;
    CreateCodecInstanceProc creationProc;

    {
        // Acquire global critical section

        ImagingCritSec critsec;

        ReloadCachedCodecInfo();

        // Check if we have an encoder with the specified class ID

        CachedCodecInfo* cur;

        for (cur = CachedCodecs; cur != NULL; cur = cur->next)
        {
            if ((cur->Flags & IMGCODEC_ENCODER) && cur->Clsid == *clsid)
            {
                found = TRUE;

                DllName = (WCHAR*)cur->DllName;
                creationProc = cur->creationProc;

                if (cur->Flags & IMGCODEC_SEEKABLE_ENCODE)
                    needSeekable = TRUE;

                break;
            }
        }
    }

    if (!found)
        return IMGERR_CODECNOTFOUND;

    // Create an instance of image encoder

    IImageEncoder* codec;
    HRESULT hr;

    if (creationProc)
    {
        // Built-in encoder

        hr = creationProc(IID_IImageEncoder, (VOID**) &codec);
    }
    else
    {
        // External encoder

        hr = MyCreateInstance(
                DllName,
                IID_IImageEncoder,
                (VOID**) &codec);
    }

    if (FAILED(hr))
        return hr;

    // Initialize the decoder with input data stream

    hr = codec->InitEncoder(stream);

    if (SUCCEEDED(hr))
        *encoder = codec;
    else
        codec->Release();

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Get the list of installed codecs
*
* Arguments:
*
*   count - Return the number of installed codecs
*   codecs - Pointer to an array of ImageCodecInfo structures
*   selectionFlag - Whether caller is interested in decoders or encoders
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

#define COPYCODECINFOSTR(_f)            \
        dst->_f = (const WCHAR*) buf;   \
        size = SizeofWSTR(cur->_f);     \
        memcpy(buf, cur->_f, size);     \
        buf += size

HRESULT
GetInstalledCodecs(
    UINT* count,
    ImageCodecInfo** codecs,
    UINT selectionFlag
    )
{
    TRACE(("GetInstalledCodecs: flag = 0x%x\n", selectionFlag));

    // Acquire global critical section

    ImagingCritSec critsec;

    ReloadCachedCodecInfo();

    CachedCodecInfo* cur;
    UINT n, size;

    // Count the number of selected codecs
    // and figure the amount of memory we need to allocate

    n = size = 0;

    for (cur = CachedCodecs; cur; cur = cur->next)
    {
        if (cur->Flags & selectionFlag)
        {
            n++;
            size += cur->structSize;
        }
    }

    BYTE* buf;
    HRESULT hr;

    *count = 0;
    *codecs = NULL;

    // Allocate output memory buffer

    if (n == 0)
        hr = IMGERR_CODECNOTFOUND;
    else if ((buf = (BYTE*) GpCoAlloc(size)) == NULL)
        hr = E_OUTOFMEMORY;
    else
    {
        *count = n;
        *codecs = (ImageCodecInfo*) buf;

        // Copy codec information to the output buffer

        ImageCodecInfo* dst = *codecs;
        buf += n * sizeof(ImageCodecInfo);

        for (cur = CachedCodecs; cur; cur = cur->next)
        {
            if ((cur->Flags & selectionFlag) == 0)
                continue;

            // First do a simple memory copy

            *dst = *static_cast<ImageCodecInfo*>(cur);

            // Then modify the pointer fields

            COPYCODECINFOSTR(CodecName);

            if (cur->DllName != NULL)
            {
                COPYCODECINFOSTR(DllName);
            }

            COPYCODECINFOSTR(FormatDescription);
            COPYCODECINFOSTR(FilenameExtension);
            COPYCODECINFOSTR(MimeType);

            if (size = cur->SigCount*cur->SigSize)
            {
                dst->SigPattern = buf;
                memcpy(buf, cur->SigPattern, size);
                buf += size;

                dst->SigMask = buf;
                memcpy(buf, cur->SigMask, size);
                buf += size;
            }

            dst++;
        }

        hr = S_OK;
    }

    // Global critical section is released in critsec destructor

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\colorpal.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   colorpal.cpp
*
* Abstract:
*
*   Color palette related functions
*
* Revision History:
*
*   05/17/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

//
// Default 1bpp color palette
//

#define MAKEPALENTRY(r, g, b) MAKEARGB(255, r, g, b)

struct
{
    UINT flags;
    UINT count;
    ARGB entries[2];
}
const Default1bppColorPalette =
{
    PALFLAG_GRAYSCALE,
    2,

    MAKEPALENTRY(0x00, 0x00, 0x00),
    MAKEPALENTRY(0xff, 0xff, 0xff)
};

//
// Default 4bpp color palette - VGA palette
//

struct
{
    UINT flags;
    UINT count;
    ARGB entries[16];
}
const Default4bppColorPalette =
{
    0,
    16,

    MAKEPALENTRY(0x00, 0x00, 0x00),
    MAKEPALENTRY(0x80, 0x00, 0x00),
    MAKEPALENTRY(0x00, 0x80, 0x00),
    MAKEPALENTRY(0x80, 0x80, 0x00),
    MAKEPALENTRY(0x00, 0x00, 0x80),
    MAKEPALENTRY(0x80, 0x00, 0x80),
    MAKEPALENTRY(0x00, 0x80, 0x80),
    MAKEPALENTRY(0x80, 0x80, 0x80),
    MAKEPALENTRY(0xC0, 0xC0, 0xC0),
    MAKEPALENTRY(0xFF, 0x00, 0x00),
    MAKEPALENTRY(0x00, 0xFF, 0x00),
    MAKEPALENTRY(0xFF, 0xFF, 0x00),
    MAKEPALENTRY(0x00, 0x00, 0xFF),
    MAKEPALENTRY(0xFF, 0x00, 0xFF),
    MAKEPALENTRY(0x00, 0xFF, 0xFF),
    MAKEPALENTRY(0xFF, 0xFF, 0xFF)
};

//
// Default 8bpp color palette
//

struct
{
    UINT flags;
    UINT count;
    ARGB entries[256];
}
const Default8bppColorPalette =
{
    PALFLAG_HALFTONE,
    256,

    MAKEPALENTRY(0x00, 0x00, 0x00),     // 16 VGA colors
    MAKEPALENTRY(0x80, 0x00, 0x00),
    MAKEPALENTRY(0x00, 0x80, 0x00),
    MAKEPALENTRY(0x80, 0x80, 0x00),
    MAKEPALENTRY(0x00, 0x00, 0x80),
    MAKEPALENTRY(0x80, 0x00, 0x80),
    MAKEPALENTRY(0x00, 0x80, 0x80),
    MAKEPALENTRY(0x80, 0x80, 0x80),
    MAKEPALENTRY(0xC0, 0xC0, 0xC0),
    MAKEPALENTRY(0xFF, 0x00, 0x00),
    MAKEPALENTRY(0x00, 0xFF, 0x00),
    MAKEPALENTRY(0xFF, 0xFF, 0x00),
    MAKEPALENTRY(0x00, 0x00, 0xFF),
    MAKEPALENTRY(0xFF, 0x00, 0xFF),
    MAKEPALENTRY(0x00, 0xFF, 0xFF),
    MAKEPALENTRY(0xFF, 0xFF, 0xFF),

    0,                                  // 24 unused entries
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,

    // !!! TODO
    //  Use simple 4x4 dither cell for now.
    //  Eventually should switch to Daniel's supercells.

    MAKEPALENTRY(0x00, 0x00, 0x00),
    MAKEPALENTRY(0x00, 0x00, 0x33),
    MAKEPALENTRY(0x00, 0x00, 0x66),
    MAKEPALENTRY(0x00, 0x00, 0x99),
    MAKEPALENTRY(0x00, 0x00, 0xCC),
    MAKEPALENTRY(0x00, 0x00, 0xFF),
    MAKEPALENTRY(0x00, 0x33, 0x00),
    MAKEPALENTRY(0x00, 0x33, 0x33),
    MAKEPALENTRY(0x00, 0x33, 0x66),
    MAKEPALENTRY(0x00, 0x33, 0x99),
    MAKEPALENTRY(0x00, 0x33, 0xCC),
    MAKEPALENTRY(0x00, 0x33, 0xFF),
    MAKEPALENTRY(0x00, 0x66, 0x00),
    MAKEPALENTRY(0x00, 0x66, 0x33),
    MAKEPALENTRY(0x00, 0x66, 0x66),
    MAKEPALENTRY(0x00, 0x66, 0x99),
    MAKEPALENTRY(0x00, 0x66, 0xCC),
    MAKEPALENTRY(0x00, 0x66, 0xFF),
    MAKEPALENTRY(0x00, 0x99, 0x00),
    MAKEPALENTRY(0x00, 0x99, 0x33),
    MAKEPALENTRY(0x00, 0x99, 0x66),
    MAKEPALENTRY(0x00, 0x99, 0x99),
    MAKEPALENTRY(0x00, 0x99, 0xCC),
    MAKEPALENTRY(0x00, 0x99, 0xFF),
    MAKEPALENTRY(0x00, 0xCC, 0x00),
    MAKEPALENTRY(0x00, 0xCC, 0x33),
    MAKEPALENTRY(0x00, 0xCC, 0x66),
    MAKEPALENTRY(0x00, 0xCC, 0x99),
    MAKEPALENTRY(0x00, 0xCC, 0xCC),
    MAKEPALENTRY(0x00, 0xCC, 0xFF),
    MAKEPALENTRY(0x00, 0xFF, 0x00),
    MAKEPALENTRY(0x00, 0xFF, 0x33),
    MAKEPALENTRY(0x00, 0xFF, 0x66),
    MAKEPALENTRY(0x00, 0xFF, 0x99),
    MAKEPALENTRY(0x00, 0xFF, 0xCC),
    MAKEPALENTRY(0x00, 0xFF, 0xFF),
    MAKEPALENTRY(0x33, 0x00, 0x00),
    MAKEPALENTRY(0x33, 0x00, 0x33),
    MAKEPALENTRY(0x33, 0x00, 0x66),
    MAKEPALENTRY(0x33, 0x00, 0x99),
    MAKEPALENTRY(0x33, 0x00, 0xCC),
    MAKEPALENTRY(0x33, 0x00, 0xFF),
    MAKEPALENTRY(0x33, 0x33, 0x00),
    MAKEPALENTRY(0x33, 0x33, 0x33),
    MAKEPALENTRY(0x33, 0x33, 0x66),
    MAKEPALENTRY(0x33, 0x33, 0x99),
    MAKEPALENTRY(0x33, 0x33, 0xCC),
    MAKEPALENTRY(0x33, 0x33, 0xFF),
    MAKEPALENTRY(0x33, 0x66, 0x00),
    MAKEPALENTRY(0x33, 0x66, 0x33),
    MAKEPALENTRY(0x33, 0x66, 0x66),
    MAKEPALENTRY(0x33, 0x66, 0x99),
    MAKEPALENTRY(0x33, 0x66, 0xCC),
    MAKEPALENTRY(0x33, 0x66, 0xFF),
    MAKEPALENTRY(0x33, 0x99, 0x00),
    MAKEPALENTRY(0x33, 0x99, 0x33),
    MAKEPALENTRY(0x33, 0x99, 0x66),
    MAKEPALENTRY(0x33, 0x99, 0x99),
    MAKEPALENTRY(0x33, 0x99, 0xCC),
    MAKEPALENTRY(0x33, 0x99, 0xFF),
    MAKEPALENTRY(0x33, 0xCC, 0x00),
    MAKEPALENTRY(0x33, 0xCC, 0x33),
    MAKEPALENTRY(0x33, 0xCC, 0x66),
    MAKEPALENTRY(0x33, 0xCC, 0x99),
    MAKEPALENTRY(0x33, 0xCC, 0xCC),
    MAKEPALENTRY(0x33, 0xCC, 0xFF),
    MAKEPALENTRY(0x33, 0xFF, 0x00),
    MAKEPALENTRY(0x33, 0xFF, 0x33),
    MAKEPALENTRY(0x33, 0xFF, 0x66),
    MAKEPALENTRY(0x33, 0xFF, 0x99),
    MAKEPALENTRY(0x33, 0xFF, 0xCC),
    MAKEPALENTRY(0x33, 0xFF, 0xFF),
    MAKEPALENTRY(0x66, 0x00, 0x00),
    MAKEPALENTRY(0x66, 0x00, 0x33),
    MAKEPALENTRY(0x66, 0x00, 0x66),
    MAKEPALENTRY(0x66, 0x00, 0x99),
    MAKEPALENTRY(0x66, 0x00, 0xCC),
    MAKEPALENTRY(0x66, 0x00, 0xFF),
    MAKEPALENTRY(0x66, 0x33, 0x00),
    MAKEPALENTRY(0x66, 0x33, 0x33),
    MAKEPALENTRY(0x66, 0x33, 0x66),
    MAKEPALENTRY(0x66, 0x33, 0x99),
    MAKEPALENTRY(0x66, 0x33, 0xCC),
    MAKEPALENTRY(0x66, 0x33, 0xFF),
    MAKEPALENTRY(0x66, 0x66, 0x00),
    MAKEPALENTRY(0x66, 0x66, 0x33),
    MAKEPALENTRY(0x66, 0x66, 0x66),
    MAKEPALENTRY(0x66, 0x66, 0x99),
    MAKEPALENTRY(0x66, 0x66, 0xCC),
    MAKEPALENTRY(0x66, 0x66, 0xFF),
    MAKEPALENTRY(0x66, 0x99, 0x00),
    MAKEPALENTRY(0x66, 0x99, 0x33),
    MAKEPALENTRY(0x66, 0x99, 0x66),
    MAKEPALENTRY(0x66, 0x99, 0x99),
    MAKEPALENTRY(0x66, 0x99, 0xCC),
    MAKEPALENTRY(0x66, 0x99, 0xFF),
    MAKEPALENTRY(0x66, 0xCC, 0x00),
    MAKEPALENTRY(0x66, 0xCC, 0x33),
    MAKEPALENTRY(0x66, 0xCC, 0x66),
    MAKEPALENTRY(0x66, 0xCC, 0x99),
    MAKEPALENTRY(0x66, 0xCC, 0xCC),
    MAKEPALENTRY(0x66, 0xCC, 0xFF),
    MAKEPALENTRY(0x66, 0xFF, 0x00),
    MAKEPALENTRY(0x66, 0xFF, 0x33),
    MAKEPALENTRY(0x66, 0xFF, 0x66),
    MAKEPALENTRY(0x66, 0xFF, 0x99),
    MAKEPALENTRY(0x66, 0xFF, 0xCC),
    MAKEPALENTRY(0x66, 0xFF, 0xFF),
    MAKEPALENTRY(0x99, 0x00, 0x00),
    MAKEPALENTRY(0x99, 0x00, 0x33),
    MAKEPALENTRY(0x99, 0x00, 0x66),
    MAKEPALENTRY(0x99, 0x00, 0x99),
    MAKEPALENTRY(0x99, 0x00, 0xCC),
    MAKEPALENTRY(0x99, 0x00, 0xFF),
    MAKEPALENTRY(0x99, 0x33, 0x00),
    MAKEPALENTRY(0x99, 0x33, 0x33),
    MAKEPALENTRY(0x99, 0x33, 0x66),
    MAKEPALENTRY(0x99, 0x33, 0x99),
    MAKEPALENTRY(0x99, 0x33, 0xCC),
    MAKEPALENTRY(0x99, 0x33, 0xFF),
    MAKEPALENTRY(0x99, 0x66, 0x00),
    MAKEPALENTRY(0x99, 0x66, 0x33),
    MAKEPALENTRY(0x99, 0x66, 0x66),
    MAKEPALENTRY(0x99, 0x66, 0x99),
    MAKEPALENTRY(0x99, 0x66, 0xCC),
    MAKEPALENTRY(0x99, 0x66, 0xFF),
    MAKEPALENTRY(0x99, 0x99, 0x00),
    MAKEPALENTRY(0x99, 0x99, 0x33),
    MAKEPALENTRY(0x99, 0x99, 0x66),
    MAKEPALENTRY(0x99, 0x99, 0x99),
    MAKEPALENTRY(0x99, 0x99, 0xCC),
    MAKEPALENTRY(0x99, 0x99, 0xFF),
    MAKEPALENTRY(0x99, 0xCC, 0x00),
    MAKEPALENTRY(0x99, 0xCC, 0x33),
    MAKEPALENTRY(0x99, 0xCC, 0x66),
    MAKEPALENTRY(0x99, 0xCC, 0x99),
    MAKEPALENTRY(0x99, 0xCC, 0xCC),
    MAKEPALENTRY(0x99, 0xCC, 0xFF),
    MAKEPALENTRY(0x99, 0xFF, 0x00),
    MAKEPALENTRY(0x99, 0xFF, 0x33),
    MAKEPALENTRY(0x99, 0xFF, 0x66),
    MAKEPALENTRY(0x99, 0xFF, 0x99),
    MAKEPALENTRY(0x99, 0xFF, 0xCC),
    MAKEPALENTRY(0x99, 0xFF, 0xFF),
    MAKEPALENTRY(0xCC, 0x00, 0x00),
    MAKEPALENTRY(0xCC, 0x00, 0x33),
    MAKEPALENTRY(0xCC, 0x00, 0x66),
    MAKEPALENTRY(0xCC, 0x00, 0x99),
    MAKEPALENTRY(0xCC, 0x00, 0xCC),
    MAKEPALENTRY(0xCC, 0x00, 0xFF),
    MAKEPALENTRY(0xCC, 0x33, 0x00),
    MAKEPALENTRY(0xCC, 0x33, 0x33),
    MAKEPALENTRY(0xCC, 0x33, 0x66),
    MAKEPALENTRY(0xCC, 0x33, 0x99),
    MAKEPALENTRY(0xCC, 0x33, 0xCC),
    MAKEPALENTRY(0xCC, 0x33, 0xFF),
    MAKEPALENTRY(0xCC, 0x66, 0x00),
    MAKEPALENTRY(0xCC, 0x66, 0x33),
    MAKEPALENTRY(0xCC, 0x66, 0x66),
    MAKEPALENTRY(0xCC, 0x66, 0x99),
    MAKEPALENTRY(0xCC, 0x66, 0xCC),
    MAKEPALENTRY(0xCC, 0x66, 0xFF),
    MAKEPALENTRY(0xCC, 0x99, 0x00),
    MAKEPALENTRY(0xCC, 0x99, 0x33),
    MAKEPALENTRY(0xCC, 0x99, 0x66),
    MAKEPALENTRY(0xCC, 0x99, 0x99),
    MAKEPALENTRY(0xCC, 0x99, 0xCC),
    MAKEPALENTRY(0xCC, 0x99, 0xFF),
    MAKEPALENTRY(0xCC, 0xCC, 0x00),
    MAKEPALENTRY(0xCC, 0xCC, 0x33),
    MAKEPALENTRY(0xCC, 0xCC, 0x66),
    MAKEPALENTRY(0xCC, 0xCC, 0x99),
    MAKEPALENTRY(0xCC, 0xCC, 0xCC),
    MAKEPALENTRY(0xCC, 0xCC, 0xFF),
    MAKEPALENTRY(0xCC, 0xFF, 0x00),
    MAKEPALENTRY(0xCC, 0xFF, 0x33),
    MAKEPALENTRY(0xCC, 0xFF, 0x66),
    MAKEPALENTRY(0xCC, 0xFF, 0x99),
    MAKEPALENTRY(0xCC, 0xFF, 0xCC),
    MAKEPALENTRY(0xCC, 0xFF, 0xFF),
    MAKEPALENTRY(0xFF, 0x00, 0x00),
    MAKEPALENTRY(0xFF, 0x00, 0x33),
    MAKEPALENTRY(0xFF, 0x00, 0x66),
    MAKEPALENTRY(0xFF, 0x00, 0x99),
    MAKEPALENTRY(0xFF, 0x00, 0xCC),
    MAKEPALENTRY(0xFF, 0x00, 0xFF),
    MAKEPALENTRY(0xFF, 0x33, 0x00),
    MAKEPALENTRY(0xFF, 0x33, 0x33),
    MAKEPALENTRY(0xFF, 0x33, 0x66),
    MAKEPALENTRY(0xFF, 0x33, 0x99),
    MAKEPALENTRY(0xFF, 0x33, 0xCC),
    MAKEPALENTRY(0xFF, 0x33, 0xFF),
    MAKEPALENTRY(0xFF, 0x66, 0x00),
    MAKEPALENTRY(0xFF, 0x66, 0x33),
    MAKEPALENTRY(0xFF, 0x66, 0x66),
    MAKEPALENTRY(0xFF, 0x66, 0x99),
    MAKEPALENTRY(0xFF, 0x66, 0xCC),
    MAKEPALENTRY(0xFF, 0x66, 0xFF),
    MAKEPALENTRY(0xFF, 0x99, 0x00),
    MAKEPALENTRY(0xFF, 0x99, 0x33),
    MAKEPALENTRY(0xFF, 0x99, 0x66),
    MAKEPALENTRY(0xFF, 0x99, 0x99),
    MAKEPALENTRY(0xFF, 0x99, 0xCC),
    MAKEPALENTRY(0xFF, 0x99, 0xFF),
    MAKEPALENTRY(0xFF, 0xCC, 0x00),
    MAKEPALENTRY(0xFF, 0xCC, 0x33),
    MAKEPALENTRY(0xFF, 0xCC, 0x66),
    MAKEPALENTRY(0xFF, 0xCC, 0x99),
    MAKEPALENTRY(0xFF, 0xCC, 0xCC),
    MAKEPALENTRY(0xFF, 0xCC, 0xFF),
    MAKEPALENTRY(0xFF, 0xFF, 0x00),
    MAKEPALENTRY(0xFF, 0xFF, 0x33),
    MAKEPALENTRY(0xFF, 0xFF, 0x66),
    MAKEPALENTRY(0xFF, 0xFF, 0x99),
    MAKEPALENTRY(0xFF, 0xFF, 0xCC),
    MAKEPALENTRY(0xFF, 0xFF, 0xFF)
};

/**************************************************************************\
*
* Function Description:
*
*   Get default color palette for the specified pixel format
*
* Arguments:
*
*   pixfmt - Specifies the pixel format
*       must be one of the indexed color formats
*
* Return Value:
*
*   Pointer to the requested default color palette
*
\**************************************************************************/

const ColorPalette*
GetDefaultColorPalette(
    PixelFormatID pixfmt
    )
{
    const ColorPalette* pal;

    switch (pixfmt)
    {
    case PIXFMT_1BPP_INDEXED:

        pal = (const ColorPalette*) &Default1bppColorPalette;
        break;

    case PIXFMT_4BPP_INDEXED:
        pal = (const ColorPalette*) &Default4bppColorPalette;
        break;

    case PIXFMT_8BPP_INDEXED:
        pal = (const ColorPalette*) &Default8bppColorPalette;
        break;

    default:
        RIP(("Invalid pixel format in GetDefaultColorPalette"));
        pal = NULL;
        break;
    }

    return pal;
}


/**************************************************************************\
*
* Function Description:
*
*   Make a copy of the specified color palette
*
* Arguments:
*
*   oldpal - Specifies the palette to be copied
*   useCoalloc - Use CoTaskMemAlloc or malloc to allocate memory?
*
* Return Value:
*
*   Pointer to the new copy of the palette
*   NULL if there is an error
*
\**************************************************************************/

ColorPalette*
CloneColorPalette(
    const ColorPalette* oldpal,
    BOOL useCoalloc
    )
{

    // If we don't have an old palette then we can't create one
    if (oldpal == NULL)
    {
        return NULL;
    }

    // Allocate memory for the new palette

    ColorPalette* newpal;
    UINT size;

    size = offsetof(ColorPalette, Entries) + oldpal->Count * sizeof(ARGB);
    newpal = (ColorPalette*) (useCoalloc ? GpCoAlloc(size) : GpMalloc(size));

    if (newpal != NULL)
    {
        // Copy the input palette contents

        memcpy(newpal, oldpal, size);
    }
    else
    {
        WARNING(("Out of memory in CloneColorPalette"));
    }

    return newpal;
}

/**************************************************************************\
*
* Function Description:
*
* Make a copy of the specified color palette, padding the end so that
* the result has the given number of entries.
*
* Arguments:
*
*   oldpal     - Specifies the palette to be copied
*   numEntries - The number of entries the new palette should have
*   fillColor  - The color to use for the extra entries (if any)
*
* Notes:
*
*   Doesn't handle shrinks. numEntries must be at least as much as the
*   number of entries in the original palette.
*
* Return Value:
*
*   Pointer to the new copy of the palette
*   NULL if there is an error
*
\**************************************************************************/

ColorPalette*
CloneColorPaletteResize(
    const ColorPalette* oldpal,
    UINT numEntries,
    ARGB fillColor
    )
{
    ASSERT(numEntries >= oldpal->Count);
    
    // Allocate memory for the new palette

    ColorPalette* newpal;
    UINT oldsize, newsize;

    oldsize = offsetof(ColorPalette, Entries) + oldpal->Count * sizeof(ARGB);
    newsize = oldsize + (numEntries - oldpal->Count) * sizeof(ARGB);
    
    newpal = static_cast<ColorPalette*>(GpMalloc(newsize));

    if (newpal != NULL)
    {
        // Copy the input palette contents

        memcpy(newpal, oldpal, oldsize);
        newpal->Count = numEntries;
        
        UINT i;
        ARGB *ptr = &(newpal->Entries[oldpal->Count]);
        
        for (i=oldpal->Count;i<numEntries;i++)
        {
            *ptr++ = fillColor;
        }
    }
    else
    {
        WARNING(("Out of memory in CloneColorPaletteResize"));
    }

    return newpal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\colorpal.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   colorpal.hpp
*
* Abstract:
*
*   Color palette related declarations
*
* Revision History:
*
*   05/17/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _COLORPAL_HPP
#define _COLORPAL_HPP

//
// Return the default color palette for the specified pixel format
//

const ColorPalette*
GetDefaultColorPalette(
    PixelFormatID pixfmt
    );

//
// Make a copy of the specified color palette
//

ColorPalette*
CloneColorPalette(
    const ColorPalette* oldpal,
    BOOL useCoalloc = FALSE
    );

//
// Make a copy of the specified color palette, padding the end so that
// the result has the given number of entries.
//

ColorPalette*
CloneColorPaletteResize(
    const ColorPalette* oldpal,
    UINT numEntries,
    ARGB fillColor
    );

#endif // !_COLORPAL_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\filestream.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   filestream.hpp
*
* Abstract:
*
*   Wrap an IStream interface on top of a file
*
* Revision History:
*
*   07/02/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _FILESTREAM_HPP
#define _FILESTREAM_HPP

//
// Multi-thread semantics:
//  FILESTREAM_USEBUSYLOCK - busy lock
//  FILESTREAM_USEWAITLOCK - wait lock
//  FILESTREAM_USENOLOCK - no lock
//

#define FILESTREAM_USEBUSYLOCK

#if defined(FILESTREAM_USEBUSYLOCK)

//
// Busy lock
//

#define DECLARE_FILESTREAMLOCK \
        GpLockable objectLock;

#define ACQUIRE_FILESTREAMLOCK \
        GpLock fsLock(&objectLock); \
        if (fsLock.LockFailed()) \
            return HRESULT_FROM_WIN32(ERROR_BUSY);

#elif defined(FILESTREAM_USEWAITLOCK)

//
// Wait lock
//

class GpFileStreamLockable
{
public:
    GpFileStreamLockable()
    {
        InitializeCriticalSection(&critsect);
    }

    ~GpFileStreamLockable()
    {
        DeleteCriticalSection(&critsect);
    }

private:
    CRITICAL_SECTION critsect;
};

class GpFileStreamLock
{
public:
    GpFileStreamLock(CRITICAL_SECTION* critsect)
    {
        this->critsect = critsect;
        EnterCriticalSection(critsect);
    }

    ~GpFileStreamLock()
    {
        LeaveCriticalSection(critsect);
    }

private:
    CRITICAL_SECTION* critsect;
};

#define DECLARE_FILESTREAMLOCK \
        GpFileStreamLockable objectLock;

#define ACQUIRE_FILESTREAMLOCK \
        GpFileStreamLock fsLock(&objectLock);

#else // FILESTREAM_USENOLOCK

//
// No lock
//

#define DECLARE_FILESTREAMLOCK
#define ACQUIRE_FILESTREAMLOCK

#endif //  // FILESTREAM_USENOLOCK


class GpFileStream : public IUnknownBase<IStream>
{
public:

    GpFileStream()
    {
        fileHandle = INVALID_HANDLE_VALUE;
        filename = NULL;
        accessMode = 0;
    }

    ~GpFileStream()
    {
        if (fileHandle != INVALID_HANDLE_VALUE)
            CloseHandle(fileHandle);
        
        GpFree(filename);
    }

    HRESULT InitFile(const WCHAR* filename, UINT mode);

    STDMETHOD(Read)(
        VOID* buf,
        ULONG cb,
        ULONG* cbRead
        );

    STDMETHOD(Seek)(
        LARGE_INTEGER offset,
        DWORD origin,
        ULARGE_INTEGER* newPos
        );

    STDMETHOD(Stat)(
        STATSTG* statstg,
        DWORD statFlag
        );

    STDMETHOD(Write)(
        const VOID* buf,
        ULONG cb,
        ULONG* cbWritten
        );

    STDMETHOD(CopyTo)(
        IStream* stream,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER* cbRead,
        ULARGE_INTEGER* cbWritten
        );

    STDMETHOD(SetSize)(
        ULARGE_INTEGER newSize
        );

    STDMETHOD(Commit)(
        DWORD commitFlags
        );

    STDMETHOD(Revert)();

    STDMETHOD(LockRegion)(
        ULARGE_INTEGER offset,
        ULARGE_INTEGER cb,
        DWORD lockType
        );

    STDMETHOD(UnlockRegion)(
        ULARGE_INTEGER offset,
        ULARGE_INTEGER cb,
        DWORD lockType
        );

    STDMETHOD(Clone)(
        IStream** stream
        );

private:

    DECLARE_FILESTREAMLOCK

    HANDLE fileHandle;
    WCHAR* filename;
    UINT accessMode;
};

#endif // !_FILESTREAM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\convertfmt.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   Bitmap format conversion
*
* Abstract:
*
*   Convert bitmap data between different pixel formats
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*   09/30/1999 agodfrey
*       Moved the ScanlineConverter to 'EpFormatConverter' in Engine\Render
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Copy a scanline from an unaligned source buffer to
*   an aligned destination buffer.
*
* Arguments:
*
*   dst - Pointer to the destination buffer
*   src - Pointer to the source buffer
*   totalBits - Total number of bits for the scanline
*   startBit - Number of source bits to skip
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
ReadUnalignedScanline(
    BYTE* dst,
    const BYTE* src,
    UINT totalBits,
    UINT startBit
    )
{
    // Process the whole bytes in the destination
    // NOTE: we probably could be faster doing DWORD reads/writes
    // at the expense of more complicated code. Since this code
    // path is rare, we'll take the simple route.

    UINT bytecnt = totalBits >> 3;
    UINT rem = 8 - startBit;

    while (bytecnt--)
    {
        *dst++ = (src[0] << startBit) | (src[1] >> rem);
        src++;
    }

    // Handle the last partial byte

    if ((totalBits &= 7) != 0)
    {
        BYTE mask = ~(0xff >> totalBits);
        BYTE val = (src[0] << startBit);

        if (totalBits > rem)
            val |= (src[1] >> rem);

        *dst = (*dst & ~mask) | (val & mask);
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Copy a scanline from an aligned source buffer to
*   an unaligned destination buffer.
*
* Arguments:
*
*   dst - Pointer to the destination buffer
*   src - Pointer to the source buffer
*   totalBits - Total number of bits for the scanline
*   startBit - Number of destination bits to skip
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
WriteUnalignedScanline(
    BYTE* dst,
    const BYTE* src,
    UINT totalBits,
    UINT startBit
    )
{
    UINT rem = 8-startBit;
    BYTE mask, val;

    // Special case: startBit+totalBits < 8
    //  i.e. destination fits entirely in a partial byte

    if (totalBits < rem)
    {
        mask = (0xff >> startBit);
        mask ^= (mask >> totalBits);

        *dst = (*dst & ~mask) | ((*src >> startBit) & mask);
        return;
    }

    // Handle the first partial destination byte

    *dst = (*dst & ~(0xff >> startBit)) | (*src >> startBit);
    dst++;
    totalBits -= rem;

    // Handle the whole destination bytes

    UINT bytecnt = totalBits >> 3;

    while (bytecnt--)
    {
        *dst++ = (src[0] << rem) | (src[1] >> startBit);
        src++;
    }

    // Handle the last partial destination byte

    if ((totalBits &= 7) != 0)
    {
        mask = ~(0xff >> totalBits);
        val = src[0] << rem;

        if (totalBits > startBit)
            val |= src[1] >> startBit;

        *dst = (*dst & ~mask) | (val & mask);
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Perform conversion between various pixel data formats
*
* Arguments:
*
*   dstbmp - Specifies the destination bitmap data buffer
*   dstpal - Specifies the destination color palette, if any
*   srcbmp - Specifies the source bitmap data buffer
*   srcpal - Specifies the source color palette, if any
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
ConvertBitmapData(
    const BitmapData* dstbmp,
    const ColorPalette* dstpal,
    const BitmapData* srcbmp,
    const ColorPalette* srcpal
    )
{
    ASSERT(dstbmp->Width == srcbmp->Width &&
           dstbmp->Height == srcbmp->Height);

    // Create a format conversion object

    EpFormatConverter linecvt;
    HRESULT hr;

    hr = linecvt.Initialize(dstbmp, dstpal, srcbmp, srcpal);

    if (SUCCEEDED(hr))
    {
        const BYTE* s = (const BYTE*) srcbmp->Scan0;
        BYTE* d = (BYTE*) dstbmp->Scan0;
        UINT y = dstbmp->Height;

        // Convert one scanline at a time

        while (y--)
        {
            linecvt.Convert(d, s);
            s += srcbmp->Stride;
            d += dstbmp->Stride;
        }
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Perform conversion between various pixel data formats
*   The starting pixel is not on a byte boundary in the source bitmap.
*
* Arguments:
*
*   dstbmp - Specifies the destination bitmap data buffer
*   dstpal - Specifies the destination color palette, if any
*   srcbmp - Specifies the source bitmap data buffer
*   srcpal - Specifies the source color palette, if any
*   startBit - Number of bits to skip
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
ConvertBitmapDataSrcUnaligned(
    const BitmapData* dstbmp,
    const ColorPalette* dstpal,
    const BitmapData* srcbmp,
    const ColorPalette* srcpal,
    UINT startBit
    )
{
    ASSERT(startBit > 0 && startBit <= 7);
    ASSERT(GetPixelFormatSize(srcbmp->PixelFormat) % 8 != 0);

    ASSERT(dstbmp->Width == srcbmp->Width &&
           dstbmp->Height == srcbmp->Height);

    // Create a format converter object

    EpFormatConverter linecvt;
    HRESULT hr;
    UINT totalBits;

    BYTE stackbuf[512];
    GpTempBuffer tempbuf(stackbuf, sizeof(stackbuf));

    totalBits = srcbmp->Width * GetPixelFormatSize(srcbmp->PixelFormat);
    hr = linecvt.Initialize(dstbmp, dstpal, srcbmp, srcpal);

    // Allocate temporary memory to hold byte-aligned source scanline

    if (SUCCEEDED(hr) &&
        !tempbuf.Realloc(STRIDE_ALIGNMENT((totalBits + 7) >> 3)))
    {
        WARNING(("Out of memory"));
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        const BYTE* s = (const BYTE*) srcbmp->Scan0;
        BYTE* d = (BYTE*) dstbmp->Scan0;
        BYTE* t = (BYTE*) tempbuf.GetBuffer();
        UINT y = dstbmp->Height;

        // Convert one scanline at a time

        while (y--)
        {
            // Copy source scanline into the byte-aligned buffer

            ReadUnalignedScanline(t, s, totalBits, startBit);
            s += srcbmp->Stride;

            linecvt.Convert(d, t);
            d += dstbmp->Stride;
        }
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Perform conversion between various pixel data formats
*   The starting pixel is not on a byte boundary in the destination bitmap.
*
* Arguments:
*
*   dstbmp - Specifies the destination bitmap data buffer
*   dstpal - Specifies the destination color palette, if any
*   srcbmp - Specifies the source bitmap data buffer
*   srcpal - Specifies the source color palette, if any
*   startBit - Number of bits to skip
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
ConvertBitmapDataDstUnaligned(
    const BitmapData* dstbmp,
    const ColorPalette* dstpal,
    const BitmapData* srcbmp,
    const ColorPalette* srcpal,
    UINT startBit
    )
{
    ASSERT(startBit > 0 && startBit <= 7);
    ASSERT(GetPixelFormatSize(dstbmp->PixelFormat) % 8 != 0);

    ASSERT(dstbmp->Width == srcbmp->Width &&
           dstbmp->Height == srcbmp->Height);

    // Create a format converter object

    EpFormatConverter linecvt;
    HRESULT hr;
    UINT totalBits;

    BYTE stackbuf[512];
    GpTempBuffer tempbuf(stackbuf, sizeof(stackbuf));

    totalBits = dstbmp->Width * GetPixelFormatSize(dstbmp->PixelFormat);
    hr = linecvt.Initialize(dstbmp, dstpal, srcbmp, srcpal);

    // Allocate temporary memory to hold byte-aligned source scanline

    if (SUCCEEDED(hr) &&
        !tempbuf.Realloc(STRIDE_ALIGNMENT((totalBits + 7) >> 3)))
    {
        WARNING(("Out of memory"));
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        const BYTE* s = (const BYTE*) srcbmp->Scan0;
        BYTE* d = (BYTE*) dstbmp->Scan0;
        BYTE* t = (BYTE*) tempbuf.GetBuffer();
        UINT y = dstbmp->Height;

        // Convert one scanline at a time

        while (y--)
        {
            linecvt.Convert(t, s);
            s += srcbmp->Stride;

            // Copy the byte-aligned buffer to destination scanline

            WriteUnalignedScanline(d, t, totalBits, startBit);
            d += dstbmp->Stride;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\icmdll.cpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   icmdll.cpp
*
* Abstract:
*
*   Implementation of functions to hook ICM 2.0
*
\**************************************************************************/

#include "precomp.hpp"

#include "..\..\runtime\critsec.hpp"

typedef enum {
    Unitialized = 0,
    Loaded,
    LoadFailed
} IcmDllLoadState;

IcmDllLoadState IcmState = Unitialized;

HMODULE ghInstICMDll = NULL;
        
OpenColorProfileProc pfnOpenColorProfile =
    (OpenColorProfileProc) NULL;

OpenColorProfileWProc pfnOpenColorProfileW =
    (OpenColorProfileWProc) NULL;

CloseColorProfileProc pfnCloseColorProfile =
    (CloseColorProfileProc) NULL;

CreateMultiProfileTransformProc pfnCreateMultiProfileTransform = 
    (CreateMultiProfileTransformProc) NULL;

DeleteColorTransformProc pfnDeleteColorTransform =
    (DeleteColorTransformProc) NULL;

TranslateBitmapBitsProc pfnTranslateBitmapBits =
    (TranslateBitmapBitsProc) NULL;

/**************************************************************************\
*
* Function Description:
*   Loads the ICM dll if it's there
*
\**************************************************************************/

HRESULT LoadICMDll()
{
    HRESULT hr;

    {
        // Protect access to the global variables in this scope:

        LoadLibraryCriticalSection llcs;

        if (IcmState == Loaded)
        {
            hr = S_OK;
        }
        else if (IcmState == LoadFailed)
        {
            hr = E_FAIL;
        }
        else
        {
            // Assume failure; set success if DLL loads and we hook needed
            // functions:

            hr = E_FAIL;
            IcmState = LoadFailed;

            ghInstICMDll = LoadLibraryA("mscms.dll");
            if(ghInstICMDll)
            {
                pfnOpenColorProfile = (OpenColorProfileProc) GetProcAddress(
                    ghInstICMDll, "OpenColorProfileA");

                pfnOpenColorProfileW = (OpenColorProfileWProc) GetProcAddress(
                    ghInstICMDll, "OpenColorProfileW");

                pfnCreateMultiProfileTransform =
                    (CreateMultiProfileTransformProc)GetProcAddress(
                    ghInstICMDll, "CreateMultiProfileTransform");

                pfnTranslateBitmapBits =
                    (TranslateBitmapBitsProc)GetProcAddress(
                    ghInstICMDll, "TranslateBitmapBits");

                pfnCloseColorProfile =
                    (CloseColorProfileProc)GetProcAddress(
                    ghInstICMDll, "CloseColorProfile");

                pfnDeleteColorTransform =
                    (DeleteColorTransformProc)GetProcAddress(
                    ghInstICMDll, "DeleteColorTransform");

                if(pfnOpenColorProfile &&
                   pfnOpenColorProfileW &&
                   pfnCloseColorProfile &&
                   pfnCreateMultiProfileTransform &&
                   pfnDeleteColorTransform &&
                   pfnTranslateBitmapBits)
                {
                    IcmState = Loaded;
                    hr = S_OK;
                }
            }
            else
            {
                WARNING(("Failed to load mscms.dll with code %d", GetLastError()));
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\filestream.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   filestream.hpp
*
* Abstract:
*
*   Wrap an IStream interface on top of a file
*
* Revision History:
*
*   07/02/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   Initialize a file stream object
*
* Arguments:
*
*   filename - Specifies the name of the file
*   mode - Specifies the desired access mode
*       STGM_READ, STGM_WRITE, or STGM_READWRITE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::InitFile(
    const WCHAR* filename,
    UINT mode
    )
{
    if (mode != STGM_READ &&
        mode != STGM_WRITE &&
        mode != STGM_READWRITE)
    {
        return E_INVALIDARG;
    }

    // Make a copy of the filename string

    this->filename = UnicodeStringDuplicate(filename);

    if (!this->filename)
        return E_OUTOFMEMORY;

    // Open the file for reading and/or writing

    switch (accessMode = mode)
    {
    case STGM_READ:

        // Set access mode to READ
        // Set share mode as READ which means the subsequent open operations on
        //   this file will succeed if and only if it is a READ operation.
        //   (NOTE: we can't put FILE_SHARE_WRITE here to enable the subsequent
        //   write operation on this image. The reason is that we do a memory
        //   mapping below. If we allow the user writes to the same file, it
        //   means that the decoder and encoder will point to the same piece of
        //   data in memory. This will damage the result image if we write some
        //   bits and read from it later.
        // OPEN_EXISTING means to open the file. The function fails if the file
        //   does not exist. 

        fileHandle = _CreateFile(
                        filename,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL);
        break;

    case STGM_WRITE:

        // Set access mode to WRITE
        // Set share mode as READ only, which means the subsequent open
        //   operations on this file will succeed if and only if it is a READ
        //   operation.
        //   (NOTE: with this share mode, we open the specified file here for
        //   writing. The user can also open it later for reading only. But we
        //   don't allow it for writing because in our multi-frame image save
        //   case, we will keep the file open till all the frames are written.
        //   If we allow the FILE_SHARE_WRITE, and the user opens it for writing
        //   while we are in the middle of saving multi-frame image. Bad thing
        //   will happen).
        // OPEN_ALWAYS means to open the file, if it exists. If the file does
        //   not exist, the function creates the file.

        fileHandle = _CreateFile(
                        filename,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL);
        if (fileHandle != INVALID_HANDLE_VALUE)

        {
            // Set the "end of file".
            // This is to prevent the following problem:
            // The caller asks us to write to an exisitng file. If the new file
            // size is smaller than the original one, the file size of the final
            // result file will be the same as the old one, that is, leave some
            // garbage at the end of the new file.
            
            SetEndOfFile(fileHandle);
        }

        break;

    case STGM_READWRITE:

        fileHandle = _CreateFile(
                        filename,
                        GENERIC_READ|GENERIC_WRITE,
                        0,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL);
        break;
    }

    if (fileHandle == INVALID_HANDLE_VALUE)
        return GetWin32HRESULT();

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Read data from a file stream
*
* Arguments:
*
*   buf - Points to buffer into which the stream is read
*   cb - Specifies the number of bytes to read
*   *cbRead - Returns the number of bytes actually read
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::Read(
    VOID* buf,
    ULONG cb,
    ULONG* cbRead
    )
{
    ACQUIRE_FILESTREAMLOCK

    HRESULT hr;

    hr = ReadFile(fileHandle, buf, cb, &cb, NULL) ?
                S_OK :
                GetWin32HRESULT();

    if (cbRead)
        *cbRead = cb;
    
    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Move the seek pointer in a file stream
*
* Arguments:
*
*   offset - Specifies the amount to move
*   origin - Specifies the origin of the movement
*   newPos - Returns the new seek pointer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::Seek(
    LARGE_INTEGER offset,
    DWORD origin,
    ULARGE_INTEGER* newPos
    )
{
    ACQUIRE_FILESTREAMLOCK

    // Interpret the value of 'origin' parameter

    switch (origin)
    {
    case STREAM_SEEK_SET:
        origin = FILE_BEGIN;
        break;

    case STREAM_SEEK_CUR:
        origin = FILE_CURRENT;
        break;

    case STREAM_SEEK_END:
        origin = FILE_END;
        break;
    
    default:
        return E_INVALIDARG;
    }

    // Set file pointer

    DWORD lowPart;
    LONG highPart = offset.HighPart;

    lowPart = SetFilePointer(fileHandle, offset.LowPart, &highPart, origin);

    if (lowPart == 0xffffffff && GetLastError() != NO_ERROR)
        return GetWin32HRESULT();

    if (newPos)
    {
        newPos->LowPart = lowPart;
        newPos->HighPart = highPart;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Get information about file stream
*
* Arguments:
*
*   stat - Output buffer for returning file stream information
*   flags - Misc. flag bits
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::Stat(
    STATSTG* stat,
    DWORD flags
    )
{
    ACQUIRE_FILESTREAMLOCK

    stat->type = STGTY_STREAM;
    stat->grfMode = accessMode;
    stat->grfStateBits = stat->reserved = 0;

    ZeroMemory(&stat->clsid, sizeof(stat->clsid));

    // !!! TODO
    //  We currently don't support locking operations

    stat->grfLocksSupported = 0;

    // Get file size information

    stat->cbSize.LowPart = GetFileSize(fileHandle, &stat->cbSize.HighPart);

    if (stat->cbSize.LowPart == 0xffffffff &&
        GetLastError() != NO_ERROR)
    {
        return GetWin32HRESULT();
    }

    // Get file time information

    if (!GetFileTime(fileHandle, &stat->ctime, &stat->atime, &stat->mtime))
        return GetWin32HRESULT();

    // Copy filename, if necessary

    if (flags & STATFLAG_NONAME)
        stat->pwcsName = NULL;
    else
    {
        INT cnt = SizeofWSTR(filename);

        stat->pwcsName = (WCHAR*) GpCoAlloc(cnt);

        if (!stat->pwcsName)
            return E_OUTOFMEMORY;
        
        memcpy(stat->pwcsName, filename, cnt);
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Write data into a file stream
*
* Arguments:
*
*   buf - Pointer to buffer of data to be written
*   cb - Specifies the number of bytes to write
*   cbWritten - Returns the number of bytes actually written
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::Write(
    const VOID* buf,
    ULONG cb,
    ULONG* cbWritten
    )
{
    ACQUIRE_FILESTREAMLOCK

    HRESULT hr;

    hr = WriteFile(fileHandle, buf, cb, &cb, NULL) ?
                S_OK :
                GetWin32HRESULT();

    if (cbWritten)
        *cbWritten = cb;

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Copy a specified number of bytes from the current
*   file stream to another stream.
*
* Arguments:
*
*   stream - Specifies the destination stream
*   cb - Specifies the number of bytes to copy
*   cbRead - Returns the number of bytes actually read
*   cbWritten - Returns the number of bytes actually written
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::CopyTo(
    IStream* stream,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER* cbRead,
    ULARGE_INTEGER* cbWritten
    )
{
    // !!! TODO
    WARNING(("GpFileStream::CopyTo not yet implemented"));

    return E_NOTIMPL;
}


/**************************************************************************\
*
* Function Description:
*
*   Changes the size of the file stream object
*
* Arguments:
*
*   newSize - Specifies the new size of the file stream
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::SetSize(
    ULARGE_INTEGER newSize
    )
{
    // !!! TODO
    WARNING(("GpFileStream::SetSize not yet implemented"));

    return E_NOTIMPL;
}


/**************************************************************************\
*
* Function Description:
*
*   Commit changes made to a file stream
*
* Arguments:
*
*   commitFlags - Specifies how changes are commited
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::Commit(
    DWORD commitFlags
    )
{
    ACQUIRE_FILESTREAMLOCK

    if (accessMode != STGM_READ &&
        !(commitFlags & STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE) &&
        !FlushFileBuffers(fileHandle))
    {
        return GetWin32HRESULT();
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Discards all changes that have been made to a transacted stream
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::Revert()
{
    WARNING(("GpFileStream::Revert not supported"));
    return E_NOTIMPL;
}


/**************************************************************************\
*
* Function Description:
*
*   Restricts access to a specified range of bytes in a file stream
*
* Arguments:
*
*   offset - Specifies the beginning of the byte range
*   cb - Specifies the length of the byte range
*   lockType - Specifies the lock type
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::LockRegion(
    ULARGE_INTEGER offset,
    ULARGE_INTEGER cb,
    DWORD lockType
    )
{
    // !!! TODO
    WARNING(("GpFileStream::LockRegion not yet implemented"));

    return E_NOTIMPL;
}


/**************************************************************************\
*
* Function Description:
*
*   Remove the access restrictions on a range of byte
*   previously locked through a LockRegion call
*
* Arguments:
*
*   offset - Specifies the beginning of the byte range
*   cb - Specifies the length of the byte range
*   lockType - Specifies the lock type
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::UnlockRegion(
    ULARGE_INTEGER offset,
    ULARGE_INTEGER cb,
    DWORD lockType
    )
{
    // !!! TODO
    WARNING(("GpFileStream::UnlockRegion not yet implemented"));

    return E_NOTIMPL;
}


/**************************************************************************\
*
* Function Description:
*
*   Creates a new stream object with its own seek pointer
*   that references the same bytes as the original stream. 
*
* Arguments:
*
*   stream - Returns the pointer to the cloned stream
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::Clone(
    IStream** stream
    )
{
    WARNING(("GpFileStream::Clone not supported"));
    return E_NOTIMPL;
}


/**************************************************************************\
*
* Function Description:
*
*   Create an IStream on top of a file for writing
*
* Arguments:
*
*   filename - Specifies the filename
*   stream - Returns a pointer to the newly created stream object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
CreateStreamOnFileForWrite(
    const WCHAR* filename,
    IStream** stream
    )
{
    GpFileStream* fs;

    fs = new GpFileStream();

    if (fs == NULL)
        return E_OUTOFMEMORY;
    
    HRESULT hr = fs->InitFile(filename, STGM_WRITE);

    if (FAILED(hr))
        delete fs;
    else
        *stream = static_cast<IStream*>(fs);
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\decodedimg.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   decodedimg.hpp
*
* Abstract:
*
*   GpDecodedImage class declarations
*
* Revision History:
*
*   05/26/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _DECODEDIMG_HPP
#define _DECODEDIMG_HPP

//--------------------------------------------------------------------------
// GpDecodedImage class
//--------------------------------------------------------------------------

class GpDecodedImage : public IUnknownBase<IImage>
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagDecodedImage) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid DecodedImage");
        }
    #endif

        return (Tag == ObjectTagDecodedImage);
    }
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagDecodedImage : ObjectTagInvalid;
    }

public:

    static HRESULT
    CreateFromFile(
        const WCHAR* filename,
        GpDecodedImage** image
        );

    static HRESULT
    CreateFromStream(
        IStream* stream,
        GpDecodedImage** image
        );

    //------------------------------------------------------------
    // Public IImage interface methods
    //------------------------------------------------------------

    // Get the device-independent physical dimension of the image
    //  in unit of 0.01mm

    STDMETHOD(GetPhysicalDimension)(
        OUT SIZE* size
        );

    // Get basic image information

    STDMETHOD(GetImageInfo)(
        OUT ImageInfo* imageInfo
        );

    // Set image flags

    STDMETHOD(SetImageFlags)(
        IN UINT flags
        );

    // Display the image in a GDI device context

    STDMETHOD(Draw)(
        IN HDC hdc,
        IN const RECT* dstRect,
        IN OPTIONAL const RECT* srcRect
        );

    // Push image data into an IImageSink

    STDMETHOD(PushIntoSink)(
        IN IImageSink* sink
        );

    // Get a thumbnail representation for the image object

    STDMETHOD(GetThumbnail)(
        IN OPTIONAL UINT thumbWidth,
        IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage
        );

    STDMETHOD(GetFrameCount)(
        IN const GUID* dimensionID,
        OUT UINT* count
        );

    STDMETHOD(GetFrameDimensionsCount)(
        OUT UINT* count
        );

    STDMETHOD(GetFrameDimensionsList)(
        OUT GUID* dimensionIDs,
        IN OUT UINT count
        );
    
    STDMETHOD(SelectActiveFrame)(
        IN const GUID* dimensionID,
        IN UINT frameIndex
        );

    // Query decoder capability

    STDMETHOD(QueryDecoderParam)(
        IN GUID Guid
        );

    // Set decoder parameter

    STDMETHOD(SetDecoderParam)(
        IN GUID Guid,
        IN UINT Length,
        IN PVOID Value
        );

    STDMETHOD(GetPropertyCount)(
        OUT UINT*   numOfProperty
        );

    STDMETHOD(GetPropertyIdList)(
        IN UINT numOfProperty,
        IN OUT PROPID* list
        );

    STDMETHOD(GetPropertyItemSize)(
        IN PROPID propId, 
        OUT UINT* size
        );
    
    STDMETHOD(GetPropertyItem)(
        IN PROPID            propId,
        IN UINT              propSize,
        IN OUT PropertyItem* buffer
        );

    STDMETHOD(GetPropertySize)(
        OUT UINT* totalBufferSize,
		OUT UINT* numProperties
        );

    STDMETHOD(GetAllPropertyItems)(
        IN UINT totalBufferSize,
        IN UINT numProperties,
        IN OUT PropertyItem* allItems
        );

    STDMETHOD(RemovePropertyItem)(
        IN PROPID   propId
        );

    STDMETHOD(SetPropertyItem)(
        IN PropertyItem item
        );

    // Set override resolution (replaces the native resolution)

    STDMETHOD(SetResolution)(
        IN REAL Xdpi,
        IN REAL Ydpi
        );

    // Save the bitmap object to a stream

    HRESULT
    SaveToStream(
        IN IStream* stream,
        IN CLSID* clsidEncoder,
        IN EncoderParameters* encoderParams,
        OUT IImageEncoder** ppEncoderPtr
        );

    // Save the bitmap object to a file

    HRESULT
    SaveToFile(
        IN const WCHAR* filename,
        IN CLSID* clsidEncoder,
        IN EncoderParameters* encoderParams,
        OUT IImageEncoder** ppEncoderPtr
        );
    
    // Append the bitmap object to current encoder object

    HRESULT
    SaveAppend(
        IN const EncoderParameters* encoderParams,
        IN IImageEncoder* destEncoderPtr
        );

    // Get the encoder parameter list size

    HRESULT
    GetEncoderParameterListSize(
        IN  CLSID* clsidEncoder,
        OUT UINT* size
        );

    // Get the encoder parameter list
    
    HRESULT
    GetEncoderParameterList(
        IN CLSID* clsidEncoder,
        IN UINT size,
        OUT EncoderParameters* pBuffer
        );

    // Return the pointer to the real decoder object to the caller

    HRESULT
    GetDecoderPtr(IImageDecoder **ppDecoder)
    {
        HRESULT hr = E_INVALIDARG;
        if (ppDecoder)
        {
            hr = GetImageDecoder();
            if (SUCCEEDED(hr))
            {
                *ppDecoder = decoder;
            }
        }

        return hr;
    }

private:

    GpLockable objectLock;      // object busy lock
    IImageDecoder* decoder;     // ref to decoder object
    IStream* inputStream;       // ref to input data stream
    IImage* decodeCache;        // ref to decoded image cache
    UINT cacheFlags;            // image hints
    BOOL gotProps;              // already asked decoder for properties?
    IPropertySetStorage* propset; // image properties
    REAL xdpiOverride;          // if non-zero, overrides the native dpi
    REAL ydpiOverride;          // if non-zero, overrides the native dpi

    GpDecodedImage(IStream* stream);
    ~GpDecodedImage();

    HRESULT GetImageDecoder();
    HRESULT InternalGetImageInfo(ImageInfo*);
    HRESULT InternalPushIntoSink(IImageSink*);
};

#endif // !_DECODEDIMG_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\comutils.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   comutils.hpp
*
* Abstract:
*
*   COM utility functions and macros
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _COMUTILS_HPP
#define _COMUTILS_HPP

//--------------------------------------------------------------------------
// Macros for incrementing or decrementing COM component count
//--------------------------------------------------------------------------

extern HINSTANCE DllInstance;
extern LONG ComComponentCount;

inline VOID IncrementComComponentCount()
{
    InterlockedIncrement(&ComComponentCount);
}

inline VOID DecrementComComponentCount()
{
    InterlockedDecrement(&ComComponentCount);
}


//--------------------------------------------------------------------------
// Template for implementing IUnknown interface
//
// NOTES:
// 1. We can only handle objects that has one interface other than IUnknown.
// 2. We do not support aggregation.
//--------------------------------------------------------------------------

template <class I> class IUnknownBase : public I
{
public:

    // Query interface: note that we can only handle
    // objects that one interface other than IUnknown.

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv)
    {
        if (riid == IID_IUnknown)
            *ppv = static_cast<IUnknown*>(this);
        else if (riid == __uuidof(I))
            *ppv = static_cast<I*>(this);
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }

        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK;
    }

    // Increment reference count

    STDMETHOD_(ULONG, AddRef)(VOID)
    {
        return InterlockedIncrement(&comRefCount);
    }

    // Decrement reference count

    STDMETHOD_(ULONG, Release)(VOID)
    {
        ULONG count = InterlockedDecrement(&comRefCount);

        if (count == 0)
            delete this;

        return count;
    }

protected:

    LONG comRefCount;

    // Constructor: notice that when an object is first
    // created, its reference count is set to 1.

    IUnknownBase<I>()
    {
        comRefCount = 1;
    }

    // Declare an empty virtual destructor

    virtual ~IUnknownBase<I>() {}
};


//--------------------------------------------------------------------------
// Template for implementing IClassFactory interface
//--------------------------------------------------------------------------

template <class T> class IClassFactoryBase
    : public IUnknownBase<IClassFactory>
{
public:

    // NOTE: We don't count class factory objects in ComComponentCount.
    // This means that the existence of a running class factory is not
    // guaranteed to keep a server loaded in memory.

    // Create a new instance of the component

    STDMETHOD(CreateInstance)(
        IUnknown* outer,
        REFIID riid,
        VOID** ppv
        )
    {
        // We don't support aggregation

        if (outer != NULL)
            return CLASS_E_NOAGGREGATION;

        // Instantiate a new object

        T* obj = new T;

        if (obj == NULL)
            return E_OUTOFMEMORY;

        // Get the requested interface

        HRESULT hr = obj->QueryInterface(riid, ppv);
        obj->Release();

        return hr;
    }

    // Lock/unlock the component server DLL

    STDMETHOD(LockServer)(BOOL lock)
    {
        if (lock)
        {
            IncrementComComponentCount();
        }
        else
        {
            DecrementComComponentCount();
        }

        return S_OK;
    }
};


//--------------------------------------------------------------------------
// Helper function for registering and unregistering a component
//--------------------------------------------------------------------------

struct ComComponentRegData
{
    const CLSID* clsid;
    const WCHAR* compName;
    const WCHAR* progID;
    const WCHAR* progIDNoVer;
    const WCHAR* threading;
};

HRESULT
RegisterComComponent(
    const ComComponentRegData* regdata,
    BOOL registerIt
    );

#endif // !_COMUTILS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\decodedimg.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   decodedimg.cpp
*
* Abstract:
*
*   Implementation of GpDecodedImage class
*
* Revision History:
*
*   05/26/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   Create a GpDecodedImage object from a stream or a file
*
* Arguments:
*
*   stream/filename - Specifies the input data stream or filename
*   image - Returns a pointer to newly created image object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpDecodedImage::CreateFromStream(
    IStream* stream,
    GpDecodedImage** image
    )
{
    if ( image == NULL )
    {
        return E_INVALIDARG;
    }

    GpDecodedImage* pImage = new GpDecodedImage(stream);

    if ( pImage == NULL )
    {
        return E_OUTOFMEMORY;
    }
    else if ( pImage->IsValid() )
    {
        *image = pImage;

        return S_OK;
    }
    else
    {
        delete pImage;

        return E_FAIL;
    }
}// CreateFromStream()

HRESULT
GpDecodedImage::CreateFromFile(
    const WCHAR* filename,
    GpDecodedImage** image
    )
{
    HRESULT hr;
    IStream* stream;

    hr = CreateStreamOnFileForRead(filename, &stream);

    if (SUCCEEDED(hr))
    {
        hr = CreateFromStream(stream, image);
        stream->Release();
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Construct a GpDecodedImage object from an input stream
*
* Arguments:
*
*   stream - Pointer to the input stream
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

GpDecodedImage::GpDecodedImage(
    IStream* stream
    )
{
    // Hold a reference to the input stream

    inputStream = stream;
    inputStream->AddRef();

    // Initialize other fields to their default values

    decoder = NULL;
    decodeCache = NULL;
    cacheFlags = IMGFLAG_READONLY;
    gotProps = FALSE;
    propset = NULL;

    // Set override resolution to zero (i.e., no override)

    xdpiOverride = 0.0;
    ydpiOverride = 0.0;

    SetValid ( GetImageDecoder() == S_OK );
}


/**************************************************************************\
*
* Function Description:
*
*   GpDecodedImage destructor
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

GpDecodedImage::~GpDecodedImage()
{
    if (decodeCache)
        decodeCache->Release();
    
    if (decoder)
    {   
        decoder->TerminateDecoder();
        decoder->Release();
    }
    
    if (inputStream)
        inputStream->Release();

    if (propset)
        propset->Release();

    SetValid(FALSE);    // so we don't use a deleted object
}


/**************************************************************************\
*
* Function Description:
*
*   Get the device-independent physical dimension of the image
*   in unit of 0.01mm
*
* Arguments:
*
*   size - Buffer for returning physical dimension information
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpDecodedImage::GetPhysicalDimension(
    OUT SIZE* size
    )
{
    // Query basic image info

    ImageInfo imageinfo;
    HRESULT hr;

    hr = InternalGetImageInfo(&imageinfo);

    if (SUCCEEDED(hr))
    {
        size->cx = Pixel2HiMetric(imageinfo.Width, imageinfo.Xdpi);
        size->cy = Pixel2HiMetric(imageinfo.Height, imageinfo.Ydpi);
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Get basic information about the decoded image object
*
* Arguments:
*
*   imageInfo - Buffer for returning basic image info
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpDecodedImage::GetImageInfo(
    OUT ImageInfo* imageInfo
    )
{
    // Query basic image info

    HRESULT hr;

    hr = InternalGetImageInfo(imageInfo);

    if (SUCCEEDED(hr))
    {
        // Merge in our own image cache hints

        GpLock lock(&objectLock);

        if (lock.LockFailed())
            hr = IMGERR_OBJECTBUSY;
        else
            imageInfo->Flags = (imageInfo->Flags & 0xffff) | cacheFlags;
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Set image flags
*
* Arguments:
*
*   flags - New image flags
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpDecodedImage::SetImageFlags(
    IN UINT flags
    )
{
    // Only the top half of the image flag is settable.

    if (flags & 0xffff)
        return E_INVALIDARG;

    // Lock the image object

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    // If image caching is being turn off
    // then blow away any cache we may current have

    cacheFlags = flags;

    if (!(flags & IMGFLAG_CACHING) && decodeCache)
    {
        decodeCache->Release();
        decodeCache = NULL;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Display the image in a GDI device context
*
* Arguments:
*
*   hdc - Specifies the destination device context
*   dstRect - Specifies the destination rectangle
*   srcRect - Specifies the source rectangle
*       NULL means the entire image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpDecodedImage::Draw(
    IN HDC hdc,
    IN const RECT* dstRect,
    IN OPTIONAL const RECT* srcRect
    )
{
    // Lock the current image object

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    // !!! TODO
    //  Eventually we'll create an IImageSink object
    //  on top of the destination hdc and then ask
    //  decoder to push image data into that sink.
    //  For now, always decode into a memory bitmap.

    HRESULT hr;

    if (decodeCache == NULL)
    {
        // Allocate a new GpMemoryBitmap object

        GpMemoryBitmap* bmp = new GpMemoryBitmap();

        if (bmp == NULL)
            return E_OUTOFMEMORY;

        // Ask the decoder to push data into the memory bitmap

        hr = InternalPushIntoSink(bmp);

        if (SUCCEEDED(hr))
            hr = bmp->QueryInterface(IID_IImage, (VOID**) &decodeCache);

        bmp->Release();

        if (FAILED(hr))
            return hr;
    }

    // Ask the memory bitmap to draw itself

    hr = decodeCache->Draw(hdc, dstRect, srcRect);

    // Blow away the memory bitmap cache if needed

    if ((cacheFlags & IMGFLAG_CACHING) == 0)
    {
        decodeCache->Release();
        decodeCache = NULL;
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Push image data into an IImageSink
*
* Arguments:
*
*   sink - The sink for receiving image data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpDecodedImage::PushIntoSink(
    IN IImageSink* sink
    )
{
    // Lock the current image object

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    return InternalPushIntoSink(sink);
}

HRESULT
GpDecodedImage::InternalPushIntoSink(
    IImageSink* sink
    )
{
    // Make sure we have a decoder object

    HRESULT hr = GetImageDecoder();

    if (FAILED(hr))
        return hr;

    // Start decoding

    hr = decoder->BeginDecode(sink, propset);

    if (FAILED(hr))
        return hr;

    // Decode the source image

    while ((hr = decoder->Decode()) == E_PENDING)
        Sleep(0);

    // Stop decoding

    return decoder->EndDecode(hr);
}

/**************************************************************************\
*
* Function Description:
*
*   Ask the decoder if it can do the requested operation (color key output,
*   channel seperation for now)
*
* Arguments:
*
*   Guid    - Guid for request the operation (DECODER_TRANSCOLOR,
*             DECODER_OUTPUTCHANNEL)
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   11/22/1999 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpDecodedImage::QueryDecoderParam(
    IN GUID     Guid
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Query decoder capability for the real codec decoder

    hResult = decoder->QueryDecoderParam(Guid);

    return hResult;
}// QueryDecoderParam()

/**************************************************************************\
*
* Function Description:
*
*   Tell the decoder how to output decoded image data (color key output,
*   channel seperation for now)
*
* Arguments:
*
*   Guid    - Guid for request the operation (DECODER_TRANSCOLOR,
*             DECODER_OUTPUTCHANNEL)
*   Length  - Length of the input parameters
*   Value   - Value to set the decode parameter
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   11/22/1999 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpDecodedImage::SetDecoderParam(
    IN GUID     Guid,
    IN UINT     Length,
    IN PVOID    Value
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Set decoder parameters for the real codec decoder

    hResult = decoder->SetDecoderParam(Guid, Length, Value);

    return hResult;
}// SetDecoderParam()

HRESULT
GpDecodedImage::GetPropertyCount(
    OUT UINT*   numOfProperty
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Get property item count from the real codec decoder

    hResult = decoder->GetPropertyCount(numOfProperty);

    return hResult;
}// GetPropertyItemCount()

HRESULT
GpDecodedImage::GetPropertyIdList(
    IN UINT numOfProperty,
  	IN OUT PROPID* list
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Get property item list from the real codec decoder

    hResult = decoder->GetPropertyIdList(numOfProperty, list);

    return hResult;
}// GetPropertyIdList()

HRESULT
GpDecodedImage::GetPropertyItemSize(
    IN PROPID propId,
    OUT UINT* size
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Get property item size from the real codec decoder

    hResult = decoder->GetPropertyItemSize(propId, size);

    return hResult;
}// GetPropertyItemSize()

HRESULT
GpDecodedImage::GetPropertyItem(
    IN PROPID               propId,
    IN  UINT                propSize,
    IN OUT PropertyItem*    buffer
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Get property item from the real codec decoder

    hResult = decoder->GetPropertyItem(propId, propSize, buffer);

    return hResult;
}// GetPropertyItem()

HRESULT
GpDecodedImage::GetPropertySize(
    OUT UINT* totalBufferSize,
    OUT UINT* numProperties
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Get property size from the real codec decoder

    hResult = decoder->GetPropertySize(totalBufferSize, numProperties);

    return hResult;
}// GetPropertySize()

HRESULT
GpDecodedImage::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    IN OUT PropertyItem* allItems
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Get all property items from the real codec decoder

    hResult = decoder->GetAllPropertyItems(totalBufferSize, numProperties,
                                           allItems);

    return hResult;
}// GetAllPropertyItems()

HRESULT
GpDecodedImage::RemovePropertyItem(
    IN PROPID   propId
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Remove this property item from the list

    hResult = decoder->RemovePropertyItem(propId);

    return hResult;
}// RemovePropertyItem()

HRESULT
GpDecodedImage::SetPropertyItem(
    IN PropertyItem item
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Set this property item in the list

    hResult = decoder->SetPropertyItem(item);

    return hResult;
}// SetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Ask the decoder for basic image info
*
* Arguments:
*
*   imageinfo - Pointer to buffer for receiving image info
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpDecodedImage::InternalGetImageInfo(
    ImageInfo* imageInfo
    )
{
    // Lock the current image object

    HRESULT hr;
    GpLock lock(&objectLock);

    if (lock.LockFailed())
        hr = IMGERR_OBJECTBUSY;
    else
    {
        // Make sure we have a decoder object

        hr = GetImageDecoder();

        if (SUCCEEDED(hr))
            hr = decoder->GetImageInfo(imageInfo);

        if ((xdpiOverride > 0.0) && (ydpiOverride > 0.0))
        {
            imageInfo->Xdpi = static_cast<double>(xdpiOverride);
            imageInfo->Ydpi = static_cast<double>(ydpiOverride);
        }
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Ask the decoder for total number of frames in the image
*
* Arguments:
*
*   dimensionID - Dimension ID (PAGE, RESOLUTION, TIME) the caller wants to
*                 get the total number of frame for
*   count       - Total number of frame
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   11/19/1999 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpDecodedImage::GetFrameCount(
    IN const GUID*  dimensionID,
    OUT UINT*       count
    )
{
    // Lock the current image object

    HRESULT hResult;
    GpLock  lock(&objectLock);

    if ( lock.LockFailed() )
    {
        hResult = IMGERR_OBJECTBUSY;
    }
    else
    {
        // Make sure we have a decoder object

        hResult = GetImageDecoder();

        if ( SUCCEEDED(hResult) )
        {
            // Get the frame count from the decoder

            hResult = decoder->GetFrameCount(dimensionID, count);
        }
    }

    return hResult;
}// GetFrameCount()

/**************************************************************************\
*
* Function Description:
*
*     Get the total number of dimensions the image supports
*
* Arguments:
*
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpDecodedImage::GetFrameDimensionsCount(
    UINT* count
    )
{
    // Lock the current image object

    HRESULT hResult;
    GpLock  lock(&objectLock);

    if ( lock.LockFailed() )
    {
        hResult = IMGERR_OBJECTBUSY;
    }
    else
    {
        // Make sure we have a decoder object

        hResult = GetImageDecoder();

        if ( SUCCEEDED(hResult) )
        {
            // Get the frame dimension info from the deocder

            hResult = decoder->GetFrameDimensionsCount(count);
        }
    }

    return hResult;
}// GetFrameDimensionsCount()

/**************************************************************************\
*
* Function Description:
*
*     Get an ID list of dimensions the image supports
*
* Arguments:
*
*     dimensionIDs---Memory buffer to hold the result ID list
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpDecodedImage::GetFrameDimensionsList(
    GUID*   dimensionIDs,
    UINT    count
    )
{
    // Lock the current image object

    HRESULT hResult;
    GpLock  lock(&objectLock);

    if ( lock.LockFailed() )
    {
        hResult = IMGERR_OBJECTBUSY;
    }
    else
    {
        // Make sure we have a decoder object

        hResult = GetImageDecoder();

        if ( SUCCEEDED(hResult) )
        {
            // Get the frame dimension info from the deocder

            hResult = decoder->GetFrameDimensionsList(dimensionIDs, count);
        }
    }

    return hResult;
}// GetFrameDimensionsList()

/**************************************************************************\
*
* Function Description:
*
*   Select the active frame in the bitmap image
*
* Arguments:
*
*   dimensionID  - Dimension ID (PAGE, RESOLUTION, TIME) of where the caller
*                  wants to set the active frame
*   frameIndex   - Index number of the frame to be selected
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   11/19/1999 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpDecodedImage::SelectActiveFrame(
    IN const GUID*  dimensionID,
    IN UINT         frameIndex
    )
{
    // Lock the current image object

    HRESULT hResult;
    GpLock  lock(&objectLock);

    if ( lock.LockFailed() )
    {
        hResult = IMGERR_OBJECTBUSY;
    }
    else
    {
        // Make sure we have a decoder object

        hResult = GetImageDecoder();

        if ( SUCCEEDED(hResult) )
        {
            // Set the active frame in the decoder

            hResult = decoder->SelectActiveFrame(dimensionID, frameIndex);
        }
    }

    return hResult;
}// SelectActiveFrame()

/**************************************************************************\
*
* Function Description:
*
*   Make sure we have a decoder object associated with the image
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
* Note:
*
*   We assume the caller has already locked the current image object.
*
\**************************************************************************/

HRESULT
GpDecodedImage::GetImageDecoder()
{
    ASSERT(inputStream != NULL);

    if (decoder != NULL)
        return S_OK;

    // Create and initialize the decoder object

    return CreateDecoderForStream(inputStream, &decoder, DECODERINIT_NONE);
}


/**************************************************************************\
*
* Function Description:
*
*   Get a thumbnail representation for the image object
*
* Arguments:
*
*   thumbWidth, thumbHeight - Specifies the desired thumbnail size in pixels
*   thumbImage - Return a pointer to the thumbnail image
*       The caller should Release it after using it.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpDecodedImage::GetThumbnail(
    IN OPTIONAL UINT thumbWidth,
    IN OPTIONAL UINT thumbHeight,
    OUT IImage** thumbImage
    )
{
    if (thumbWidth && !thumbHeight ||
        !thumbWidth && thumbHeight)
    {
        return E_INVALIDARG;
    }

    // Ask the decoder for thumbnail image.
    // If one is returned, check if the size matches the requested size.
    //  match: just return the thumbnail returned by the decoder
    //  mismatch: scale the thumbnail returned by the decoder to the desired size

    HRESULT hr;
    IImage* img = NULL;

    {
        GpLock lock(&objectLock);

        if (lock.LockFailed())
            return IMGERR_OBJECTBUSY;

        hr = GetImageDecoder();

        if (FAILED(hr))
            return hr;

        hr = decoder->GetThumbnail(thumbWidth, thumbHeight, &img);

        if (SUCCEEDED(hr))
        {
            ImageInfo imginfo;
            hr = img->GetImageInfo(&imginfo);

            if (SUCCEEDED(hr) &&
                imginfo.Width == thumbWidth || thumbWidth == 0 &&
                imginfo.Height == thumbHeight || thumbHeight == 0)
            {
                *thumbImage = img;
                return S_OK;
            }
        }
        else
            img = NULL;
    }

    if (thumbWidth == 0 && thumbHeight == 0)
        thumbWidth = thumbHeight = DEFAULT_THUMBNAIL_SIZE;

    // Otherwise, generate the thumbnail ourselves using the built-in scaler
    // or scale the thumbnail returned by the decoder to the right size

    GpMemoryBitmap* bmp;

    hr = GpMemoryBitmap::CreateFromImage(
                        img ? img : this,
                        thumbWidth,
                        thumbHeight,
                        PIXFMT_DONTCARE,
                        INTERP_AVERAGING,
                        &bmp);

    if (SUCCEEDED(hr))
    {
        hr = bmp->QueryInterface(IID_IImage, (VOID**) thumbImage);
        bmp->Release();
    }

    if (img)
        img->Release();

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the image resolution.  Overrides the native resolution of the image.
*
* Arguments:
*
*   Xdpi, Ydpi - new resolution
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpDecodedImage::SetResolution(
    IN REAL Xdpi,
    IN REAL Ydpi
    )
{
    HRESULT hr = S_OK;

    if ((Xdpi > 0.0) && (Ydpi > 0.0))
    {
        xdpiOverride = Xdpi;
        ydpiOverride = Ydpi;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the encoder parameter list size from an encoder object specified by
*   input clsid
*
* Arguments:
*
*   clsid - Specifies the encoder class ID
*   size--- The size of the encoder parameter list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/22/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpDecodedImage::GetEncoderParameterListSize(
    IN  CLSID* clsidEncoder,
    OUT UINT* size
    )
{
    return CodecGetEncoderParameterListSize(clsidEncoder, size);    
}// GetEncoderParameterListSize()

/**************************************************************************\
*
* Function Description:
*
*   Get the encoder parameter list from an encoder object specified by
*   input clsid
*
* Arguments:
*
*   clsid --- Specifies the encoder class ID
*   size----- The size of the encoder parameter list
*   pBuffer-- Buffer for storing the list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/22/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpDecodedImage::GetEncoderParameterList(
    IN CLSID* clsidEncoder,
    IN UINT size,
    OUT EncoderParameters* pBuffer
    )
{
    return CodecGetEncoderParameterList(clsidEncoder, size, pBuffer);
}// GetEncoderParameterList()

/**************************************************************************\
*
* Function Description:
*
*   Save the bitmap image to the specified stream.
*
* Arguments:
*
*   stream ------------ Target stream
*   clsidEncoder ------ Specifies the CLSID of the encoder to use
*   encoderParameters - Optional parameters to pass to the encoder before
*                       starting encoding
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/22/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpDecodedImage::SaveToStream(
    IN IStream* stream,
    IN CLSID* clsidEncoder,
    IN EncoderParameters* encoderParams,
    OUT IImageEncoder** ppEncoderPtr
    )
{
    if ( ppEncoderPtr == NULL )
    {
        WARNING(("GpDecodedImage::SaveToStream---Invalid input arg"));
        return E_INVALIDARG;
    }

    // Get an image encoder.

    IImageEncoder* pEncoder = NULL;

    HRESULT hResult = CreateEncoderToStream(clsidEncoder, stream, &pEncoder);

    if ( SUCCEEDED(hResult) )
    {
        *ppEncoderPtr = pEncoder;

        // Pass encode parameters to the encoder.
        // MUST do this before getting the sink interface.

        if ( encoderParams != NULL )
        {
            hResult = pEncoder->SetEncoderParameters(encoderParams);
        }

        if ( (hResult == S_OK) || (hResult == E_NOTIMPL) )
        {
            // Note: if the codec doesn't support SetEncoderparameters(), it is
            // still fine to save the image
            
            // Get an image sink from the encoder.

            IImageSink* encodeSink = NULL;

            hResult = pEncoder->GetEncodeSink(&encodeSink);
            if ( SUCCEEDED(hResult) )
            {
                // Push bitmap into the encoder sink.

                hResult = this->PushIntoSink(encodeSink);

                encodeSink->Release();                
            }
        }
    }

    return hResult;
}// SaveToStream()

/**************************************************************************\
*
* Function Description:
*
*   Save the bitmap image to the specified file.
*
* Arguments:
*
*   filename      ----- Target filename
*   clsidEncoder  ----- Specifies the CLSID of the encoder to use
*   encoderParameters - Optional parameters to pass to the encoder before
*                       starting encoding
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpDecodedImage::SaveToFile(
    IN const WCHAR* filename,
    IN CLSID* clsidEncoder,
    IN EncoderParameters* encoderParams,
    OUT IImageEncoder** ppEncoderPtr
    )
{
    IStream* stream;

    HRESULT hResult = CreateStreamOnFileForWrite(filename, &stream);

    if ( SUCCEEDED(hResult) )
    {
        hResult = SaveToStream(stream, clsidEncoder,
                               encoderParams, ppEncoderPtr);
        stream->Release();
    }

    return hResult;
}// SaveToFile()

/**************************************************************************\
*
* Function Description:
*
*   Append the bitmap object to current encoder object
*
* Arguments:
*
*   encoderParameters - Optional parameters to pass to the encoder before
*                       starting encoding
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   04/21/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpDecodedImage::SaveAppend(
    IN const EncoderParameters* encoderParams,
    IN IImageEncoder* destEncoderPtr
    )
{
    // The dest encoder pointer can't be NULL. Otherwise, it is a failure

    if ( destEncoderPtr == NULL )
    {
        WARNING(("GpDecodedImage::SaveAppend---Called without an encoder"));
        return E_FAIL;
    }

    HRESULT hResult = S_OK;
    
    // Pass encode parameters to the encoder.
    // MUST do this before getting the sink interface.

    if ( encoderParams != NULL )
    {
        hResult = destEncoderPtr->SetEncoderParameters(encoderParams);
    }

    if ( (hResult == S_OK) || (hResult == E_NOTIMPL) )
    {
        // Note: if the codec doesn't support SetEncoderparameters(), it is
        // still fine to save the image
            
        // Get an image sink from the encoder.

        IImageSink* encodeSink = NULL;

        hResult = destEncoderPtr->GetEncodeSink(&encodeSink);
        if ( SUCCEEDED(hResult) )
        {
            // Push bitmap into the encoder sink.

            hResult = this->PushIntoSink(encodeSink);

            encodeSink->Release();
        }
    }

    return hResult;
}// SaveAppend()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\imgguids.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   imgguids.cpp
*
* Abstract:
*
*   GUIDs defined and used by the imaging library
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#include <initguid.h>
#include "imgguids.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\icmdll.hpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   icmdll.hpp
*
* Abstract:
*
*   Declaration of support functions for hooking ICM 2.0
*
\**************************************************************************/

HRESULT LoadICMDll();

typedef HPROFILE (WINAPI * OpenColorProfileProc)(
    PPROFILE pProfile,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    DWORD dwCreationMode
);

typedef HPROFILE (WINAPI * OpenColorProfileWProc)(
    PPROFILE pProfile,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    DWORD dwCreationMode
);

typedef BOOL (WINAPI * CloseColorProfileProc) (
    HPROFILE hProfile
);

typedef HTRANSFORM (WINAPI * CreateMultiProfileTransformProc)(
    PHPROFILE pahProfiles,
    DWORD nProfiles,
    PDWORD padwIntent,
    DWORD nIntents,
    DWORD dwFlags,
    DWORD indexPreferredCMM
);

typedef BOOL (WINAPI * DeleteColorTransformProc)(
    HTRANSFORM hColorTransform
);

typedef BOOL (WINAPI * TranslateBitmapBitsProc)(
    HTRANSFORM hColorTransform,
    PVOID pSrcBits,
    BMFORMAT bmInput,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwInputStride,
    PVOID pDestBits,
    BMFORMAT bmOutput,
    DWORD dwOutputStride,
    PBMCALLBACKFN pfnCallback,
    ULONG ulCallbackData
);

extern OpenColorProfileProc            pfnOpenColorProfile;
extern OpenColorProfileWProc           pfnOpenColorProfileW;
extern CloseColorProfileProc           pfnCloseColorProfile;
extern CreateMultiProfileTransformProc pfnCreateMultiProfileTransform;
extern DeleteColorTransformProc        pfnDeleteColorTransform;
extern TranslateBitmapBitsProc         pfnTranslateBitmapBits;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\imginit.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   imginit.cpp
*
* Abstract:
*
*   Initialization of imaging libraray
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

//
// Global critical section
//

CRITICAL_SECTION ImagingCritSec::critSec;
BOOL             ImagingCritSec::initialized;

//
// Global COM component count
//

LONG ComComponentCount;

BOOL SuppressExternalCodecs;

//
// Initialization
//

BOOL
InitImagingLibrary(BOOL suppressExternalCodecs)
{
    
    // !!! TODO
    //  Since we have our own DLL entrypoint here, the standard
    //  runtime library initialization isn't performed. Specifically,
    //  global static C++ objects are not initialized.
    //  
    //  Manually perform any necessary initialization here.

    SuppressExternalCodecs = suppressExternalCodecs;

    __try
    {
        ImagingCritSec::InitializeCritSec();
        GpMallocTrackingCriticalSection::InitializeCriticalSection();   
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // We couldn't allocate the criticalSection
        // Return an error
        return FALSE;
    }
    return TRUE;
}


//
// Cleanup
//
extern HINSTANCE    g_hInstMsimg32;

VOID
CleanupImagingLibrary()
{
    if ( g_hInstMsimg32 != NULL )
    {
        ImagingCritSec critsec;

        FreeLibrary(g_hInstMsimg32);
        g_hInstMsimg32 = NULL;
    }

    FreeCachedCodecInfo(-1);
    GpMallocTrackingCriticalSection::DeleteCriticalSection();
    ImagingCritSec::DeleteCritSec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\imgutils.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   imgutils.cpp
*
* Abstract:
*
*   Misc. utility functions
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   Convert a 32bpp premultiplied ARGB value to
*   a 32bpp non-premultiplied ARGB value
*
* Arguments:
*
*   argb - Premultiplied ARGB value
*
* Return Value:
*
*   Non-premultiplied ARGB value
*
\**************************************************************************/

// Precomputed table for 255/a, 0 < a <= 255
//  in 16.16 fixed point format

static const ARGB UnpremultiplyTable[256] =
{
    0x000000,0xff0000,0x7f8000,0x550000,0x3fc000,0x330000,0x2a8000,0x246db6,
    0x1fe000,0x1c5555,0x198000,0x172e8b,0x154000,0x139d89,0x1236db,0x110000,
    0x0ff000,0x0f0000,0x0e2aaa,0x0d6bca,0x0cc000,0x0c2492,0x0b9745,0x0b1642,
    0x0aa000,0x0a3333,0x09cec4,0x0971c7,0x091b6d,0x08cb08,0x088000,0x0839ce,
    0x07f800,0x07ba2e,0x078000,0x074924,0x071555,0x06e453,0x06b5e5,0x0689d8,
    0x066000,0x063831,0x061249,0x05ee23,0x05cba2,0x05aaaa,0x058b21,0x056cef,
    0x055000,0x05343e,0x051999,0x050000,0x04e762,0x04cfb2,0x04b8e3,0x04a2e8,
    0x048db6,0x047943,0x046584,0x045270,0x044000,0x042e29,0x041ce7,0x040c30,
    0x03fc00,0x03ec4e,0x03dd17,0x03ce54,0x03c000,0x03b216,0x03a492,0x03976f,
    0x038aaa,0x037e3f,0x037229,0x036666,0x035af2,0x034fca,0x0344ec,0x033a54,
    0x033000,0x0325ed,0x031c18,0x031281,0x030924,0x030000,0x02f711,0x02ee58,
    0x02e5d1,0x02dd7b,0x02d555,0x02cd5c,0x02c590,0x02bdef,0x02b677,0x02af28,
    0x02a800,0x02a0fd,0x029a1f,0x029364,0x028ccc,0x028656,0x028000,0x0279c9,
    0x0273b1,0x026db6,0x0267d9,0x026217,0x025c71,0x0256e6,0x025174,0x024c1b,
    0x0246db,0x0241b2,0x023ca1,0x0237a6,0x0232c2,0x022df2,0x022938,0x022492,
    0x022000,0x021b81,0x021714,0x0212bb,0x020e73,0x020a3d,0x020618,0x020204,
    0x01fe00,0x01fa0b,0x01f627,0x01f252,0x01ee8b,0x01ead3,0x01e72a,0x01e38e,
    0x01e000,0x01dc7f,0x01d90b,0x01d5a3,0x01d249,0x01cefa,0x01cbb7,0x01c880,
    0x01c555,0x01c234,0x01bf1f,0x01bc14,0x01b914,0x01b61e,0x01b333,0x01b051,
    0x01ad79,0x01aaaa,0x01a7e5,0x01a529,0x01a276,0x019fcb,0x019d2a,0x019a90,
    0x019800,0x019577,0x0192f6,0x01907d,0x018e0c,0x018ba2,0x018940,0x0186e5,
    0x018492,0x018245,0x018000,0x017dc1,0x017b88,0x017957,0x01772c,0x017507,
    0x0172e8,0x0170d0,0x016ebd,0x016cb1,0x016aaa,0x0168a9,0x0166ae,0x0164b8,
    0x0162c8,0x0160dd,0x015ef7,0x015d17,0x015b3b,0x015965,0x015794,0x0155c7,
    0x015400,0x01523d,0x01507e,0x014ec4,0x014d0f,0x014b5e,0x0149b2,0x01480a,
    0x014666,0x0144c6,0x01432b,0x014193,0x014000,0x013e70,0x013ce4,0x013b5c,
    0x0139d8,0x013858,0x0136db,0x013562,0x0133ec,0x01327a,0x01310b,0x012fa0,
    0x012e38,0x012cd4,0x012b73,0x012a15,0x0128ba,0x012762,0x01260d,0x0124bc,
    0x01236d,0x012222,0x0120d9,0x011f93,0x011e50,0x011d10,0x011bd3,0x011a98,
    0x011961,0x01182b,0x0116f9,0x0115c9,0x01149c,0x011371,0x011249,0x011123,
    0x011000,0x010edf,0x010dc0,0x010ca4,0x010b8a,0x010a72,0x01095d,0x01084a,
    0x010739,0x01062b,0x01051e,0x010414,0x01030c,0x010206,0x010102,0x010000,
};

ARGB
Unpremultiply(
    ARGB argb
    )
{
    // Get alpha value

    ARGB a = argb >> ALPHA_SHIFT;

    // Special case: fully transparent or fully opaque

    if (a == 0 || a == 255)
        return argb;

    ARGB f = UnpremultiplyTable[a];

    ARGB r = ((argb >>   RED_SHIFT) & 0xff) * f >> 16;
    ARGB g = ((argb >> GREEN_SHIFT) & 0xff) * f >> 16;
    ARGB b = ((argb >>  BLUE_SHIFT) & 0xff) * f >> 16;

    return (a << ALPHA_SHIFT) |
           ((r > 255 ? 255 : r) << RED_SHIFT) |
           ((g > 255 ? 255 : g) << GREEN_SHIFT) |
           ((b > 255 ? 255 : b) << BLUE_SHIFT);
}


/**************************************************************************\
*
* Function Description:
*
*   Create a new registry key and set its default value
*
* Arguments:
*
*   parentKey - Handle to the parent registry key
*   keyname - Specifies the name of the subkey
*   value - Default value for the subkey
*   retkey - Buffer for returning a handle to the opened subkey
*       NULL if the caller is not interested in such
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
SetRegKeyValue(
    HKEY parentKey,
    const WCHAR* keyname,
    const WCHAR* value,
    HKEY* retkey
    )
{
    HKEY hkey;
    LONG status;

    // Create or open the specified registry key

    status = _RegCreateKey(parentKey, keyname, KEY_ALL_ACCESS, &hkey);
                
    if (status != ERROR_SUCCESS)
        return status;

    // Set the default value for the new key

    status = _RegSetString(hkey, NULL, value);

    // Check if the caller is interested in the handle to the new key

    if (status == ERROR_SUCCESS && retkey)
        *retkey = hkey;
    else
        RegCloseKey(hkey);

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Delete a registry key and everything below it.
*
* Arguments:
*
*   parentKey - Handle to the parent registry key
*   keyname - Specifies the name of the subkey to be deleted
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
RecursiveDeleteRegKey(
    HKEY parentKey,
    const WCHAR* keyname
    )
{
    HKEY hkey;
    LONG status;

    // Open the specified registry key

    status = _RegOpenKey(parentKey, keyname, KEY_ALL_ACCESS, &hkey);
                 
    if (status != ERROR_SUCCESS)
        return status;

    // Enumerate all subkeys

    WCHAR subkeyStr[MAX_PATH];
    
    do
    {
        status = _RegEnumKey(hkey, 0, subkeyStr);
                        
        // Recursively delete subkeys

        if (status == ERROR_SUCCESS)
            status = RecursiveDeleteRegKey(hkey, subkeyStr);
    }
    while (status == ERROR_SUCCESS);

    // Close the specified key and then delete it

    RegCloseKey(hkey);
    return _RegDeleteKey(parentKey, keyname);
}


/**************************************************************************\
*
* Function Description:
*
*   Register / unregister a COM component
*
* Arguments:
*
*   regdata - Component registration data
*   registerIt - Whether to register or unregister the component
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
RegisterComComponent(
    const ComComponentRegData* regdata,
    BOOL registerIt
    )
{
    static const WCHAR CLSID_KEYSTR[] = L"CLSID";
    static const WCHAR INPROCSERVER32_KEYSTR[] = L"InProcServer32";
    static const WCHAR THREADING_VALSTR[] = L"ThreadingModel";
    static const WCHAR PROGID_KEYSTR[] = L"ProgID";
    static const WCHAR PROGIDNOVER_KEYSTR[] = L"VersionIndependentProgID";
    static const WCHAR CURVER_KEYSTR[] = L"CurVer";

    // compose class ID string

    WCHAR clsidStr[64];
    StringFromGUID2(*regdata->clsid, clsidStr, 64);

    // open registry key HKEY_CLASSES_ROOT\CLSID

    LONG status;
    HKEY clsidKey;

    status = _RegOpenKey(
                HKEY_CLASSES_ROOT,
                CLSID_KEYSTR,
                KEY_ALL_ACCESS,
                &clsidKey);
                
    if (status != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(status);

    if (registerIt)
    {
        // Register the component

        HKEY hkey;
        WCHAR fullpath[MAX_PATH];

        // HKEY_CLASSES_ROOT
        //  <Version-independent ProgID> - component friendly name
        //      CLSID - current version class ID
        //      CurVer - current version ProgID

        if (!_GetModuleFileName(DllInstance, fullpath))
        {
            status = GetLastError();
            goto regcompExit;
        }

        status = SetRegKeyValue(
                    HKEY_CLASSES_ROOT,
                    regdata->progIDNoVer,
                    regdata->compName,
                    &hkey);

        if (status != ERROR_SUCCESS)
            goto regcompExit;

        status = SetRegKeyValue(hkey, CLSID_KEYSTR, clsidStr, NULL);

        if (status == ERROR_SUCCESS)
            status = SetRegKeyValue(hkey, CURVER_KEYSTR, regdata->progID, NULL);

        RegCloseKey(hkey);

        if (status != ERROR_SUCCESS)
            goto regcompExit;

        // HKEY_CLASSES_ROOT
        //  <ProgID> - friendly component name
        //      CLSID - class ID

        status = SetRegKeyValue(
                    HKEY_CLASSES_ROOT,
                    regdata->progID,
                    regdata->compName,
                    &hkey);

        if (status == ERROR_SUCCESS)
        {
            status = SetRegKeyValue(hkey, CLSID_KEYSTR, clsidStr, NULL);
            RegCloseKey(hkey);
        }

        if (status != ERROR_SUCCESS)
            goto regcompExit;

        // HKEY_CLASSES_ROOT
        //  CLSID
        //      <class ID> - friendly component name
        //          InProcServer32 - full pathname to component DLL
        //              Threading : REG_SZ : threading model
        //          ProgID - current version ProgID
        //          VersionIndependentProgID - ...

        status = SetRegKeyValue(clsidKey, clsidStr, regdata->compName, &hkey);

        if (status != ERROR_SUCCESS)
            goto regcompExit;

        HKEY inprocKey;
        status = SetRegKeyValue(hkey, INPROCSERVER32_KEYSTR, fullpath, &inprocKey);

        if (status == ERROR_SUCCESS)
        {
            status = _RegSetString(inprocKey, THREADING_VALSTR, regdata->threading);
            RegCloseKey(inprocKey);
        }

        if (status == ERROR_SUCCESS)
            status = SetRegKeyValue(hkey, PROGID_KEYSTR, regdata->progID, NULL);

        if (status == ERROR_SUCCESS)
            status = SetRegKeyValue(hkey, PROGIDNOVER_KEYSTR, regdata->progIDNoVer, NULL);

        RegCloseKey(hkey);
    }
    else
    {
        // Unregister the component

        status = RecursiveDeleteRegKey(clsidKey, clsidStr);

        if (status == ERROR_SUCCESS)
            status = RecursiveDeleteRegKey(HKEY_CLASSES_ROOT, regdata->progIDNoVer);

        if (status == ERROR_SUCCESS)
            status = RecursiveDeleteRegKey(HKEY_CLASSES_ROOT, regdata->progID);
    }

regcompExit:

    RegCloseKey(clsidKey);

    if (status == ERROR_SUCCESS)
        return S_OK;
    else
    {
        WARNING(("RegisterComComponent (%d) failed: 0x%08x", registerIt, status));
        return HRESULT_FROM_WIN32(status);
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Create/open a registry key
*
* Arguments:
*
*   rootKey - Specifies the root registry key
*   keyname - Relative path to the new registry key to be created
*   samDesired - Desired access mode
*   hkeyResult - Returns a handle to the new key
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
_RegCreateKey(
    HKEY rootKey,
    const WCHAR* keyname,
    REGSAM samDesired,
    HKEY* hkeyResult
    )
{
    DWORD disposition;

    // Windows NT - Unicode

    if (OSInfo::IsNT)
    {
        return RegCreateKeyExW(
                    rootKey,
                    keyname,
                    0,
                    NULL,
                    0,
                    samDesired,
                    NULL,
                    hkeyResult,
                    &disposition);
    }

    // Windows 9x - non-Unicode

    AnsiStrFromUnicode subkeyStr(keyname);

    if (subkeyStr.IsValid())
    {
        return RegCreateKeyExA(
                    rootKey,
                    subkeyStr,
                    0,
                    NULL,
                    0,
                    samDesired,
                    NULL,
                    hkeyResult,
                    &disposition);
    }
    else
        return ERROR_INVALID_DATA;
}


/**************************************************************************\
*
* Function Description:
*
*   Open a registry key
*
* Arguments:
*
*   rootKey - Specifies the root registry key
*   keyname - Relative path to the new registry key to be opened
*   samDesired - Desired access mode
*   hkeyResult - Returns a handle to the opened key
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
_RegOpenKey(
    HKEY rootKey,
    const WCHAR* keyname,
    REGSAM samDesired,
    HKEY* hkeyResult
    )
{
    // Windows NT - Unicode

    if (OSInfo::IsNT)
    {
        return RegOpenKeyExW(
                    rootKey,
                    keyname,
                    0,
                    samDesired,
                    hkeyResult);
    }

    // Windows 9x - non-Unicode

    AnsiStrFromUnicode subkeyStr(keyname);
    
    if (subkeyStr.IsValid())
    {
        return RegOpenKeyExA(
                    rootKey,
                    subkeyStr,
                    0, 
                    samDesired,
                    hkeyResult);
    }
    else
        return ERROR_INVALID_DATA;
}


/**************************************************************************\
*
* Function Description:
*
*   Enumerate the subkeys under the specified registry key
*
* Arguments:
*
*   parentKey - Handle to the parent registry key
*   index - Enumeration index
*   subkeyStr - Buffer for holding the subkey name
*       must be able to hold at least MAX_PATH characters
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
_RegEnumKey(
    HKEY parentKey,
    DWORD index,
    WCHAR* subkeyStr
    )
{
    // Windows NT - Unicode

    FILETIME filetime;
    DWORD subkeyLen = MAX_PATH;

    if (OSInfo::IsNT)
    {
        return RegEnumKeyExW(
                    parentKey,
                    index,
                    subkeyStr,
                    &subkeyLen,
                    NULL,
                    NULL,
                    NULL,
                    &filetime);
    }

    // Windows 9x - non-Unicode

    CHAR ansibuf[MAX_PATH];
    LONG status;

    status = RegEnumKeyExA(
                    parentKey,
                    index,
                    ansibuf,
                    &subkeyLen,
                    NULL,
                    NULL,
                    NULL,
                    &filetime);

    return (status != ERROR_SUCCESS) ? status :
           AnsiToUnicodeStr(ansibuf, subkeyStr, MAX_PATH) ?
                ERROR_SUCCESS :
                ERROR_INVALID_DATA;
}


/**************************************************************************\
*
* Function Description:
*
*   Delete the specified registry key
*
* Arguments:
*
*   parentKey - Handle to the parent registry key
*   keyname - Name of the subkey to be deleted
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
_RegDeleteKey(
    HKEY parentKey,
    const WCHAR* keyname
    )
{
    // Windows NT - Unicode

    if (OSInfo::IsNT)
        return RegDeleteKeyW(parentKey, keyname);

    // Windows 9x - non-Unicode

    AnsiStrFromUnicode subkeyStr(keyname);

    return subkeyStr.IsValid() ?
                RegDeleteKeyA(parentKey, subkeyStr) :
                ERROR_INVALID_DATA;
}


/**************************************************************************\
*
* Function Description:
*
*   Write string value into the registry
*
* Arguments:
*
*   hkey - Specifies the registry key under which the value is written
*   name - Specifies the name of the value
*   value - Specifies the string value to be written
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
_RegSetString(
    HKEY hkey,
    const WCHAR* name,
    const WCHAR* value
    )
{
    // Windows NT - Unicode

    if (OSInfo::IsNT)
    {
        return RegSetValueExW(
                    hkey,
                    name,
                    0,
                    REG_SZ,
                    (const BYTE*) value,
                    SizeofWSTR(value));
    }

    // Windows 9x - non-Unicode

    AnsiStrFromUnicode nameStr(name);
    AnsiStrFromUnicode valueStr(value);
    const CHAR* ansival;

    if (!nameStr.IsValid() || !valueStr.IsValid())
        return ERROR_INVALID_DATA;

    ansival = valueStr;

    return RegSetValueExA(
                hkey,
                nameStr,
                0,
                REG_SZ,
                (const BYTE*) ansival,
                SizeofSTR(ansival));
}


/**************************************************************************\
*
* Function Description:
*
*   Write DWORD value into the registry
*
* Arguments:
*
*   hkey - Specifies the registry key under which the value is written
*   name - Specifies the name of the value
*   value - Specifies the DWORD value to be written
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
_RegSetDWORD(
    HKEY hkey,
    const WCHAR* name,
    DWORD value
    )
{
    // Windows NT - Unicode

    if (OSInfo::IsNT)
    {
        return RegSetValueExW(
                    hkey,
                    name,
                    0,
                    REG_DWORD,
                    (const BYTE*) &value,
                    sizeof(value));
    }

    // Windows 9x - non-Unicode

    AnsiStrFromUnicode nameStr(name);

    if (nameStr.IsValid())
    {
        return RegSetValueExA(
                    hkey,
                    nameStr,
                    0,
                    REG_DWORD,
                    (const BYTE*) &value,
                    sizeof(value));
    }
    else
        return ERROR_INVALID_DATA;
}


/**************************************************************************\
*
* Function Description:
*
*   Write binary value into the registry
*
* Arguments:
*
*   hkey - Specifies the registry key under which the value is written
*   name - Specifies the name of the value
*   value - Specifies the binary value to be written
*   size - Size of the binary value, in bytes
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
_RegSetBinary(
    HKEY hkey,
    const WCHAR* name,
    const VOID* value,
    DWORD size
    )
{
    // Windows NT - Unicode

    if (OSInfo::IsNT)
    {
        return RegSetValueExW(
                    hkey,
                    name,
                    0,
                    REG_BINARY,
                    (const BYTE*) value,
                    size);
    }

    // Windows 9x - non-Unicode

    AnsiStrFromUnicode nameStr(name);

    if (nameStr.IsValid())
    {
        return RegSetValueExA(
                    hkey,
                    nameStr,
                    0,
                    REG_BINARY,
                    (const BYTE*) value,
                    size);
    }
    else
        return ERROR_INVALID_DATA;
}


/**************************************************************************\
*
* Function Description:
*
*   Read DWORD value out of the registry
*
* Arguments:
*
*   hkey - The registry under which to read the value from
*   name - Name of the value to be read
*   value - Returns the DWORD value read
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
_RegGetDWORD(
    HKEY hkey,
    const WCHAR* name,
    DWORD* value
    )
{
    // Windows NT - Unicode

    LONG status;
    DWORD regtype;
    DWORD regsize = sizeof(DWORD);

    if (OSInfo::IsNT)
    {
        status = RegQueryValueExW(
                    hkey,
                    name,
                    NULL,
                    &regtype,
                    (BYTE*) value,
                    &regsize);
    }
    else
    {
        // Windows 9x - non-Unicode

        AnsiStrFromUnicode nameStr(name);

        if (!nameStr.IsValid())
            return ERROR_INVALID_DATA;

        status = RegQueryValueExA(
                    hkey,
                    nameStr,
                    NULL,
                    &regtype,
                    (BYTE*) value,
                    &regsize);
    }

    return (status != ERROR_SUCCESS) ? status :
           (regtype != REG_DWORD || regsize != sizeof(DWORD)) ?
                ERROR_INVALID_DATA :
                ERROR_SUCCESS;
}


/**************************************************************************\
*
* Function Description:
*
*   Read binary value out of the registry
*
* Arguments:
*
*   hkey - The registry under which to read the value from
*   name - Name of the value to be read
*   buf - Output buffer
*   size - Size of the output buffer, in bytes
*
* Return Value:
*
*   Status code
*
* Notes:
*
*   The size of the value read out of the registry must be exactly
*   the same as the specified output buffer size.
*
\**************************************************************************/

LONG
_RegGetBinary(
    HKEY hkey,
    const WCHAR* name,
    VOID* buf,
    DWORD size
    )
{
    // Windows NT - Unicode

    LONG status;
    DWORD regtype;
    DWORD regsize = size;

    if (OSInfo::IsNT)
    {
        status = RegQueryValueExW(
                    hkey,
                    name,
                    NULL,
                    &regtype,
                    (BYTE*) buf,
                    &regsize);
    }
    else
    {
        // Windows 9x - non-Unicode

        AnsiStrFromUnicode nameStr(name);

        if (!nameStr.IsValid())
            return ERROR_INVALID_DATA;

        status = RegQueryValueExA(
                    hkey,
                    nameStr,
                    NULL,
                    &regtype,
                    (BYTE*) buf,
                    &regsize);
    }

    return (status != ERROR_SUCCESS) ? status :
           (regtype != REG_BINARY || regsize != size) ?
                ERROR_INVALID_DATA :
                ERROR_SUCCESS;
}


/**************************************************************************\
*
* Function Description:
*
*   Read string value out of the registry
*
* Arguments:
*
*   hkey - The registry under which to read the value from
*   name - Name of the value to be read
*   buf - Output buffer
*   size - Size of the output buffer, in bytes
*
* Return Value:
*
*   Status code
*
* Notes:
*
*   The longest string we can handle here is MAX_PATH-1.
*
\**************************************************************************/

LONG
_RegGetString(
    HKEY hkey,
    const WCHAR* name,
    WCHAR* buf,
    DWORD size
    )
{
    // Windows NT - Unicode

    LONG status;
    DWORD regtype;
    DWORD regsize;

    if (OSInfo::IsNT)
    {
        regsize = size;

        status = RegQueryValueExW(
                    hkey,
                    name,
                    NULL,
                    &regtype,
                    (BYTE*) buf,
                    &regsize);
        
        return (status == ERROR_SUCCESS && regtype != REG_SZ) ?
                    ERROR_INVALID_DATA :
                    status;
    }

    // Windows 9x - non-Unicode

    CHAR ansibuf[MAX_PATH];
    AnsiStrFromUnicode nameStr(name);

    if (!nameStr.IsValid())
        return ERROR_INVALID_DATA;

    size /= 2;
    regsize = MAX_PATH;

    status = RegQueryValueExA(
                hkey,
                nameStr,
                NULL,
                &regtype,
                (BYTE*) ansibuf,
                &regsize);

    return (status != ERROR_SUCCESS) ? status :
           (regtype != REG_SZ) ? ERROR_INVALID_DATA :
           AnsiToUnicodeStr(ansibuf, buf, size) ?
                ERROR_SUCCESS :
                ERROR_INVALID_DATA;
}


/**************************************************************************\
*
* Function Description:
*
*   Get the full path name of the specified module
*
* Arguments:
*
*   moduleHandle - Module handle
*   moduleName - Buffer for holding the module filename
*       must be able to hold at least MAX_PATH characters
*
* Return Value:
*
*   TRUE if successful, FALSE if there is an error
*
\**************************************************************************/

BOOL
_GetModuleFileName(
    HINSTANCE moduleHandle,
    WCHAR* moduleName
    )
{
    // Windows NT - Unicode

    if (OSInfo::IsNT)
        return GetModuleFileNameW(moduleHandle, moduleName, MAX_PATH);

    // Windows 9x - non-Unicode

    CHAR ansibuf[MAX_PATH];

    return GetModuleFileNameA(moduleHandle, ansibuf, MAX_PATH) ?
                AnsiToUnicodeStr(ansibuf, moduleName, MAX_PATH) :
                FALSE;
}


/**************************************************************************\
*
* Function Description:
*
*   Load string resource
*
* Arguments:
*
*   hInstance - handle of module containing string resource 
*   strId - string resource identifier
*   buf - string output buffer
*   size - size of output buffer, in characters
*
* Return Value:
*
*   Length of the loaded string (excluding null terminator)
*   0 if there is an error
*
\**************************************************************************/

INT
_LoadString(
    HINSTANCE hInstance,
    UINT strId,
    WCHAR* buf,
    INT size
    )
{
    // Windows NT - Unicode

    if (OSInfo::IsNT)
        return LoadStringW(hInstance, strId, buf, size);

    // Windows 9x - non-Unicode

    CHAR ansibuf[MAX_PATH];
    INT n;

    // NOTE: we only support string length < MAX_PATH

    if (size > MAX_PATH)
        return 0;

    n = LoadStringA(hInstance, strId, ansibuf, MAX_PATH);
    return (n > 0 && AnsiToUnicodeStr(ansibuf, buf, size)) ? n : 0;
}


/**************************************************************************\
*
* Function Description:
*
*   Load bitmap resource
*
* Arguments:
*
*   hInstance - handle of module containing bitmap resource
*   bitmapName - pointer to bitmap resource name OR bitmap resource
*       identifier (resource identifier is zero in high order word)
*
* Return Value:
*
*   Handle of the loaded bitmap
*   0 if there is an error
*
\**************************************************************************/

HBITMAP
_LoadBitmap(
    HINSTANCE hInstance,
    const WCHAR *bitmapName
    )
{
    // Windows NT - Unicode

    if (OSInfo::IsNT)
    {
        return LoadBitmapW(hInstance, bitmapName);
    }

    // Win9x - ANSI only

    else
    {
        if (!IS_INTRESOURCE(bitmapName))
        {
            AnsiStrFromUnicode bitmapStr(bitmapName);

            if (bitmapStr.IsValid())
            {
                return LoadBitmapA(hInstance, bitmapStr);
            }
            else
            {
                return (HBITMAP) NULL;
            }
        }
        else
        {
            // If bitmapName is really an integer resource identifier,
            // then it can be passed directly to the ANSI version of the
            // API.

            return LoadBitmapA(hInstance, (LPCSTR) bitmapName);
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Create or open the specified file
*
* Arguments:
*
*   filename - specifies the name of the file
*   accessMode - specifies the desired access mode
*   shareMode - specifies the share mode
*   creationFlags - creation flags
*   attrs - attribute flags
*
* Return Value:
*
*   Handle to the file created or opened
*   INVALID_HANDLE_VALUE if there is an error
*
\**************************************************************************/

HANDLE
_CreateFile(
    const WCHAR* filename,
    DWORD accessMode,
    DWORD shareMode,
    DWORD creationFlags,
    DWORD attrs
    )
{
    // Windows NT - Unicode

    if (OSInfo::IsNT)
    {
        return CreateFileW(
                    filename,
                    accessMode,
                    shareMode,
                    NULL,
                    creationFlags,
                    attrs,
                    NULL);
    }

    // Windows 9x - non-Unicode

    AnsiStrFromUnicode nameStr(filename);

    if (nameStr.IsValid())
    {
        return CreateFileA(
                    nameStr,
                    accessMode,
                    shareMode,
                    NULL,
                    creationFlags,
                    attrs,
                    NULL);
    }
    else
        return INVALID_HANDLE_VALUE;
}


/**************************************************************************\
*
* Function Description:
*
*   Create an IPropertySetStorage object on top of a memory buffer
*
* Arguments:
*
*   propSet - Returns a pointer to the newly created object
*   hmem - Optional handle to memory buffer
*       if NULL, we'll allocate memory ourselves
*       otherwise, must be allocated by GlobalAlloc and 
*           must be moveable and non-discardable
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
CreateIPropertySetStorageOnHGlobal(
    IPropertySetStorage** propSet,
    HGLOBAL hmem
    )
{
    HRESULT hr;
    ILockBytes* lockbytes;
    IStorage* stg;

    hr = CreateILockBytesOnHGlobal(hmem, TRUE, &lockbytes);

    if (FAILED(hr))
        return hr;

    hr = StgCreateDocfileOnILockBytes(lockbytes, 
        STGM_DIRECT | STGM_READWRITE | STGM_CREATE  | STGM_SHARE_EXCLUSIVE, 
        0, 
        &stg);
    lockbytes->Release();

    if (FAILED(hr))
        return hr;
    
    hr = stg->QueryInterface(IID_IPropertySetStorage, (VOID**) propSet);
    stg->Release();

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Print out debug messages using a message box
*
* Arguments:
*
*   format - printf format string
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

#if DBG
// This function is never used anywhere in the imaging tree.
/*
VOID
DbgMessageBox(
    const CHAR* format,
    ...
    )
{
    CHAR buf[1024];
    va_list arglist;

    va_start(arglist, format);
    vsprintf(buf, format, arglist);
    va_end(arglist);

    MessageBoxA(NULL, buf, "Debug Message", MB_OK);
}
*/

#endif // DBG


/**************************************************************************\
*
* Function Description:
*
*     Reads a specified number bytes from a stream.  Blocking behavior:
*
*     - If the decoder is in blocking mode and the stream returns E_PENDING 
*         then this function blocks until the stream returns the data.
*     - If the decoder is in non-blocking mode and the stream returns 
*         E_PENDING then this function seeks back in the stream to before 
*         the read and returns E_PENDING.
*     
*     If the stream returns a success but reutrns less bytes than the number 
*     requested then this function returns E_FAIL.
*
* Arguments:
*
*     stream - Stream to read from.
*     buffer - Array to read into.  If buffer is NULL then this function seeks 
*         instead of reading.  If the buffer is NULL and the count is negative 
*         then the stream seeks backwards
*     count - Number of bytes to read.
*     blocking - TRUE if this function should block if the stream returns 
*         E_PENDING.  From a decoder, use something like"!(decoderFlags & 
*         DECODERINIT_NOBLOCK)"
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
ReadFromStream(IN IStream* stream, OUT VOID* buffer, IN INT count, IN BOOL 
    blocking)
{
    HRESULT hresult;
    LONG actualread = 0;
    LARGE_INTEGER lcount;
    ULARGE_INTEGER lactualread;
    BOOL repeat;

    do
    {
        repeat = FALSE;

        if (buffer)
        {
            if (count < 0)
                return E_INVALIDARG;
            hresult = stream->Read(buffer, (unsigned)count, (unsigned long*)&actualread);
        }
        else
        {
            lcount.QuadPart = count;
            hresult = stream->Seek(lcount, STREAM_SEEK_CUR, NULL);
            if (SUCCEEDED(hresult))
                actualread = count;
        }

        if (hresult == E_PENDING && blocking)
        {
            buffer = (char*)buffer + actualread;
            count -= actualread;
            repeat = TRUE;
            Sleep(0);
        }
    } while(repeat);

    if (blocking)
    {
        if (actualread != count)
            return E_FAIL;
        ASSERT(hresult != E_PENDING);
    }
    else if (hresult == E_PENDING)
    {
        LONGLONG lread;
        LARGE_INTEGER seekcount;

        seekcount.QuadPart = -((LONGLONG)actualread);

        hresult = stream->Seek(seekcount, STREAM_SEEK_CUR, NULL);
        if (FAILED(hresult))
            return hresult;

        return E_PENDING;
    }

    if (FAILED(hresult))
        return hresult;

    if (actualread != count)
        return E_FAIL;

    return hresult;
}


/**************************************************************************\
*
* Function Description:
*
*     Seeks 'count' number of bytes forward in a stream from the current 
*     stream pointer.  If 'count' is negative then the stream seeks backwards. 
*     Handles both blocking and non-blocking seeking.
*
* Arguments:
*
*     stream - Stream to seek through.
*     count - Number of bytes to seek.
*     blocking - TRUE if this function should block if the stream returns 
*         E_PENDING.  From a decoder, use something like"!(decoderFlags & 
*         DECODERINIT_NOBLOCK)"
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
SeekThroughStream(IN IStream* stream, IN INT count, IN BOOL blocking)
{
    return ReadFromStream(stream, NULL, count, blocking);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\imgfactory.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   imgfactory.hpp
*
* Abstract:
*
*   ImagingFactory class declarations
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _IMGFACTORY_HPP
#define _IMGFACTORY_HPP

//--------------------------------------------------------------------------
// Imaging library factory class
//--------------------------------------------------------------------------

class GpImagingFactory : public IUnknownBase<IImagingFactory>
{
public:

    //------------------------------------------------------------
    // Public IImagingFactory interface methods
    //------------------------------------------------------------

    // Create an image object from an input stream
    //  stream doesn't have to seekable
    //  caller should Release the stream if call is successful

    STDMETHOD(CreateImageFromStream)(
        IN IStream* stream,
        OUT IImage** image
        );

    // Create an image object from a file

    STDMETHOD(CreateImageFromFile)(
        IN const WCHAR* filename,
        OUT IImage** image
        );

    // Create an image object from a memory buffer

    STDMETHOD(CreateImageFromBuffer)(
        IN const VOID* buf,
        IN UINT size,
        IN BufferDisposalFlag disposalFlag,
        OUT IImage** image
        );
    
    // Create a new bitmap image object

    STDMETHOD(CreateNewBitmap)(
        IN UINT width,
        IN UINT height,
        IN PixelFormatID pixelFormat,
        OUT IBitmapImage** bitmap
        );

    // Create a bitmap image from an IImage object

    STDMETHOD(CreateBitmapFromImage)(
        IN IImage* image,
        IN OPTIONAL UINT width,
        IN OPTIONAL UINT height,
        IN OPTIONAL PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT IBitmapImage** bitmap
        );

    // Create a new bitmap image object on user-supplied memory buffer

    STDMETHOD(CreateBitmapFromBuffer)(
        IN BitmapData* bitmapData,
        OUT IBitmapImage** bitmap
        );

    // Create an image decoder object to process the given input stream

    STDMETHOD(CreateImageDecoder)(
        IN IStream* stream,
        IN DecoderInitFlag flags,
        OUT IImageDecoder** decoder
        );

    // Create an image encoder object that can output data in
    // the specified image file format.

    STDMETHOD(CreateImageEncoderToStream)(
        IN const CLSID* clsid,
        IN IStream* stream,
        OUT IImageEncoder** encoder
        );

    STDMETHOD(CreateImageEncoderToFile)(
        IN const CLSID* clsid,
        IN const WCHAR* filename,
        OUT IImageEncoder** encoder
        );

    // Get a list of all currently installed image decoders

    STDMETHOD(GetInstalledDecoders)(
        OUT UINT* count,
        OUT ImageCodecInfo** decoders
        );

    // Get a list of all currently installed image decoders

    STDMETHOD(GetInstalledEncoders)(
        OUT UINT* count,
        OUT ImageCodecInfo** encoders
        );

    // Install an image encoder / decoder
    //  caller should do the regular COM component
    //  installation before calling this method

    STDMETHOD(InstallImageCodec)(
        IN const ImageCodecInfo* codecInfo
        );

    // Uninstall an image encoder / decoder

    STDMETHOD(UninstallImageCodec)(
        IN const WCHAR* codecName,
        IN UINT flags
        );
};

#endif // !_IMGFACTORY_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\imgfactory.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   imgfactory.cpp
*
* Abstract:
*
*   Implementation of GpImagingFactory class
*
* Revision History:
*
*   05/11/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   Create an image object from an input stream
*
* Arguments:
*
*   stream - Specifies the input data stream
*   image - Returns a pointer to an IImage object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::CreateImageFromStream(
    IN IStream* stream,
    OUT IImage** image
    )
{
    HRESULT hr;
    GpDecodedImage* img;

    hr = GpDecodedImage::CreateFromStream(stream, &img);

    if (SUCCEEDED(hr))
        *image = img;

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Create an image object from a file
*
* Arguments:
*
*   filename - Specifies the name of the image file
*   image - Returns a pointer to an IImage object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::CreateImageFromFile(
    IN const WCHAR* filename,
    OUT IImage** image
    )
{
    HRESULT hr;
    GpDecodedImage* img;

    hr = GpDecodedImage::CreateFromFile(filename, &img);

    if (SUCCEEDED(hr))
        *image = img;

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Create an image object from a memory buffer
*
* Arguments:
*
*   buf - Pointer to the memory buffer
*   size - Size of the buffer, in bytes
*   disposalFlags - How to dispose the buffer after image is released
*   image - Returns a pointer to an IImage object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::CreateImageFromBuffer(
    IN const VOID* buf,
    IN UINT size,
    IN BufferDisposalFlag disposalFlag,
    OUT IImage** image
    )
{
    // Validate disposal flag parameter

    UINT allocFlag;

    switch (disposalFlag)
    {
    case DISPOSAL_NONE:
        allocFlag = GpReadOnlyMemoryStream::FLAG_NONE;
        break;

    case DISPOSAL_GLOBALFREE:
        allocFlag = GpReadOnlyMemoryStream::FLAG_GALLOC;
        break;

    case DISPOSAL_COTASKMEMFREE:
        allocFlag = GpReadOnlyMemoryStream::FLAG_COALLOC;
        break;

    case DISPOSAL_UNMAPVIEW:
        allocFlag = GpReadOnlyMemoryStream::FLAG_MAPFILE;
        break;
    
    default:
        return E_INVALIDARG;
    }

    // Create an IStream on top of the memory buffer
    
    GpReadOnlyMemoryStream* stream;

    stream = new GpReadOnlyMemoryStream();

    if (!stream)
        return E_OUTOFMEMORY;

    stream->InitBuffer(buf, size);

    // Create a decoded image object from the stream

    HRESULT hr;
    GpDecodedImage* img;
    
    hr = GpDecodedImage::CreateFromStream(stream, &img);

    if (SUCCEEDED(hr))
    {
        stream->SetAllocFlag(allocFlag);
        hr = img->QueryInterface(IID_IImage, (void **) image);
        img->Release();
    }

    stream->Release();

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Create a new bitmap image object
*
* Arguments:
*
*   width, height - Specifies the new bitmap dimension, in pixels
*   pixelFormat - Specifies the desired pixel data format
*   bitmap - Return a pointer to IBitmapImage interface
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

#define CREATEBITMAP_SNIPPET                        \
        *bitmap = NULL;                             \
        HRESULT hr;                                 \
        GpMemoryBitmap* bm = new GpMemoryBitmap();  \
        if (bm == NULL)                             \
            return E_OUTOFMEMORY;

#define CHECKBITMAP_SNIPPET                         \
        if (FAILED(hr))                             \
            delete bm;                              \
        else                                        \
            *bitmap = bm;                           \
        return hr;

HRESULT
GpImagingFactory::CreateNewBitmap(
    IN UINT width,
    IN UINT height,
    IN PixelFormatID pixelFormat,
    OUT IBitmapImage** bitmap
    )
{
    CREATEBITMAP_SNIPPET

    hr = bm->InitNewBitmap(width, height, pixelFormat);

    CHECKBITMAP_SNIPPET
}


/**************************************************************************\
*
* Function Description:
*
*   Create a bitmap image from an IImage object
*
* Arguments:
*
*   image - Specifies the source image object
*   width, height - Specifies the desired dimension of the bitmap
*       0 means the same dimension as the source image
*   hints - Specifies interpolation hints
*   bitmap - Return a pointer to IBitmapImage interface
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::CreateBitmapFromImage(
    IN IImage* image,
    IN OPTIONAL UINT width,
    IN OPTIONAL UINT height,
    IN OPTIONAL PixelFormatID pixelFormat,
    IN InterpolationHint hints,
    OUT IBitmapImage** bitmap
    )
{
    HRESULT hr;
    GpMemoryBitmap* bmp;

    hr = GpMemoryBitmap::CreateFromImage(
                image,
                width,
                height,
                pixelFormat,
                hints,
                &bmp);

    if (SUCCEEDED(hr))
        *bitmap = bmp;

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Create a new bitmap image object on user-supplied memory buffer
*
* Arguments:
*
*   bitmapData - Information about user-supplied memory buffer
*   pixelFormat - Specifies the desired pixel data format
*   bitmap - Return a pointer to IBitmapImage interface
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::CreateBitmapFromBuffer(
    IN BitmapData* bitmapData,
    OUT IBitmapImage** bitmap
    )
{
    CREATEBITMAP_SNIPPET

    hr = bm->InitMemoryBitmap(bitmapData);

    CHECKBITMAP_SNIPPET
}


/**************************************************************************\
*
* Function Description:
*
*   Create an image decoder object to process the specified input stream
*
* Arguments:
*
*   stream - Specifies the input data stream
*   flags - Misc. flags
*   decoder - Return a pointer to an IImageDecoder interface
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::CreateImageDecoder(
    IN IStream* stream,
    IN DecoderInitFlag flags,
    OUT IImageDecoder** decoder
    )
{
    // Find an approriate decoder object that
    // can handle the given input data stream.
    //
    // NOTE: We assume the returned decoder object
    // has already been initialize with the input stream.

    return CreateDecoderForStream(stream, decoder, flags);
}


/**************************************************************************\
*
* Function Description:
*
*   Create an image encoder object that can output data in
*   the specified image file format.
*
* Arguments:
*
*   clsid - Specifies the encoder object class ID
*   stream - Specifies the output data stream, or
*   filename - Specifies the output filename
*   encoder - Return a pointer to an IImageEncoder interface
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::CreateImageEncoderToStream(
    IN const CLSID* clsid,
    IN IStream* stream,
    OUT IImageEncoder** encoder
    )
{
    return CreateEncoderToStream(clsid, stream, encoder);
}

HRESULT
GpImagingFactory::CreateImageEncoderToFile(
    IN const CLSID* clsid,
    IN const WCHAR* filename,
    OUT IImageEncoder** encoder
    )
{
    HRESULT hr;
    IStream* stream;

    hr = CreateStreamOnFileForWrite(filename, &stream);

    if (SUCCEEDED(hr))
    {
        hr = CreateImageEncoderToStream(clsid, stream, encoder);
        stream->Release();
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Get a list of all currently installed image decoders
*
* Arguments:
*
*   count - Return the number of installed decoders 
*   decoders - Return a pointer to an array of ImageCodecInfo structures
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::GetInstalledDecoders(
    OUT UINT* count,
    OUT ImageCodecInfo** decoders
    )
{
    return GetInstalledCodecs(count, decoders, IMGCODEC_DECODER);
}


/**************************************************************************\
*
* Function Description:
*
*   Get a list of all currently installed image encoders
*
* Arguments:
*
*   count - Return the number of installed encoders
*   encoders - Return a pointer to an array of ImageCodecInfo structures
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::GetInstalledEncoders(
    OUT UINT* count,
    OUT ImageCodecInfo** encoders
    )
{
    return GetInstalledCodecs(count, encoders, IMGCODEC_ENCODER);
}


/**************************************************************************\
*
* Function Description:
*
*   Install an image encoder / decoder
*       caller should do the regular COM component
*       installation before calling this method
*
* Arguments:
*
*   codecInfo - Information about the codec
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::InstallImageCodec(
    IN const ImageCodecInfo* codecInfo
    )
{
    return InstallCodec(codecInfo);
}

/**************************************************************************\
*
* Function Description:
*
*   Uninstall an image encoder / decoder
*
* Arguments:
*
*   codecName - Specifies the name of the codec to be uninstalled
*   flags - Specifies whether to uninstall system-wide or per-user codec
*       IMGCODEC_SYSTEM or IMGCODEC_USER
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::UninstallImageCodec(
    IN const WCHAR* codecName,
    IN UINT flags
    )
{
    return UninstallCodec(codecName, flags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\imgrsrc.h ===
//
// Strings for built-in BMP codec
//

#define IDS_BMP_CODECNAME       2010
#define IDS_BMP_FORMATDESC      2011
#define IDS_BMP_FILENAMEEXT     2012
#define IDS_BMP_MIMETYPE        2013

#define IDS_JPEG_CODECNAME      2020
#define IDS_JPEG_FORMATDESC     2021
#define IDS_JPEG_FILENAMEEXT    2022
#define IDS_JPEG_MIMETYPE       2023

#define IDS_GIF_CODECNAME       2030
#define IDS_GIF_FORMATDESC      2031
#define IDS_GIF_FILENAMEEXT     2032
#define IDS_GIF_MIMETYPE        2033

#define IDS_EMF_CODECNAME       2040
#define IDS_EMF_FORMATDESC      2041
#define IDS_EMF_FILENAMEEXT     2042
#define IDS_EMF_MIMETYPE        2043

#define IDS_WMF_CODECNAME       2050
#define IDS_WMF_FORMATDESC      2051
#define IDS_WMF_FILENAMEEXT     2052
#define IDS_WMF_MIMETYPE        2053

#define IDS_TIFF_CODECNAME      2060
#define IDS_TIFF_FORMATDESC     2061
#define IDS_TIFF_FILENAMEEXT    2062
#define IDS_TIFF_MIMETYPE       2063

#define IDS_PNG_CODECNAME       2070
#define IDS_PNG_FORMATDESC      2071
#define IDS_PNG_FILENAMEEXT     2072
#define IDS_PNG_MIMETYPE        2073

#define IDS_ICO_CODECNAME       2080
#define IDS_ICO_FORMATDESC      2081
#define IDS_ICO_FILENAMEEXT     2082
#define IDS_ICO_MIMETYPE        2083
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\mmx.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   mmx.cpp
*
* Abstract:
*
*   MMX specific routines
*
* Revision History:
*
*   06/07/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#ifdef _X86_

/**************************************************************************\
*
* Function Description:
*
*   Use MMX to linearly interpolate between two scanlines
*
* Arguments:
*
*   dstbuf - Destination buffer
*   line0 - Pointer to the first source scanline
*   line1 - Pointer to the second source scanline
*   w0 - Weight for the first scanline, in .8 fixed point format
*   w1 - Weight for the second scanline
*   count - Number of ARGB pixels
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
MMXBilinearScale(
    ARGB* dstbuf,
    const ARGB* line0,
    const ARGB* line1,
    INT w0,
    INT w1,
    INT count
    )
{
    __asm
    {
        push    esi             ; save esi and edi on stack
        push    edi
        mov     ecx, count      ; ecx = count
        mov     edi, dstbuf     ; edi = dstbuf
        mov     esi, line0      ; esi = line0
        mov     ebx, line1      ; ebx = line1

        movd    mm3, w0         ; mm3 = w0 repeat 4 times
        movd    mm4, w1         ; mm4 = w1 repeat 4 times
        pxor    mm0, mm0        ; mm0 = 0
        punpcklwd mm3, mm3
        punpcklwd mm4, mm4
        punpcklwd mm3, mm3
        punpcklwd mm4, mm4

    L1:
        test    ecx, ecx        ; while ecx != 0
        jz      L2

        movd    mm1, [esi]      ; mm1 = next 4 bytes from line0
        dec     ecx
        add     esi, 4
        movd    mm2, [ebx]      ; mm2 = next 4 bytes from line1
        punpcklbw mm1, mm0
        add     ebx, 4
        punpcklbw mm2, mm0

        pmullw  mm1, mm3        ; mm1 <= mm1 * mm3 + mm2 * mm4
        pmullw  mm2, mm4
        paddw   mm1, mm2

        psrlw   mm1, 8
        packuswb mm1, mm0       ; save 4 result bytes to dstbuf
        movd    [edi], mm1
        add     edi, 4
        jmp     L1

    L2:
        pop     edi             ; restore edi and esi
        pop     esi
        emms
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Use MMX to interpolate four scanlines with specified weights
*
* Arguments:
*
*   dstbuf - Destination buffer
*   line0, line1, line2, line3 - Pointer to the source scanlines
*   w0, w1, w2, w3 - Weights for each source scanline
*   count - Number of ARGB pixels
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
MMXBicubicScale(
    ARGB* dstbuf,
    const ARGB* line0,
    const ARGB* line1,
    const ARGB* line2,
    const ARGB* line3,
    INT w0,
    INT w1,
    INT w2,
    INT w3,
    INT count
    )
{
    __asm
    {
        push    esi                 ; save esi and edi on stack
        push    edi

        movd    mm0, w0             ; mm0 = w0, 15-bit precision, repeated 4 times
        movd    mm1, w1             ; mm1 <=> w1
        movd    mm2, w2             ; mm2 <=> w2
        movd    mm3, w3             ; mm3 <=> w3

        psrlq   mm0, 1
        psrlq   mm1, 1
        psrlq   mm2, 1
        psrlq   mm3, 1

        punpcklwd mm0, mm0
        punpcklwd mm1, mm1
        punpcklwd mm2, mm2
        punpcklwd mm3, mm3

        punpcklwd mm0, mm0
        punpcklwd mm1, mm1
        punpcklwd mm2, mm2
        punpcklwd mm3, mm3

        mov     edi, dstbuf         ; edi = dstbuf
        mov     ecx, count          ; ecx = count
        mov     esi, line0          ; esi = line0
        mov     eax, line1          ; eax = line1
        mov     ebx, line2          ; ebx = line2
        mov     edx, line3          ; edx = line3
        pxor    mm7, mm7            ; mm7 = 0

    L1: test    ecx, ecx            ; while ecx != 0
        jz      L2
        dec     ecx

        movd    mm4, [esi]          ; next pixel from line0
        movd    mm5, [eax]          ; next pixel from line1
        punpcklbw mm4, mm7
        punpcklbw mm5, mm7
        psllw   mm4, 3
        psllw   mm5, 3
        pmulhw  mm4, mm0
        pmulhw  mm5, mm1
        add     esi, 4
        add     eax, 4

        movd    mm6, [ebx]          ; next pixel from line2
        paddsw  mm4, mm5
        punpcklbw mm6, mm7
        movd    mm5, [edx]          ; next pixel from line3
        psllw   mm6, 3
        punpcklbw mm5, mm7
        pmulhw  mm6, mm2
        psllw   mm5, 3
        paddsw  mm4, mm6
        pmulhw  mm5, mm3
        add     ebx, 4
        paddsw  mm4, mm5
        add     edx, 4
        psraw   mm4, 2

        packuswb mm4, mm7
        movd    [edi], mm4
        add     edi, 4
        jmp     L1

    L2:
        pop     edi                 ; restore edi and esi
        pop     esi
        emms
    }
}

#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\mmx.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   mmx.hpp
*
* Abstract:
*
*   MMX related declarations
*
* Revision History:
*
*   06/07/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _MMX_HPP
#define _MMX_HPP

#ifdef _X86_

// Use MMX to linearly interpolate two scanlines

VOID
MMXBilinearScale(
    ARGB* dstbuf,
    const ARGB* line0,
    const ARGB* line1,
    INT w0,
    INT w1,
    INT count
    );

// Use MMX to interpolate four scanlines with specified weights

VOID
MMXBicubicScale(
    ARGB* dstbuf,
    const ARGB* line0,
    const ARGB* line1,
    const ARGB* line2,
    const ARGB* line3,
    INT w0,
    INT w1,
    INT w2,
    INT w3,
    INT count
    );

#endif // _X86_

#endif // !_MMX_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\imgutils.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   imgutils.hpp
*
* Abstract:
*
*   Misc. utility functions and macros
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _IMGUTILS_HPP
#define _IMGUTILS_HPP

//--------------------------------------------------------------------------
// Memory allocation/deallocation macros
//--------------------------------------------------------------------------

inline LPVOID
GpCoAlloc(
    SIZE_T cb
    )
{
    #if PROFILE_MEMORY_USAGE
    MC_LogAllocation(cb);
    #endif
    return CoTaskMemAlloc(cb);
}
    
#define GpCoFree        CoTaskMemFree

#define SizeofSTR(s)    (sizeof(CHAR) * (strlen(s) + 1))
#define SizeofWSTR(s)   (sizeof(WCHAR) * (UnicodeStringLength(s) + 1))
#define ALIGN4(x)       (((x) + 3) & ~3)
#define ALIGN16(x)      (((x) + 15) & ~15)


//--------------------------------------------------------------------------
// Helper class for managing temporary memory buffer
// NOTE: This is intended to reduce malloc/free calls.
//--------------------------------------------------------------------------

class GpTempBuffer
{
public:
    GpTempBuffer(VOID* stackbuf, UINT bufsize)
    {
        buffer = stackbuf;
        this->bufsize = bufsize;
        allocFlag = FALSE;
    }

    GpTempBuffer()
    {
        buffer = NULL;
        bufsize = 0;
        allocFlag = FALSE;
    }

    ~GpTempBuffer()
    {
        if (allocFlag)
            GpFree(buffer);
    }

    VOID* GetBuffer()
    {
        return buffer;
    }

    BOOL Realloc(UINT size)
    {
        if (size <= bufsize)
            return TRUE;

        if (allocFlag)
            GpFree(buffer);
        
        allocFlag = TRUE;
        bufsize = size;
        buffer = GpMalloc(size);

        return buffer != NULL;
    }
    
private:
    
    VOID* buffer;
    UINT bufsize;
    BOOL allocFlag;

    // Disable copy constructor and assignment operator

    GpTempBuffer(const GpTempBuffer&);
    GpTempBuffer& operator=(const GpTempBuffer&);
};


//--------------------------------------------------------------------------
// Global critical section (for each process)
//--------------------------------------------------------------------------

class ImagingCritSec
{
public:

    static VOID InitializeCritSec()
    {
        __try
        {
            ::InitializeCriticalSection(&critSec);
        }
        __except(EXCEPTION_CONTINUE_SEARCH)
        {
        }

        initialized = TRUE;
    }

    static VOID DeleteCritSec()
    {
        if (initialized)
        {
            DeleteCriticalSection(&critSec);
            initialized = FALSE;
        }
    }

    ImagingCritSec()
    {
        ASSERT(initialized);
        EnterCriticalSection(&critSec);
    }

    ~ImagingCritSec()
    {
        ASSERT(initialized);
        LeaveCriticalSection(&critSec);
    }

private:
    static CRITICAL_SECTION critSec;
    static BOOL initialized;
};


//--------------------------------------------------------------------------
// Functions for dealing with ARGB color values
//--------------------------------------------------------------------------

// Convert 32bpp PARGB to 32bpp ARGB

ARGB Unpremultiply(ARGB argb);

// Convert 32bpp ARGB to 32bpp PARGB

inline ARGB Premultiply(ARGB argb)
{
    ARGB a = (argb >> ALPHA_SHIFT);

    if (a == 255)
        return argb;
    else if (a == 0)
        return 0;

    ARGB _000000gg = (argb >> 8) & 0x000000ff;
    ARGB _00rr00bb = (argb & 0x00ff00ff);

    ARGB _0000gggg = _000000gg * a + 0x00000080;
    _0000gggg += (_0000gggg >> 8);

    ARGB _rrrrbbbb = _00rr00bb * a + 0x00800080;
    _rrrrbbbb += ((_rrrrbbbb >> 8) & 0x00ff00ff);

    return (a << ALPHA_SHIFT) |
           (_0000gggg & 0x0000ff00) |
           ((_rrrrbbbb >> 8) & 0x00ff00ff);
}

// Fill an ARGB pixel buffer with the specified color value

inline VOID FillMemoryARGB(ARGB* p, UINT count, ARGB c)
{
    while (count--)
        *p++ = c;
}

// Copy an ARGB pixel buffer

inline VOID CopyMemoryARGB(ARGB* d, const ARGB* s, UINT count)
{
    while (count--)
        *d++ = *s++;
}

// Recursively delete a registry key

LONG
RecursiveDeleteRegKey(
    HKEY parentKey,
    const WCHAR* keyname
    );


//--------------------------------------------------------------------------
// Unicode wrappers for win9x
//--------------------------------------------------------------------------

LONG
_RegCreateKey(
    HKEY rootKey,
    const WCHAR* keyname,
    REGSAM samDesired,
    HKEY* hkeyResult
    );

LONG
_RegOpenKey(
    HKEY rootKey,
    const WCHAR* keyname,
    REGSAM samDesired,
    HKEY* hkeyResult
    );

LONG
_RegEnumKey(
    HKEY parentKey,
    DWORD index,
    WCHAR* subkeyStr
    );

LONG
_RegDeleteKey(
    HKEY parentKey,
    const WCHAR* keyname
    );

LONG
_RegSetString(
    HKEY hkey,
    const WCHAR* name,
    const WCHAR* value
    );

LONG
_RegSetDWORD(
    HKEY hkey,
    const WCHAR* name,
    DWORD value
    );

LONG
_RegSetBinary(
    HKEY hkey,
    const WCHAR* name,
    const VOID* value,
    DWORD size
    );

LONG
_RegGetDWORD(
    HKEY hkey,
    const WCHAR* name,
    DWORD* value
    );

LONG
_RegGetBinary(
    HKEY hkey,
    const WCHAR* name,
    VOID* buf,
    DWORD size
    );

LONG
_RegGetString(
    HKEY hkey,
    const WCHAR* name,
    WCHAR* buf,
    DWORD size
    );

BOOL
_GetModuleFileName(
    HINSTANCE moduleHandle,
    WCHAR* moduleName
    );

INT
_LoadString(
    HINSTANCE hInstance,
    UINT strId,
    WCHAR* buf,
    INT size
    );

HBITMAP
_LoadBitmap(
    HINSTANCE hInstance,
    const WCHAR *bitmapName
    );

HANDLE
_CreateFile(
    const WCHAR* filename,
    DWORD accessMode,
    DWORD shareMode,
    DWORD creationFlags,
    DWORD attrs
    );


//--------------------------------------------------------------------------
// Helper class for converting Unicode input strings to ANSI strings
//  NOTE: we only handle strings with length < MAX_PATH.
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
// IStream helper functions
//--------------------------------------------------------------------------

//Blocking and nonblocking reading from stream w/ error checking
HRESULT ReadFromStream(IN IStream* stream, OUT VOID* buffer, IN INT count, 
    IN BOOL blocking);

//Blocking and nonblocking seeking from stream w/ error checking
HRESULT SeekThroughStream(IN IStream* stream, IN INT count, IN BOOL 
    blocking);

inline BOOL
ReadStreamBytes(
    IStream* stream,
    VOID* buf,
    UINT size
    )
{
    ULONG cbRead;

    return SUCCEEDED(stream->Read(buf, size, &cbRead)) &&
           (size == cbRead);
}

inline BOOL
SeekStreamPos(
    IStream* stream,
    DWORD   dwOrigin,
    UINT pos
    )
{
    LARGE_INTEGER i;

    i.QuadPart = pos;
    return SUCCEEDED(stream->Seek(i, dwOrigin, NULL));
}

HRESULT
CreateStreamOnFileForRead(
    const WCHAR* filename,
    IStream** stream
    );

HRESULT
CreateStreamOnFileForWrite(
    const WCHAR* filename,
    IStream** stream
    );

HRESULT
CreateIPropertySetStorageOnHGlobal(
    IPropertySetStorage** propSet,
    HGLOBAL hmem = NULL
    );

inline HRESULT
GetWin32HRESULT()
{
    DWORD err = GetLastError();
    return err ? HRESULT_FROM_WIN32(err) : E_FAIL;
}


//--------------------------------------------------------------------------
// Print out debug messages using a message box
//--------------------------------------------------------------------------

#if DBG
VOID DbgMessageBox(const CHAR* format, ...);
#endif

//
// Trace function calls
//

#if DBG && defined(ENABLE_TRACE)
#define TRACE(msg) DbgPrint msg
#else
#define TRACE(msg)
#endif

#endif // !_IMGUTILS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\memstream.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   memstream.hpp
*
* Abstract:
*
*   Read-only memory stream declarations
*
* Revision History:
*
*   06/14/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _MEMSTREAM_HPP
#define _MEMSTREAM_HPP

class GpReadOnlyMemoryStream : public IUnknownBase<IStream>
{
public:

    GpReadOnlyMemoryStream()
    {
        membuf = NULL;
        memsize = curptr = 0;
        allocFlag = FLAG_NONE;
        hfile = INVALID_HANDLE_VALUE;
        filename = NULL;
    }

    ~GpReadOnlyMemoryStream()
    {
        VOID* p = (VOID*) membuf;

        // Free memory if necessary

        if (p != NULL)
        {
            switch (allocFlag)
            {
            case FLAG_GALLOC:
                GlobalFree((HGLOBAL) p);
                break;

            case FLAG_VALLOC:
                VirtualFree(p, 0, MEM_RELEASE);
                break;

            case FLAG_COALLOC:
                CoTaskMemFree(p);
                break;

            case FLAG_MAPFILE:
                UnmapViewOfFile(p);
                break;
            }
        }

        // Close the open file, if any

        if (hfile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hfile);
        }
        
        if (filename)
        {
            GpFree(filename);
        }
    }

    enum
    {
        FLAG_NONE,
        FLAG_GALLOC,
        FLAG_VALLOC,
        FLAG_COALLOC,
        FLAG_MAPFILE
    };

    VOID InitBuffer(const VOID* buf, UINT size, UINT allocFlag = FLAG_NONE)
    {
        membuf = (const BYTE*) buf;
        memsize = size;
        curptr = 0;
        this->allocFlag = allocFlag;
    }

    HRESULT InitFile(const WCHAR* filename);

    VOID SetAllocFlag(UINT allocFlag)
    {
        this->allocFlag = allocFlag;
    }

    //----------------------------------------------------------------
    // IStream interface methods
    //----------------------------------------------------------------

    STDMETHOD(Read)(
        VOID* buf,
        ULONG cb,
        ULONG* cbRead
        );

    STDMETHOD(Seek)(
        LARGE_INTEGER offset,
        DWORD origin,
        ULARGE_INTEGER* newPos
        );

    STDMETHOD(Stat)(
        STATSTG* statstg,
        DWORD statFlag
        );

    STDMETHOD(Write)(
        const VOID* buf,
        ULONG cb,
        ULONG* cbWritten
        )
    {
        return STG_E_ACCESSDENIED;
    }

    STDMETHOD(CopyTo)(
        IStream* stream,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER* cbRead,
        ULARGE_INTEGER* cbWritten
        )
    {
        return E_NOTIMPL;
    }
        
    STDMETHOD(SetSize)(
        ULARGE_INTEGER newSize
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(Commit)(
        DWORD commitFlags
        )
    {
        return S_OK;
    }

    STDMETHOD(Revert)()
    {
        return E_NOTIMPL;
    }

    STDMETHOD(LockRegion)(
        ULARGE_INTEGER offset,
        ULARGE_INTEGER cb,
        DWORD lockType
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(UnlockRegion)(
        ULARGE_INTEGER offset,
        ULARGE_INTEGER cb,
        DWORD lockType
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(Clone)(
        IStream** stream
        )
    {
        return E_NOTIMPL;
    }

private:

    GpLockable objectLock;
    const BYTE* membuf;
    UINT memsize;
    UINT curptr;
    UINT allocFlag;
    HANDLE hfile;
    WCHAR* filename;
};

class GpWriteOnlyMemoryStream : public IUnknownBase<IStream>
{
private:

    GpLockable objectLock;              // Object lock
    BYTE *m_pMemBuf;                    // Poinetr to memory buffer
    UINT m_uMemSize;                    // Memory buffer size
    UINT m_curPtr;                      // Current memory position

public:
    GpWriteOnlyMemoryStream()
    {
        m_pMemBuf = NULL;
        m_uMemSize = 0;
        m_curPtr = 0;
    }

    ~GpWriteOnlyMemoryStream()
    {
        // Free memory if necessary

        if (m_pMemBuf != NULL)
        {
            GpFree(m_pMemBuf);
            m_pMemBuf = NULL;
        }
        
        m_uMemSize = 0;
        m_curPtr = 0;
    }

    // This method lets the caller set the size of memory buffer being allocated

    HRESULT InitBuffer(const UINT uSize)
    {
        // Initialize buffer size should be bigger than zero

        if (uSize == 0)
        {
            return E_INVALIDARG;
        }

        HRESULT hr = E_OUTOFMEMORY;
        m_pMemBuf = (BYTE*)GpMalloc(uSize);
        if (m_pMemBuf)
        {
            m_uMemSize = uSize;
            m_curPtr = 0;

            hr = S_OK;
        }

        return hr;
    }

    // This method returns how many bytes have been written in the buffer and
    // also returns the starting pointer of the memory buffer
    
    HRESULT GetBitsPtr(BYTE **ppStartPtr, UINT *puSize)
    {
        HRESULT hr = E_INVALIDARG;

        if (ppStartPtr && puSize)
        {
            *ppStartPtr = m_pMemBuf;
            *puSize = m_curPtr;
            hr = S_OK;
        }

        return hr;
    }

    //----------------------------------------------------------------
    // IStream interface methods
    //----------------------------------------------------------------

    STDMETHOD(Read)(
        VOID* buf,
        ULONG cb,
        ULONG* cbRead
        )
    {
        // This is a write only class. Can't allow Read()

        return STG_E_ACCESSDENIED;
    }

    STDMETHOD(Seek)(
        LARGE_INTEGER offset,
        DWORD origin,
        ULARGE_INTEGER* newPos
        );

    STDMETHOD(Stat)(
        STATSTG* statstg,
        DWORD statFlag
        );

    STDMETHOD(Write)(
        const VOID* buf,
        ULONG cb,
        ULONG* cbWritten
        );

    STDMETHOD(CopyTo)(
        IStream* stream,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER* cbRead,
        ULARGE_INTEGER* cbWritten
        )
    {
        return E_NOTIMPL;
    }
        
    STDMETHOD(SetSize)(
        ULARGE_INTEGER newSize
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(Commit)(
        DWORD commitFlags
        )
    {
        return S_OK;
    }

    STDMETHOD(Revert)()
    {
        return E_NOTIMPL;
    }

    STDMETHOD(LockRegion)(
        ULARGE_INTEGER offset,
        ULARGE_INTEGER cb,
        DWORD lockType
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(UnlockRegion)(
        ULARGE_INTEGER offset,
        ULARGE_INTEGER cb,
        DWORD lockType
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(Clone)(
        IStream **stream
        )
    {
        return E_NOTIMPL;
    }
};

#endif // !_MEMSTREAM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\memstream.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   memstream.cpp
*
* Abstract:
*
*   Read-only memory stream implementation
*
* Revision History:
*
*   06/14/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   Read data from a memory stream
*
* Arguments:
*
*   buf - Points to the output buffer for reading data into
*   cb - Number of bytes to read
*   cbRead - Returns the number of bytes actually read
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpReadOnlyMemoryStream::Read(
    VOID* buf,
    ULONG cb,
    ULONG* cbRead
    )
{
    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    HRESULT hr = S_OK;
    UINT n = memsize - curptr;

    if (n > cb)
        n = cb;

    __try
    {
        GpMemcpy(buf, membuf+curptr, n);
        curptr += n;
        if (cbRead) *cbRead = n;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = STG_E_READFAULT;
        if (cbRead) *cbRead = 0;
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Change the current pointer in a memory stream
*
* Arguments:
*
*   offset - Specifies the amount of movement
*   origin - Specifies the origin of movement
*   newPos - Returns the new pointer position after the move
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpReadOnlyMemoryStream::Seek(
    LARGE_INTEGER offset,
    DWORD origin,
    ULARGE_INTEGER* newPos
    )
{
    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    LONGLONG pos;

    switch (origin)
    {
    case STREAM_SEEK_SET:

        pos = offset.QuadPart;
        break;

    case STREAM_SEEK_END:

        pos = memsize;
        break;
    
    case STREAM_SEEK_CUR:

        pos = (LONGLONG) curptr + offset.QuadPart;
        break;

    default:

        pos = -1;
        break;
    }

    if (pos < 0 || pos > memsize)
        return E_INVALIDARG;

    curptr = (DWORD) pos;

    if (newPos)
        newPos->QuadPart = pos;

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Return general information about a memory stream
*
* Arguments:
*
*   statstg - Output buffer
*   statFlag - Misc. flags
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpReadOnlyMemoryStream::Stat(
    STATSTG* statstg,
    DWORD statFlag
    )
{
    if (NULL == statstg)
    {
        return E_INVALIDARG;
    }
    
    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    ZeroMemory(statstg, sizeof(STATSTG));

    statstg->type = STGTY_STREAM;
    statstg->cbSize.QuadPart = memsize;
    statstg->grfMode = STGM_READ;

    if (hfile != INVALID_HANDLE_VALUE &&
        !GetFileTime(hfile, 
                     &statstg->ctime,
                     &statstg->atime,
                     &statstg->mtime))
    {
        return GetWin32HRESULT();
    }

    if (!(statFlag & STATFLAG_NONAME))
    {
        const WCHAR* p = filename ? filename : L"";
        INT count = SizeofWSTR(p);

        #if PROFILE_MEMORY_USAGE
        MC_LogAllocation(count);
        #endif
        
        statstg->pwcsName = (WCHAR*) CoTaskMemAlloc(count);

        if (!statstg->pwcsName)
            return E_OUTOFMEMORY;
        
        GpMemcpy(statstg->pwcsName, p, count);
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Initialize a read-only memory stream by mapping a file
*
* Arguments:
*
*   filename - Specifies the name of the input file
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpReadOnlyMemoryStream::InitFile(
    const WCHAR* filename
    )
{
    // Make a copy of the filename string

    this->filename = UnicodeStringDuplicate(filename);

    if (!this->filename)
        return E_OUTOFMEMORY;

    // Open a handle to the specified file
    // Set access mode to READ
    // Set share mode as READ which means the subsequent open operations on
    //   this file will succeed if and only if it is a READ operation.
    //   (NOTE: we can't put FILE_SHARE_WRITE here to enable the subsequent
    //   write operation on this image. The reason is that we do a memory
    //   mapping below. If we allow the user writes to the same file, it
    //   means that the decoder and encoder will point to the same piece of
    //   data in memory. This will damage the result image if we write some
    //   bits and read from it later.
    // OPEN_EXISTING means to open the file. The function fails if the file
    //   does not exist. 

    hfile = _CreateFile(filename,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL);

    if (hfile == INVALID_HANDLE_VALUE)
        return GetWin32HRESULT();

    // Obtain the file size
    //  NOTE: We don't support files larger than 4GB.

    DWORD sizeLow, sizeHigh;
    sizeLow = GetFileSize(hfile, &sizeHigh);

    if (sizeLow == 0xffffffff || sizeHigh != 0)
        return GetWin32HRESULT();

    // Map the file into memory

    HANDLE filemap;
    VOID* fileview = NULL;

    filemap = CreateFileMappingA(hfile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (filemap)
    {
        fileview = MapViewOfFile(filemap, FILE_MAP_READ, 0, 0, 0);
        CloseHandle(filemap);
    }

    if (!fileview)
        return GetWin32HRESULT();

    InitBuffer(fileview, sizeLow, FLAG_MAPFILE);
    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Create an IStream on top of a file for reading
*
* Arguments:
*
*   filename - Specifies the filename
*   stream - Returns a pointer to the newly created stream object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
CreateStreamOnFileForRead(
    const WCHAR* filename,
    IStream** stream
    )
{
    // Create a new GpReadOnlyMemoryStream object

    GpReadOnlyMemoryStream* memstrm;

    memstrm = new GpReadOnlyMemoryStream();

    if (!memstrm)
        return E_OUTOFMEMORY;

    // Initialize it with a memory mapped file

    HRESULT hr = memstrm->InitFile(filename);

    if (FAILED(hr))
        delete memstrm;
    else
        *stream = static_cast<IStream*>(memstrm);

    return hr;
}

// GpWriteOnlyMemoryStream

/**************************************************************************\
*
* Function Description:
*
*   Change the current pointer in a memory stream
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpWriteOnlyMemoryStream::Seek(
    LARGE_INTEGER offset,   // Specifies the amount of movement
    DWORD origin,           // Specifies the origin of movement
    ULARGE_INTEGER* newPos  // Returns the new pointer position after the move
    )
{
    GpLock lock(&objectLock);

    if (lock.LockFailed())
    {
        return IMGERR_OBJECTBUSY;
    }

    LONGLONG pos = 0;

    switch (origin)
    {
    case STREAM_SEEK_SET:
        pos = offset.QuadPart;
        break;

    case STREAM_SEEK_END:
        pos = m_uMemSize;
        break;
    
    case STREAM_SEEK_CUR:
        pos = (LONGLONG)m_curPtr + offset.QuadPart;
        break;

    default:
        pos = -1;
        break;
    }

    if ((pos < 0) || (pos > m_uMemSize))
    {
        return E_INVALIDARG;
    }

    m_curPtr = (DWORD)pos;

    if (newPos)
    {
        newPos->QuadPart = pos;
    }

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*   Return general information about a memory stream
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpWriteOnlyMemoryStream::Stat(
    STATSTG* statstg,       // Output buffer
    DWORD statFlag          // Misc. flags
    )
{
    if (NULL == statstg)
    {
        return E_INVALIDARG;
    }

    GpLock lock(&objectLock);

    if (lock.LockFailed())
    {
        return IMGERR_OBJECTBUSY;
    }

    ZeroMemory(statstg, sizeof(STATSTG));

    statstg->type = STGTY_STREAM;
    statstg->cbSize.QuadPart = m_uMemSize;
    statstg->grfMode = STGM_WRITE;              // Write only
    statstg->pwcsName = NULL;                   // No file name

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*   Write data into a file stream
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpWriteOnlyMemoryStream::Write(
    IN const VOID* srcBuf,      // Pointer to buffer of data to be written
    IN ULONG cbNeedToWrite,     // Specifies the number of bytes to write
    OUT ULONG *cbWritten        // Returns the number of bytes actually written
    )
{
    if ((NULL == srcBuf) || (NULL == cbWritten))
    {
        return E_INVALIDARG;
    }

    if (cbNeedToWrite == 0)
    {
        return S_OK;
    }

    GpLock lock(&objectLock);

    if (lock.LockFailed())
    {
        return IMGERR_OBJECTBUSY;
    }
    
    // Check if the unfilled bytes left in our memory buffer can hold the
    // requirement or not

    ASSERT(m_uMemSize >= m_curPtr);

    if ((m_uMemSize - m_curPtr) < cbNeedToWrite)
    {
        // Can't fill the requirement, then double current memory buffer

        UINT uNewSize = (m_uMemSize << 1);

        // Check if this new size can meet the requirement

        ASSERT(uNewSize >= m_curPtr);
        if ((uNewSize - m_curPtr) < cbNeedToWrite)
        {
            // If not, then just allocate whatever the caller asks for
            // That is, the new size will be the caller asks for "cbNeedToWrite"
            // plus all the BYTEs we have written "m_curPtr"

            uNewSize = cbNeedToWrite + m_curPtr;
        }

        BYTE *pbNewBuf = (BYTE*)GpRealloc(m_pMemBuf, uNewSize);

        if (pbNewBuf)
        {
            // Note: GpRealloc() will copy the old contents into "pbNewBuf"
            // before return to us if it succeed

            m_pMemBuf = pbNewBuf;

            // Update memory buffer size.
            // Note: we don't need to update m_curPtr.

            m_uMemSize = uNewSize;
        }
        else
        {
            // Note: if the memory expansion failed, we simply return. So we
            // still have all the old contents. The contents buffer will be
            // freed when the destructor is called.

            WARNING(("GpWriteOnlyMemoryStream::Write---Out of memory"));
            return E_OUTOFMEMORY;
        }        
    }// If the buffer left is too small

    ASSERT((m_uMemSize - m_curPtr) >= cbNeedToWrite);
    
    HRESULT hr = S_OK;

    __try
    {
        GpMemcpy(m_pMemBuf + m_curPtr, srcBuf, cbNeedToWrite);

        // Move the current pointer

        m_curPtr += cbNeedToWrite;
        *cbWritten = cbNeedToWrite;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // Note: we return STG_E_READFAULT, rather than STG_E_WRITEFAULT
        // because we are sure the destination buffer is OK. The reason we get
        // an exception is most likely due to the source. For example, if the
        // source is the result of file mapping across the net. It might not
        // available at this moment when we do the copy

        hr = STG_E_READFAULT;
        *cbWritten = 0;
    }

    return hr;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\propertyutil.cpp ===
#include "precomp.hpp"
#include "propertyutil.hpp"

#define PROPID_NAME_FIRST 1024

/**************************************************************************\
*
* Function Description:
*
*     This function returns a SysAllocString compatible string, but
*     without introducing a dependency on oleaut32.dll.
*     Note:  Do not use this to allocate strings that will be freed
*     with oleaut32's SysFreeString, because they may not come from
*     the same heap.
*
* Arguments:
*
*     sz - string to be allocated
*
* Return Value:
*
*   BSTR string
*
\**************************************************************************/

BSTR
ImgSysAllocString(
    const OLECHAR *sz
    )
{
    INT len   = UnicodeStringLength(sz);
    BSTR bstr = (BSTR) GpMalloc(sizeof(WCHAR) * (len + 1) + sizeof(ULONG));
    if (bstr) 
    {
        *((ULONG *) bstr) = len * sizeof(WCHAR);
        bstr = (BSTR) (((ULONG *) bstr) + 1); // Return a pointer just past
                                              // the dword count
        UnicodeStringCopy(bstr, sz);
    }
    
    return bstr;
}

/**************************************************************************\
*
* Function Description:
*
*     This functions frees a BSTR allocated with ImgSysAllocString.
*     Note:  Do not use this function to free a string allocated using
*     oleaut32's SysAllocString, because they may not come from the
*     same heap
*
* Arguments:
*
*     sz - string to be allocated
*
* Return Value:
*
*   BSTR string
*
\**************************************************************************/

VOID
ImgSysFreeString(
    BSTR bstr
    )
{
    if (bstr) 
    {
        bstr = (BSTR) (((ULONG *) bstr) - 1);  // Allocation starts 4 bytes before the first character
        GpFree(bstr);
    }
}


/**************************************************************************\
*
* Function Description:
*
*     Adds a unicode string to a property storage
*
* Arguments:
*
*     propStg -- The property storage to modify
*     pwszKey -- A string value describing the property
*     propidKey -- a PROPID describing the property
*     value -- A unicode string to be used as the value
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT 
AddProperty(
    IPropertyStorage *propStg, 
    PROPID propidKey, 
    WCHAR *value
    )
{
    HRESULT hresult;
    PROPSPEC propSpec[2];
    INT cSpec = 0;

    if ( propidKey != 0 )
    {        
        propSpec[cSpec].ulKind = PRSPEC_PROPID;
        propSpec[cSpec].propid = propidKey;
        cSpec++;
    }

    PROPVARIANT variant[1];
    PropVariantInit(&variant[0]);
    variant[0].vt = VT_BSTR;
    BSTR bstr = ImgSysAllocString(value);
    variant[0].bstrVal = bstr;

    hresult = propStg->WriteMultiple(cSpec, propSpec, variant, PROPID_NAME_FIRST);

    ImgSysFreeString(bstr);
    return hresult;
}

/**************************************************************************\
*
* Function Description:
*
*     Adds a single byte string to a property storage
*
* Arguments:
*
*     propStg -- The property storage to modify
*     pwszKey -- A string value describing the property
*     propidKey -- a PROPID describing the property
*     value -- A character string to be used as the value
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT 
AddProperty(
    IPropertyStorage *propStg, 
    PROPID propidKey, 
    CHAR *value
    )
{
    HRESULT hresult;

    WCHAR str[MAX_PATH];
    if (!AnsiToUnicodeStr(value, str, MAX_PATH)) 
    {
        return E_FAIL;
    }
    
    PROPSPEC propSpec[2];
    INT cSpec = 0;

    if ( propidKey != 0 )
    {        
        propSpec[cSpec].ulKind = PRSPEC_PROPID;
        propSpec[cSpec].propid = propidKey;
        cSpec++;
    }

    PROPVARIANT variant[1];
    PropVariantInit(&variant[0]);
    variant[0].vt = VT_BSTR;
    BSTR bstr = ImgSysAllocString(str);
    variant[0].bstrVal = bstr;

    hresult = propStg->WriteMultiple(cSpec, propSpec, variant, PROPID_NAME_FIRST);

    ImgSysFreeString(bstr);
    return hresult;
}

/**************************************************************************\
*
* Function Description:
*
*     Adds an integer to a property storage
*
* Arguments:
*
*     propStg -- The property storage to modify
*     pwszKey -- A string value describing the property
*     propidKey -- a PROPID describing the property
*     value -- An integer to be used as the value
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT 
AddProperty(
    IPropertyStorage *propStg,
    PROPID propidKey, 
    INT value
    )
{
    PROPSPEC propSpec[2];
    INT cSpec = 0;

    if ( propidKey != 0 )
    {        
        propSpec[cSpec].ulKind = PRSPEC_PROPID;
        propSpec[cSpec].propid = propidKey;
        cSpec++;
    }

    PROPVARIANT variant[1];
    PropVariantInit(&variant[0]);
    variant[0].vt = VT_I4;
    variant[0].lVal = value;

    return propStg->WriteMultiple(cSpec, propSpec, variant, PROPID_NAME_FIRST); 
}

/**************************************************************************\
*
* Function Description:
*
*     Adds a double to a property storage
*
* Arguments:
*
*     propStg -- The property storage to modify
*     pwszKey -- A string value describing the property
*     propidKey -- a PROPID describing the property
*     value -- A double to be used as the value
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT 
AddProperty(
    IPropertyStorage *propStg,
    PROPID propidKey, 
    double value
    )
{
    PROPSPEC propSpec[2];
    INT cSpec = 0;

    if ( propidKey != 0 )
    {        
        propSpec[cSpec].ulKind = PRSPEC_PROPID;
        propSpec[cSpec].propid = propidKey;
        cSpec++;
    }

    PROPVARIANT variant[1];
    PropVariantInit(&variant[0]);
    variant[0].vt = VT_R8;
    variant[0].dblVal = value;

    return propStg->WriteMultiple(cSpec, propSpec, variant, PROPID_NAME_FIRST); 
}

HRESULT 
AddProperty(
    IPropertyStorage*   propStg, 
    PROPID              propidKey, 
    UCHAR*              value,
    UINT                uiLength
    )
{
    PROPSPEC propSpec[2];
    INT cSpec = 0;

    if ( propidKey != 0 )
    {        
        propSpec[cSpec].ulKind = PRSPEC_PROPID;
        propSpec[cSpec].propid = propidKey;
        cSpec++;
    }

    PROPVARIANT variant[1];
    PropVariantInit(&variant[0]);
    variant[0].vt = VT_VECTOR | VT_UI1;
    variant[0].caub.cElems = uiLength;
    variant[0].caub.pElems = value;

    return propStg->WriteMultiple(cSpec, propSpec, variant, PROPID_NAME_FIRST);
}

HRESULT
AddProperty(
    IPropertyStorage* propStg,
    PROPID              propidKey,
    FILETIME            value
    )
{
    PROPSPEC propSpec[2];
    INT cSpec = 0;

    if ( propidKey != 0 )
    {        
        propSpec[cSpec].ulKind = PRSPEC_PROPID;
        propSpec[cSpec].propid = propidKey;
        cSpec++;
    }

    PROPVARIANT variant[1];
    PropVariantInit(&variant[0]);
    variant[0].vt = VT_FILETIME;
    variant[0].filetime = value;

    return propStg->WriteMultiple(cSpec, propSpec, variant, PROPID_NAME_FIRST);
}

HRESULT
AddPropertyList(
    InternalPropertyItem*   pTail,
    PROPID                  id,
    UINT                    uiLength,
    WORD                    wType,
    VOID*                   pValue
    )
{
    InternalPropertyItem* pNewItem = new InternalPropertyItem();

    if ( pNewItem == NULL )
    {
        return E_OUTOFMEMORY;
    }

    pNewItem->id = id;
    pNewItem->type = wType;
    pNewItem->length = uiLength;
    pNewItem->value = GpMalloc(uiLength);
    if ( pNewItem->value == NULL )
    {
        // need to clean up this if we allocated the first one and 
        // failed the second one.
        
        delete pNewItem;
        
        WARNING(("AddPropertyList--out of memory"));
        return E_OUTOFMEMORY;
    }

    GpMemcpy(pNewItem->value, pValue, uiLength);
    
    pTail->pPrev->pNext = pNewItem;
    pNewItem->pPrev = pTail->pPrev;
    pNewItem->pNext = pTail;
    pTail->pPrev = pNewItem;

    return S_OK;
}// AddPropertyList()

HRESULT
RemovePropertyItemFromList(
    InternalPropertyItem*   pItem
    )
{
    if ( pItem == NULL )
    {
        WARNING(("JPEG::RemovePropertyItemFromList--Empty input"));
        return E_FAIL;
    }

    // Free the memory allocated in this item

    GpFree(pItem->value);

    InternalPropertyItem*   pPrev = pItem->pPrev;
    InternalPropertyItem*   pNext = pItem->pNext;

    // pPrev will never be NULL because we always have the guardian, the header
    // note in the list. Same for the tail node

    ASSERT(pPrev != NULL);
    ASSERT(pNext != NULL);

    pPrev->pNext = pNext;
    pNext->pPrev = pPrev;

    return S_OK;
}// AddPropertyList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\pointops.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   pointops.cpp
*
* Abstract:
*
*   Perform basic point operations on a bitmap image
*
* Revision History:
*
*   07/16/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   Adjust the brightness of the bitmap image
*
* Arguments:
*
*   percent - Specifies how much to adjust the brightness by
*       assuming intensity value is between 0 and 1
*       new intensity = old intensity + percent
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::AdjustBrightness(
    IN FLOAT percent
    )
{
    if (percent > 1 || percent < -1)
        return E_INVALIDARG;

    // Compute the lookup table entries

    BYTE lut[256];
    INT incr = (INT) (percent * 255);

    for (INT i=0; i < 256; i++)
    {
        INT j = i + incr;
        lut[i] = (BYTE) ((j < 0) ? 0 : (j > 255) ? 255 : j);
    }

    // Call the common function to do the work

    return PerformPointOps(lut);
}


/**************************************************************************\
*
* Function Description:
*
*   Adjust the contrast of the bitmap image
*
* Arguments:
*
*   shadow - new intensity value corresponding to old intensity value 0
*   highlight - new intensity value corresponding to old value 1
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::AdjustContrast(
    IN FLOAT shadow,
    IN FLOAT highlight
    )
{
    BYTE lut[256];

    // Compute the lookup table entries

    INT l, h;

    l = (INT) (shadow * 255);
    h = (INT) (highlight * 255);

    if (l > h)
        return E_INVALIDARG;
    
    for (INT i=0; i < 256; i++)
    {
        INT j = l + i * (h - l) / 255;
        lut[i] = (BYTE) ((j < 0) ? 0 : (j > 255) ? 255 : j);
    }

    // Call the common function to do the work

    return PerformPointOps(lut);
}


/**************************************************************************\
*
* Function Description:
*
*   Adjust the gamma of the bitmap image
*
* Arguments:
*
*   gamma - Specifies the gamma value
*       new intensity = old intensity ** gamma
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::AdjustGamma(
    IN FLOAT gamma
    )
{
    // Compute the lookup table entries

    BYTE lut[256];

    lut[0] = 0;

    for (INT i=1; i < 256; i++)
        lut[i] = (BYTE) (pow(i / 255.0, gamma) * 255);

    // Call the common function to do the work

    return PerformPointOps(lut);
}


/**************************************************************************\
*
* Function Description:
*
*   Perform point operation on an array of 32bpp pixels
*
* Arguments:
*
*   pixbuf - Pointer to the pixel buffer to be operated on
*   count - Pixel count
*   lut - Specifies the lookup table to be used
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
PointOp32bppProc(
    ARGB* pixbuf,
    UINT count,
    const BYTE lut[256]
    )
{
    while (count--)
    {
        ARGB p = *pixbuf;

        *pixbuf++ = ((ARGB) lut[ p        & 0xff]      ) |
                    ((ARGB) lut[(p >>  8) & 0xff] <<  8) |
                    ((ARGB) lut[(p >> 16) & 0xff] << 16) |
                    (p & 0xff000000);
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Perform point operation on an array of 24bpp pixels
*
* Arguments:
*
*   pixbuf - Pointer to the pixel buffer to be operated on
*   count - Pixel count
*   lut - Specifies the lookup table to be used
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
PointOp24bppProc(
    BYTE* pixbuf,
    UINT count,
    const BYTE lut[256]
    )
{
    count *= 3;

    while (count--)
    {
        *pixbuf = lut[*pixbuf];
        pixbuf++;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Perform point operations on a bitmap image
*
* Arguments:
*
*   lut - Specifies the lookup table to be used
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::PerformPointOps(
    const BYTE lut[256]
    )
{
    // Lock the current bitmap image object

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    // If we're dealing with indexed color images,
    // then perform the point operation on the color palette

    if (IsIndexedPixelFormat(PixelFormat))
    {
        ColorPalette* pal = CloneColorPalette(GetCurrentPalette());

        if (pal == NULL)
            return E_OUTOFMEMORY;
        
        PointOp32bppProc(
            pal->Entries,
            pal->Count,
            lut);
        
        GpFree(colorpal);
        colorpal = pal;

        return S_OK;
    }

    // Determine what pixel format we want to operate on

    PixelFormatID pixfmt;
        
    if (PixelFormat == PIXFMT_24BPP_RGB ||
        PixelFormat == PIXFMT_32BPP_RGB ||
        PixelFormat == PIXFMT_32BPP_ARGB)
    {
        pixfmt = PixelFormat;
    }
    else
        pixfmt = PIXFMT_32BPP_ARGB;

    // Allocate temporary scanline buffer if necessary

    GpTempBuffer tempbuf(NULL, 0);
    BitmapData bmpdata;
    RECT rect = { 0, 0, Width, 1 };
    UINT flags = IMGLOCK_READ|IMGLOCK_WRITE;
    HRESULT hr;

    if (pixfmt != PixelFormat)
    {
        bmpdata.Stride = Width * sizeof(ARGB);
        bmpdata.Reserved = 0;

        if (!tempbuf.Realloc(bmpdata.Stride))
            return E_OUTOFMEMORY;
        
        bmpdata.Scan0 = tempbuf.GetBuffer();
        flags |= IMGLOCK_USERINPUTBUF;
    }

    // Process one scanline at a time
    //
    // NOTE: May want to consider doing multiple scanlines
    // per iteration to reduce the overhead from calling
    // Lock/UnlockBits.

    for (UINT y=0; y < Height; y++)
    {
        hr = InternalLockBits(&rect, flags, pixfmt, &bmpdata);

        if (FAILED(hr))
            return hr;

        if (pixfmt == PIXFMT_24BPP_RGB)
        {
            PointOp24bppProc(
                (BYTE*) bmpdata.Scan0,
                bmpdata.Width,
                lut);
        }
        else
        {
            PointOp32bppProc(
                (ARGB*) bmpdata.Scan0,
                bmpdata.Width,
                lut);
        }

        InternalUnlockBits(&rect, &bmpdata);

        rect.top += 1;
        rect.bottom += 1;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Perform color adjustment on a bitmap image
*
* Arguments:
*
*   imageAttributes - Pointer to the color adjustment parameters
*   callback - Abort callback
*   callbackData - Data to pass to the abort callback
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::PerformColorAdjustment(
    IN GpRecolor* recolor,
    IN ColorAdjustType type,
    IN DrawImageAbort callback,
    IN VOID* callbackData
    )
{
    // Lock the current bitmap image object

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    // Flush dirty state

    recolor->Flush();

    // If we're dealing with indexed color images,
    // then perform the point operation on the color palette

    if (IsIndexedPixelFormat(PixelFormat))
    {
        ColorPalette* pal = CloneColorPalette(GetCurrentPalette());

        if (pal == NULL)
            return E_OUTOFMEMORY;
        
        recolor->ColorAdjust(
            pal->Entries,
            pal->Count,
            type
        );
        
        GpFree(colorpal);
        colorpal = pal;

        return S_OK;
    }

    // Determine what pixel format we want to operate on

    PixelFormatID pixfmt;

    //!!!TODO: can optimize for 24bpp by implementing
    //!!!      GpRecolor::ColorAdjust24bppProc
    //!!!      (see GpMemoryBitmap:: and PointOp24bppProc above)

    if (PixelFormat == PIXFMT_32BPP_RGB ||
        PixelFormat == PIXFMT_32BPP_ARGB)
    {
        pixfmt = PixelFormat;
    }
    else
        pixfmt = PIXFMT_32BPP_ARGB;

    // Allocate temporary scanline buffer if necessary

    GpTempBuffer tempbuf(NULL, 0);
    BitmapData bmpdata;
    RECT rect = { 0, 0, Width, 1 };
    UINT flags = IMGLOCK_READ|IMGLOCK_WRITE;
    HRESULT hr;

    if (pixfmt != PixelFormat)
    {
        bmpdata.Stride = Width * sizeof(ARGB);
        bmpdata.Reserved = 0;

        if (!tempbuf.Realloc(bmpdata.Stride))
            return E_OUTOFMEMORY;
        
        bmpdata.Scan0 = tempbuf.GetBuffer();
        flags |= IMGLOCK_USERINPUTBUF;
    }

    // Process one scanline at a time
    //
    // NOTE: May want to consider doing multiple scanlines
    // per iteration to reduce the overhead from calling
    // Lock/UnlockBits.

    for (UINT y=0; y < Height; y++)
    {
        if (callback && ((*callback)(callbackData)))
        {
            return IMGERR_ABORT;
        }

        hr = InternalLockBits(&rect, flags, pixfmt, &bmpdata);

        if (FAILED(hr))
        {
            return hr;
        }

        recolor->ColorAdjust(
            static_cast<ARGB*>(bmpdata.Scan0),
            bmpdata.Width, 
            type
        );

        InternalUnlockBits(&rect, &bmpdata);

        rect.top += 1;
        rect.bottom += 1;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\propertyutil.hpp ===
#ifndef _PROPERTYUTIL_HPP_
#define _PROPERTYUTIL_HPP_

typedef struct tagInternalPropertyItem
{
    struct tagInternalPropertyItem*   pNext;
    struct tagInternalPropertyItem*   pPrev;
    PROPID  id;     // ID of this property
    ULONG   length; // Length of the property
    WORD    type;   // Type of the value, one of TAG_TYPE_ defined in imaging.h
    VOID*   value;  // property value
} InternalPropertyItem;

HRESULT
AddProperty(IPropertyStorage*   propStg, 
            PROPID              propidKey,
            WCHAR*              value);

HRESULT 
AddProperty(IPropertyStorage*   propStg, 
            PROPID              propidKey,
            CHAR*               value);

HRESULT 
AddProperty(IPropertyStorage*   propStg,
            PROPID              propidKey,
            INT                 value);

HRESULT 
AddProperty(IPropertyStorage*   propStg,
            PROPID              propidKey,
            double              value);

HRESULT 
AddProperty(IPropertyStorage*   propStg, 
            PROPID              propidKey,
            UCHAR*              value,
            UINT                uiLength);

HRESULT
AddProperty(IPropertyStorage* propStg,
            PROPID              propidKey,
            FILETIME            value);

HRESULT
AddPropertyList(InternalPropertyItem*   pTail,
                PROPID                  id,
                UINT                    uiLength,
                WORD                    wType,
                VOID*                   pValue);
HRESULT
RemovePropertyItemFromList(InternalPropertyItem* pItem);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\srgb2cmyk.h ===
BYTE SrgbToCmykTable[19652] =
{
200,210,221,214,241,255,255,255,255,255,255,255,253,248,244,242,242,
186,198,204,203,221,219,246,245,244,243,243,255,253,247,244,242,241,
168,186,198,206,215,214,232,240,238,253,251,250,242,237,233,230,228,
187,171,185,196,206,215,227,237,247,253,250,244,241,235,231,228,227,
193,175,188,190,197,206,217,228,235,240,248,238,232,226,222,225,224,
197,182,190,193,196,198,204,216,224,228,231,231,224,218,217,215,213,
200,201,191,200,198,198,197,204,212,216,218,221,216,210,207,205,203,
207,206,193,204,203,201,198,198,203,207,206,206,210,200,195,194,195,
209,213,197,204,209,206,202,198,199,201,199,194,193,188,182,180,181,
206,209,214,206,213,210,206,200,196,197,196,189,182,179,171,165,164,
201,203,207,205,211,211,207,201,194,191,191,188,179,172,168,155,151,
192,194,197,199,204,207,204,199,192,187,184,184,179,168,162,155,141,
183,184,186,190,197,199,198,195,189,183,179,177,175,167,157,154,143,
177,178,180,183,190,189,187,184,181,176,171,168,166,166,157,147,144,
177,178,180,182,183,181,180,176,173,171,165,160,155,152,155,145,137,
177,178,179,178,176,176,173,171,169,163,162,156,149,145,139,145,136,
177,178,177,175,174,174,171,170,164,162,162,154,147,141,136,128,137,
187,194,212,227,236,247,254,255,255,255,255,255,251,246,243,241,241,
172,182,198,212,225,238,243,242,242,242,255,255,251,246,243,241,240,
168,170,182,195,207,221,237,238,253,251,250,248,241,235,231,229,228,
174,171,173,185,198,209,223,235,245,251,249,246,239,233,230,227,226,
186,183,180,182,190,201,212,224,232,237,245,238,230,225,221,224,223,
192,193,185,187,190,192,200,212,221,225,229,229,222,217,216,214,213,
191,196,189,195,193,193,193,200,209,213,216,219,214,208,206,204,207,
193,202,191,202,199,197,194,195,200,204,203,204,206,198,195,193,195,
207,209,209,202,206,203,199,195,196,198,196,192,191,187,181,179,180,
205,208,213,205,211,208,203,197,194,195,194,187,181,178,169,164,163,
199,202,206,204,210,209,205,198,192,189,189,186,177,170,167,154,150,
191,193,196,200,204,206,202,197,190,185,183,182,177,166,161,154,140,
182,183,185,189,196,200,197,194,187,181,178,176,174,166,155,152,142,
177,178,180,183,189,188,186,183,180,175,170,167,165,164,156,146,143,
177,178,179,181,182,180,179,175,172,170,164,159,154,151,154,144,136,
177,178,178,177,175,175,172,170,168,162,161,155,148,144,138,144,135,
177,177,176,175,173,174,170,169,163,161,161,153,146,140,135,127,136,
159,166,187,187,218,233,249,253,255,255,255,253,248,244,241,239,239,
145,154,173,194,209,225,239,251,255,255,255,253,247,243,240,239,239,
143,144,157,176,195,211,228,241,249,248,247,244,237,233,229,238,238,
156,154,155,168,185,199,215,229,238,248,246,241,235,231,227,225,225,
165,171,167,168,178,192,205,218,226,232,240,234,227,222,224,222,221,
172,183,181,177,179,183,193,206,216,221,225,226,219,214,214,212,211,
186,188,189,187,185,184,185,193,204,209,212,216,211,206,204,202,205,
189,193,195,195,192,190,187,188,194,199,200,201,203,196,193,191,193,
193,204,203,199,200,197,193,190,191,194,192,189,188,184,179,177,179,
194,205,208,203,207,204,199,193,190,191,190,184,178,175,168,163,162,
191,200,203,209,208,206,201,195,189,186,186,183,174,167,160,152,149,
185,191,194,199,202,203,199,194,187,182,180,179,174,164,158,152,138,
180,182,184,187,195,197,195,190,184,179,175,173,171,164,153,150,141,
175,177,179,182,187,186,184,181,177,173,168,165,164,162,153,144,141,
176,177,178,180,179,178,175,173,170,168,162,157,153,149,152,142,134,
176,177,176,175,174,174,170,169,164,160,159,153,146,142,137,142,133,
176,175,175,173,171,172,168,167,162,159,159,153,144,138,133,126,135,
120,135,153,174,181,190,230,245,250,250,249,246,242,239,237,237,237,
115,124,145,168,186,207,224,237,252,254,251,246,242,239,237,236,236,
120,120,131,153,177,195,215,229,240,243,250,245,241,237,236,235,235,
136,133,131,143,165,184,202,218,228,239,241,235,230,226,224,222,222,
153,154,150,149,159,176,192,208,218,224,234,227,222,223,220,219,219,
166,167,167,164,163,169,181,196,208,214,218,220,215,213,211,209,209,
165,170,177,176,172,171,172,183,195,202,206,210,207,204,201,199,203,
170,186,184,184,182,178,176,178,185,192,193,195,198,192,190,188,191,
187,191,195,193,192,188,184,181,183,186,186,183,183,181,176,174,176,
190,193,202,201,200,197,191,186,183,184,183,178,173,171,164,161,161,
188,190,200,203,202,200,195,188,183,180,181,178,169,163,157,149,147,
182,184,191,196,200,198,195,189,182,177,175,175,170,159,154,149,136,
174,176,181,185,193,194,191,186,180,174,171,169,167,159,149,146,138,
166,167,177,180,184,182,180,177,174,170,165,163,161,159,150,141,136,
166,175,177,177,176,175,172,170,167,164,159,154,150,146,148,139,131,
167,174,174,173,171,171,168,166,161,158,156,150,145,140,134,139,130,
167,173,172,171,169,170,166,161,159,157,150,150,144,136,131,124,132,
 92,111,124,145,167,190,193,227,238,238,240,237,235,233,232,232,233,
 93,102,119,141,163,184,199,221,236,243,240,237,234,233,232,232,233,
101,102,111,132,156,177,198,213,226,242,238,235,233,231,230,230,231,
116,113,111,120,143,166,187,204,215,226,230,226,223,220,219,218,219,
136,134,130,126,134,157,176,194,206,214,223,221,219,217,215,215,215,
151,152,151,147,143,150,165,182,196,204,209,212,210,207,206,205,211,
158,160,161,161,157,154,157,169,184,193,198,203,201,198,196,199,199,
164,164,169,170,168,164,161,163,173,182,185,188,190,187,185,187,187,
169,172,182,181,180,176,171,169,171,175,177,176,176,174,171,172,173,
175,186,191,191,190,187,181,175,173,175,174,170,166,165,159,157,158,
183,185,189,195,194,192,187,180,174,172,173,170,162,157,153,146,144,
178,180,183,192,193,191,188,182,175,170,168,168,163,153,148,138,132,
171,172,175,181,186,187,184,180,174,168,165,164,162,154,144,139,133,
163,164,166,177,179,178,176,173,169,165,160,158,157,154,144,135,132,
164,165,167,173,172,171,168,165,162,157,154,149,146,143,144,135,127,
165,166,170,169,167,165,164,160,157,154,152,146,141,136,131,135,126,
165,166,169,168,166,163,162,158,156,153,147,146,140,133,128,120,128,
 75, 86,105,119,140,165,188,194,203,225,226,225,224,226,226,227,229,
 76, 84, 99,116,137,161,184,198,216,226,225,224,225,225,225,226,228,
 83, 86, 96,111,132,155,178,195,209,224,224,223,223,223,224,225,226,
 96, 95, 96,103,122,146,169,188,200,212,220,220,220,220,221,222,224,
113,112,109,105,112,135,156,177,191,201,211,210,209,209,209,210,211,
130,131,129,125,120,126,146,165,182,191,198,203,201,200,204,205,206,
142,142,143,143,139,134,138,153,170,181,187,193,192,193,193,194,195,
154,155,153,154,152,147,144,147,158,169,175,179,182,180,181,181,183,
161,164,166,166,165,161,155,153,156,162,166,166,168,167,166,167,171,
166,169,173,178,177,173,167,161,161,162,162,160,158,158,153,153,154,
169,171,182,185,184,181,176,168,163,162,163,159,153,149,145,141,141,
167,174,177,182,184,182,178,172,165,160,159,160,154,145,141,133,129,
166,167,170,174,181,179,176,172,166,160,157,156,154,146,137,133,128,
160,161,163,166,173,172,170,166,162,158,154,152,151,146,137,129,126,
161,162,164,166,166,164,162,159,155,151,149,144,141,138,138,129,121,
162,163,163,162,162,160,159,154,152,148,147,141,136,131,126,130,121,
163,162,161,163,161,158,158,153,151,145,142,141,135,130,124,116,123,
 62, 72, 86, 99,117,140,163,182,192,202,209,211,212,213,215,220,223,
 62, 70, 86, 97,114,136,160,178,194,204,208,210,212,213,217,219,222,
 66, 71, 82, 95,109,131,155,174,189,203,206,209,210,213,215,218,220,
 78, 78, 82, 91,103,124,147,169,182,194,203,206,208,210,212,215,218,
 91, 92, 91, 90, 97,114,136,159,175,185,196,200,203,205,208,210,213,
108,107,106,103,100,105,125,146,164,176,185,191,193,194,196,198,200,
122,122,122,121,118,112,116,135,152,165,173,181,183,184,186,187,194,
136,136,135,135,133,129,124,128,142,155,162,167,171,172,173,178,181,
150,150,149,148,147,143,137,135,138,146,153,156,159,159,159,163,166,
157,159,164,162,161,157,151,145,145,146,147,148,148,149,147,147,151,
161,162,166,172,170,167,161,154,149,149,149,146,142,140,138,135,136,
159,161,165,174,173,171,166,160,152,148,149,148,142,135,132,126,124,
156,157,160,167,172,170,166,161,155,150,147,146,144,136,128,124,114,
151,152,158,161,165,164,163,159,155,150,146,143,142,138,128,121,115,
157,158,160,159,159,157,155,152,148,144,142,138,135,132,131,121,115,
158,158,157,156,154,154,150,148,145,140,137,135,130,125,120,123,114,
157,157,156,155,156,153,149,147,142,139,136,135,129,124,118,111,116,
 52, 60, 76, 85, 98,117,139,157,173,184,190,195,199,203,205,208,211,
 51, 59, 71, 82, 96,114,136,154,170,182,189,195,198,202,205,208,215,
 52, 58, 69, 81, 92,110,131,150,166,180,187,193,197,200,203,210,213,
 61, 62, 68, 79, 89,103,124,145,160,173,183,189,193,197,203,207,211,
 73, 74, 74, 77, 85, 96,115,138,155,166,178,184,189,194,198,202,206,
 87, 87, 87, 86, 85, 91,107,127,146,158,168,177,183,187,192,190,194,
103,102,102,100, 97, 94, 98,117,134,148,158,167,172,176,179,183,187,
117,117,116,115,113,109,104,108,125,139,147,154,160,163,167,170,174,
132,131,131,130,128,124,119,116,119,130,139,143,148,149,152,156,159,
144,147,145,144,142,139,133,128,126,127,131,135,137,139,139,142,145,
150,151,155,155,154,150,145,138,133,133,133,131,129,130,129,129,131,
150,152,155,159,159,157,152,145,138,135,136,135,129,123,123,119,118,
148,149,152,156,159,158,154,149,143,137,135,135,133,125,117,115,108,
144,145,147,150,156,156,153,149,145,139,135,133,133,128,118,112,108,
145,146,147,151,150,148,146,143,139,135,132,129,127,125,122,112,107,
147,148,150,149,147,144,143,139,136,132,129,127,123,119,114,115,106,
151,150,150,148,146,146,142,138,135,132,126,124,122,117,112,104,109,
 42, 49, 59, 69, 82, 98,117,132,147,159,169,177,183,190,195,199,204,
 41, 48, 59, 68, 80, 95,114,130,144,158,168,176,182,189,194,198,203,
 42, 48, 58, 68, 78, 92,110,127,141,155,166,174,180,187,192,197,201,
 47, 50, 56, 66, 76, 87,104,123,137,149,161,170,178,184,189,194,203,
 57, 58, 60, 63, 73, 82, 96,115,132,144,155,166,173,179,187,193,198,
 69, 70, 71, 71, 72, 79, 90,107,125,138,149,159,167,175,181,187,192,
 84, 84, 83, 83, 81, 80, 85,100,117,131,140,150,158,166,169,174,179,
 99, 99, 98, 96, 93, 90, 87, 92,109,122,131,139,146,153,159,165,170,
113,113,112,111,108,105,100, 97,100,113,123,129,135,139,144,150,155,
127,127,126,125,123,119,114,110,107,108,115,121,125,128,131,135,140,
138,138,138,137,135,132,126,120,117,116,115,115,117,119,120,122,126,
138,140,142,144,143,140,135,129,123,120,121,120,115,111,112,111,113,
137,138,141,145,145,143,140,135,128,123,121,123,121,112,106,102,101,
134,135,138,141,145,144,141,137,132,127,123,121,122,117,106,102, 99,
138,139,141,141,140,138,136,133,129,125,121,120,118,116,111,101, 98,
140,140,139,138,138,136,133,130,127,122,119,118,115,111,106,106, 97,
140,140,139,140,138,135,134,130,127,122,118,116,115,110,105, 97,101,
 32, 39, 47, 58, 66, 80, 97,110,121,134,147,157,167,174,180,189,195,
 32, 39, 47, 56, 65, 78, 95,109,119,132,145,155,166,173,179,188,194,
 32, 38, 47, 55, 64, 76, 91,107,117,129,143,153,164,171,180,187,192,
 36, 39, 45, 54, 63, 73, 86,102,114,124,138,151,160,168,177,184,190,
 44, 46, 47, 52, 61, 70, 80, 96,110,120,131,145,155,165,173,179,186,
 54, 55, 56, 56, 59, 68, 76, 88,104,115,126,138,150,159,167,176,183,
 67, 67, 67, 67, 66, 66, 74, 83, 98,110,120,129,141,152,160,168,176,
 81, 81, 80, 78, 76, 74, 74, 80, 93,105,114,122,130,140,150,155,162,
 95, 95, 93, 92, 89, 85, 82, 80, 85, 97,107,114,121,128,135,142,150,
109,108,107,106,103, 99, 95, 91, 88, 90, 99,106,111,116,121,128,134,
121,120,119,118,116,113,107,102, 99, 97, 96,100,103,107,110,114,120,
128,127,127,126,125,122,117,112,107,104,105,103,100, 99,100,103,106,
125,126,129,130,130,128,124,119,113,108,107,109,107, 98, 95, 93, 95,
123,124,126,129,131,129,127,123,118,113,109,109,110,104, 94, 91, 90,
124,125,126,129,128,127,124,122,118,114,110,108,107,106, 98, 90, 87,
129,128,129,128,127,125,123,119,116,112,108,106,105,102, 97, 95, 86,
132,131,130,129,127,127,123,119,116,113,108,105,106,102, 96, 89, 91,
 23, 30, 36, 43, 52, 63, 78, 90, 98,109,124,138,147,159,167,174,185,
 24, 29, 36, 43, 51, 62, 76, 89, 97,107,122,136,146,158,166,173,184,
 24, 29, 36, 43, 50, 60, 73, 87, 95,103,119,134,144,156,164,171,183,
 27, 30, 35, 43, 50, 58, 70, 84, 93,100,114,129,140,153,161,172,180,
 34, 35, 36, 42, 49, 57, 66, 78, 90, 97,108,123,138,148,157,168,176,
 42, 43, 44, 44, 48, 55, 63, 72, 85, 94,102,116,130,141,153,162,170,
 52, 52, 52, 53, 52, 53, 61, 69, 79, 90, 98,107,122,135,145,154,166,
 64, 64, 63, 62, 61, 59, 60, 67, 75, 86, 94,103,113,125,137,147,156,
 77, 77, 76, 74, 71, 68, 66, 67, 72, 81, 90, 97,105,114,125,132,141,
 90, 90, 88, 87, 84, 80, 75, 73, 72, 75, 83, 90, 97,103,112,120,128,
102,101,100, 99, 97, 93, 88, 84, 81, 79, 79, 84, 89, 94,100,106,114,
110,110,109,108,107,104, 99, 94, 90, 88, 87, 86, 86, 87, 89, 94, 99,
114,115,114,114,113,111,107,102, 97, 93, 92, 93, 91, 84, 83, 83, 88,
111,112,114,117,115,114,111,108,103, 98, 95, 96, 96, 90, 81, 79, 77,
109,110,117,116,116,115,112,110,106,101, 98, 96, 96, 94, 85, 78, 75,
118,117,117,116,115,113,111,108,104,100, 97, 94, 94, 92, 87, 82, 75,
119,119,118,119,117,115,111,109,104,101, 98, 95, 93, 93, 87, 79, 80,
 16, 21, 27, 32, 39, 48, 60, 71, 77, 87,101,117,131,140,149,162,170,
 17, 21, 27, 32, 39, 47, 58, 70, 76, 85,100,115,129,139,152,161,169,
 17, 21, 27, 32, 38, 46, 56, 68, 75, 81, 96,112,127,137,151,159,167,
 20, 22, 26, 32, 38, 45, 54, 65, 73, 78, 92,108,123,134,147,156,165,
 25, 26, 27, 32, 38, 44, 52, 61, 71, 76, 84,102,118,129,143,152,165,
 31, 32, 33, 33, 37, 44, 50, 58, 67, 74, 79, 94,111,126,137,146,159,
 39, 39, 40, 40, 40, 42, 49, 56, 63, 71, 76, 85,102,117,129,142,152,
 48, 48, 48, 48, 47, 46, 47, 55, 60, 67, 74, 81, 93,108,122,133,143,
 60, 59, 59, 57, 55, 53, 52, 53, 59, 64, 71, 77, 84, 99,111,123,134,
 72, 71, 70, 68, 65, 62, 59, 58, 58, 62, 67, 72, 80, 88,100,111,119,
 83, 83, 82, 80, 78, 73, 69, 64, 63, 63, 64, 68, 73, 80, 88, 98,107,
 92, 92, 91, 90, 88, 85, 81, 76, 72, 71, 70, 69, 71, 73, 77, 85, 92,
 98, 99, 97, 97, 95, 93, 90, 85, 80, 77, 77, 77, 73, 70, 71, 74, 80,
100,100,102,100, 99, 98, 95, 92, 87, 83, 81, 81, 81, 74, 67, 66, 69,
 99,100,101,103,102,100, 98, 95, 91, 87, 84, 83, 83, 80, 71, 66, 64,
105,104,104,104,103,101, 98, 95, 92, 88, 85, 83, 82, 80, 75, 68, 64,
109,109,108,106,105,102,101, 97, 94, 89, 86, 84, 82, 83, 76, 68, 68,
 11, 14, 19, 23, 28, 34, 43, 52, 56, 59, 81, 95,111,121,136,145,159,
 11, 14, 19, 23, 28, 34, 42, 51, 56, 58, 79, 94,110,120,134,144,158,
 12, 14, 19, 23, 28, 33, 41, 50, 55, 57, 76, 91,107,122,133,142,156,
 14, 15, 18, 23, 28, 33, 40, 48, 54, 56, 71, 87,104,119,129,144,153,
 17, 18, 19, 23, 28, 33, 39, 46, 52, 55, 65, 81, 98,114,125,139,149,
 22, 23, 23, 24, 28, 33, 38, 44, 50, 54, 56, 73, 92,107,119,134,144,
 28, 28, 29, 29, 29, 32, 37, 42, 48, 53, 56, 64, 83,100,115,126,137,
 35, 35, 35, 35, 35, 34, 36, 42, 46, 50, 55, 58, 74, 91,106,117,131,
 43, 43, 43, 42, 40, 39, 38, 40, 46, 49, 52, 56, 63, 81, 96,110,121,
 53, 53, 52, 51, 49, 46, 44, 43, 45, 49, 50, 53, 60, 72, 87, 99,111,
 64, 63, 62, 61, 58, 55, 51, 48, 48, 49, 50, 52, 55, 63, 75, 88, 99,
 74, 73, 72, 71, 69, 66, 61, 57, 54, 53, 53, 52, 54, 58, 65, 75, 85,
 81, 81, 80, 79, 77, 75, 72, 67, 63, 60, 60, 59, 55, 55, 58, 64, 72,
 85, 86, 85, 84, 83, 81, 78, 75, 70, 66, 66, 66, 64, 57, 53, 54, 61,
 85, 85, 87, 87, 85, 84, 82, 79, 76, 72, 69, 69, 69, 64, 55, 52, 51,
 90, 92, 91, 90, 88, 87, 84, 82, 78, 74, 72, 70, 69, 67, 60, 53, 51,
 95, 95, 94, 93, 91, 91, 88, 84, 81, 77, 74, 72, 70, 69, 64, 55, 54,
  7,  9, 12, 15, 19, 23, 28, 33, 35, 42, 52, 76, 91,107,117,132,142,
  7,  9, 12, 15, 18, 23, 28, 33, 35, 40, 51, 75, 90,106,116,131,141,
  7,  9, 12, 15, 18, 22, 27, 32, 35, 37, 48, 72, 87,104,114,129,139,
  9, 10, 12, 15, 19, 22, 27, 31, 34, 33, 44, 68, 84,101,116,127,137,
 11, 11, 12, 15, 19, 22, 26, 31, 34, 34, 38, 63, 79, 96,111,122,138,
 14, 15, 15, 16, 19, 22, 26, 30, 34, 35, 35, 56, 72, 90,106,117,132,
 18, 19, 19, 19, 19, 22, 26, 29, 33, 35, 36, 47, 64, 82, 98,110,125,
 23, 23, 23, 23, 23, 23, 25, 29, 33, 35, 36, 38, 55, 74, 90,105,117,
 29, 29, 29, 28, 28, 27, 26, 29, 33, 35, 35, 36, 45, 64, 81, 96,107,
 36, 36, 35, 34, 33, 31, 30, 30, 32, 35, 36, 35, 38, 54, 71, 85, 99,
 44, 44, 43, 42, 40, 38, 35, 34, 34, 35, 37, 36, 36, 42, 61, 76, 88,
 54, 53, 52, 51, 49, 46, 43, 40, 38, 38, 38, 38, 37, 39, 49, 63, 76,
 62, 62, 61, 60, 58, 55, 52, 48, 44, 42, 43, 42, 38, 38, 42, 53, 64,
 69, 68, 67, 66, 64, 62, 60, 57, 53, 49, 49, 49, 46, 39, 39, 43, 53,
 71, 71, 71, 70, 69, 67, 65, 62, 59, 55, 53, 53, 53, 47, 39, 39, 42,
 77, 77, 76, 75, 73, 71, 70, 67, 63, 60, 57, 55, 55, 52, 46, 39, 38,
 81, 81, 80, 81, 80, 77, 74, 72, 68, 64, 61, 60, 58, 55, 50, 41, 39,
  3,  5,  7,  8, 10, 12, 15, 17, 16, 31, 39, 64, 78, 88,105,115,130,
  3,  5,  7,  8, 10, 12, 15, 17, 16, 30, 38, 62, 72, 87,104,114,129,
  4,  5,  7,  9, 10, 12, 15, 17, 17, 15, 36, 60, 70, 85,102,112,128,
  5,  5,  7,  9, 10, 12, 15, 17, 17, 15, 30, 56, 66, 82, 99,109,125,
  6,  6,  7,  9, 11, 13, 15, 17, 18, 16, 25, 37, 61, 77, 94,110,121,
  8,  8,  8,  9, 11, 13, 15, 17, 18, 17, 20, 31, 55, 71, 89,105,116,
 10, 11, 11, 11, 11, 13, 15, 17, 19, 19, 17, 25, 48, 64, 82, 98,109,
 13, 13, 14, 14, 13, 13, 15, 17, 19, 20, 19, 18, 40, 56, 74, 90,102,
 17, 17, 17, 17, 16, 16, 15, 18, 20, 21, 20, 19, 31, 47, 65, 81, 96,
 21, 21, 21, 21, 20, 19, 18, 18, 20, 22, 22, 20, 19, 37, 55, 72, 87,
 27, 27, 26, 26, 24, 23, 21, 21, 21, 22, 24, 22, 20, 26, 45, 61, 76,
 34, 33, 33, 32, 30, 29, 26, 25, 23, 23, 24, 24, 21, 20, 33, 51, 66,
 42, 41, 40, 39, 38, 36, 33, 30, 28, 27, 27, 27, 23, 22, 22, 39, 53,
 48, 48, 47, 46, 45, 43, 41, 38, 34, 32, 31, 31, 28, 23, 24, 30, 43,
 54, 53, 53, 52, 50, 49, 47, 44, 41, 38, 36, 36, 34, 29, 23, 25, 33,
 61, 62, 63, 61, 59, 56, 52, 50, 47, 43, 41, 39, 39, 36, 29, 24, 23,
 69, 68, 68, 66, 64, 62, 59, 58, 54, 50, 48, 45, 44, 40, 34, 27, 24,
  1,  1,  2,  2,  3,  3,  3,  2,  0,  0, 28, 37, 62, 77, 86,103,113,
  1,  1,  2,  3,  3,  3,  3,  2,  0,  0, 27, 36, 61, 76, 85,102,112,
  1,  1,  2,  3,  3,  3,  3,  2,  1,  0, 25, 34, 59, 74, 83,101,111,
  1,  2,  2,  3,  3,  3,  4,  3,  1,  0, 22, 31, 56, 71, 81, 98,108,
  2,  2,  2,  3,  4,  4,  4,  4,  2,  0,  0, 28, 51, 66, 76, 94,105,
  3,  3,  3,  3,  4,  4,  5,  5,  4,  1,  0, 20, 46, 55, 71, 89,105,
  4,  4,  4,  4,  4,  5,  6,  6,  6,  4,  1, 16, 26, 49, 65, 82, 98,
  5,  5,  5,  5,  5,  5,  6,  7,  7,  6,  4, 10, 20, 42, 57, 75, 91,
  7,  7,  7,  7,  7,  7,  6,  7,  8,  8,  6,  3, 14, 34, 49, 67, 83,
  9,  9,  9,  9,  9,  8,  8,  8,  9,  9,  8,  6,  3, 25, 40, 58, 73,
 12, 12, 12, 12, 11, 10, 10,  9,  9, 10, 10,  9,  6,  9, 30, 48, 63,
 17, 16, 16, 16, 15, 14, 13, 12, 11, 11, 11, 11,  8,  5, 20, 36, 52,
 22, 22, 21, 20, 19, 18, 17, 15, 14, 13, 13, 13, 11,  7, 10, 26, 42,
 28, 28, 27, 26, 25, 24, 22, 20, 18, 17, 16, 15, 14, 10,  9, 18, 31,
 33, 33, 32, 31, 30, 29, 28, 26, 23, 21, 20, 19, 17, 14, 10, 10, 24,
 40, 40, 39, 37, 35, 34, 33, 33, 29, 26, 24, 23, 22, 19, 14, 11, 14,
 61, 61, 62, 61, 59, 56, 52, 43, 39, 35, 32, 31, 28, 25, 19, 13, 11,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 26, 36, 61, 76, 85,103,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 25, 35, 60, 75, 85,102,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 24, 33, 58, 73, 83,101,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 22, 31, 55, 70, 80, 98,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 19, 28, 52, 67, 77, 94,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 15, 24, 47, 62, 72, 89,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 17, 41, 55, 66, 84,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 12, 22, 44, 59, 77,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6, 16, 36, 52, 69,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10, 28, 43, 60,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 20, 34, 51,
  2,  2,  2,  2,  2,  2,  1,  1,  0,  0,  0,  0,  0,  0,  6, 24, 40,
  6,  5,  5,  5,  5,  4,  3,  3,  2,  1,  1,  0,  0,  0,  0, 16, 29,
 10, 10,  9,  8,  8,  7,  7,  6,  4,  3,  3,  2,  1,  0,  0,  7, 21,
 15, 14, 14, 13, 12, 11, 11, 10,  8,  7,  6,  4,  3,  2,  0,  0, 14,
 19, 19, 18, 17, 16, 15, 15, 14, 12, 10,  9,  7,  6,  4,  2,  0,  6,
 40, 40, 39, 38, 36, 33, 31, 28, 30, 25, 21, 18, 15, 11,  7,  1,  0,
185,195,202,199,230,244,245,249,254,255,255,255,255,252,250,248,248,
155,161,173,179,205,207,227,230,234,238,241,255,252,249,247,246,246,
116,114,132,157,178,186,202,212,217,238,241,243,239,237,235,233,233,
 84, 95, 98,119,144,164,181,195,212,225,229,229,230,228,227,226,227,
 69, 78, 73, 88,107,130,151,169,186,200,212,211,212,212,212,216,218,
 54, 62, 59, 61, 78, 95,113,134,153,170,182,190,192,193,197,199,201,
 41, 41, 47, 43, 53, 68, 83, 98,118,135,150,160,165,169,174,178,182,
 29, 29, 36, 31, 34, 46, 59, 72, 85,102,117,127,135,141,147,154,162,
 21, 20, 25, 24, 22, 27, 37, 48, 60, 71, 86, 97,103,110,119,128,136,
 15, 14, 13, 15, 13, 15, 20, 28, 36, 45, 55, 67, 76, 80, 90,100,109,
  8,  8,  7,  8,  7,  7,  8, 12, 17, 23, 30, 37, 46, 54, 58, 73, 84,
  2,  2,  1,  1,  0,  0,  1,  2,  3,  6, 10, 14, 19, 26, 33, 48, 59,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  3,  8, 13, 35,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
188,198,209,225,235,242,246,250,255,255,255,255,254,251,249,248,248,
155,165,180,200,214,223,228,231,235,239,255,255,251,249,247,246,246,
115,123,135,158,179,195,208,213,236,239,242,243,239,236,234,233,233,
 93, 95,103,121,146,165,181,197,213,227,230,231,229,228,227,226,227,
 75, 75, 78, 90,109,132,152,169,186,200,212,213,212,212,211,216,218,
 59, 58, 62, 64, 79, 96,114,134,154,170,182,190,191,193,197,199,201,
 46, 44, 48, 45, 54, 69, 84, 99,118,136,150,160,165,169,174,178,185,
 34, 31, 37, 32, 36, 46, 60, 73, 86,103,117,127,135,142,148,154,162,
 22, 21, 21, 24, 23, 28, 38, 49, 60, 72, 86, 97,104,110,119,128,136,
 15, 15, 13, 16, 14, 16, 20, 29, 37, 46, 56, 68, 76, 81, 90,100,110,
  9,  8,  8,  9,  7,  7,  9, 12, 18, 24, 30, 38, 47, 54, 59, 74, 86,
  2,  2,  1,  1,  1,  0,  1,  2,  4,  6, 10, 14, 20, 27, 33, 48, 59,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  3,  9, 13, 35,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
184,206,219,202,235,240,247,252,255,255,255,255,254,251,249,248,247,
165,174,189,205,215,222,233,245,255,255,255,254,251,248,246,245,245,
129,129,139,160,181,196,209,224,238,241,243,242,238,236,234,241,241,
107,106,109,124,148,166,182,197,213,229,231,231,229,227,226,226,226,
 87, 84, 86, 95,112,136,153,170,187,200,212,212,212,211,215,216,217,
 69, 65, 65, 69, 82, 99,117,136,155,171,183,190,191,192,196,198,201,
 49, 48, 49, 50, 57, 71, 86,101,119,137,151,161,166,169,174,178,185,
 37, 35, 35, 36, 38, 48, 62, 74, 87,104,118,128,135,142,148,154,162,
 26, 23, 23, 25, 25, 29, 39, 51, 62, 73, 88, 98,104,111,120,128,137,
 18, 15, 14, 16, 15, 17, 21, 30, 38, 47, 57, 69, 77, 82, 91,100,110,
 10,  9,  8,  7,  8,  8, 10, 13, 19, 25, 31, 39, 48, 55, 62, 74, 86,
  3,  2,  2,  1,  1,  1,  1,  2,  4,  7, 11, 15, 21, 28, 34, 49, 62,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  4, 10, 13, 35,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
211,197,227,232,214,214,244,254,255,255,255,255,252,250,248,247,247,
180,187,199,210,214,222,232,244,255,255,255,253,250,247,246,245,245,
145,145,153,170,187,198,209,224,240,244,250,247,244,242,241,240,241,
121,120,118,130,152,169,183,198,214,228,232,230,228,226,225,225,226,
 98, 97, 96,101,117,139,155,171,187,201,213,212,211,214,214,215,217,
 75, 75, 75, 77, 86,103,121,138,156,172,183,190,191,194,196,198,200,
 59, 58, 56, 57, 62, 74, 89,104,121,139,152,161,166,170,174,178,185,
 44, 39, 40, 41, 43, 51, 64, 77, 90,106,120,129,136,142,149,154,162,
 29, 28, 27, 27, 29, 32, 42, 53, 64, 75, 89,100,106,112,120,128,137,
 20, 19, 17, 17, 18, 19, 23, 31, 40, 49, 59, 71, 79, 83, 92,103,112,
 11, 11,  9,  8,  9, 10, 11, 14, 20, 26, 33, 41, 50, 57, 63, 77, 87,
  4,  3,  2,  1,  1,  1,  2,  3,  5,  8, 12, 17, 22, 30, 36, 49, 62,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  6, 11, 16, 36,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
213,200,226,232,235,239,224,254,255,255,255,254,251,249,247,246,246,
191,197,208,216,221,224,224,244,255,255,254,251,248,246,244,244,244,
163,164,173,187,197,204,213,226,239,252,248,245,242,241,240,240,240,
138,136,135,145,162,175,187,200,215,228,231,228,226,225,224,225,225,
111,110,110,112,125,144,157,172,189,202,212,213,213,213,214,215,216,
 85, 85, 86, 87, 93,108,126,141,158,173,184,190,192,194,196,198,204,
 65, 64, 64, 66, 69, 78, 93,108,124,141,153,162,167,170,174,180,184,
 49, 49, 47, 48, 51, 56, 67, 80, 93,108,122,131,137,143,149,156,162,
 36, 35, 31, 32, 34, 37, 45, 56, 67, 78, 92,102,107,114,122,130,137,
 24, 21, 20, 20, 21, 23, 26, 34, 43, 52, 62, 74, 81, 85, 94,103,112,
 13, 12, 12, 10, 11, 12, 13, 16, 22, 29, 36, 44, 53, 60, 64, 78, 88,
  5,  4,  4,  2,  2,  2,  3,  4,  7, 10, 14, 19, 25, 32, 39, 52, 63,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  4,  8, 14, 21, 41,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
215,220,215,233,238,243,247,238,241,255,255,251,248,247,245,245,245,
200,204,212,219,226,231,237,240,254,255,252,248,246,244,243,243,243,
177,180,188,199,206,212,219,229,240,250,245,243,240,239,238,238,239,
154,153,155,164,176,186,194,205,218,228,233,231,230,230,230,231,233,
127,126,126,128,137,152,163,176,191,203,213,212,212,212,213,214,216,
 99, 98, 98,100,103,115,131,144,160,175,185,190,192,193,198,201,204,
 76, 75, 75, 77, 79, 85, 98,113,128,143,155,163,167,172,176,180,184,
 56, 56, 56, 57, 60, 63, 72, 84, 98,112,125,133,138,144,151,156,162,
 40, 39, 39, 39, 42, 44, 50, 60, 71, 82, 95,104,110,116,123,131,140,
 28, 27, 26, 24, 26, 28, 31, 38, 47, 56, 65, 77, 83, 88, 97,106,113,
 17, 16, 14, 13, 13, 15, 17, 19, 25, 32, 39, 47, 56, 63, 69, 81, 90,
  7,  5,  5,  4,  3,  4,  5,  6,  9, 12, 17, 22, 28, 36, 42, 53, 66,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  3,  6, 11, 17, 22, 42,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 11,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
222,224,229,235,241,247,251,255,252,253,253,249,245,243,241,243,244,
210,212,213,223,230,237,243,248,254,254,249,246,242,240,241,241,242,
191,193,199,205,212,220,227,234,242,248,243,240,237,237,236,237,238,
169,168,170,178,186,195,204,212,222,229,232,229,228,228,229,230,232,
144,143,143,145,152,162,173,184,196,205,213,214,214,216,217,219,222,
114,113,113,114,116,124,138,151,165,178,186,192,193,195,197,200,203,
 89, 88, 88, 88, 90, 93,103,118,132,147,157,165,169,172,176,180,188,
 67, 67, 67, 67, 70, 72, 78, 89,103,116,128,135,141,146,151,159,165,
 48, 47, 47, 48, 50, 53, 56, 65, 76, 87, 98,107,112,118,125,133,140,
 32, 31, 30, 30, 32, 35, 38, 42, 51, 60, 70, 80, 86, 90, 99,107,116,
 19, 19, 18, 17, 17, 19, 21, 24, 29, 36, 43, 51, 60, 66, 72, 83, 92,
  9,  8,  8,  5,  6,  6,  8,  9, 12, 15, 20, 26, 32, 40, 45, 57, 68,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  3,  6,  9, 14, 20, 28, 43,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  3, 17,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
229,231,221,231,243,249,254,255,255,255,251,246,243,241,239,239,239,
219,221,225,230,234,241,247,251,255,253,248,243,240,238,237,236,240,
203,204,208,213,218,226,234,239,244,248,242,237,235,233,232,235,237,
183,182,183,189,195,203,214,220,226,231,230,227,226,225,227,228,230,
158,158,157,159,165,173,185,195,203,209,215,213,213,214,216,218,221,
130,129,129,129,132,137,149,162,174,183,189,194,196,198,201,199,202,
102,102,101,100,102,105,112,126,139,152,161,167,171,174,178,183,187,
 79, 79, 79, 79, 80, 82, 85, 94,108,119,131,138,143,149,154,159,165,
 57, 57, 57, 58, 60, 63, 65, 71, 81, 92,102,110,116,121,128,134,141,
 39, 38, 38, 39, 40, 43, 46, 49, 56, 66, 74, 84, 90, 94,102,110,117,
 23, 23, 22, 22, 23, 25, 27, 30, 34, 41, 48, 56, 65, 70, 77, 86, 94,
 11, 11, 10,  9,  9, 10, 12, 14, 16, 19, 24, 30, 37, 45, 50, 61, 71,
  0,  0,  0,  0,  0,  0,  0,  0,  2,  4,  6,  9, 13, 19, 24, 33, 47,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  6, 18,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
236,237,239,241,245,251,255,255,255,255,250,243,239,238,237,237,237,
227,229,231,234,238,244,249,253,255,254,247,241,237,236,235,235,235,
213,214,217,220,225,231,238,243,247,250,240,235,232,231,230,231,232,
194,194,195,200,205,212,220,226,231,235,231,227,224,223,223,224,229,
171,171,170,172,178,185,195,205,210,214,217,213,212,212,215,217,220,
144,144,144,144,146,152,161,175,185,190,194,195,196,198,201,204,208,
116,116,116,116,117,119,125,137,150,161,166,171,174,178,179,183,187,
 91, 91, 91, 91, 91, 93, 96,103,114,125,136,143,147,152,157,162,168,
 68, 68, 69, 69, 71, 72, 75, 78, 86, 96,105,114,120,125,131,137,144,
 47, 47, 47, 48, 50, 52, 55, 58, 63, 71, 80, 88, 94, 98,105,113,120,
 28, 29, 29, 29, 30, 32, 35, 38, 40, 46, 54, 62, 69, 74, 81, 89, 97,
 14, 14, 14, 13, 14, 15, 17, 19, 21, 24, 29, 35, 42, 50, 54, 65, 74,
  2,  2,  1,  0,  0,  1,  2,  3,  5,  7, 10, 13, 18, 23, 29, 37, 50,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  7, 10, 23,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
240,241,242,237,247,252,255,255,255,255,249,243,238,235,233,235,236,
232,234,236,236,241,246,250,253,255,255,246,240,235,232,231,233,234,
220,221,224,226,230,235,240,244,248,253,242,235,231,228,229,229,230,
202,203,205,209,213,219,225,230,234,239,233,226,223,221,222,223,224,
181,181,182,184,190,198,204,211,216,219,221,215,212,212,212,214,216,
157,157,157,158,160,168,176,185,193,197,199,198,197,197,199,204,207,
130,130,130,131,132,135,142,150,162,170,173,176,176,179,183,187,192,
104,103,104,104,105,108,110,116,125,135,143,148,152,156,161,163,169,
 80, 80, 80, 81, 82, 83, 85, 89, 95,103,111,118,125,129,135,141,148,
 57, 58, 58, 59, 60, 62, 64, 67, 71, 77, 85, 92, 98,103,109,116,123,
 37, 37, 37, 37, 39, 41, 43, 46, 48, 53, 60, 68, 74, 79, 85, 92,100,
 18, 19, 19, 19, 20, 21, 23, 25, 28, 30, 35, 41, 48, 55, 58, 69, 77,
  5,  5,  4,  4,  4,  5,  6,  8, 10, 12, 14, 18, 23, 29, 34, 41, 54,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  3,  6, 11, 15, 28,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
243,244,245,246,249,253,255,255,255,255,249,241,236,234,232,231,234,
236,237,239,240,243,248,250,252,255,255,247,239,234,231,229,229,233,
226,226,228,230,234,239,242,244,247,255,243,235,230,227,226,225,229,
210,210,212,215,219,224,229,232,235,240,235,227,223,220,219,222,223,
190,190,191,193,199,205,211,215,218,222,224,216,212,211,210,213,215,
167,168,168,169,173,180,188,193,198,201,204,201,198,197,199,201,204,
143,143,143,144,145,149,157,163,170,177,179,181,179,180,183,186,193,
117,117,117,118,120,122,124,130,137,145,151,154,156,158,163,168,174,
 92, 92, 92, 93, 95, 97, 99,101,106,113,119,125,131,134,139,143,149,
 69, 69, 69, 70, 71, 73, 75, 77, 80, 85, 93, 98,103,108,113,120,127,
 46, 46, 46, 47, 49, 51, 53, 55, 58, 61, 67, 74, 79, 84, 89, 95,103,
 26, 26, 26, 26, 27, 29, 31, 33, 36, 38, 42, 48, 54, 59, 63, 73, 80,
  8,  8,  8,  9,  9, 10, 12, 13, 16, 18, 20, 23, 29, 34, 39, 47, 57,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  3,  5,  7, 11, 16, 20, 32,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
245,245,246,247,249,253,255,255,255,255,249,240,235,232,229,230,230,
240,240,241,242,245,248,251,251,253,254,247,238,233,230,229,228,228,
230,231,232,233,236,240,243,244,245,249,243,234,229,226,225,224,225,
216,216,217,219,223,228,232,233,234,239,235,227,222,219,219,219,219,
198,198,198,200,205,210,215,218,220,222,224,217,212,210,210,211,215,
178,178,178,178,182,188,194,198,201,204,207,202,199,198,198,199,204,
154,154,155,156,156,160,168,173,177,181,184,185,181,181,182,187,191,
129,130,130,131,132,133,136,143,147,153,158,161,160,161,164,168,173,
104,104,105,106,108,110,111,113,118,123,129,133,136,138,142,148,155,
 80, 80, 81, 82, 83, 85, 87, 89, 91, 96,102,106,110,113,118,125,129,
 56, 57, 57, 58, 59, 61, 63, 65, 68, 71, 75, 81, 85, 89, 93,100,107,
 34, 34, 34, 35, 36, 38, 40, 42, 44, 47, 50, 55, 60, 65, 68, 76, 83,
 14, 14, 15, 15, 16, 17, 18, 20, 22, 25, 27, 30, 35, 40, 45, 52, 61,
  0,  0,  0,  0,  0,  0,  1,  3,  4,  6,  8, 10, 13, 17, 22, 24, 37,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  5, 13,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
247,247,247,248,249,253,255,254,254,255,243,239,233,230,228,227,229,
243,242,243,244,246,249,251,251,250,254,241,237,231,228,227,225,228,
235,234,235,236,238,241,244,244,244,247,237,233,227,225,223,222,225,
222,222,222,224,226,230,233,234,234,236,230,226,221,219,217,219,219,
206,206,205,207,210,214,218,220,221,221,220,216,211,210,209,211,212,
187,187,186,186,189,193,198,201,203,205,207,203,199,198,197,200,202,
165,165,165,165,165,169,174,179,181,184,187,187,183,182,184,186,189,
142,142,142,142,143,143,146,151,155,159,163,167,164,163,165,168,175,
117,117,117,118,119,120,121,122,127,132,137,141,142,141,144,149,155,
 92, 92, 93, 94, 95, 97, 98, 99,101,106,111,115,117,118,122,127,135,
 68, 68, 68, 69, 71, 73, 74, 76, 78, 81, 85, 90, 93, 95, 98,105,112,
 43, 44, 44, 45, 46, 47, 49, 51, 54, 57, 59, 63, 68, 71, 74, 81, 87,
 21, 21, 22, 22, 23, 25, 26, 28, 30, 33, 35, 38, 42, 46, 50, 57, 65,
  3,  3,  3,  4,  4,  5,  7,  8, 10, 12, 14, 16, 18, 23, 27, 31, 42,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  3,  7, 11, 17,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
249,248,248,249,250,253,253,253,252,247,244,233,231,228,226,227,226,
245,244,244,245,246,249,250,249,249,245,242,230,228,226,224,225,225,
238,237,237,238,239,242,243,243,243,241,238,227,225,222,221,222,222,
227,226,226,227,229,231,233,234,233,235,231,220,219,216,217,217,217,
212,212,211,212,214,216,219,221,221,221,222,212,210,208,209,209,212,
195,194,194,193,195,198,201,204,205,206,208,200,198,196,197,198,203,
175,174,174,173,173,176,179,182,185,187,189,186,184,182,183,185,190,
152,152,152,151,151,152,154,158,161,164,168,170,167,165,166,170,173,
128,128,128,128,129,129,129,131,135,139,143,147,147,145,146,150,155,
103,104,104,105,106,107,107,107,110,114,118,122,126,124,125,129,136,
 79, 80, 80, 81, 82, 84, 85, 86, 87, 90, 94, 98,101,102,103,108,114,
 55, 55, 55, 56, 57, 58, 60, 62, 64, 67, 69, 73, 77, 80, 81, 85, 92,
 30, 30, 30, 31, 32, 33, 35, 37, 39, 42, 44, 47, 51, 55, 58, 63, 69,
  9,  9, 10, 10, 11, 12, 13, 15, 17, 19, 21, 23, 26, 31, 34, 37, 46,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  3,  4,  6,  9, 13, 16, 23,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
250,249,249,249,250,251,252,251,251,237,232,225,224,224,224,224,226,
246,246,245,245,246,248,249,247,248,235,230,223,222,223,222,222,225,
240,239,239,239,240,242,243,242,242,242,227,219,219,219,219,219,222,
230,230,229,229,230,232,234,233,233,233,223,214,214,214,213,214,217,
217,216,216,216,217,219,221,221,221,222,216,212,206,206,206,209,210,
201,200,200,199,200,202,204,205,206,207,206,202,195,195,195,198,200,
182,181,181,180,180,182,184,186,188,189,192,189,183,182,182,185,188,
160,160,160,159,159,159,161,163,166,168,172,174,167,166,166,169,172,
137,137,137,137,137,137,137,139,142,145,149,153,150,148,148,151,157,
114,114,114,114,114,115,115,116,118,121,124,128,133,129,128,131,137,
 90, 90, 91, 91, 92, 93, 93, 94, 95, 98,101,104,108,108,107,110,116,
 66, 66, 66, 67, 68, 69, 71, 72, 74, 76, 78, 81, 84, 89, 88, 90, 95,
 40, 40, 41, 41, 42, 43, 45, 47, 49, 52, 54, 56, 60, 64, 67, 69, 74,
 17, 17, 17, 18, 19, 20, 21, 23, 25, 27, 29, 32, 35, 39, 43, 45, 52,
  0,  0,  0,  0,  0,  0,  2,  3,  5,  7,  9, 11, 13, 16, 20, 22, 28,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  4,  7,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
250,250,250,249,249,250,250,249,249,250,225,222,218,220,220,222,223,
247,246,246,246,246,247,247,246,246,248,224,221,216,218,219,220,221,
241,241,240,240,241,242,242,241,240,244,221,218,213,215,216,217,218,
232,232,231,231,232,233,234,233,232,234,216,213,208,210,210,212,214,
220,220,219,219,220,221,222,222,221,222,226,206,201,202,203,205,207,
205,205,204,204,205,206,207,207,207,208,211,199,192,192,193,196,200,
187,187,187,187,187,187,188,190,190,191,195,187,184,180,181,184,188,
167,167,166,166,166,166,167,169,170,172,175,173,170,166,167,169,174,
145,145,145,145,144,144,145,146,148,150,153,158,154,150,150,152,157,
122,122,122,122,122,122,123,124,125,127,129,133,137,132,132,133,138,
 99,100,100,100,100,101,101,102,103,105,107,109,113,115,112,113,118,
 76, 76, 77, 77, 78, 79, 79, 81, 82, 84, 86, 87, 90, 95, 93, 94, 97,
 51, 52, 52, 52, 53, 54, 56, 57, 59, 62, 64, 65, 67, 72, 74, 75, 78,
 25, 26, 26, 27, 28, 29, 30, 32, 34, 37, 40, 42, 44, 47, 52, 53, 58,
  5,  5,  5,  5,  6,  7,  8, 10, 12, 14, 16, 18, 21, 24, 28, 29, 35,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  4,  7, 10, 13,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
247,238,242,241,244,242,242,239,237,236,233,217,215,214,217,218,221,
244,236,239,238,241,240,240,237,235,234,231,216,213,212,215,217,220,
239,231,234,234,236,235,236,234,231,230,228,213,211,209,212,214,217,
230,232,227,226,231,228,229,228,225,225,223,209,206,205,207,209,213,
219,221,222,220,220,223,222,219,217,216,216,203,200,198,201,202,206,
205,207,208,208,208,209,209,209,207,206,206,194,192,190,192,193,197,
191,189,191,191,192,193,193,193,194,193,193,194,183,179,181,182,186,
170,171,172,172,173,173,173,174,175,176,177,179,170,168,166,169,173,
150,151,151,151,152,152,152,153,154,155,157,161,155,153,151,153,157,
130,130,130,130,130,130,131,131,133,134,135,138,143,135,134,136,139,
108,108,108,108,108,108,109,110,111,113,114,115,119,118,116,117,120,
 85, 85, 86, 86, 86, 87, 88, 89, 90, 92, 93, 94, 96,100, 98, 98,101,
 62, 62, 62, 62, 63, 64, 65, 67, 68, 71, 73, 74, 74, 78, 80, 80, 82,
 36, 36, 37, 37, 38, 39, 40, 42, 44, 47, 50, 52, 53, 54, 59, 60, 63,
 12, 13, 13, 13, 14, 15, 16, 18, 20, 23, 25, 28, 30, 32, 35, 37, 41,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  4,  6,  8, 11, 13, 17, 19,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
189,164,122, 98, 48, 22, 14,  8,  4,  2,  1,  0,  0,  0,  0,  0,  0,
181,168,135,106, 66, 53, 25, 18, 12,  8,  5,  0,  0,  0,  0,  0,  0,
174,180,145,111, 76, 61, 39, 26, 18,  4,  2,  0,  0,  0,  0,  0,  0,
229,187,169,132, 99, 72, 49, 32, 15,  4,  1,  0,  0,  0,  0,  0,  0,
253,209,202,165,127, 94, 69, 46, 27, 11,  0,  0,  0,  0,  0,  0,  0,
255,228,221,197,160,122, 90, 66, 43, 23,  6,  0,  0,  0,  0,  0,  0,
255,255,233,221,186,150,116, 87, 63, 39, 19,  2,  0,  0,  0,  0,  0,
255,255,245,241,209,174,141,110, 83, 59, 35, 14,  0,  0,  0,  0,  0,
255,255,254,247,230,199,167,135,105, 78, 53, 28,  8,  0,  0,  0,  0,
255,255,255,255,248,220,191,160,128,100, 73, 45, 21,  2,  0,  0,  0,
255,255,255,255,255,235,208,180,150,120, 93, 66, 37, 14,  0,  0,  0,
255,255,255,255,255,244,220,195,167,138,111, 85, 57, 29,  7,  0,  0,
255,255,255,255,255,246,228,206,180,154,126,100, 74, 47, 20,  0,  0,
255,255,255,255,253,239,222,204,186,163,139,113, 89, 65, 38, 12,  0,
255,255,255,255,246,233,219,203,187,170,148,124,101, 79, 60, 37, 14,
255,255,255,251,242,231,217,204,190,172,157,135,112, 91, 71, 57, 36,
255,255,255,250,240,232,219,207,192,178,166,145,123,102, 83, 65, 54,
185,159,111, 70, 44, 24, 13,  8,  4,  2,  1,  0,  0,  0,  0,  0,  0,
186,164,126, 83, 54, 34, 24, 17, 12,  8,  0,  0,  0,  0,  0,  0,  0,
201,173,139,106, 75, 51, 32, 24,  7,  4,  2,  0,  0,  0,  0,  0,  0,
227,203,165,129, 97, 71, 49, 30, 14,  4,  1,  0,  0,  0,  0,  0,  0,
252,231,201,163,125, 93, 68, 46, 26, 11,  0,  0,  0,  0,  0,  0,  0,
255,254,220,196,159,121, 90, 66, 43, 23,  6,  0,  0,  0,  0,  0,  0,
255,255,236,220,185,149,115, 86, 63, 39, 19,  2,  0,  0,  0,  0,  0,
255,255,246,244,208,173,140,109, 82, 58, 34, 14,  0,  0,  0,  0,  0,
255,255,255,248,229,198,166,134,104, 78, 52, 28,  8,  0,  0,  0,  0,
255,255,255,255,247,219,190,159,127, 99, 72, 45, 21,  2,  0,  0,  0,
255,255,255,255,255,234,208,179,149,120, 93, 65, 37, 14,  0,  0,  0,
255,255,255,255,255,244,220,195,167,138,110, 84, 56, 28,  7,  0,  0,
255,255,255,255,255,250,228,206,180,154,126,100, 74, 46, 20,  0,  0,
255,255,255,255,253,239,222,204,186,163,138,113, 88, 64, 37, 12,  0,
255,255,255,255,246,233,219,203,187,170,147,124,101, 79, 60, 36, 13,
255,255,255,251,242,231,217,204,190,172,156,135,111, 91, 71, 56, 35,
255,255,255,249,240,231,218,207,191,177,165,144,122,102, 83, 64, 53,
168,154,111, 98, 50, 29, 12,  7,  3,  2,  1,  0,  0,  0,  0,  0,  0,
180,158,123, 85, 58, 37, 20,  8,  2,  1,  0,  0,  0,  0,  0,  0,  0,
198,169,131,103, 74, 51, 32, 16,  6,  3,  1,  0,  0,  0,  0,  0,  0,
223,200,160,123, 94, 69, 48, 29, 14,  2,  0,  0,  0,  0,  0,  0,  0,
233,229,197,159,122, 91, 67, 46, 26, 10,  0,  0,  0,  0,  0,  0,  0,
245,252,227,194,157,119, 89, 65, 43, 22,  6,  0,  0,  0,  0,  0,  0,
255,255,249,219,183,148,113, 85, 62, 39, 18,  2,  0,  0,  0,  0,  0,
255,255,255,240,206,171,139,108, 81, 58, 34, 13,  0,  0,  0,  0,  0,
255,255,255,251,228,196,164,132,103, 77, 52, 28,  7,  0,  0,  0,  0,
255,255,255,255,246,218,188,157,126, 98, 71, 44, 21,  1,  0,  0,  0,
255,255,255,255,255,233,207,178,148,119, 92, 64, 36, 14,  0,  0,  0,
255,255,255,255,255,243,219,194,166,137,109, 83, 56, 28,  7,  0,  0,
255,255,255,255,255,250,228,204,180,153,125, 99, 73, 46, 19,  0,  0,
255,255,255,255,252,239,222,204,184,162,138,112, 88, 63, 36, 11,  0,
255,255,255,255,246,233,218,203,186,169,147,123,100, 78, 59, 35, 13,
255,255,255,251,241,230,217,203,187,171,156,134,111, 90, 70, 56, 34,
255,255,255,249,239,231,218,206,191,177,165,145,121,101, 82, 64, 52,
178,145,120, 89, 76, 60, 18,  7,  4,  2,  0,  0,  0,  0,  0,  0,  0,
180,159,127, 94, 69, 43, 23, 10,  2,  1,  0,  0,  0,  0,  0,  0,  0,
195,166,130,104, 76, 53, 33, 17,  5,  2,  0,  0,  0,  0,  0,  0,  0,
218,198,155,118, 92, 68, 47, 28, 13,  2,  0,  0,  0,  0,  0,  0,  0,
239,227,196,155,117, 89, 66, 45, 25,  9,  0,  0,  0,  0,  0,  0,  0,
255,245,225,191,154,116, 87, 64, 42, 22,  6,  0,  0,  0,  0,  0,  0,
255,252,246,216,180,145,111, 84, 61, 38, 18,  1,  0,  0,  0,  0,  0,
255,255,255,236,203,168,136,106, 80, 57, 33, 13,  0,  0,  0,  0,  0,
255,255,255,253,225,194,161,130,101, 75, 51, 27,  7,  0,  0,  0,  0,
255,255,255,255,244,216,186,155,124, 96, 70, 43, 20,  1,  0,  0,  0,
255,255,255,255,255,232,205,176,146,117, 90, 63, 35, 13,  0,  0,  0,
255,255,255,255,255,242,218,193,165,135,108, 82, 54, 27,  6,  0,  0,
255,255,255,255,255,249,228,203,179,152,124, 98, 72, 45, 19,  0,  0,
255,255,255,255,255,238,221,204,184,162,137,112, 87, 62, 35,  9,  0,
255,255,255,255,245,232,218,202,185,168,146,122, 99, 77, 58, 34, 12,
255,255,255,250,240,229,216,202,186,170,155,133,111, 89, 69, 54, 33,
255,255,255,248,239,230,217,202,190,176,157,143,122,100, 81, 63, 51,
184,149,132,102, 73, 46, 43, 11,  4,  2,  0,  0,  0,  0,  0,  0,  0,
186,166,136,105, 77, 52, 36, 13,  4,  0,  0,  0,  0,  0,  0,  0,  0,
196,170,140,113, 84, 59, 36, 19,  7,  0,  0,  0,  0,  0,  0,  0,  0,
220,196,156,120, 95, 70, 48, 28, 13,  2,  0,  0,  0,  0,  0,  0,  0,
241,224,194,152,114, 87, 64, 43, 24,  9,  0,  0,  0,  0,  0,  0,  0,
255,247,224,191,151,113, 86, 63, 41, 21,  5,  0,  0,  0,  0,  0,  0,
255,255,243,214,178,142,109, 83, 60, 37, 17,  1,  0,  0,  0,  0,  0,
255,255,255,233,200,165,133,103, 78, 56, 32, 12,  0,  0,  0,  0,  0,
255,255,255,249,222,190,157,127, 99, 73, 50, 26,  6,  0,  0,  0,  0,
255,255,255,255,241,213,183,151,121, 94, 68, 42, 19,  0,  0,  0,  0,
255,255,255,255,254,230,203,174,143,115, 89, 61, 34, 12,  0,  0,  0,
255,255,255,255,255,240,216,191,162,133,106, 81, 53, 26,  6,  0,  0,
255,255,255,255,255,246,225,202,177,150,122, 96, 71, 43, 18,  0,  0,
255,255,255,255,254,237,222,203,183,161,136,111, 85, 60, 33, 10,  0,
255,255,255,254,244,231,216,201,184,165,144,121, 98, 76, 56, 32, 10,
255,255,255,248,239,227,214,200,185,169,153,131,109, 88, 68, 52, 31,
255,255,253,246,237,226,215,201,188,174,156,142,121, 99, 80, 61, 50,
190,172,137,114, 85, 55, 31, 27, 16,  1,  0,  0,  0,  0,  0,  0,  0,
193,174,147,116, 88, 60, 35, 21,  5,  0,  0,  0,  0,  0,  0,  0,  0,
200,178,150,123, 94, 67, 42, 23,  8,  0,  0,  0,  0,  0,  0,  0,  0,
219,195,161,130,103, 77, 52, 31, 14,  2,  0,  0,  0,  0,  0,  0,  0,
239,220,192,152,115, 89, 65, 43, 24,  9,  0,  0,  0,  0,  0,  0,  0,
255,244,221,188,147,109, 83, 61, 39, 19,  4,  0,  0,  0,  0,  0,  0,
255,255,241,212,177,139,105, 81, 59, 36, 16,  0,  0,  0,  0,  0,  0,
255,255,254,230,198,162,130,101, 76, 54, 31, 11,  0,  0,  0,  0,  0,
255,255,255,245,218,186,153,123, 96, 71, 48, 25,  5,  0,  0,  0,  0,
255,255,255,255,237,210,179,147,118, 91, 65, 40, 18,  0,  0,  0,  0,
255,255,255,255,251,227,200,170,140,112, 86, 58, 32, 11,  0,  0,  0,
255,255,255,255,255,238,214,188,159,131,104, 78, 50, 24,  5,  0,  0,
255,255,255,255,255,244,223,200,175,147,120, 94, 69, 41, 17,  0,  0,
255,255,255,255,252,240,221,202,182,160,135,109, 84, 58, 32,  9,  0,
255,255,255,255,242,230,215,199,182,163,143,119, 96, 74, 53, 29,  8,
255,255,254,247,237,225,213,198,183,167,151,129,107, 86, 66, 50, 29,
255,255,250,245,235,224,214,199,186,169,154,140,119, 98, 78, 59, 48,
193,177,152,124, 96, 66, 39, 19, 11,  3,  0,  0,  0,  0,  0,  0,  0,
197,180,153,127, 99, 70, 43, 22,  6,  0,  0,  0,  0,  0,  0,  0,  0,
203,184,159,132,103, 76, 49, 27, 10,  0,  0,  0,  0,  0,  0,  0,  0,
218,196,167,140,112, 85, 58, 35, 16,  2,  0,  0,  0,  0,  0,  0,  0,
235,217,191,156,122, 95, 70, 46, 25,  9,  0,  0,  0,  0,  0,  0,  0,
255,240,217,185,145,108, 83, 60, 38, 18,  4,  0,  0,  0,  0,  0,  0,
255,255,238,209,174,135,101, 78, 56, 33, 14,  0,  0,  0,  0,  0,  0,
255,255,252,227,195,160,127, 97, 74, 52, 29,  9,  0,  0,  0,  0,  0,
255,255,255,241,214,183,150,120, 92, 69, 46, 23,  4,  0,  0,  0,  0,
255,255,255,255,232,205,175,143,114, 88, 62, 38, 16,  0,  0,  0,  0,
255,255,255,255,247,223,196,166,136,108, 82, 55, 30, 10,  0,  0,  0,
255,255,255,255,255,234,211,184,155,127,101, 75, 47, 23,  4,  0,  0,
255,255,255,255,255,241,220,197,172,144,117, 92, 66, 39, 15,  0,  0,
255,255,255,255,255,238,223,203,182,159,132,107, 82, 56, 30,  7,  0,
255,255,255,253,243,228,214,197,180,160,141,118, 94, 72, 50, 26,  4,
255,255,252,245,235,223,210,196,180,163,145,127,105, 84, 63, 47, 27,
255,252,248,241,233,222,209,197,181,167,151,137,116, 95, 76, 57, 45,
196,181,153,131,105, 77, 49, 24,  4,  0,  0,  0,  0,  0,  0,  0,  0,
199,183,161,137,108, 80, 52, 27,  7,  0,  0,  0,  0,  0,  0,  0,  0,
204,187,165,140,112, 85, 58, 32, 12,  0,  0,  0,  0,  0,  0,  0,  0,
216,197,172,147,120, 92, 66, 40, 18,  2,  0,  0,  0,  0,  0,  0,  0,
233,215,189,158,129,101, 76, 50, 27,  9,  0,  0,  0,  0,  0,  0,  0,
251,235,213,182,146,112, 87, 63, 39, 19,  3,  0,  0,  0,  0,  0,  0,
255,254,234,205,171,133,100, 77, 54, 31, 12,  0,  0,  0,  0,  0,  0,
255,255,248,224,192,157,123, 93, 71, 49, 26,  7,  0,  0,  0,  0,  0,
255,255,255,237,211,180,147,115, 88, 66, 43, 21,  3,  0,  0,  0,  0,
255,255,255,251,228,201,171,139,109, 83, 59, 36, 15,  0,  0,  0,  0,
255,255,255,255,242,218,192,162,132,104, 78, 51, 28,  8,  0,  0,  0,
255,255,255,255,252,230,207,180,151,123, 98, 72, 44, 21,  2,  0,  0,
255,255,255,255,255,238,217,194,168,140,114, 89, 63, 36, 13,  0,  0,
255,255,255,255,255,242,221,201,180,155,129,104, 79, 54, 28,  6,  0,
255,255,255,251,241,229,212,195,178,158,137,115, 92, 69, 46, 22,  1,
255,255,249,242,233,221,207,193,177,160,142,124,103, 81, 61, 44, 23,
252,250,245,239,230,219,207,193,179,164,146,129,113, 92, 73, 54, 42,
201,186,166,142,115, 86, 58, 30,  6,  0,  0,  0,  0,  0,  0,  0,  0,
202,187,167,144,117, 89, 61, 33, 10,  0,  0,  0,  0,  0,  0,  0,  0,
207,191,171,148,121, 93, 66, 38, 14,  0,  0,  0,  0,  0,  0,  0,  0,
216,198,176,153,127,100, 73, 46, 21,  1,  0,  0,  0,  0,  0,  0,  0,
230,213,188,161,136,108, 82, 56, 30,  9,  0,  0,  0,  0,  0,  0,  0,
246,231,210,180,147,118, 91, 68, 41, 18,  1,  0,  0,  0,  0,  0,  0,
255,249,230,203,170,133,102, 79, 55, 31, 11,  0,  0,  0,  0,  0,  0,
255,255,244,220,189,155,120, 91, 69, 46, 24,  6,  0,  0,  0,  0,  0,
255,255,254,234,207,176,144,111, 84, 62, 40, 18,  1,  0,  0,  0,  0,
255,255,255,245,223,197,167,135,105, 79, 56, 33, 13,  0,  0,  0,  0,
255,255,255,255,237,213,187,158,127,100, 74, 48, 26,  7,  0,  0,  0,
255,255,255,255,247,226,202,176,147,119, 94, 68, 41, 19,  1,  0,  0,
255,255,255,255,253,234,213,189,163,136,110, 86, 60, 33, 12,  0,  0,
255,255,255,255,255,239,220,199,176,151,125,101, 77, 51, 25,  4,  0,
255,255,255,253,243,226,212,194,175,155,134,113, 89, 66, 42, 18,  0,
255,253,249,242,230,218,205,190,173,156,137,121,100, 78, 58, 40, 19,
249,247,243,235,226,215,204,189,175,158,142,125,110, 89, 70, 51, 38,
207,193,173,147,124, 95, 66, 36, 10,  0,  0,  0,  0,  0,  0,  0,  0,
208,193,175,152,126, 98, 68, 39, 13,  0,  0,  0,  0,  0,  0,  0,  0,
211,196,177,155,130,102, 73, 44, 17,  0,  0,  0,  0,  0,  0,  0,  0,
217,201,181,160,135,108, 80, 51, 24,  1,  0,  0,  0,  0,  0,  0,  0,
229,213,190,165,141,116, 88, 61, 33,  9,  0,  0,  0,  0,  0,  0,  0,
243,229,208,180,150,124, 98, 72, 44, 18,  0,  0,  0,  0,  0,  0,  0,
255,244,226,201,169,135,107, 82, 58, 31,  9,  0,  0,  0,  0,  0,  0,
255,255,240,218,190,156,121, 92, 70, 46, 22,  3,  0,  0,  0,  0,  0,
255,255,249,230,205,175,141,109, 82, 60, 37, 16,  0,  0,  0,  0,  0,
255,255,255,241,219,193,163,131,101, 75, 53, 30, 10,  0,  0,  0,  0,
255,255,255,251,232,209,183,154,123, 95, 69, 45, 23,  5,  0,  0,  0,
255,255,255,255,242,221,198,172,143,115, 90, 64, 37, 16,  0,  0,  0,
255,255,255,255,249,230,208,185,159,132,106, 82, 56, 30, 10,  0,  0,
255,255,255,255,253,236,216,195,172,147,121, 97, 73, 48, 22,  3,  0,
255,255,255,255,239,227,209,194,174,153,132,109, 86, 63, 37, 14,  0,
255,254,245,238,229,217,202,187,170,152,134,115, 97, 75, 54, 36, 15,
246,243,239,232,223,212,199,185,170,154,137,120,106, 87, 66, 48, 34,
215,201,182,160,134,104, 73, 41, 12,  0,  0,  0,  0,  0,  0,  0,  0,
215,201,183,161,135,106, 76, 44, 15,  0,  0,  0,  0,  0,  0,  0,  0,
217,203,185,164,138,110, 80, 49, 20,  0,  0,  0,  0,  0,  0,  0,  0,
221,206,188,167,143,115, 87, 57, 27,  2,  0,  0,  0,  0,  0,  0,  0,
229,215,195,172,148,122, 95, 66, 36,  9,  0,  0,  0,  0,  0,  0,  0,
241,228,209,182,155,129,104, 77, 48, 19,  0,  0,  0,  0,  0,  0,  0,
251,241,224,200,170,138,112, 86, 61, 32,  8,  0,  0,  0,  0,  0,  0,
255,250,236,216,190,157,122, 96, 72, 47, 21,  1,  0,  0,  0,  0,  0,
255,255,245,227,204,176,142,109, 83, 60, 36, 14,  0,  0,  0,  0,  0,
255,255,254,237,216,191,161,128, 99, 73, 51, 27,  8,  0,  0,  0,  0,
255,255,255,246,227,205,179,150,120, 91, 65, 42, 20,  2,  0,  0,  0,
255,255,255,255,237,217,194,168,140,112, 86, 59, 35, 14,  0,  0,  0,
255,255,255,255,244,225,204,180,155,128,103, 78, 52, 27,  8,  0,  0,
255,255,255,255,249,231,212,191,167,142,117, 94, 70, 44, 20,  1,  0,
255,255,255,252,242,231,210,195,174,152,130,107, 84, 60, 35, 12,  0,
252,250,245,238,229,213,200,183,168,149,130,111, 93, 72, 50, 31, 10,
244,241,237,228,219,208,196,181,166,149,132,115, 99, 83, 63, 44, 30,
223,209,191,170,143,112, 80, 46, 15,  0,  0,  0,  0,  0,  0,  0,  0,
223,209,192,170,144,114, 82, 49, 17,  0,  0,  0,  0,  0,  0,  0,  0,
223,210,193,172,147,118, 87, 54, 22,  0,  0,  0,  0,  0,  0,  0,  0,
226,213,196,175,151,122, 93, 62, 29,  2,  0,  0,  0,  0,  0,  0,  0,
232,219,201,180,155,128,101, 71, 39, 10,  0,  0,  0,  0,  0,  0,  0,
240,229,211,187,161,135,108, 82, 51, 21,  0,  0,  0,  0,  0,  0,  0,
249,239,223,201,173,143,116, 91, 64, 34,  8,  0,  0,  0,  0,  0,  0,
255,247,234,214,190,158,125,100, 75, 48, 21,  0,  0,  0,  0,  0,  0,
255,254,242,225,203,176,142,110, 85, 61, 36, 12,  0,  0,  0,  0,  0,
255,255,250,234,214,190,160,127, 98, 74, 51, 26,  5,  0,  0,  0,  0,
255,255,255,242,224,202,176,146,117, 89, 64, 40, 18,  0,  0,  0,  0,
255,255,255,250,233,213,190,164,136,109, 82, 55, 32, 12,  0,  0,  0,
255,255,255,255,240,221,200,177,151,125,100, 75, 48, 24,  6,  0,  0,
255,255,255,255,244,227,207,186,163,138,114, 90, 66, 40, 17,  0,  0,
255,255,255,255,248,230,212,193,172,149,126,103, 81, 57, 32, 10,  0,
254,251,247,233,224,212,199,181,166,146,126,107, 88, 68, 46, 25,  5,
239,237,232,226,217,206,191,177,161,144,127,110, 93, 79, 58, 39, 25,
229,216,200,178,151,119, 86, 51, 16,  0,  0,  0,  0,  0,  0,  0,  0,
229,216,200,179,153,121, 89, 54, 19,  0,  0,  0,  0,  0,  0,  0,  0,
229,217,201,180,154,124, 93, 59, 24,  0,  0,  0,  0,  0,  0,  0,  0,
231,219,203,183,158,129, 98, 66, 32,  2,  0,  0,  0,  0,  0,  0,  0,
234,223,207,186,162,134,105, 76, 42, 11,  0,  0,  0,  0,  0,  0,  0,
240,230,214,192,167,140,112, 85, 54, 22,  0,  0,  0,  0,  0,  0,  0,
247,238,223,202,176,147,120, 94, 67, 36,  8,  0,  0,  0,  0,  0,  0,
254,246,232,213,189,159,128,102, 78, 50, 21,  0,  0,  0,  0,  0,  0,
255,251,239,223,201,175,141,111, 87, 63, 36, 10,  0,  0,  0,  0,  0,
255,255,246,230,211,188,158,126, 98, 75, 51, 25,  2,  0,  0,  0,  0,
255,255,253,238,220,198,173,144,114, 88, 64, 39, 15,  0,  0,  0,  0,
255,255,255,245,228,209,186,160,132,105, 78, 52, 29,  8,  0,  0,  0,
255,255,255,251,235,217,196,173,148,121, 96, 71, 43, 21,  3,  0,  0,
255,255,255,254,239,222,203,182,158,134,110, 86, 62, 37, 15,  0,  0,
255,255,255,255,242,226,208,188,167,145,122, 99, 77, 53, 28,  7,  0,
255,245,240,233,224,213,200,180,164,144,123,104, 85, 65, 41, 19,  0,
238,235,231,224,215,201,188,174,157,140,122,105, 88, 72, 54, 34, 20,
235,222,206,185,158,125, 91, 56, 18,  0,  0,  0,  0,  0,  0,  0,  0,
234,222,206,185,159,127, 93, 59, 21,  0,  0,  0,  0,  0,  0,  0,  0,
234,223,207,186,160,130, 97, 64, 26,  0,  0,  0,  0,  0,  0,  0,  0,
235,224,208,188,163,133,102, 70, 34,  1,  0,  0,  0,  0,  0,  0,  0,
237,226,211,191,167,138,109, 79, 45, 11,  0,  0,  0,  0,  0,  0,  0,
240,231,216,195,171,144,115, 88, 57, 23,  0,  0,  0,  0,  0,  0,  0,
246,237,223,203,178,150,123, 96, 69, 37,  7,  0,  0,  0,  0,  0,  0,
251,243,230,212,189,160,130,104, 80, 52, 21,  0,  0,  0,  0,  0,  0,
255,249,237,221,199,173,141,112, 89, 65, 37,  9,  0,  0,  0,  0,  0,
255,252,242,227,208,185,155,124, 97, 76, 52, 24,  0,  0,  0,  0,  0,
255,255,247,233,216,195,169,140,111, 86, 64, 39, 13,  0,  0,  0,  0,
255,255,253,240,223,204,182,156,128,101, 76, 51, 27,  5,  0,  0,  0,
255,255,255,245,229,212,192,169,144,117, 92, 66, 40, 18,  0,  0,  0,
255,255,255,249,234,217,198,178,155,130,106, 83, 59, 32, 12,  0,  0,
255,255,255,250,236,220,203,183,163,140,117, 95, 73, 49, 25,  5,  0,
250,247,242,235,225,213,193,179,163,141,124,104, 84, 62, 39, 16,  0,
237,235,230,218,209,198,185,169,153,137,118,101, 83, 66, 48, 29, 14,
238,226,210,188,162,129, 94, 60, 21,  8,  0,  0,  0,  0,  0,  0,  0,
237,226,210,189,163,131, 96, 62, 24,  9,  0,  0,  0,  0,  0,  0,  0,
237,226,210,190,164,134,100, 66, 29,  0,  0,  0,  0,  0,  0,  0,  0,
237,226,211,191,167,137,105, 73, 37,  3,  0,  0,  0,  0,  0,  0,  0,
238,228,213,194,170,142,111, 81, 47, 12,  0,  0,  0,  0,  0,  0,  0,
239,230,216,197,173,147,118, 89, 58, 24,  0,  0,  0,  0,  0,  0,  0,
243,234,221,202,179,152,125, 98, 70, 38,  7,  0,  0,  0,  0,  0,  0,
248,240,228,210,187,160,132,106, 80, 53, 21,  0,  0,  0,  0,  0,  0,
252,246,234,218,197,171,141,113, 89, 65, 37,  8,  0,  0,  0,  0,  0,
255,249,239,224,206,182,153,123, 97, 75, 51, 24,  0,  0,  0,  0,  0,
255,251,242,229,212,191,166,137,108, 85, 63, 38, 12,  0,  0,  0,  0,
255,254,245,233,217,199,177,152,124, 97, 74, 50, 26,  3,  0,  0,  0,
255,255,250,238,223,206,187,165,139,113, 88, 63, 38, 15,  0,  0,  0,
255,255,253,241,227,211,193,174,151,126,102, 79, 54, 29,  8,  0,  0,
255,255,254,243,229,214,197,179,159,136,113, 91, 69, 45, 21,  3,  0,
255,255,255,250,237,221,203,178,162,146,122,102, 81, 59, 35, 13,  0,
231,228,223,216,207,196,183,165,150,133,114, 97, 79, 62, 43, 24,  9,
238,227,212,190,164,133, 98, 62, 24,  0,  1,  0,  0,  0,  0,  0,  0,
238,227,212,191,165,134,100, 64, 27,  0,  2,  0,  0,  0,  0,  0,  0,
238,227,212,191,166,137,103, 68, 32,  0,  2,  0,  0,  0,  0,  0,  0,
237,227,212,193,168,140,108, 75, 39,  5,  4,  0,  0,  0,  0,  0,  0,
237,228,214,195,171,144,114, 82, 48, 14,  0,  0,  0,  0,  0,  0,  0,
237,229,216,197,175,149,121, 91, 59, 25,  0,  0,  0,  0,  0,  0,  0,
239,232,219,201,179,154,127,100, 70, 38,  7,  0,  0,  0,  0,  0,  0,
243,236,224,207,186,160,134,108, 81, 52, 21,  1,  0,  0,  0,  0,  0,
248,241,231,215,194,169,142,115, 90, 65, 36,  7,  0,  0,  0,  0,  0,
252,246,236,222,203,180,152,123, 98, 75, 50, 22,  0,  0,  0,  0,  0,
253,248,239,226,209,189,164,135,107, 84, 62, 37, 11,  0,  0,  0,  0,
253,248,240,228,213,195,173,148,121, 95, 72, 49, 24,  1,  0,  0,  0,
254,249,241,231,217,201,182,160,135,109, 84, 60, 37, 14,  0,  0,  0,
255,252,244,233,220,205,189,170,147,123, 98, 74, 49, 26,  5,  0,  0,
255,252,245,235,222,208,192,175,156,133,110, 88, 65, 40, 17,  0,  0,
255,255,250,240,224,210,194,181,160,140,119, 98, 77, 55, 31, 10,  0,
255,255,255,253,240,224,208,163,147,130,113, 94, 77, 58, 39, 19,  3,
234,217,206,186,163,133,102, 70, 37,  7,  0,  0,  0,  0,  0,  0,  0,
234,217,206,187,164,135,104, 72, 38,  8,  0,  0,  0,  0,  0,  0,  0,
233,217,207,187,165,136,106, 74, 41, 11,  0,  0,  0,  0,  0,  0,  0,
232,225,207,188,168,139,110, 79, 46, 15,  0,  0,  0,  0,  0,  0,  0,
231,225,213,193,170,145,115, 85, 53, 21,  0,  0,  0,  0,  0,  0,  0,
232,226,214,196,174,149,121, 92, 61, 29,  2,  3,  0,  0,  0,  0,  0,
235,226,216,199,179,155,128,101, 71, 39, 10,  0,  0,  0,  0,  0,  0,
235,230,220,204,184,160,135,109, 82, 52, 20,  0,  0,  0,  0,  0,  0,
241,237,226,211,191,168,143,117, 91, 65, 35,  5,  0,  0,  0,  0,  0,
248,242,232,218,200,177,152,125, 99, 75, 50, 21,  0,  0,  0,  0,  0,
250,245,236,223,207,186,162,134,108, 85, 62, 36,  9,  0,  0,  0,  0,
250,245,237,226,211,193,171,146,119, 94, 72, 48, 23,  0,  0,  0,  0,
248,244,237,226,213,197,178,157,132,107, 83, 59, 35, 12,  0,  0,  0,
249,244,237,227,215,201,185,166,144,120, 96, 71, 46, 24,  3,  0,  0,
249,245,238,229,217,204,189,173,153,130,108, 85, 61, 35, 14,  0,  0,
249,245,238,229,217,204,191,176,158,138,116, 96, 75, 52, 27,  7,  0,
255,255,252,243,230,216,200,184,169,149,128,107, 87, 66, 43, 18,  0,
250,248,233,210,184,149,116, 85, 56, 33, 16,  3,  0,  0,  0,  0,  0,
232,232,221,201,177,154,120, 96, 74, 52, 33,  0,  0,  0,  0,  0,  0,
200,206,201,188,161,143,114, 91, 73, 32, 15,  0,  0,  0,  0,  0,  0,
190,183,183,174,153,130,106, 81, 51, 22,  6,  0,  0,  0,  0,  0,  0,
170,163,168,160,147,126,104, 83, 58, 29,  0,  0,  0,  0,  0,  0,  0,
142,139,146,144,133,119,101, 83, 64, 41, 14,  0,  0,  0,  0,  0,  0,
115,116,116,119,115,104, 92, 80, 64, 47, 26,  3,  0,  0,  0,  0,  0,
 91, 91, 89, 93, 93, 87, 78, 70, 62, 48, 32, 14,  0,  0,  0,  0,  0,
 67, 68, 68, 70, 70, 70, 64, 57, 52, 45, 34, 20,  6,  0,  0,  0,  0,
 44, 45, 45, 48, 47, 49, 47, 43, 39, 34, 30, 21, 11,  1,  0,  0,  0,
 23, 23, 23, 25, 24, 24, 26, 25, 23, 22, 19, 16, 11,  5,  0,  0,  0,
  6,  5,  4,  4,  1,  0,  2,  4,  6,  7,  8,  8,  7,  5,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
246,241,226,204,179,145,110, 80, 52, 30, 14,  1,  0,  0,  0,  0,  0,
230,229,217,195,168,141,116, 93, 70, 49,  5,  0,  0,  0,  0,  0,  0,
204,207,202,184,160,133,106, 88, 48, 29, 12,  0,  0,  0,  0,  0,  0,
187,186,183,176,154,129,105, 78, 49, 19,  3,  0,  0,  0,  0,  0,  0,
169,169,169,161,149,127,104, 83, 58, 29,  0,  0,  0,  0,  0,  0,  0,
143,145,145,144,134,120,102, 83, 64, 41, 14,  0,  0,  0,  0,  0,  0,
113,115,116,119,116,104, 93, 80, 65, 47, 25,  3,  0,  0,  0,  0,  0,
 88, 91, 89, 93, 93, 88, 79, 71, 62, 49, 32, 14,  0,  0,  0,  0,  0,
 67, 68, 69, 70, 70, 70, 64, 58, 52, 46, 34, 20,  6,  0,  0,  0,  0,
 44, 45, 45, 48, 48, 49, 48, 43, 39, 35, 30, 21, 11,  1,  0,  0,  0,
 24, 23, 23, 26, 24, 25, 26, 26, 24, 22, 20, 17, 12,  5,  0,  0,  0,
  6,  5,  4,  3,  2,  1,  2,  5,  7,  8,  8,  8,  7,  5,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
229,228,213,196,169,138, 99, 71, 44, 26, 10,  0,  0,  0,  0,  0,  0,
222,221,208,187,162,136,106, 68, 31, 15,  1,  0,  0,  0,  0,  0,  0,
200,202,200,182,157,131,103, 74, 42, 24,  8,  0,  0,  0,  0,  0,  0,
183,182,184,178,155,129,105, 77, 48, 13,  0,  0,  0,  0,  0,  0,  0,
160,166,165,162,153,128,104, 82, 57, 28,  0,  0,  0,  0,  0,  0,  0,
134,143,144,143,136,124,103, 83, 63, 40, 13,  0,  0,  0,  0,  0,  0,
114,114,116,119,116,106, 95, 81, 65, 47, 25,  2,  0,  0,  0,  0,  0,
 89, 91, 91, 93, 93, 89, 80, 72, 63, 49, 32, 14,  0,  0,  0,  0,  0,
 67, 68, 69, 70, 71, 71, 65, 59, 53, 46, 34, 20,  6,  0,  0,  0,  0,
 45, 45, 45, 48, 48, 50, 49, 44, 40, 35, 31, 21, 11,  1,  0,  0,  0,
 25, 24, 23, 23, 24, 26, 27, 27, 25, 23, 20, 17, 12,  5,  0,  0,  0,
  7,  6,  5,  3,  2,  2,  4,  6,  7,  8,  9,  9,  7,  5,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
213,201,191,174,162,142, 94, 59, 36, 19,  5,  0,  0,  0,  0,  0,  0,
206,204,193,173,154,128, 99, 64, 27,  9,  0,  0,  0,  0,  0,  0,  0,
193,195,192,175,152,127,100, 71, 36, 16,  0,  0,  0,  0,  0,  0,  0,
177,178,182,176,155,129,103, 76, 47, 13,  0,  0,  0,  0,  0,  0,  0,
159,161,161,163,156,130,105, 82, 57, 27,  0,  0,  0,  0,  0,  0,  0,
138,140,140,140,138,129,105, 83, 63, 39, 13,  0,  0,  0,  0,  0,  0,
107,111,115,116,116,108, 98, 83, 65, 46, 25,  2,  0,  0,  0,  0,  0,
 84, 91, 90, 91, 93, 90, 82, 74, 64, 49, 32, 13,  0,  0,  0,  0,  0,
 67, 68, 69, 70, 71, 71, 66, 60, 54, 48, 34, 20,  5,  0,  0,  0,  0,
 46, 47, 46, 48, 49, 50, 50, 45, 41, 37, 32, 22, 11,  1,  0,  0,  0,
 26, 26, 24, 24, 26, 27, 29, 28, 26, 24, 21, 18, 12,  5,  0,  0,  0,
  8,  8,  6,  4,  2,  4,  5,  8,  9, 10, 10,  9,  8,  5,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
190,180,172,155,136,113,108, 53, 25, 12,  0,  0,  0,  0,  0,  0,  0,
189,185,175,157,137,118, 99, 58, 23,  1,  0,  0,  0,  0,  0,  0,  0,
182,182,178,164,141,118, 94, 66, 32,  0,  0,  0,  0,  0,  0,  0,  0,
170,171,174,168,149,124,100, 73, 44, 11,  0,  0,  0,  0,  0,  0,  0,
157,156,157,160,154,131,105, 82, 55, 26,  0,  0,  0,  0,  0,  0,  0,
134,135,135,136,139,132,107, 84, 62, 38, 12,  0,  0,  0,  0,  0,  0,
109,110,112,113,114,111,103, 85, 65, 45, 24,  1,  0,  0,  0,  0,  0,
 86, 87, 90, 90, 91, 91, 84, 77, 66, 50, 31, 13,  0,  0,  0,  0,  0,
 66, 67, 69, 70, 71, 71, 68, 62, 56, 49, 35, 19,  5,  0,  0,  0,  0,
 47, 48, 48, 49, 50, 51, 51, 47, 42, 38, 33, 22, 11,  0,  0,  0,  0,
 27, 27, 27, 26, 27, 29, 30, 30, 28, 25, 22, 19, 12,  5,  0,  0,  0,
  9,  9,  8,  5,  5,  6,  8, 10, 11, 11, 11, 10,  8,  6,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  2,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
173,167,154,140,121,100, 76, 70, 50,  5,  0,  0,  0,  0,  0,  0,  0,
172,168,157,142,123,104, 80, 59, 19,  0,  0,  0,  0,  0,  0,  0,  0,
170,167,161,148,127,107, 86, 59, 28,  0,  0,  0,  0,  0,  0,  0,  0,
159,160,160,154,137,114, 93, 68, 40,  8,  0,  0,  0,  0,  0,  0,  0,
147,148,149,151,144,125,102, 79, 53, 24,  0,  0,  0,  0,  0,  0,  0,
127,129,130,132,135,129,108, 84, 62, 37, 10,  0,  0,  0,  0,  0,  0,
106,107,108,109,111,111,106, 87, 66, 45, 23,  0,  0,  0,  0,  0,  0,
 88, 89, 88, 88, 89, 90, 86, 81, 67, 49, 30, 12,  0,  0,  0,  0,  0,
 67, 68, 70, 69, 70, 71, 70, 64, 59, 50, 34, 19,  4,  0,  0,  0,  0,
 48, 48, 49, 50, 51, 52, 52, 49, 44, 40, 34, 22, 10,  0,  0,  0,  0,
 29, 29, 28, 28, 30, 31, 32, 32, 30, 27, 24, 20, 12,  5,  0,  0,  0,
 11, 10,  9,  8,  8,  9, 10, 12, 14, 13, 13, 12,  9,  6,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  3,  3,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
155,150,139,125,108, 90, 68, 41, 29, 10,  0,  0,  0,  0,  0,  0,  0,
156,150,141,127,110, 92, 71, 46, 17,  0,  0,  0,  0,  0,  0,  0,  0,
154,151,143,130,115, 96, 77, 52, 23,  0,  0,  0,  0,  0,  0,  0,  0,
147,147,145,136,122,102, 83, 61, 34,  5,  0,  0,  0,  0,  0,  0,  0,
136,136,137,137,128,112, 92, 72, 47, 20,  0,  0,  0,  0,  0,  0,  0,
118,120,123,124,125,118,101, 81, 59, 34,  8,  0,  0,  0,  0,  0,  0,
100,101,103,105,106,107,103, 86, 65, 44, 21,  0,  0,  0,  0,  0,  0,
 84, 84, 85, 86, 87, 88, 86, 83, 67, 49, 29, 11,  0,  0,  0,  0,  0,
 67, 67, 68, 69, 70, 70, 70, 66, 61, 50, 34, 18,  4,  0,  0,  0,  0,
 48, 49, 50, 51, 52, 52, 52, 51, 47, 42, 35, 21, 10,  0,  0,  0,  0,
 29, 30, 30, 31, 32, 32, 33, 34, 32, 29, 26, 21, 12,  4,  0,  0,  0,
 13, 13, 12, 10, 11, 12, 13, 15, 16, 16, 15, 13, 10,  6,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  3,  4,  4,  4,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
137,132,121,111, 96, 81, 61, 36,  9,  0,  0,  0,  0,  0,  0,  0,  0,
138,133,124,113, 98, 83, 64, 40, 13,  0,  0,  0,  0,  0,  0,  0,  0,
137,134,126,114,101, 86, 68, 46, 20,  0,  0,  0,  0,  0,  0,  0,  0,
132,132,129,118,106, 92, 74, 53, 29,  3,  0,  0,  0,  0,  0,  0,  0,
123,123,124,121,111, 98, 81, 62, 39, 15,  0,  0,  0,  0,  0,  0,  0,
110,111,112,113,111,104, 90, 72, 51, 28,  5,  0,  0,  0,  0,  0,  0,
 94, 94, 97,100,100, 99, 95, 81, 62, 40, 18,  0,  0,  0,  0,  0,  0,
 80, 80, 81, 83, 85, 84, 85, 82, 66, 47, 28,  9,  0,  0,  0,  0,  0,
 65, 66, 67, 68, 69, 69, 68, 67, 63, 49, 32, 17,  2,  0,  0,  0,  0,
 49, 50, 50, 51, 52, 52, 52, 52, 49, 44, 34, 21,  9,  0,  0,  0,  0,
 30, 31, 32, 32, 33, 34, 34, 35, 35, 31, 28, 22, 12,  4,  0,  0,  0,
 14, 14, 14, 13, 14, 15, 16, 17, 19, 19, 17, 15, 12,  6,  1,  0,  0,
  1,  0,  0,  0,  0,  0,  0,  0,  2,  4,  5,  6,  6,  5,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
119,114,107, 97, 85, 71, 55, 33,  9,  0,  0,  0,  0,  0,  0,  0,  0,
120,115,108, 98, 86, 73, 58, 36, 12,  0,  0,  0,  0,  0,  0,  0,  0,
120,116,109,100, 88, 76, 61, 41, 17,  0,  0,  0,  0,  0,  0,  0,  0,
117,116,112,102, 91, 80, 66, 47, 24,  2,  0,  0,  0,  0,  0,  0,  0,
109,110,110,107, 95, 85, 72, 54, 33, 11,  0,  0,  0,  0,  0,  0,  0,
 99,100,101,102, 98, 89, 79, 63, 43, 21,  1,  0,  0,  0,  0,  0,  0,
 87, 88, 89, 91, 91, 89, 83, 71, 54, 33, 13,  0,  0,  0,  0,  0,  0,
 75, 76, 77, 79, 81, 80, 79, 76, 62, 44, 25,  7,  0,  0,  0,  0,  0,
 63, 63, 64, 65, 67, 67, 66, 67, 63, 48, 31, 16,  1,  0,  0,  0,  0,
 48, 49, 50, 51, 52, 52, 52, 51, 51, 45, 33, 20,  8,  0,  0,  0,  0,
 31, 32, 33, 34, 35, 35, 36, 35, 36, 34, 29, 22, 12,  3,  0,  0,  0,
 16, 16, 16, 16, 17, 18, 19, 20, 20, 21, 19, 16, 12,  6,  0,  0,  0,
  3,  2,  2,  0,  0,  1,  2,  4,  6,  7,  8,  8,  7,  5,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
103, 98, 93, 85, 74, 62, 49, 29,  9,  0,  0,  0,  0,  0,  0,  0,  0,
103, 99, 93, 85, 74, 63, 50, 32, 11,  0,  0,  0,  0,  0,  0,  0,  0,
103,100, 94, 86, 76, 65, 53, 36, 15,  0,  0,  0,  0,  0,  0,  0,  0,
101,100, 96, 88, 79, 68, 57, 41, 20,  1,  0,  0,  0,  0,  0,  0,  0,
 95, 96, 96, 92, 82, 72, 62, 47, 27,  8,  0,  0,  0,  0,  0,  0,  0,
 88, 89, 89, 90, 85, 75, 67, 55, 36, 16,  0,  0,  0,  0,  0,  0,  0,
 79, 80, 81, 81, 81, 78, 70, 62, 45, 26,  8,  0,  0,  0,  0,  0,  0,
 70, 70, 71, 73, 73, 72, 70, 66, 54, 37, 19,  3,  0,  0,  0,  0,  0,
 59, 60, 61, 62, 64, 64, 62, 62, 59, 44, 28, 13,  0,  0,  0,  0,  0,
 47, 48, 48, 49, 50, 51, 51, 50, 51, 46, 32, 19,  7,  0,  0,  0,  0,
 33, 33, 33, 34, 35, 36, 36, 36, 36, 35, 31, 21, 11,  3,  0,  0,  0,
 18, 18, 18, 18, 19, 20, 21, 21, 22, 23, 21, 18, 13,  6,  0,  0,  0,
  5,  5,  4,  4,  4,  5,  6,  7,  9, 10, 11, 10,  8,  6,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  2,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 87, 84, 79, 72, 62, 52, 41, 25,  8,  0,  0,  0,  0,  0,  0,  0,  0,
 87, 84, 79, 73, 63, 53, 42, 27,  9,  0,  0,  0,  0,  0,  0,  0,  0,
 87, 85, 80, 73, 65, 54, 44, 30, 12,  0,  0,  0,  0,  0,  0,  0,  0,
 86, 85, 82, 75, 67, 57, 48, 34, 17,  1,  0,  0,  0,  0,  0,  0,  0,
 81, 82, 82, 77, 69, 60, 51, 40, 23,  6,  0,  0,  0,  0,  0,  0,  0,
 76, 76, 77, 77, 72, 63, 55, 46, 30, 13,  0,  0,  0,  0,  0,  0,  0,
 70, 70, 71, 71, 70, 66, 58, 51, 38, 21,  5,  0,  0,  0,  0,  0,  0,
 63, 63, 64, 64, 64, 62, 60, 54, 45, 30, 14,  1,  0,  0,  0,  0,  0,
 54, 55, 56, 57, 57, 56, 54, 54, 49, 38, 23, 10,  0,  0,  0,  0,  0,
 45, 45, 46, 47, 48, 49, 48, 47, 47, 43, 29, 16,  5,  0,  0,  0,  0,
 32, 33, 33, 34, 35, 36, 36, 35, 35, 36, 32, 20, 10,  1,  0,  0,  0,
 19, 19, 19, 20, 21, 22, 22, 22, 22, 23, 23, 19, 12,  5,  0,  0,  0,
  7,  7,  7,  7,  8,  8,  9, 10, 11, 12, 13, 12, 10,  6,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  3,  3,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 73, 70, 66, 60, 51, 42, 33, 20,  7,  0,  0,  0,  0,  0,  0,  0,  0,
 73, 70, 66, 60, 52, 43, 34, 22,  8,  0,  0,  0,  0,  0,  0,  0,  0,
 72, 70, 66, 61, 53, 44, 35, 24, 10,  0,  0,  0,  0,  0,  0,  0,  0,
 71, 71, 68, 62, 55, 46, 38, 28, 13,  1,  0,  0,  0,  0,  0,  0,  0,
 68, 68, 68, 64, 56, 48, 40, 32, 18,  5,  0,  0,  0,  0,  0,  0,  0,
 64, 64, 65, 64, 59, 51, 44, 36, 24, 10,  0,  0,  0,  0,  0,  0,  0,
 59, 59, 60, 60, 59, 54, 46, 40, 31, 16,  4,  0,  0,  0,  0,  0,  0,
 54, 54, 55, 55, 54, 52, 49, 42, 36, 24, 10,  0,  0,  0,  0,  0,  0,
 48, 48, 48, 49, 49, 47, 45, 44, 39, 31, 17,  6,  0,  0,  0,  0,  0,
 40, 41, 41, 42, 43, 42, 41, 39, 39, 35, 24, 12,  3,  0,  0,  0,  0,
 31, 31, 32, 33, 34, 34, 34, 33, 33, 34, 30, 18,  8,  0,  0,  0,  0,
 20, 20, 20, 21, 22, 22, 23, 23, 23, 23, 24, 21, 12,  5,  0,  0,  0,
  9,  9,  9,  9, 10, 11, 11, 12, 12, 13, 14, 14, 11,  6,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,  5,  5,  5,  4,  3,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 58, 55, 52, 47, 40, 32, 25, 15,  5,  0,  0,  0,  0,  0,  0,  0,  0,
 58, 55, 52, 47, 41, 33, 25, 17,  6,  0,  0,  0,  0,  0,  0,  0,  0,
 57, 56, 53, 48, 41, 34, 26, 18,  7,  0,  0,  0,  0,  0,  0,  0,  0,
 56, 56, 54, 49, 43, 35, 28, 21, 10,  1,  0,  0,  0,  0,  0,  0,  0,
 54, 55, 54, 51, 44, 37, 30, 24, 14,  3,  0,  0,  0,  0,  0,  0,  0,
 51, 51, 52, 51, 47, 39, 33, 27, 18,  7,  0,  0,  0,  0,  0,  0,  0,
 48, 48, 48, 48, 47, 42, 35, 30, 23, 12,  3,  0,  0,  0,  0,  0,  0,
 43, 44, 44, 44, 43, 42, 37, 32, 26, 18,  8,  0,  0,  0,  0,  0,  0,
 39, 39, 40, 40, 39, 38, 36, 34, 29, 23, 13,  4,  0,  0,  0,  0,  0,
 34, 34, 35, 35, 35, 34, 32, 31, 30, 26, 19,  9,  1,  0,  0,  0,  0,
 28, 28, 28, 29, 29, 29, 28, 27, 27, 27, 22, 14,  5,  0,  0,  0,  0,
 19, 19, 20, 20, 21, 21, 22, 21, 22, 22, 22, 18, 10,  3,  0,  0,  0,
 10, 10, 10, 11, 11, 12, 12, 12, 13, 13, 14, 14, 12,  6,  1,  0,  0,
  2,  2,  2,  2,  2,  3,  3,  4,  5,  5,  6,  7,  7,  5,  3,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 41, 40, 37, 34, 28, 22, 16, 10,  3,  0,  0,  0,  0,  0,  0,  0,  0,
 42, 40, 38, 34, 29, 23, 17, 11,  4,  0,  0,  0,  0,  0,  0,  0,  0,
 42, 41, 38, 35, 29, 23, 18, 12,  5,  0,  0,  0,  0,  0,  0,  0,  0,
 41, 41, 39, 35, 30, 25, 19, 14,  6,  0,  0,  0,  0,  0,  0,  0,  0,
 40, 40, 40, 37, 32, 26, 21, 16,  9,  2,  0,  0,  0,  0,  0,  0,  0,
 38, 38, 38, 38, 34, 28, 23, 18, 12,  5,  0,  0,  0,  0,  0,  0,  0,
 35, 36, 36, 36, 35, 30, 25, 20, 15,  8,  2,  0,  0,  0,  0,  0,  0,
 32, 33, 33, 33, 32, 31, 27, 22, 18, 12,  5,  0,  0,  0,  0,  0,  0,
 29, 29, 30, 30, 29, 28, 27, 24, 20, 15,  9,  2,  0,  0,  0,  0,  0,
 26, 26, 26, 27, 26, 25, 24, 23, 22, 18, 13,  6,  0,  0,  0,  0,  0,
 22, 23, 23, 23, 23, 22, 21, 20, 20, 19, 15, 10,  3,  0,  0,  0,  0,
 17, 17, 17, 18, 18, 18, 18, 17, 17, 17, 17, 13,  6,  1,  0,  0,  0,
 10, 10, 10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 10,  4,  0,  0,  0,
  4,  4,  4,  4,  4,  4,  5,  5,  6,  6,  7,  7,  7,  6,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  2,  2,  2,  1,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 24, 24, 22, 20, 16, 12,  9,  5,  1,  1,  0,  0,  0,  0,  0,  0,  0,
 25, 24, 23, 20, 17, 13,  9,  6,  2,  1,  0,  0,  0,  0,  0,  0,  0,
 25, 24, 23, 21, 17, 13, 10,  6,  2,  0,  0,  0,  0,  0,  0,  0,  0,
 25, 25, 24, 21, 18, 14, 11,  7,  3,  0,  0,  0,  0,  0,  0,  0,  0,
 24, 25, 24, 23, 19, 15, 12,  9,  5,  1,  0,  0,  0,  0,  0,  0,  0,
 23, 24, 24, 24, 21, 17, 13, 10,  6,  2,  0,  0,  0,  0,  0,  0,  0,
 22, 23, 23, 23, 22, 19, 15, 12,  9,  4,  1,  0,  0,  0,  0,  0,  0,
 21, 21, 21, 21, 21, 20, 17, 14, 11,  7,  2,  0,  0,  0,  0,  0,  0,
 19, 19, 19, 19, 19, 18, 18, 15, 12,  9,  5,  1,  0,  0,  0,  0,  0,
 17, 17, 17, 17, 17, 17, 16, 15, 14, 11,  7,  3,  0,  0,  0,  0,  0,
 15, 15, 16, 16, 15, 15, 14, 14, 14, 13, 10,  6,  2,  0,  0,  0,  0,
 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 11,  8,  4,  0,  0,  0,  0,
  9,  9,  9,  9,  9, 10, 10, 10,  9,  9,  9,  9,  6,  2,  0,  0,  0,
  4,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  7,  6,  4,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  1,  1,  2,  2,  3,  3,  3,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  7,  7,  6,  6,  5,  3,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  7,  7,  7,  6,  5,  3,  2,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  7,  8,  7,  7,  5,  4,  2,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  8,  8,  8,  7,  6,  4,  3,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  8,  9,  9,  8,  7,  5,  3,  2,  1,  0,  0,  0,  0,  0,  0,  0,  0,
  8,  9,  9,  9,  8,  6,  4,  3,  1,  0,  0,  0,  0,  0,  0,  0,  0,
  9,  9,  9,  9,  9,  7,  6,  4,  3,  1,  0,  0,  0,  0,  0,  0,  0,
  9,  9,  9,  9,  9,  9,  7,  5,  4,  2,  0,  0,  0,  0,  0,  0,  0,
  8,  8,  9,  9,  9,  8,  8,  7,  5,  3,  1,  0,  0,  0,  0,  0,  0,
  8,  8,  8,  8,  8,  8,  8,  7,  6,  5,  3,  1,  0,  0,  0,  0,  0,
  8,  8,  8,  8,  8,  7,  7,  7,  7,  6,  4,  2,  1,  0,  0,  0,  0,
  7,  7,  7,  7,  7,  7,  7,  6,  6,  6,  5,  3,  2,  0,  0,  0,  0,
  6,  6,  6,  6,  6,  6,  6,  6,  5,  5,  5,  4,  3,  1,  0,  0,  0,
  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,  4,  3,  2,  0,  0,  0,
  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  2,  2,  2,  2,  2,  2,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,
  2,  2,  2,  2,  2,  2,  2,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,
  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\recolor.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   recolor.cpp
*
* Abstract:
*
*   Recoloring operations.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Flush any dirty state in the recoloring and recompute accelerations
*   if necessary.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::Flush()
{
    matrixType = MatrixNone;
    gammaLut = FALSE;

    if (!(validFlags & ValidNoOp))
    {
        if (validFlags & ValidMatrix)
        {
            BOOL DiagonalMatrix = TRUE;
            BOOL TranslateMatrix = TRUE;
            BOOL ZeroesAt3 = TRUE;
            UINT i, j;

            for (i = 0; (i < 5) && DiagonalMatrix; i++)
            {
                for (j = 0; (j < 5) && DiagonalMatrix; j++)
                {
                    if ((i != j) && (matrix.m[i][j] != 0.0))
                        DiagonalMatrix = FALSE;
                }
            }
            
            for (i = 0; (i < 4) && TranslateMatrix; i++)
            {
                for (j = 0; (j < 5) && TranslateMatrix; j++)
                {
                    if (((i==j) && (REALABS(matrix.m[i][j]-1.0f) >= REAL_EPSILON)) ||
                        ((i!=j) && (REALABS(matrix.m[i][j]) >= REAL_EPSILON)))
                    {
                        TranslateMatrix = FALSE;
                    }
                }
            }
            
            if(TranslateMatrix)
            {
                matrixType = MatrixTranslate;
            }
            else
            {              
                // If the alpha channel diagonal is zero, we *must* perform
                // alpha channel recoloring because the image is becoming
                // fully transparent.
                
                if (DiagonalMatrix)
                {
                    // If it's a diagonal matrix and the alpha channel scale
                    // factor is 1, we can use a 3 channel scale.
    
                    if ( REALABS(matrix.m[3][3]-1.0f) >= REAL_EPSILON )
                    {
                        ZeroesAt3 = FALSE;
                    }
                }
                else
                {
                    for (i = 0; (i < 5) && ZeroesAt3; i++)
                    {
                        if( i == 3 )
                        {
                            // The alpha channel scale component on the main
                            // diagonal must be 1.0
                                                
                            if(REALABS(matrix.m[3][3]-1.0f) >= REAL_EPSILON) {
                                ZeroesAt3 = FALSE;
                                break;
                            }
                        }
                        else if (( REALABS(matrix.m[i][3]) >= REAL_EPSILON) || 
                                 ( REALABS(matrix.m[3][i]) >= REAL_EPSILON))
                        {
                            // All of the matrix elements that contribute alpha
                            // channel stuff must be zero (exception above).
                            
                            ZeroesAt3 = FALSE;
                            break;
                        }
                    }
                }
    
                if (DiagonalMatrix)
                {
                    if (ZeroesAt3)
                    {
                        matrixType = MatrixScale3;
                    }
                    else
                    {
                        matrixType = MatrixScale4;
                    }
    
                }
                else
                {
                    if (ZeroesAt3)
                    {
                        matrixType = Matrix4x4;
                    }
                    else
                    {
                        matrixType = Matrix5x5;
                    }
                }
            }
        }
        else
        {
            matrixType = MatrixNone;
        }

        ComputeLuts();
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize the recoloring lookup tables
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::ComputeLuts()
{
    // Lookup table to handle scaling-only default color matrix:

    if ((matrixType == MatrixScale3) || (matrixType == MatrixScale4))
    {
        {
            REAL scaleR = matrix.m[0][0];
            REAL scaleG = matrix.m[1][1];
            REAL scaleB = matrix.m[2][2];
            REAL scaleA;
            
            if (matrixType == MatrixScale4)
            {
                scaleA = matrix.m[3][3];
            }
            else
            {
                scaleA = 1.0f;
            }

            for (INT i = 0; i < 256; i++)
            {
                lutR[i] = (BYTE) ((REAL) i * scaleR);
                lutG[i] = (BYTE) ((REAL) i * scaleG);
                lutB[i] = (BYTE) ((REAL) i * scaleB);
                lutA[i] = (BYTE) ((REAL) i * scaleA);
            }
        }
    }

    // Lookup table to handle the gray scale matrix:

    if (validFlags & ValidGrayMatrix)
    {
        for (UINT index = 0; index < 256; index++)
        {
            Color gray(static_cast<BYTE>(index), 
                       static_cast<BYTE>(index), 
                       static_cast<BYTE>(index));

            grayMatrixLUT[index] = gray.GetValue();
        }
        TransformColor5x5(grayMatrixLUT, 256, matrixGray);
    }

    // Lookup tables to handle gamma correction and bileveling:

    UINT maskedFlags = validFlags & (ValidGamma | ValidBilevel);

    gammaLut = (maskedFlags != 0);
    if(!gammaLut) return;

    if (maskedFlags == ValidGamma)
    {
        // Just gamma

        for (INT i=0; i < 256; i++)
            lut[i] = (BYTE) (pow(i / 255.0, extraGamma) * 255);
    }
    else if (maskedFlags == ValidBilevel)
    {
        // Just threshold

        BYTE threshold = static_cast<BYTE>(GpCeiling(bilevelThreshold * 255.0f));

        for (INT i=0; i < 256; i++)
        {
            if (i < threshold)
                lut[i] = 0;
            else
                lut[i] = 255;
        }
    }
    else
    {
        // Both gamma and threshold

        for (INT i=0; i < 256; i++)
        {
            if (pow(i / 255.0, extraGamma) < bilevelThreshold)
                lut[i] = 0;
            else
                lut[i] = 255;
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Perform color twist recoloring using the color matrix.
*   Use special handling of Grays if necessary
*
* Arguments:
*
*   pixbuf - Pointer to the pixel buffer to be operated on
*   count - Pixel count
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::ComputeColorTwist(
    ARGB*               pixbufIn,
    UINT                countIn
    )
{
    ARGB* pixbuf;
    UINT  count;

    //QUAL: The result of the matrix is quantized to 8-bit so we can
    //      go through the LUT for the gamma/threshold operation.  For
    //      best results, the result of the matrix operation should
    //      be preserved and the gamma/threshold done it.
    //      For the special case of scaling, we can combine the
    //      LUTs rather than cascading for better accuracy and performance.

    pixbuf = pixbufIn;
    count  = countIn;

    switch(matrixType)
    {
    case MatrixNone:     
        // Nothing to do - handle the Gamma LUT after the switch
    break;

    case Matrix4x4:
    // !!! PERF [asecchia]
    // We don't have a 4x4 optimized codepath yet - fall through
    // to the general 5x5 transform.
    
    case Matrix5x5:
        if(matrixFlags == ColorMatrixFlagsDefault)
        {
            TransformColor5x5(pixbuf, count, matrix);
        }
        else
        {
            ASSERT((matrixFlags == ColorMatrixFlagsSkipGrays)||
                   (matrixFlags == ColorMatrixFlagsAltGray));            
            
            TransformColor5x5AltGrays(
                pixbuf, 
                count, 
                matrix, 
                matrixFlags == ColorMatrixFlagsSkipGrays
            );
        }
    break;

    case MatrixScale3:
    // !!! PERF [asecchia]
    // We don't have a scale 3 optimized codepath yet - fall through
    // to the more general scale 4 code.
    // The alpha LUT is set up to be the identity, so this will work.
    
    case MatrixScale4:
        if(matrixFlags == ColorMatrixFlagsDefault)
        {
            TransformColorScale4(pixbuf, count);
        }
        else
        {
            ASSERT((matrixFlags == ColorMatrixFlagsSkipGrays)||
                   (matrixFlags == ColorMatrixFlagsAltGray));            
            
            TransformColorScale4AltGrays(
                pixbuf, 
                count, 
                matrixFlags == ColorMatrixFlagsSkipGrays
            );
        }
        break;
        
    case MatrixTranslate:
        if(matrixFlags == ColorMatrixFlagsDefault)
        {
            TransformColorTranslate(pixbuf, count, matrix);
        }
        else
        {
            ASSERT((matrixFlags == ColorMatrixFlagsSkipGrays)||
                   (matrixFlags == ColorMatrixFlagsAltGray));            
            
            TransformColorTranslateAltGrays(
                pixbuf, 
                count, 
                matrix,
                matrixFlags == ColorMatrixFlagsSkipGrays
            );
        }
        break;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Perform point operation on an array of 32bpp pixels
*
* Arguments:
*
*   pixbuf - Pointer to the pixel buffer to be operated on
*   count - Pixel count
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::ColorAdjust(
    ARGB*               pixbufIn,
    UINT                countIn
    )
{
    ARGB* pixbuf;
    UINT  count;

    // Do LUT remapping:

    if (validFlags & ValidRemap)
    {
        pixbuf = pixbufIn;
        count  = countIn;

        while (count--)
        {
            ARGB p = *pixbuf;

            ColorMap *currentMap = colorMap;
            ColorMap *endMap = colorMap + colorMapCount;

            for ( ; currentMap < endMap; currentMap++)
            {
                if (p == currentMap->oldColor.GetValue())
                {
                    *pixbuf = currentMap->newColor.GetValue();
                    break;
                }
            }

            pixbuf++;
        }
    }

    // Do transparancy color keys:

    if (validFlags & ValidColorKeys)
    {
        pixbuf = pixbufIn;
        count  = countIn;

        while (count--)
        {
            ARGB p = *pixbuf;

            if ((((p      ) & 0xff) >=  colorKeyLow.GetBlue() ) &&
                (((p      ) & 0xff) <= colorKeyHigh.GetBlue() ) &&
                (((p >>  8) & 0xff) >=  colorKeyLow.GetGreen()) &&
                (((p >>  8) & 0xff) <= colorKeyHigh.GetGreen()) &&
                (((p >> 16) & 0xff) >=  colorKeyLow.GetRed()  ) &&
                (((p >> 16) & 0xff) <= colorKeyHigh.GetRed()  ))
            {
                *pixbuf = p & 0x00ffffff;
            }
            pixbuf++;
        }
    }

    // Do color twist

    ComputeColorTwist(pixbufIn, countIn);

    // Do the gamma and thresholding.
        
    if (gammaLut)
    {
        TransformColorGammaLUT(pixbufIn, countIn);
    }

    // CMYK Channel output handling:

    if ( validFlags & ValidOutputChannel )
    {
        DoCmykSeparation(pixbufIn, countIn);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Perform CMYK separation.
*
* Arguments:
*
*   pixbuf - Pointer to the pixel buffer to be processed
*   count - Pixel count
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::DoCmykSeparation(
    ARGB* pixbuf,
    UINT  count
    )
{
    switch (CmykState)
    {
    case CmykByICM:
        DoCmykSeparationByICM(pixbuf, count);
        break;

#ifdef CMYK_INTERPOLATION_ENABLED
    case CmykByInterpolation:
        DoCmykSeparationByInterpolation(pixbuf, count);
        break;
#endif

    case CmykByMapping:
    default:
        DoCmykSeparationByMapping(pixbuf, count);
        break;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Perform CMYK separation by using ICM2.0 "outside of DC" functions.
*
* Arguments:
*
*   pixbuf - Pointer to the pixel buffer to be processed
*   count - Pixel count
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::DoCmykSeparationByICM(
    ARGB* pixbuf,
    UINT  count
    )
{
    ASSERT(transformSrgbToCmyk != NULL);

    // Translate from sRGB to CMYK.  Only one scanline (plus as ARGB
    // scanline is already DWORD aligned), so we can let ICM compute
    // default stride.

    if ((*pfnTranslateBitmapBits)(
            transformSrgbToCmyk,
            pixbuf,
            BM_xRGBQUADS,
            count,
            1,
            0,
            pixbuf,
            BM_CMYKQUADS,
            0,
            NULL,
            NULL))
    {
        ULONG channelMask;
        ULONG channelShift;

        // Replicate the chosen channel to each of the destination
        // channels (negative image, since separation is being done
        // for output to a separation plate).  For example, if
        // ColorChannelFlagsM is specified, make each pixel equal
        // to (255, 255-Magenta, 255-Magenta, 255-Magenta).

        switch (ChannelIndex)
        {
        case ColorChannelFlagsC:
            channelMask = 0xff000000;
            channelShift = 24;
            break;

        case ColorChannelFlagsM:
            channelMask = 0x00ff0000;
            channelShift = 16;
            break;

        case ColorChannelFlagsY:
            channelMask = 0x0000ff00;
            channelShift = 8;
            break;

        default:
        case ColorChannelFlagsK:
            channelMask = 0x000000ff;
            channelShift = 0;
            break;
        }

        while (count--)
        {
            BYTE c = 255 - (BYTE)((*pixbuf & channelMask) >> channelShift);
            *pixbuf++ = MAKEARGB(255, c, c, c);
        }
    }
}

#ifdef CMYK_INTERPOLATION_ENABLED
/**************************************************************************\
*
* Function Description:
*
*   Perform CMYK separation using a tetrahedral interpolation.
*
* Arguments:
*
*   pixbuf - Pointer to the pixel buffer to be processed
*   count - Pixel count
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::DoCmykSeparationByInterpolation(
    ARGB* pixbuf,
    UINT  count
    )
{
    ASSERT((interpSrgbToCmyk != NULL) && interpSrgbToCmyk->IsValid());

    UINT uiChannel;

    // Figure out the channel index

    switch ( ChannelIndex )
    {
    case ColorChannelFlagsC:
        uiChannel = 0;
        break;

    case ColorChannelFlagsM:
        uiChannel = 1;
        break;

    case ColorChannelFlagsY:
        uiChannel = 2;
        break;

    default:
    case ColorChannelFlagsK:
        uiChannel = 3;
        break;
    }

    BYTE cTemp[4];

    while (count--)
    {
        interpSrgbToCmyk->Transform((BYTE *) pixbuf, cTemp);

        *pixbuf++ = MAKEARGB(255,
                             255 - cTemp[uiChannel],
                             255 - cTemp[uiChannel],
                             255 - cTemp[uiChannel]);
    }
}
#endif

/**************************************************************************\
*
* Function Description:
*
*   Perform CMYK separation using a simple mapping:
*
*       C' = 1 - R
*       M' = 1 - G
*       Y' = 1 - B
*       K  = min(C, M, Y)
*       C  = C' - K
*       Y  = Y' - K
*       M  = M' - K
*
* Arguments:
*
*   pixbuf - Pointer to the pixel buffer to be processed
*   count - Pixel count
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::DoCmykSeparationByMapping(
    ARGB* pixbuf,
    UINT  count
    )
{
    UINT uiChannel;

    // Figure out the channel index

    switch ( ChannelIndex )
    {
    case ColorChannelFlagsC:
        uiChannel = 0;

        break;

    case ColorChannelFlagsM:
        uiChannel = 1;

        break;

    case ColorChannelFlagsY:
        uiChannel = 2;

        break;

    case ColorChannelFlagsK:
        uiChannel = 3;

        break;

    default:
        // Invalid channel requirement

        return;
    }

    BYTE    cTemp[4];

    while ( count-- )
    {
        ARGB p = *pixbuf;

        // Get C, M, Y from 1 - R, 1 - G and 1 - B, respectively

        cTemp[0] = 255 - (BYTE)((p & 0x00ff0000) >> 16);    // C
        cTemp[1] = 255 - (BYTE)((p & 0x0000ff00) >> 8);     // M
        cTemp[2] = 255 - (BYTE)(p & 0x000000ff);            // Y

        // K = min(C, M, Y)

        cTemp[3] = cTemp[0];                                // K

        if ( cTemp[3] > cTemp[1] )
        {
            cTemp[3] = cTemp[1];
        }

        if ( cTemp[3] > cTemp[2] )
        {
            cTemp[3] = cTemp[2];
        }

        // C = C - K, M = M - K, Y = Y - K. But here we only need to
        // calculate the required channel. If required channel is K, then
        // we don't need to do any calculation

        if ( uiChannel < 3 )
        {
            cTemp[uiChannel] = cTemp[uiChannel] - cTemp[3];
        }

        // Compose the output channel (Note: negative image since the
        // separation is intended to go to a separation plate).

        *pixbuf++ = MAKEARGB(255,
                             255 - cTemp[uiChannel],
                             255 - cTemp[uiChannel],
                             255 - cTemp[uiChannel]);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Setup the state needed to do sRGB to CMYK conversion.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Can be one of the following values:
*
*       CmykBySimple
*           Setup to do conversion by simple mapping, DoSimpleCmykSeparation
*
*       CmykByICM
*           Setup to do conversion via ICM 2.0, DoIcmCmykSeparation
*
*       CmykByInterpolation
*           Setup to do conversion via tetrahedral interpolation,
*           DoInterpolatedCmykSeparation
*
\**************************************************************************/

#ifdef CMYK_INTERPOLATION_ENABLED
// Bring in the big sRGB to CMYK table

#include "srgb2cmyk.h"
#endif

HRESULT
GpRecolorObject::SetupCmykSeparation(WCHAR *profile)
{
    HRESULT hr = E_INVALIDARG;

    if (profile)
    {
        // First try ICM:

        hr = LoadICMDll();
        if (SUCCEEDED(hr))
        {
            HTRANSFORM transform;
            HPROFILE colorProfs[2];
            WCHAR *profileName;

            UINT profileSize = sizeof(WCHAR) * (UnicodeStringLength(profile) + 1);
            profileName = (WCHAR *) GpMalloc(profileSize);

            if (profileName)
            {
                UnicodeStringCopy(profileName, profile);

                // Setup source profile (assumes source is sRGB):

                PROFILE srgbProfile;
                char srgbProfileName[40] = "sRGB Color Space Profile.icm";
                srgbProfile.dwType = PROFILE_FILENAME;
                srgbProfile.pProfileData = srgbProfileName;
                srgbProfile.cbDataSize = 40;

                colorProfs[0] = (*pfnOpenColorProfile)(&srgbProfile,
                                                       PROFILE_READ,
                                                       FILE_SHARE_READ,
                                                       OPEN_EXISTING);

                // Setup destination CMYK profile:

                PROFILE cmykProfile;
                cmykProfile.dwType = PROFILE_FILENAME;
                cmykProfile.pProfileData = profileName;
                cmykProfile.cbDataSize = profileSize;

                colorProfs[1] = (*pfnOpenColorProfileW)(&cmykProfile,
                                                        PROFILE_READ,
                                                        FILE_SHARE_READ,
                                                        OPEN_EXISTING);

                // Assume failure:

                hr = E_INVALIDARG;

                if ((colorProfs[0] != NULL) && (colorProfs[1] != NULL))
                {
                    // Create color transform:

                    DWORD intents[2] = {INTENT_PERCEPTUAL, INTENT_PERCEPTUAL};

                    transform =
                        (*pfnCreateMultiProfileTransform)(colorProfs,
                                                          2,
                                                          intents,
                                                          2,
                                                          BEST_MODE |
                                                          USE_RELATIVE_COLORIMETRIC,
                                                          0);
                    if (transform != NULL)
                    {
                        // Replace current ICM separation info with the new stuff:

                        CleanupCmykSeparation();
                        transformSrgbToCmyk = transform;
                        profiles[0] = colorProfs[0];
                        profiles[1] = colorProfs[1];
                        cmykProfileName = profileName;

                        CmykState = CmykByICM;

                        hr = S_OK;
                    }
                }

                // If not successful, cleanup:

                if (FAILED(hr))
                {
                    // Cleanup the temp ICM separation info:

                    if (colorProfs[0] != NULL)
                        (*pfnCloseColorProfile)(colorProfs[0]);

                    if (colorProfs[1] != NULL)
                        (*pfnCloseColorProfile)(colorProfs[1]);

                    if (profileName != NULL)
                        GpFree(profileName);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

        }
        else
        {
            hr = E_FAIL;
        }

#ifdef CMYK_INTERPOLATION_ENABLED
        // If ICM failed, try setting up for interpolation

        if (CmykState == CmykByMapping)
        {
            interpSrgbToCmyk = new K2_Tetrahedral(SrgbToCmykTable, 17, 3, 4);

            if (interpSrgbToCmyk)
            {
                if (interpSrgbToCmyk->IsValid())
                {
                    CmykState = CmykByInterpolation;
                    hr = S_OK;
                }
                else
                {
                    CleanupCmykSeparation();
                }
            }
        }
#endif
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Cleanup state setup by SetupCmykSeparation.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::CleanupCmykSeparation()
{
    if (transformSrgbToCmyk)
    {
        (*pfnDeleteColorTransform)(transformSrgbToCmyk);
        transformSrgbToCmyk = NULL;
    }

    if (profiles[0] != NULL)
    {
        (*pfnCloseColorProfile)(profiles[0]);
        profiles[0] = NULL;
    }

    if (profiles[1] != NULL)
    {
        (*pfnCloseColorProfile)(profiles[1]);
        profiles[1] = NULL;
    }

#ifdef CMYK_INTERPOLATION_ENABLED
    if (interpSrgbToCmyk)
    {
        delete interpSrgbToCmyk;
        interpSrgbToCmyk = NULL;
    }
#endif

    if (cmykProfileName != NULL)
    {
        GpFree(cmykProfileName);
        cmykProfileName = NULL;
    }

    CmykState = CmykByMapping;
}

#ifdef CMYK_INTERPOLATION_ENABLED
//==============================================================================

inline
int K2_Tetrahedral::addshift(int x)  
{
    return ( 17*( 17*((x & 0x0004) >> 2) + ((x & 0x0002) >> 1) ) + (x & 0x0001) );
}

K2_Tetrahedral::K2_Tetrahedral(BYTE *tbl, int tableDim, int inDim, int outDim)
{
    int i, j, tableSize = 0;

    // Currently only need sRGB to CMYK conversion, so we can assume inDim==3
    // and outDim==4.
    //ASSERT((inDim==3) || (inDim==4));
    ASSERT(inDim==3);

    ASSERT(tableDim == 17);

    for (i=0; i<K2_TETRAHEDRAL_MAX_TABLES; i++)
    {
        table[i] = NULL;
    }

    inDimension = inDim;
    outDimension = outDim;
    tableDimension = tableDim;

    if (inDimension == 3)
        tableSize = 17*17*17;
    if (inDimension == 4)
        tableSize = 17*17*17*17;

    UINT *tableBuffer = (UINT *) GpMalloc(sizeof(UINT) * tableSize * outDimension);

    if (tableBuffer)
    {
        for (i=0; i<outDimension; i++)
        {
            table[i] = tableBuffer + (tableSize * i);

            for (j=0; j<tableSize; j++)
            {
                table[i][j] = (*tbl++);
            }
        }

        valid = TRUE;
    }
    else
    {
        WARNING(("K2_Tetrahedral - unable to allocate memory"));
        valid = FALSE;
    }
}

K2_Tetrahedral::~K2_Tetrahedral()
{
    if (table[0])
        GpFree(table[0]);

    SetValid(FALSE);    // so we don't use a deleted object
}

inline
void K2_Tetrahedral::Transform (BYTE *in, BYTE *out)
{
    unsigned int *tbl, r1, r2;
    register int  a, b, c;
    register char v0, v1, v2, v3;
    register char v1_and_v0, v2_and_v1, v3_and_v2;
    register char v1_or_v0,  v2_or_v1,  v3_or_v2;
    register char v2_and_v1_and_v0, v3_or_v2_or_v1_or_v0;
    register char v2_and_v1_or_v0,  v3_or_v2_or_v1_and_v0;
    register char v2_or_v1_and_v0,  v3_or_v2_and_v1_or_v0;
    register char v2_or_v1_or_v0,   v3_or_v2_and_v1_and_v0;
    register char v3_and_v2_and_v1, v3_and_v2_or_v1_or_v0;
    register char v3_and_v2_or_v1,  v3_and_v2_or_v1_and_v0;
    register char v3_or_v2_and_v1,  v3_and_v2_and_v1_or_v0;
    register char v3_or_v2_or_v1,   v3_and_v2_and_v1_and_v0;
    register int index0, index1, index2, index3, index4, index5, index6, index7;
    register int index8, index9, index10, index11, index12, index13, index14, index15;

    //a = (in[0] >= 0xF8) ? (int)in[0]+1 : (int)in[0];
    //b = (in[1] >= 0xF8) ? (int)in[1]+1 : (int)in[1];
    //c = (in[2] >= 0xF8) ? (int)in[2]+1 : (int)in[2];
    a = (in[2] >= 0xF8) ? (int)in[2]+1 : (int)in[2];
    b = (in[1] >= 0xF8) ? (int)in[1]+1 : (int)in[1];
    c = (in[0] >= 0xF8) ? (int)in[0]+1 : (int)in[0];

    // Compute slices across the input components
    v0 = ( (a & 0x01) << 2 ) + ( (b & 0x01) << 1 ) + ( (c & 0x01) );
    v1 = ( (a & 0x02) << 1 ) + ( (b & 0x02) )      + ( (c & 0x02) >> 1);
    v2 = ( (a & 0x04) )      + ( (b & 0x04) >> 1 ) + ( (c & 0x04) >> 2);
    v3 = ( (a & 0x08) >> 1 ) + ( (b & 0x08) >> 2 ) + ( (c & 0x08) >> 3);

    // Compute offset from origin
    v1_and_v0               = v1 & v0;
    v1_or_v0                = v1 | v0;
    v2_and_v1               = v2 & v1;
    v2_and_v1_and_v0        = v2 & v1_and_v0;
    v2_and_v1_or_v0         = v2 & v1_or_v0;
    v2_or_v1                = v2 | v1;
    v2_or_v1_and_v0         = v2 | v1_and_v0;
    v2_or_v1_or_v0          = v2 | v1_or_v0;
    v3_and_v2               = v3 & v2;
    v3_and_v2_and_v1        = v3 & v2_and_v1;
    v3_and_v2_and_v1_and_v0 = v3 & v2_and_v1_and_v0;
    v3_and_v2_and_v1_or_v0  = v3 & v2_and_v1_or_v0;
    v3_and_v2_or_v1         = v3 & v2_or_v1;
    v3_and_v2_or_v1_and_v0  = v3 & v2_or_v1_and_v0;
    v3_and_v2_or_v1_or_v0   = v3 & v2_or_v1_or_v0;
    v3_or_v2                = v3 | v2;
    v3_or_v2_and_v1         = v3 | v2_and_v1;
    v3_or_v2_and_v1_and_v0  = v3 | v2_and_v1_and_v0;
    v3_or_v2_and_v1_or_v0   = v3 | v2_and_v1_or_v0;
    v3_or_v2_or_v1          = v3 | v2_or_v1;
    v3_or_v2_or_v1_and_v0   = v3 | v2_or_v1_and_v0;
    v3_or_v2_or_v1_or_v0    = v3 | v2_or_v1_or_v0;

    // Generate indicies into table
    index0  = ( 17*17*(a>>4) ) + ( 17*(b>>4) ) + (c>>4);
    index1  = addshift(v3);
    index2  = addshift(v3_and_v2);
    index3  = addshift(v3_and_v2_and_v1);
    index4  = addshift(v3_and_v2_and_v1_and_v0);
    index5  = addshift(v3_and_v2_and_v1_or_v0);
    index6  = addshift(v3_and_v2_or_v1);
    index7  = addshift(v3_and_v2_or_v1_and_v0);
    index8  = addshift(v3_and_v2_or_v1_or_v0);
    index9  = addshift(v3_or_v2);
    index10 = addshift(v3_or_v2_and_v1);
    index11 = addshift(v3_or_v2_and_v1_and_v0);
    index12 = addshift(v3_or_v2_and_v1_or_v0);
    index13 = addshift(v3_or_v2_or_v1);
    index14 = addshift(v3_or_v2_or_v1_and_v0);
    index15 = addshift(v3_or_v2_or_v1_or_v0);

    // Compute output
    if (inDimension == 3)
    {
        for (int i=0; i<outDimension; i++)
        {
            tbl = table[i] + index0;

            r1 = (tbl[0] + tbl[index1] + tbl[index2] + tbl[index3] +
                  tbl[index4] + tbl[index5] + tbl[index6] + tbl[index7] +
                  tbl[index8] + tbl[index9] + tbl[index10] + tbl[index11] +
                  tbl[index12] + tbl[index13] + tbl[index14] + tbl[index15] +
                  0x08 ) >> 4;

            if (r1 > 255)
                out[i] = (BYTE) 255;
            else
                out[i] = (BYTE) r1;
        }
    }
    else if (inDimension == 4)
    {
        // 4D interpolator (linearly interpolate on 4th dimension)

        unsigned int kindex, koffset1, koffset2;
        double fraction, ip, r;

        kindex   = in[3] >> 4;
        koffset1 = 17*17*17 * kindex;
        koffset2 = 17*17*17 * (kindex + 1);

        if (kindex < 15)
            fraction = (double)(in[3] & 0x0f)/16.0;
        else                                      // Do end point short step
            fraction = (double)(in[3] & 0x0f)/15.0;

        for (int i=0; i<outDimension; i++)
        {
            tbl = table[i] + index0 + koffset1;

            r1 = tbl[0] + tbl[index1] + tbl[index2] + tbl[index3] +
                 tbl[index4] + tbl[index5] + tbl[index6] + tbl[index7] +
                 tbl[index8] + tbl[index9] + tbl[index10] + tbl[index11] +
                 tbl[index12] + tbl[index13] + tbl[index14] + tbl[index15];

            tbl = table[i] + index0 + koffset2;

            r2 = tbl[0] + tbl[index1] + tbl[index2] + tbl[index3] +
                 tbl[index4] + tbl[index5] + tbl[index6] + tbl[index7] +
                 tbl[index8] + tbl[index9] + tbl[index10] + tbl[index11] +
                 tbl[index12] + tbl[index13] + tbl[index14] + tbl[index15];

            r = ((double)r1 + ((double)r2-(double)r1)*fraction )/16.0 + 0.5;  // interpolate & round

            modf(r,&ip);

            if (ip > 255)
                ip = 255;

            out[i] = (BYTE)ip;
        }
    }
}
#endif


// Weird channel ordering.

#define B_CHANNEL 2
#define G_CHANNEL 1
#define R_CHANNEL 0
#define A_CHANNEL 3

/**************************************************************************\
*
* Function Description:
*
*   Apply the 5x5 Color Matrix in place
*
* Arguments:
*
*   InOut buf     - the color data
*   IN    count   - number of pixels in the color data
*   IN    cmatrix - The color matrix to use for the transform.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/


VOID
GpRecolorObject::TransformColor5x5(
    ARGB *buf, 
    INT count,
    ColorMatrix cmatrix    
)
{
    // must be passed a valid buffer.
    
    ASSERT(count >= 0);
    ASSERT(buf != NULL);
    
    INT i = count;
    
    // Set up byte pointers to each of the color chanels for this pixel.
    
    BYTE *b = (BYTE*) buf;
    BYTE *g;
    BYTE *r;
    BYTE *a;
    
    // Pre-compute the translation component -- it'll be the same
    // for all pixels.
    
    REAL b_c = cmatrix.m[4][B_CHANNEL] * 255;
    REAL g_c = cmatrix.m[4][G_CHANNEL] * 255;
    REAL r_c = cmatrix.m[4][R_CHANNEL] * 255;
    REAL a_c = cmatrix.m[4][A_CHANNEL] * 255;
    
    BYTE bv;
    BYTE gv;
    BYTE rv;
    BYTE av;    
    
    // Run through all the pixels in the input buffer.
    
    while(i--) 
    {
        // b channel is already set - set the others
        
        g = b+1;
        r = b+2;
        a = b+3;
        
        // access the individual channels using byte pointer access
        
        // !!! [asecchia] not computing the homogenous coordinate -
        //     perspective transform is ignored.
        //     We should be computing the coefficient and dividing 
        //     by it for each channel.
        
        // BackWords order BGRA
            
        // Compute the matrix channel contributions into temporary storage
        // so that we avoid propagating the new value of the channel into
        // the computation for the next channel.
        
        // Blue channel
        bv = ByteSaturate( GpRound (
            cmatrix.m[0][B_CHANNEL] * (*r) +
            cmatrix.m[1][B_CHANNEL] * (*g) +
            cmatrix.m[2][B_CHANNEL] * (*b) +
            cmatrix.m[3][B_CHANNEL] * (*a) + b_c
        )); 
        
        // Green channel
        gv = ByteSaturate( GpRound (
            cmatrix.m[0][G_CHANNEL] * (*r) +
            cmatrix.m[1][G_CHANNEL] * (*g) +
            cmatrix.m[2][G_CHANNEL] * (*b) +
            cmatrix.m[3][G_CHANNEL] * (*a) + g_c
        )); 

        // Red channel
        rv = ByteSaturate( GpRound (
            cmatrix.m[0][R_CHANNEL] * (*r) +
            cmatrix.m[1][R_CHANNEL] * (*g) +
            cmatrix.m[2][R_CHANNEL] * (*b) +
            cmatrix.m[3][R_CHANNEL] * (*a) + r_c
        )); 
        
        // Alpha channel
        av = ByteSaturate( GpRound (
            cmatrix.m[0][A_CHANNEL] * (*r) +
            cmatrix.m[1][A_CHANNEL] * (*g) +
            cmatrix.m[2][A_CHANNEL] * (*b) +
            cmatrix.m[3][A_CHANNEL] * (*a) + a_c
        )); 
                
        // Update the pixel in the buffer.
        
        *b = bv;
        *g = gv;
        *r = rv;
        *a = av;
        
        // Next pixel.
        
        b += 4;
    }    
}

/**************************************************************************\
*
* Function Description:
*
*   Apply the 5x5 Color Matrix in place - handle special case grays
*
* Arguments:
*
*   InOut buf     - the color data
*   IN    count   - number of pixels in the color data
*   IN    cmatrix - The color matrix to use for the transform.
*   IN    skip    - True if the skip grays flag is on.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/


VOID
GpRecolorObject::TransformColor5x5AltGrays(
    ARGB *buf, 
    INT count,
    ColorMatrix cmatrix,
    BOOL skip
)
{
    // must be passed a valid buffer.
    
    ASSERT(count >= 0);
    ASSERT(buf != NULL);
    
    INT i = count;
    
    // Set up byte pointers to each of the color chanels for this pixel.
    
    BYTE *b = (BYTE*) buf;
    BYTE *g;
    BYTE *r;
    BYTE *a;
    
    // Pre-compute the translation component -- it'll be the same
    // for all pixels.
    
    REAL b_c = cmatrix.m[4][B_CHANNEL] * 255;
    REAL g_c = cmatrix.m[4][G_CHANNEL] * 255;
    REAL r_c = cmatrix.m[4][R_CHANNEL] * 255;
    REAL a_c = cmatrix.m[4][A_CHANNEL] * 255;
    
    BYTE bv;
    BYTE gv;
    BYTE rv;
    BYTE av;
    
    // Run through all the pixels in the input buffer.
    
    while(i--) 
    {
        if(!IsPureGray((ARGB*)b))
        {        
            // b channel is already set - set the others
            
            g = b+1;
            r = b+2;
            a = b+3;
            
            // access the individual channels using byte pointer access
            
            // !!! [asecchia] not computing the homogenous coordinate -
            //     perspective transform is ignored.
            //     We should be computing the coefficient and dividing 
            //     by it for each channel.
            
            // BackWords order BGRA
            
            // Compute the matrix channel contributions into temporary storage
            // so that we avoid propagating the new value of the channel into
            // the computation for the next channel.
            
            // Blue channel
            bv = ByteSaturate( GpRound (
                cmatrix.m[0][B_CHANNEL] * (*r) +
                cmatrix.m[1][B_CHANNEL] * (*g) +
                cmatrix.m[2][B_CHANNEL] * (*b) +
                cmatrix.m[3][B_CHANNEL] * (*a) + b_c
            )); 
            
            // Green channel
            gv = ByteSaturate( GpRound (
                cmatrix.m[0][G_CHANNEL] * (*r) +
                cmatrix.m[1][G_CHANNEL] * (*g) +
                cmatrix.m[2][G_CHANNEL] * (*b) +
                cmatrix.m[3][G_CHANNEL] * (*a) + g_c
            )); 
    
            // Red channel
            rv = ByteSaturate( GpRound (
                cmatrix.m[0][R_CHANNEL] * (*r) +
                cmatrix.m[1][R_CHANNEL] * (*g) +
                cmatrix.m[2][R_CHANNEL] * (*b) +
                cmatrix.m[3][R_CHANNEL] * (*a) + r_c
            )); 
            
            // Alpha channel
            av = ByteSaturate( GpRound (
                cmatrix.m[0][A_CHANNEL] * (*r) +
                cmatrix.m[1][A_CHANNEL] * (*g) +
                cmatrix.m[2][A_CHANNEL] * (*b) +
                cmatrix.m[3][A_CHANNEL] * (*a) + a_c
            ));
            
            // Update the pixel in the buffer.
            
            *b = bv;
            *g = gv;
            *r = rv;
            *a = av;
        }
        else
        {
            if(!skip) 
            {
                *(ARGB *)b = grayMatrixLUT[*b];
            }
        }
        
        // Next pixel.
            
        b += 4;
    }    
}


/**************************************************************************\
*
* Function Description:
*
*   Apply the 5x5 Color Matrix in place. Special case for the ARGB scale
*
* Arguments:
*
*   InOut buf     - the color data
*   IN    count   - number of pixels in the color data
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::TransformColorScale4(
    ARGB *buf, 
    INT count
)
{
    // must be passed a valid buffer.
    ASSERT(count >= 0);
    ASSERT(buf != NULL);
    
    INT i = count;
    BYTE *b = (BYTE*) buf;
    
    // Run through all the pixels in the input buffer.
    
    while(i--) 
    {
        // access the individual channels using byte pointer access
        // Ignore the gamma LUT for the alpha channel.

        // BackWords order BGRA
        *b++ = lutB[*b];
        *b++ = lutG[*b];
        *b++ = lutR[*b];
        *b++ = lutA[*b];
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Apply the 5x5 Color Matrix in place. Special case for the ARGB scale.
*   Handle special case grays.   
*
* Arguments:
*
*   InOut buf     - the color data
*   IN    count   - number of pixels in the color data
*   IN    skip    - True if the skip grays flag is on.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::TransformColorScale4AltGrays(
    ARGB *buf, 
    INT count,
    BOOL skip
)
{
    // must be passed a valid buffer.
    ASSERT(count >= 0);
    ASSERT(buf != NULL);
    
    INT i = count;
    BYTE *b = (BYTE*) buf;
    
    // Run through all the pixels in the input buffer.
    
    while(i--) 
    {
        if(!IsPureGray((ARGB*)b))
        {        
            // access the individual channels using byte pointer access
            // Ignore the gamma LUT for the alpha channel.
    
            // BackWords order BGRA
            *b++ = lutB[*b];
            *b++ = lutG[*b];
            *b++ = lutR[*b];
            *b++ = lutA[*b];
        }
        else
        {
            if(!skip) 
            {
                *(ARGB *)b = grayMatrixLUT[*b];
            }
            
            b += 4;
        }
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Apply the Gamma Look Up Table (LUT)
*
* Arguments:
*
*   InOut buf     - the color data
*   IN    count   - number of pixels in the color data
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::TransformColorGammaLUT(
    ARGB *buf, 
    INT count
)
{
    // must be passed a valid buffer.
    ASSERT(count >= 0);
    ASSERT(buf != NULL);
    
    INT i = count;
    BYTE *b = (BYTE*) buf;
    
    // Run through all the pixels in the input buffer.
    
    while(i--) 
    {
        // access the individual channels using byte pointer access
        // Ignore the gamma LUT for the alpha channel.

        // BackWords order BGRA
        *b++ = lut[*b];
        *b++ = lut[*b];
        *b++ = lut[*b];
         b++;             // don't gamma convert the alpha channel
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Apply the 5x5 Color Matrix in the special case of only translation
*
* Arguments:
*
*   InOut buf     - the color data
*   IN    count   - number of pixels in the color data
*   IN    cmatrix - The color matrix to use for the transform.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::TransformColorTranslate(
    ARGB *buf, 
    INT count,
    ColorMatrix cmatrix
)
{
    // must be passed a valid buffer.
    ASSERT(count >= 0);
    ASSERT(buf != NULL);
    
    INT i = count;
    BYTE *b = (BYTE*) buf;
    INT b_c = GpRound( cmatrix.m[4][B_CHANNEL] * 255 );
    INT g_c = GpRound( cmatrix.m[4][G_CHANNEL] * 255 );
    INT r_c = GpRound( cmatrix.m[4][R_CHANNEL] * 255 );
    INT a_c = GpRound( cmatrix.m[4][A_CHANNEL] * 255 );
    
    
    // Run through all the pixels in the input buffer.
    
    while(i--) 
    {
        // access the individual channels using byte pointer access
        
        // BackWords order BGRA
        *b++ = ByteSaturate((*b) + b_c);
        *b++ = ByteSaturate((*b) + g_c);
        *b++ = ByteSaturate((*b) + r_c);
        *b++ = ByteSaturate((*b) + a_c);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Apply the 5x5 Color Matrix in the special case of only translation
*   Handle special case grays.
*
* Arguments:
*
*   InOut buf     - the color data
*   IN    count   - number of pixels in the color data
*   IN    cmatrix - The color matrix to use for the transform.
*   IN    skip    - True if the skip grays flag is on.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::TransformColorTranslateAltGrays(
    ARGB *buf, 
    INT count,
    ColorMatrix cmatrix,
    BOOL skip
)
{
    // must be passed a valid buffer.
    ASSERT(count >= 0);
    ASSERT(buf != NULL);
    
    INT i = count;
    BYTE *b = (BYTE*) buf;
    INT b_c = GpRound( cmatrix.m[4][B_CHANNEL] * 255 );
    INT g_c = GpRound( cmatrix.m[4][G_CHANNEL] * 255 );
    INT r_c = GpRound( cmatrix.m[4][R_CHANNEL] * 255 );
    INT a_c = GpRound( cmatrix.m[4][A_CHANNEL] * 255 );
    
    // Run through all the pixels in the input buffer.
    
    while(i--) 
    {
        if(!IsPureGray((ARGB*)b))
        {
            // access the individual channels using byte pointer access

            // BackWords order BGRA
            *b++ = ByteSaturate((*b) + b_c);
            *b++ = ByteSaturate((*b) + g_c);
            *b++ = ByteSaturate((*b) + r_c);
            *b++ = ByteSaturate((*b) + a_c);
        }
        else 
        {
            if(!skip) 
            {
                *(ARGB *)b = grayMatrixLUT[*b];
            }
        
            b += 4;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\recolor.hpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   recolor.hpp
*
* Abstract:
*
*   GpRecolor and GpRecolorObject class declarations
*
\**************************************************************************/

#ifndef _RECOLOR_HPP
#define _RECOLOR_HPP

//#define CMYK_INTERPOLATION_ENABLED
#ifdef CMYK_INTERPOLATION_ENABLED

//--------------------------------------------------------------------------
// K2_Tetrahedral class
//
// Used to do tetrahedral interpolation for color space conversion
//--------------------------------------------------------------------------

#define K2_TETRAHEDRAL_MAX_TABLES 4

class K2_Tetrahedral
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagK2_Tetrahedral : ObjectTagInvalid;
    }

public:

    K2_Tetrahedral(BYTE*, int, int, int);
    ~K2_Tetrahedral();

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagK2_Tetrahedral) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid K2_Tetrahedral");
        }
    #endif

        return (Tag == ObjectTagK2_Tetrahedral);
    }

    VOID Transform(BYTE*, BYTE*);

private:

    int inDimension, outDimension;
    int tableDimension;
    unsigned int *table[K2_TETRAHEDRAL_MAX_TABLES];

    int addshift(int);
};
#endif

//--------------------------------------------------------------------------
// GpRecolorObject class
//--------------------------------------------------------------------------

class GpRecolorObject
{
    friend class GpMemoryBitmap;

public:

    GpRecolorObject()
    {
        validFlags = 0;

        colorMapSize = 0;
        colorMap = NULL;

        grayMatrixLUT = NULL;

        profiles[0] = NULL;
        profiles[1] = NULL;
        transformSrgbToCmyk = NULL;
#ifdef CMYK_INTERPOLATION_ENABLED
        interpSrgbToCmyk = NULL;
#endif
        cmykProfileName = NULL;
        CmykState = CmykByMapping;
    }

    ~GpRecolorObject()
    {
        if (colorMap)
            GpFree(colorMap);

        if (grayMatrixLUT)
            GpFree(grayMatrixLUT);

        CleanupCmykSeparation();
    }

    VOID Dispose()
    {
        delete this;
    }

    VOID Flush();

    // Perform recoloring:

    VOID
    ColorAdjust(
        ARGB* pixbufIn,
        UINT  countIn
        );

    // Recoloring helper functions:

    VOID
    ComputeColorTwist(
        ARGB* pixbufIn,
        UINT  countIn
        );

    VOID
    DoCmykSeparation(
        ARGB* pixbuf,
        UINT  count
        );

    // Methods to set recoloring attributes:

    HRESULT
    SetColorMatrix(
        ColorMatrix *colorMatrix,
        ColorMatrixFlags flags = ColorMatrixFlagsDefault
        )
    {
        if (colorMatrix &&
            ((flags == ColorMatrixFlagsDefault) || (flags == ColorMatrixFlagsSkipGrays)))
        {
            matrix = *colorMatrix;
            matrixFlags = flags;
            SetFlag(ValidMatrix);
            ClearFlag(ValidGrayMatrix);
            return S_OK;
        }
        else
            return E_INVALIDARG;
    }

    HRESULT
    SetColorMatrices(
        ColorMatrix *colorMatrix,
        ColorMatrix *grayMatrix,
        ColorMatrixFlags flags = ColorMatrixFlagsDefault
        )
    {
        if ((grayMatrix == NULL) || (flags != ColorMatrixFlagsAltGray))
            return SetColorMatrix(colorMatrix, flags);

        if (grayMatrixLUT == NULL)
        {
            grayMatrixLUT = static_cast<ARGB *>(GpMalloc(256*sizeof(ARGB)));

            if (grayMatrixLUT == NULL)
            {
                ClearFlag(ValidGrayMatrix);
                return E_OUTOFMEMORY;
            }
        }

        if (colorMatrix)
        {
            matrix = *colorMatrix;
            matrixGray = *grayMatrix;
            matrixFlags = flags;
            SetFlag(ValidMatrix);
            SetFlag(ValidGrayMatrix);
            return S_OK;
        }
        else
            return E_INVALIDARG;
    }

    HRESULT ClearColorMatrices()
    {
        ClearFlag(ValidMatrix);
        ClearFlag(ValidGrayMatrix);
        return S_OK;
    }

    HRESULT SetThreshold(REAL threshold)
    {
        bilevelThreshold = threshold;
        SetFlag(ValidBilevel);
        return S_OK;
    }

    HRESULT ClearThreshold()
    {
        ClearFlag(ValidBilevel);
        return S_OK;
    }

    HRESULT SetGamma(REAL gamma)
    {
        if ( gamma <= 0.0 )
        {
            WARNING(("GpRecolorObject::SetGamma---can't set gamma <= 0.0"));
            return E_FAIL;
        }

        extraGamma = gamma;
        SetFlag(ValidGamma);
        return S_OK;
    }

    HRESULT ClearGamma()
    {
        ClearFlag(ValidGamma);
        return S_OK;
    }

    HRESULT SetNoOp()
    {
        SetFlag(ValidNoOp);
        return S_OK;
    }

    HRESULT ClearNoOp()
    {
        ClearFlag(ValidNoOp);
        return S_OK;
    }

    HRESULT SetColorKey(Color* colorLow, Color* colorHigh)
    {
        if (colorLow && colorHigh &&
            (colorLow->GetRed()   <= colorHigh->GetRed()  ) &&
            (colorLow->GetGreen() <= colorHigh->GetGreen()) &&
            (colorLow->GetBlue()  <= colorHigh->GetBlue() ))
        {
            colorKeyLow  = *colorLow;
            colorKeyHigh = *colorHigh;
            SetFlag(ValidColorKeys);
            return S_OK;
        }
        else
            return E_INVALIDARG;
    }

    HRESULT ClearColorKey()
    {
        ClearFlag(ValidColorKeys);
        return S_OK;
    }

    HRESULT SetOutputChannel(ColorChannelFlags channelFlags)
    {
        if ( (channelFlags >= ColorChannelFlagsC)
           &&(channelFlags < ColorChannelFlagsLast) )
        {
            ChannelIndex = channelFlags;

            SetFlag(ValidOutputChannel);

            return S_OK;
        }
        else
        {
            return E_INVALIDARG;
        }
    }
    
    HRESULT ClearOutputChannel()
    {
        ClearFlag(ValidOutputChannel);
        return S_OK;        
    }

    HRESULT SetOutputChannelProfile(WCHAR *profile)
    {
        HRESULT hr = SetupCmykSeparation(profile);

        if (SUCCEEDED(hr))
        {
            SetFlag(ValidChannelProfile);
        }

        return hr;
    }
    
    HRESULT ClearOutputChannelProfile()
    {
        CleanupCmykSeparation();
        ClearFlag(ValidChannelProfile);

        return S_OK;        
    }

    HRESULT SetRemapTable(UINT mapSize, ColorMap *map)
    {
        if (mapSize && map)
        {
            if (mapSize > colorMapSize)
            {
                VOID *newmap = GpMalloc(mapSize * sizeof(ColorMap));

                if (newmap)
                {
                    if (colorMap)
                        GpFree(colorMap);

                    colorMapSize = mapSize;
                    colorMap = static_cast<ColorMap *>(newmap);
                }
                else
                    return E_OUTOFMEMORY;
            }

            SetFlag(ValidRemap);
            colorMapCount = mapSize;
            memcpy(static_cast<VOID*>(colorMap), static_cast<VOID*>(map),
                   mapSize * sizeof(ColorMap));

            return S_OK;
        }
        else
            return E_INVALIDARG;
    }

    HRESULT ClearRemapTable()
    {
        ClearFlag(ValidRemap);
        return S_OK;
    }

public:

    enum
    {
        ValidNoOp           = 0x00000001,
        ValidMatrix         = 0x00000002,
        ValidBilevel        = 0x00000004,
        ValidGamma          = 0x00000008,
        ValidColorKeys      = 0x00000010,
        ValidRemap          = 0x00000020,
        ValidOutputChannel  = 0x00000040,
        ValidGrayMatrix     = 0x00000080,
        ValidChannelProfile = 0x00000100
    };

public:

    UINT validFlags;

    ColorMatrixFlags matrixFlags;
    ColorMatrix matrix;
    ColorMatrix matrixGray;

    REAL bilevelThreshold;
    REAL extraGamma;

    Color colorKeyLow;
    Color colorKeyHigh;

    ColorChannelFlags   ChannelIndex;   
    
    UINT colorMapSize;
    UINT colorMapCount;
    ColorMap *colorMap;

private:

    VOID SetFlag(UINT flag)
    {
        validFlags |= flag;
    }

    VOID ClearFlag(UINT flag)
    {
        validFlags &= ~flag;
    }

public:

    enum
    {
        MatrixNone      = 0,
        Matrix4x4       = 1,
        Matrix5x5       = 2,
        MatrixScale3    = 3,    // used for contrast adjustments
        MatrixScale4    = 4,    // used for contrast adjustments
        MatrixTranslate = 5     // used for brightness adjustments
    };

private:

    UINT matrixType;
    BOOL gammaLut;
    BYTE lutR[256];
    BYTE lutG[256];
    BYTE lutB[256];
    BYTE lutA[256];
    BYTE lut[256];
    ARGB *grayMatrixLUT;

    // CMYK separation data

    enum
    {
        CmykByMapping       = 0,
        CmykByICM           = 1,
        CmykByInterpolation = 2
    };

    UINT CmykState;
    WCHAR *cmykProfileName;             // filename of CMYK ICC profile
    HPROFILE profiles[2];               // for ICM-based separation
    HTRANSFORM transformSrgbToCmyk;     // for ICM-based separation
#ifdef CMYK_INTERPOLATION_ENABLED
    K2_Tetrahedral* interpSrgbToCmyk;   // for interpolation-based separation
#endif

    VOID ComputeLuts();

    inline BOOL IsPureGray(ARGB* argb)
    {
        // Access the RGB channels through byte pointer comparisons.

        return (
            (*(BYTE*)(argb) == (*( (BYTE*)(argb)+1 ))) &&
            (*(BYTE*)(argb) == (*( (BYTE*)(argb)+2 )))
        );
    }
    
    inline BYTE ByteSaturate(INT i) 
    {
        if(i > 255) {i = 255;}
        if(i < 0) {i = 0;}                   
        return (BYTE)i;
    }

    VOID TransformColor5x5(
        ARGB *buf, 
        INT count, 
        ColorMatrix cmatrix
    );
    
    VOID TransformColor5x5AltGrays(
        ARGB *buf, 
        INT count, 
        ColorMatrix cmatrix,
        BOOL skip
    );
    
    VOID TransformColorGammaLUT(ARGB *buf, INT count);
    
    VOID TransformColorScale4(
        ARGB *buf, 
        INT count
    );
    
    VOID TransformColorScale4AltGrays(
        ARGB *buf, 
        INT count,
        BOOL skip
    );
    
    VOID TransformColorTranslate(
        ARGB *buf, 
        INT count, 
        ColorMatrix cmatrix
    );
    
    VOID TransformColorTranslateAltGrays(
        ARGB *buf, 
        INT count, 
        ColorMatrix cmatrix,
        BOOL skip
    );

    VOID
    DoCmykSeparationByICM(
        ARGB* pixbuf,
        UINT  count
        );

#ifdef CMYK_INTERPOLATION_ENABLED
    VOID
    DoCmykSeparationByInterpolation(
        ARGB* pixbuf,
        UINT  count
        );
#endif

    VOID
    DoCmykSeparationByMapping(
        ARGB* pixbuf,
        UINT  count
        );

    HRESULT SetupCmykSeparation(WCHAR *profile);
    VOID CleanupCmykSeparation();
};

//--------------------------------------------------------------------------
// GpRecolor class
//--------------------------------------------------------------------------

class GpRecolor
{
protected:
    // If NULL, use RecolorObject[ColorAdjustTypeDefault], unless
    // IsIdentity is TRUE.
    
    GpRecolorObject *       RecolorObject[ColorAdjustTypeCount];

    // If set, there is no recoloring for this type of object
    BYTE                    IsIdentity[ColorAdjustTypeCount];
    
public:

    GpRecolor()
    {
        GpMemset(RecolorObject, 0, ColorAdjustTypeCount * sizeof(RecolorObject[0]));
        GpMemset(IsIdentity,    0, ColorAdjustTypeCount * sizeof(IsIdentity[0]));
    }

    ~GpRecolor()
    {
        for (INT i = 0; i < ColorAdjustTypeCount; i++)
        {
            delete RecolorObject[i];
        }
    }

    VOID Dispose()
    {
        delete this;
    }

    // Set to identity, regardless of what the default color adjustment is.
    VOID
    SetToIdentity(
        ColorAdjustType     type
        )
    {
        if ((type == ColorAdjustTypeDefault) || ValidColorAdjustType(type))
        {
            delete RecolorObject[type];
            RecolorObject[type] = NULL;
            IsIdentity[type] = TRUE;
        }
    }

    // Remove any individual color adjustments, and go back to using the default
    VOID
    Reset(
        ColorAdjustType     type
        )
    {
        if ((type == ColorAdjustTypeDefault) || ValidColorAdjustType(type))
        {
            delete RecolorObject[type];
            RecolorObject[type] = NULL;
            IsIdentity[type] = FALSE;
        }
    }

    VOID
    ColorAdjust(
        ARGB*               pixbufIn,
        UINT                countIn,
        ColorAdjustType     type
        ) const
    {
        GpRecolorObject *   recolorObject = UseRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            recolorObject->ColorAdjust(pixbufIn, countIn);
        }
    }

    VOID
    ColorAdjustCOLORREF(
        COLORREF *          color,
        ColorAdjustType     type
        ) const
    {
        GpRecolorObject *   recolorObject = UseRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            ARGB    argb = COLORREFToARGB(*color);
            recolorObject->ColorAdjust(&argb, 1);
            *color = ARGBToCOLORREF(argb);
        }
    }

    UINT
    GetValidFlags(
        ColorAdjustType     type
        ) const
    {
        UINT                validFlags    = 0;
        GpRecolorObject *   recolorObject = UseRecolorObject(type);

        if (recolorObject != NULL)
        {
            validFlags = recolorObject->validFlags;
        }
        return validFlags;
    }

    BOOL 
    HasRecoloring(
        ColorAdjustType type
        ) const
    {
        if (type != ColorAdjustTypeAny)
        {
            return (GetValidFlags(type) != 0);
        }
        else
        {
            GpRecolorObject *   recolorObject;
            
            for (INT i = ColorAdjustTypeDefault; i < ColorAdjustTypeCount; i++)
            {
                recolorObject = ClearRecolorObject((ColorAdjustType)i);
                if ((recolorObject != NULL) && (recolorObject->validFlags != 0))
                {
                    return TRUE;
                }
            }
        }
        return FALSE;
    }

    ARGB
    GetColorKeyLow(
        ColorAdjustType     type
        ) const
    {
        ARGB                argb          = 0;
        GpRecolorObject *   recolorObject = UseRecolorObject(type);

        if (recolorObject != NULL)
        {
            argb = recolorObject->colorKeyLow.GetValue();
        }
        return argb;
    }

    ARGB
    GetColorKeyHigh(
        ColorAdjustType     type
        ) const
    {
        ARGB                argb          = 0;
        GpRecolorObject *   recolorObject = UseRecolorObject(type);

        if (recolorObject != NULL)
        {
            argb = recolorObject->colorKeyHigh.GetValue();
        }
        return argb;
    }

    ColorChannelFlags
    GetChannelIndex(
        ColorAdjustType     type
        ) const
    {
        ColorChannelFlags   channelIndex  = ColorChannelFlagsC;
        GpRecolorObject *   recolorObject = UseRecolorObject(type);

        if (recolorObject != NULL)
        {
            channelIndex = recolorObject->ChannelIndex;
        }
        return channelIndex;
    }

    // Flush all the recolor objects.
    VOID Flush()
    {
        INT     type;
        
        for (type = ColorAdjustTypeDefault; type < ColorAdjustTypeCount; type++)
        {
            if ((RecolorObject[type] != NULL) &&
                ((type == ColorAdjustTypeDefault) || 
                 (RecolorObject[type] != RecolorObject[ColorAdjustTypeDefault])))
            {
                RecolorObject[type]->Flush();
            }
        }
    }

    HRESULT
    SetColorMatrices(
        ColorAdjustType type,
        ColorMatrix *colorMatrix,
        ColorMatrix *grayMatrix,
        ColorMatrixFlags flags = ColorMatrixFlagsDefault
        )
    {
        if (colorMatrix || grayMatrix)
        {
            GpRecolorObject *   recolorObject = SetRecolorObject(type);

            if (recolorObject != NULL)
            {
                return recolorObject->SetColorMatrices(colorMatrix,
                                                       grayMatrix,
                                                       flags);
            }
        }
        return E_FAIL;
    }

    HRESULT ClearColorMatrices(
        ColorAdjustType type
        )
    {
        GpRecolorObject *   recolorObject = ClearRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            recolorObject->ClearColorMatrices();
        }
        return S_OK;    // nothing to clear if recolorObject is NULL
    }

    HRESULT SetThreshold(
        ColorAdjustType type,
        REAL threshold
        )
    {
        GpRecolorObject *   recolorObject = SetRecolorObject(type);

        if (recolorObject != NULL)
        {
            return recolorObject->SetThreshold(threshold);
        }
        return E_FAIL;
    }

    HRESULT ClearThreshold(
        ColorAdjustType type
        )
    {
        GpRecolorObject *   recolorObject = ClearRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            recolorObject->ClearThreshold();
        }
        return S_OK;    // nothing to clear if recolorObject is NULL
    }

    HRESULT SetGamma(
        ColorAdjustType type,
        REAL gamma
        )
    {
        GpRecolorObject *   recolorObject = SetRecolorObject(type);

        if (recolorObject != NULL)
        {
            return recolorObject->SetGamma(gamma);
        }
        return E_FAIL;
    }

    HRESULT ClearGamma(
        ColorAdjustType type
        )
    {
        GpRecolorObject *   recolorObject = ClearRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            recolorObject->ClearGamma();
        }
        return S_OK;    // nothing to clear if recolorObject is NULL
    }

    HRESULT SetNoOp(
        ColorAdjustType type
        )
    {
        GpRecolorObject *   recolorObject = SetRecolorObject(type);

        if (recolorObject != NULL)
        {
            return recolorObject->SetNoOp();
        }
        return E_FAIL;
    }

    HRESULT ClearNoOp(
        ColorAdjustType type
        )
    {
        GpRecolorObject *   recolorObject = ClearRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            recolorObject->ClearNoOp();
        }
        return S_OK;    // nothing to clear if recolorObject is NULL
    }

    HRESULT SetColorKey(
        ColorAdjustType type,
        Color* colorLow, 
        Color* colorHigh
        )
    {
        if (colorLow && colorHigh &&
            (colorLow->GetRed()   <= colorHigh->GetRed()  ) &&
            (colorLow->GetGreen() <= colorHigh->GetGreen()) &&
            (colorLow->GetBlue()  <= colorHigh->GetBlue() ))
        {
            GpRecolorObject *   recolorObject = SetRecolorObject(type);

            if (recolorObject != NULL)
            {
                return recolorObject->SetColorKey(colorLow, colorHigh);
            }
        }
        return E_FAIL;
    }

    HRESULT ClearColorKey(
        ColorAdjustType type
        )
    {
        GpRecolorObject *   recolorObject = ClearRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            recolorObject->ClearColorKey();
        }
        return S_OK;    // nothing to clear if recolorObject is NULL
    }

    HRESULT SetOutputChannel(
        ColorAdjustType type,
        ColorChannelFlags channelFlags
        )
    {
        if ( (channelFlags >= ColorChannelFlagsC)
           &&(channelFlags < ColorChannelFlagsLast) )
        {
            GpRecolorObject *   recolorObject = SetRecolorObject(type);

            if (recolorObject != NULL)
            {
                return recolorObject->SetOutputChannel(channelFlags);
            }
        }
        return E_FAIL;
    }
    
    HRESULT ClearOutputChannel(
        ColorAdjustType type
        )
    {
        GpRecolorObject *   recolorObject = ClearRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            recolorObject->ClearOutputChannel();
        }
        return S_OK;    // nothing to clear if recolorObject is NULL
    }

    HRESULT SetOutputChannelProfile(
        ColorAdjustType type,
        WCHAR *profile
        )
    {
        if (profile)
        {
            GpRecolorObject *   recolorObject = SetRecolorObject(type);

            if (recolorObject != NULL)
            {
                return recolorObject->SetOutputChannelProfile(profile);
            }
        }
        return E_FAIL;
    }
    
    HRESULT ClearOutputChannelProfile(
        ColorAdjustType type
        )
    {
        GpRecolorObject *   recolorObject = ClearRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            recolorObject->ClearOutputChannelProfile();
        }
        return S_OK;    // nothing to clear if recolorObject is NULL
    }

    HRESULT SetRemapTable(
        ColorAdjustType type,
        UINT mapSize, 
        ColorMap *map
        )
    {
        if (mapSize && map)
        {
            GpRecolorObject *   recolorObject = SetRecolorObject(type);

            if (recolorObject != NULL)
            {
                return recolorObject->SetRemapTable(mapSize, map);
            }
        }
        return E_FAIL;
    }

    HRESULT ClearRemapTable(
        ColorAdjustType type
        )
    {
        GpRecolorObject *   recolorObject = ClearRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            recolorObject->ClearRemapTable();
        }
        return S_OK;    // nothing to clear if recolorObject is NULL
    }

protected:
    BOOL ValidColorAdjustType(ColorAdjustType type) const
    {
        return ((type > ColorAdjustTypeDefault) && (type < ColorAdjustTypeCount));
    }

    // Get a recolor object for doing a color adjustment; if NULL, use default
    GpRecolorObject *
    UseRecolorObject(
        ColorAdjustType     type
        ) const
    {
        GpRecolorObject *   recolorObject = NULL;

        if (ValidColorAdjustType(type))
        {
            recolorObject = RecolorObject[type];

            if ((recolorObject == NULL) && (!IsIdentity[type]))
            {
                recolorObject = RecolorObject[ColorAdjustTypeDefault];
            }
        }
        return recolorObject;
    }

    // Get a recolor object to clear; if there isn't one, then nothing to clear
    GpRecolorObject *
    ClearRecolorObject(
        ColorAdjustType     type
        ) const
    {
        if ((type == ColorAdjustTypeDefault) || ValidColorAdjustType(type))
        {
            return RecolorObject[type];
        }
        return NULL;
    }

    // Get a recolor object to set; if there isn't one, create one
    GpRecolorObject *
    SetRecolorObject(
        ColorAdjustType     type
        )
    {
        GpRecolorObject *   recolorObject = NULL;
        
        if ((type == ColorAdjustTypeDefault) || ValidColorAdjustType(type))
        {
            recolorObject = RecolorObject[type];

            if (recolorObject == NULL)
            {
                recolorObject = new GpRecolorObject();
                RecolorObject[type] = recolorObject;
                if (recolorObject != NULL)
                {
                    IsIdentity[type] = FALSE;
                }
            }
        }
        return recolorObject;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\resample.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   resample.hpp
*
* Abstract:
*
*   Bitmap scaler declarations 
*
* Revision History:
*
*   06/01/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _RESAMPLE_HPP
#define _RESAMPLE_HPP


class GpBitmapScaler : public IUnknownBase<IImageSink>
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagBitmapScaler : ObjectTagInvalid;
    }

public:

    // Constructor / destructor

    GpBitmapScaler(
        IImageSink* dstsink,
        UINT dstwidth,
        UINT dstheight,
        InterpolationHint interp = InterpolationHintDefault
        );

    ~GpBitmapScaler();

    // Begin the sink process

    STDMETHOD(BeginSink)(
        IN OUT ImageInfo* imageInfo,
        OUT OPTIONAL RECT* subarea
        );

    // End the sink process

    STDMETHOD(EndSink)(
        IN HRESULT statusCode
        );

    // Pass the color palette to the image sink

    STDMETHOD(SetPalette)(
        IN const ColorPalette* palette
        );

    // Ask the sink to allocate pixel data buffer

    STDMETHOD(GetPixelDataBuffer)(
        IN const RECT* rect,
        IN PixelFormatID pixelFormat,
        IN BOOL lastPass,
        OUT BitmapData* bitmapData
        );

    // Give the sink pixel data and release data buffer

    STDMETHOD(ReleasePixelDataBuffer)(
        IN const BitmapData* bitmapData
        );

    // Push pixel data

    STDMETHOD(PushPixelData)(
        IN const RECT* rect,
        IN const BitmapData* bitmapData,
        IN BOOL lastPass
        );

    // Push raw image data

    STDMETHOD(PushRawData)(
        IN const VOID* buffer,
        IN UINT bufsize
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(NeedTransform)(
        OUT UINT* rotation
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(NeedRawProperty)(void *pSRc)
    {
        // GpBitmapScaler can't handle raw property

        return E_FAIL;
    }
    
    STDMETHOD(PushRawInfo)(
        IN OUT void* info
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(GetPropertyBuffer)(
        IN     UINT            uiTotalBufferSize,
        IN OUT PropertyItem**  ppBuffer
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(PushPropertyItems)(
        IN UINT             numOfItems,
        IN UINT             uiTotalBufferSize,
        IN PropertyItem*    item,
        IN BOOL             fICCProfileChanged
        )
    {
        return E_NOTIMPL;
    }

private:

    typedef HRESULT (GpBitmapScaler::*YSCALEPROC)(const ARGB*);
    typedef VOID (GpBitmapScaler::*XSCALEPROC)(ARGB*, const ARGB*);

    typedef struct 
    {
        INT current;
        INT expected;
        ARGB* buf;
    } TEMPLINEINFO;


    IImageSink* dstSink;
    INT dstWidth, dstHeight, dstBand;
    InterpolationHint interpX, interpY;
    PixelFormatID pixelFormat;
    INT srcWidth, srcHeight;
    ARGB* tempSrcBuf;
    INT tempSrcLines;
    ARGB* tempDstBuf;
    INT tempDstSize;
    DWORD* accbufy;
    YSCALEPROC pushSrcLineProc;
    XSCALEPROC xscaleProc;
    INT ystep, srcy, dsty;
    FIX16 yratio, xratio, ystepFrac;
    FIX16 invyratio, invxratio;
    TEMPLINEINFO tempLines[4];
    INT srcPadding;
    BitmapData cachedDstData;
    INT cachedDstCnt, cachedDstRemaining;
    BYTE* cachedDstNext;
    bool m_fNeedToPremultiply;

    // Check if the scaler object is in a valid state

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagBitmapScaler) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid BitmapScaler");
        }
    #endif

        return (Tag == ObjectTagBitmapScaler);
    }

    // Push one source scanline into the bitmap scaler sink

    HRESULT PushSrcLineNearestNeighbor(const ARGB* s);
    HRESULT PushSrcLineBilinear(const ARGB* s);
    HRESULT PushSrcLineAveraging(const ARGB* s);
    HRESULT PushSrcLineBicubic(const ARGB* s);

    // Scale one scanine

    VOID ScaleLineNearestNeighbor(ARGB* d, const ARGB* s);
    VOID ScaleLineBilinear(ARGB* d, const ARGB* s);
    VOID ScaleLineAveraging(ARGB* d, const ARGB* s);
    VOID ScaleLineBicubic(ARGB* d, const ARGB* s);

    // Get buffer for next destination band

    HRESULT GetNextDstBand();
    HRESULT FlushDstBand();

    // Allocate temporary memory for holding source pixel data

    ARGB* AllocTempSrcBuffer(INT lines);
    HRESULT AllocTempDstBuffer(INT size);

    // Initialize internal states of the scaler object

    HRESULT InitScalerState();
    HRESULT InitBilinearY();
    VOID UpdateExpectedTempLinesBilinear(INT line);
    BOOL UpdateExpectedTempLinesBicubic(INT line);

    // Cubic interpolation table

    enum
    {
        BICUBIC_SHIFT = 6,
        BICUBIC_STEPS = 1 << BICUBIC_SHIFT
    };

    static const FIX16 cubicCoeffTable[2*BICUBIC_STEPS+1];
};

#endif // !_RESAMPLE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\bmp\bmpcodec.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   bmpcodec.hpp
*
* Abstract:
*
*   Header file for the bitmap encoder/decoder
*
* Revision History:
*
*   5/13/1999 OriG (Ori Gershony)
*       Created it.
*
*   2/7/2000  OriG (Ori Gershony)
*       Move encoder and decoder into separate classes
*
\**************************************************************************/

#include "bmpdecoder.hpp"
#include "bmpencoder.hpp"

class GpBmpCodec : public GpBmpDecoder, public GpBmpEncoder
{
protected:
    LONG comRefCount;       // COM object reference count    

public:

    // Constructor and Destructor
    
    GpBmpCodec::GpBmpCodec(void);
    GpBmpCodec::~GpBmpCodec(void);

    // IUnknown methods

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\bmp\bmpcodec.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   bmpcodec.cpp
*
* Abstract:
*
*   Shared methods for the bitmap codec
*
* Revision History:
*
*   5/10/1999 OriG
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "bmpcodec.hpp"


/**************************************************************************\
*
* Function Description:
*
*     Constructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpBmpCodec::GpBmpCodec(
    void
    )
{
    comRefCount   = 1;
}

/**************************************************************************\
*
* Function Description:
*
*     Destructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpBmpCodec::~GpBmpCodec(
    void
    )
{
}

/**************************************************************************\
*
* Function Description:
*
*     QueryInterface
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP
GpBmpCodec::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IImageDecoder)
    {
        *ppv = static_cast<IImageDecoder*>(this);
    }
    else if (riid == IID_IImageEncoder)
    {    
        *ppv = static_cast<IImageEncoder*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageDecoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     AddRef
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpBmpCodec::AddRef(
    VOID)
{
    return InterlockedIncrement(&comRefCount);
}

/**************************************************************************\
*
* Function Description:
*
*     Release
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpBmpCodec::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&comRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\api\resample.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   resample.cpp
*
* Abstract:
*
*   Bitamp scaler implementation
*
* Revision History:
*
*   06/01/1999 davidx
*       Created it.
*
* Notes:
*
*   We assume the pixels are on integer coordinates and
*   pixel area is centered around it. To scale a scanline
*   of s pixels to d pixels, we have the following equations:
*          x     |   y
*       -----------------
*         -0.5   |  -0.5
*        s - 0.5 | d - 0.5
*
*       y + 0.5   x + 0.5
*       ------- = -------
*         d         s
*
*   Forward mapping from source to destination coordinates:
*
*           d            d-s
*       y = - x + 0.5 * -----
*           s             s
*
*   Inverse mapping from destination to source coordinates:
*   
*           s            s-d
*       x = - y + 0.5 * -----
*           d             d
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   GpBitmapScaler constructor / destructor
*
* Arguments:
*
*   dstsink - Destination sink for the scaler
*   dstwidth, dstheight - Destination dimension
*   interp - Interpolation method
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

GpBitmapScaler::GpBitmapScaler(
    IImageSink* dstsink,
    UINT dstwidth,
    UINT dstheight,
    InterpolationHint interp
    )
{
    this->dstSink = dstsink;
    dstsink->AddRef();

    this->dstWidth = dstwidth;
    this->dstHeight = dstheight;

    // Default to bilinear interpolation

    if (interp < INTERP_NEAREST_NEIGHBOR || interp > INTERP_BICUBIC)
        interp = INTERP_BILINEAR;

    interpX = interpY = interp;

    dstBand = OSInfo::VAllocChunk / dstWidth;

    if (dstBand < 4)
        dstBand = 4;

    cachedDstCnt = cachedDstRemaining = 0;
    cachedDstNext = NULL;
    tempSrcBuf = tempDstBuf = NULL;
    tempSrcLines = tempDstSize = 0;
    m_fNeedToPremultiply = false;

    SetValid(FALSE);
}

GpBitmapScaler::~GpBitmapScaler()
{
    ASSERT(cachedDstCnt == 0);

    dstSink->Release();
    if (NULL != tempSrcBuf)
    {
        GpFree(tempSrcBuf);
    }
    if (NULL != tempDstBuf)
    {
        GpFree(tempDstBuf);
    }

    SetValid(FALSE);    // so we don't use a deleted object
}


/**************************************************************************\
*
* Function Description:
*
*   Begin sinking source image data into the bitmap scaler
*
* Arguments:
*
*   imageInfo - For negotiating data transfer parameters with the source
*   subarea - For returning subarea information
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::BeginSink(
    IN OUT ImageInfo* imageInfo,
    OUT OPTIONAL RECT* subarea
    )
{
    ImageInfo tempinfo;
    HRESULT hr;

    // Whistler Bug 191203 - For scaling results to be correct you need to
    // do it in pre-multiplied space. Our scaler only works on 32 BPP data,
    // but didn't care about whether or not it was pre-multiplied.
    //
    // KLUDGE ALERT!
    // All of the V1 codecs will produce ARGB data (not pre-multiplied).
    // So we will fool the code, by saying it is PARGB, and we will do the
    // the premultiplying step right before we push the data into the scaler.
    // The exception to this is RGB formats that have no alpha as they are
    // pre-multiplied by default.
    //
    // In V2 we should address this problem properly. - JBronsk
    //
    // Note: We don't have CMYK as a color format. But if an image is in
    // CMYK color space and it contains an ICM color profile for CMYK to RGB
    // conversion, the lower level codec will return the data in its native
    // format, that is CMYK, while it still claims it is ARGB. In this case,
    // we CANNOT do premultiply since the channels are really CMYK not ARGB.
    // But there is one kind of CMYK JPEG which will set IMGFLAG_COLORSPACE_CMYK
    // and it is still in 24 RGB mode.
    // So: !(  ((imageInfo->Flags & IMGFLAG_COLORSPACE_CMYK)
    //      ==IMGFLAG_COLORSPACE_CMYK)&&(GetPixelFormatSize(pixelFormat) == 32))
    // means if the source image format is CMYK and its pixel size is 32, then
    // we don't need to do a pre-multiply. See Windows bug# 412605
    // Here we have another not perfect case, that is, if the source image is
    // in CMYK space. But it doesn't have ICM profile. So the lower level codec
    // will convert it to RGB and fill the alpha bits as ff. It returns the
    // format as ARGB. Though we might miss the following premultiply case, it
    // is OK since premultiply doesn't have any effect for alpha = 0xff.

    pixelFormat = imageInfo->PixelFormat;
    if ((pixelFormat != PIXFMT_32BPP_RGB) && // if not 32 BPP and pre-multipled
	    (pixelFormat != PIXFMT_32BPP_PARGB) &&
        (!(((imageInfo->Flags & IMGFLAG_COLORSPACE_CMYK)==IMGFLAG_COLORSPACE_CMYK)&&
           (GetPixelFormatSize(pixelFormat) == 32))) )
    {
	    if ((pixelFormat != PixelFormat16bppRGB555) &&
		    (pixelFormat != PixelFormat16bppRGB565) &&
		    (pixelFormat != PixelFormat48bppRGB) &&
		    (pixelFormat != PixelFormat24bppRGB))
	    {
		    m_fNeedToPremultiply = true; // pre-multiply if required
	    }
	    pixelFormat = PIXFMT_32BPP_PARGB; // set format to pre-multiplied
    }

    srcWidth = imageInfo->Width;
    srcHeight = imageInfo->Height;

    BOOL partialScaling;
    
    partialScaling = (imageInfo->Flags & SINKFLAG_PARTIALLY_SCALABLE) &&
                     (imageInfo->Width != (UINT) dstWidth ||
                      imageInfo->Height != (UINT) dstHeight);

    if (partialScaling)
    {
        imageInfo->Width = dstWidth;
        imageInfo->Height = dstHeight;
    }
    else
    {
        imageInfo->Flags &= ~SINKFLAG_PARTIALLY_SCALABLE;

        tempinfo.RawDataFormat = IMGFMT_MEMORYBMP;
        tempinfo.PixelFormat = pixelFormat;
        tempinfo.Width = dstWidth;
        tempinfo.Height = dstHeight;
        tempinfo.Xdpi = imageInfo->Xdpi * dstWidth / srcWidth;
        tempinfo.Ydpi = imageInfo->Ydpi * dstHeight / srcHeight;
        tempinfo.TileWidth = dstWidth;
        tempinfo.TileHeight = dstBand;

        tempinfo.Flags = SINKFLAG_TOPDOWN | 
                         SINKFLAG_FULLWIDTH |
                         (imageInfo->Flags & SINKFLAG_HASALPHA);

        // Negotiate with the destination sink

        hr = dstSink->BeginSink(&tempinfo, NULL);

        if (FAILED(hr))
            return hr;
        
        dstBand = tempinfo.TileHeight;

        if (tempinfo.Flags & SINKFLAG_WANTPROPS)
            imageInfo->Flags |= SINKFLAG_WANTPROPS;

        // We expect the destination sink to support 32bpp ARGB

        pixelFormat = tempinfo.PixelFormat;
        ASSERT(GetPixelFormatSize(pixelFormat) == 32);
    }

    imageInfo->PixelFormat = pixelFormat;
    imageInfo->RawDataFormat = IMGFMT_MEMORYBMP;

    imageInfo->Flags = (imageInfo->Flags & 0xffff) |
                        SINKFLAG_TOPDOWN |
                        SINKFLAG_FULLWIDTH;

    if (subarea)
    {
        subarea->left = subarea->top = 0;
        subarea->right = imageInfo->Width;
        subarea->bottom = imageInfo->Height;
    }

    // Initialize internal states of the scaler object

    return partialScaling ? S_OK : InitScalerState();
}


/**************************************************************************\
*
* Function Description:
*
*   Initialize internal states of the scaler object
*     This should be called before each pass.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::InitScalerState()
{
    // Common initialization by all interpolation algorithms

    srcy = dsty = 0;
    xratio = (FIX16) ((double) srcWidth * FIX16_ONE / dstWidth);
    yratio = (FIX16) ((double) srcHeight * FIX16_ONE / dstHeight);
    invxratio = (FIX16) ((double) dstWidth * FIX16_ONE / srcWidth);
    invyratio = (FIX16) ((double) dstHeight * FIX16_ONE / srcHeight);

    // NOTE:
    // If source and destination dimensions are within
    // +/- 2% of each other, we'll just fall back to
    // nearest neighbor interpolation algorithm.

    if (abs(FIX16_ONE - xratio) <= FIX16_ONE/50)
        interpX = INTERP_NEAREST_NEIGHBOR;
    
    if (abs(FIX16_ONE - yratio) <= FIX16_ONE/50)
        interpY = INTERP_NEAREST_NEIGHBOR;

    // Algorithm specific initialization

    HRESULT hr;

    srcPadding = 4;

    switch (interpX)
    {
    case INTERP_BILINEAR:
        xscaleProc = ScaleLineBilinear;
        break;

    case INTERP_AVERAGING:

        // If scaling up in x-direction,
        //  substitute with bilinear interpolation

        if (dstWidth >= srcWidth)
            xscaleProc = ScaleLineBilinear;
        else
        {
            xscaleProc = ScaleLineAveraging;
            srcPadding = 0;
        }
        break;

    case INTERP_BICUBIC:
        xscaleProc = ScaleLineBicubic;
        break;

    default:
        srcPadding = 0;
        xscaleProc = ScaleLineNearestNeighbor;
        break;
    }

    switch (interpY)
    {
    case INTERP_BILINEAR:

        hr = InitBilinearY();
        break;

    case INTERP_AVERAGING:

        if (dstHeight >= srcHeight)
        {
            // Scaling up in y-direction
            //  substitute with bilinear interpolation

            hr = InitBilinearY();
        }
        else
        {
            // Scaling down in y-direction
            //  use averaging algorithm

            pushSrcLineProc = PushSrcLineAveraging;
            ystepFrac = yratio;

            // Allocate space for temporary accumulator buffer
            //  we use one 32-bit integer for each color component

            UINT size1 = ALIGN4(dstWidth * sizeof(ARGB));
            UINT size2 = 4*dstWidth*sizeof(DWORD);

            hr = AllocTempDstBuffer(size1+size2);
            
            if (SUCCEEDED(hr))
            {
                accbufy = (DWORD*) ((BYTE*) tempDstBuf + size1);
                memset(accbufy, 0, size2);
            }
        }
        break;

    case INTERP_BICUBIC:

        pushSrcLineProc = PushSrcLineBicubic;
        hr = AllocTempDstBuffer(4*dstWidth*sizeof(ARGB));

        if (SUCCEEDED(hr))
        {
            tempLines[0].buf = tempDstBuf;
            tempLines[1].buf = tempLines[0].buf + dstWidth;
            tempLines[2].buf = tempLines[1].buf + dstWidth;
            tempLines[3].buf = tempLines[2].buf + dstWidth;
            tempLines[0].current =
            tempLines[1].current =
            tempLines[2].current =
            tempLines[3].current = -1;

            ystepFrac = (yratio - FIX16_ONE) >> 1;
            ystep = ystepFrac >> FIX16_SHIFT;
            ystepFrac &= FIX16_MASK;
            UpdateExpectedTempLinesBicubic(ystep);
        }
        break;

    default:

        pushSrcLineProc = PushSrcLineNearestNeighbor;
        ystep = srcHeight >> 1;
        hr = AllocTempDstBuffer(dstWidth*sizeof(ARGB));
        break;
    }

    SetValid(SUCCEEDED(hr));
    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Allocate temporary memory buffer for holding destination scanlines
*
* Arguments:
*
*   size - Desired of the temporary destination buffer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::AllocTempDstBuffer(
    INT size
    )
{
    if (size > tempDstSize)
    {
        if ( NULL != tempDstBuf )
        {
            GpFree(tempDstBuf);
        }

        tempDstBuf = (ARGB*) GpMalloc(size);
        tempDstSize = tempDstBuf ? size : 0;
    }

    return tempDstBuf ? S_OK : E_OUTOFMEMORY;
}


/**************************************************************************\
*
* Function Description:
*
*   End the sink process
*
* Arguments:
*
*   statusCode - Last status code
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::EndSink(
    HRESULT statusCode
    )
{
    HRESULT hr = FlushDstBand();

    if (FAILED(hr))
        statusCode = hr;

    return dstSink->EndSink(statusCode);
}


/**************************************************************************\
*
* Function Description:
*
*   Ask the sink to allocate pixel data buffer
*
* Arguments:
*
*   rect - Specifies the interested area of the bitmap
*   pixelFormat - Specifies the desired pixel format
*   lastPass - Whether this the last pass over the specified area
*   bitmapData - Returns information about pixel data buffer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::GetPixelDataBuffer(
    IN const RECT* rect,
    IN PixelFormatID pixelFormat,
    IN BOOL lastPass,
    OUT BitmapData* bitmapData
    )
{
    // We only accept bitmap data in top-down banding order

    ASSERT(IsValid());
    ASSERT(rect->left == 0 && rect->right == srcWidth);
    ASSERT(rect->top < rect->bottom && rect->bottom <= srcHeight);
    ASSERT(srcy == rect->top);
    ASSERT(lastPass);

    // Allocate memory for holding source pixel data

    bitmapData->Width = srcWidth;
    bitmapData->Height = rect->bottom - rect->top;
    bitmapData->Reserved = 0;
    bitmapData->PixelFormat = this->pixelFormat;

    // NOTE: we pad two extra pixels on each end of the scanline

    bitmapData->Stride = (srcWidth + 4) * sizeof(ARGB);
    bitmapData->Scan0 = AllocTempSrcBuffer(bitmapData->Height);

    return bitmapData->Scan0 ? S_OK: E_OUTOFMEMORY;
}


/**************************************************************************\
*
* Function Description:
*
*   Give the sink pixel data and release data buffer
*
* Arguments:
*
*   bitmapData - Buffer filled by previous GetPixelDataBuffer call
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::ReleasePixelDataBuffer(
    IN const BitmapData* bitmapData
    )
{
    HRESULT hr;
    INT count = bitmapData->Height;
    ARGB* p = (ARGB*) bitmapData->Scan0;

    while (count--)
    {
 	    if (m_fNeedToPremultiply)
	    {
		    for (UINT i = 0; i < bitmapData->Width; i++)
		    {
			    p[i] = Premultiply(p[i]);
		    }
	    }

        if (srcPadding)
        {
            p[-2] = p[-1] = p[0];
            p[srcWidth] = p[srcWidth+1] = p[srcWidth-1];
        }

        hr = (this->*pushSrcLineProc)(p);
        srcy++;

        if (FAILED(hr))
            return hr;

        p = (ARGB*) ((BYTE*) p + bitmapData->Stride);
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Push pixel data into the bitmap scaler
*
* Arguments:
*
*   rect - Specifies the affected area of the bitmap
*   bitmapData - Info about the pixel data being pushed
*   lastPass - Whether this is the last pass over the specified area
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::PushPixelData(
    IN const RECT* rect,
    IN const BitmapData* bitmapData,
    IN BOOL lastPass
    )
{
    // We only accept bitmap data in top-down banding order

    ASSERT(IsValid());
    ASSERT(rect->left == 0 && rect->right == srcWidth);
    ASSERT(rect->top < rect->bottom && rect->bottom <= srcHeight);
    ASSERT(srcy == rect->top);
    ASSERT(lastPass);
    ASSERT(rect->right - rect->left == (INT) bitmapData->Width &&
           rect->bottom - rect->top == (INT) bitmapData->Height);

    HRESULT hr = S_OK;
    INT count = bitmapData->Height;
    ARGB* p = (ARGB*) bitmapData->Scan0;

    if (srcPadding == 0)
    {
        // If we don't need to pad source scanlines,
        // then we can use the source pixel data buffer directly

        while (count--)
        {
            if (m_fNeedToPremultiply)
            {
	            for (UINT i = 0; i < bitmapData->Width; i++)
	            {
		            p[i] = Premultiply(p[i]);
	            }
            }

            hr = (this->*pushSrcLineProc)(p);
            srcy++;

            if (FAILED(hr))
                break;

            p = (ARGB*) ((BYTE*) p + bitmapData->Stride);
        }
    }
    else
    {
        // Otherwise, we need to copy source pixel data into
        // a temporary buffer one scanline at a time.

        ARGB* buf = AllocTempSrcBuffer(1);

        if (buf == NULL)
            return E_OUTOFMEMORY;

        while (count--)
        {
            if (m_fNeedToPremultiply)
            {
	            for (UINT i = 0; i < bitmapData->Width; i++)
	            {
		            p[i] = Premultiply(p[i]);
	            }
            }

            ARGB* s = p;
            ARGB* d = buf;
            INT x = srcWidth;

            d[-2] = d[-1] = *s;

            while (x--)
                *d++ = *s++;

            d[0] = d[1] = s[-1];

            hr = (this->*pushSrcLineProc)(buf);
            srcy++;

            if (FAILED(hr))
                break;

            p = (ARGB*) ((BYTE*) p + bitmapData->Stride);
        }
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Pass color palette to an image sink
*
* Arguments:
*
*   palette - Pointer to the color palette to be set
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::SetPalette(
    IN const ColorPalette* palette
    )
{
    // We don't have anything to do with color palettes.
    // Just pass it down stream to the destination sink.

    return dstSink->SetPalette(palette);
}


/**************************************************************************\
*
* Function Description:
*
*   Allocate temporary memory for holding source pixel data
*
* Arguments:
*
*   lines - How many source scanlines are needed
*
* Return Value:
*
*   Pointer to the temporary source buffer
*   NULL if there is an error
*
\**************************************************************************/

ARGB*
GpBitmapScaler::AllocTempSrcBuffer(
    INT lines
    )
{
    // NOTE: We leave two extra pixels at each end of the scanline

    if (lines > tempSrcLines)
    {
        if ( NULL != tempSrcBuf )
        {
            GpFree(tempSrcBuf);
        }
        tempSrcBuf = (ARGB*) GpMalloc((srcWidth + 4) * lines * sizeof(ARGB));

        if (!tempSrcBuf)
            return NULL;

        tempSrcLines = lines;
    }

    return tempSrcBuf + 2;
}


/**************************************************************************\
*
* Function Description:
*
*   Push a source scanline into the bitmap scaler
*       using nearest neighbor interpolation algorithm
*
* Arguments:
*
*   s - Pointer to source scanline pixel values
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

#define GETNEXTDSTLINE(d)                           \
        {                                           \
            if (cachedDstRemaining == 0)            \
            {                                       \
                hr = GetNextDstBand();              \
                if (FAILED(hr)) return hr;          \
            }                                       \
            cachedDstRemaining--;                   \
            d = (ARGB*) cachedDstNext;              \
            cachedDstNext += cachedDstData.Stride;  \
            dsty++;                                 \
        }
    
HRESULT
GpBitmapScaler::PushSrcLineNearestNeighbor(
    const ARGB* s
    )
{
    ystep += dstHeight;

    if (ystep < srcHeight)
        return S_OK;

    INT lines = ystep / srcHeight;
    ystep %= srcHeight;

    // Ask for pixel data buffer from the destination sink

    ARGB* d;
    HRESULT hr;
    
    GETNEXTDSTLINE(d);

    // Scale the source line

    (this->*xscaleProc)(d, s);

    // Replicate the scaled line, if necessary

    ARGB* p;

    if (cachedDstRemaining < --lines)
    {
        CopyMemoryARGB(tempDstBuf, d, dstWidth);
        p = tempDstBuf;
    }
    else
        p = d;

    while (lines--)
    {
        GETNEXTDSTLINE(d);
        CopyMemoryARGB(d, p, dstWidth);
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Scale one scanline using nearest neighbor interpolation algorithm
*
* Arguments:
*
*   d - Points to destination pixel buffer
*   s - Points to source pixel values
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpBitmapScaler::ScaleLineNearestNeighbor(
    ARGB* d,
    const ARGB* s
    )
{
    INT xstep = srcWidth >> 1;
    INT cx = srcWidth;

    while (cx--)
    {
        xstep += dstWidth;

        while (xstep >= srcWidth)
        {
            xstep -= srcWidth;
            *d++ = *s;
        }

        *s++;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Push a source scanline into the bitmap scaler
*       using bilinear interpolation algorithm
*
* Arguments:
*
*   s - Pointer to source scanline pixel values
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::PushSrcLineBilinear(
    const ARGB* s
    )
{
    // Check if the current source line is useful

    if (srcy == tempLines[0].expected)
    {
        (this->*xscaleProc)(tempLines[0].buf, s);
        tempLines[0].current = srcy;
    }

    if (srcy == tempLines[1].expected)
    {
        (this->*xscaleProc)(tempLines[1].buf, s);
        tempLines[1].current = srcy;
    }

    // Emit destination scanline, if any

    while (dsty < dstHeight &&
           tempLines[1].current != -1 &&
           tempLines[0].current != -1)
    {

        // Ask for pixel data buffer from the destination sink

        ARGB* d;
        HRESULT hr;
        
        GETNEXTDSTLINE(d);

        // Linearly interpolate between two neighboring scanlines

        ARGB* s0 = tempLines[0].buf;
        ARGB* s1 = tempLines[1].buf;

        UINT w1 = ystepFrac >> 8;
        UINT w0 = 256 - w1;
        INT count = dstWidth;

        if (w1 == 0)
        {
            // Fast path: no interpolation necessary

            CopyMemoryARGB(d, s0, count);
        }

        #ifdef _X86_

        else if (OSInfo::HasMMX)
        {
            MMXBilinearScale(d, s0, s1, w0, w1, count);
        }

        #endif // _X86_

        else
        {
            // Normal case: interpolate two neighboring lines

            while (count--)
            {
                ARGB A00aa00gg, A00rr00bb;

                A00aa00gg = *s0++;
                A00rr00bb = A00aa00gg & 0x00ff00ff;
                A00aa00gg = (A00aa00gg >> 8) & 0x00ff00ff;

                ARGB B00aa00gg, B00rr00bb;

                B00aa00gg = *s1++;
                B00rr00bb = B00aa00gg & 0x00ff00ff;
                B00aa00gg = (B00aa00gg >> 8) & 0x00ff00ff;

                ARGB Caaaagggg, Crrrrbbbb;

                Caaaagggg = (A00aa00gg * w0 + B00aa00gg * w1);
                Crrrrbbbb = (A00rr00bb * w0 + B00rr00bb * w1) >> 8;

                *d++ = (Caaaagggg & 0xff00ff00) |
                       (Crrrrbbbb & 0x00ff00ff);
            }
        }

        // Update internal states

        ystepFrac += yratio;
        ystep += (ystepFrac >> FIX16_SHIFT);
        ystepFrac &= FIX16_MASK;
        UpdateExpectedTempLinesBilinear(ystep);
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Initial internal states for bilinear scaling in y-direction
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::InitBilinearY()
{
    pushSrcLineProc = PushSrcLineBilinear;

    HRESULT hr = AllocTempDstBuffer(2*dstWidth*sizeof(ARGB));

    if (SUCCEEDED(hr))
    {
        tempLines[0].buf = tempDstBuf;
        tempLines[1].buf = tempDstBuf + dstWidth;
        tempLines[0].current = 
        tempLines[1].current = -1;

        ystepFrac = (yratio - FIX16_ONE) >> 1;
        ystep = ystepFrac >> FIX16_SHIFT;
        ystepFrac &= FIX16_MASK;
        UpdateExpectedTempLinesBilinear(ystep);
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Update the expected source line information for 
*   the y-direction of bilinear scaling
*
* Arguments:
*
*   line - The index of the active scanline
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpBitmapScaler::UpdateExpectedTempLinesBilinear(
    INT line
    )
{
    // Clamp to within range

    INT ymax = srcHeight-1;
    INT line0 = line < 0 ? 0 : line > ymax ? ymax : line;
    INT line1 = line+1 > ymax ? ymax : line+1;

    // Check if line0 is ready

    ARGB* p;

    if ((tempLines[0].expected = line0) != tempLines[0].current)
    {
        if (line0 == tempLines[1].current)
        {
            // switch line1 to line0

            tempLines[1].current = tempLines[0].current;
            tempLines[0].current = line0;

            p = tempLines[0].buf;
            tempLines[0].buf = tempLines[1].buf;
            tempLines[1].buf = p;
        }
        else
            tempLines[0].current = -1;
    }

    // Check if line1 is ready

    if ((tempLines[1].expected = line1) != tempLines[1].current)
    {
        if (line1 == tempLines[0].current)
        {
            // Copy line0 to line1
            //  this could happen at the bottom of the image

            tempLines[1].current = line1;
            CopyMemoryARGB(tempLines[1].buf, tempLines[0].buf, dstWidth);
        }
        else
            tempLines[1].current = -1;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Scale one scanline using bilinear interpolation algorithm
*
* Arguments:
*
*   d - Points to destination pixel buffer
*   s - Points to source pixel values
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpBitmapScaler::ScaleLineBilinear(
    ARGB* d,
    const ARGB* s
    )
{
    ARGB* dend = d + dstWidth;
    INT count = dstWidth;
    FIX16 xstep;

    // Figure out initial sampling position in the source line

    xstep = (xratio - FIX16_ONE) >> 1;
    s += (xstep >> FIX16_SHIFT);
    xstep &= FIX16_MASK;

    // Loop over all destination pixels

    while (count--)
    {
        UINT w1 = xstep >> 8;
        UINT w0 = 256 - w1;

        ARGB A00aa00gg = s[0];
        ARGB A00rr00bb = A00aa00gg & 0x00ff00ff;
        A00aa00gg = (A00aa00gg >> 8) & 0x00ff00ff;

        ARGB B00aa00gg = s[1];
        ARGB B00rr00bb = B00aa00gg & 0x00ff00ff;
        B00aa00gg = (B00aa00gg >> 8) & 0x00ff00ff;

        ARGB Caaaagggg = A00aa00gg * w0 + B00aa00gg * w1;
        ARGB Crrrrbbbb = (A00rr00bb * w0 + B00rr00bb * w1) >> 8;

        *d++ = (Caaaagggg & 0xff00ff00) |
               (Crrrrbbbb & 0x00ff00ff);
        
        // Check if we need to move source pointer

        xstep += xratio;
        s += (xstep >> FIX16_SHIFT);
        xstep &= FIX16_MASK;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Push a source scanline into the bitmap scaler
*       using averaging interpolation algorithm
*
* Arguments:
*
*   s - Pointer to source scanline pixel values
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::PushSrcLineAveraging(
    const ARGB* s
    )
{
    // This is only used for scaling down

    ASSERT(srcHeight >= dstHeight);

    if (dsty >= dstHeight)
        return S_OK;

    // Scale the current line horizontally

    (this->*xscaleProc)(tempDstBuf, s);
    s = tempDstBuf;

    INT count = dstWidth;
    DWORD* acc = accbufy;
    
    const BYTE *kptr = reinterpret_cast<const BYTE*>(s);

    if (ystepFrac > FIX16_ONE)
    {
        // Consume the entire input scanline
        // without emit an output scanline

        while (count--)
        {
            // Consume the entire source pixel
            // without emitting a destination pixel
            acc[0] += (DWORD)(kptr[0]) << FIX16_SHIFT; 
            acc[1] += (DWORD)(kptr[1]) << FIX16_SHIFT; 
            acc[2] += (DWORD)(kptr[2]) << FIX16_SHIFT; 
            acc[3] += (DWORD)(kptr[3]) << FIX16_SHIFT; 
            
            acc += 4;
            kptr += 4;
        }

        ystepFrac -= FIX16_ONE;
    }
    else
    {
        // Emit an output scanline

        ARGB* d;
        HRESULT hr;
        
        GETNEXTDSTLINE(d);
        
        BYTE *dptr = reinterpret_cast<BYTE*>(d);
        BYTE *dend = reinterpret_cast<BYTE*>(d+dstWidth);

        BYTE a, r, g, b;
        DWORD t1, t2;

        while (count--)
        {
            t1 = kptr[0]; 
            t2 = t1 * ystepFrac;
            b = Fix16MulRoundToByte((acc[0] + t2), invyratio);
            acc[0] = (t1 << FIX16_SHIFT) - t2;
            
            t1 = kptr[1]; 
            t2 = t1 * ystepFrac;
            g = Fix16MulRoundToByte((acc[1] + t2), invyratio);
            acc[1] = (t1 << FIX16_SHIFT) - t2;
            
            t1 = kptr[2]; 
            t2 = t1 * ystepFrac;
            r = Fix16MulRoundToByte((acc[2] + t2), invyratio);
            acc[2] = (t1 << FIX16_SHIFT) - t2;
            
            t1 = kptr[3]; 
            t2 = t1 * ystepFrac;
            a = Fix16MulRoundToByte((acc[3] + t2), invyratio);
            acc[3] = (t1 << FIX16_SHIFT) - t2;

            kptr += 4;
            acc += 4;

            dptr[0] = b;
            dptr[1] = g;
            dptr[2] = r;
            dptr[3] = a;
            dptr += 4;
        }

        ystepFrac = yratio - (FIX16_ONE - ystepFrac);
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Scale one scanline using averaging interpolation algorithm
*
* Arguments:
*
*   d - Points to destination pixel buffer
*   s - Points to source pixel values
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpBitmapScaler::ScaleLineAveraging(
    ARGB* d,
    const ARGB* s
    )
{
    DWORD accA, accR, accG, accB;
    DWORD outfrac = xratio;
    const DWORD invx = invxratio;
    
    BYTE *dptr = reinterpret_cast<BYTE*>(d);
    BYTE *dend = reinterpret_cast<BYTE*>(d+dstWidth);
    const BYTE *kptr = reinterpret_cast<const BYTE*>(s);
    accA = accR = accG = accB = 0;

    for (;;)
    {
        if (outfrac > FIX16_ONE)
        {
            // Consume the entire source pixel
            // without emitting a destination pixel
            accB += (DWORD)(kptr[0]) << FIX16_SHIFT; 
            accG += (DWORD)(kptr[1]) << FIX16_SHIFT; 
            accR += (DWORD)(kptr[2]) << FIX16_SHIFT; 
            accA += (DWORD)(kptr[3]) << FIX16_SHIFT; 
            
            outfrac -= FIX16_ONE;
        }
        else
        {
            // Emit an output pixel

            BYTE a, r, g, b;
            DWORD t1, t2;


            t1 = kptr[0]; 
            t2 = t1 * outfrac;
            b = Fix16MulRoundToByte((accB + t2), invx);
            accB = (t1 << FIX16_SHIFT) - t2;
            
            t1 = kptr[1]; 
            t2 = t1 * outfrac;
            g = Fix16MulRoundToByte((accG + t2), invx);
            accG = (t1 << FIX16_SHIFT) - t2;
            
            t1 = kptr[2]; 
            t2 = t1 * outfrac;
            r = Fix16MulRoundToByte((accR + t2), invx);
            accR = (t1 << FIX16_SHIFT) - t2;
            
            t1 = kptr[3];
            t2 = t1 * outfrac;
            a = Fix16MulRoundToByte((accA + t2), invx);
            accA = (t1 << FIX16_SHIFT) - t2;


            dptr[0] = b;
            dptr[1] = g;
            dptr[2] = r;
            dptr[3] = a;
            dptr += 4;
            
            if (dptr == dend)
                break;

            outfrac = xratio - (FIX16_ONE - outfrac);
        }

        // Move on to the next source pixel

        kptr += 4;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Push a source scanline into the bitmap scaler
*       using bicubic interpolation algorithm
*
* Arguments:
*
*   s - Pointer to source scanline pixel values
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

// Cubic interpolation table

const FIX16 GpBitmapScaler::cubicCoeffTable[2*BICUBIC_STEPS+1] =
{
    65536, 65496, 65379, 65186, 64920, 64583, 64177, 63705,
    63168, 62569, 61911, 61195, 60424, 59600, 58725, 57802,
    56832, 55818, 54763, 53668, 52536, 51369, 50169, 48939,
    47680, 46395, 45087, 43757, 42408, 41042, 39661, 38268,
    36864, 35452, 34035, 32614, 31192, 29771, 28353, 26941,
    25536, 24141, 22759, 21391, 20040, 18708, 17397, 16110,
    14848, 13614, 12411, 11240, 10104,  9005,  7945,  6927,
     5952,  5023,  4143,  3313, 2536,  1814,  1149,   544,
        0,  -496,  -961, -1395, -1800, -2176, -2523, -2843,
    -3136, -3403, -3645, -3862, -4056, -4227, -4375, -4502,
    -4608, -4694, -4761, -4809, -4840, -4854, -4851, -4833,
    -4800, -4753, -4693, -4620, -4536, -4441, -4335, -4220,
    -4096, -3964, -3825, -3679, -3528, -3372, -3211, -3047,
    -2880, -2711, -2541, -2370, -2200, -2031, -1863, -1698,
    -1536, -1378, -1225, -1077, -936,  -802,  -675,  -557,
     -448,  -349,  -261,  -184, -120,   -69,   -31,    -8,
        0
};

HRESULT
GpBitmapScaler::PushSrcLineBicubic(
    const ARGB* s
    )
{
    // Check if the current source line is useful

    for (INT i=0; i < 4; i++)
    {
        if (srcy == tempLines[i].expected)
        {
            (this->*xscaleProc)(tempLines[i].buf, s);
            tempLines[i].current = srcy;
        }
    }

    if (tempLines[3].current == -1 ||
        tempLines[2].current == -1 ||
        tempLines[1].current == -1 ||
        tempLines[0].current == -1)
    {
        return S_OK;
    }

    // Emit destination scanline, if any

    while (dsty < dstHeight)
    {
        // Ask for pixel data buffer from the destination sink

        ARGB* d;
        HRESULT hr;
        
        GETNEXTDSTLINE(d);

        // Interpolate four neighboring scanlines

        INT x = ystepFrac >> (FIX16_SHIFT - BICUBIC_SHIFT);

        if (x == 0)
        {
            // Fast case: skip the interpolation

            CopyMemoryARGB(d, tempLines[1].buf, dstWidth);
        }
        
        #ifdef _X86_

        else if (OSInfo::HasMMX)
        {
            MMXBicubicScale(
                d,
                tempLines[0].buf,
                tempLines[1].buf,
                tempLines[2].buf,
                tempLines[3].buf,
                cubicCoeffTable[BICUBIC_STEPS+x],
                cubicCoeffTable[x],
                cubicCoeffTable[BICUBIC_STEPS-x],
                cubicCoeffTable[2*BICUBIC_STEPS-x],
                dstWidth);
        }

        #endif // _X86_

        else
        {
            // Interpolate scanlines

            FIX16 w0 = cubicCoeffTable[BICUBIC_STEPS+x];
            FIX16 w1 = cubicCoeffTable[x];
            FIX16 w2 = cubicCoeffTable[BICUBIC_STEPS-x];
            FIX16 w3 = cubicCoeffTable[2*BICUBIC_STEPS-x];

            const FIX16* p0 = (const FIX16*) tempLines[0].buf;
            const FIX16* p1 = (const FIX16*) tempLines[1].buf;
            const FIX16* p2 = (const FIX16*) tempLines[2].buf;
            const FIX16* p3 = (const FIX16*) tempLines[3].buf;

            for (x=0; x < dstWidth; x++)
            {
                FIX16 a, r, g, b;

                a = (w0 * ((p0[x] >> 24) & 0xff) +
                     w1 * ((p1[x] >> 24) & 0xff) +
                     w2 * ((p2[x] >> 24) & 0xff) +
                     w3 * ((p3[x] >> 24) & 0xff)) >> FIX16_SHIFT;

                a = (a < 0) ? 0 : (a > 255) ? 255 : a;

                r = (w0 * ((p0[x] >> 16) & 0xff) +
                     w1 * ((p1[x] >> 16) & 0xff) +
                     w2 * ((p2[x] >> 16) & 0xff) +
                     w3 * ((p3[x] >> 16) & 0xff)) >> FIX16_SHIFT;

                r = (r < 0) ? 0 : (r > 255) ? 255 : r;

                g = (w0 * ((p0[x] >> 8) & 0xff) +
                     w1 * ((p1[x] >> 8) & 0xff) +
                     w2 * ((p2[x] >> 8) & 0xff) +
                     w3 * ((p3[x] >> 8) & 0xff)) >> FIX16_SHIFT;

                g = (g < 0) ? 0 : (g > 255) ? 255 : g;

                b = (w0 * (p0[x] & 0xff) +
                     w1 * (p1[x] & 0xff) +
                     w2 * (p2[x] & 0xff) +
                     w3 * (p3[x] & 0xff)) >> FIX16_SHIFT;

                b = (b < 0) ? 0 : (b > 255) ? 255 : b;

                d[x] = (a << 24) | (r << 16) | (g << 8) | b;
            }
        }

        // Update internal states

        ystepFrac += yratio;
        ystep += (ystepFrac >> FIX16_SHIFT);
        ystepFrac &= FIX16_MASK;

        if (!UpdateExpectedTempLinesBicubic(ystep))
            break;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Scale one scanline using bicubic interpolation algorithm
*
* Arguments:
*
*   d - Points to destination pixel buffer
*   s - Points to source pixel values
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpBitmapScaler::ScaleLineBicubic(
    ARGB* d,
    const ARGB* s
    )
{
    INT count = dstWidth;
    FIX16 xstep;

    // Figure out initial sampling position in the source line

    xstep = (xratio - FIX16_ONE) >> 1;
    s += (xstep >> FIX16_SHIFT);
    xstep &= FIX16_MASK;

    // Loop over all destination pixels

    while (count--)
    {
        INT x = xstep >> (FIX16_SHIFT - BICUBIC_SHIFT);
        FIX16 w0 = cubicCoeffTable[BICUBIC_STEPS+x];
        FIX16 w1 = cubicCoeffTable[x];
        FIX16 w2 = cubicCoeffTable[BICUBIC_STEPS-x];
        FIX16 w3 = cubicCoeffTable[2*BICUBIC_STEPS-x];

        const FIX16* p = (const FIX16*) s;
        FIX16 a, r, g, b;

        a = (w0 * ((p[-1] >> 24) & 0xff) +
             w1 * ((p[ 0] >> 24) & 0xff) +
             w2 * ((p[ 1] >> 24) & 0xff) +
             w3 * ((p[ 2] >> 24) & 0xff)) >> FIX16_SHIFT;

        a = (a < 0) ? 0 : (a > 255) ? 255 : a;

        r = (w0 * ((p[-1] >> 16) & 0xff) +
             w1 * ((p[ 0] >> 16) & 0xff) +
             w2 * ((p[ 1] >> 16) & 0xff) +
             w3 * ((p[ 2] >> 16) & 0xff)) >> FIX16_SHIFT;

        r = (r < 0) ? 0 : (r > 255) ? 255 : r;

        g = (w0 * ((p[-1] >> 8) & 0xff) +
             w1 * ((p[ 0] >> 8) & 0xff) +
             w2 * ((p[ 1] >> 8) & 0xff) +
             w3 * ((p[ 2] >> 8) & 0xff)) >> FIX16_SHIFT;

        g = (g < 0) ? 0 : (g > 255) ? 255 : g;

        b = (w0 * (p[-1] & 0xff) +
             w1 * (p[ 0] & 0xff) +
             w2 * (p[ 1] & 0xff) +
             w3 * (p[ 2] & 0xff)) >> FIX16_SHIFT;

        b = (b < 0) ? 0 : (b > 255) ? 255 : b;

        *d++ = (a << 24) | (r << 16) | (g << 8) | b;

        // Check if we need to move source pointer

        xstep += xratio;
        s += (xstep >> FIX16_SHIFT);
        xstep &= FIX16_MASK;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Update the expected source line information for
*   the y-direction of bicubic scaling
*
* Arguments:
*
*   line - The index of the active scanline
*
* Return Value:
*
*   TRUE if all there are enough source data to emit a destination line
*   FALSE otherwise
*
\**************************************************************************/

BOOL
GpBitmapScaler::UpdateExpectedTempLinesBicubic(
    INT line
    )
{
    BOOL ready = TRUE;
    INT y, ymax = srcHeight-1;
    line--;
    
    for (INT i=0; i < 4; i++)
    {
        // Clamp line index to within range

        y = (line < 0) ? 0 : line > ymax ? ymax : line;
        line++;

        if ((tempLines[i].expected = y) != tempLines[i].current)
        {
            for (INT j=i+1; j < 4; j++)
            {
                if (y == tempLines[j].current)
                    break;
            }

            if (j < 4)
            {
                if (y < ymax)
                {
                    ARGB* p = tempLines[i].buf;
                    tempLines[i].buf = tempLines[j].buf;
                    tempLines[j].buf = p;

                    tempLines[j].current = tempLines[i].current;
                }
                else
                {
                    CopyMemoryARGB(
                        tempLines[i].buf,
                        tempLines[j].buf,
                        dstWidth);
                }

                tempLines[i].current = y;
            }
            else
            {
                tempLines[i].current = -1;
                ready = FALSE;
            }
        }
    }

    return ready;
}


/**************************************************************************\
*
* Function Description:
*
*   Cache the next band of destination bitmap data
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::GetNextDstBand()
{
    ASSERT(dsty < dstHeight);

    HRESULT hr;

    // Make sure we flush the previously cached band 
    // to the destination sink.

    if (cachedDstCnt)
    {
        hr = dstSink->ReleasePixelDataBuffer(&cachedDstData);
        cachedDstCnt = cachedDstRemaining = 0;

        if (FAILED(hr))
            return hr;
    }

    // Now ask the destination for the next band

    INT h = min(dstBand, dstHeight-dsty);
    RECT rect = { 0, dsty, dstWidth, dsty+h };

    hr = dstSink->GetPixelDataBuffer(
                    &rect,
                    pixelFormat,
                    TRUE,
                    &cachedDstData);

    if (FAILED(hr))
        return hr;

    cachedDstCnt = cachedDstRemaining = h;
    cachedDstNext = (BYTE*) cachedDstData.Scan0;
    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Flush any cached destination bands
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::FlushDstBand()
{
    if (cachedDstRemaining != 0)
        WARNING(("Missing destination scanlines"));

    HRESULT hr;

    hr = cachedDstCnt == 0 ?
            S_OK :
            dstSink->ReleasePixelDataBuffer(&cachedDstData);

    cachedDstCnt = cachedDstRemaining = 0;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\bmp\bmpdecoder.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   decoder.cpp
*
* Abstract:
*
*   Implementation of the bitmap filter decoder
*
* Revision History:
*
*   5/10/1999 OriG
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "bmpdecoder.hpp"

/**************************************************************************\
*
* Function Description:
*
*     Initialize the image decoder
*
* Arguments:
*
*     stream -- The stream containing the bitmap data
*     flags - Misc. flags
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::InitDecoder(
    IN IStream* stream,
    IN DecoderInitFlag flags
    )
{
    HRESULT hresult;
    
    // Make sure we haven't been initialized already
    
    if (pIstream) 
    {
        WARNING(("GpBmpDecoder::InitDecoded -- InitDecoded() called twice"));
        return E_FAIL;
    }

    // Keep a reference on the input stream
    
    stream->AddRef();  
    pIstream = stream;
    SetValid(TRUE);

    bReadHeaders = FALSE;
    hBitmapGdi = NULL;
    pBitsGdi = NULL;

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Reads the bitmap headers out of the stream
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
    
HRESULT
GpBmpDecoder::ReadBitmapHeaders(
    void
    )
{
    if (!bReadHeaders) 
    {
        // Read bitmap file header
    
        if (!ReadStreamBytes(pIstream, &bmfh, sizeof(BITMAPFILEHEADER)) ||
            (bmfh.bfType != 0x4D42) ||
            (bmfh.bfOffBits >= bmfh.bfSize))
        {
            // There are .BMP files with bad headers that paintbrush can read.
            // We should not fail to decode them.

#ifdef BAD_HEADER_WARNING
            WARNING(("Bad .BMP header information"));
#endif            
            //return E_FAIL;
        }

        // Read bitmap info header
    
        BITMAPV5HEADER* bmih = &bmiBuffer.header;
        if (!ReadStreamBytes(pIstream, bmih, sizeof(DWORD)))
        {
            SetValid(FALSE);
            WARNING(("BmpDecoder::ReadBitmapHeaders-ReadStreamBytes() failed"));
            return E_FAIL;
        }
 
        if ((bmih->bV5Size == sizeof(BITMAPINFOHEADER)) ||
            (bmih->bV5Size == sizeof(BITMAPV4HEADER)) ||
            (bmih->bV5Size == sizeof(BITMAPV5HEADER)) )
        {
            // Good, we have the standard BITMAPINFOHEADER
            // or BITMAPV4HEADER or BITMAPV5HEADER

            if (!ReadStreamBytes(pIstream, 
                                 ((PBYTE) bmih) + sizeof(DWORD), 
                                 bmih->bV5Size - sizeof(DWORD)))
            {
                SetValid(FALSE);
                WARNING(("BmpDec::ReadBitmapHeaders-ReadStreamBytes() failed"));
                return E_FAIL;
            }
        
            // Read color table/bitmap mask if appropriate

            UINT colorTableSize = GetColorTableCount() * sizeof(RGBQUAD);

            // Some badly formed images, see Windows bug #513274, may contain
            // more than 256 entries in the color look table which is useless
            // from technical point of view. We can reject this kind of file.

            if (colorTableSize > 1024)
            {
                return E_FAIL;
            }

            if (colorTableSize && !ReadStreamBytes(pIstream, bmiBuffer.colors, colorTableSize))
            {
                SetValid(FALSE);
                WARNING(("BmpDec::ReadBitmapHeaders-ReadStreamBytes() failed"));
                return E_FAIL;
            }
        }
        else if (bmih->bV5Size == sizeof(BITMAPCOREHEADER)) 
        {
            BITMAPCOREHEADER bch;

            if (!ReadStreamBytes(pIstream, 
                                 ((PBYTE) &bch) + sizeof(DWORD), 
                                 sizeof(BITMAPCOREHEADER) - sizeof(DWORD)))
            {
                SetValid(FALSE);
                WARNING(("BmpDec::ReadBitmapHeaders-ReadStreamBytes() failed"));
                return E_FAIL;
            }

            bmih->bV5Width       = bch.bcWidth;
            bmih->bV5Height      = bch.bcHeight;
            bmih->bV5Planes      = bch.bcPlanes;
            bmih->bV5BitCount    = bch.bcBitCount;
            bmih->bV5Compression = BI_RGB;
            bmih->bV5ClrUsed     = 0;
        
            // Read color table/bitmap mask if appropriate

            UINT colorTableCount = GetColorTableCount();
            
            // Some badly formed images, see Windows bug #513274, may contain
            // more than 256 entries in the color look table. Reject this file.

            if (colorTableCount > 256)
            {
                return E_FAIL;
            }

            RGBTRIPLE rgbTripleBuffer[256];
            
            if (colorTableCount)
            {
                if (!ReadStreamBytes(pIstream, rgbTripleBuffer,
                                     colorTableCount * sizeof(RGBTRIPLE)))
                {
                    SetValid(FALSE);
                    WARNING(("BmpDec::ReadBmpHeader-ReadStreamBytes() failed"));
                    return E_FAIL;
                }    

                for (UINT i=0; i<colorTableCount; i++) 
                {
                    bmiBuffer.colors[i].rgbBlue     = rgbTripleBuffer[i].rgbtBlue;
                    bmiBuffer.colors[i].rgbGreen    = rgbTripleBuffer[i].rgbtGreen;
                    bmiBuffer.colors[i].rgbRed      = rgbTripleBuffer[i].rgbtRed;
                    bmiBuffer.colors[i].rgbReserved = 0x0; 
                }
            }
        }
        else
        {
            WARNING(("GpBmpDecoder::ReadBitmapHeaders--unknown bitmap header"));
            SetValid(FALSE);
            return E_FAIL;
        }

        // Check for top-down bitmaps

        IsTopDown = (bmih->bV5Height < 0);

        bReadHeaders = TRUE;
    }

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Computes the number of entries in the color table
*
* Return Value:
*
*     Number of entries in color table
*
\**************************************************************************/

UINT   
GpBmpDecoder::GetColorTableCount(
    void)
{
    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    UINT count = 0;

    if (bmih->bV5Compression == BI_BITFIELDS)
    {
        if (bmih->bV5BitCount == 16 || bmih->bV5BitCount == 32)
        {
            count = 3;
        }
    }
    else switch (bmih->bV5BitCount)
    {
         case 1:
         case 4:
         case 8:

             if (bmih->bV5ClrUsed != 0)
             {    
                 count = bmih->bV5ClrUsed;
             }
             else
             {    
                 count = (1 << bmih->bV5BitCount);
             }

             break;
    }

    return count;
}

/**************************************************************************\
*
* Function Description:
*
*     Sets the palette in decodeSink.  Note that colorPalette is freed at
*     the end of the decode operation.
*
* Return Value:
*s
*     Number of entries in color table
*
\**************************************************************************/

HRESULT
GpBmpDecoder::SetBitmapPalette()
{
    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    
    if ((bmih->bV5BitCount == 1) ||
        (bmih->bV5BitCount == 4) ||
        (bmih->bV5BitCount == 8))
    {
        if (!pColorPalette) 
        {
            UINT colorTableCount = GetColorTableCount();

            // Some badly formed images, see Windows bug #513274, may contain
            // more than 256 entries in the color look table. Reject this file.

            if (colorTableCount > 256)
            {
                return E_FAIL;
            }

            pColorPalette = (ColorPalette *) GpMalloc(sizeof(ColorPalette) + 
                colorTableCount * sizeof(ARGB));

            if (!pColorPalette) 
            {
                WARNING(("BmpDecoder::SetBitmapPalette----Out of memory"));
                return E_OUTOFMEMORY;
            }

            pColorPalette->Flags = 0;
            pColorPalette->Count = colorTableCount;

            UINT i;
            for (i=0; i < colorTableCount; i++) 
            {
                pColorPalette->Entries[i] = MAKEARGB(
                    255,
                    bmiBuffer.colors[i].rgbRed,
                    bmiBuffer.colors[i].rgbGreen,
                    bmiBuffer.colors[i].rgbBlue);
            }
        }
       
        decodeSink->SetPalette(pColorPalette);
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Computes the pixel format ID of the bitmap
*
* Return Value:
*
*     Pixel format ID
*
\**************************************************************************/

PixelFormatID 
GpBmpDecoder::GetPixelFormatID(
    void)
{
    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    PixelFormatID pixelFormatID;

    switch(bmih->bV5BitCount)
    {
    case 1:
        pixelFormatID = PIXFMT_1BPP_INDEXED;
        break;

    case 4:
        pixelFormatID = PIXFMT_4BPP_INDEXED;
        break;

    case 8:
        pixelFormatID = PIXFMT_8BPP_INDEXED;
        break;

    case 16:
        pixelFormatID = PIXFMT_16BPP_RGB555;
        break;

    case 24:
        pixelFormatID = PIXFMT_24BPP_RGB;
        break;

    case 32:
        pixelFormatID = PIXFMT_32BPP_RGB;
        break;

    case 64:
        pixelFormatID = PIXFMT_64BPP_ARGB;
        break;
    
    default:
        pixelFormatID = PIXFMT_UNDEFINED;
        break;
    }

    // Let's return non BI_RGB images in a 32BPP format.  This is because
    // GDI doesn't always do the SetDIBits correctly on arbitrary palettes.

    if (bmih->bV5Compression != BI_RGB) 
    {
        pixelFormatID = PIXFMT_32BPP_RGB;
    }

    return pixelFormatID;
}

STDMETHODIMP 
GpBmpDecoder::QueryDecoderParam(
    IN GUID     Guid
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP 
GpBmpDecoder::SetDecoderParam(
    IN GUID     Guid,
    IN UINT     Length,
    IN PVOID    Value
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP 
GpBmpDecoder::GetPropertyCount(
    OUT UINT*   numOfProperty
    )
{
    if ( numOfProperty == NULL )
    {
        return E_INVALIDARG;
    }

    *numOfProperty = 0;
    return S_OK;
}

STDMETHODIMP 
GpBmpDecoder::GetPropertyIdList(
    IN UINT numOfProperty,
    IN OUT PROPID* list
    )
{
    if ( (numOfProperty != 0) || (list == NULL) )
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

HRESULT
GpBmpDecoder::GetPropertyItemSize(
    IN PROPID propId,
    OUT UINT* size
    )
{
    if ( size == NULL )
    {
        return E_INVALIDARG;
    }

    *size = 0;
    return IMGERR_PROPERTYNOTFOUND;
}// GetPropertyItemSize()

HRESULT
GpBmpDecoder::GetPropertyItem(
    IN PROPID               propId,
    IN UINT                 propSize,
    IN OUT PropertyItem*    buffer
    )
{
    if ( (propSize != 0) || (buffer == NULL) )
    {
        return E_INVALIDARG;
    }

    return IMGERR_PROPERTYNOTFOUND;
}// GetPropertyItem()

HRESULT
GpBmpDecoder::GetPropertySize(
    OUT UINT* totalBufferSize,
    OUT UINT* numProperties
    )
{
    if ( (totalBufferSize == NULL) || (numProperties == NULL) )
    {
        return E_INVALIDARG;
    }

    *totalBufferSize = 0;
    *numProperties = 0;

    return S_OK;
}// GetPropertySize()

HRESULT
GpBmpDecoder::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    IN OUT PropertyItem* allItems
    )
{
    if ( (totalBufferSize != 0) || (numProperties != 0) || (allItems == NULL) )
    {
        return E_INVALIDARG;
    }

    return S_OK;
}// GetAllPropertyItems()

HRESULT
GpBmpDecoder::RemovePropertyItem(
    IN PROPID   propId
    )
{
    return IMGERR_PROPERTYNOTFOUND;
}// RemovePropertyItem()

HRESULT
GpBmpDecoder::SetPropertyItem(
    IN PropertyItem item
    )
{
    return IMGERR_PROPERTYNOTSUPPORTED;
}// SetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*     Cleans up the image decoder
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

// Clean up the image decoder object

STDMETHODIMP 
GpBmpDecoder::TerminateDecoder()
{
    // Release the input stream
    
    if (!IsValid())
    {
        WARNING(("GpBmpDecoder::TerminateDecoder -- invalid image"))
        return E_FAIL;
    }

    if(pIstream)
    {
        pIstream->Release();
        pIstream = NULL;
    }

    if (hBitmapGdi) 
    {
        DeleteObject(hBitmapGdi);
        hBitmapGdi = NULL;
        pBitsGdi = NULL;
        
        WARNING(("GpBmpCodec::TerminateDecoder--need to call EndDecode first"));
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Initiates the decode of the current frame
*
* Arguments:
*
*   decodeSink - The sink that will support the decode operation
*   newPropSet - New image property sets, if any
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::BeginDecode(
    IN IImageSink* imageSink,
    IN OPTIONAL IPropertySetStorage* newPropSet
    )
{
    if (!IsValid())
    {
        WARNING(("GpBmpDecoder::BeginDecode -- invalid image"))
        return E_FAIL;
    }

    if (decodeSink) 
    {
        WARNING(("BeginDecode called again before call to EngDecode"));
        return E_FAIL;
    }

    imageSink->AddRef();
    decodeSink = imageSink;

    currentLine = 0;
    bCalledBeginSink = FALSE;

    return S_OK;
}
    

/**************************************************************************\
*
* Function Description:
*
*     Ends the decode of the current frame
*
* Arguments:
*
*     statusCode -- status of decode operation

* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::EndDecode(
    IN HRESULT statusCode
    )
{
    if (!IsValid())
    {
        WARNING(("GpBmpDecoder::EndDecode -- invalid image"))
        return E_FAIL;
    }

    if (pColorPalette) 
    {
        // free the color palette

        GpFree(pColorPalette);
        pColorPalette = NULL;
    }

    if (hBitmapGdi) 
    {
        DeleteObject(hBitmapGdi);
        hBitmapGdi = NULL;
        pBitsGdi = NULL;
    }
    
    if (!decodeSink) 
    {
        WARNING(("EndDecode called before call to BeginDecode"));
        return E_FAIL;
    }
    
    HRESULT hresult = decodeSink->EndSink(statusCode);

    decodeSink->Release();
    decodeSink = NULL;

    if (FAILED(hresult)) 
    {
        WARNING(("GpBmpDecoder::EndDecode -- EndSink() failed"))
        statusCode = hresult; // If EndSink failed return that (more recent)
                              // failure code
    }

    return statusCode;
}


/**************************************************************************\
*
* Function Description:
*
*     Sets up the ImageInfo structure
*
* Arguments:
*
*     ImageInfo -- information about the decoded image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::GetImageInfo(OUT ImageInfo* imageInfo)
{
    HRESULT hresult;

    hresult = ReadBitmapHeaders();
    if (FAILED(hresult)) 
    {
        WARNING(("GpBmpDecoder::GetImageInfo -- ReadBitmapHeaders failed."));
        return hresult;
    }
    
    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    
    imageInfo->RawDataFormat = IMGFMT_BMP;
    imageInfo->PixelFormat   = GetPixelFormatID();
    imageInfo->Width         = bmih->bV5Width;
    imageInfo->Height        = abs(bmih->bV5Height);
    imageInfo->TileWidth     = bmih->bV5Width;
    imageInfo->TileHeight    = 1;
    imageInfo->Flags         = SINKFLAG_TOPDOWN
                             | SINKFLAG_FULLWIDTH
                             | IMGFLAG_HASREALPIXELSIZE
                             | IMGFLAG_COLORSPACE_RGB;

    // if both XPelsPerMeter and YPelsPerMeter are greater than 0, then
    // we claim that the file has real dpi info in the flags.  Otherwise,
    // we set the dpi's to the default and claim that the dpi's are fake.
    if ( (bmih->bV5XPelsPerMeter > 0) && (bmih->bV5YPelsPerMeter > 0) )
    {
        imageInfo->Xdpi = (bmih->bV5XPelsPerMeter * 254.0) / 10000.0;
        imageInfo->Ydpi = (bmih->bV5YPelsPerMeter * 254.0) / 10000.0;
        imageInfo->Flags |= IMGFLAG_HASREALDPI;
    }
    else
    {
        // Start: [Bug 103296]
        // Change this code to use Globals::DesktopDpiX and Globals::DesktopDpiY
        HDC hdc;
        hdc = ::GetDC(NULL);
        if ((hdc == NULL) || 
            ((imageInfo->Xdpi = (REAL)::GetDeviceCaps(hdc, LOGPIXELSX)) <= 0) ||
            ((imageInfo->Ydpi = (REAL)::GetDeviceCaps(hdc, LOGPIXELSY)) <= 0))
        {
            WARNING(("BmpDecoder::GetImageInfo-GetDC or GetDeviceCaps failed"));
            imageInfo->Xdpi = DEFAULT_RESOLUTION;
            imageInfo->Ydpi = DEFAULT_RESOLUTION;
        }
        ::ReleaseDC(NULL, hdc);
        // End: [Bug 103296]
    }

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*
*     decodeSink --  The sink that will support the decode operation
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::Decode()
{
    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    HRESULT hresult;
    ImageInfo imageInfo;

    if (!IsValid())
    {
        WARNING(("GpBmpDecoder::Decode -- invalid image"))
        return E_FAIL;
    }

    hresult = GetImageInfo(&imageInfo);
    if (FAILED(hresult)) 
    {
        WARNING(("GpBmpDecoder::Decode -- GetImageInfo() failed"))
        return hresult;
    }

    // Inform the sink that decode is about to begin

    if (!bCalledBeginSink) 
    {
        hresult = decodeSink->BeginSink(&imageInfo, NULL);
        if (!SUCCEEDED(hresult)) 
        {
            WARNING(("GpBmpDecoder::Decode -- BeginSink() failed"))
            return hresult;
        }

        // Client cannot modify height and width

        imageInfo.Width  = bmih->bV5Width;
        imageInfo.Height = abs(bmih->bV5Height);

        bCalledBeginSink = TRUE;
    
        // Set the palette in the sink.  Shouldn't do anything if there's 
        // no palette to set.

        hresult = SetBitmapPalette();
        if (!SUCCEEDED(hresult)) 
        {
            WARNING(("GpBmpDecoder::Decode -- SetBitmapPalette() failed"))
            return hresult;
        }
    }

    PixelFormatID srcPixelFormatID = GetPixelFormatID();
    
    // Check the required pixel format. If it is not one of our supportted
    // format, switch it to a canonical one
    
    if ( imageInfo.PixelFormat != srcPixelFormatID )
    {
        // The sink is trying to negotiate a format with us

        switch ( imageInfo.PixelFormat )
        {
            // If the sink asks for one of the BMP supported image format, we
            // will honor its request if we can convert from current format to
            // the destination format. If we can't, then we can only decode it
            // to 32 ARGB

        case PIXFMT_1BPP_INDEXED:
        case PIXFMT_4BPP_INDEXED:
        case PIXFMT_8BPP_INDEXED:
        case PIXFMT_16BPP_RGB555:
        case PIXFMT_24BPP_RGB:
        case PIXFMT_32BPP_RGB:
        {
            // Check if we can convert the source pixel format to the format
            // sink required. If not. we return 32BPP ARGB

            EpFormatConverter linecvt;
            if ( linecvt.CanDoConvert(srcPixelFormatID,
                                      imageInfo.PixelFormat) == FALSE )
            {
                imageInfo.PixelFormat = PIXFMT_32BPP_ARGB;
            }
        }
            break;

        default:

            // For all the rest format, we convert it to 32BPP_ARGB and let
            // the sink to do the conversion to the format it likes

            imageInfo.PixelFormat = PIXFMT_32BPP_ARGB;

            break;
        }// switch ( imageInfo.PixelFormat )
    }// if ( imageInfo.PixelFormat != srcPixelFormatID )

    // Decode the current frame
    
    hresult = DecodeFrame(imageInfo);

    return hresult;
}// Decode()

/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*
*     imageInfo -- decoding parameters
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::DecodeFrame(
    IN ImageInfo& imageInfo
    )
{
    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    HRESULT hresult;
    RECT currentRect;
    INT bmpStride;

    // Compute DWORD aligned stride of bitmap in stream

    if (bmih->bV5Compression == BI_RGB) 
    {
        bmpStride = (bmih->bV5Width * bmih->bV5BitCount + 7) / 8;
        bmpStride = (bmpStride + 3) & (~0x3);
    }
    else
    {
        // Non BI_RGB bitmaps are stored in 32BPP

        bmpStride = bmih->bV5Width * sizeof(RGBQUAD);
    }

    // Do we need to change format?
    
    PixelFormatID pixelFormatID = GetPixelFormatID();
    if (pixelFormatID == PIXFMT_UNDEFINED) 
    {
        WARNING(("GpBmpDecoder::DecodeFrame---Pixel format undefined"));
        return E_FAIL;
    }    

    // Buffer to hold one line of original image bits

    VOID* pOriginalBits = GpMalloc(bmpStride);
    if (!pOriginalBits) 
    {
        WARNING(("GpBmpDecoder::DecodeFrame---GpMalloc() failed"));
        return E_OUTOFMEMORY;
    }

    // Adjust for top-down bitmap

    if (IsTopDown)
    {
        bmpStride = -bmpStride;
    }

    currentRect.left = 0;
    currentRect.right = imageInfo.Width;

    while (currentLine < (INT) imageInfo.Height) 
    {
        // Read one source line from the image

        hresult = ReadLine(pOriginalBits, currentLine, imageInfo);
               
        if (FAILED(hresult)) 
        {
            if (pOriginalBits)
            {
                GpFree(pOriginalBits);
            }

            WARNING(("GpBmpDecoder::DecodeFrame---ReadLine() failed"));
            return hresult;
        }
        
        currentRect.top = currentLine;
        currentRect.bottom = currentLine + 1;

        BitmapData bitmapData;
        hresult = decodeSink->GetPixelDataBuffer(&currentRect, 
                                                 imageInfo.PixelFormat, 
                                                 TRUE,
                                                 &bitmapData);
        if (!SUCCEEDED(hresult)) 
        {
            if (pOriginalBits)
            {
                GpFree(pOriginalBits);
            }
            
            WARNING(("GpBmpDecoder::DecodeFrame--GetPixelDataBuffer() failed"));
            return E_FAIL;
        }
        
        if (pixelFormatID != imageInfo.PixelFormat) 
        {
            // Need to copy bits to bitmapData.scan0
            
            BitmapData bitmapDataOriginal;
            bitmapDataOriginal.Width = bitmapData.Width;
            bitmapDataOriginal.Height = 1;
            bitmapDataOriginal.Stride = bmpStride;
            bitmapDataOriginal.PixelFormat = pixelFormatID;
            bitmapDataOriginal.Scan0 = pOriginalBits;
            bitmapDataOriginal.Reserved = 0;
            
            // Convert the image from "pixelFormatID" to "imageInfo.PixelFormat"
            // The result will be in "bitmapData"

            hresult = ConvertBitmapData(&bitmapData,
                                        pColorPalette,
                                        &bitmapDataOriginal,
                                        pColorPalette);
            if ( FAILED(hresult) )
            {
                WARNING (("BmpDecoder::DecodeFrame--ConvertBitmapData failed"));
                if (pOriginalBits)
                {
                    GpFree(pOriginalBits);
                }

                // We should not failed here since we have done the check if we
                // can do the conversion or not in Decode()

                ASSERT(FALSE);
                return E_FAIL;
            }
        }
        else
        {
            // Note: Theoritically, bmpStride == uiDestStride. But some codec
            // might not allocate DWORD aligned memory chunk, like gifencoder.
            // So the problem will occur in GpMemcpy() below when we fill the
            // dest buffer. Though we can fix it in the encoder side. But it is
            // not realistic if the encoder is written by 3rd party ISVs.
            //
            // One example is when you open an 8bpp indexed BMP and save it as
            // GIF. If the width is 0x14d (333 in decimal), the GIF encoder only
            // allocates 14d bytes for each scan line. So we have to calculate
            // the destStride and use it when do a memcpy()

            UINT    uiDestStride = imageInfo.Width
                                 * GetPixelFormatSize(imageInfo.PixelFormat);
            uiDestStride = (uiDestStride + 7) >> 3; // Total bytes needed

            GpMemcpy(bitmapData.Scan0, pOriginalBits, uiDestStride);
        }

        hresult = decodeSink->ReleasePixelDataBuffer(&bitmapData);
        if (!SUCCEEDED(hresult)) 
        {
            if (pOriginalBits)
            {
                GpFree(pOriginalBits);
            }
            
            WARNING (("BmpDec::DecodeFrame--ReleasePixelDataBuffer() failed"));
            return E_FAIL;
        }

        currentLine++;
    }
    
    if (pOriginalBits)
    {
        GpFree(pOriginalBits);
    }
    
    return S_OK;
}// DecodeFrame()
    
/**************************************************************************\
*
* Function Description:
*
*     Reads a line in the native format into pBits
*
* Arguments:
*
*     pBits -- a buffer to hold the line data
*     currentLine -- The line to read
*     imageInfo -- info about the image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::ReadLine(
    IN VOID *pBits,
    IN INT currentLine,
    IN ImageInfo imageInfo
    )
{
    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    HRESULT hresult;
    
    switch (bmih->bV5Compression) 
    {
    case BI_RGB:
        hresult = ReadLine_BI_RGB(pBits, currentLine, imageInfo);
        break;

    case BI_BITFIELDS:

        // Let's use GDI to do the bitfields rendering (much easier than
        // writing special purpose code for this).  This is the same
        // codepath we use for RLEs.

    case BI_RLE8:
    case BI_RLE4:
        hresult = ReadLine_GDI(pBits, currentLine, imageInfo);
        break;

    default:
        WARNING(("GpBmpDecoder::ReadLine---Unknown bitmap format"));
        hresult = E_FAIL;
        break;
    }

    return hresult;
}
    
    
/**************************************************************************\
*
* Function Description:
*
*     Reads a line in the native format into pBits.  This is the case where
*     the format is BI_RGB.
*
* Arguments:
*
*     pBits -- a buffer to hold the line data
*     currentLine -- The line to read
*     imageInfo -- info about the image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::ReadLine_BI_RGB(
    IN VOID *pBits,
    IN INT currentLine,
    IN ImageInfo imageInfo
    )
{
    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    
    // Compute DWORD aligned stride of bitmap in stream

    UINT bmpStride = (bmih->bV5Width * bmih->bV5BitCount + 7) / 8;
    bmpStride = (bmpStride + 3) & (~0x3);

    // Seek to beginning of stream data

    INT offset;

    if (IsTopDown)
    {
        offset = bmfh.bfOffBits +
                 bmpStride * currentLine;
    }
    else
    {
        offset = bmfh.bfOffBits +
                 bmpStride * (imageInfo.Height - currentLine - 1);
    }

    if (!SeekStreamPos(pIstream, STREAM_SEEK_SET, offset))
    {
        WARNING(("GpBmpDecoder::ReadLine_BI_RGB---SeekStreamPos() failed"));
        return E_FAIL;
    }

    // Read one line

    if (!ReadStreamBytes(pIstream, 
                         (void *) pBits,
                         (bmih->bV5Width * bmih->bV5BitCount + 7) / 8)) 
    {
        WARNING(("GpBmpDecoder::ReadLine_BI_RGB---ReadStreamBytes() failed"));
        return E_FAIL;
    }

    return S_OK;
}
    

/**************************************************************************\
*
* Function Description:
*
*     Uses GDI to decode a non-native format into a known DIB format
*
* Arguments:
*
*     pBits -- a buffer to hold the line data
*     currentLine -- The line to read
*     imageInfo -- info about the image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::ReadLine_GDI(
    IN VOID *pBits,
    IN INT currentLine,
    IN ImageInfo imageInfo
    )
{
    HRESULT hresult;

    if (!pBitsGdi) 
    {
        hresult = GenerateGdiBits(imageInfo);
        if (FAILED(hresult)) 
        {
            WARNING(("GpBmpDecoder::ReadLine_GDI---GenerateGdiBits() failed"));
            return hresult;
        }
    }

    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    
    // Compute DWORD aligned stride of bitmap in stream

    UINT bmpStride = bmih->bV5Width * sizeof(RGBQUAD);

    if (IsTopDown)
    {
        GpMemcpy(pBits,
                 ((PBYTE) pBitsGdi) + bmpStride * currentLine,
                 bmpStride);
    }
    else
    {
        GpMemcpy(pBits,
                 ((PBYTE)pBitsGdi)
                    + bmpStride * (imageInfo.Height - currentLine - 1),
                 bmpStride);
    }

    return S_OK;
}



/**************************************************************************\
*
* Function Description:
*
*     Uses GDI to generate image bits in a known format (from RLE)
*     
* Arguments:
*
*     imageInfo -- info about the image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::GenerateGdiBits(
    IN ImageInfo imageInfo
    )
{
    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    HRESULT hresult;

    // Allocate temporary storage for bits from stream
    
    STATSTG statStg;
    hresult = pIstream->Stat(&statStg, STATFLAG_NONAME);
    if (FAILED(hresult))
    {
        WARNING(("GpBmpDecoder::GenerateGdiBits---Stat() failed"));
        return hresult;
    }
    // According to the document for IStream::Stat::StatStage(), the caller
    // has to free the pwcsName string
    
    CoTaskMemFree(statStg.pwcsName);
    
    UINT bufferSize = statStg.cbSize.LowPart - bmfh.bfOffBits;    
    VOID *pStreamBits = GpMalloc(bufferSize);
    if (!pStreamBits) 
    {
        WARNING(("GpBmpDecoder::GenerateGdiBits---GpMalloc() failed"));
        return E_OUTOFMEMORY;
    }
    
    // Now read the bits from the stream

    if (!SeekStreamPos(pIstream, STREAM_SEEK_SET, bmfh.bfOffBits))
    {
        WARNING(("GpBmpDecoder::GenerateGdiBits---SeekStreamPos() failed"));
        GpFree(pStreamBits);
        return E_FAIL;
    }
    
    if (!ReadStreamBytes(pIstream, pStreamBits, bufferSize))
    {
        WARNING(("GpBmpDecoder::GenerateGdiBits---ReadStreamBytes() failed"));
        GpFree(pStreamBits);
        return E_FAIL;
    }

    // Now allocate a GDI DIBSECTION to render the bitmap

    BITMAPINFO bmi;
    bmi.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth         = bmih->bV5Width;
    bmi.bmiHeader.biHeight        = bmih->bV5Height;
    bmi.bmiHeader.biPlanes        = 1;
    bmi.bmiHeader.biBitCount      = 32;
    bmi.bmiHeader.biCompression   = BI_RGB;
    bmi.bmiHeader.biSizeImage     = 0;
    bmi.bmiHeader.biXPelsPerMeter = bmih->bV5XPelsPerMeter;
    bmi.bmiHeader.biYPelsPerMeter = bmih->bV5YPelsPerMeter;
    bmi.bmiHeader.biClrUsed       = 0;
    bmi.bmiHeader.biClrImportant  = 0;

    HDC hdcScreen = GetDC(NULL);
    if ( hdcScreen == NULL )
    {
        WARNING(("GpBmpDecoder::GenerateGdiBits---GetDC failed"));
        GpFree(pStreamBits);
        return E_FAIL;
    }

    hBitmapGdi = CreateDIBSection(hdcScreen, 
                                  (BITMAPINFO *) &bmi, 
                                  DIB_RGB_COLORS, 
                                  (void **) &pBitsGdi, 
                                  NULL, 
                                  0);
    if (!hBitmapGdi) 
    {
        GpFree(pStreamBits);
        ReleaseDC(NULL, hdcScreen);
        WARNING(("GpBmpDecoder::GenerateGdiBits--failed to create DIBSECTION"));
        return E_FAIL;
    }

    // The BITMAPINFOHEADER in the file should already have the correct size set
    // for RLEs, but in some cases it doesn't so we will fix it here.

    if ((bmih->bV5SizeImage == 0) || (bmih->bV5SizeImage > bufferSize)) 
    {
        bmih->bV5SizeImage = bufferSize;
    }
    
    // we need to convert bmiBuffer into a BITMAPINFO so that SetDIBits
    // understands the structure passed in.
    BITMAPINFO *pbmiBufferTemp;

    pbmiBufferTemp = static_cast<BITMAPINFO *>
        (GpMalloc(sizeof (BITMAPINFO) + (255 * sizeof(RGBQUAD))));
    if (!pbmiBufferTemp)
    {
        DeleteObject(hBitmapGdi);
        GpFree(pStreamBits);
        ReleaseDC(NULL, hdcScreen);
        WARNING(("GpBmpDecoder::GenerateGdiBits -- failed in GpMalloc()"));
        return E_FAIL;
    }

    pbmiBufferTemp->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    pbmiBufferTemp->bmiHeader.biWidth         = bmiBuffer.header.bV5Width;
    pbmiBufferTemp->bmiHeader.biHeight        = bmiBuffer.header.bV5Height;
    pbmiBufferTemp->bmiHeader.biPlanes        = bmiBuffer.header.bV5Planes;
    pbmiBufferTemp->bmiHeader.biBitCount      = bmiBuffer.header.bV5BitCount;
    pbmiBufferTemp->bmiHeader.biCompression   = bmiBuffer.header.bV5Compression;
    pbmiBufferTemp->bmiHeader.biSizeImage     = bmiBuffer.header.bV5SizeImage;
    pbmiBufferTemp->bmiHeader.biXPelsPerMeter = bmiBuffer.header.bV5XPelsPerMeter;
    pbmiBufferTemp->bmiHeader.biYPelsPerMeter = bmiBuffer.header.bV5YPelsPerMeter;
    pbmiBufferTemp->bmiHeader.biClrUsed       = bmiBuffer.header.bV5ClrUsed;
    pbmiBufferTemp->bmiHeader.biClrImportant  = bmiBuffer.header.bV5ClrImportant;

    for (int i = 0; i < 256; i++)
    {
        pbmiBufferTemp->bmiColors[i] = bmiBuffer.colors[i];
    }

    // for V4 and V5 headers, if we have BI_BITFIELDS for biCompression, then
    // copy the RGB masks into the first three colors
    if (((bmih->bV5Size == sizeof(BITMAPV4HEADER)) ||
         (bmih->bV5Size == sizeof(BITMAPV5HEADER)))  &&
        (bmih->bV5Compression == BI_BITFIELDS))
    {
        *((DWORD *) &(pbmiBufferTemp->bmiColors[0])) = bmih->bV5RedMask;
        *((DWORD *) &(pbmiBufferTemp->bmiColors[1])) = bmih->bV5GreenMask;
        *((DWORD *) &(pbmiBufferTemp->bmiColors[2])) = bmih->bV5BlueMask;
    }

    INT numLinesCopied = SetDIBits(hdcScreen, 
                                   hBitmapGdi, 
                                   0, 
                                   imageInfo.Height,
                                   pStreamBits, 
                                   pbmiBufferTemp,
                                   DIB_RGB_COLORS);

    GpFree(pbmiBufferTemp);
    GpFree(pStreamBits);
    ReleaseDC(NULL, hdcScreen);

    if (numLinesCopied != (INT) imageInfo.Height) 
    {
        WARNING(("GpBmpDecoder::GenerateGdiBits -- SetDIBits failed"));
        DeleteObject(hBitmapGdi);
        hBitmapGdi = NULL;
        pBitsGdi = NULL;

        return E_FAIL;
    }

    // At this point pBitsGdi contains the rendered bits in a native format.
    // This buffer will be released in EndDecode.

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Get the total number of dimensions the image supports
*
* Arguments:
*
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::GetFrameDimensionsCount(
    UINT* count
    )
{
    if ( count == NULL )
    {
        WARNING(("GpBmpDecoder::GetFrameDimensionsCount-Invalid input parameter"));
        return E_INVALIDARG;
    }
    
    // Tell the caller that BMP is a one dimension image.

    *count = 1;

    return S_OK;
}// GetFrameDimensionsCount()

/**************************************************************************\
*
* Function Description:
*
*     Get an ID list of dimensions the image supports
*
* Arguments:
*
*     dimensionIDs---Memory buffer to hold the result ID list
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::GetFrameDimensionsList(
    GUID*   dimensionIDs,
    UINT    count
    )
{
    if ( (count != 1) || (dimensionIDs == NULL) )
    {
        WARNING(("GpBmpDecoder::GetFrameDimensionsList-Invalid input param"));
        return E_INVALIDARG;
    }

    // BMP image only supports page dimension

    dimensionIDs[0] = FRAMEDIM_PAGE;

    return S_OK;
}// GetFrameDimensionsList()

/**************************************************************************\
*
* Function Description:
*
*     Get number of frames for the specified dimension
*     
* Arguments:
*
*     dimensionID --
*     count --     
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::GetFrameCount(
    IN const GUID* dimensionID,
    OUT UINT* count
    )
{
    if ( (NULL == count) || (*dimensionID != FRAMEDIM_PAGE) )
    {
        WARNING(("GpBmpDecoder::GetFrameCount -- invalid parameters"))
        return E_INVALIDARG;
    }
    
    if (!IsValid())
    {
        WARNING(("GpBmpDecoder::GetFrameCount -- invalid image"))
        return E_FAIL;
    }

    *count = 1;
    
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Select currently active frame
*     
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::SelectActiveFrame(
    IN const GUID* dimensionID,
    IN UINT frameIndex
    )
{
    if (!IsValid())
    {
        WARNING(("GpBmpDecoder::SelectActiveFrame -- invalid image"))
        return E_FAIL;
    }

    if ( (dimensionID == NULL) || (*dimensionID != FRAMEDIM_PAGE) )
    {
        WARNING(("GpBmpDecoder::SelectActiveFrame--Invalid GUID input"));
        return E_INVALIDARG;
    }

    if ( frameIndex > 1 )
    {
        // BMP is a single frame image format

        WARNING(("GpBmpDecoder::SelectActiveFrame--Invalid frame index"));
        return E_INVALIDARG;
    }

    return S_OK;
}// SelectActiveFrame()

/**************************************************************************\
*
* Function Description:
*
*   Get image thumbnail
*
* Arguments:
*
*   thumbWidth, thumbHeight - Specifies the desired thumbnail size in pixels
*   thumbImage - Returns a pointer to the thumbnail image
*
* Return Value:
*
*   Status code
*
* Note:
*
*   Even if the optional thumbnail width and height parameters are present,
*   the decoder is not required to honor it. The requested size is used
*   as a hint. If both width and height parameters are 0, then the decoder
*   is free to choose an convenient thumbnail size.
*
\**************************************************************************/

HRESULT
GpBmpDecoder::GetThumbnail(
    IN OPTIONAL UINT thumbWidth,
    IN OPTIONAL UINT thumbHeight,
    OUT IImage** thumbImage
    )
{
    if (!IsValid())
    {
        WARNING(("GpBmpDecoder::GetThumbnail -- invalid image"))
        return E_FAIL;
    }

    return E_NOTIMPL;
}

/**************************************************************************\
*
* Function Description:
*
*     Constructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpBmpDecoder::GpBmpDecoder(
    void
    )
{
    comRefCount   = 1;
    pIstream      = NULL;
    decodeSink    = NULL;
    pColorPalette = NULL;
    GpMemset(&bmiBuffer.header, 0, sizeof(BITMAPV5HEADER));
}

/**************************************************************************\
*
* Function Description:
*
*     Destructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpBmpDecoder::~GpBmpDecoder(
    void
    )
{
    // The destructor should never be called before Terminate is called, but
    // if it does we should release our reference on the stream anyway to avoid
    // a memory leak.

    if(pIstream)
    {
        WARNING(("GpBmpCodec::~GpBmpCodec -- need to call TerminateDecoder first"));
        pIstream->Release();
        pIstream = NULL;
    }

    if(pColorPalette)
    {
        WARNING(("GpBmpCodec::~GpBmpCodec -- color palette not freed"));
        GpFree(pColorPalette);
        pColorPalette = NULL;
    }

    SetValid(FALSE);    // so we don't use a deleted object
}

/**************************************************************************\
*
* Function Description:
*
*     QueryInterface
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IImageDecoder)
    {
        *ppv = static_cast<IImageDecoder*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageDecoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     AddRef
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpBmpDecoder::AddRef(
    VOID)
{
    return InterlockedIncrement(&comRefCount);
}

/**************************************************************************\
*
* Function Description:
*
*     Release
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpBmpDecoder::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&comRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\emf\emfcodec.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   emfcodec.cpp
*
* Abstract:
*
*   Shared methods for the EMF codec
*
* Revision History:
*
*   6/14/1999 OriG
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "emfcodec.hpp"


/**************************************************************************\
*
* Function Description:
*
*     Constructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpEMFCodec::GpEMFCodec(
    void
    )
{
    comRefCount   = 1;
    pIstream      = NULL;
    decodeSink    = NULL;
}

/**************************************************************************\
*
* Function Description:
*
*     Destructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpEMFCodec::~GpEMFCodec(
    void
    )
{
    // The destructor should never be called before Terminate is called, but
    // if it does we should release our reference on the stream anyway to avoid
    // a memory leak.

    if(pIstream)
    {
        WARNING(("GpEMFCodec::~GpEMFCodec -- need to call TerminateDecoder first"));
        pIstream->Release();
        pIstream = NULL;
    }
}

/**************************************************************************\
*
* Function Description:
*
*     QueryInterface
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IImageDecoder)
    {
        *ppv = static_cast<IImageDecoder*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageDecoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     AddRef
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpEMFCodec::AddRef(
    VOID)
{
    return InterlockedIncrement(&comRefCount);
}

/**************************************************************************\
*
* Function Description:
*
*     Release
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpEMFCodec::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&comRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\dll\dllentry.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   dllentry.cpp
*
* Abstract:
*
*   Description of what this module does.
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


//
// DLL instance handle
//

extern HINSTANCE DllInstance;

BOOL InitImagingLibrary(BOOL suppressExternalCodecs);
VOID CleanupImagingLibrary();

/**************************************************************************\
*
* Function Description:
*
*   DLL entrypoint
*
* Arguments:
* Return Value:
*
*   See Win32 SDK documentation
*
\**************************************************************************/

extern "C" BOOL
DllEntryPoint(
    HINSTANCE   dllHandle,
    DWORD       reason,
    CONTEXT*    reserved
    )
{
    BOOL ret = TRUE;
    
    switch (reason)
    {
    case DLL_PROCESS_ATTACH:

        // To improve the working set, we tell the system we don't
        // want any DLL_THREAD_ATTACH calls

        DllInstance = dllHandle;
        DisableThreadLibraryCalls(dllHandle);
        
        ret = GpRuntime::Initialize();

        if (ret)
        {
            ret = InitImagingLibrary(FALSE);
        }
        break;

    case DLL_PROCESS_DETACH:

        CleanupImagingLibrary();
        GpRuntime::Uninitialize();
        break;
    }

    return ret;
}


/**************************************************************************\
*
* Function Description:
*
*   Determine whether the DLL can be safely unloaded
*   See Win32 SDK documentation for more details.
*
\**************************************************************************/

STDAPI
DllCanUnloadNow()
{
    return (ComComponentCount == 0) ? S_OK : S_FALSE;
}


/**************************************************************************\
*
* Function Description:
*
*   Retrieves a class factory object from a DLL.
*   See Win32 SDK documentation for more details.
*
\**************************************************************************/

typedef IClassFactoryBase<GpImagingFactory> GpDllClassFactory;

STDAPI
DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    VOID** ppv
    )
{
    if (rclsid != CLSID_ImagingFactory)
        return CLASS_E_CLASSNOTAVAILABLE;

    GpDllClassFactory* factory = new GpDllClassFactory();

    if (factory == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = factory->QueryInterface(riid, ppv);
    factory->Release();

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Register/unregister our COM component
*   See Win32 SDK documentation for more details.
*
\**************************************************************************/

static const ComComponentRegData ComRegData =
{
    &CLSID_ImagingFactory,
    L"ImagingFactory COM Component",
    L"imaging.ImagingFactory.1",
    L"imaging.ImagingFactory",
    L"Both"
};

STDAPI
DllRegisterServer()
{
    return RegisterComComponent(&ComRegData, TRUE);
}

STDAPI
DllUnregisterServer()
{
    return RegisterComComponent(&ComRegData, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\emf\emfdecoder.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   emfdecoder.cpp
*
* Abstract:
*
*   Implementation of the EMF decoder
*
* Revision History:
*
*   6/14/1999 OriG
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "emfcodec.hpp"

/**************************************************************************\
*
* Function Description:
*
*     Initialize the image decoder
*
* Arguments:
*
*     stream -- The stream containing the bitmap data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::InitDecoder(
    IN IStream* stream,
    IN DecoderInitFlag flags
    )
{
    HRESULT hresult;
    
    // Make sure we haven't been initialized already
    
    if (pIstream) 
    {
        return E_FAIL;
    }

    // Keep a reference on the input stream
    
    stream->AddRef();  
    pIstream = stream;
    bReadHeader = FALSE;
    bReinitializeEMF = FALSE;

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Cleans up the image decoder
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpEMFCodec::TerminateDecoder()
{
    // Release the input stream
    
    if(pIstream)
    {
        pIstream->Release();
        pIstream = NULL;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Reads the EMF header
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpEMFCodec::ReadEMFHeader()
{
    HRESULT hresult;
    
    if (!pIstream) 
    {
        return E_FAIL;
    }

    if (!bReadHeader) 
    {
        ULONG cbRead;
        hresult = pIstream->Read((void *) &emh, sizeof(emh), &cbRead);
        if (FAILED(hresult)) 
        {
            return hresult;
        }
        if (cbRead != sizeof(emh)) 
        {
            return E_FAIL;
        }

        bReadHeader = TRUE;

        imageInfo.RawDataFormat = IMGFMT_EMF;
        imageInfo.PixelFormat = PIXFMT_32BPP_RGB;
        imageInfo.Width  = emh.rclBounds.right  - emh.rclBounds.left;
        imageInfo.Height = emh.rclBounds.bottom - emh.rclBounds.top;
        imageInfo.TileWidth  = imageInfo.Width;
        imageInfo.TileHeight = 1; // internal GDI format is bottom-up...

        #define MM_PER_INCH 25.4
        imageInfo.Xdpi = MM_PER_INCH * emh.szlDevice.cx / emh.szlMillimeters.cx;
        imageInfo.Ydpi = MM_PER_INCH * emh.szlDevice.cy / emh.szlMillimeters.cy;
        imageInfo.Flags = SINKFLAG_TOPDOWN
                        | SINKFLAG_FULLWIDTH
                        | SINKFLAG_SCALABLE
                        | IMGFLAG_HASREALPIXELSIZE
                        | IMGFLAG_COLORSPACE_RGB;
    }

    return S_OK;
}

STDMETHODIMP 
GpEMFCodec::QueryDecoderParam(
    IN GUID		Guid
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP 
GpEMFCodec::SetDecoderParam(
    IN GUID		Guid,
	IN UINT		Length,
	IN PVOID	Value
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP 
GpEMFCodec::GetPropertyCount(
    OUT UINT*   numOfProperty
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP 
GpEMFCodec::GetPropertyIdList(
    IN UINT numOfProperty,
  	IN OUT PROPID* list
    )
{
    return E_NOTIMPL;
}

HRESULT
GpEMFCodec::GetPropertyItemSize(
    IN PROPID propId,
    OUT UINT* size
    )
{
    return E_NOTIMPL;
}// GetPropertyItemSize()

HRESULT
GpEMFCodec::GetPropertyItem(
    IN PROPID               propId,
    IN UINT                 propSize,
    IN OUT PropertyItem*    buffer
    )
{
    return E_NOTIMPL;
}// GetPropertyItem()

HRESULT
GpEMFCodec::GetPropertySize(
    OUT UINT* totalBufferSize,
    OUT UINT* numProperties
    )
{
    return E_NOTIMPL;
}// GetPropertySize()

HRESULT
GpEMFCodec::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    IN OUT PropertyItem* allItems
    )
{
    return E_NOTIMPL;
}// GetAllPropertyItems()

HRESULT
GpEMFCodec::RemovePropertyItem(
    IN PROPID   propId
    )
{
    return E_NOTIMPL;
}// RemovePropertyItem()

HRESULT
GpEMFCodec::SetPropertyItem(
    IN PropertyItem item
    )
{
    return E_NOTIMPL;
}// SetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*     Initiates the decode of the current frame
*
* Arguments:
*
*   decodeSink --  The sink that will support the decode operation
*   newPropSet - New image property sets, if any
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::BeginDecode(
    IN IImageSink* imageSink,
    IN OPTIONAL IPropertySetStorage* newPropSet
    )
{
    if (decodeSink) 
    {
        WARNING(("BeginDecode called again before call to EngDecode"));
        return E_FAIL;
    }

    imageSink->AddRef();
    decodeSink = imageSink;

    return S_OK;
}
    

/**************************************************************************\
*
* Function Description:
*
*     Ends the decode of the current frame
*
* Arguments:
*
*     statusCode -- status of decode operation

* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::EndDecode(
    IN HRESULT statusCode
    )
{
    HRESULT hresult;

    if (!decodeSink) 
    {
        WARNING(("EndDecode called before call to BeginDecode"));
        return E_FAIL;
    }
    
    hresult = decodeSink->EndSink(statusCode);

    decodeSink->Release();
    decodeSink = NULL;

    bReinitializeEMF = TRUE;
    
    return hresult;
}


/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*
*     decodeSink --  The sink that will support the decode operation
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::GetImageInfo(OUT ImageInfo* imageInfoArg)
{
    HRESULT hresult;

    hresult = ReadEMFHeader();
    if (FAILED(hresult)) 
    {
        return hresult;
    }

    *imageInfoArg = imageInfo;

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*
*     decodeSink --  The sink that will support the decode operation
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::Decode()
{
    HRESULT hresult = S_OK;
    void *buffer;

    // If this is the second time through this stream, reinitialize pointer.

    if (bReinitializeEMF) 
    {
        bReadHeader = FALSE;
        if (!pIstream) 
        {
            return E_FAIL;
        }

        LARGE_INTEGER zero = {0,0};
        hresult = pIstream->Seek(zero, STREAM_SEEK_SET, NULL);
        if (!SUCCEEDED(hresult))
        {
            return hresult;
        }
    }

    hresult = ReadEMFHeader();
    if (FAILED(hresult)) 
    {
        return hresult;
    }

    // Allocate a buffer for the metafile

    buffer = GpMalloc(emh.nBytes);
    if (!buffer) 
    {
        return E_OUTOFMEMORY;
    }

    // Copy the metafile header to the start of the buffer

    *((ENHMETAHEADER *) buffer) = emh;

    // Now read the rest of the metafile into the buffer

    void *restOfBuffer = (void *) (((BYTE *) buffer) + sizeof(emh));
    ULONG cbRead;
    hresult = pIstream->Read(restOfBuffer, emh.nBytes - sizeof(emh), &cbRead);
    if (FAILED(hresult)) 
    {
        return hresult;
    }
    if (cbRead != (emh.nBytes - sizeof(emh))) 
    {
        return E_FAIL;
    }

    // Call BeginSink

    hresult = decodeSink->BeginSink(&imageInfo, NULL);
    if (FAILED(hresult)) 
    {
        return hresult;
    }

    // Create memory DC and dibsection

    BITMAPINFO bmi;
    bmi.bmiHeader.biSize     = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth    = imageInfo.Width;
    bmi.bmiHeader.biHeight   = imageInfo.Height;
    bmi.bmiHeader.biPlanes   = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biSizeImage = 0;
    bmi.bmiHeader.biXPelsPerMeter = 0;
    bmi.bmiHeader.biYPelsPerMeter = 0;
    bmi.bmiHeader.biClrUsed = 0;
    bmi.bmiHeader.biClrImportant = 0;

    PBYTE pBits;
    HDC hdcScreen = GetDC(NULL);
    if ( hdcScreen == NULL )
    {
        GpFree(buffer);
        return E_FAIL;
    }

    HDC hdcMem = CreateCompatibleDC(hdcScreen);
    if ( hdcMem == NULL )
    {
        ReleaseDC(NULL, hdcScreen);
        GpFree(buffer);
        return E_FAIL;
    }

    HBITMAP hbitmap = CreateDIBSection(hdcScreen, 
                                       &bmi, 
                                       DIB_RGB_COLORS,
                                        (void **) &pBits, 
                                       NULL, 
                                       0);
    if (!hbitmap) 
    {
        WARNING(("GpEMFCodec::Decode -- failed to create DIBSection"));

        DeleteDC(hdcMem);
        ReleaseDC(NULL, hdcScreen);
        GpFree(buffer);
        return E_OUTOFMEMORY;
    }

    // Initialize background to white

    UINT *p = (UINT *) pBits;
    UINT numPixels = imageInfo.Width * imageInfo.Height;
    UINT i;
    for (i = 0; i < numPixels; i++, p++) 
    {
        *p = 0x00ffffff;
    }

    HBITMAP hOldBitmap = reinterpret_cast<HBITMAP>(SelectObject(hdcMem, hbitmap));
        
    // Create a handle for the metafile backing the bits from the stream

    HENHMETAFILE hemf = SetEnhMetaFileBits(emh.nBytes, (BYTE *) buffer);
    if (!hemf) 
    {
        WARNING(("GpEMFCodec::Decode -- cannot create metafile backing stream bits"));

        DeleteDC(hdcMem);

        HBITMAP hTempBitmap = reinterpret_cast<HBITMAP>(SelectObject(hdcMem,
                                                                   hOldBitmap));
        if ( hTempBitmap != NULL )
        {
            DeleteObject(hTempBitmap);
        }
        ReleaseDC(NULL, hdcScreen);
        GpFree(buffer);
        return E_FAIL;
    }

    // Play the metafile onto the memory DC

    RECT rect;
    rect.left = rect.top = 0;
    rect.right = imageInfo.Width;
    rect.bottom = imageInfo.Height;
    PlayEnhMetaFile(hdcMem, hemf, &rect);
 
    // And finally deliver the bits to the sink

    // ASSERT: The bits are in PIXFMT_32BPP_RGB format (no alpha values)
    
    BitmapData bitmapData;

    bitmapData.Width  = imageInfo.Width;
    bitmapData.Height = 1;
    bitmapData.Stride = bitmapData.Width * 4;
    bitmapData.PixelFormat = PIXFMT_32BPP_ARGB;
    bitmapData.Reserved = 0;

    rect.left  = 0;
    rect.right = imageInfo.Width;

    for (i=0; i < imageInfo.Height; i++) 
    {
        rect.top    = i;
        rect.bottom = i + 1;
        bitmapData.Scan0 = pBits + (imageInfo.Height - i - 1) * bitmapData.Stride;

        // need to fill in the alpha values to make the bits be PIXFMT_32BPP_ARGB format,
        // which is a canonical format.
        UINT j;
        BYTE *ptr;
        for (j = 0, ptr = static_cast<BYTE *>(bitmapData.Scan0);
             j < imageInfo.Width;
             j++, ptr += 4)
        {
            // fill in the alpha value with 0xff
            *(ptr + 3) = 0xff;
        }

        hresult = decodeSink->PushPixelData(&rect, 
                                            &bitmapData,
                                            TRUE);

        if (FAILED(hresult)) 
        {
            WARNING(("GpEMFCodec::Decode -- failed call to PushPixelData"));
            break;
        }
    }    
    
    // Release objects
    
    DeleteEnhMetaFile(hemf);
    DeleteObject(SelectObject(hdcMem, hOldBitmap));
    DeleteDC(hdcMem);
    ReleaseDC(NULL, hdcScreen);
    GpFree(buffer);
    
    return hresult;
}

/**************************************************************************\
*
* Function Description:
*
*     Get the total number of dimensions the image supports
*
* Arguments:
*
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::GetFrameDimensionsCount(
    UINT* count
    )
{
    if ( count == NULL )
    {
        WARNING(("GpEmfCodec::GetFrameDimensionsCount--Invalid input parameter"));
        return E_INVALIDARG;
    }
    
    // Tell the caller that EMF is a one dimension image.

    *count = 1;
    
    return S_OK;
}// GetFrameDimensionsCount()

/**************************************************************************\
*
* Function Description:
*
*     Get an ID list of dimensions the image supports
*
* Arguments:
*
*     dimensionIDs---Memory buffer to hold the result ID list
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::GetFrameDimensionsList(
    GUID*   dimensionIDs,
    UINT    count
    )
{
    if ( (count != 1) || (dimensionIDs == NULL) )
    {
        WARNING(("GpEmfCodec::GetFrameDimensionsList-Invalid input param"));
        return E_INVALIDARG;
    }

    dimensionIDs[0] = FRAMEDIM_PAGE;

    return S_OK;
}// GetFrameDimensionsList()

/**************************************************************************\
*
* Function Description:
*
*     Get number of frames for the specified dimension
*     
* Arguments:
*
*     dimensionID --
*     count --     
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::GetFrameCount(
    IN const GUID* dimensionID,
    OUT UINT* count
    )
{
    if ( (NULL == count) || (*dimensionID != FRAMEDIM_PAGE) )
    {
        return E_INVALIDARG;
    }
    
    *count = 1;

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Select currently active frame
*     
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::SelectActiveFrame(
    IN const GUID* dimensionID,
    IN UINT frameIndex
    )
{
    return E_NOTIMPL;
}



/**************************************************************************\
*
* Function Description:
*
*   Get image thumbnail
*
* Arguments:
*
*   thumbWidth, thumbHeight - Specifies the desired thumbnail size in pixels
*   thumbImage - Returns a pointer to the thumbnail image
*
* Return Value:
*
*   Status code
*
* Note:
*
*   Even if the optional thumbnail width and height parameters are present,
*   the decoder is not required to honor it. The requested size is used
*   as a hint. If both width and height parameters are 0, then the decoder
*   is free to choose an convenient thumbnail size.
*
\**************************************************************************/

HRESULT
GpEMFCodec::GetThumbnail(
    IN OPTIONAL UINT thumbWidth,
    IN OPTIONAL UINT thumbHeight,
    OUT IImage** thumbImage
    )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\bmp\bmpencoder.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   bmpencoder.cpp
*
* Abstract:
*
*   Implementation of the bitmap filter encoder.  This file contains the
*   methods for both the encoder (IImageEncoder) and the encoder's sink
*  (IImageSink).
*
* Revision History:
*
*   5/10/1999 OriG
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "bmpencoder.hpp"


// =======================================================================
// IImageEncoder methods
// =======================================================================

/**************************************************************************\
*
* Function Description:
*
*     Initialize the image encoder
*
* Arguments:
*
*     stream - input stream to write encoded data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
    
STDMETHODIMP
GpBmpEncoder::InitEncoder(
    IN IStream* stream
    )
{
    // Make sure we haven't been initialized already

    if (pIoutStream)
    {
        return E_FAIL;
    }

    // Keep a reference on the input stream

    stream->AddRef();
    pIoutStream = stream;

    return S_OK;
}
        
/**************************************************************************\
*
* Function Description:
*
*     Cleans up the image encoder
*
* Arguments:
*
*     NONE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpEncoder::TerminateEncoder()
{
    // Release the input stream

    if(pIoutStream)
    {
        pIoutStream->Release();
        pIoutStream = NULL;
    }

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Returns a pointer to the vtable of the encoder sink.  The caller will
*     push the bitmap bits into the encoder sink, which will encode the
*     image.
*
* Arguments:
*
*     sink - upon exit will contain a pointer to the IImageSink vtable
*       of this object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpEncoder::GetEncodeSink(
    OUT IImageSink** sink
    )
{
    AddRef();
    *sink = static_cast<IImageSink*>(this);

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Set active frame dimension
*
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpEncoder::SetFrameDimension(
    IN const GUID* dimensionID
    )
{
    return S_OK;
}

HRESULT
GpBmpEncoder::GetEncoderParameterListSize(
    OUT UINT* size
    )
{
    return E_NOTIMPL;
}// GetEncoderParameterListSize()

HRESULT
GpBmpEncoder::GetEncoderParameterList(
    IN  UINT   size,
    OUT EncoderParameters* Params
    )
{
    return E_NOTIMPL;
}// GetEncoderParameterList()

HRESULT
GpBmpEncoder::SetEncoderParameters(
    IN const EncoderParameters* Param
    )
{
    return S_OK;
}// SetEncoderParameters()

// =======================================================================
// IImageSink methods
// =======================================================================

/**************************************************************************\
*
* Function Description:
*
*     Caches the image info structure and initializes the sink state
*
* Arguments:
*
*     imageInfo - information about the image and format negotiations
*     subarea - the area in the image to deliver into the sink, in our
*       case the whole image.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpBmpEncoder::BeginSink(
    IN OUT ImageInfo* imageInfo,
    OUT OPTIONAL RECT* subarea
    )
{
    //Require TOPDOWN and FULLWIDTH
    imageInfo->Flags = imageInfo->Flags | SINKFLAG_TOPDOWN | SINKFLAG_FULLWIDTH;

    //Disallow SCALABLE, PARTIALLY_SCALABLE, MULTIPASS and COMPOSITE
    imageInfo->Flags = imageInfo->Flags & ~SINKFLAG_SCALABLE & ~SINKFLAG_PARTIALLY_SCALABLE & ~SINKFLAG_MULTIPASS & ~SINKFLAG_COMPOSITE;

    encoderImageInfo = *imageInfo;
    bWroteHeader = FALSE;

    if (subarea) 
    {
        // Deliver the whole image to the encoder

        subarea->left = subarea->top = 0;
        subarea->right  = imageInfo->Width;
        subarea->bottom = imageInfo->Height;
    }

    return S_OK;
}
    

/**************************************************************************\
*
* Function Description:
*
*     Cleans up the sink state
*
* Arguments:
*
*     statusCode - the reason why the sink is terminating
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpBmpEncoder::EndSink(
    IN HRESULT statusCode
    )
{
    return statusCode;
}
    
/**************************************************************************\
*
* Function Description:
*
*     Writes the bitmap file headers
*
* Arguments:
*
*     palette - the color palette to put in the bitmap info header (can be
*       NULL)
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpBmpEncoder::WriteHeader(
    IN const ColorPalette* palette
    )
{
    BITMAPFILEHEADER bfh;
    BITMAPINFOHEADER bmih;
    RGBQUAD bmiColors[256];
    UINT numColors = 0; // Number of colors in bmiColors
    HRESULT hresult;
    BOOL bNeedPalette = FALSE;

    if (bWroteHeader) 
    {
        // Already wrote the header

        return S_OK;
    }

    // Setup BITMAPINFOHEADER

    ZeroMemory(&bmih, sizeof(bmih));
    bmih.biSize   = sizeof(bmih);
    bmih.biWidth  = encoderImageInfo.Width;
    bmih.biHeight = encoderImageInfo.Height;
    bmih.biPlanes = 1;
    bmih.biCompression = BI_RGB;

    // 1 inch = 2.54 cm - so scale by 100/2.54 to get pixels per meter from DPI

    bmih.biXPelsPerMeter = (LONG)((encoderImageInfo.Xdpi * 100.0 / 2.54) + 0.5);
    bmih.biYPelsPerMeter = (LONG)((encoderImageInfo.Ydpi * 100.0 / 2.54) + 0.5);

    // Format specific setup work

    if (encoderImageInfo.PixelFormat == PIXFMT_1BPP_INDEXED)
    {
        bmih.biBitCount = 1;
        bNeedPalette = TRUE;
    }
    else if (encoderImageInfo.PixelFormat == PIXFMT_4BPP_INDEXED)
    {
        bmih.biBitCount = 4;
        bNeedPalette = TRUE;
    }
    else if (encoderImageInfo.PixelFormat == PIXFMT_8BPP_INDEXED) 
    {
        bmih.biBitCount = 8;
        bNeedPalette = TRUE;        
    }
    else if (encoderImageInfo.PixelFormat == PIXFMT_16BPP_RGB555) 
    {
        bmih.biBitCount = 16;
    }
    else if (encoderImageInfo.PixelFormat == PIXFMT_16BPP_RGB565) 
    {
        bmih.biBitCount = 16;
        bmih.biCompression = BI_BITFIELDS;
        numColors = 3;
        ((UINT32 *) bmiColors)[0] = 0xf800;
        ((UINT32 *) bmiColors)[1] = 0x07e0;
        ((UINT32 *) bmiColors)[2] = 0x001f;
    }
    else if (encoderImageInfo.PixelFormat == PIXFMT_24BPP_RGB) 
    {
        bmih.biBitCount = 24;
    }
    else if ((encoderImageInfo.PixelFormat == PIXFMT_32BPP_RGB) ||
             (encoderImageInfo.PixelFormat == PIXFMT_32BPP_ARGB) ||
             (encoderImageInfo.PixelFormat == PIXFMT_32BPP_PARGB))
    {
        bmih.biBitCount = 32;
    }
    else if ((encoderImageInfo.PixelFormat == PIXFMT_64BPP_ARGB) ||
         (encoderImageInfo.PixelFormat == PIXFMT_64BPP_PARGB))
    {
        bmih.biBitCount = 64;
    }

    else
    {
        // For other format we'll save as 32BPP RGB.
        
        encoderImageInfo.PixelFormat = PIXFMT_32BPP_RGB;
        bmih.biBitCount = 32;
    }
     
    // Get palette if necessary

    if (bNeedPalette)
    {
        if (!palette) 
        {
            WARNING(("GpBmpEncoder::WriteHeader -- Palette needed but not provided by sink\n"));
            return E_FAIL;
        }

        numColors = palette->Count;
        for (UINT i=0; i<numColors; i++) 
        {
            bmiColors[i] = *((RGBQUAD *) (&palette->Entries[i]));
        }
    
        bmih.biClrUsed = bmih.biClrImportant = numColors;
    }
    
    // Compute the bitmap stride

    bitmapStride = (encoderImageInfo.Width * bmih.biBitCount + 7) / 8;
    bitmapStride = (bitmapStride + 3) & (~3);
    

    // Now fill in the BITMAPFILEHEADER

    bfh.bfType = 0x4d42;
    bfh.bfReserved1 = 0;
    bfh.bfReserved2 = 0;
    bfh.bfOffBits = sizeof(bfh) + sizeof(bmih) + numColors * sizeof(RGBQUAD);
    bfh.bfSize = bfh.bfOffBits + bitmapStride * encoderImageInfo.Height;

    // Write the BITMAPFILEHEADER

    ULONG cbWritten;
    hresult = pIoutStream->Write((void *)&bfh, sizeof(bfh), &cbWritten);
    if (!SUCCEEDED(hresult)) 
    {
        return hresult;
    }
    if (cbWritten != sizeof(bfh)) 
    {
        return E_FAIL;
    }

    // Write the BITMAPINFOHEADER

    hresult = pIoutStream->Write((void *)&bmih, sizeof(bmih), &cbWritten);
    if (!SUCCEEDED(hresult)) 
    {
        return hresult;
    }
    if (cbWritten != sizeof(bmih)) 
    {
        return E_FAIL;
    }

    // Write the bmiColors

    if (numColors) 
    {
        hresult = pIoutStream->Write((void *)bmiColors, numColors * sizeof(RGBQUAD), &cbWritten);
        if (!SUCCEEDED(hresult)) 
        {
            return hresult;
        }
        if (cbWritten != numColors * sizeof(RGBQUAD)) 
            {
            return E_FAIL;
        }
    }

    // Remember offset of data from beginning of stream

    encodedDataOffset = sizeof(bfh) + sizeof (bmih) + numColors * sizeof(RGBQUAD);
    
    bWroteHeader = TRUE;
    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Sets the bitmap palette
*
* Arguments:
*
*     palette - The palette to set in the sink
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpBmpEncoder::SetPalette(
    IN const ColorPalette* palette
    )
{
    return WriteHeader(palette);
}

/**************************************************************************\
*
* Function Description:
*
*     Gives a buffer to the sink where data is to be deposited    
*
* Arguments:
*
*     rect - Specifies the interested area of the bitmap
*     pixelFormat - Specifies the desired pixel format
*     lastPass - Whether this the last pass over the specified area
*     bitmapData - Returns information about pixel data buffer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpEncoder::GetPixelDataBuffer(
    IN const RECT* rect, 
    IN PixelFormatID pixelFormat,
    IN BOOL lastPass,
    OUT BitmapData* bitmapData
    )
{
    HRESULT hresult;
    
    // Write bitmap headers if haven't done so yet
    
    hresult = WriteHeader(NULL);
    if (!SUCCEEDED(hresult)) 
    {
        return hresult;
    }
    
    if ((rect->left != 0) || (rect->right != (LONG) encoderImageInfo.Width)) 
    {
        WARNING(("GpBmpEncoder::GetPixelDataBuffer -- must be same width as image"));
        return E_INVALIDARG;
    }

    if (pixelFormat != encoderImageInfo.PixelFormat)
    {
        WARNING(("GpBmpEncoder::GetPixelDataBuffer -- bad pixel format"));
        return E_INVALIDARG;
    }

    if (!lastPass) 
    {
        WARNING(("GpBmpEncoder::GetPixelDataBuffer -- must receive last pass pixels"));
        return E_INVALIDARG;
    }

    bitmapData->Width       = encoderImageInfo.Width;
    bitmapData->Height      = rect->bottom - rect->top;
    bitmapData->Stride      = bitmapStride;
    bitmapData->PixelFormat = encoderImageInfo.PixelFormat;
    bitmapData->Reserved    = 0;
    
    // Remember the rectangle to be encoded

    encoderRect = *rect;
    
    // Now allocate the buffer where the data will go
    
    if (!lastBufferAllocated) 
    {
        lastBufferAllocated = GpMalloc(bitmapStride * bitmapData->Height);
        if (!lastBufferAllocated) 
        {
            return E_OUTOFMEMORY;
        }
        bitmapData->Scan0 = lastBufferAllocated;
    }
    else
    {
        WARNING(("GpBmpEncoder::GetPixelDataBuffer -- need to first free buffer obtained in previous call"));
        return E_FAIL;
    }


    return S_OK;    
}

/**************************************************************************\
*
* Function Description:
*
*     Write out the data from the sink's buffer into the stream
*
* Arguments:
*
*     bitmapData - Buffer filled by previous GetPixelDataBuffer call
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpEncoder::ReleasePixelDataBuffer(
    IN const BitmapData* bitmapData
    )
{
    HRESULT hresult = S_OK;
    
    // Write one scanline at a time going from bottom to top (make stream
    // writes more sequential).

    INT scanLine;
    for (scanLine = encoderRect.bottom - 1;
         scanLine >= encoderRect.top;
         scanLine--) 
    {
        // Seek to beginning of line

        if (!SeekStreamPos(pIoutStream, STREAM_SEEK_SET,
            encodedDataOffset + (encoderImageInfo.Height - 1 - scanLine) * bitmapStride))
        {
            hresult = E_FAIL;
            break;  // make sure we free bitmapData->scan0 before we return
        }

        // Now write the bits to the stream

        ULONG cbWritten;
        BYTE *pLineBits = ((BYTE *) bitmapData->Scan0) + 
            (scanLine - encoderRect.top) * bitmapData->Stride;
        hresult = pIoutStream->Write((void *) pLineBits, bitmapStride, &cbWritten);
        if (!SUCCEEDED(hresult)) 
        {
            break;  // make sure we free bitmapData->scan0 before we return
        }
        if (cbWritten != (UINT) bitmapStride) 
        {
            hresult = E_FAIL;
            break;  // make sure we free bitmapData->scan0 before we return
        }
    }

    // Free the memory buffer since we're done with it

    if (bitmapData->Scan0 == lastBufferAllocated)
    {
        GpFree(bitmapData->Scan0);
        lastBufferAllocated = NULL;
    }

    return hresult;
}
    

/**************************************************************************\
*
* Function Description:
*
*     Push data into stream (buffer supplied by caller)
*
* Arguments:
*
*     rect - Specifies the affected area of the bitmap
*     bitmapData - Info about the pixel data being pushed
*     lastPass - Whether this is the last pass over the specified area
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpEncoder::PushPixelData(
    IN const RECT* rect,
    IN const BitmapData* bitmapData,
    IN BOOL lastPass
    )
{
    HRESULT hresult;
    
    // Write bitmap headers if haven't done so yet
    
    hresult = WriteHeader(NULL);
    if (!SUCCEEDED(hresult)) 
    {
        return hresult;
    }
    
    encoderRect = *rect;

    if (!lastPass) 
    {
        WARNING(("GpBmpEncoder::PushPixelData -- must receive last pass pixels"));
        return E_INVALIDARG;
    }

    return ReleasePixelDataBuffer(bitmapData);
}


/**************************************************************************\
*
* Function Description:
*
*     Pushes raw compressed data into the .bmp stream.  Not implemented
*     because this filter doesn't understand raw compressed data.
*
* Arguments:
*
*     buffer - Pointer to image data buffer
*     bufsize - Size of the data buffer
*    
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpEncoder::PushRawData(
    IN const VOID* buffer, 
    IN UINT bufsize
    )
{
    return E_NOTIMPL;
}


/**************************************************************************\
*
* Function Description:
*
*     Constructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpBmpEncoder::GpBmpEncoder(
    void
    )
{
    comRefCount   = 1;
    pIoutStream   = NULL;
    lastBufferAllocated = NULL;
}

/**************************************************************************\
*
* Function Description:
*
*     Destructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpBmpEncoder::~GpBmpEncoder(
    void
    )
{
    // The destructor should never be called before Terminate is called, but
    // if it does we should release our reference on the stream anyway to avoid
    // a memory leak.

    if(pIoutStream)
    {
        WARNING(("GpBmpCodec::~GpBmpCodec -- need to call TerminateEncoder first"));
        pIoutStream->Release();
        pIoutStream = NULL;
    }

    if(lastBufferAllocated)
    {
        WARNING(("GpBmpCodec::~GpBmpCodec -- sink buffer not freed"));
        GpFree(lastBufferAllocated);
        lastBufferAllocated = NULL;
    }
}

/**************************************************************************\
*
* Function Description:
*
*     QueryInterface
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP
GpBmpEncoder::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IImageEncoder)
    {    
        *ppv = static_cast<IImageEncoder*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageEncoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     AddRef
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpBmpEncoder::AddRef(
    VOID)
{
    return InterlockedIncrement(&comRefCount);
}

/**************************************************************************\
*
* Function Description:
*
*     Release
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpBmpEncoder::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&comRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\gif\gifbuffer.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*    gifbuffer.cpp
*
* Abstract:
*
*    The GifBuffer class holds gif data that has been uncompressed. It is
*    able to hold data one line at a time or as one large chunk, depending on
*    how it is needed.
*
* Revision History:
*
*    7/9/1999 t-aaronl
*        Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "gifbuffer.hpp"

/**************************************************************************\
*
* Function Description:
*
*     Contructor for GifBuffer
*
* Arguments:
*
*     none
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

GifBuffer::GifBuffer(
    IN IImageSink*      pSink,
    IN RECT             imageDataRect,
    IN RECT             imageRect,
    IN RECT             frameRect,
    IN BOOL             fOneRowAtATime, 
    IN PixelFormatID    pixelFormat, 
    IN ColorPalette*    pColorPalette, 
    IN BOOL             fHasLocalPalette, 
    IN GifFrameCache*   pGifFrameCache, 
    IN BOOL             fSinkData, 
    IN BOOL             fHasTransparentColor,
    IN BYTE             cTransIndex, 
    IN BYTE             cDisposalMethod
    )
{
    SinkPtr               = pSink;
    OriginalImageRect     = imageDataRect;
    OutputImageRect       = imageRect;
    FrameRect             = frameRect;
    IsOneRowAtATime       = fOneRowAtATime;
    DstPixelFormat        = pixelFormat;
    BufferColorPalettePtr = (ColorPalette*)&ColorPaletteBuffer;
    
    GpMemcpy(BufferColorPalettePtr, pColorPalette, 
        offsetof(ColorPalette, Entries) + pColorPalette->Count * sizeof(ARGB));
    
    CurrentFrameCachePtr  = pGifFrameCache;
    NeedSendDataToSink    = fSinkData;
    TransparentIndex      = cTransIndex;
    DisposalMethod        = cDisposalMethod;
    HasTransparentColor   = fHasTransparentColor;

    // Initialize the CurrentFrameCachePtr, if necessary.
    // ASSERT: fHasLocalPalette should be TRUE if and only if there is a
    // local palette associated with the current frame OR BufferColorPalettePtr
    // could be different from the previous color palette (which might
    // be the case if the transparent color index changed in the last gce).
    
    if ( CurrentFrameCachePtr != NULL )
    {
        if ( (CurrentFrameCachePtr->CachePaletteInitialized() == FALSE)
           ||(fHasLocalPalette == TRUE) )
        {
            if ( CurrentFrameCachePtr->SetFrameCachePalette(pColorPalette)
                 == FALSE )
            {
                SetValid(FALSE);
                return;
            }

            DstPixelFormat = CurrentFrameCachePtr->pixformat;
        }
    }

    // Create a BitmapDataBuffer which can holds the whole OutputImageRect. The
    // real memory buffer is pointed by RegionBufferPtr

    BitmapDataBuffer.Width = OutputImageRect.right - OutputImageRect.left;
    
    UINT    uiOriginalImageStride = OriginalImageRect.right
                                  - OriginalImageRect.left;
    BufferStride = BitmapDataBuffer.Width;
    if ( DstPixelFormat == PIXFMT_32BPP_ARGB )
    {
        uiOriginalImageStride = (uiOriginalImageStride << 2);
        BufferStride = (BufferStride << 2);
    }
    
    BitmapDataBuffer.Height = OutputImageRect.bottom - OutputImageRect.top;
    BitmapDataBuffer.Stride = BufferStride;
    BitmapDataBuffer.PixelFormat = DstPixelFormat;
    BitmapDataBuffer.Scan0 = NULL;
    BitmapDataBuffer.Reserved = 0;
    SetValid(TRUE);

    if ( IsOneRowAtATime == FALSE )
    {
        // If we are buffering the whole image then we have to get a pointer to 
        // the buffer that we will use
        
        if ( CurrentFrameCachePtr == NULL )
        {
            RegionBufferPtr = (BYTE*)GpMalloc(BitmapDataBuffer.Stride
                                              * BitmapDataBuffer.Height);
        }
        else
        {
            // If we are in animated mode then use the frame cache's
            // RegionBufferPtr to hold the current data
            
            RegionBufferPtr = CurrentFrameCachePtr->GetBuffer();
        }

        if ( RegionBufferPtr == NULL )
        {
            WARNING(("GifBuffer::GifBuffer---RegionBufferPtr is NULL"));
            SetValid(FALSE);
        }
        else
        {
            BitmapDataBuffer.Scan0 = RegionBufferPtr;
        }
    }// Not one row at a time
    else
    {
        // If it is One Row At A Time, then we don't need a Region Buffer

        RegionBufferPtr = NULL;
    }

    // If it is a multi-framed GIF and Dispose method is 3, then we need to
    // create a restore buffer

    if ( (CurrentFrameCachePtr != NULL) && (DisposalMethod == 3) )
    {
        RestoreBufferPtr = (BYTE*)GpMalloc(BitmapDataBuffer.Stride
                                           * BitmapDataBuffer.Height);
        if ( RestoreBufferPtr == NULL )
        {
            WARNING(("GifBuffer::GifBuffer---RestoreBufferPtr is NULL"));
            SetValid(FALSE);
        }
        else
        {
            // Copy "OutputImageRect" data in the cache to RestoreBufferPtr

            CurrentFrameCachePtr->CopyFromCache(OutputImageRect,
                                                RestoreBufferPtr);
        }
    }
    else
    {
        RestoreBufferPtr = NULL;
    }

    // Allocate bunch of buffers we need

    ScanlineBufferPtr = (BYTE*)GpMalloc(uiOriginalImageStride);
    TempBufferPtr = (BYTE*)GpMalloc(uiOriginalImageStride);
    ExcessBufferPtr = (BYTE*)GpMalloc(uiOriginalImageStride);

    if ( (ScanlineBufferPtr == NULL)
       ||(TempBufferPtr == NULL)
       ||(ExcessBufferPtr == NULL) )
    {
        SetValid(FALSE);
    }

    CurrentRowPtr = NULL;
}// GifBuffer Ctor()

/**************************************************************************\
*
* Function Description:
*
*     Destructor for GifBuffer
*
* Arguments:
*
*     none
*
* Return Value:
*
*     none
*
\**************************************************************************/

GifBuffer::~GifBuffer()
{
    if ( CurrentFrameCachePtr == NULL )
    {
        // Region buffer will be allocated only when CurrentFrameCachePtr is
        // NULL. See the code in the Constructor

        GpFree(RegionBufferPtr);
    }

    BufferColorPalettePtr->Count = 0;

    GpFree(ScanlineBufferPtr);
    GpFree(TempBufferPtr);
    GpFree(ExcessBufferPtr);

    if ( RestoreBufferPtr != NULL )
    {
        // RestoreBufferPtr should be freed in FinishFrame() and set to NULL

        WARNING(("GifBuffer::~GifBuffer---RestoreBufferPtr not null"));
        GpFree(RestoreBufferPtr);
    }

    SetValid(FALSE);                // So we don't use a deleted object
}// GifBuffer Dstor()

/**************************************************************************\
*
* Function Description:
*
*   Sets CurrentRowPtr to point to a buffer from the sink if the GifBuffer is in
*   "one row at a time mode". Otherwise set CurrentRowPtr to point to the whole
*   image buffer where the decompressed data should be written.
*
* Arguments:
*
*     iRow --- Row number to get a pointer to.
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GifBuffer::GetBuffer(
    IN INT iRow
    )
{
    if ( IsOneRowAtATime == TRUE )
    {
        // If it is One Row At A Time, we can ask the sink to allocate the
        // buffer and directly dump the decode result one raw at a time to that
        // buffer

        RECT currentRect = {0,
                            OutputImageRect.top + iRow, 
                            OutputImageRect.right - OutputImageRect.left,
                            OutputImageRect.top + iRow + 1
                           };

        HRESULT hResult = SinkPtr->GetPixelDataBuffer(&currentRect,
                                                      DstPixelFormat, 
                                                      TRUE,
                                                      &BitmapDataBuffer);
        if ( FAILED(hResult) )
        {
            WARNING(("GifBuffer::GetBuffer---GetPixelDataBuffer() failed"));
            return hResult;
        }

        CurrentRowPtr = (UNALIGNED BYTE*)(BitmapDataBuffer.Scan0);

        if ( CurrentFrameCachePtr != NULL )
        {
            // Copy one line of data from the frame cache into CurrentRowPtr

            CurrentFrameCachePtr->FillScanline(CurrentRowPtr, iRow);
        }
    }
    else
    {
        // Not one row at a time.

        if ( CurrentFrameCachePtr == NULL )
        {
            // No frame cache, then use our own RegionBuffer to receive
            // decompressed data

            CurrentRowPtr = RegionBufferPtr + iRow * BufferStride;
        }
        else
        {
            // If there is a frame cache, then we just get a pointer to the
            // current row in the frame cache

            CurrentRowPtr = CurrentFrameCachePtr->GetScanLinePtr(iRow);
        }
    }

    // Remember current row number

    CurrentRowNum = iRow;

    return S_OK;
}// GetBuffer()

/**************************************************************************\
*
* Function Description:
*
*   Sends the buffer to the sink. If the color needs to be converted from 
*   8bppIndexed to 32bppARGB then it uses the 'BufferColorPalettePtr' member
*   variable for the conversion.
*
* Arguments:
*
*     fPadBorder      -- Whether we should pad the borders of the line with
*                        the background color
*     cBackGroundColor-- The color to use if fPadBorder or padLine is TRUE
*     iLine           -- Line to use from the CurrentFrameCachePtr, if necessary
*     fPadLine        -- Whether the entire line should be padded
*                        (with the background color)
*     fSkipLine       -- Whether the entire line should be skipped
*                        (using the CurrentFrameCachePtr to fill in the line)
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GifBuffer::ReleaseBuffer(
    IN BOOL fPadBorder,
    IN BYTE cBackGroundColor,
    IN int  iLine,
    IN BOOL fPadLine,
    IN BOOL fSkipLine
    )
{
    if ( fSkipLine == FALSE )
    {
        if ( CurrentRowPtr == NULL )
        {
            WARNING(("Gif:ReleaseBuffer-GetBuf must be called bef ReleaseBuf"));
            return E_FAIL;
        }
    
        if ( fPadLine == TRUE )
        {
            // Pad the whole line with background color. Result is in
            // CurrentRowPtr

            ASSERT(OutputImageRect.left == 0);

            if ( DstPixelFormat == PIXFMT_8BPP_INDEXED )
            {
                for ( int i = 0; i < OutputImageRect.right; i++ )
                {
                    CurrentRowPtr[i] = cBackGroundColor;
                }
            }
            else
            {
                // 32 bpp ARGB mode

                for ( int i = 0; i < OutputImageRect.right; i++ )
                {
                    ((ARGB*)CurrentRowPtr)[i] =
                        BufferColorPalettePtr->Entries[cBackGroundColor];
                }
            }
        }// ( fPadLine == TRUE )
        else
        {
            // Not pad line case
            // ASSERT: ScanlineBufferPtr now contains all of the pixels in a
            // line of the image. We now copy the correct bits (i.e., accounting
            // for clipping and horizontal padding) of ScanlineBufferPtr to
            // CurrentRowPtr.
    
            int i;

            if ( DstPixelFormat == PIXFMT_8BPP_INDEXED )
            {
                ASSERT(CurrentFrameCachePtr == NULL);

                // Fill the left of the clip region with background color

                for ( i = 0; i < FrameRect.left; i++ )
                {
                    CurrentRowPtr[i] = cBackGroundColor;
                }

                // Fill the clip region with real data

                for ( i = FrameRect.left; i < FrameRect.right; i++ )
                {
                    CurrentRowPtr[i] = ScanlineBufferPtr[i - FrameRect.left];
                }

                // Fill the right of the clip region with background color

                for (i = FrameRect.right; i < OutputImageRect.right; i++)
                {
                    CurrentRowPtr[i] = cBackGroundColor;
                }
            }// 8BPP mode
            else
            {
                // 32 bpp mode

                ASSERT(DstPixelFormat == PIXFMT_32BPP_ARGB);

                BYTE*   pInputBuffer = NULL;
                if ( CurrentFrameCachePtr != NULL )
                {
                    pInputBuffer = CurrentFrameCachePtr->GetScanLinePtr(iLine);
                }

                if ( fPadBorder == TRUE )
                {
                    // Fill the left of the clip region with background color
                    
                    for ( i = 0; i < FrameRect.left; i++ )
                    {
                        ((ARGB*)CurrentRowPtr)[i] =
                               BufferColorPalettePtr->Entries[cBackGroundColor];
                    }

                    // Fill the right of clip region with background color

                    for ( i = FrameRect.right; i < OutputImageRect.right; i++ )
                    {
                        ((ARGB*)CurrentRowPtr)[i] =
                              BufferColorPalettePtr->Entries[cBackGroundColor];
                    }
                }// ( fPadBorder == TRUE )
                else
                {
                    // Not pad board case
                    // Fill the region outside of the clip region with data
                    // from the frame cache if we have one (pInputBuffer!= NULL)

                    if ( pInputBuffer != NULL )
                    {
                        for ( i = 0; i < FrameRect.left; i++ )
                        {
                            ((ARGB*)CurrentRowPtr)[i]= ((ARGB*)pInputBuffer)[i];
                        }

                        for (i = FrameRect.right; i <OutputImageRect.right; i++)
                        {
                            ((ARGB*)CurrentRowPtr)[i]= ((ARGB*)pInputBuffer)[i];
                        }
                    }
                }

                // Now fill the data inside the clip region

                for ( i = FrameRect.left; i < FrameRect.right; i++ )
                {
                    ARGB    argbTemp =
                                ((ARGB*)ScanlineBufferPtr)[i - FrameRect.left];

                    // If there is a frame cache and the pixel is transparent,
                    // then assign the background pixel value to it. Otherwise,
                    // assign the full ARGB value

                    if ( (CurrentFrameCachePtr != NULL)
                       &&((argbTemp & ALPHA_MASK) == 0) )
                    {
                        ((ARGB*)CurrentRowPtr)[i] =((ARGB*)pInputBuffer)[i];
                    }
                    else
                    {
                        ((ARGB*)CurrentRowPtr)[i] = argbTemp;
                    }
                }// Fill data inside clip region
            }// 32 bpp mode
        }// None pad line case
    }// ( fSkipLine == FALSE )

    // ASSERT: CurrentRowPtr now contains exactly the bits needed to release to
    // the sink
    // Update the cache if necessary. This line is the result of the compositing
    // and should be put in the cache if there is one. This will be used to
    // compose the next frame

    if ( CurrentFrameCachePtr != NULL )
    {
        CurrentFrameCachePtr->PutScanline(CurrentRowPtr, CurrentRowNum);
    }

    // Release the line if we are in "One row at a time" mode

    if ( IsOneRowAtATime == TRUE )
    {
        HRESULT hResult = SinkPtr->ReleasePixelDataBuffer(&BitmapDataBuffer);
        if (FAILED(hResult))
        {
            WARNING(("GifBuf::ReleaseBuffer-ReleasePixelDataBuffer() failed"));
            return hResult;
        }
    }

    CurrentRowPtr = NULL;

    return S_OK;
}// ReleaseBuffer()

/**************************************************************************\
*
* Function Description:
*
*     Called after all the data in the frame has been set. Pushes the buffer.
*
* Arguments:
*
*     fLastFrame is FALSE if the image is multipass and this is not the last 
*     pass. It is TRUE otherwise (default is TRUE).
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GifBuffer::FinishFrame(
    IN BOOL fLastFrame
    )
{
    HRESULT hResult;

    // Check if we still have a line need to draw into

    if ( CurrentRowPtr != NULL )
    {        
        WARNING(("Buf::FinishFrame-ReleaseBuf must be called bef FinishFrame"));
        
        // Release the last line

        hResult = ReleaseBuffer(FALSE,          // Don't pad the board
                                0,              // Background color
                                0,              // Line number
                                FALSE,          // Don't pad the line
                                FALSE);         // Don't skip the line
        if ( FAILED(hResult) )
        {
            WARNING(("GifBuffer::FinishFrame---ReleaseBuffer() failed"));
            return hResult;
        }
    }

    if ( (IsOneRowAtATime == FALSE) && (NeedSendDataToSink == TRUE) )
    {
        // Send all the data down to the sink at once

        ASSERT(BitmapDataBuffer.Scan0 == RegionBufferPtr);
        hResult = SinkPtr->PushPixelData(&OutputImageRect, &BitmapDataBuffer,
                                         fLastFrame);
        if ( FAILED(hResult) )
        {
            WARNING(("GifBuffer::FinishFrame---PushPixelData() failed"));
            return hResult;
        }
    }

    if ( fLastFrame == TRUE )
    {
        if ( DisposalMethod == 3 )
        {
            // Restore from last frame

            ASSERT(RestoreBufferPtr);
            CurrentFrameCachePtr->CopyToCache(FrameRect, RestoreBufferPtr);
            GpFree(RestoreBufferPtr);
            RestoreBufferPtr = NULL;
        }
        else if ( DisposalMethod == 2 )
        {
            // Restore to background

            CurrentFrameCachePtr->ClearCache(FrameRect);
        }
    }

    return S_OK;
}// FinishFrame()

/**************************************************************************\
*
* Function Description:
*
*   Gets all scanlines from 'top' to 'bottom', fills them with 'color' then 
*   releases them.
*
* Arguments:
*
*   Top and bottom bounds and the fill color.
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GifBuffer::PadScanLines(
    IN INT  iTopLine,
    IN INT  iBottomLine,
    IN BYTE color
    )
{
    for ( INT y = iTopLine; y <= iBottomLine; y++ )
    {
        HRESULT hResult = GetBuffer(y);
        if ( FAILED(hResult) )
        {
            WARNING(("GifBuffer::PadScanLines---GetBuffer() failed"));
            return hResult;
        }

        if ( DstPixelFormat == PIXFMT_8BPP_INDEXED )
        {
            GpMemset(ScanlineBufferPtr, color,
                     OriginalImageRect.right - OriginalImageRect.left);
        }
        else
        {
            ASSERT(DstPixelFormat == PIXFMT_32BPP_ARGB);
            for (int i = 0;
                 i < (OriginalImageRect.right - OriginalImageRect.left); i++)
            {
                ((ARGB*)(ScanlineBufferPtr))[i] =
                                BufferColorPalettePtr->Entries[color];
            }
        }

        hResult = ReleaseBuffer(FALSE,          // Don't pad the board
                                color,          // Background color
                                y,              // Line number
                                TRUE,           // Pad the line
                                FALSE);         // Don't skip the line
        if ( FAILED(hResult) )
        {
            WARNING(("GifBuffer::PadScanLines---ReleaseBuffer() failed"));
            return hResult;
        }
    }

    return S_OK;
}// PadScanLines()

/**************************************************************************\
*
* Function Description:
*
*     Gets all scanlines from 'top' to 'bottom' then releases them.
*
* Arguments:
*
*     Top and bottom bounds.
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GifBuffer::SkipScanLines(
    IN INT top,
    IN INT bottom
    )
{
    for ( INT y = top; y <= bottom; y++ )
    {
        HRESULT hResult = GetBuffer(y);
        if (FAILED(hResult))
        {
            WARNING(("GifBuffer::SkipScanLines---GetBuffer() failed"));
            return hResult;
        }

        hResult = ReleaseBuffer(FALSE, 0, 0, FALSE, TRUE);
        if (FAILED(hResult))
        {
            WARNING(("GifBuffer::SkipScanLines---ReleaseBuffer() failed"));
            return hResult;
        }
    }

    return S_OK;
}// SkipScanLines()

/**************************************************************************\
*
* Function Description:
*
*     CopyLine makes a copy of the current line, releases it, gets the next 
*     line and puts the data from the first line into the new one.  The new 
*     one still needs to be released.  This function invalidates any copy of 
*     the pointer to the data that the caller may have.  The caller must 
*     GetCurrentBuffer() to refresh the pointer to the data.
*
* Arguments:
*
*     none
*
* Return Value:
*
*     none
*
\**************************************************************************/

STDMETHODIMP
GifBuffer::CopyLine()
{
    HRESULT hResult = S_OK;

    if ( CurrentRowNum < OutputImageRect.bottom - 1 )
    {
        UINT    uiDstPixelSize = 1;

        if ( DstPixelFormat == PIXFMT_32BPP_ARGB )
        {
            uiDstPixelSize = (uiDstPixelSize << 2);
        }

        ASSERT(TempBufferPtr != NULL);

        GpMemcpy(TempBufferPtr, ScanlineBufferPtr,
                (OriginalImageRect.right - OriginalImageRect.left)
                 * uiDstPixelSize);

        // Sends the buffer to the sink

        hResult = ReleaseBuffer(FALSE,          // Don't pad the board
                                0,              // Background color
                                0,              // Line number
                                FALSE,          // Don't pad the line
                                FALSE);         // Don't skip the line
    
        if ( SUCCEEDED(hResult) )
        {
            // Sets CurrentRowPtr to an approprite buffer

            hResult = GetBuffer(CurrentRowNum + 1);
        }
        
        GpMemcpy(ScanlineBufferPtr, TempBufferPtr,
                (OriginalImageRect.right - OriginalImageRect.left)
                 * uiDstPixelSize);
    }

    return hResult;
}// CopyLine()

/**************************************************************************\
*
* Function Description:
*
*     This function assumes that the buffer that contains the relevant
*     data for the current scanline (ScanlineBufferPtr) contains
*     (8BPP) indexes.  This function uses the color palette to convert the
*     buffer into ARGB values.
*
* Arguments:
*
*     none
*
* Return Value:
*
*     none
*
\**************************************************************************/

void
GifBuffer::ConvertBufferToARGB()
{
    if ( HasTransparentColor == TRUE )
    {
        for ( int i = OriginalImageRect.right - OriginalImageRect.left - 1;
              i >= 0; i--)
        {
            // If the index equals the transparent index, then set the pixel as
            // transparent. Otherwise, get the real ARGB value from the palette
            //
            // Note: ScanlineBufferPtr is allocated in the constructor. The
            // pixel format has been taken into consideration. So we have
            // allocated enough bytes for 32 ARGB case. So we won't write out
            // the memory bounds.
            // Note: Writing over ScanlineBufferPtr works because we start from
            // the end of the buffer and move backwards.

            if ( ((BYTE*)ScanlineBufferPtr)[i] == TransparentIndex )
            {
                ((ARGB*)ScanlineBufferPtr)[i] = 0x00000000;
            }
            else
            {
                ((ARGB*)(ScanlineBufferPtr))[i] =
                  BufferColorPalettePtr->Entries[((BYTE*)ScanlineBufferPtr)[i]];
            }
        }
    }
    else
    {
        for ( int i = OriginalImageRect.right - OriginalImageRect.left - 1;
              i >= 0; i--)
        {
            ((ARGB*)(ScanlineBufferPtr))[i] =
                  BufferColorPalettePtr->Entries[((BYTE*)ScanlineBufferPtr)[i]];
        }
    }
}// ConvertBufferToARGB()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\emf\emfcodec.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   emfcodec.hpp
*
* Abstract:
*
*   Header file for the EMF encoder/decoder
*
* Revision History:
*
*   6/14/1999 OriG
*       Created it.
*
\**************************************************************************/

class GpEMFCodec : public IImageDecoder
{
private:

    // =====================================================
    // Decoder privates
    // =====================================================

    IStream *pIstream;
    IImageSink* decodeSink;
    ImageInfo imageInfo;
    ENHMETAHEADER emh;
    BOOL bReadHeader;
    BOOL bReinitializeEMF;
    
protected:
    LONG comRefCount;       // COM object reference count    

public:

    // Constructor and Destructor
    
    GpEMFCodec::GpEMFCodec(void);
    GpEMFCodec::~GpEMFCodec(void);

    // IImageDecoder methods
    
    STDMETHOD(InitDecoder)(IN IStream* stream, IN DecoderInitFlag flags);
    STDMETHOD(TerminateDecoder) ();
    STDMETHOD(BeginDecode)(IN IImageSink* imageSink, IN OPTIONAL IPropertySetStorage* newPropSet);
    STDMETHOD(Decode)();
    STDMETHOD(EndDecode)(IN HRESULT statusCode);
    STDMETHOD(GetFrameDimensionsCount)(OUT UINT* count);
    STDMETHOD(GetFrameDimensionsList)(OUT GUID* dimensionIDs,IN OUT UINT count);
    STDMETHOD(GetFrameCount)(IN const GUID* dimensionID, OUT UINT* count);
    STDMETHOD(SelectActiveFrame)(IN const GUID* dimensionID, 
        IN UINT frameIndex);
    STDMETHOD(GetImageInfo)(OUT ImageInfo* imageInfo);
    STDMETHOD(GetThumbnail)(IN OPTIONAL UINT thumbWidth, IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage);
    STDMETHOD(QueryDecoderParam)(IN GUID Guid);
    STDMETHOD(SetDecoderParam)(IN GUID Guid, IN UINT Length, IN PVOID Value);
    STDMETHOD(GetPropertyCount)(OUT UINT* numOfProperty);
    STDMETHOD(GetPropertyIdList)(IN UINT numOfProperty,IN OUT PROPID* list);
    STDMETHOD(GetPropertyItemSize)(IN PROPID propId, OUT UINT* size);    
    STDMETHOD(GetPropertyItem)(IN PROPID propId, IN UINT propSize,
                               IN OUT PropertyItem* buffer);
    STDMETHOD(GetPropertySize)(OUT UINT* totalBufferSize,
                               OUT UINT* numProperties);
    STDMETHOD(GetAllPropertyItems)(IN UINT totalBufferSize,
                                   IN UINT numProperties,
                                   IN OUT PropertyItem* allItems);
    STDMETHOD(RemovePropertyItem)(IN PROPID propId);
    STDMETHOD(SetPropertyItem)(IN PropertyItem item);
    STDMETHOD(GetRawInfo)(IN OUT void** info)
    {
        return E_NOTIMPL;
    }
    
    STDMETHOD(ReadEMFHeader());
    
    // IUnknown methods

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\bmp\bmpdecoder.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   bmpdecoder.hpp
*
* Abstract:
*
*   Header file for the bitmap decoder
*
* Revision History:
*
*   5/13/1999 OriG (Ori Gershony)
*       Created it.
*
*   2/7/2000  OriG (Ori Gershony)
*       Move encoder and decoder into separate classes
*
\**************************************************************************/

class GpBmpDecoder : public IImageDecoder
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagBmpDecoder) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid BmpDecoder");
        }
    #endif

        return (Tag == ObjectTagBmpDecoder);
    }
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagBmpDecoder : ObjectTagInvalid;
    }

private:
    
    IStream *pIstream;
    IImageSink* decodeSink;
    ColorPalette *pColorPalette;

    BITMAPFILEHEADER bmfh;

    HBITMAP hBitmapGdi; // bitmap for GDI to render into (from RLE)
    VOID *pBitsGdi;     // bits pointer for above bitmap
    BOOL IsTopDown;     // indicates top-down instead of GDI default bottom-up
    
    // Bitmap info header and color table
    struct 
    {
        BITMAPV5HEADER header;  // this is allowed to be a BITMAPINFOHEADER or
                                // a BITMAPV4HEADER.  bV5Size determines what
                                // kind of header it really is.
        RGBQUAD colors[256];
    } bmiBuffer;

    BOOL bReadHeaders;
    BOOL bCalledBeginSink;
    INT currentLine;

    HRESULT ReadBitmapHeaders(void);
    UINT GetColorTableCount(void);
    HRESULT SetBitmapPalette();
    PixelFormatID GetPixelFormatID(void);
    STDMETHODIMP DecodeFrame(IN ImageInfo& imageInfo);
    STDMETHODIMP ReadLine(IN VOID *pBits, IN INT currentLine, 
                          IN ImageInfo imageInfo);
    STDMETHODIMP ReadLine_BI_RGB(IN VOID *pBits, IN INT currentLine, 
                                 IN ImageInfo imageInfo);
    STDMETHODIMP ReadLine_GDI(IN VOID *pBits, IN INT currentLine, 
                              IN ImageInfo imageInfo);
    STDMETHODIMP GenerateGdiBits(IN ImageInfo imageInfo);

protected:
    LONG comRefCount;       // COM object reference count    

public:
    
    // Constructor and Destructor
    
    GpBmpDecoder(void);
    ~GpBmpDecoder(void);

    // IImageDecoder methods
    
    STDMETHOD(InitDecoder)(IN IStream* stream, IN DecoderInitFlag flags);
    STDMETHOD(TerminateDecoder) ();
    STDMETHOD(BeginDecode)(IN IImageSink* imageSink, IN OPTIONAL IPropertySetStorage* newPropSet);
    STDMETHOD(Decode)();
    STDMETHOD(EndDecode)(IN HRESULT statusCode);
    STDMETHOD(GetFrameDimensionsCount)(OUT UINT* count);
    STDMETHOD(GetFrameDimensionsList)(OUT GUID* dimensionIDs,IN OUT UINT count);
    STDMETHOD(GetFrameCount)(IN const GUID* dimensionID, OUT UINT* count);
    STDMETHOD(SelectActiveFrame)(IN const GUID* dimensionID, 
        IN UINT frameIndex);
    STDMETHOD(GetImageInfo)(OUT ImageInfo* imageInfo);
    STDMETHOD(GetThumbnail)(IN OPTIONAL UINT thumbWidth, IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage);
    STDMETHOD(QueryDecoderParam)(IN GUID Guid);
    STDMETHOD(SetDecoderParam)(IN GUID Guid, IN UINT Length, IN PVOID Value);
    STDMETHOD(GetPropertyCount)(OUT UINT* numOfProperty);
    STDMETHOD(GetPropertyIdList)(IN UINT numOfProperty,IN OUT PROPID* list);
    STDMETHOD(GetPropertyItemSize)(IN PROPID propId, OUT UINT* size);    
    STDMETHOD(GetPropertyItem)(IN PROPID propId, IN UINT propSize,
                               IN OUT PropertyItem* buffer);
    STDMETHOD(GetPropertySize)(OUT UINT* totalBufferSize,
                               OUT UINT* numProperties);
    STDMETHOD(GetAllPropertyItems)(IN UINT totalBufferSize,
                                   IN UINT numProperties,
                                   IN OUT PropertyItem* allItems);
    STDMETHOD(RemovePropertyItem)(IN PROPID propId);
    STDMETHOD(SetPropertyItem)(IN PropertyItem item);
    STDMETHOD(GetRawInfo)(IN OUT void** info)
    {
        return E_NOTIMPL;
    }
    
    // IUnknown methods

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\bmp\bmpencoder.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   bmpencoder.hpp
*
* Abstract:
*
*   Header file for the bitmap encoder
*
* Revision History:
*
*   5/13/1999 OriG (Ori Gershony)
*       Created it.
*
*   2/7/2000  OriG (Ori Gershony)
*       Move encoder and decoder into separate classes
*
\**************************************************************************/

class GpBmpEncoder : public IImageEncoder, public IImageSink
{
private:
    
    IStream *pIoutStream;
    ImageInfo encoderImageInfo;
    BOOL bWroteHeader;
    RECT encoderRect;       // Area to be encoded next
    INT encodedDataOffset;  // offset of data from beginning of stream
    VOID *lastBufferAllocated;
    INT bitmapStride;

    STDMETHODIMP WriteHeader(IN const ColorPalette* palette);

protected:
    LONG comRefCount;       // COM object reference count    

public:

    // Constructor and Destructor
    
    GpBmpEncoder::GpBmpEncoder(void);
    GpBmpEncoder::~GpBmpEncoder(void);

    // IImageEncoder methods

    STDMETHOD(InitEncoder)(IN IStream* stream);
    STDMETHOD(TerminateEncoder)();
    STDMETHOD(GetEncodeSink)(OUT IImageSink** sink);
    STDMETHOD(SetFrameDimension)(IN const GUID* dimensionID);
    STDMETHOD(GetEncoderParameterListSize)(OUT UINT* size);
    STDMETHOD(GetEncoderParameterList)(IN UINT	  size,
                                       OUT EncoderParameters* Params);
    STDMETHOD(SetEncoderParameters)(IN const EncoderParameters* Param);

    STDMETHOD(NeedTransform(OUT UINT* rotation))
    {
        return E_NOTIMPL;
    }
    
    STDMETHOD(NeedRawProperty)(void *pSRc)
    {
        // BMP can't handle raw property when saving for now

        return E_FAIL;
    }
    
    STDMETHOD(PushRawInfo)(IN void* info)
    {
        return E_NOTIMPL;
    }

    STDMETHOD(GetPropertyBuffer)(
        IN     UINT            uiTotalBufferSize,
        IN OUT PropertyItem**  ppBuffer
        )
    {
        return E_NOTIMPL;
    }
    
    STDMETHOD(PushPropertyItems)(
        IN UINT             numOfItems,
        IN UINT             uiTotalBufferSize,
        IN PropertyItem*    item,
        IN BOOL             fICCProfileChanged
        )
    {
        return E_NOTIMPL;
    }

    // IImageSink methods (sink for encoder)

    STDMETHOD(BeginSink)(IN OUT ImageInfo* imageInfo, 
        OUT OPTIONAL RECT* subarea);
    STDMETHOD(EndSink)(IN HRESULT statusCode);
    STDMETHOD(SetPalette)(IN const ColorPalette* palette);
    STDMETHOD(GetPixelDataBuffer)(IN const RECT* rect, 
        IN PixelFormatID pixelFormat, IN BOOL lastPass,
        OUT BitmapData* bitmapData);
    STDMETHOD(ReleasePixelDataBuffer)(IN const BitmapData* bitmapData);
    STDMETHOD(PushRawData)(IN const VOID* buffer, IN UINT bufsize);
    STDMETHOD(PushPixelData)(IN const RECT* rect,
        IN const BitmapData* bitmapData, IN BOOL lastPass);

    // IUnknown methods

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\gif\gifbuffer.hpp ===
#pragma once

/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*    gifbuffer.hpp
*
* Abstract:
*
*    The GifBuffer class holds gif data that has been uncompressed.  It is
*    able to hold data one line at a time or as one large chunk, depending on
*    how it is needed.
*
* Revision History:
*
*    7/7/1999 t-aaronl
*        Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "gifframecache.hpp"

class GifBuffer
{
public:
    GifBuffer(IN IImageSink* _sink,
              IN RECT _imagedatarect,
              IN RECT _imagerect,
              IN RECT _framerect,
              IN BOOL _onerowatatime,
              IN PixelFormatID _pixelformat,
              IN ColorPalette *_colorpalette,
              IN BOOL haslocalpalette,
              IN GifFrameCache *gifframecache,
              IN BOOL _sinkdata,
              IN BOOL usetransparency,
              IN BYTE _transindex,
              IN BYTE _disposalmethod);
    ~GifBuffer();

    STDMETHOD(GetBuffer)(IN INT row);
    STDMETHOD(ReleaseBuffer)(IN BOOL padBorder,
                             IN BYTE backgroundColor,
                             IN int line,
                             IN BOOL padLine,
                             IN BOOL skipLine);
    STDMETHOD(FinishFrame)(IN BOOL lastframe = TRUE);
    STDMETHOD(PadScanLines)(INT top, INT bottom, BYTE color);
    STDMETHOD(SkipScanLines)(INT top, INT bottom);
    STDMETHOD(CopyLine)();

    // Returns a pointer to where the uncompressed data should be written to.

    BYTE*   GetCurrentBuffer()
    {
        return ScanlineBufferPtr;
    }

    // Returns a pointer to where the uncompressed data should be written to
    // in the case where we are not actually rendering the output line.

    BYTE*   GetExcessBuffer()
    {
        return ExcessBufferPtr;
    }

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagGifBuffer) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid GifBuffer");
        }
    #endif

        return (Tag == ObjectTagGifBuffer);
    }
    void ConvertBufferToARGB();

private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    
    ObjectTag           Tag;        // Keep this as the 1st value in the object!

    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagGifBuffer : ObjectTagInvalid;
    }

    BitmapData  BitmapDataBuffer;   // Holds info and data to be passed to the
                                    // sink
    BYTE ColorPaletteBuffer[offsetof(ColorPalette, Entries)
                            + sizeof(ARGB) * 256];
    ColorPalette* BufferColorPalettePtr;
                                    // Current color palette in the GIF buffer
    IImageSink* SinkPtr;            // The sink that this buffer is talking to
    GifFrameCache* CurrentFrameCachePtr;
                                    // A cache of the all of the data currently
                                    //   decoded between frames
    RECT    OriginalImageRect;      // Original image data's dimensions
    RECT    OutputImageRect;        // The output image's full dimensions
    RECT    FrameRect;              // OriginalImageRect, clipped to
                                    //   OutputImageRect
    PixelFormatID DstPixelFormat;   // Pixelformat that the sink wants
    UINT    BufferStride;           // Byte offset of the next line in the
                                    //   buffer
    INT     CurrentRowNum;          // The number of the row that is currently
                                    //   being drawn into
    BYTE*   RegionBufferPtr;        // Beginning of the region being drawn into
    UNALIGNED BYTE* CurrentRowPtr;  // Points to the beginning of the row that
                                    //   is currently being drawn into
    BYTE*   ScanlineBufferPtr;      // The output of the decompressor is placed
                                    // here before being copied to CurrentRowPtr
    BYTE*   TempBufferPtr;          // Same as ScanlineBufferPtr, except this is
                                    //   used when HasTransparentColor is TRUE
    BYTE*   ExcessBufferPtr;        // Buffer for lines that won't be rendered
    BYTE*   RestoreBufferPtr;       // Buffer containing info from the last
                                    //   frame drawn for purposes of replacing
                                    //   the current data according to the gif's
                                    //   disposal method
    BYTE    TransparentIndex;       // Index of the transparent color if there
                                    //   is one
    BYTE    DisposalMethod;         // 0-1: leave as is,
                                    // 2:replace w/ background,
                                    // 3: replace w/ previous frame
    BOOL    IsOneRowAtATime;        // TRUE: one row will be sent to the sink at
                                    //   a time, in ReleaseBuffer()
                                    // FALSE: data will be buffered and sent in
                                    //   one chunk in FinishFrame()
    BOOL    NeedSendDataToSink;     // TRUE: data should be sent to the sink
    BOOL    HasTransparentColor;    // TRUE: current frame has a transparent
                                    //   color
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\gif\gifcodec.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   gifcodec.cpp
*
* Abstract:
*
*   Shared methods for the gif codec
*
* Revision History:
*
*   5/13/1999 t-aaronl
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "gifcodec.hpp"

// Create an instance of gif codec object

HRESULT CreateCodecInstance(REFIID iid, VOID** codec)
{
    HRESULT hr;
    GpGifCodec *GifCodec = new GpGifCodec();

    if (GifCodec != NULL)
    {
        hr = GifCodec->QueryInterface(iid, codec);
        GifCodec->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *codec = NULL;
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*     Constructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpGifCodec::GpGifCodec(
    void
    )
{
    comRefCount = 1;
    istream = NULL;
    decodeSink = NULL;
    HasCodecInitialized = FALSE;
    HasCalledBeginDecode = FALSE;
    GifFrameCachePtr = NULL;
    IsAnimatedGif = FALSE;
    IsMultiImageGif = FALSE;
    FrameDelay = 0;
    HasLoopExtension = FALSE;
    TotalNumOfFrame = -1;
    moreframes = TRUE;
    currentframe = -1;
    firstdecode = TRUE;
    colorpalette = (ColorPalette*)&colorpalettebuffer;

    IncrementComComponentCount();
}

/**************************************************************************\
*
* Function Description:
*
*     Destructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpGifCodec::~GpGifCodec(
    void
    )
{
    // The destructor should never be called before Terminate is called, but
    // if it does we should release our reference on the stream anyway to avoid
    // a memory leak.

    if(istream)
    {
        WARNING(("GpGifCodec::~GpGifCodec -- need to call TerminateDecoder first"));
        istream->Release();
        istream = NULL;
    }

    DecrementComComponentCount();
}

/**************************************************************************\
*
* Function Description:
*
*     QueryInterface
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IImageDecoder)
    {
        *ppv = static_cast<IImageDecoder*>(this);
    }
    else if (riid == IID_IImageEncoder)
    {    
        *ppv = static_cast<IImageEncoder*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageDecoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     AddRef
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpGifCodec::AddRef(
    VOID)
{
    return InterlockedIncrement(&comRefCount);
}

/**************************************************************************\
*
* Function Description:
*
*     Release
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpGifCodec::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&comRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\gif\giffile.h ===
#pragma once

/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   giffile.hpp
*
* Abstract:
*
*   Header file with gif file structures.
*
* Revision History:
*
*   6/8/1999 t-aaronl
*       Created it.
*
\**************************************************************************/


#define GIFPLAINTEXTEXTENSIONSIZE 13
#define GIFAPPEXTENSIONHEADERSIZE 11

#pragma pack(1)

struct GifFileHeader  //13 bytes
{
    BYTE signature[6];
    WORD LogicScreenWidth;
    WORD LogicScreenHeight;
    BYTE globalcolortablesize: 3;  //bit fields in reverse significant order
    BYTE sortflag: 1;
    BYTE colorresolution: 3;
    BYTE globalcolortableflag: 1;  // <- most significant
    BYTE backgroundcolor;
    BYTE pixelaspect;
};

struct GifPaletteEntry
{
    BYTE red;
    BYTE green;
    BYTE blue;
};

struct GifColorTable  //palette is up to 3*256 BYTEs
{
    GifPaletteEntry colors[256];
};

struct GifImageDescriptor  //9 bytes
{
  //BYTE imageseparator;  //=0x2C
    WORD left;
    WORD top;
    WORD width;
    WORD height;
    BYTE localcolortablesize: 3;  //bit fields in reverse significant order
    BYTE reserved: 2;
    BYTE sortflag: 1;
    BYTE interlaceflag: 1;
    BYTE localcolortableflag: 1;  // <- most significant
};

struct GifGraphicControlExtension  //6 bytes
{
  //BYTE extensionintroducer;  //=0x21
  //BYTE graphiccontrollabel;  //=0xF9
    BYTE blocksize;
    BYTE transparentcolorflag: 1;  //bit fields in reverse significant order
    BYTE userinputflag: 1;
    BYTE disposalmethod: 3;
    BYTE reserved: 3;  // <- most significant

    WORD delaytime;  //in hundreths of a second
    BYTE transparentcolorindex;
};

#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\gif\gifconst.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   gifconst.cpp
*
* Abstract:
*
*   Constant data related to GIF codec
*
* Revision History:
*
*   06/16/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GIFCONST_CPP
#define _GIFCONST_CPP

#define GIFVERSION 1

#define GIFSIGCOUNT 2
#define GIFSIGSIZE  6

const BYTE GIFHeaderPattern[GIFSIGCOUNT*GIFSIGSIZE] =
{
    0x47, 0x49, 0x46,  //'GIF'
    0x38, 0x39, 0x61,  //'89a'

    0x47, 0x49, 0x46,  //'GIF'
    0x38, 0x37, 0x61   //'87a'
};

const BYTE GIFHeaderMask[GIFSIGCOUNT*GIFSIGSIZE] =
{
    0xff, 0xff, 0xff,
    0xff, 0xff, 0xff,

    0xff, 0xff, 0xff,
    0xff, 0xff, 0xff
};

const CLSID GifCodecClsID =
{
    0x557cf402,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

#endif // !_GIFCONST_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\gif\gifencoder.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   gifencoder.cpp
*
* Abstract:
*
*   Implementation of the gif filter encoder.  This file contains the
*   methods for both the encoder (IImageEncoder) and the encoder's sink
*   (IImageSink).
*
* Revision History:
*
*   6/9/1999 t-aaronl
*       Created it from OriG's template
*
\**************************************************************************/

#include "precomp.hpp"
#include "gifcodec.hpp"

/**************************************************************************\
*
* Function Description:
*
*     Initialize the image encoder
*
* Arguments:
*
*     stream - input stream to write encoded data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::InitEncoder(IN IStream* stream)
{
    //Check to see if this decoder or encoder is already initialized
    if (HasCodecInitialized)
    {
        WARNING(("Encoder already initialized."));
        return E_FAIL;
    }
    HasCodecInitialized = TRUE;

    // Make sure we haven't been initialized already
    if (istream)
    {
        WARNING(("Encoder already initialized."));
        return E_FAIL;
    }

    // Keep a reference on the input stream
    stream->AddRef();
    istream = stream;

    HasCalledBeginDecode = FALSE;
    headerwritten = FALSE;
    bTransparentColorIndex = FALSE;
    transparentColorIndex = 0;
    compressionbuffer = NULL;

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Cleans up the image encoder
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::TerminateEncoder()
{
    if (!HasCodecInitialized)
    {
        WARNING(("Encoder not initialized."));
        return E_FAIL;
    }
    HasCodecInitialized = FALSE;
    
    // Release the input stream
    if (istream)
    {
        istream->Release();
        istream = NULL;
    }

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Returns a pointer to the vtable of the encoder sink.  The caller will
*     push the bitmap bits into the encoder sink, which will encode the
*     image.
*
* Arguments:
*
*     sink - upon exit will contain a pointer to the IImageSink vtable
*       of this object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::GetEncodeSink(
    OUT IImageSink** sink
    )
{
    AddRef();
    *sink = static_cast<IImageSink*>(this);

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Set active frame dimension
*
* Arguments:
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::SetFrameDimension(
    IN const GUID* dimensionID
    )
{
    return E_NOTIMPL;
}

HRESULT
GpGifCodec::GetEncoderParameterListSize(
    OUT UINT* size
    )
{
    return E_NOTIMPL;
}// GetEncoderParameterListSize()

HRESULT
GpGifCodec::GetEncoderParameterList(
    IN  UINT   size,
    OUT EncoderParameters* Params
    )
{
    return E_NOTIMPL;
}// GetEncoderParameterList()

HRESULT
GpGifCodec::SetEncoderParameters(
    IN const EncoderParameters* Param
    )
{
    return E_NOTIMPL;
}// SetEncoderParameters()

/**************************************************************************\
*
* Function Description:
*
*     Caches the image info structure and initializes the sink state
*
* Arguments:
*
*     imageInfo - information about the image and format negotiations
*     subarea - the area in the image to deliver into the sink, in our
*       case the whole image.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpGifCodec::BeginSink(
    IN OUT ImageInfo* imageInfo,
    OUT OPTIONAL RECT* subarea
    )
{
    HRESULT hresult;
    
    if ( HasCalledBeginDecode)
    {
        WARNING(("BeginSink called twice without a EndSink between."));
        return E_FAIL;
    }
    HasCalledBeginDecode = TRUE;

    //TODO: actually find out if the image is interlaced from the metadata instead of just setting it to false
    interlaced = FALSE;

    if (!subarea) 
    {
        // Deliver the whole image to the encoder
        encoderrect.left = 0;
        encoderrect.top = 0;
        encoderrect.right = imageInfo->Width;
        encoderrect.bottom = imageInfo->Height;
    }
    else
    {
        // !!! This else code does the same thing as the if part.
        // !!! Need to investigate what the GIF code can handle here.
        subarea->left = subarea->top = 0;
        subarea->right  = imageInfo->Width;
        subarea->bottom = imageInfo->Height;
        encoderrect = *subarea;
    }

    //The data is pushed in top-down order so the currentline is the next line 
    //of data that we expect.
    currentline = encoderrect.top;

    //Tell the source just what we can do

    if (imageInfo->PixelFormat != PIXFMT_8BPP_INDEXED)
    {
        imageInfo->PixelFormat = PIXFMT_32BPP_ARGB;
        from32bpp = TRUE;
    }
    else
    {
        from32bpp = FALSE;
    }

    //Require TOPDOWN and FULLWIDTH
    imageInfo->Flags = imageInfo->Flags | SINKFLAG_TOPDOWN | SINKFLAG_FULLWIDTH;

    //Disallow SCALABLE, PARTIALLY_SCALABLE, MULTIPASS and COMPOSITE
    imageInfo->Flags = imageInfo->Flags & ~SINKFLAG_SCALABLE & ~SINKFLAG_PARTIALLY_SCALABLE & ~SINKFLAG_MULTIPASS & ~SINKFLAG_COMPOSITE;

    CachedImageInfo = *imageInfo;

    colorpalette->Count = 0;


    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Clean up the sink state including writing whatever we have of an 
*     incomplete image to the output stream.
*
* Arguments:
*
*     statusCode - the reason why the sink is terminating
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP 
GpGifCodec::EndSink(
    IN HRESULT statusCode)
{
    HRESULT hresult;
 
    if (!HasCalledBeginDecode)
    {
        WARNING(("EndDecode called before call to BeginDecode\n"));
        return E_FAIL;
    }

    //Assuming that we have some data to write to the disk, write it.
    if (compressionbuffer)
    {
        int height = encoderrect.bottom - encoderrect.top;
        int width = encoderrect.right - encoderrect.left;

        //Fill the end of an incomplete image with 0's.
        if (from32bpp)
            width *= 4;
        while (currentline < height)
        {

            memset(compressionbuffer + (currentline * width), gifinfo.backgroundcolor, (height - currentline) * width);

            currentline++;
        }

        hresult = WriteImage();
        if (FAILED(hresult))
            return hresult;
    }
    
    //TODO: move writing the trailer to after all frames are written
    BYTE c = 0x3B;  //Gif trailer chunk marker
    hresult = istream->Write(&c, 1, NULL);
    if (FAILED(hresult))
        return hresult;

    //Get ready for the next encoding.
    HasCalledBeginDecode = FALSE;
    headerwritten = FALSE;

    GpFree(compressionbuffer);
    compressionbuffer = NULL;

    return statusCode;
}

/**************************************************************************\
*
* Function Description:
*
*     Sets the bitmap palette.  The first palette entry with an alpha
*     value == 0 is set to be the transparent color index.
*
* Arguments:
*
*     palette - The palette to set in the sink
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpGifCodec::SetPalette(IN const ColorPalette* palette)
{
    DWORD i;
    
    //TODO: palettes larger than 256 have to be downsampled or halftoned 
    //because gif only supports maximum 256 color palettes.  The negotiation 
    //process should probably include the palette size.

    //Gifs only support a palette with a power of 2 for the number of colors.
    DWORD numcolors = Gppow2 (Gplog2(palette->Count-1)+1);

    //Copy the palette passed to us into our own data structure.
    for (i=0;i<palette->Count;i++)
    {
        colorpalette->Entries[i] = palette->Entries[i];
    }

    //Fill the unused entries with 0's.
    for (i=palette->Count;i<numcolors;i++)
    {
        colorpalette->Entries[i] = 0;
    }
    
    colorpalette->Count = numcolors;
    colorpalette->Flags = palette->Flags;

    // Set the first color palette entry with alpha value == 0 to
    // be the transparent index (so that when we save to GIF format,
    // that transparency information is not lost).
    for (i = 0; i < palette->Count; i++)
    {
        if ((palette->Entries[i] & ALPHA_MASK) == 0x00)
        {
            transparentColorIndex = i;
            bTransparentColorIndex = TRUE;
            break;
        }
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Allocates a block o' memory to hold uncompressed data that is in the 
*     process of being turned into compressed data
*
* Arguments:
*
*     bitmapData - information about pixel data buffer
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::AllocateCompressionBuffer(const BitmapData *bitmapdata)
{
    if (!compressionbuffer) 
    {
        int width = encoderrect.right - encoderrect.left;
        int height = encoderrect.bottom - encoderrect.top;
        if (from32bpp)
        {
            compressionbuffer = (unsigned __int8*)GpMalloc(width * height * 4);
        }
        else
        {
            compressionbuffer = (unsigned __int8*)GpMalloc(width * height);
        }
        if (!compressionbuffer)
        {
            WARNING(("GpGifCodec::AllocateCompressionBuffer - Out of memory."));
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Gives a buffer to the sink where data is to be deposited    
*
* Arguments:
*
*     rect - Specifies the interested area of the bitmap
*     pixelFormat - Specifies the desired pixel format
*     lastPass - Whether this the last pass over the specified area
*     bitmapData - Returns information about pixel data buffer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::GetPixelDataBuffer(
    IN const RECT* rect, 
    IN PixelFormatID pixelFormat,
    IN BOOL lastPass,
    OUT BitmapData* bitmapdata
    )
{
    HRESULT hresult;

    if (!from32bpp && colorpalette->Count == 0)
    {
        WARNING(("SetPalette was not called before requesting data in 8bpp indexed mode."));
        return E_FAIL;
    }

    if ((rect->left < 0) || (rect->top < 0)) 
    {
        WARNING(("GpGifCodec::GetPixelDataBuffer -- requested area lies out of (0,0),(width,height)."));
        return E_INVALIDARG;
    }

    if (rect->top != currentline)
    {
        WARNING(("GpGifCodec::PushPixelDataBuffer -- lines out of order."));
        return E_INVALIDARG;
    }

    if ((pixelFormat != PIXFMT_32BPP_ARGB) &&
        (pixelFormat != PIXFMT_8BPP_INDEXED))
    {
        WARNING(("GpGifCodec::GetPixelDataBuffer -- bad pixel format"));
        return E_INVALIDARG;
    }

    if (!lastPass)
    {
        WARNING(("GpGifCodec::GetPixelDataBuffer -- must receive last pass pixels"));
        return E_INVALIDARG;
    }

    bitmapdata->Width = CachedImageInfo.Width;
    bitmapdata->Height = rect->bottom - rect->top;
    bitmapdata->Stride = from32bpp ? CachedImageInfo.Width * 4 : CachedImageInfo.Width;
    bitmapdata->PixelFormat = CachedImageInfo.PixelFormat;
    bitmapdata->Reserved = 0;

    hresult = AllocateCompressionBuffer(bitmapdata);
    if (FAILED(hresult))
        return hresult;

    //Give a pointer to the place in the compression buffer that the user asks 
    //for.
    bitmapdata->Scan0 = compressionbuffer + rect->top * bitmapdata->Stride;

    scanrect = *rect;
    
    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Write out the data from the sink's buffer into the stream
*
* Arguments:
*
*     bitmapData - Buffer filled by previous GetPixelDataBuffer call
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::ReleasePixelDataBuffer(IN const BitmapData* bitmapData)
{
    HRESULT hresult;

    hresult = PushPixelData(&scanrect, bitmapData, TRUE);
    if (FAILED(hresult))
        return hresult;
    
    return S_OK;
}
    

/**************************************************************************\
*
* Function Description:
*
*     Push data into stream (buffer supplied by caller)
*
* Arguments:
*
*     rect - Specifies the affected area of the bitmap
*     bitmapData - Info about the pixel data being pushed
*     lastPass - Whether this is the last pass over the specified area
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::PushPixelData(IN const RECT *rect, IN const BitmapData *bitmapdata, IN BOOL lastPass)
{
    HRESULT hresult;

    if (!from32bpp && colorpalette->Count == 0)
    {
        WARNING(("GpGifCodec::PushPixelDataBuffer -- SetPalette was not called before sending data in 8bpp indexed mode."));
        return E_FAIL;
    }

    if ((rect->left < 0) || (rect->top < 0))
    {
        WARNING(("GpGifCodec::PushPixelDataBuffer -- requested area lies out of (0,0),(width,height)."));
        return E_INVALIDARG;
    }

    if (rect->top != currentline)
    {
        WARNING(("GpGifCodec::PushPixelDataBuffer -- lines out of order."));
        return E_INVALIDARG;
    }

    if ((bitmapdata->PixelFormat != PIXFMT_32BPP_ARGB) &&
        (bitmapdata->PixelFormat != PIXFMT_8BPP_INDEXED))
    {
        WARNING(("GpGifCodec::PushPixelDataBuffer -- bad pixel format."));
        return E_INVALIDARG;
    }

    if (!lastPass)
    {
        WARNING(("GpGifCodec::PushPixelDataBuffer -- must receive last pass pixels."));
        return E_INVALIDARG;
    }

    hresult = AllocateCompressionBuffer(bitmapdata);
    if (FAILED(hresult))
        return hresult;

    if (!compressionbuffer)
        return E_OUTOFMEMORY;

    int line;
    for (line=0;line<rect->bottom-rect->top;line++)
    {
        int modline = currentline + line;

        //TODO:  Interlacing encoding does not work correctly.
        if (interlaced)
        {
            modline = TranslateInterlacedLineBackwards(currentline, encoderrect.bottom - encoderrect.top);
        }
        
        //Copy the data from the current scanline buffer to the correct location in the compression buffer.
        if (from32bpp)
        {
            memcpy(compressionbuffer + modline * bitmapdata->Width * 4, (unsigned __int8*)bitmapdata->Scan0 + line * bitmapdata->Stride, bitmapdata->Width * 4);
        }
        else
        {
            memcpy(compressionbuffer + modline * bitmapdata->Width, (unsigned __int8*)bitmapdata->Scan0 + line * bitmapdata->Stride, bitmapdata->Width);
        }
    }

    currentline += line;

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Pushes raw compressed data into the Gif stream.  Not implemented
*     because this filter doesn't understand raw compressed data.
*
* Arguments:
*
*     buffer - Pointer to image data buffer
*     bufsize - Size of the data buffer
*    
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::PushRawData(IN const VOID* buffer, IN UINT bufsize)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\gif\gifframecache.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*    gifframecache.cpp
*
* Abstract:
*
*    The GifFrameCache class holds a frame of data to be used to composite 
*    upon for subsequent frames.
*
* Revision History:
*
*    7/16/1999 t-aaronl
*        Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "gifframecache.hpp"

/**************************************************************************\
*
* Function Description:
*
*     Contructor for GifFrameCache
*
* Arguments:
*
*     none
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

GifFrameCache::GifFrameCache(
    IN GifFileHeader &gifinfo,
    IN PixelFormatID _pixformat,
    IN BYTE gifCodecBackgroundColor
    ): ValidFlag(TRUE)
{
    FrameCacheWidth = gifinfo.LogicScreenWidth;
    FrameCacheHeight = gifinfo.LogicScreenHeight;

    // The gifCodecBackgroundColor should be determined by the function
    // GpGifCodec::GetBackgroundColor()
    
    BackGroundColorIndex = gifCodecBackgroundColor;
    CacheColorPalettePtr = (ColorPalette*)&ColorPaletteBuffer;
    CacheColorPalettePtr->Flags = 0;
    CacheColorPalettePtr->Count = 0;
    HasCachePaletteInitialized = FALSE;
    pixformat = _pixformat;

    Is32Bpp = (pixformat == PIXFMT_32BPP_ARGB);

    FrameCacheSize = FrameCacheWidth * FrameCacheHeight * (Is32Bpp ? 4 : 1);
    FrameCacheBufferPtr = (BYTE*)GpMalloc(FrameCacheSize);
    if ( FrameCacheBufferPtr == NULL )
    {
        ValidFlag = FALSE;
    }
}

/**************************************************************************\
*
* Function Description:
*
*     Destructor for GifFrameCache
*
* Arguments:
*
*     none
*
* Return Value:
*
*     none
*
\**************************************************************************/

GifFrameCache::~GifFrameCache()
{
    CacheColorPalettePtr->Count = 0;
    GpFree(FrameCacheBufferPtr);
}

/**************************************************************************\
*
* Function Description:
*
*     Performs operations needed to begin the current frame
*
* Arguments:
*
*     none
*
* Return Value:
*
*     none
*
\**************************************************************************/

void 
GifFrameCache::InitializeCache()
{
    RECT rect = {0,
                 0,
                 FrameCacheWidth,
                 FrameCacheHeight
                };

    ClearCache(rect);
}

/**************************************************************************\
*
* Function Description:
*
*     Clears the specified area of the cache with the background color
*
* Arguments:
*
*     none
*
* Return Value:
*
*     none
*
\**************************************************************************/

void 
GifFrameCache::ClearCache(
    IN RECT rect
    )
{
    if ( Is32Bpp == TRUE )
    {
        // For a 32 bpp cache buffer, we have to set the color value for each
        // pixel

        ARGB color = CacheColorPalettePtr->Entries[BackGroundColorIndex];
        
        // TODO: the cache may be initialized before the CacheColorPalettePtr is
        // valid? I'm not sure, but it needs to be looked at.

        for ( int y = rect.top; y < rect.bottom; y++ )
        {
            ARGB* bufferstart = (ARGB*)FrameCacheBufferPtr
                              + y * FrameCacheWidth;

            for ( int x = rect.left; x < rect.right; x++ )
            {
                bufferstart[x] = color;
            }
        }
    }
    else
    {
        // For a 8 bpp cache buffer, we need only to set the color index value
        // for each pixel
        
        INT     rectwidth = rect.right - rect.left;
        BYTE*   bufferleft = FrameCacheBufferPtr + rect.left;

        for ( int y = rect.top; y < rect.bottom; y++ )
        {
            GpMemset(bufferleft + y * FrameCacheWidth,
                     BackGroundColorIndex, rectwidth);
        }
    }
}// ClearCache()

/**************************************************************************\
*
* Function Description:
*
*     Copies a rectangle of data in the cache to the specified buffer.
*
* Arguments:
*
*     none
*
* Return Value:
*
*     none
*
\**************************************************************************/

void 
GifFrameCache::CopyFromCache(
    IN RECT         rect,
    IN OUT BYTE*    pDstBuffer
    )
{
    ASSERT(rect.right >= rect.left);

    UINT    uiPixelSize = Is32Bpp ? 4 : 1;
    INT     iRectStride = (rect.right - rect.left) * uiPixelSize;
    UINT    uiFrameCacheStride = FrameCacheWidth * uiPixelSize;
    BYTE*   pBufferLeft = FrameCacheBufferPtr + rect.left * uiPixelSize;

    for ( int y = rect.top; y < rect.bottom; y++ )
    {
        GpMemcpy(pDstBuffer + y * iRectStride,
                 pBufferLeft + y * uiFrameCacheStride,
                 iRectStride);
    }
}

/**************************************************************************\
*
* Function Description:
*
*     Copies a rectangle of data in the specified buffer to the cache.
*
* Arguments:
*
*     none
*
* Return Value:
*
*     none
*
\**************************************************************************/

void 
GifFrameCache::CopyToCache(
    IN RECT         rect,
    IN OUT BYTE*    pSrcBuffer
    )
{
    ASSERT(rect.right >= rect.left);
    
    UINT    uiPixelSize = Is32Bpp ? 4 : 1;
    INT     iRectStride = (rect.right - rect.left) * uiPixelSize;
    BYTE*   pBufferLeft = FrameCacheBufferPtr + rect.left * uiPixelSize;
    UINT    uiFrameCacheStride = FrameCacheWidth * uiPixelSize;

    for ( int y = rect.top; y < rect.bottom; y++ )
    {
        GpMemcpy(pBufferLeft + y * uiFrameCacheStride,
                 pSrcBuffer + y * iRectStride,
                 iRectStride);
    }
}// CopyToCache()

/**************************************************************************\
*
* Function Description:
*
*     Copies one line of data from the frame cache into a buffer
*
* Arguments:
*
*   pbDstBuffer  - location of where to put the data
*   uiCurrentRow - index of the data in the cache
*
* Return Value:
*
*     none
*
\**************************************************************************/

void 
GifFrameCache::FillScanline(
    BYTE*   pbDstBuffer,
    UINT    uiCurrentRow
    )
{
    ASSERT(uiCurrentRow < FrameCacheHeight);
    ASSERT(pbDstBuffer != NULL);

    UINT pos = uiCurrentRow * FrameCacheWidth * (Is32Bpp ? 4 : 1);
    ASSERT(pos < FrameCacheSize);

    GpMemcpy(pbDstBuffer, FrameCacheBufferPtr + pos,
             FrameCacheWidth * (Is32Bpp ? 4 : 1));
}// FillScanline()

/**************************************************************************\
*
* Function Description:
*
*     Gets a pointer to a scanline in the cache
*
* Arguments:
*
*     uiRowNum - index of the data in the cache
*
* Return Value:
*
*     a pointer to the beginning of the requested row
*
\**************************************************************************/

BYTE* 
GifFrameCache::GetScanLinePtr(
    UINT uiRowNum
    )
{
    ASSERT(uiRowNum < FrameCacheHeight);

    UINT uiPos = uiRowNum * FrameCacheWidth * (Is32Bpp ? 4 : 1);
    ASSERT(uiPos < FrameCacheSize);

    return FrameCacheBufferPtr + uiPos;
}// GetScanLinePtr()

/**************************************************************************\
*
* Function Description:
*
*     Copies data from the scanline location into the cache
*
* Arguments:
*
*     pScanLine - location of where to take the data from
*     uiRowNum  - index of the data in the cache
*
*
* Return Value:
*
*     none
*
\**************************************************************************/

void 
GifFrameCache::PutScanline(
    BYTE*   pScanLine,
    UINT    uiRowNum
    )
{
    ASSERT(uiRowNum < FrameCacheHeight);
    ASSERT(pScanLine != NULL);

    UINT uiPos = uiRowNum * FrameCacheWidth;
    ASSERT(uiPos < FrameCacheSize / (Is32Bpp ? 4 : 1));

    GpMemcpy(FrameCacheBufferPtr + uiPos * (Is32Bpp ? 4 : 1), pScanLine,
             FrameCacheWidth * (Is32Bpp ? 4 : 1));
}// PutScanline()

/**************************************************************************\
*
* Function Description:
*
*     Allocates a new palette and copies a palette into it.
*
* Arguments:
*
*     palette - The palette to set in the sink
*
* Return Value:
*
*     none
*
\**************************************************************************/

BOOL
GifFrameCache::SetFrameCachePalette(
    IN ColorPalette* pSrcPalette
    )
{
    UINT i;

    BOOL fIsSamePalette = TRUE;
    
    if ( (CacheColorPalettePtr->Count != 0) && (Is32Bpp == FALSE) )
    {
        pSrcPalette->Count = CacheColorPalettePtr->Count;

        for ( i = 0; i < pSrcPalette->Count && fIsSamePalette; i++ )
        {
            fIsSamePalette = (pSrcPalette->Entries[i]
                              == CacheColorPalettePtr->Entries[i]);
        }

        // TODO/NOTE:  If the palettes are not the same I am converting the
        // cache to 32bpp and using that mode from now on.  However, it would
        // not be that difficult to optimize the case where if the two palettes
        // have less than 257 colors, merge the palettes together and still be
        // in 8 bpp indexed.

        if ( fIsSamePalette == FALSE )
        {
            if ( ConvertTo32bpp() == TRUE )
            {
                pixformat = PIXFMT_32BPP_ARGB;
            }
            else
            {
                return FALSE;
            }
        }
        else
        {
            pixformat = PIXFMT_8BPP_INDEXED;
        }
    }
    else
    {
        GpMemcpy(CacheColorPalettePtr, 
                 pSrcPalette, 
                 offsetof(ColorPalette, Entries)
                 + pSrcPalette->Count*sizeof(ARGB));
    }

    HasCachePaletteInitialized = TRUE;

    return TRUE;
}// SetFrameCachePalette()

/**************************************************************************\
*
* Function Description:
*
*     Converts the cache into 32bpp ARGB from 8bpp indexed
*
* Arguments:
*
*     none
*
* Return Value:
*
*     none
*
\**************************************************************************/

BOOL 
GifFrameCache::ConvertTo32bpp()
{
    UINT    uiNewNumOfBytes = FrameCacheSize * 4;
    BYTE*   pNewBuffer = (BYTE*)GpMalloc(uiNewNumOfBytes);

    if ( pNewBuffer == NULL )
    {
        WARNING(("GifFrameCache::ConvertTo32bpp---Out of memory"));
        return FALSE;
    }

    for ( UINT i = 0; i < FrameCacheSize; i++ )
    {
        ((ARGB*)pNewBuffer)[i] =
            CacheColorPalettePtr->Entries[FrameCacheBufferPtr[i]];
    }

    GpFree(FrameCacheBufferPtr);
    FrameCacheBufferPtr = pNewBuffer;

    FrameCacheSize = uiNewNumOfBytes;
    Is32Bpp = TRUE;

    return TRUE;
}// ConvertTo32bpp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\imaging\gif\gifcodec.hpp ===
#pragma once

/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   gifcodec.hpp
*
* Abstract:
*
*   Header file for the gif encoder/decoder
*
* Revision History:
*
*   5/13/1999 t-aaronl
*       Created it from OriG's template.
*
\**************************************************************************/

#include "giffile.h"
#include "liblzw/lzwread.h"
#include "liblzw/lzwwrite.h"
#include "gifoverflow.hpp"
#include "gifbuffer.hpp"
#include "gifframecache.hpp"


//TODO: The encoder and decoder should be split into separate classes 
//because they really don't share anything between themselves anyway.
class GpGifCodec : public IImageDecoder,
                   public IImageEncoder,
                   public IImageSink
{
private:

    /*-----------------\
      For en/decoding
    \-----------------*/
    ImageInfo   CachedImageInfo;    // Image info for input image
    BOOL        IsImageInfoCached;  // TRUE if we have already cached it
    BOOL        HasCodecInitialized;//TRUE if Init(En|De)coder has been called
                                    // before the corresponding Terminate.
    BOOL        HasCalledBeginDecode;// State for BeginDecode/EndDecode
    IStream *istream;
    BYTE colorpalettebuffer[offsetof(ColorPalette, Entries) + sizeof(ARGB) * 256];
    ColorPalette *colorpalette;

    /*-----------------\
      For decoding
    \-----------------*/
    IImageSink* decodeSink;
    GifFileHeader gifinfo;
    BOOL bGifinfoFirstFrameDim;
    WORD gifinfoFirstFrameWidth;
    WORD gifinfoFirstFrameHeight;
    BOOL bGifinfoMaxDim;
    WORD gifinfoMaxWidth;
    WORD gifinfoMaxHeight;
    GifColorTable GlobalColorTable;     // GIF global color table
    GifGraphicControlExtension lastgce; // The scope of a GCE is limited to
                                        // The following image chunk.
    GifFrameCache*  GifFrameCachePtr;   // Pointer to the Gif Frame Cache
    DecoderInitFlag decoderflags;
    BOOL blocking;
    BOOL lastgcevalid;                  // TRUE if the variable lastgce has been
                                        //   set.
    BOOL headerread;
    BOOL firstdecode;
    BOOL HasCalledBeginSink;
    BOOL IsAnimatedGif;                 // True if the image is animated GIF
    BOOL IsMultiImageGif;               // True if the image is a multiimage GIF
    WORD FrameDelay;                    // Frame delay, in hundreths of a second
    BOOL HasLoopExtension;
    UINT16 LoopCount;                   // Loop count for an animated gif
    BOOL moreframes;
    UINT GlobalColorTableSize;          // GIF global color table size
    INT TotalNumOfFrame;
    INT currentframe;
    LONGLONG frame0pos;

    // Property related variables

    UINT    PropertyNumOfItems;         // Number of property items in the image
    UINT    PropertyListSize;           // Total bytes for storing values
    BOOL    HasProcessedPropertyItem;   // TRUE if we have processed once
    UINT*   FrameDelayArrayPtr;         // A pointer to an array of frame delay
                                        // value. Each frame has a frame delay
    UINT    FrameDelayBufferSize;       // Current size of the buffer for
                                        // storingframe delay info
    BYTE*   CommentsBufferPtr;          // A pointer to the comments buffer
    UINT    CommentsBufferLength;       // Length of comments chunk

    int TranslateInterlacedLine(IN int line, IN int height, IN int pass);
    int WhichPass(IN int line, IN int height);
    int NumRowsInPass(IN int pass);
    BYTE GetBackgroundColor (void);
    void CopyConvertPalette(IN GifColorTable *gct, 
                            OUT ColorPalette *cp, 
                            IN UINT count);
    STDMETHOD(SetFrameColorTable)(IN BOOL local, 
                                 IN OUT ColorPalette *colorpalette);
    STDMETHOD(GetOutputSpace)(IN int line, 
                              IN GifBuffer &gifbuffer, 
                              IN LZWDecompressor &lzwdecompressor, 
                              IN GifOverflow &gifoverflow, 
                              IN GifImageDescriptor currentImageInfo, 
                              IN GifImageDescriptor clippedCurrentImageInfo, 
                              IN BOOL padborder);
    STDMETHOD(GetCompressedData)(IN LZWDecompressor &lzwdecompressor,
                                 IN BYTE compresseddata[256], 
                                 OUT BOOL &stillmoredata);
    STDMETHOD(ReadGifHeaders)();
    STDMETHOD(ProcessImageChunk)(IN BOOL processdata, 
                                 IN BOOL sinkdata,
                                 ImageInfo dstImageInfo);
    STDMETHOD(ProcessGraphicControlChunk)(IN BOOL processdata);
    STDMETHOD(ProcessCommentChunk)(IN BOOL processdata);
    STDMETHOD(ProcessPlainTextChunk)(IN BOOL processdata);
    STDMETHOD(ProcessApplicationChunk)(IN BOOL processdata);
    STDMETHOD(SeekThroughDataChunk)(IN IStream *istream, IN BYTE headersize);
    STDMETHOD(MarkStream)(IN IStream *istream, OUT LONGLONG &markpos);
    STDMETHOD(ResetStream)(IN IStream *istream, IN LONGLONG &markpos);
    STDMETHOD(SkipToNextFrame)();
    STDMETHOD(ReadFrameProperties)();
    STDMETHOD(MoveToNextFrame)();
    STDMETHOD(DoDecode)(BOOL processdata, BOOL sinkdata, BOOL decodeframe);

    /*-----------------\
      For encoding
    \-----------------*/
    RECT encoderrect;  //Contains the bounds that the encoder is handling.
    RECT scanrect;  //Contains the bounds of the area that is currently being 
                    //pushed into the encoder
    unsigned __int8* compressionbuffer;
    BOOL headerwritten;
    BOOL bTransparentColorIndex;
    UINT transparentColorIndex;
    BOOL from32bpp;
    BOOL gif89;
    BOOL interlaced;
    int currentline;
    STDMETHOD(WritePalette)();
    STDMETHOD(WriteGifHeader)(IN ImageInfo &imageinfo, IN BOOL from32bpp);
    STDMETHOD(WriteGifGraphicControlExtension) (IN BYTE packedFields,
                                                IN WORD delayTime,
                                                IN UINT transparentColorIndex);
    STDMETHOD(WriteGifImageDescriptor)(IN ImageInfo &imageinfo, IN BOOL 
        from32bpp);
    STDMETHOD(AllocateCompressionBuffer)(const BitmapData *bitmapdata);
    STDMETHOD(CompressAndWriteImage)();
    STDMETHOD(WriteImage)();
    int TranslateInterlacedLineBackwards(IN int line, IN int height);

protected:
    LONG comRefCount;  //COM object reference count    

public:

    // Constructor and Destructor
    
    GpGifCodec::GpGifCodec(void);
    GpGifCodec::~GpGifCodec(void);

    // IImageDecoder methods
    
    STDMETHOD(InitDecoder)(IN IStream* stream, IN DecoderInitFlag flags);
    STDMETHOD(TerminateDecoder)();
    STDMETHOD(BeginDecode)(IN IImageSink* imageSink, IN OPTIONAL 
        IPropertySetStorage* newPropSet);
    STDMETHOD(Decode)();
    STDMETHOD(EndDecode)(IN HRESULT statusCode);

    STDMETHOD(GetFrameDimensionsCount)(OUT UINT* count);
    STDMETHOD(GetFrameDimensionsList)(OUT GUID* dimensionIDs,IN OUT UINT count);
    STDMETHOD(GetFrameCount)(IN const GUID* dimensionID, OUT UINT* count);
    STDMETHOD(SelectActiveFrame)(IN const GUID* dimensionID, 
        IN UINT frameIndex);
    STDMETHOD(GetImageInfo)(OUT ImageInfo* imageInfo);
    STDMETHOD(GetThumbnail)(IN OPTIONAL UINT thumbWidth, IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage);
    STDMETHOD(QueryDecoderParam)(IN GUID Guid);
    STDMETHOD(SetDecoderParam)(IN GUID Guid, IN UINT Length, IN PVOID Value);
    STDMETHOD(GetPropertyCount)(OUT UINT* numOfProperty);
    STDMETHOD(GetPropertyIdList)(IN UINT numOfProperty,IN OUT PROPID* list);
    STDMETHOD(GetPropertyItemSize)(IN PROPID propId, OUT UINT* size);    
    STDMETHOD(GetPropertyItem)(IN PROPID propId, IN UINT propSize,
                               IN OUT PropertyItem* buffer);
    STDMETHOD(GetPropertySize)(OUT UINT* totalBufferSize,
                               OUT UINT* numProperties);
    STDMETHOD(GetAllPropertyItems)(IN UINT totalBufferSize,
                                   IN UINT numProperties,
                                   IN OUT PropertyItem* allItems);
    STDMETHOD(RemovePropertyItem)(IN PROPID propId);
    STDMETHOD(SetPropertyItem)(IN PropertyItem item);
    STDMETHOD(GetRawInfo)(IN OUT void** info)
    {
        return E_NOTIMPL;
    }

    // IImageEncoder methods

    STDMETHOD(InitEncoder)(IN IStream* stream);
    STDMETHOD(TerminateEncoder)();
    STDMETHOD(GetEncodeSink)(OUT IImageSink** sink);
    STDMETHOD(SetFrameDimension)(IN const GUID* dimensionID);
    STDMETHOD(GetEncoderParameterListSize)(OUT UINT* size);
    STDMETHOD(GetEncoderParameterList)(IN UINT	  size,
                                       OUT EncoderParameters* Params);
    STDMETHOD(SetEncoderParameters)(IN const EncoderParameters* Param);

    STDMETHOD(NeedTransform(OUT UINT* rotation))
    {
        return E_NOTIMPL;
    }
    
    STDMETHOD(NeedRawProperty)(void *pSRc)
    {
        // GIF can't handle raw property when saving for now

        return E_FAIL;
    }
    
    STDMETHOD(PushRawInfo)(IN OUT void* info)
    {
        return E_NOTIMPL;
    }
    
