_LOCAL_FILE_LOGGING_WRITING_WHEN_LOG_FILE_SIZE_NOT_ZERO, NULL, 0, IDS_ERROR__LOGGING_TITLE );

            // Reset the ref count so all pages know that we need to play the game again.
            m_pSynchronizer->ResetCountToHighest();

            // This uses the resource ID of this page to make this page the current page.
            PropSheet_SetCurSelByID( GetParent(), IDD );

            return FALSE;

         }
         bstrNumberAsText.Empty();
         hr = PutSdoI4( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_OPEN_NEW_SIZE, lTemp, IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_WHEN_LOG_FILE_SIZE, m_hWnd, NULL );
         if( FAILED( hr ) )
         {
            // Reset the ref count so all pages know that we need to play the game again.
            m_pSynchronizer->ResetCountToHighest();

            // This uses the resource ID of this page to make this page the current page.
            PropSheet_SetCurSelByID( GetParent(), IDD );

            return FALSE;
         }
         else
         {
            // We succeeded.

            // Turn off the dirty bit.
            m_fDirtyLogFileSize = FALSE;
         }
      }
   }

   if( m_fDirtyLogFileDirectory )
   {
      bResult = GetDlgItemText( IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_DIRECTORY, (BSTR &) bstrTemp );
      if( ! bResult )
      {
         // We couldn't retrieve a BSTR, so we need to initialize this variant to a null BSTR.
         bstrTemp = _T("");
      }
      hr = PutSdoBSTR( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_FILE_DIRECTORY, &bstrTemp, IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_LOG_FILE_DIRECTORY, m_hWnd, NULL );
      if( FAILED( hr ) )
      {
         // Reset the ref count so all pages know that we need to play the game again.
         m_pSynchronizer->ResetCountToHighest();

         // This uses the resource ID of this page to make this page the current page.
         PropSheet_SetCurSelByID( GetParent(), IDD );

         return FALSE;
      }
      else
      {
         // We succeeded.

         // Turn off the dirty bit.
         m_fDirtyLogFileDirectory = FALSE;

      }
      bstrTemp.Empty();
   }

   if( m_fDirtyLogInV1Format )
   {
      if( SendDlgItemMessage( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_IAS1, BM_GETCHECK, 0, 0) )
      {
         lTemp = LOG_FILE_FORMAT__IAS1;
      }
      else
      {
         lTemp = LOG_FILE_FORMAT__ODBC;
      }

       hr = PutSdoI4( m_spSdoAccounting, PROPERTY_ACCOUNTING_LOG_IAS1_FORMAT, lTemp, IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_LOG_FILE_FORMAT, m_hWnd, NULL );
      if( FAILED( hr ) )
      {
         // Reset the ref count so all pages know that we need to play the game again.
         m_pSynchronizer->ResetCountToHighest();

         // This uses the resource ID of this page to make this page the current page.
         PropSheet_SetCurSelByID( GetParent(), IDD );

         return FALSE;
      }
      else
      {
         // We succeeded.

         // Turn off the dirty bit.
         m_fDirtyLogInV1Format = FALSE;
      }
   }

   if (m_fDirtyDeleteIfFull)
   {
      BOOL deleteIfFull  = SendDlgItemMessage(
                              IDC_CHECK_DELETE_IF_FULL,
                              BM_GETCHECK,
                              0,
                              0
                              );
      hr = PutSdoBOOL(
              m_spSdoAccounting,
              PROPERTY_ACCOUNTING_LOG_DELETE_IF_FULL,
              deleteIfFull,
              USE_DEFAULT,
              m_hWnd,
              0
              );
      if (SUCCEEDED(hr))
      {
         m_fDirtyDeleteIfFull = TRUE;
      }
      else
      {
          m_pSynchronizer->ResetCountToHighest();
          PropSheet_SetCurSelByID( GetParent(), IDD);
          return FALSE;
      }
   }

   // If we made it to here, try to apply the changes.

   // Check to see if there are other pages which have not yet validated their data.
   LONG lRefCount = m_pSynchronizer->LowerCount();
   if( lRefCount <= 0 )
   {
      // There is nobody else left, so now we can commit the data.

      hr = m_spSdoAccounting->Apply();
      if( FAILED( hr ) )
      {
         if(hr == DB_E_NOTABLE)   // assume, the RPC connection has problem
            ShowErrorDialog( m_hWnd, IDS_ERROR__NOTABLE_TO_WRITE_SDO, NULL, 0, IDS_ERROR__LOGGING_TITLE );
         else
         {
//         m_spSdoAccounting->LastError( &bstrError );
//         ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_WRITE_DATA_TO_SDO, bstrError );
            ShowErrorDialog( m_hWnd, IDS_ERROR__CANT_WRITE_DATA_TO_SDO, NULL, 0, IDS_ERROR__LOGGING_TITLE );
         }
         // Reset the ref count so all pages know that we need to play the game again.
         m_pSynchronizer->ResetCountToHighest();

         // This uses the resource ID of this page to make this page the current page.
         PropSheet_SetCurSelByID( GetParent(), IDD );

         return FALSE;
      }
      else
      {
         // We succeeded.

         // The data was accepted, so notify the main context of our snapin
         // that it may need to update its views.
         CChangeNotification * pChangeNotification = new CChangeNotification();
         pChangeNotification->m_dwFlags = CHANGE_UPDATE_RESULT_NODE;
         pChangeNotification->m_pNode = m_pNodeBeingModified;
         pChangeNotification->m_pParentNode = m_pParentOfNodeBeingModified;

         HRESULT hr = PropertyChangeNotify( (LPARAM) pChangeNotification );
         _ASSERTE( SUCCEEDED( hr ) );


         // Tell the service to reload data.
         HRESULT hrTemp = m_spSdoServiceControl->ResetService();
         if( FAILED( hrTemp ) )
         {
            // Fail silently.
         }

      }
   }


   return TRUE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage2::OnQueryCancel

Return values:

   TRUE if the page can be destroyed,
   FALSE if the page should not be destroyed (i.e. there was invalid data)

Remarks:

   OnQueryCancel gets called for each page in on a property sheet if that
   page has been visited, regardless of whether any values were changed.

   If you never switch to a tab, then its OnQueryCancel method will never get called.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CLocalFileLoggingPage2::OnQueryCancel()
{
   ATLTRACE(_T("# CLocalFileLoggingPage2::OnQueryCancel\n"));


   HRESULT hr;

   if( m_spSdoAccounting != NULL )
   {
      // If the user wants to cancel, we should make sure that we rollback
      // any changes the user may have started.

      // If the user had not already tried to commit something,
      // a cancel on an SDO will hopefully be designed to be benign.

      hr = m_spSdoAccounting->Restore();
      // Don't care about the HRESULT, but it might be good to see it for debugging.

   }

   return TRUE;

}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage2::OnNewLogInterval


Remarks:

   Called when the user clicks on the Enable Logging check box.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CLocalFileLoggingPage2::OnNewLogInterval(
        UINT uMsg
      , WPARAM wParam
      , HWND hwnd
      , BOOL& bHandled
      )
{
   ATLTRACE(_T("# CLocalFileLoggingPage2::OnNewLogInterval\n"));

   // The Enable Logging button has been checked -- check dependencies.
   SetLogFileFrequencyDependencies();

   // This return value is ignored.
   return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage2::SetLogFileFrequencyDependencies

Remarks:

   Utility to set state of items which may depend on the
   "When log file size reaches" radio button.

   Call whenever something changes the state of
   IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES
   or any of the other logging frequency radio buttons.

--*/
//////////////////////////////////////////////////////////////////////////////
void CLocalFileLoggingPage2::SetLogFileFrequencyDependencies( void )
{
   ATLTRACE(_T("# CLocalFileLoggingPage2::SetLogFileFrequencyDependencies\n"));


   int nLoadStringResult;
   TCHAR szDaily[IAS_MAX_STRING];
   TCHAR szWeekly[IAS_MAX_STRING];
   TCHAR szMonthly[IAS_MAX_STRING];
   TCHAR szWhenLogFileSizeReaches[IAS_MAX_STRING];


   nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_LOCAL_FILE_LOGGING_PAGE2__DAILY_FORMAT, szDaily, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );

   nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_LOCAL_FILE_LOGGING_PAGE2__WEEKLY_FORMAT, szWeekly, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );

   nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_LOCAL_FILE_LOGGING_PAGE2__MONTHLY_FORMAT, szMonthly, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );

   nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_SIZE_REACHES_FORMAT, szWhenLogFileSizeReaches, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );



   // Set the text to appear as the log file name.
   if( ::SendMessage( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY ), BM_GETCHECK, 0, 0 ) )
      SetDlgItemText( IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_NAME, szDaily );
   else if( ::SendMessage( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY ), BM_GETCHECK, 0, 0 ) )
      SetDlgItemText( IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_NAME, szWeekly );
   else if( ::SendMessage( GetDlgItem(IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY ), BM_GETCHECK, 0, 0 ) )
      SetDlgItemText( IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_NAME, szMonthly );
   else
      // This takes care of both the UNLIMITED and the WHEN_LOG_FILE_SIZE_REACHES case -- they both
      // use the same format of filename.
      SetDlgItemText( IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_NAME, szWhenLogFileSizeReaches );


   // Ascertain what the state of the IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES radio button is.
   int iChecked = ::SendMessage( GetDlgItem(IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES), BM_GETCHECK, 0, 0 );
   int iEnabled = ::IsWindowEnabled( GetDlgItem( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES ) );

   if( iChecked && iEnabled )
   {
      // Make sure the correct items are enabled.

      ::EnableWindow( GetDlgItem( IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE_UNITS), TRUE );
      ::EnableWindow( GetDlgItem( IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE), TRUE );

   }
   else
   {
      // Make sure the correct items are enabled.

      ::EnableWindow( GetDlgItem( IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE_UNITS), FALSE );
      ::EnableWindow( GetDlgItem( IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE), FALSE );

   }

   // Enable deleting old log files iff unlimited file size is not selected.
   iChecked = ::SendMessage(
                   GetDlgItem(IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__UNLIMITED),
                   BM_GETCHECK,
                   0,
                   0
                   );
   ::EnableWindow(GetDlgItem(IDC_CHECK_DELETE_IF_FULL), !iChecked);
}



/////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingPage2::GetHelpPath

Remarks:

   This method is called to get the help file path within
   an compressed HTML document when the user presses on the Help
   button of a property sheet.

   It is an override of atlsnap.h CIASPropertyPageImpl::OnGetHelpPath.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalFileLoggingPage2::GetHelpPath( LPTSTR szHelpPath )
{
   ATLTRACE(_T("# CLocalFileLoggingPage2::GetHelpPath\n"));


   // Check for preconditions:



#ifdef UNICODE_HHCTRL
   // ISSUE: We seemed to have a problem with passing WCHAR's to the hhctrl.ocx
   // installed on this machine -- it appears to be non-unicode.
   lstrcpy( szHelpPath, _T("idh_proppage_local_file_logging2.htm") );
#else
   strcpy( (CHAR *) szHelpPath, "idh_proppage_local_file_logging2.htm" );
#endif

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\localfileloggingpage2.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

	LocalFileLoggingPage2.h

Abstract:

	Header file for the CLocalFileLoggingPage2 class.

	This is our handler class for the second CMachineNode property page.

	See LocalFileLoggingPage2.cpp for implementation.

Author:

    Michael A. Maguire 12/15/97

Revision History:
	mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_LOG_LOCAL_FILE_LOGGING_PAGE_2_H_)
#define _LOG_LOCAL_FILE_LOGGING_PAGE_2_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "PropertyPage.h"
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

class CLocalFileLoggingNode;

class CLocalFileLoggingPage2 : public CIASPropertyPage<CLocalFileLoggingPage2>
{

public :
	
	CLocalFileLoggingPage2( LONG_PTR hNotificationHandle, CLocalFileLoggingNode *pLocalFileLoggingNode,  TCHAR* pTitle = NULL, BOOL bOwnsNotificationHandle = FALSE );

	~CLocalFileLoggingPage2();


	// This is the ID of the dialog resource we want for this class.
	// An enum is used here because the correct value of
	// IDD must be initialized before the base class's constructor is called
	enum { IDD = IDD_PROPPAGE_LOCAL_FILE_LOGGING2 };

	BEGIN_MSG_MAP(CLocalFileLoggingPage2)
		COMMAND_CODE_HANDLER(BN_CLICKED, OnChange)		
		COMMAND_CODE_HANDLER(EN_CHANGE, OnChange)
		COMMAND_CODE_HANDLER(CBN_SELCHANGE, OnChange)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER( IDC_BUTTON_LOCAL_FILE_LOGGING_PAGE2__BROWSE, OnBrowse )
//		COMMAND_ID_HANDLER( IDC_CHECK_LOCAL_FILE_LOGGING_PAGE2__AUTOMATICALLY_OPEN_NEW_LOG, OnAutomaticallyOpenNewLog )
		COMMAND_ID_HANDLER( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY, OnNewLogInterval )
		COMMAND_ID_HANDLER( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY, OnNewLogInterval )
		COMMAND_ID_HANDLER( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY, OnNewLogInterval )
		COMMAND_ID_HANDLER( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__UNLIMITED, OnNewLogInterval )
		COMMAND_ID_HANDLER( IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES, OnNewLogInterval )
		CHAIN_MSG_MAP(CIASPropertyPage<CLocalFileLoggingPage2>)
	END_MSG_MAP()

	BOOL OnApply();

	BOOL OnQueryCancel();

	HRESULT GetHelpPath( LPTSTR szFilePath );



	// Pointer to stream into which this page's Sdo interface
	// pointer will be marshalled.
	LPSTREAM m_pStreamSdoAccountingMarshal;

	LPSTREAM m_pStreamSdoServiceControlMarshal;

protected:
	// Interface pointer for this page's client's sdo.
	CComPtr<ISdo>	m_spSdoAccounting;

	// Smart pointer to interface for telling service to reload data.
	CComPtr<ISdoServiceControl>	m_spSdoServiceControl;

	// When we are passed a pointer to the client node in our constructor,
	// we will save away a pointer to its parent, as this is the node
	// which will need to receive an update message once we have
	// applied any changes.
	CSnapInItem * m_pParentOfNodeBeingModified;
	CSnapInItem * m_pNodeBeingModified;

private:

	LRESULT OnInitDialog(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);

	LRESULT OnChange(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

	LRESULT OnBrowse(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);

//	LRESULT OnAutomaticallyOpenNewLog(
//		  UINT uMsg
//		, WPARAM wParam
//		, HWND hwnd
//		, BOOL& bHandled
//		);

	LRESULT OnNewLogInterval(
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);


//	void SetAutomaticallyOpenNewLogDependencies( void );
	void SetLogFileFrequencyDependencies( void );

protected:

	// Dirty bits -- for keeping track of data which has been touched
	// so that we only save data we have to.
	BOOL m_fDirtyAutomaticallyOpenNewLog;
	BOOL m_fDirtyFrequency;
	BOOL m_fDirtyLogFileSize;
	BOOL m_fDirtyLogFileDirectory;
	BOOL m_fDirtyLogInV1Format;
	BOOL m_fDirtyDeleteIfFull;

};

#endif // _LOG_LOCAL_FILE_LOGGING_PAGE_2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\localfileloggingnode.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    LocalFileLoggingNode.cpp

Abstract:

   Implementation file for the CClient class.


Author:

    Michael A. Maguire 12/15/97

Revision History:
   mmaguire 12/15/97 - created

--*/
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"

//
// where we can find declaration for main class in this file:
//
#include "logcomp.h"
#include "LocalFileLoggingNode.h"
#include "LogCompD.h"

#include "SnapinNode.cpp"  // Template class implementation
//
//
// where we can find declarations needed in this file:
//
#include "LoggingMethodsNode.h"
#include "LocalFileLoggingPage1.h"
#include "LocalFileLoggingPage2.h"
#include "LogMacNd.h"

// Need to include this at least once to get in build:
#include "sdohelperfuncs.cpp"

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::CLocalFileLoggingNode

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CLocalFileLoggingNode::CLocalFileLoggingNode( CSnapInItem * pParentNode )
   : LoggingMethod(IAS_PROVIDER_MICROSOFT_ACCOUNTING, pParentNode)
{
   // for help files
   m_helpIndex = (((CLoggingMethodsNode *)m_pParentNode)->m_ExtendRas)? RAS_HELP_INDEX:0;


   // Set the display name for this object
   TCHAR lpszName[IAS_MAX_STRING];
   int nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_LOCAL_FILE_LOGGING_NODE__NAME, lpszName, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );

   m_bstrDisplayName = lpszName;

   m_resultDataItem.nImage =     IDBI_NODE_LOCAL_FILE_LOGGING;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::~CLocalFileLoggingNode

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CLocalFileLoggingNode::~CLocalFileLoggingNode() throw ()
{
   ATLTRACE(_T("# --- CLocalFileLoggingNode::~CLocalFileLoggingNode\n"));
}


HRESULT CLocalFileLoggingNode::LoadCachedInfoFromSdo() throw ()
{
   CComVariant spVariant;
   HRESULT hr = configSdo->GetProperty(
                              PROPERTY_ACCOUNTING_LOG_FILE_DIRECTORY,
                              &spVariant
                              );
   if (SUCCEEDED(hr))
   {
      m_bstrDescription = V_BSTR(&spVariant);
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::CreatePropertyPages

See CSnapinNode::CreatePropertyPages (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP  CLocalFileLoggingNode::CreatePropertyPages (
                 LPPROPERTYSHEETCALLBACK pPropertySheetCallback
               , LONG_PTR hNotificationHandle
               , IUnknown* pUnknown
               , DATA_OBJECT_TYPES type
               )
{
   ATLTRACE(_T("# CLocalFileLoggingNode::CreatePropertyPages\n"));

   // Check for preconditions:
   _ASSERTE( pPropertySheetCallback != NULL );

   HRESULT hr;

   CLoggingMachineNode * pServerNode = GetServerRoot();
   _ASSERTE( pServerNode != NULL );
   hr = pServerNode->CheckConnectionToServer();
   if( FAILED( hr ) )
   {
      return hr;
   }

   TCHAR lpszTab1Name[IAS_MAX_STRING];
   TCHAR lpszTab2Name[IAS_MAX_STRING];
   int nLoadStringResult;

   // Load property page tab name from resource.
   nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_LOCAL_FILE_LOGGING_PAGE1__TAB_NAME, lpszTab1Name, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );

   // This page will take care of deleting itself when it
   // receives the PSPCB_RELEASE message.
   // We specify TRUE for the bOwnsNotificationHandle parameter so that this page's destructor will be
   // responsible for freeing the notification handle.  Only one page per sheet should do this.
   CLocalFileLoggingPage1 * pLocalFileLoggingPage1 = new CLocalFileLoggingPage1( hNotificationHandle, this, lpszTab1Name, TRUE );

   if( NULL == pLocalFileLoggingPage1 )
   {
      ATLTRACE(_T("# ***FAILED***: CLocalFileLoggingNode::CreatePropertyPages -- Couldn't create property pages\n"));
      return E_OUTOFMEMORY;
   }

   // Load property page tab name from resource.
   nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_LOCAL_FILE_LOGGING_PAGE2__TAB_NAME, lpszTab2Name, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );

   // This page will take care of deleting itself when it
   // receives the PSPCB_RELEASE message.
   CLocalFileLoggingPage2 * pLocalFileLoggingPage2 = new CLocalFileLoggingPage2( hNotificationHandle, this, lpszTab2Name );

   if( NULL == pLocalFileLoggingPage2 )
   {
      ATLTRACE(_T("# ***FAILED***: CLocalFileLoggingNode::CreatePropertyPages -- Couldn't create property pages\n"));

      // Clean up the first page we created.
      delete pLocalFileLoggingPage1;

      return E_OUTOFMEMORY;
   }

   // Marshall the ISdo pointer so that the property page, which
   // runs in another thread, can unmarshall it and use it properly.
   hr = CoMarshalInterThreadInterfaceInStream(
                 IID_ISdo                 //Reference to the identifier of the interface
               , configSdo           //Pointer to the interface to be marshaled
               , &( pLocalFileLoggingPage1->m_pStreamSdoAccountingMarshal ) //Address of output variable that receives the IStream interface pointer for the marshaled interface
               );

   if( FAILED( hr ) )
   {
      delete pLocalFileLoggingPage1;
      delete pLocalFileLoggingPage2;

      ShowErrorDialog( NULL, IDS_ERROR__NO_SDO, NULL, hr, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );

      return E_FAIL;
   }

   // Marshall the ISdo pointer so that the property page, which
   // runs in another thread, can unmarshall it and use it properly.
   hr = CoMarshalInterThreadInterfaceInStream(
                 IID_ISdo                 //Reference to the identifier of the interface
               , configSdo                 //Pointer to the interface to be marshaled
               , &( pLocalFileLoggingPage2->m_pStreamSdoAccountingMarshal ) //Address of output variable that receives the IStream interface pointer for the marshaled interface
               );

   if( FAILED( hr ) )
   {
      delete pLocalFileLoggingPage1;
      delete pLocalFileLoggingPage2;

      ShowErrorDialog( NULL, IDS_ERROR__NO_SDO, NULL, hr, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );

      return E_FAIL;
   }

   // Marshall the ISdo pointer so that the property page, which
   // runs in another thread, can unmarshall it and use it properly.
   hr = CoMarshalInterThreadInterfaceInStream(
                 IID_ISdoServiceControl            //Reference to the identifier of the interface
               , controlSdo                //Pointer to the interface to be marshaled
               , &( pLocalFileLoggingPage1->m_pStreamSdoServiceControlMarshal ) //Address of output variable that receives the IStream interface pointer for the marshaled interface
               );

   if( FAILED( hr ) )
   {
      delete pLocalFileLoggingPage1;
      delete pLocalFileLoggingPage2;

      ShowErrorDialog( NULL, IDS_ERROR__NO_SDO, NULL, hr, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );

      return E_FAIL;
   }

   // Marshall the ISdo pointer so that the property page, which
   // runs in another thread, can unmarshall it and use it properly.
   hr = CoMarshalInterThreadInterfaceInStream(
                 IID_ISdoServiceControl            //Reference to the identifier of the interface
               , controlSdo                //Pointer to the interface to be marshaled
               , &( pLocalFileLoggingPage2->m_pStreamSdoServiceControlMarshal ) //Address of output variable that receives the IStream interface pointer for the marshaled interface
               );

   if( FAILED( hr ) )
   {
      delete pLocalFileLoggingPage1;
      delete pLocalFileLoggingPage2;

      ShowErrorDialog( NULL, IDS_ERROR__NO_SDO, NULL, hr, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );

      return E_FAIL;
   }

   // Add the pages to the MMC property sheet.
   hr = pPropertySheetCallback->AddPage( pLocalFileLoggingPage1->Create() );
   _ASSERT( SUCCEEDED( hr ) );

   hr = pPropertySheetCallback->AddPage( pLocalFileLoggingPage2->Create() );
   _ASSERT( SUCCEEDED( hr ) );

   // Add a synchronization object which makes sure we only commit data
   // when all pages are OK with their data.
   CSynchronizer * pSynchronizer = new CSynchronizer();
   _ASSERTE( pSynchronizer != NULL );

   // Hand the sycnchronizer off to the pages.
   pLocalFileLoggingPage1->m_pSynchronizer = pSynchronizer;
   pSynchronizer->AddRef();

   pLocalFileLoggingPage2->m_pSynchronizer = pSynchronizer;
   pSynchronizer->AddRef();

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::QueryPagesFor

See CSnapinNode::QueryPagesFor (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP  CLocalFileLoggingNode::QueryPagesFor ( DATA_OBJECT_TYPES type )
{
   ATLTRACE(_T("# CLocalFileLoggingNode::QueryPagesFor\n"));

   // S_OK means we have pages to display
   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::GetResultPaneColInfo

See CSnapinNode::GetResultPaneColInfo (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
OLECHAR* CLocalFileLoggingNode::GetResultPaneColInfo(int nCol)
{
   ATLTRACE(_T("# CLocalFileLoggingNode::GetResultPaneColInfo\n"));

   // Check for preconditions:
   // None.

   switch( nCol )
   {
   case 0:
      return m_bstrDisplayName;
      break;
   case 1:
      return m_bstrDescription;
      break;
   default:
      // ISSUE: error -- should we assert here?
      return NULL;
      break;
   }
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::SetVerbs

See CSnapinNode::SetVerbs (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalFileLoggingNode::SetVerbs( IConsoleVerb * pConsoleVerb )
{
   ATLTRACE(_T("# CLocalFileLoggingNode::SetVerbs\n"));

   // Check for preconditions:
   _ASSERTE( pConsoleVerb != NULL );

   HRESULT hr = S_OK;

   // We want the user to be able to choose Properties on this node
   hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );

   // We want Properties to be the default
   hr = pConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES );

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::GetComponentData

This method returns our unique CComponentData object representing the scope
pane of this snapin.

It relies upon the fact that each node has a pointer to its parent,
except for the root node, which instead has a member variable pointing
to CComponentData.

This would be a useful function to use if, for example, you need a reference
to some IConsole but you weren't passed one.  You can use GetComponentData
and then use the IConsole pointer which is a member variable of our
CComponentData object.

--*/
//////////////////////////////////////////////////////////////////////////////
CLoggingComponentData * CLocalFileLoggingNode::GetComponentData( void )
{
   ATLTRACE(_T("# CLocalFileLoggingNode::GetComponentData\n"));

   // Check for preconditions:
   _ASSERTE( m_pParentNode != NULL );

   return ((CLoggingMethodsNode *) m_pParentNode)->GetComponentData();
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::GetServerRoot

This method returns the Server node under which this node can be found.

It relies upon the fact that each node has a pointer to its parent,
all the way up to the server node.

This would be a useful function to use if, for example, you need a reference
to some data specific to a server.

--*/
//////////////////////////////////////////////////////////////////////////////
CLoggingMachineNode * CLocalFileLoggingNode::GetServerRoot( void )
{
   ATLTRACE(_T("# CLocalFileLoggingNode::GetServerRoot\n"));

   // Check for preconditions:
   _ASSERTE( m_pParentNode != NULL );

   return ((CLoggingMethodsNode *) m_pParentNode)->GetServerRoot();
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLocalFileLoggingNode::OnPropertyChange

This is our own custom response to the MMCN_PROPERTY_CHANGE notification.

MMC never actually sends this notification to our snapin with a specific lpDataObject,
so it would never normally get routed to a particular node but we have arranged it
so that our property pages can pass the appropriate CSnapInItem pointer as the param
argument.  In our CComponent::Notify override, we map the notification message to
the appropriate node using the param argument.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLocalFileLoggingNode::OnPropertyChange(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         )
{
   ATLTRACE(_T("# CLocalFileLoggingNode::OnPropertyChange\n"));

   // Check for preconditions:
   // None.

   return LoadCachedInfoFromSdo();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\logabout.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    LogAbout.h

Abstract:

	Header file for the CLoggingSnapinAbout class.

	The CLoggingSnapinAbout class implements the ISnapinAbout interface which enables the MMC 
	console to get copyright and version information from the snap-in.
	The console also uses this interface to obtain images for the static folder
	from the snap-in.

	See About.cpp for implementation.


Revision History:
	mmaguire 11/6/97 - created using MMC snap-in wizard


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_LOG_ABOUT_H_)
#define _LOG_ABOUT_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


class ATL_NO_VTABLE CLoggingSnapinAbout : 
	  public ISnapinAbout
	, public CComObjectRoot
	, public CComCoClass< CLoggingSnapinAbout, &CLSID_LoggingSnapinAbout>
{

public:
	
	DECLARE_REGISTRY(CLoggingSnapinAbout, _T("NAPSnapinAbout.1"), _T("NAPSnapinAbout.1"), IDS_NAPSNAPIN_DESC, THREADFLAGS_BOTH);

	BEGIN_COM_MAP(CLoggingSnapinAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

	STDMETHOD(GetSnapinDescription)( LPOLESTR *lpDescription );

    STDMETHOD(GetProvider)( LPOLESTR *lpName );

    STDMETHOD(GetSnapinVersion)( LPOLESTR *lpVersion );

    STDMETHOD(GetSnapinImage)( HICON *hAppIcon );

    STDMETHOD(GetStaticFolderImage)(
		  HBITMAP *hSmallImage
		, HBITMAP *hSmallImageOpen
		, HBITMAP *hLargeImage
		, COLORREF *cMask
		);

};

#endif // _LOG_ABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\logabout.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) Microsoft Corporation
//
// Module Name:
//
//    LogAbout.cpp
//
// Abstract:
//
//   Implementation file for the CLoggingSnapinAbout class.
//
//   The CLoggingSnapinAbout class implements the ISnapinAbout interface which
//   enables the MMC console to get copyright and version information from the 
//   snap-in.
//   The console also uses this interface to obtain images for the static 
//   folder from the snap-in.
//////////////////////////////////////////////////////////////////////////////
#include "Precompiled.h"
#include "LogAbout.h"
#include <ntverp.h>


//////////////////////////////////////////////////////////////////////////////
/*++
CLoggingSnapinAbout::GetSnapinDescription

Enables the console to obtain the text for the snap-in's description box.
  
Parameters

lpDescription 
[out] Pointer to the text for the description box on an About property page. 

Return Values

S_OK 
The text was successfully obtained. 

Remarks
Memory for out parameters must be allocated using CoTaskMemAlloc.
--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CLoggingSnapinAbout::GetSnapinDescription (LPOLESTR *lpDescription)
{
   USES_CONVERSION;

   TCHAR szBuf[256];
   if (::LoadString(_Module.GetResourceInstance(), IDS_NAPSNAPIN_DESC, szBuf, 256) == 0)
      return E_FAIL;

   *lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(TCHAR));
   if (*lpDescription == NULL)
      return E_OUTOFMEMORY;

   ocscpy(*lpDescription, T2OLE(szBuf));

   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++
CLoggingSnapinAbout::GetProvider

Enables the console to obtain the snap-in provider's name.

Parameters

lpName 
[out] Pointer to the text making up the snap-in provider's name. 

Return Values

S_OK 
The name was successfully obtained. 

Remarks

Memory for out parameters must be allocated using CoTaskMemAlloc.
--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CLoggingSnapinAbout::GetProvider (LPOLESTR *lpName)
{
   ATLTRACE(_T("+NAPMMC+:# CLoggingSnapinAbout::GetProvider\n"));

   USES_CONVERSION;
   TCHAR szBuf[256];
   if (::LoadString(_Module.GetResourceInstance(), IDS_NAPSNAPIN_PROVIDER, szBuf, 256) == 0)
      return E_FAIL;

   *lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(TCHAR));
   if (*lpName == NULL)
      return E_OUTOFMEMORY;

   ocscpy(*lpName, T2OLE(szBuf));

   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++
CLoggingSnapinAbout::GetSnapinVersion

Enables the console to obtain the snap-in's version number.

Parameters

lpVersion 
[out] Pointer to the text making up the snap-in's version number. 


Return Values

S_OK 
The version number was successfully obtained. 


Remarks

Memory for out parameters must be allocated using CoTaskMemAlloc.
--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CLoggingSnapinAbout::GetSnapinVersion (LPOLESTR *lpVersion)
{
   CString version(LVER_PRODUCTVERSION_STR);

   *lpVersion = (LPOLESTR)CoTaskMemAlloc(
                              version.GetLength() + sizeof(WCHAR));

   if (*lpVersion == NULL)
   {
      return E_OUTOFMEMORY;
   }

   wcscpy(*lpVersion, (LPCWSTR)version);

   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++
CLoggingSnapinAbout::GetSnapinImage

Enables the console to obtain the snap-in's main icon to be used in the About box.

Parameters

hAppIcon 
[out] Pointer to the handle of the main icon of the snap-in that is to be used in the About property page. 

Return Values

S_OK 
The handle to the icon was successfully obtained. 

  ISSUE: What do I return if I can't get the icon?

Remarks

Memory for out parameters must be allocated using CoTaskMemAlloc.
--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CLoggingSnapinAbout::GetSnapinImage (HICON *hAppIcon)
{
   if ( NULL == (*hAppIcon = ::LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_NAP_SNAPIN_IMAGE) ) ) )
      return E_FAIL;

   return S_OK;
}


STDMETHODIMP CLoggingSnapinAbout::GetStaticFolderImage (
   HBITMAP *hSmallImage,
    HBITMAP *hSmallImageOpen,
    HBITMAP *hLargeImage,
    COLORREF *cMask)
{
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\locwarndlg.cpp ===
/****************************************************************************************
 * NAME:	LocWarnDlg.cpp
 *
 * CLASS:	CLocationWarningDialog
 *
 * OVERVIEW
 *
 * Internet Authentication Server: 
 *			This dialog box is used to warn the user when user changes policy
 *			location
 *
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History:	
 *				4/12/98		Created by	Byao	
 *
 *****************************************************************************************/

#include "Precompiled.h"
#include "LocWarnDlg.h"

// Constructor/Destructor
CLocationWarningDialog::CLocationWarningDialog()
{

}

CLocationWarningDialog::~CLocationWarningDialog()
{
}


LRESULT CLocationWarningDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	TRACE_FUNCTION("CLocationWarningDialog::OnInitDialog");

	return 1;  // Let the system set the focus
}


LRESULT CLocationWarningDialog::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	TRACE_FUNCTION("CLocationWarningDialog::OnOK");

	EndDialog(wID);
	return 0;
}


LRESULT CLocationWarningDialog::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	TRACE_FUNCTION("CLocationWarningDialog::OnCancel");
	EndDialog(wID);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\locwarndlg.h ===
/****************************************************************************************
 * NAME:	LocWarnDlg.h
 *
 * CLASS:	CLocationWarningDialog
 *
 * OVERVIEW
 *
 * Internet Authentication Server: NAP Location dialog
 *			This dialog box is used to change the Network Access Policy Location 
 *
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History:	
 *				4/12/98		Created by	Byao	
 *
 *****************************************************************************************/

#ifndef _LOCWARNDLG_H_
#define _LOCWARNDLG_H_

#include "dialog.h"

/////////////////////////////////////////////////////////////////////////////
// CLocationWarningDlg
class CLocationWarningDialog: public CIASDialog<CLocationWarningDialog>
{
public:
	CLocationWarningDialog();
	~CLocationWarningDialog();

	enum { IDD = IDD_DIALOG_POLICY_WARNING };

BEGIN_MSG_MAP(CLocationWarningDialog)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	
	CHAIN_MSG_MAP(CIASDialog<CLocationWarningDialog>)
END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

public:
};

#endif //_LOCWARNDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\logcomp.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    LogComp.h

Abstract:

   The CLoggingComponent class implements several interfaces which MMC uses:
   
   The IComponent interface is basically how MMC talks to the snap-in
   to get it to implement a right-hand-side "scope" pane.  There can be several
   objects implementing this interface instantiated at once.  These are best
   thought of as "views" on the single object implementing the IComponentData
   "document" (see ComponentData.cpp).

   The IExtendPropertySheet interface is how the snap-in adds property sheets
   for any of the items a user might click on.

   The IExtendContextMenu interface what we do to add custom entries
   to the menu which appears when a user right-clicks on a node.
   
   The IExtendControlBar interface allows us to support a custom
   iconic toolbar.

   See Component.cpp for implementation details.

Note:

   Much of the functionality of this class is implemented in atlsnap.h
   by IComponentImpl.  We are mostly overriding here.


Revision History:
   mmaguire 11/6/97 - created using MMC snap-in wizard


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_LOG_COMPONENT_H_)
#define _LOG_COMPONENT_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//Moved to Precompiled.h: #include <atlsnap.h>
//
//
// where we can find what this class has or uses:
//
#include "LogCompD.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


class CLoggingComponent :
     public CComObjectRootEx<CComSingleThreadModel>
   , public CSnapInObjectRoot<2, CLoggingComponentData>
   , public IExtendPropertySheetImpl<CLoggingComponent>
   , public IExtendContextMenuImpl<CLoggingComponent>
   , public IExtendControlbarImpl<CLoggingComponent>
   , public IResultDataCompare
   , public IExtendTaskPadImpl<CLoggingComponent>
   , public IComponentImpl<CLoggingComponent>
{

public:

   BEGIN_COM_MAP(CLoggingComponent)
      COM_INTERFACE_ENTRY(IComponent)
      COM_INTERFACE_ENTRY(IExtendPropertySheet2)
      COM_INTERFACE_ENTRY(IExtendContextMenu)
      COM_INTERFACE_ENTRY(IExtendControlbar)
      COM_INTERFACE_ENTRY(IResultDataCompare)
      COM_INTERFACE_ENTRY(IExtendTaskPad)
   END_COM_MAP()

   CLoggingComponent();

   ~CLoggingComponent();

   // We are overiding ATLsnap.h's IComponentImpl implementation of this
   // in order to correctly handle messages which it is incorrectly
   // ignoring (e.g. MMCN_COLUMN_CLICK and MMCN_SNAPINHELP)

   STDMETHOD(Notify)(
          LPDATAOBJECT lpDataObject
        , MMC_NOTIFY_TYPE event
        , LPARAM arg
        , LPARAM param
      );

   STDMETHOD(CompareObjects)(
           LPDATAOBJECT lpDataObjectA
         , LPDATAOBJECT lpDataObjectB
         );

   // IResultDataCompare
   STDMETHOD(Compare)(LPARAM lUserParam,
        MMC_COOKIE cookieA,
        MMC_COOKIE cookieB,
        int *pnResult);

   CSnapInItem * m_pSelectedNode;

protected:

   virtual HRESULT OnColumnClick(
        LPARAM arg
      , LPARAM param
      );

   virtual HRESULT OnViewChange( 
        LPARAM arg
      , LPARAM param
      );

   virtual HRESULT OnPropertyChange(   
        LPARAM arg
      , LPARAM param
      );

   virtual HRESULT OnAddImages(  
           LPARAM arg
         , LPARAM param
         );

   // html help
   HRESULT OnResultContextHelp(LPDATAOBJECT lpDataObject);
   
   HBITMAP m_hBitmap16;
   HBITMAP m_hBitmap32;
};

#endif // _LOG_COMPONENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\logcompd.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation

Module Name:

    LogCompD.cpp

Abstract:

   The CLoggingComponentData class implements several interfaces which MMC uses:

   The IComponentData interface is basically how MMC talks to the snap-in
   to get it to implement the left-hand-side "scope" pane.

   The IExtendPropertySheet interface is how the snap-in adds property sheets
   for any of the items a user might click on.

   The IExtendContextMenu interface what we do to add custom entries
   to the menu which appears when a user right-clicks on a node.

   The IExtendControlBar interface allows us to support a custom
   iconic toolbar.

   See ComponentData.cpp for implementation.

Note:

   Much of the functionality of this class is implemented in atlsnap.h
   by IComponentDataImpl.  We are mostly overriding here.

Revision History:
   mmaguire 11/6/97 - created using MMC snap-in wizard


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_LOG_COMPONENT_DATA_H_)
#define _LOG_COMPONENT_DATA_H_
#pragma once

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//Moved to Precompiled.h: #include <atlsnap.h>
//
//
// where we can find what this class has or uses:
//
#include "LogMacNd.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


   //
   // hack start
   //

   // This is a big hack to work around a atlsnap.h bug: Atlsnap.h
   // can't support extending multiple nodes. So we basically just
   // copied EXTENSION_SNAPIN_NODEINFO_ENTRY() here. We need to change
   // this after the atlsnap.h fix -- MAM: 08-06-98 -- yeah right
   //

   //
   // The following statements are copied from atlsnap.h and then changed
   // to support multiple extending node
   //
   // IsSupportedGUID will also set the m_enumExtendedSnapin flag in side m_##dataClass object
   // which, in our case, is CLoggingMachineNode
   //

#define EXTENSION_SNAPIN_NODEINFO_ENTRY_EX(dataClass) \
   if ( m_##dataClass.IsSupportedGUID( guid ) )\
   { \
      *ppItem = m_##dataClass.GetExtNodeObject(pDataObject, &m_##dataClass); \
      _ASSERTE(*ppItem != NULL); \
      (*ppItem)->InitDataClass(pDataObject, &m_##dataClass); \
      return hr; \
   }

   //
   // hack end
   //

class CLoggingComponent;

class CLoggingComponentData :
     public CComObjectRootEx<CComSingleThreadModel>
   , public CSnapInObjectRoot<1, CLoggingComponentData>
   , public IComponentDataImpl<CLoggingComponentData, CLoggingComponent>
   , public IExtendPropertySheetImpl<CLoggingComponentData>
   , public IExtendContextMenuImpl<CLoggingComponentData>
   , public IExtendControlbarImpl<CLoggingComponentData>
   , public ISnapinHelp
   , public CComCoClass<CLoggingComponentData, &CLSID_LoggingSnapin>,
     private IASTraceInitializer
{

public:

   CLoggingComponentData();
   ~CLoggingComponentData();

   DECLARE_NO_REGISTRY()

   EXTENSION_SNAPIN_DATACLASS(CLoggingMachineNode)

   BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CLoggingComponentData)
   EXTENSION_SNAPIN_NODEINFO_ENTRY_EX(CLoggingMachineNode)
   END_EXTENSION_SNAPIN_NODEINFO_MAP()

   BEGIN_COM_MAP(CLoggingComponentData)
      COM_INTERFACE_ENTRY(IComponentData)
      COM_INTERFACE_ENTRY(IExtendPropertySheet2)
      COM_INTERFACE_ENTRY(IExtendContextMenu)
      COM_INTERFACE_ENTRY(IExtendControlbar)
      COM_INTERFACE_ENTRY(ISnapinHelp)
   END_COM_MAP()


   DECLARE_NOT_AGGREGATABLE(CLoggingComponentData)

    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

   STDMETHOD(CompareObjects)(
        LPDATAOBJECT lpDataObjectA
      , LPDATAOBJECT lpDataObjectB
      );

   STDMETHOD(CreateComponent)(LPCOMPONENT *ppComponent);

   // ISnapinHelp method(s)
   STDMETHOD(GetHelpTopic)(LPOLESTR * lpCompiledHelpFile)
   {return E_UNEXPECTED;};

   // We are overiding ATLsnap.h's IComponentImpl implementation of this
   // in order to correctly handle messages which it is incorrectly
   // ignoring (e.g. MMCN_COLUMN_CLICK and MMCN_SNAPINHELP)
   STDMETHOD(Notify)(
          LPDATAOBJECT lpDataObject
        , MMC_NOTIFY_TYPE event
        , LPARAM arg
        , LPARAM param
      );

   virtual HRESULT OnPropertyChange(
        LPARAM arg
      , LPARAM param
      );
};

#endif // _LOG_COMPONENT_DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\logcompd.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    LogCompD.cpp

Abstract:

   Implementation file for the CLoggingComponentData class.

   The CLoggingComponentData class implements several interfaces which MMC uses:
   
   The IComponentData interface is basically how MMC talks to the snap-in
   to get it to implement the left-hand-side "scope" pane.  There is only one
   object implementing this interface instantiated -- it is best thought of as
   the main "document" on which the objects implementing the IComponent interface
   (see Component.cpp) are "views".

   The IExtendPropertySheet interface is how the snap-in adds property sheets
   for any of the items a user might click on.

   The IExtendContextMenu interface what we do to add custom entries
   to the menu which appears when a user right-clicks on a node.
   
   The IExtendControlBar interface allows us to support a custom
   iconic toolbar.

Note:

   Much of the functionality of this class is implemented in atlsnap.h
   by IComponentDataImpl.  We are mostly overriding here.


Revision History:
   mmaguire 11/6/97  - created using MMC snap-in wizard
   mmaguire 11/24/97 - hurricaned for better project structure

--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "LogCompD.h"
//
// where we can find declarations needed in this file:
//
#include "LogMacNd.h"
#include "LocalFileLoggingNode.h"
#include "LoggingMethodsNode.h"
#include "LogComp.h"
#include <stdio.h>
#include "ChangeNotification.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingComponentData::CLoggingComponentData

--*/
//////////////////////////////////////////////////////////////////////////////
CLoggingComponentData::CLoggingComponentData()
{
   ATLTRACE(_T("+NAPMMC+:# +++ CLoggingComponentData::CLoggingComponentData\n"));

   // We pass our CRootNode a pointer to this CLoggingComponentData.  This is so that
   // it and any of its children nodes have access to our member variables
   // and services, and thus we have snapin-global data if we need it
   // using the GetComponentData function.
// m_pNode = new CRootNode( this );
// _ASSERTE(m_pNode != NULL);

   m_pComponentData = this;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingComponentData::~CLoggingComponentData

--*/
//////////////////////////////////////////////////////////////////////////////
CLoggingComponentData::~CLoggingComponentData()
{
   ATLTRACE(_T("+NAPMMC+:# --- CLoggingComponentData::~CLoggingComponentData\n"));

// delete m_pNode;
// m_pNode = NULL;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingComponentData::Initialize

HRESULT Initialize(
  LPUNKNOWN pUnknown  // Pointer to console's IUnknown.
);

Called by MMC to initialize the IComponentData object.


Parameters

   pUnknown [in] Pointer to the console's IUnknown interface. This interface
   pointer can be used to call QueryInterface for IConsole and IConsoleNameSpace.


Return Values

   S_OK  The component was successfully initialized.

   E_UNEXPECTED
   An unexpected error occurred.


Remarks

   IComponentData::Initialize is called when a snap-in is being created and has
   items in the scope pane to enumerate. The pointer to IConsole that is passed
   in is used to make QueryInterface calls to the console for interfaces such as
   IConsoleNamespace. The snap-in should also call IConsole::QueryScopeImageList
   to get the image list for the scope pane and add images to be displayed on
   the scope pane side.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CLoggingComponentData::Initialize (LPUNKNOWN pUnknown)
{

   ATLTRACE(_T("+NAPMMC+:# CLoggingComponentData::Initialize\n"));

   // MAM: special for extention snapin:
   m_CLoggingMachineNode.m_pComponentData = this;


   HRESULT hr = IComponentDataImpl<CLoggingComponentData, CLoggingComponent >::Initialize(pUnknown);
   if (FAILED(hr))
   {
      ATLTRACE(_T("+NAPMMC+:***FAILED***: CLoggingComponentData::Initialize -- Base class initialization\n"));
      return hr;
   }

   CComPtr<IImageList> spImageList;

   if (m_spConsole->QueryScopeImageList(&spImageList) != S_OK)
   {
      ATLTRACE(_T("+NAPMMC+:***FAILED***: IConsole::QueryScopeImageList failed\n"));
      return E_UNEXPECTED;
   }

   // Load bitmaps associated with the scope pane
   // and add them to the image list

   HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_NAPSNAPIN_16));
   if (hBitmap16 == NULL)
   {
      ATLTRACE(_T("+NAPMMC+:***FAILED***: CLoggingComponentData::Initialize -- LoadBitmap\n"));
      //ISSUE: Will MMC still be able to function if this fails?
      return S_OK;
   }

   HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_NAPSNAPIN_32));
   if (hBitmap32 == NULL)
   {
      ATLTRACE(_T("+NAPMMC+:***FAILED***: CLoggingComponentData::Initialize -- LoadBitmap\n"));
      //ISSUE: Will MMC still be able to function if this fails?

      //ISSUE: Should DeleteObject previous hBitmap16 since it was successfully loaded.
      
      return S_OK;
   }

   if (spImageList->ImageListSetStrip((LONG_PTR*)hBitmap16, (LONG_PTR*)hBitmap32, 0, RGB(255, 0, 255)) != S_OK)
   {
      ATLTRACE(_T("+NAPMMC+:***FAILED***: CLoggingComponentData::Initialize  -- ImageListSetStrip\n"));
      return E_UNEXPECTED;
   }

   // ISSUE: Do we need to release the HBITMAP objects?
   // This wasn't done wizard-generated code -- does MMC make a copy of these or
   // does it take care of deleting the ones we passed to it?
   // DeleteObject( hBitmap16 );
   // DeleteObject( hBitmap32 );
   
   //
   //  NAP snap-in will need to use ListView common control to display
   //  attribute types for a particular rule. We need to initialize the common
   //  controls during initialization. This can ensure COMTRL32.DLL is loaded
   //
   INITCOMMONCONTROLSEX initCommCtrlsEx;

   initCommCtrlsEx.dwSize = sizeof(INITCOMMONCONTROLSEX);
   initCommCtrlsEx.dwICC = ICC_WIN95_CLASSES ;

   if (!InitCommonControlsEx(&initCommCtrlsEx))
   {
      ATLTRACE(_T("+NAPMMC+:***FAILED***: CLoggingComponentData::Initialize  -- InitCommonControlsEx()\n"));
      return E_UNEXPECTED;
   }
   return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CLoggingComponentData::CompareObjects

Needed so that IPropertySheetProvider::FindPropertySheet will work.

FindPropertySheet is used to bring a pre-existing property sheet to the foreground
so that we don't open multiple copies of Properties on the same node.

It requires CompareObjects to be implemented on both IComponent and IComponentData.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CLoggingComponentData::CompareObjects(
        LPDATAOBJECT lpDataObjectA
      , LPDATAOBJECT lpDataObjectB
      )
{
   ATLTRACE(_T("+NAPMMC+:# CLoggingComponentData::CompareObjects\n"));

   HRESULT hr;

   CSnapInItem *pDataA, *pDataB;
   DATA_OBJECT_TYPES typeA, typeB;

   hr = GetDataClass(lpDataObjectA, &pDataA, &typeA);
   if ( FAILED( hr ) )
   {
      return hr;
   }
   
   hr = GetDataClass(lpDataObjectB, &pDataB, &typeB);
   if ( FAILED( hr ) )
   {
      return hr;
   }

   if( pDataA == pDataB )
   {
      // They are the same object.
      return S_OK;
   }
   else
   {
      // They are different.
      return S_FALSE;
   }
}


/////////////////////////////////////////////////////////////////////////////
/*++

CLoggingComponentData::CreateComponent

We override the ATLsnap.h implementation so that we can save away our 'this'
pointer into the CLoggingComponent object we create.  This way the IComponent object
has knowledge of the CLoggingComponentData object to which it belongs.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CLoggingComponentData::CreateComponent(LPCOMPONENT *ppComponent)
{
   ATLTRACE(_T("# CLoggingComponentData::CreateComponent\n"));

   HRESULT hr = E_POINTER;

   ATLASSERT(ppComponent != NULL);
   if (ppComponent == NULL)
      ATLTRACE(_T("# IComponentData::CreateComponent called with ppComponent == NULL\n"));
   else
   {
      *ppComponent = NULL;
      
      CComObject< CLoggingComponent >* pComponent;
      hr = CComObject< CLoggingComponent >::CreateInstance(&pComponent);
      ATLASSERT(SUCCEEDED(hr));
      if (FAILED(hr))
         ATLTRACE(_T("# IComponentData::CreateComponent : Could not create IComponent object\n"));
      else
      {
         hr = pComponent->QueryInterface(IID_IComponent, (void**)ppComponent);
      
         pComponent->m_pComponentData = this;
      }
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingComponentData::Notify

Notifies the snap-in of actions taken by the user.

HRESULT Notify(
  LPDATAOBJECT lpDataObject,  // Pointer to a data object
  MMC_NOTIFY_TYPE event,  // Action taken by a user
  LPARAM arg,               // Depends on event
  LPARAM param              // Depends on event
);


Parameters

   lpDataObject
   [in] Pointer to the data object of the currently selected item.

   event
   [in] Identifies an action taken by a user. IComponent::Notify can receive the
   following notifications:

      MMCN_ACTIVATE
      MMCN_ADD_IMAGES
      MMCN_BTN_CLICK
      MMCN_CLICK
      MMCN_DBLCLICK
      MMCN_DELETE
      MMCN_EXPAND
      MMCN_MINIMIZED
      MMCN_PROPERTY_CHANGE
      MMCN_REMOVE_CHILDREN
      MMCN_RENAME
      MMCN_SELECT
      MMCN_SHOW
      MMCN_VIEW_CHANGE

   All of which are forwarded to each node's Notify method, as well as:

      MMCN_COLUMN_CLICK
      MMCN_SNAPINHELP

   Which are handled here.


   arg
   Depends on the notification type.

   param
   Depends on the notification type.


Return Values

   S_OK
   Depends on the notification type.

   E_UNEXPECTED
   An unexpected error occurred.


Remarks

   We are overiding the ATLsnap.h implementation of IComponentImpl because
   it always returns E_UNEXPECTED when lpDataObject == NULL.
   Unfortunately, some valid message (e.g. MMCN_SNAPINHELP and MMCN_COLUMN_CLICK)
   pass in lpDataObject = NULL   by design.

   Also, there seems to be some problem with Sridhar's latest
   IComponentImpl::Notify method, because it causes MMC to run-time error.


--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CLoggingComponentData::Notify (
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
{
   ATLTRACE(_T("# CLoggingComponentData::Notify\n"));

   // Check for preconditions:
   // None.

   HRESULT hr;

   // lpDataObject should be a pointer to a node object.
   // If it is NULL, then we are being notified of an event
   // which doesn't pertain to any specific node.

   if ( NULL == lpDataObject )
   {
      // respond to events which have no associated lpDataObject

      switch( event )
      {

      case MMCN_PROPERTY_CHANGE:
         hr = OnPropertyChange( arg, param );
         break;

      default:
         ATLTRACE(_T("# CLoggingComponent::Notify - called with lpDataObject == NULL and no event handler\n"));
         hr = E_NOTIMPL;
         break;
      }
      return hr;
   }

   // We were passed a LPDATAOBJECT which corresponds to a node.
   // We convert this to the ATL ISnapInDataInterface pointer.
   // This is done in GetDataClass (a static method of ISnapInDataInterface)
   // by asking the dataobject via a supported clipboard format (CCF_GETCOOKIE)
   // to write out a pointer to itself on a stream and then
   // casting this value to a pointer.
   // We then call the Notify method on that object, letting
   // the node object deal with the Notify event itself.

   CSnapInItem* pItem;
   DATA_OBJECT_TYPES type;
   hr = m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
   
   ATLASSERT(SUCCEEDED(hr));
   
   if (SUCCEEDED(hr))
   {
      hr = pItem->Notify( event, arg, param, this, NULL, type );
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingComponentData::OnPropertyChange

HRESULT OnPropertyChange(  
           LPARAM arg
         , LPARAM param
         )

This is where we respond to an MMCN_PROPERTY_CHANGE notification.

This notification is sent when we call MMCPropertyChangeNotify.
We call this in our property pages when changes are made to the data
they contain and we may need to update of view of the data.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLoggingComponentData::OnPropertyChange(   
           LPARAM arg
         , LPARAM lParam
         )
{
   ATLTRACE(_T("# CLoggingComponentData::OnPropertyChange\n"));

   // Check for preconditions:
   _ASSERTE( m_spConsole != NULL );

   HRESULT hr = S_FALSE;

   if( lParam != NULL )
   {

      // We were passed a pointer to a CChangeNotification in the param argument.

      CChangeNotification * pChangeNotification = (CChangeNotification *) lParam;
      
      // We call notify on the node specified, passing it our own custom event type
      // so that it knows that it must refresh its data.

      // Call notify on this node with the MMCN_PROPERTY_CHANGE notification.
      // We had to use this trick because of the fact that we are using template
      // classes and so we have no common object among all our nodes
      // other than CSnapInItem.  But we can't change CSnapInItem
      // so instead we use the notify method it already has with a new
      // notification.
      
      // Note:  We are trying to deal gracefully here with the fact that the
      // MMCN_PROPERTY_CHANGE notification doesn't pass us an lpDataObject
      // so we have to have our own protocol for picking out which node
      // needs to update itself.
      
      hr = pChangeNotification->m_pNode->Notify( MMCN_PROPERTY_CHANGE
                     , NULL
                     , NULL
                     , NULL
                     , NULL
                     , (DATA_OBJECT_TYPES) 0
                     );

      // We want to make sure all views with this node select also get updated.
      // Pass it the CChangeNotification pointer we were passed in param.
      hr = m_spConsole->UpdateAllViews( NULL, lParam, 0);

      pChangeNotification->Release();
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\logcomp.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    LogComp.cpp

Abstract:

	Implementation file for the CLoggingComponent class.

	The CLoggingComponent class implements several interfaces which MMC uses:
	
	The IComponent interface is basically how MMC talks to the snap-in
	to get it to implement a right-hand-side "scope" pane.  There can be several
	objects implementing this interface instantiated at once.  These are best
	thought of as "views" on the single object implementing the IComponentData
	"document" (see ComponentData.cpp).

	The IExtendPropertySheet interface is how the snap-in adds property sheets
	for any of the items a user might click on.

	The IExtendContextMenu interface what we do to add custom entries
	to the menu which appears when a user right-clicks on a node.
	
	The IExtendControlBar interface allows us to support a custom
	iconic toolbar.

	The IResultDataCompare interface allows us to support a custom
	sorting algorithm for result pane items

Note:

	Much of the functionality of this class is implemented in atlsnap.h
	by IComponentDataImpl.  We are mostly overriding here.

Revision History:
	mmaguire 11/6/97	- created using MMC snap-in wizard
	mmaguire 11/24/97	- hurricaned for better project structure

--*/
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "LogComp.h"
//
// where we can find declarations needed in this file:
//
#include "LogMacNd.h"
#include "LocalfileLoggingNode.h"
#include "LoggingMethodsNode.h"
#include "ChangeNotification.h"

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingComponent::CLoggingComponent

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CLoggingComponent::CLoggingComponent()
{
	TRACE_FUNCTION("CLoggingComponent::CLoggingComponent");

	m_pSelectedNode = NULL;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingComponent::~CLoggingComponent

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CLoggingComponent::~CLoggingComponent()
{
	TRACE_FUNCTION("CLoggingComponent::~CLoggingComponent");
}


//+---------------------------------------------------------------------------
//
// Function:  Compare
//
// Class:	  CLoggingComponent  (inherited from IResultDataCompare)
//
// Synopsis:  customized sorting algorithm
//			  This method will be called whenever MMC console needs to
//			  compare two result pane data items, for example, when user
//			  clicks on the column header
//
// Arguments:
//	  LPARAM lUserParam,   User-provided information
//	  MMC_COOKIE cookieA,      Unique identifier of first object
//	  MMC_COOKIE cookieB,      Unique identifier of second object
//	  int * pnResult     Column being sorted//
//
// Returns:   STDMETHODIMP -
//
// History:   Created byao		2/5/98 4:19:10 PM
//
//+---------------------------------------------------------------------------
STDMETHODIMP CLoggingComponent::Compare(LPARAM lUserParam,
							MMC_COOKIE cookieA,
							MMC_COOKIE cookieB,
							int *pnResult)
{
	TRACE_FUNCTION("CLoggingComponent::Compare");

	//
	// sort policies node according to their merit value
	//
	CLocalFileLoggingNode *pA = (CLocalFileLoggingNode*)cookieA;
	CLocalFileLoggingNode *pB = (CLocalFileLoggingNode*)cookieB;

	ATLASSERT(pA != NULL);
	ATLASSERT(pB != NULL);

	//*pnResult = pA->GetMerit() > pB->GetMerit();
    *pnResult = 0;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingComponent::Notify

Notifies the snap-in of actions taken by the user.

HRESULT Notify(
  LPDATAOBJECT lpDataObject,  // Pointer to a data object
  MMC_NOTIFY_TYPE event,  // Action taken by a user
  LPARAM arg,               // Depends on event
  LPARAM param              // Depends on event
);


Parameters

	lpDataObject
	[in] Pointer to the data object of the currently selected item.

	event
	[in] Identifies an action taken by a user. IComponent::Notify can receive the
	following notifications:

		MMCN_ACTIVATE
		MMCN_ADD_IMAGES
		MMCN_BTN_CLICK
		MMCN_CLICK
		MMCN_DBLCLICK
		MMCN_DELETE
		MMCN_EXPAND
		MMCN_MINIMIZED
		MMCN_PROPERTY_CHANGE
		MMCN_REMOVE_CHILDREN
		MMCN_RENAME
		MMCN_SELECT
		MMCN_SHOW
		MMCN_VIEW_CHANGE

	All of which are forwarded to each node's Notify method, as well as:

		MMCN_COLUMN_CLICK
		MMCN_SNAPINHELP

	Which are handled here.


	arg
	Depends on the notification type.

	param
	Depends on the notification type.


Return Values

	S_OK
	Depends on the notification type.

	E_UNEXPECTED
	An unexpected error occurred.


Remarks

	We are overiding the ATLsnap.h implementation of IComponentImpl because
	it always returns E_UNEXPECTED when lpDataObject == NULL.
	Unfortunately, some valid message (e.g. MMCN_SNAPINHELP and MMCN_COLUMN_CLICK)
	pass in lpDataObject = NULL	by design.

	Also, there seems to be some problem with Sridhar's latest
	IComponentImpl::Notify method, because it causes MMC to run-time error.


--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CLoggingComponent::Notify (
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param
		)
{
	TRACE_FUNCTION("CLoggingComponent::Notify");

	HRESULT hr;

	// deal with help
	if(event == MMCN_CONTEXTHELP)
	{
      return OnResultContextHelp(lpDataObject);
   }

	// lpDataObject should be a pointer to a node object.
	// If it is NULL, then we are being notified of an event
	// which doesn't pertain to any specific node.

	if ( NULL == lpDataObject )
	{
		// respond to events which have no associated lpDataObject
		switch( event )
		{
		case MMCN_COLUMN_CLICK:
			hr = OnColumnClick( arg, param );
			break;

		case MMCN_PROPERTY_CHANGE:
			hr = OnPropertyChange( arg, param );
			break;

		case MMCN_VIEW_CHANGE:
			hr = OnViewChange( arg, param );
			break;

		default:
			ATLTRACE(_T("+NAPMMC+:# CLoggingComponent::Notify - called with lpDataObject == NULL and no event handler\n"));
			hr = E_NOTIMPL;
			break;
		}
		return hr;
	}

	// Respond to some notifications where the lpDataObject is not NULL
	// but we nevertheless have decided that we want to handle them on a
	// per-IComponent basis.

	switch( event )
	{

	case MMCN_ADD_IMAGES:
		hr = OnAddImages( arg, param );
		return hr;
		break;

	}

	// We were passed a LPDATAOBJECT which corresponds to a node.
	// We convert this to the ATL ISnapInDataInterface pointer.
	// This is done in GetDataClass (a static method of ISnapInDataInterface)
	// by asking the dataobject via a supported clipboard format (CCF_GETCOOKIE)
	// to write out a pointer to itself on a stream and then
	// casting this value to a pointer.
	// We then call the Notify method on that object, letting
	// the node object deal with the Notify event itself.

	CSnapInItem* pData;
	DATA_OBJECT_TYPES type;
	hr = CSnapInItem::GetDataClass(lpDataObject, &pData, &type);
	
	if (SUCCEEDED(hr))
	{
		// We need a richer Notify method which has information about the IComponent and IComponentData objects
		//hr = pData->Notify(event, arg, param, TRUE, m_spConsole, NULL, NULL);

		hr = pData->Notify(event, arg, param, NULL, this, type );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CLoggingComponent::CompareObjects

Needed so that IPropertySheetProvider::FindPropertySheet will work.

FindPropertySheet is used to bring a pre-existing property sheet to the foreground
so that we don't open multiple copies of Properties on the same node.

It requires CompareObjects to be implemented on both IComponent and IComponentData.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CLoggingComponent::CompareObjects(
		  LPDATAOBJECT lpDataObjectA
		, LPDATAOBJECT lpDataObjectB
		)
{
	TRACE_FUNCTION("CLoggingComponent::CompareObjects");

	HRESULT hr;

	CSnapInItem *pDataA, *pDataB;
	DATA_OBJECT_TYPES typeA, typeB;

	hr = GetDataClass(lpDataObjectA, &pDataA, &typeA);
	if ( FAILED( hr ) )
	{
		return hr;
	}
	
	hr = GetDataClass(lpDataObjectB, &pDataB, &typeB);
	if ( FAILED( hr ) )
	{
		return hr;
	}

	if( pDataA == pDataB )
	{
		// They are the same object.
		return S_OK;
	}
	else
	{
		// They are different.
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
/*++

CLoggingComponent::OnColumnClick

HRESULT OnColumnClick(	
			  LPARAM arg
			, LPARAM param
			)

In our implementation, this method gets called when the MMCN_COLUMN_CLICK
Notify message is sent for our IComponent object.

MMC sends this message when the user clicks on a result-list view column header.


Parameters

	arg
	Column number.

	param
	Sort option flags. By default, the sort is in ascending order. To specify descending order, use the RSI_DESCENDING (0x0001) flag.


Return Values
	
	Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLoggingComponent::OnColumnClick(
	  LPARAM arg
	, LPARAM param
	)
{
	TRACE_FUNCTION("CLoggingComponent::OnColumnClick -- Not implemented");

	return E_NOTIMPL;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingComponent::OnViewChange

HRESULT OnViewChange(	
			  LPARAM arg
			, LPARAM param
			)

This is where we respond to an MMCN_VIEW_CHANGE notification which was
set without any reference to a specific node.

In our implementation, this is a signal to refresh the view of the currently
selected node for this IComponent's view.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLoggingComponent::OnViewChange(	
			  LPARAM arg
			, LPARAM param
			)
{
	ATLTRACE(_T("+NAPMMC+:# CLoggingComponent::OnViewChange\n"));

	HRESULT hr = S_FALSE;

	CChangeNotification *pChangeNotification = NULL;

	try
	{

		// If arg here is non-NULL, it should be a pointer to a CChangeNotification object.
		if( arg != NULL )
		{
			pChangeNotification = (CChangeNotification *) arg;

			// For now, just call update item on the node.
			
			// ISSUE: Later, we should have a switch on m_dwFlags to see what we should do.
			// e.g. in the case of a deletion, we should (maybe?) reselect parent node or something.

			switch( pChangeNotification->m_dwFlags )
			{
			case CHANGE_UPDATE_RESULT_NODE:
				{
					// We need to update a single node.
					
					CComQIPtr< IResultData, &IID_IResultData > spResultData( m_spConsole );
					if( ! spResultData )
					{
						throw hr;
					}

					if( pChangeNotification->m_pNode )
					{
						HRESULTITEM item;
						hr = spResultData->FindItemByLParam( (LPARAM) pChangeNotification->m_pNode, &item );
						// Note: You can't use the itemID stored in CSnapInItem's RESULTDATAITEM structure
						// as this itemID is unique to each view -- so when you add the same item in each
						// result pane view, you get a different itemID from each call to InsertItem.
						// CSnapInItem's RESULTDATAITEM structure only stores the last one stored.
						// This is a flaw in the atlsnap.h architecture, which is why we use
						// MMC's FindItemByLParam instead to get the appropriate itemID.
						hr = spResultData->UpdateItem( item );
					}
				}
				break;
			case CHANGE_UPDATE_CHILDREN_OF_SELECTED_NODE:
				{
					// We basically tell MMC to simulate reselecting the
					// currently selected scope-pane node, which causes it to redraw.
					// This will cause MMC to send the MMCN_SHOW notification
					// to the selected node.
					if( m_pSelectedNode )
					{
						SCOPEDATAITEM *pScopeDataItem;
						m_pSelectedNode->GetScopeData( &pScopeDataItem );
						hr = m_spConsole->SelectScopeItem( pScopeDataItem->ID );
					}

				}
				break;
			case CHANGE_UPDATE_CHILDREN_OF_THIS_NODE:
				{
					// We basically tell MMC to simulate reselecting the
					// currently selected scope-pane node, which causes it to redraw.
					// This will cause MMC to send the MMCN_SHOW notification
					// to the selected node.
					if( pChangeNotification->m_pNode && m_pSelectedNode && pChangeNotification->m_pNode == m_pSelectedNode )
					{
						SCOPEDATAITEM *pScopeDataItem;
						m_pSelectedNode->GetScopeData( &pScopeDataItem );
						hr = m_spConsole->SelectScopeItem( pScopeDataItem->ID );
					}
				}

			default:
				break;
			}
		}
	}
	catch(...)
	{
		// Do nothing -- just need to catch for proper clean-up below.
	}

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingComponent::OnAddImages

HRESULT OnAddImages(	
			  LPARAM arg
			, LPARAM param
			)

This is where we respond to an MMCN_ADD_IMAGES notification to
this IComponent object.

We add images to the image list used to display result pane
items corresponding to this IComponent's view.

MMC sends this message to the snap-in's IComponent implementation
to add images for the result pane.

Parameters

	arg
	Pointer to the result pane's image list (IImageList).

	param
	Specifies the HSCOPEITEM of the item that was selected or deselected.


Return Values

	Not used.


Remarks

	The primary snap-in should add images for both folders and leaf
	items. Extension snap-ins should add only folder images.


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLoggingComponent::OnAddImages(	
			  LPARAM arg
			, LPARAM param
			)
{
	ATLTRACE(_T("# CLoggingComponent::OnAddImages\n"));

	// Check for preconditions:
	_ASSERTE( arg != NULL );

	HRESULT hr = S_FALSE;

	// ISSUE: sburns in localsec does a trick where he combines
	// scope and result pane ImageLists into one
	// is this necessary?
	
	CComPtr<IImageList> spImageList = reinterpret_cast<IImageList*>(arg);
	_ASSERTE( spImageList != NULL );

	HBITMAP hBitmap16 = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE( IDB_NAPSNAPIN_16 ) );
	HBITMAP hBitmap32 = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE( IDB_NAPSNAPIN_32 ) );

	if( hBitmap16 != NULL && hBitmap32 != NULL )
	{
		hr = spImageList->ImageListSetStrip( (LONG_PTR*) hBitmap16, (LONG_PTR*) hBitmap32, 0, RGB(255, 0, 255) );
		if( FAILED( hr ) )
		{
			ATLTRACE(_T("# *** CSnapinNode::OnAddImages  -- Failed to add images.\n"));
		}
	}

   if ( hBitmap16 != NULL )
   {
      DeleteObject(hBitmap16);
   }

   if ( hBitmap32 != NULL )
   {
      DeleteObject(hBitmap32);
   }

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingComponent::OnPropertyChange

HRESULT OnPropertyChange(	
			  LPARAM arg
			, LPARAM param
			)

This is where we respond to an MMCN_PROPERTY_CHANGE notification.

This notification is sent when we call MMCPropertyChangeNotify.
We call this in our property pages when changes are made to the data
they contain and we may need to update of view of the data.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLoggingComponent::OnPropertyChange(	
			  LPARAM lArg
			, LPARAM lParam
			)
{
	ATLTRACE(_T("# CNodeWithResultChildrenList::OnPropertyChange\n"));

	// Check for preconditions:
	_ASSERTE( m_spConsole != NULL );

	HRESULT hr = S_FALSE;

	if( lParam )
	{
		// We were passed a pointer to a CChangeNotification in the param argument.

		CChangeNotification * pChangeNotification = (CChangeNotification *) lParam;

		// We call notify on the node specified, passing it our own custom event type
		// so that it knows that it must refresh its data.

		// Call notify on this node with the MMCN_PROPERTY_CHANGE notification.
		// We had to use this trick because of the fact that we are using template
		// classes and so we have no common object among all our nodes
		// other than CSnapInItem.  But we can't change CSnapInItem
		// so instead we use the notify method it already has with a new
		// notification.
		
		// Note:  We are trying to deal gracefully here with the fact that the
		// MMCN_PROPERTY_CHANGE notification doesn't pass us an lpDataObject
		// so we have to have our own protocol for picking out which node
		// needs to update itself.
		
		hr = pChangeNotification->m_pNode->Notify( MMCN_PROPERTY_CHANGE
							, NULL
							, NULL
							, NULL
							, NULL
							, (DATA_OBJECT_TYPES) 0
							);

		// We want to make sure all views with this node select also get updated.
		// Pass it the CChangeNotification pointer we were passed in param.
		hr = m_pComponentData->m_spConsole->UpdateAllViews( NULL, lParam, 0);
	
		pChangeNotification->Release();
	
	}
	return hr;
}


/*!--------------------------------------------------------------------------
	CComponent::OnResultContextHelp
		Implementation of OnResultContextHelp
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CLoggingComponent::OnResultContextHelp(LPDATAOBJECT lpDataObject)
{
   // Need to find if the context is running in the Remote Access snap-in 
   // or in the IAS snapin.
   const WCHAR szIASDefaultHelpTopic[] = L"ias_ops.chm::/sag_ias_log_conc.htm";
   const WCHAR szRASDefaultHelpTopic[] = L"RRASconcepts.chm::" \
                                         L"/sag_RRAS-Ch1_84.htm";

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   bool isRasSnapin = false;
   CSnapInItem* pItem;
   DATA_OBJECT_TYPES type;

   HRESULT hr = GetDataClass(lpDataObject, &pItem, &type);

   if ( SUCCEEDED(hr) ) 
   {
      isRasSnapin = (pItem->m_helpIndex == RAS_HELP_INDEX);
   } 

   CComPtr<IDisplayHelp>  spDisplayHelp;

   hr = m_spConsole->QueryInterface(
                        __uuidof(IDisplayHelp), 
                        (LPVOID*) &spDisplayHelp
                        );
   
   ASSERT (SUCCEEDED (hr));
   if ( SUCCEEDED (hr) )
   {
      if ( isRasSnapin )
      {
         hr = spDisplayHelp->ShowTopic(W2OLE ((LPWSTR)szRASDefaultHelpTopic));
      }
      else
      {
         hr = spDisplayHelp->ShowTopic(W2OLE ((LPWSTR)szIASDefaultHelpTopic));
      }

      ASSERT (SUCCEEDED (hr));
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\loggingmethod.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the class LoggingMethod.
//
///////////////////////////////////////////////////////////////////////////////

#include "Precompiled.h"
#include "logcomp.h"
#include "logcompd.h"
#include "loggingmethod.h"
#include "loggingmethodsnode.h"
#include "snapinnode.cpp"


LoggingMethod::LoggingMethod(long sdoId, CSnapInItem* parent)
   : CSnapinNode<
        LoggingMethod,
        CLoggingComponentData,
        CLoggingComponent
        >(parent),
     componentId(sdoId)
{
}


LoggingMethod::~LoggingMethod() throw ()
{
}


HRESULT LoggingMethod::InitSdoPointers(ISdo* machine) throw ()
{
   if (machine == 0)
   {
      return E_POINTER;
   }

   CComPtr<ISdo> newConfigSdo;
   HRESULT hr = SDOGetSdoFromCollection(
                   machine,
                   PROPERTY_IAS_REQUESTHANDLERS_COLLECTION,
                   PROPERTY_COMPONENT_ID,
                   componentId,
                   &newConfigSdo
                   );
   if (FAILED(hr))
   {
      return hr;
   }

   CComPtr<ISdoServiceControl> newControlSdo;
   hr = machine->QueryInterface(
                    __uuidof(ISdoServiceControl),
                    reinterpret_cast<void**>(&newControlSdo)
                    );
   if (FAILED(hr))
   {
      return hr;
   }

   configSdo = newConfigSdo;
   controlSdo = newControlSdo;

   return LoadCachedInfoFromSdo();
}


CLoggingMethodsNode* LoggingMethod::Parent() const throw ()
{
   return static_cast<CLoggingMethodsNode*>(m_pParentNode);
}


CLoggingComponentData* LoggingMethod::GetComponentData()
{
   return (Parent() != 0) ? Parent()->GetComponentData() : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\loggingmethodsnode.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    LoggingMethodsNode.h

Abstract:

   Header file for the CLoggingMethodsNode subnode.

   See LoggingMethodsNode.cpp for implementation.

Author:

    Michael A. Maguire 12/15/97

Revision History:
   mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_LOG_LOGGING_METHODS_NODE_H_)
#define _LOG_LOGGING_METHODS_NODE_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "NodeWithResultChildrenList.h"
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

class CLocalFileLoggingNode;
class CLoggingMachineNode;
class LoggingMethod;
class CLoggingComponentData;
class CLoggingComponent;

class CLoggingMethodsNode
   : public CNodeWithResultChildrenList<
               CLoggingMethodsNode,
               LoggingMethod,
               CSimpleArray<LoggingMethod*>,
               CLoggingComponentData,
               CLoggingComponent
               >
{
public:

   SNAPINMENUID(IDM_LOGGING_METHODS_NODE)

   BEGIN_SNAPINTOOLBARID_MAP(CLoggingMethodsNode)
//    SNAPINTOOLBARID_ENTRY(IDR_LOGGING_METHODS_TOOLBAR)
   END_SNAPINTOOLBARID_MAP()

   HRESULT DataRefresh( ISdo* pServiceSdo );

   // Constructor/Destructor
   CLoggingMethodsNode(CSnapInItem * pParentNode, bool extendRasNode);
   ~CLoggingMethodsNode();

   STDMETHOD(FillData)(CLIPFORMAT cf, LPSTREAM pStream);

   virtual HRESULT OnRefresh(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         );

   // Used to get access to snapin-global data.
   CLoggingComponentData * GetComponentData( void );

   // Used to get access to server-global data.
   CLoggingMachineNode * GetServerRoot( void );

   // SDO management.
   HRESULT InitSdoPointers( ISdo *pSdo );
   HRESULT LoadCachedInfoFromSdo( void );

   // Some overrides for standard MMC functionality.
   OLECHAR* GetResultPaneColInfo( int nCol );
   HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );
   HRESULT PopulateResultChildrenList( void );
   HRESULT SetVerbs( IConsoleVerb * pConsoleVerb );

   // Our own handling of property page changes.
   HRESULT OnPropertyChange(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );

   bool m_ExtendRas;

private:
   typedef CNodeWithResultChildrenList<
              CLoggingMethodsNode,
              LoggingMethod,
              CSimpleArray<LoggingMethod*>,
              CLoggingComponentData,
              CLoggingComponent
              > MyBaseClass;

   // pointer to our root Server Data Object;
   CComPtr<ISdo>  m_spSdo;
};

#endif // _IAS_LOGGING_METHODS_NODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\loggingmethodsnode.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation

Module Name:

    LoggingMethodsNode.cpp

Abstract:

   Implementation file for the CLoggingMethodsNode class.


Author:

    Michael A. Maguire 12/15/97

Revision History:
   mmaguire 12/15/97 - created

--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"

//
// where we can find declaration for main class in this file:
//
#include "LoggingMethodsNode.h"
//
//
// where we can find declarations needed in this file:
//
#include "LocalFileLoggingNode.h"
#include "LogCompD.h"   // this must be included before NodeWithResultChildrenList.cpp
#include "LogComp.h"    // this must be included before NodeWithResultChildrenList.cpp
#include "NodeWithResultChildrenList.cpp" // Implementation of template class.
#include "LogMacNd.h"
#include "dbnode.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

#define COLUMN_WIDTH__LOGGING_METHOD   150
#define COLUMN_WIDTH__DESCRIPTION      300


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMethodsNode::CLoggingMethodsNode

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CLoggingMethodsNode::CLoggingMethodsNode(
                        CSnapInItem* pParentNode,
                        bool extendRasNode
                        )
   : MyBaseClass(pParentNode, (extendRasNode ? RAS_HELP_INDEX : 0)),
     m_ExtendRas(extendRasNode)
{
   ATLTRACE(_T("# +++ CLoggingMethodsNode::CLoggingMethodsNode\n"));

   // Check for preconditions:
   // None.

   // Set the display name for this object
   TCHAR lpszName[IAS_MAX_STRING];
   int nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_LOGGING_METHODS_NODE__NAME, lpszName, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );

   m_bstrDisplayName = lpszName;

   // In IComponentData::Initialize, we are asked to inform MMC of
   // the icons we would like to use for the scope pane.
   // Here we store an index to which of these images we
   // want to be used to display this node
   m_scopeDataItem.nImage =      IDBI_NODE_LOGGING_METHODS_CLOSED;
   m_scopeDataItem.nOpenImage =  IDBI_NODE_LOGGING_METHODS_OPEN;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMethodsNode::InitSdoPointers

Call as soon as you have constructed this class and pass in it's SDO pointer.

--*/
//////////////////////////////////////////////////////////////////////////////
    HRESULT CLoggingMethodsNode::InitSdoPointers( ISdo *pSdo )
{
   ATLTRACE(_T("# CLoggingMethodsNode::InitSdoPointers\n"));

   // Check for preconditions:
   _ASSERTE( pSdo != NULL );

   HRESULT hr = S_OK;

   // Release the old pointer if we had one.
   if( m_spSdo != NULL )
   {
      m_spSdo.Release();
   }

   // Save our client sdo pointer.
   m_spSdo = pSdo;

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMethodsNode::~CLoggingMethodsNode

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CLoggingMethodsNode::~CLoggingMethodsNode()
{
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMethodsNode::GetResultPaneColInfo

See CSnapinNode::GetResultPaneColInfo (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
OLECHAR* CLoggingMethodsNode::GetResultPaneColInfo(int nCol)
{
   ATLTRACE(_T("# CLoggingMethodsNode::GetResultPaneColInfo\n"));

   // Check for preconditions:
   // None.

   if (nCol == 0 && m_bstrDisplayName != NULL)
      return m_bstrDisplayName;

   return NULL;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMethodsNode::SetVerbs

See CSnapinNode::SetVerbs (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLoggingMethodsNode::SetVerbs( IConsoleVerb * pConsoleVerb )
{
   ATLTRACE(_T("# CLoggingMethodsNode::SetVerbs\n"));

   // Check for preconditions:
   // None.

   HRESULT hr = S_OK;

   hr = pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );
   // CLoggingMethodsNode has no properties
// hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, FALSE );

   // We don't want the user deleting or renaming this node, so we
   // don't set the MMC_VERB_RENAME or MMC_VERB_DELETE verbs.
   // By default, when a node becomes selected, these are disabled.

   // We want double-clicking on a collection node to show its children.
   // hr = pConsoleVerb->SetVerbState( MMC_VERB_OPEN, ENABLED, TRUE );
   // hr = pConsoleVerb->SetDefaultVerb( MMC_VERB_OPEN );

   return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  DataRefresh -- to support
//
// Class: CPoliciesNode
//
// Synopsis:  Initialize the CPoliciesNode using the SDO pointers
//
// Arguments: ISdo*           pMachineSdo    - Server SDO
//         ISdoDictionaryOld* pDictionarySdo - Sdo Dictionary
// Returns:   HRESULT -  how the initialization goes
//
// History:   Created byao 2/6/98 8:03:12 PM
//
//+---------------------------------------------------------------------------
HRESULT CLoggingMethodsNode::DataRefresh( ISdo* pSdo )
{
   // Save away the interface pointers.
   m_spSdo = pSdo;

   HRESULT retval = S_OK;
   for (int i = 0; i < m_ResultChildrenList.GetSize(); ++i)
   {
      HRESULT hr = m_ResultChildrenList[i]->InitSdoPointers(pSdo);
      if (FAILED(hr))
      {
         retval = hr;
      }
   }

   return retval;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPoliciesNode::OnRefresh

See CSnapinNode::OnRefresh (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLoggingMethodsNode::OnRefresh(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         )
{
   HRESULT   hr = S_OK;
   CWaitCursor WC;
   CComPtr<IConsole> spConsole;

   // We need IConsole
   if( pComponentData != NULL )
   {
       spConsole = ((CLoggingComponentData*)pComponentData)->m_spConsole;
   }
   else
   {
       spConsole = ((CLoggingComponent*)pComponent)->m_spConsole;
   }
   _ASSERTE( spConsole != NULL );

   for (int i = 0; i < m_ResultChildrenList.GetSize(); ++i)
   {
      hr = BringUpPropertySheetForNode(
              m_ResultChildrenList[i],
              pComponentData,
              pComponent,
              spConsole
              );
      if (hr == S_OK)
      {
         // We found a property sheet already up for this node.
         ShowErrorDialog(
            NULL,
            IDS_ERROR_CLOSE_PROPERTY_SHEET,
            NULL,
            hr,
            0,
            spConsole
            );
         return hr;
      }
   }

   // reload SDO
   hr =  ((CLoggingMachineNode *) m_pParentNode)->DataRefresh();

   for (int i = 0; i < m_ResultChildrenList.GetSize(); ++i)
   {
      // Load cached info from SDO
      m_ResultChildrenList[i]->OnPropertyChange(
                                  arg,
                                  param,
                                  pComponentData,
                                  pComponent,
                                  type
                                  );
   }

   // refresh the node
   hr = MyBaseClass::OnRefresh( arg, param, pComponentData, pComponent, type);

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMethodsNode::InsertColumns

See CNodeWithResultChildrenList::InsertColumns (which this method overrides)
for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLoggingMethodsNode::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
   ATLTRACE(_T("# CLoggingMethodsNode::InsertColumns\n"));

   // Check for preconditions:
   _ASSERTE( pHeaderCtrl != NULL );

   HRESULT hr;
   int nLoadStringResult;
   TCHAR szLoggingMethod[IAS_MAX_STRING];
   TCHAR szDescription[IAS_MAX_STRING];

   nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_LOGGING_METHODS_NODE__LOGGING_METHOD, szLoggingMethod, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );

   nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_LOGGING_METHODS_NODE__DESCRIPTION, szDescription, IAS_MAX_STRING );
   _ASSERT( nLoadStringResult > 0 );


   hr = pHeaderCtrl->InsertColumn( 0, szLoggingMethod, LVCFMT_LEFT, COLUMN_WIDTH__LOGGING_METHOD );
   _ASSERT( S_OK == hr );

   hr = pHeaderCtrl->InsertColumn( 1, szDescription, LVCFMT_LEFT, COLUMN_WIDTH__DESCRIPTION );
   _ASSERT( S_OK == hr );

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMethodsNode::PopulateResultChildrenList

See CNodeWithResultChildrenList::PopulateResultChildrenList (which this method overrides)
for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLoggingMethodsNode::PopulateResultChildrenList( void )
{
   HRESULT hr = S_OK;

   if (m_ResultChildrenList.GetSize() == 0)
   {
      CLocalFileLoggingNode* localFile = 0;
      DatabaseNode* database = 0;

      do
      {
         localFile = new (std::nothrow) CLocalFileLoggingNode(this);
         if (localFile == 0)
         {
            hr = E_OUTOFMEMORY;
            break;
         }

         hr = localFile->InitSdoPointers(m_spSdo);
         if (FAILED(hr)) { break; }
         hr = AddChildToList(localFile);
         if (FAILED(hr)) { break; }

         // Check if the database accounting component is present.
         CComPtr<ISdo> dbAcct;
         hr = SDOGetSdoFromCollection(
                 m_spSdo,
                 PROPERTY_IAS_REQUESTHANDLERS_COLLECTION,
                 PROPERTY_COMPONENT_ID,
                 IAS_PROVIDER_MICROSOFT_DB_ACCT,
                 &dbAcct
                 );
         if (SUCCEEDED(hr))
         {
            database = new (std::nothrow) DatabaseNode(this);
            if (database == 0)
            {
               hr = E_OUTOFMEMORY;
               break;
            }

            hr = database->InitSdoPointers(m_spSdo);
            if (FAILED(hr)) { break; }
            hr = AddChildToList(database);
            if (FAILED(hr)) { break; }
         }
         else
         {
            // Suppress the error since it just means were managing a downlevel
            // machine.
            hr = S_OK;
         }

         m_bResultChildrenListPopulated = TRUE;
      }
      while (false);

      if (!m_bResultChildrenListPopulated)
      {
         m_ResultChildrenList.RemoveAll();
         delete localFile;
         delete database;
      }
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMethodsNode::GetComponentData

This method returns our unique CComponentData object representing the scope
pane of this snapin.

It relies upon the fact that each node has a pointer to its parent,
except for the root node, which instead has a member variable pointing
to CComponentData.

This would be a useful function to use if, for example, you need a reference
to some IConsole but you weren't passed one.  You can use GetComponentData
and then use the IConsole pointer which is a member variable of our
CComponentData object.

--*/
//////////////////////////////////////////////////////////////////////////////
CLoggingComponentData * CLoggingMethodsNode::GetComponentData( void )
{
   ATLTRACE(_T("# CLoggingMethodsNode::GetComponentData\n"));

   // Check for preconditions:
   _ASSERTE( m_pParentNode );

   return ((CLoggingMachineNode *) m_pParentNode)->GetComponentData();
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMethodsNode::GetServerRoot

This method returns the Server node under which this node can be found.

It relies upon the fact that each node has a pointer to its parent,
all the way up to the server node.

This would be a useful function to use if, for example, you need a reference
to some data specific to a server.

--*/
//////////////////////////////////////////////////////////////////////////////
CLoggingMachineNode * CLoggingMethodsNode::GetServerRoot( void )
{
   ATLTRACE(_T("# CLoggingMethodsNode::GetServerRoot\n"));

   // Check for preconditions:
   _ASSERTE( m_pParentNode != NULL );

   return (CLoggingMachineNode *) m_pParentNode;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMethodsNode::OnPropertyChange

This is our own custom response to the MMCN_PROPERTY_CHANGE notification.

MMC never actually sends this notification to our snapin with a specific lpDataObject,
so it would never normally get routed to a particular node but we have arranged it
so that our property pages can pass the appropriate CSnapInItem pointer as the param
argument.  In our CComponent::Notify override, we map the notification message to
the appropriate node using the param argument.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLoggingMethodsNode::OnPropertyChange(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         )
{
   ATLTRACE(_T("# CLoggingMethodsNode::OnPropertyChange\n"));

   // Check for preconditions:
   // None.

   return LoadCachedInfoFromSdo();
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMethodsNode::LoadCachedInfoFromSdo

Causes this node and its children to re-read all their cached info from
the SDO's.  Call if you change something and you want to make sure that
the display reflects this change.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLoggingMethodsNode::LoadCachedInfoFromSdo()
{
   HRESULT retval = S_OK;

   for (int i = 0; i < m_ResultChildrenList.GetSize(); ++i)
   {
      HRESULT hr = m_ResultChildrenList[i]->LoadCachedInfoFromSdo();
      if (FAILED(hr))
      {
         retval = hr;
      }
   }

   return retval;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPoliciesNode::FillData

The server node need to override CSnapInItem's implementation of this so that
we can
also support a clipformat for exchanging machine names with any snapins
extending us.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CLoggingMethodsNode::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
   ATLTRACE(_T("# CClientsNode::FillData\n"));

   // Check for preconditions:
   // None.

   HRESULT hr = DV_E_CLIPFORMAT;
   ULONG uWritten = 0;

   if (cf == CF_MMC_NodeID)
   {
      ::CString   SZNodeID = (LPCTSTR)GetSZNodeType();

      if (INTERNET_AUTHENTICATION_SERVICE_SNAPIN == GetServerRoot()->m_enumExtendedSnapin)
         SZNodeID += L":Ext_IAS:";

      SZNodeID += GetServerRoot()->m_bstrServerAddress;

       DWORD dwIdSize = 0;

         SNodeID2* NodeId = NULL;
      BYTE *id = NULL;
       DWORD textSize = (SZNodeID.GetLength()+ 1) * sizeof(TCHAR);

         dwIdSize = textSize + sizeof(SNodeID2);

      try{
         NodeId = (SNodeID2 *)_alloca(dwIdSize);
       }
      catch(...)
       {
         hr = E_OUTOFMEMORY;
         return hr;
       }

          NodeId->dwFlags = 0;
       NodeId->cBytes = textSize;
       memcpy(NodeId->id,(BYTE*)(LPCTSTR)SZNodeID, textSize);

      hr = pStream->Write(NodeId, dwIdSize, &uWritten);
       return hr;
   }

   // Call the method which we're overriding to let it handle the
   // rest of the possible cases as usual.
   return MyBaseClass::FillData( cf, pStream );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\logmacnd.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    MachineNode.h

Abstract:

   Header file for the MachineNode subnode.

   See MachineNode.cpp for implementation.

Revision History:
   mmaguire 12/03/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_LOG_MACHINE_NODE_H_)
#define _LOG_MACHINE_NODE_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "SnapinNode.h"

#include "rtradvise.h"
//
//
// where we can find what this class has or uses:
//
#include "LoggingMethodsNode.h"
#include "ConnectionToServer.h"
#include <map>
#include <string>
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

class CLoggingMachineNode;
class CLoggingComponentData;

typedef std::map< std::basic_string< wchar_t > , CLoggingMachineNode * > LOGGINGSERVERSMAP;

class CLoggingMachineNode : public CSnapinNode< CLoggingMachineNode, CLoggingComponentData, CLoggingComponent >
{
public:
   
   // Clipboard format through which this extension snapin receives
   // information about machine it's focussed on.
   static CLIPFORMAT m_CCF_MMC_SNAPIN_MACHINE_NAME;
   
   static void InitClipboardFormat();

   // Returns whether we extend a particular GUID and sets the
   // m_enumExtendedSnapin to indicate which snapin we are extending.
   BOOL IsSupportedGUID( GUID & guid );

   // Indicates which standalone snapin we are extending.
   _enum_EXTENDED_SNAPIN m_enumExtendedSnapin;

   HRESULT InitSdoObjects();

   SNAPINMENUID(IDM_MACHINE_NODE)

   BEGIN_SNAPINTOOLBARID_MAP(CLoggingMachineNode)
      SNAPINTOOLBARID_ENTRY(IDR_MACHINE_TOOLBAR)
   END_SNAPINTOOLBARID_MAP()

   CSnapInItem * GetExtNodeObject(LPDATAOBJECT pDataObject, CLoggingMachineNode * pDataClass );

   CLoggingMachineNode();

   ~CLoggingMachineNode();

   LPOLESTR GetResultPaneColInfo(int nCol);

   STDMETHOD(CheckConnectionToServer)( BOOL fVerbose = TRUE );

    // Pointer to the CComponentData object owning this node.
   // A root node doesn't belong to another node, so its
   // m_pParentNode pointer is NULL.
   // Rather it is owned by the unique IComponentData object
   // for this snapin.
   // We pass in this CComponentData pointer during CComponentData initialization.
   // By storing this pointer, we can have access to member
   // variables stored in CComponentData, e.g. a pointer to IConsole.
   // Since all nodes store a pointer to their parent, any node
   // can look its way up the tree and get access to CComponentData.
   CLoggingComponentData * m_pComponentData;

   void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault);

   BOOL m_fAlreadyAnalyzedDataClass;
   BOOL m_bConfigureLocal;

   CComBSTR m_bstrServerAddress;

   virtual HRESULT OnExpand(  
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         );

   virtual HRESULT OnRename(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         );

   virtual HRESULT OnRefresh(   
                    LPARAM arg
                  , LPARAM param
                  , IComponentData * pComponentData
                  , IComponent * pComponent
                  , DATA_OBJECT_TYPES type
                  );

   virtual HRESULT OnRemoveChildren(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
            
   STDMETHOD(TaskNotify)(
              IDataObject * pDataObject
            , VARIANT * pvarg
            , VARIANT * pvparam
            );

   STDMETHOD(EnumTasks)(
              IDataObject * pDataObject
            , BSTR szTaskGroup
            , IEnumTASK** ppEnumTASK
            );

   HRESULT OnTaskPadDefineNetworkAccessPolicy(
              IDataObject * pDataObject
            , VARIANT * pvarg
            , VARIANT * pvparam
            );

   CLoggingComponentData * GetComponentData( void );
   HRESULT  DataRefresh();
   
   // Pointers to child nodes.
   CLoggingMethodsNode * m_pLoggingNode; // this is one CPoliciesNode object

   ////////////////////////////////////////////////////////////////////////////
   //
   // Asynchrnous connect related...
   //
   ////////////////////////////////////////////////////////////////////////////
   HRESULT BeginConnectAction( void );
   HRESULT LoadSdoData(BOOL fDSAvailable);
   HRESULT LoadCachedInfoFromSdo( void );

   ////////////////////////////////////////////////////////////////////////////

   // OnRRASChange -- to decide if to show LOGGING node under the machine node
   // Only show LOGGING node if NT Accounting is selected
   HRESULT OnRRASChange( 
            /* [in] */ LONG_PTR ulConnection,
            /* [in] */ DWORD dwChangeType,
            /* [in] */ DWORD dwObjectType,
            /* [in] */ LPARAM lUserParam,
            /* [in] */ LPARAM lParam);

   HRESULT TryShow(BOOL* pbVisible);

   ////////////////////////////////////////////////////////////////////////////
   //
   // SDO related pointers
   //
   ////////////////////////////////////////////////////////////////////////////
   CComPtr<ISdoDictionaryOld> m_spDictionarySdo;    // Dictionary SDO

   // if the server being focused is supported by this node
   // during connection, if server is NT4, this is set to false
   BOOL  m_bServerSupported;

protected:
   virtual HRESULT SetVerbs( IConsoleVerb * pConsoleVerb );
   BOOL  m_fSdoConnected;
   BOOL  m_fUseActiveDirectory;
   BOOL  m_fDSAvailable;
   CLoggingConnectionToServer *  m_pConnectionToServer;
   BOOL  m_fNodeHasUI;

   // For extending snapins like RRAS which have multiple machine views.
   LOGGINGSERVERSMAP m_mapMachineNodes;
   CComPtr< CRtrAdviseSinkForIAS<CLoggingMachineNode> >  m_spRtrAdviseSink;
};

_declspec( selectany ) CLIPFORMAT CLoggingMachineNode::m_CCF_MMC_SNAPIN_MACHINE_NAME = 0;
// _declspec( selectany ) _enum_EXTENDED_SNAPIN CLoggingMachineNode::m_enumExtendedSnapin = INTERNET_AUTHENTICATION_SERVICE_SNAPIN;

#endif // _LOG_MACHINE_NODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\loggingmethod.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class LoggingMethod.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef LOGGINGMETHOD_H
#define LOGGINGMETHOD_H
#pragma once

#include "snapinnode.h"

class CLoggingComponent;
class CLoggingComponentData;
class CLoggingMethodsNode;


// Abstract base class for the result pane items displayed under Remote Access
// Logging.
class __declspec(novtable) LoggingMethod
   : public CSnapinNode<
               LoggingMethod,
               CLoggingComponentData,
               CLoggingComponent
               >
{
public:
   LoggingMethod(long sdoId, CSnapInItem* parent);
   virtual ~LoggingMethod() throw ();

   HRESULT InitSdoPointers(ISdo* machine) throw ();

   virtual HRESULT LoadCachedInfoFromSdo() throw () = 0;

   CLoggingMethodsNode* Parent() const throw ();

protected:
   virtual CLoggingComponentData* GetComponentData();

   // SDO containing our configuration.
   CComPtr<ISdo> configSdo;
   // SDO used for resetting the service when config changes.
   CComPtr<ISdoServiceControl> controlSdo;

private:
   long componentId;

   // Not implemented.
   LoggingMethod(const LoggingMethod&);
   LoggingMethod& operator=(const LoggingMethod&);
};


#endif // LOGGINGMETHOD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\logmacnd.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    LogMacNd.cpp

Abstract:

   Implementation file for the CLoggingMachineNode class.


Revision History:
   mmaguire 12/03/97
   byao    6/11/98   Added asynchrnous connect

--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"

//
// where we can find declaration for main class in this file:
//

#include "LogMacNd.h"
#include "LogComp.h"
#include "SnapinNode.cpp"  // Template implementation

//
// where we can find declarations needed in this file:
//
#include "NapUtil.h"
#include "MachineEnumTask.h"
#include "NodeTypeGUIDS.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMachineNode::IsSupportedGUID

Used to determine whether we extend the node type of a given GUID, and sets
the m_enumExtendedSnapin variable to indicate what snapin we are extending.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CLoggingMachineNode::IsSupportedGUID( GUID & guid )
{
   if( IsEqualGUID( guid, InternetAuthenticationServiceGUID_ROOTNODETYPE ) )
   {
      m_enumExtendedSnapin = INTERNET_AUTHENTICATION_SERVICE_SNAPIN;
      return TRUE;
   }
   else
   {
      if( IsEqualGUID( guid, NetworkConsoleGUID_ROOTNODETYPE) )
      {
         m_enumExtendedSnapin = NETWORK_MANAGEMENT_SNAPIN;
         return TRUE;
      }
      else
      {
         if( IsEqualGUID( guid, RoutingAndRemoteAccessGUID_MACHINENODETYPE ) )
         {
            m_enumExtendedSnapin = RRAS_SNAPIN;
            return TRUE;
         }
      }
   }

   return FALSE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMachineNode::GetExtNodeObject

Depending on which snapin we are extending, when queried for a node object
corresponding to a particular machine, we must decide which node we want
to give a pointer to.

When we extend a snapin like IAS or Network Management, where there is one
instance of a snapin per machine being configured, we simply return a pointer
to "this" -- this CLoggingMachineNode object is the single one being administed.

When we extend a snapin like RRAS where there is an "Enterprise" view and
one snapin may need to manage a view of multiple machines, this CLoggingMachineNode
will act as a redirector to a CLoggingMachineNode in a list of m_mapMachineNodes it
maintains which corresponds to the appropriate machines.

--*/
//////////////////////////////////////////////////////////////////////////////
CSnapInItem * CLoggingMachineNode::GetExtNodeObject(LPDATAOBJECT pDataObject, CLoggingMachineNode * pDataClass )
{
   TRACE_FUNCTION("CLoggingMachineNode::GetExtNodeObject");

   if( m_enumExtendedSnapin == INTERNET_AUTHENTICATION_SERVICE_SNAPIN
      || m_enumExtendedSnapin == NETWORK_MANAGEMENT_SNAPIN )
   {
      // There is one instance of a machine node per snapin.
      // This machine node is a "virtual root" that shadows the node being extended.
      m_fNodeHasUI = TRUE;
      return this;
   }
   else
   {
      try
      {
         _ASSERTE( m_enumExtendedSnapin == RRAS_SNAPIN );

         // There are many machine nodes and one extension snapin needs to handle them all.

         // We use this function to extract the machine name from the clipboard format.
         // It will set the corrent value in m_bstrServerAddress.
         m_fAlreadyAnalyzedDataClass = FALSE;
         InitDataClass( pDataObject, pDataClass );
         
         // See if we already have a CLoggingMachineNode object corresponding to the
         // machine named in m_bstrServerAddress and insert it if we do not.

         LOGGINGSERVERSMAP::iterator theIterator;
         std::basic_string< wchar_t > MyString = m_bstrServerAddress;

         BOOL  bAddedAsLocal = ExtractComputerAddedAsLocal(pDataObject);

         // local machine has special entry
         if(bAddedAsLocal)
            MyString = _T("");
            
         CLoggingMachineNode * pMachineNode = NULL;

         theIterator = m_mapMachineNodes.find(MyString);
         if( theIterator == m_mapMachineNodes.end() )
         {
            // We need to insert a new CLoggingMachineNode object for m_bstrServerAddress.
            pMachineNode = new CLoggingMachineNode();
            pMachineNode->m_pComponentData = m_pComponentData;
            pMachineNode->m_enumExtendedSnapin = m_enumExtendedSnapin;

            // RRAS refresh advise setup F bug 213623: 
            m_spRtrAdviseSink.p = CRtrAdviseSinkForIAS<CLoggingMachineNode>::SetAdvise(pMachineNode, pDataObject);
            // ~RRAS

            m_mapMachineNodes.insert( LOGGINGSERVERSMAP::value_type( MyString, pMachineNode ) );

            // ISSUE: We should be able to use the pair returned from insert above,
            // but for now, just use find again.
            theIterator = m_mapMachineNodes.find(MyString);
                     
         }
         else
         {
            pMachineNode = (CLoggingMachineNode*)theIterator->second;
         }

         // RRAS refresh advise setup F bug 213623: 
         if(!pMachineNode->m_spRtrAdviseSink)
            pMachineNode->m_spRtrAdviseSink.p = CRtrAdviseSinkForIAS<CLoggingMachineNode>::SetAdvise(pMachineNode, pDataObject);
         // ~RRAS
         pMachineNode->m_fNodeHasUI = TRUE;

         // We already have a CLoggingMachineNode for this object.
         return theIterator->second;
      }

      catch(...)
      {
         // Error.
         return NULL;
      }
   }
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMachineNode::OnRRASChange

   // OnRRASChange -- to decide if to show LOGGING node under the machine node
   // Only show LOGGING node if NT Accounting is selected

--*/
HRESULT CLoggingMachineNode::OnRRASChange( 
            /* [in] */ LONG_PTR ulConnection,
            /* [in] */ DWORD dwChangeType,
            /* [in] */ DWORD dwObjectType,
            /* [in] */ LPARAM lUserParam,
            /* [in] */ LPARAM lParam)
{
   HRESULT  hr = S_OK;
   hr = TryShow(NULL);
   
   return S_OK;
}


HRESULT CLoggingMachineNode::OnRemoveChildren(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
   // logging node will be removed, so we should set the ID to 0
   if(m_pLoggingNode)
      m_pLoggingNode->m_scopeDataItem.ID = 0;

   // disconnect RRAS on change notify
   // RRAS refresh
   if(m_spRtrAdviseSink != NULL)
   {
      m_spRtrAdviseSink->ReleaseSink();
      m_spRtrAdviseSink.Release();
   }

   m_fNodeHasUI = FALSE;

   return S_OK;
}


//========================

//========================
HRESULT CLoggingMachineNode::TryShow(BOOL* pbVisible )
{
   HRESULT  hr = S_OK;
   CComPtr<IConsole> spConsole;
   CComPtr<IConsoleNameSpace> spConsoleNameSpace;
   BOOL bShow = FALSE;
      
   if(!m_bServerSupported || !m_fAlreadyAnalyzedDataClass || !m_pLoggingNode || !m_fNodeHasUI)  
      return hr;

   // when RRAS_SNAPIN extension
   if(m_enumExtendedSnapin == RRAS_SNAPIN)
   {
      BSTR  bstrMachine = NULL;
      
      if(!m_bConfigureLocal)
         bstrMachine = m_bstrServerAddress;
         
      bShow = ( IsRRASConfigured(bstrMachine)&& (IsRRASUsingNTAccounting(bstrMachine) || IsRRASUsingNTAuthentication(bstrMachine)) );
   }
   // IAS, show only IAS service is installed on the machine
   else if (INTERNET_AUTHENTICATION_SERVICE_SNAPIN == m_enumExtendedSnapin)
   {
      hr = IfServiceInstalled(m_bstrServerAddress, _T("IAS"), &bShow);
      if(hr != S_OK) return hr;
   }
   else  // always show
   {
      bShow = TRUE;
   }

   // deal with the node
   hr = m_pComponentData->m_spConsole->QueryInterface(
                                 IID_IConsoleNameSpace, 
                                 (VOID**)(&spConsoleNameSpace) );

   if(S_OK != hr)
      goto Error;

   if ( bShow &&  m_pLoggingNode->m_scopeDataItem.ID == NULL)  // show the node
   {
         hr = spConsoleNameSpace->InsertItem( &(m_pLoggingNode->m_scopeDataItem) );
//       _ASSERT( NULL != m_pLoggingNode->m_scopeDataItem.ID );
   }
   else if (!bShow && m_pLoggingNode->m_scopeDataItem.ID != NULL) // hide
   { // hide the node
         hr = spConsoleNameSpace->DeleteItem( m_pLoggingNode->m_scopeDataItem.ID, TRUE );
         m_pLoggingNode->m_scopeDataItem.ID = NULL;
   }
   
   if(hr == S_OK && pbVisible)
      *pbVisible = bShow;
Error:

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMachineNode::CLoggingMachineNode

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CLoggingMachineNode::CLoggingMachineNode(): CSnapinNode<CLoggingMachineNode, CLoggingComponentData, CLoggingComponent>( NULL )
{
   TRACE_FUNCTION("CLoggingMachineNode::CLoggingMachineNode");


   // The children subnodes have not yet been created.
   m_pLoggingNode = NULL;

   // Set the display name for this object
   m_bstrDisplayName = L"@Some Machine";

   // In IComponentData::Initialize, we are asked to inform MMC of
   // the icons we would like to use for the scope pane.
   // Here we store an index to which of these images we
   // want to be used to display this node
   m_scopeDataItem.nImage =      IDBI_NODE_MACHINE_CLOSED;
   m_scopeDataItem.nOpenImage =  IDBI_NODE_MACHINE_OPEN;

   //
   // initialize all the SDO pointers
   //
   m_spDictionarySdo = NULL;

   m_fAlreadyAnalyzedDataClass = FALSE;   

   // connected?
   m_fSdoConnected = FALSE;

   // helper class that connect to server asynchrnously
   m_pConnectionToServer = NULL;

   // default to not configuring the local machine
   m_bConfigureLocal = FALSE;

   m_fNodeHasUI = FALSE;

   // if the server being focused is supported by this node
   m_bServerSupported = TRUE;

   m_enumExtendedSnapin = INTERNET_AUTHENTICATION_SERVICE_SNAPIN;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMachineNode::~CLoggingMachineNode

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CLoggingMachineNode::~CLoggingMachineNode()
{
   TRACE_FUNCTION("CLoggingMachineNode::~CLoggingMachineNode");

   if( NULL != m_pConnectionToServer )
   {
      m_pConnectionToServer->Release(TRUE);
   }

   // Delete children nodes
   delete m_pLoggingNode;

   // Delete the list of machines in case we are extending a snapin with
   // enterprise view like RRAS.
   LOGGINGSERVERSMAP::iterator theIterator;
   for( theIterator = m_mapMachineNodes.begin(); theIterator != m_mapMachineNodes.end(); ++theIterator )
   {
      delete theIterator->second;
   }
   m_mapMachineNodes.clear();
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMachineNode::GetResultPaneColInfo

See CSnapinNode::GetResultPaneColInfo (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
LPOLESTR CLoggingMachineNode::GetResultPaneColInfo(int nCol)
{
   TRACE_FUNCTION("CLoggingMachineNode::GetResultPaneColInfo");

   if (nCol == 0)
   {
      return m_bstrDisplayName;
   }

   // TODO : Return the text for other columns
   return OLESTR("Running");
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMachineNode::OnExpand

See CSnapinNode::OnExpand (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLoggingMachineNode::OnExpand( 
                    LPARAM arg
                  , LPARAM param
                  , IComponentData * pComponentData
                  , IComponent * pComponent
                  , DATA_OBJECT_TYPES type
                  )
{
   TRACE_FUNCTION("CLoggingMachineNode::OnExpand");

   IConsoleNameSpace * pConsoleNameSpace;
   HRESULT hr = S_FALSE;

   if( TRUE == arg )
   {
      // we are expanding the root node -- which is the machine node here.

      // Try to create the children of this Machine node
      if( NULL == m_pLoggingNode )
      {
         m_pLoggingNode = new CLoggingMethodsNode(
                                 this,
                                 m_enumExtendedSnapin == RRAS_SNAPIN
                                 );
      }

      if( NULL == m_pLoggingNode )
      {
         hr = E_OUTOFMEMORY;

         // Use MessageBox() rather than IConsole::MessageBox() here because the
         // first time this gets called m_ipConsole is not fully initialized
         // ISSUE: The above statement is probably not true for this node.
         ::MessageBox( NULL, L"@Unable to allocate new nodes", L"CLoggingMachineNode::OnExpand", MB_OK );

         return(hr);
      }

      //
      // we need to get all the SDO pointers, this include the SdoServer,
      // Dictionary, Profile collection, policy collection and condition collection
      //

      //todo: report error when not connected?
      hr = BeginConnectAction();
      if ( FAILED(hr) )
      {
         return hr;
      }
         
      // But to get that, first we need IConsole
      CComPtr<IConsole> spConsole;
      if( pComponentData != NULL )
      {
          spConsole = ((CLoggingComponentData*)pComponentData)->m_spConsole;
      }
      else
      {
         // We should have a non-null pComponent
          spConsole = ((CLoggingComponent*)pComponent)->m_spConsole;
      }
      _ASSERTE( spConsole != NULL );

      hr = spConsole->QueryInterface(IID_IConsoleNameSpace, (VOID**)(&pConsoleNameSpace) );
      _ASSERT( S_OK == hr );


      // This was done in MeanGene's Step 3 -- I'm guessing MMC wants this filled in
      m_pLoggingNode->m_scopeDataItem.relativeID = (HSCOPEITEM) param;

#ifndef  ALWAYS_SHOW_RAP_NODE
      hr = TryShow(NULL);
#else    
      hr = pConsoleNameSpace->InsertItem( &(m_pLoggingNode->m_scopeDataItem) );
      _ASSERT( NULL != m_pLoggingNode->m_scopeDataItem.ID );
#endif

      pConsoleNameSpace->Release(); // Don't forget to do this!
   }
   else  // arg != TRUE so not expanding
   {
      // do nothing for now -- I don't think arg = FALSE is even implemented
      // for MMC v. 1.0 or 1.1
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMachineNode::OnRename

See CSnapinNode::OnRename (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLoggingMachineNode::OnRename(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         )
{
   TRACE_FUNCTION("MachineNode::OnRename");

   HRESULT hr = S_FALSE;

   //ISSUE: Consider moving this into base CNAPNode class or a CLeafNode class

   OLECHAR * pTemp = new OLECHAR[lstrlen((OLECHAR*) param) + 1];
   
   if ( NULL == pTemp )
   {
      return S_FALSE;
   }

   lstrcpy( pTemp, (OLECHAR*) param );

   m_bstrDisplayName = pTemp;

   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMachineNode::SetVerbs

See CSnapinNode::SetVerbs (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLoggingMachineNode::SetVerbs( IConsoleVerb * pConsoleVerb )
{
   TRACE_FUNCTION("CLoggingMachineNode::SetVerbs");

   HRESULT hr = S_OK;

   // We want the user to be able to choose Properties on this node
   hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );

   // We want the default verb to be Properties
   hr = pConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES );

   // We want the user to be able to delete this node
   hr = pConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE );

   // We want the user to be able to rename this node
   hr = pConsoleVerb->SetVerbState( MMC_VERB_RENAME, ENABLED, TRUE );

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMachineNode::GetComponentData

This method returns our unique CComponentData object representing the scope
pane of this snapin.

It relies upon the fact that each node has a pointer to its parent,
except for the root node, which instead has a member variable pointing
to CComponentData.

This would be a useful function to use if, for example, you need a reference
to some IConsole but you weren't passed one.  You can use GetComponentData
and then use the IConsole pointer which is a member variable of our
CComponentData object.

--*/
//////////////////////////////////////////////////////////////////////////////
CLoggingComponentData * CLoggingMachineNode::GetComponentData( void )
{
   TRACE_FUNCTION("CLoggingMachineNode::GetComponentData");

   return m_pComponentData;
}


//+---------------------------------------------------------------------------
//
// Function:  CLoggingMachineNode::InitClipboardFormat
//
// Synopsis:  initialize the clipboard format that's used to pass computer name
//         from the primary snap-in and extension snap-in
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    byao   2/25/98 7:04:33 PM
//
//+---------------------------------------------------------------------------
void CLoggingMachineNode::InitClipboardFormat()
{
   TRACE_FUNCTION("CLoggingMachineNode::InitClipboardFormat");

   // Init a clipboard format which will allow us to exchange
   // machine name information.
   m_CCF_MMC_SNAPIN_MACHINE_NAME = (CLIPFORMAT) RegisterClipboardFormat(_T("MMC_SNAPIN_MACHINE_NAME"));

}


//+---------------------------------------------------------------------------
//
// Function:  CLoggingMachineNode::InitDataClass
//
// Synopsis:  gets passed the IDataObject sent to the extension snapin for this
//          node, queries this IDataObject for the name of the machine
//          which this snapin is extending
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    mmaguire  2/25/98 9:07 PM
//
//+---------------------------------------------------------------------------
void CLoggingMachineNode::InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
{
   TRACE_FUNCTION("CLoggingMachineNode::InitDataClass");

   // Check for preconditions.
   if( m_fAlreadyAnalyzedDataClass )
   {
      // We have already performed any work we needed to do with the dataobject here.
      return;
   }

   if (pDataObject == NULL)
   {
      return;
   }

   HRESULT hr;
// OLECHAR szMachineName[IAS_MAX_COMPUTERNAME_LENGTH];
   // Try a large size because RRAS seems to want 2048
   OLECHAR szMachineName[4000];

   // Fill the structures which will tell the IDataObject what information
   // we want it to give us.
   STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
   FORMATETC formatetc = { m_CCF_MMC_SNAPIN_MACHINE_NAME,
      NULL,
      DVASPECT_CONTENT,
      -1,
      TYMED_HGLOBAL
   };

   // Allocate enough global memory for the IDataObject to write
   // the max computer name length.
   stgmedium.hGlobal = GlobalAlloc(0, sizeof(OLECHAR)*(IAS_MAX_COMPUTERNAME_LENGTH) );
   if (stgmedium.hGlobal == NULL)
   {
      return;
   }

   // Ask the IDataObject for the computer name.
   hr = pDataObject->GetDataHere(&formatetc, &stgmedium);
   if (SUCCEEDED(hr))
   {
      // Parse the data given back to us.
      
      // Create a stream on HGLOBAL
      CComPtr<IStream> spStream;
      hr = CreateStreamOnHGlobal(stgmedium.hGlobal, FALSE, &spStream);
      if (SUCCEEDED(hr))
      {
         // Read from the stream.
         unsigned long uWritten;
         hr = spStream->Read(szMachineName, sizeof(OLECHAR)*(IAS_MAX_COMPUTERNAME_LENGTH), &uWritten);
         if( SUCCEEDED(hr) )
         {
            m_bstrServerAddress = szMachineName;

            // check to see if we are configuring the local machine
            CString strLocalMachine;
            DWORD dwSize = MAX_COMPUTERNAME_LENGTH;

            ::GetComputerName(strLocalMachine.GetBuffer(dwSize), &dwSize);
            strLocalMachine.ReleaseBuffer();

            // If the machine name we read was either an empty string,
            // or it equals the name of the current computer,
            // then we are configuring the local machine.
            if ( ! szMachineName[0] || strLocalMachine.CompareNoCase(szMachineName) == 0)
            {
               m_bConfigureLocal = TRUE;
            }
         }
         else
         {
            ShowErrorDialog( NULL, USE_DEFAULT, NULL, S_OK, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );
         }        
      }
   }

   GlobalFree(stgmedium.hGlobal);

   if( SUCCEEDED( hr ) )
   {
      // If we made it to here with an successful HRESULT, we have successfully analyzed
      // the IDataObject and we set this flag so that we don't do this work again.
      m_fAlreadyAnalyzedDataClass = TRUE; 
   }
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMachineNode::TaskNotify

See CSnapinNode::TaskNotify (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CLoggingMachineNode::TaskNotify(
           IDataObject * pDataObject
         , VARIANT * pvarg
         , VARIANT * pvparam
         )
{
   TRACE_FUNCTION("CLoggingMachineNode::TaskNotify");

   // Check for preconditions:
   // None.
   if ( !m_fSdoConnected )
   {
      return S_OK;
   }

   HRESULT hr = S_FALSE;

   if (pvarg->vt == VT_I4)
   {
      switch (pvarg->lVal)
      {
      case MACHINE_TASK__DEFINE_NETWORK_ACCESS_POLICY:
         hr = OnTaskPadDefineNetworkAccessPolicy( pDataObject, pvarg, pvparam );
         break;
      default:
         break;
      }
   }

   // ISSUE: What should I be returning here?
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMachineNode::EnumTasks

See CSnapinNode::EnumTasks (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CLoggingMachineNode::EnumTasks(
           IDataObject * pDataObject
         , BSTR szTaskGroup
         , IEnumTASK** ppEnumTASK
         )
{
   TRACE_FUNCTION("CLoggingMachineNode::EnumTasks");

   // Check for preconditions:
   // None.
   if ( !m_fSdoConnected )
   {
      return S_OK;
   }

   HRESULT hr = S_OK;
   CMachineEnumTask * pMachineEnumTask = new CMachineEnumTask( (CMachineNode *) this );

   if ( pMachineEnumTask  == NULL )
   {
      hr = E_OUTOFMEMORY;
   }
   else
   {
      // Make sure release works properly on failure.
      pMachineEnumTask ->AddRef ();

      hr = pMachineEnumTask ->Init( pDataObject, szTaskGroup);
      if( hr == S_OK )
      {
         hr = pMachineEnumTask->QueryInterface( IID_IEnumTASK, (void **)ppEnumTASK );
      }
      
      pMachineEnumTask->Release();
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMachineNode::OnTaskPadDefineNetworkAccessPolicy

Respond to the Define Network Access Policy taskpad command.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLoggingMachineNode::OnTaskPadDefineNetworkAccessPolicy(
                    IDataObject * pDataObject
                  , VARIANT * pvarg
                  , VARIANT * pvparam
                  )
{
   TRACE_FUNCTION("CLoggingMachineNode::OnTaskPadDefineNetworkAccessPolicy");

   // Check for preconditions:
   // None.

   if ( !m_fSdoConnected )
   {
      return S_OK;
   }

   HRESULT hr = S_OK ;
   bool  bDummy =  TRUE;

   // Simulate a call to the OnNewPolicy message on the CPoliciesNode object,
   // just as if the user had clicked on New Policy
   _ASSERTE( m_pLoggingNode != NULL );
   

   // The process command message will need a pointer to CSnapInObjectRoot
   CLoggingComponentData *pComponentData = GetComponentData();
   _ASSERTE( pComponentData != NULL );

    /*
   hr = m_pPoliciesNode->OnNewPolicy(
                       bDummy    // Not needed.
                     , (CSnapInObjectRoot *) pComponentData
                     );
    */
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMachineNode::BeginConnectAction


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLoggingMachineNode::BeginConnectAction( void )
{
   TRACE_FUNCTION("CLoggingMachineNode::BeginConnectAction");

   HRESULT hr;

   if( NULL != m_pConnectionToServer )
   {
      // Already begun.
      return S_FALSE;
   }

   m_pConnectionToServer = new CLoggingConnectionToServer(
                              (CLoggingMachineNode *) this,
                              m_bstrServerAddress,
                              m_enumExtendedSnapin == INTERNET_AUTHENTICATION_SERVICE_SNAPIN );
   if( ! m_pConnectionToServer )
   {
      ShowErrorDialog( NULL, IDS_ERROR_CANT_CREATE_OBJECT, NULL, S_OK, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );
      return E_OUTOFMEMORY;
   }
   
   m_pConnectionToServer->AddRef();

   // This starts the connect action off in another thread.

   CLoggingComponentData * pComponentData = GetComponentData();
   _ASSERTE( pComponentData != NULL );
   _ASSERTE( pComponentData->m_spConsole != NULL );

   HWND hWndMainWindow;

   hr = pComponentData->m_spConsole->GetMainWindow( &hWndMainWindow );
   _ASSERTE( SUCCEEDED( hr ) );
   _ASSERTE( NULL != hWndMainWindow );

   // This modeless dialog will take care of calling InitSdoPointers
   // when it is notified by the worker thread it creates that
   // the connect action got an SDO pointer.
   HWND hWndConnectDialog = m_pConnectionToServer->Create( hWndMainWindow );

   if( ! hWndConnectDialog )
   {
      // Error -- couldn't create window.
      ShowErrorDialog( NULL, USE_DEFAULT, NULL, S_OK, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );
      return E_FAIL;
   }

   if ( m_enumExtendedSnapin != INTERNET_AUTHENTICATION_SERVICE_SNAPIN )
   {
      //
      // don't show the "Connecting ... " window for IAS, because IAS UI
      // already does that
      //
      
      // MAM 07/27/98 -- Don't show any connection window at all -- we will
      // change the policies icon to an hourglass.
      //pConnectionToServer->ShowWindow(SW_SHOW);
   }
   return S_OK;
}


//+---------------------------------------------------------------------------
//
// Function:  CLoggingMachineNode::LoadSdoData
//
// Synopsis:  load data from SDO
//
// Arguments: BOOL  fDSAvailable -- is DS service available for this machine?
//
// Returns:   HRESULT -
//
// History:   Created Header    byao  6/11/98 3:17:21 PM
//                      Created for asynchrnous connect call
//+---------------------------------------------------------------------------
HRESULT CLoggingMachineNode::LoadSdoData(BOOL  fDSAvailable)
{
   TRACE_FUNCTION("CLoggingMachineNode::LoadSdoData");

   HRESULT hr = S_OK;

   m_fDSAvailable = fDSAvailable;

   // Retrieve the SDO interfaces which were obtained
   // during the Connect action.
   ISdo*  pServiceSdo;

   // Make sure this is NULL before we try to set it.
   pServiceSdo = NULL;

   hr = m_pConnectionToServer->GetSdoService( &pServiceSdo );
   if( FAILED( hr ) || ! pServiceSdo )
   {
      ErrorTrace(ERROR_NAPMMC_MACHINENODE, "Can't get Service Sdo");
      return hr;
   }

   // Give the policies node the pointer to the policies sdo collection.
   if ( m_pLoggingNode )
   {
        hr = m_pLoggingNode->InitSdoPointers(pServiceSdo);
   }
   
   m_fSdoConnected = TRUE;

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CServerNode::CheckConnectionToServer

Use this to check that the connection to the server is up before you do
anything with SDO pointers.

Parameters

  BOOL fVerbose  - set this to TRUE if you want messages output to user.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP  CLoggingMachineNode::CheckConnectionToServer( BOOL fVerbose )
{
   ATLTRACE(_T("# CLoggingMachineNode::CheckConnectionToServer\n"));
   
   if( ! m_pConnectionToServer )
   {
      if( fVerbose )
      {
         ShowErrorDialog( NULL, IDS_ERROR__NO_CONNECTION_ATTEMPTED, NULL, S_OK, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );
      }
      return RPC_E_DISCONNECTED;
   }

   switch( m_pConnectionToServer->GetConnectionStatus() )
   {
       case NO_CONNECTION_ATTEMPTED:
          if( fVerbose )
          {
            ShowErrorDialog( NULL, IDS_ERROR__NO_CONNECTION_ATTEMPTED, NULL, S_OK, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );
          }
          return RPC_E_DISCONNECTED;
          break;
   
        case CONNECTING:
          if( fVerbose )
          {
            ShowErrorDialog( NULL, IDS_ERROR__CONNECTION_IN_PROGRESS, NULL, S_OK, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );
          }
          return RPC_E_DISCONNECTED;
          break;
   
        case CONNECTED:
          return S_OK;
          break;
   
        case CONNECTION_ATTEMPT_FAILED:
          if( fVerbose )
          {
            ShowErrorDialog( NULL, IDS_ERROR__CONNECTION_ATTEMPT_FAILED, NULL, S_OK, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );
          }
          return RPC_E_DISCONNECTED;
          break;
   
        case CONNECTION_INTERRUPTED:
          if( fVerbose )
          {
            ShowErrorDialog( NULL, IDS_ERROR__CONNECTION_INTERRUPTED, NULL, S_OK, IDS_ERROR__LOGGING_TITLE, GetComponentData()->m_spConsole );
          }
          return RPC_E_DISCONNECTED;
          break;
   
        default:
          // We shouldn't get here.
          _ASSERTE( FALSE );
          return E_FAIL;
          break;
   }
}


//////////////////////////////////////////////////////////////////////////////
/*++

CMachineNode::DataRefresh


--*/
//////////////////////////////////////////////////////////////////////////////

// called to refresh the nodes
HRESULT  CLoggingMachineNode::DataRefresh()
{
   HRESULT hr = S_OK;

   CComPtr<ISdo>           spSdo;
   hr = m_pConnectionToServer->ReloadSdo(&spSdo, NULL);

   // refresh client node
   if(hr == S_OK)
   {
      hr = m_pLoggingNode->DataRefresh(spSdo);
   }
   
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMachineNode::OnRefresh

For more information, see CSnapinNode::OnRefresh which this method overrides.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLoggingMachineNode::OnRefresh(   
                    LPARAM arg
                  , LPARAM param
                  , IComponentData * pComponentData
                  , IComponent * pComponent
                  , DATA_OBJECT_TYPES type
                  )
{
   ATLTRACE(_T("# CServerNode::OnRefresh\n"));

   // Check for preconditions:
   //_ASSERTE( pComponentData != NULL || pComponent != NULL );

   return LoadCachedInfoFromSdo();
}


//////////////////////////////////////////////////////////////////////////////
/*++

CLoggingMachineNode::LoadCachedInfoFromSdo

Causes this node and its children to re-read all their cached info from
the SDO's.  Call if you change something and you want to make sure that
the display reflects this change.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CLoggingMachineNode::LoadCachedInfoFromSdo( void )
{
   ATLTRACE(_T("# CServerNode::LoadCachedInfoFromSdo\n"));

   // Check for preconditions:

   HRESULT hr;

   hr = m_pLoggingNode->LoadCachedInfoFromSdo();
   // Ignore failed HRESULT.

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\machineenumtask.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    MachineEnumTask.cpp

Abstract:

	This class implements the CMachineEnumTask class, an enumerator for 
	tasks the NAP snapin will add to the main IAS taskpad.

Revision History:
	mmaguire 03/06/98 - created from IAS taskpad code


--*/
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "MachineEnumTask.h"
//
// where we can find declarations needed in this file:
//
#include "MachineNode.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
/*++

CMachineEnumTask::CMachineEnumTask

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CMachineEnumTask::CMachineEnumTask( CMachineNode * pMachineNode )
{
	TRACE_FUNCTION("CMachineEnumTask::CMachineEnumTask");
	
	// Check for preconditions.	
	_ASSERTE( pMachineNode != NULL );

	m_pMachineNode = pMachineNode;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CMachineEnumTask::CMachineEnumTask

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CMachineEnumTask::CMachineEnumTask()
{
	TRACE_FUNCTION("CMachineEnumTask::CMachineEnumTask");
}



//////////////////////////////////////////////////////////////////////////////
/*++

CMachineEnumTask::Init

Here is where we see what taskpad we are providing tasks for.
In our case we know that we only have one taskpad.
The string we test for is "CMTP1". This was the string following the '#'
that we passed in GetResultViewType.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CMachineEnumTask::Init (IDataObject * pdo, LPOLESTR szTaskGroup)
{
	TRACE_FUNCTION("CMachineEnumTask::Init");

	// Return ok, if we can handle data object and group.
	if( !lstrcmp(szTaskGroup, L"CMTP1") )
	{
		m_type = 1; // default tasks
	}
	else
	{
		_ASSERTE(FALSE);
	}
	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CMachineEnumTask::Next

We get called here over and over untill we have no more tasks to provide.
Other tasks may still appear on our taskpad as a result of what extensions add.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CMachineEnumTask::Next (ULONG celt, MMC_TASK *rgelt, ULONG *pceltFetched)
{
	TRACE_FUNCTION("CMachineEnumTask::Next");
		
	// Caller alloc's array of MMC_TASKs.
   	// Callee fills MMC_TASK elements (via CoTaskMemAlloc).
	
	// Check for preconditions.	
	if ((rgelt == NULL) || (pceltFetched == NULL))
	{
		return E_INVALIDARG;
	}
	_ASSERTE(!IsBadWritePtr (rgelt, celt*sizeof(MMC_TASK)));
	_ASSERTE(!IsBadWritePtr (pceltFetched, sizeof(ULONG)));
	_ASSERTE( m_type == 1 );
	_ASSERTE( m_pMachineNode != NULL );

	UINT uintTextResourceID;
	UINT uintHelpTextResourceID;
	TCHAR lpszTemp[IAS_MAX_STRING];
	int nLoadStringResult;
	

	// Setup a path to resources used in each case.
	// In each case, we are constructing a string pointing to the resource 
	// of the form: "res://D:\MyPath\MySnapin.dll/img\SomeImage.bmp"

	// Make the mouse over bitmap address.
	OLECHAR szMouseOverBuffer[MAX_PATH*2];    // A little extra.

	lstrcpy (szMouseOverBuffer, L"res://");

	HINSTANCE hInstance = _Module.GetModuleInstance();

	::GetModuleFileName (hInstance, szMouseOverBuffer + lstrlen(szMouseOverBuffer), MAX_PATH);
	OLECHAR * szMouseOverBufferAfterFileName = szMouseOverBuffer + lstrlen(szMouseOverBuffer);


	// Make a copy of the string we built above for the mouse off bitmap address.
	OLECHAR szMouseOffBuffer[MAX_PATH*2];    // A little extra.
	
	lstrcpy( szMouseOffBuffer, szMouseOverBuffer );

	OLECHAR * szMouseOffBufferAfterFileName = szMouseOffBuffer + lstrlen(szMouseOffBuffer);


	// celt will actually always only be 1
	for (ULONG i=0; i<celt; i++)
	{
		// make an MMC_TASK pointer to make life easier below.
		MMC_TASK * task = &rgelt[i];

		// Add action.
		task->eActionType = MMC_ACTION_ID;
		task->sDisplayObject.eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;	// Non-transparent raster.


		// Decide on the appropriate resource to use based on m_index, 
		// which tells us which task we are enumerating.
		switch( m_index )
		{
		case 0:
//			if( m_pMachineNode->m_fClientAdded )
//			{
//				lstrcpy (szBufferAfterFileName , L"/img\\TaskClientDone.bmp");
//			}
//			else
//			{
				lstrcpy (szMouseOverBufferAfterFileName , L"/img\\TaskDefineNAPMouseOver.gif");
				lstrcpy (szMouseOffBufferAfterFileName , L"/img\\TaskDefineNAP.gif");
//			}
			uintTextResourceID = IDS_TASKPAD_TEXT__DEFINE_NETWORK_ACCCESS_POLICY;
			uintHelpTextResourceID = IDS_TASKPAD_HELP_TEXT__DEFINE_NETWORK_ACCCESS_POLICY;
			task->nCommandID = MACHINE_TASK__DEFINE_NETWORK_ACCESS_POLICY;		// Set the task identifier.
			break;
		default:
			// Problem -- we only have the tasks listed above.
			if (pceltFetched)
			{
				*pceltFetched = i;	// Note that this is accurate because i above is zero based.
			}
			return S_FALSE;   // Failed to enumerate any more tasks.
			break;
		}

		task->sDisplayObject.uBitmap.szMouseOverBitmap = (LPOLESTR) CoTaskMemAlloc( sizeof(OLECHAR)*(lstrlen(szMouseOverBuffer)+1) );
		
		if( task->sDisplayObject.uBitmap.szMouseOverBitmap )
		{
			// Copy the string to the allocated memory.
			lstrcpy( task->sDisplayObject.uBitmap.szMouseOverBitmap, szMouseOverBuffer );

			task->sDisplayObject.uBitmap.szMouseOffBitmap = (LPOLESTR) CoTaskMemAlloc( sizeof(OLECHAR)*(lstrlen(szMouseOffBuffer)+1) );

			if( task->sDisplayObject.uBitmap.szMouseOffBitmap ) 
			{
				// Copy the string to the allocated memory.
				lstrcpy( task->sDisplayObject.uBitmap.szMouseOffBitmap, szMouseOffBuffer);

				 // Add button text, loaded from resources.
				nLoadStringResult = LoadString(  _Module.GetResourceInstance(), uintTextResourceID, lpszTemp, IAS_MAX_STRING );
				_ASSERT( nLoadStringResult > 0 );
				task->szText = (LPOLESTR) CoTaskMemAlloc( sizeof(OLECHAR)*(lstrlen(lpszTemp)+1) );

				if (task->szText) 
				{
					// Copy the string to the allocated memory.
					lstrcpy( task->szText, lpszTemp );

					// Add help string, loaded from resources.

					// ISSUE: Why don't I seem to be loading the whole string here sometimes
					// e.g.: for IDS_TASKPAD_HELP_TEXT__REGISTER_NEW_RADIUS_CLIENT ?

					nLoadStringResult = LoadString(  _Module.GetResourceInstance(), uintHelpTextResourceID, lpszTemp, IAS_MAX_STRING );
					_ASSERT( nLoadStringResult > 0 );
					task->szHelpString = (LPOLESTR) CoTaskMemAlloc( sizeof(OLECHAR)*(lstrlen(lpszTemp)+1) );

					if (task->szHelpString) 
					{
						// Copy the string to the allocated memory.
						lstrcpy( task->szHelpString, lpszTemp );
						
						m_index++;
						continue;   // all is well
					}

					// If we get here, there was an error, and we didn't "continue".
					CoTaskMemFree(task->szText);

				}

				// If we get here, there was an error, and we didn't "continue".
				CoTaskMemFree(task->sDisplayObject.uBitmap.szMouseOffBitmap);

			}

			// If we get here, there was an error, and we didn't "continue".
			CoTaskMemFree(task->sDisplayObject.uBitmap.szMouseOverBitmap);

		}


		// If we get here, we didn't "continue" and therefore fail.
		if ( NULL != pceltFetched)
		{
			*pceltFetched = i;	// Note that this is accurate because i above is zero based.
		}
		return S_FALSE;   // Failure.
	}

	// If we get here all is well.
	if (pceltFetched)
	  *pceltFetched = celt;
	return S_OK;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CMachineEnumTask::CopyState

Used by the clone method.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CMachineEnumTask::CopyState( CMachineEnumTask * pSourceMachineEnumTask )
{
	TRACE_FUNCTION("CMachineEnumTask::CopyState");

	m_pMachineNode  = pSourceMachineEnumTask->m_pMachineNode;
	m_index = pSourceMachineEnumTask->m_index;
	m_type = pSourceMachineEnumTask->m_type;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\machineenumtask.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    MachineEnumTask.h

Abstract:

	Header file for the CMachineEnumTask class -- this class implements 
	an enumerator for tasks to add the NAP taskpad to the main IAS one.

	See MachineEnumTask.cpp for implementation details.

Revision History:
	mmaguire 03/06/98 - created from IAS taskpad code


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_MACHINE_ENUM_TASKS_H_)
#define _IAS_MACHINE_ENUM_TASKS_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "EnumTask.h"
//
//
// where we can find what this class has or uses:
//

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



#define MACHINE_TASK__DEFINE_NETWORK_ACCESS_POLICY				10


class CMachineNode;

class CMachineEnumTask : public IEnumTASKImpl<CMachineEnumTask>
{

public:

	// Use this constructor - pass in a pointer to CMachineNode.
	CMachineEnumTask( CMachineNode * pMachineNode );

	// This constructor is used only by IEnumTASKImpl's Clone method.
	CMachineEnumTask();



	STDMETHOD(Init)(
		  IDataObject * pdo
		, LPOLESTR szTaskGroup
		);

	STDMETHOD(Next)( 
		  ULONG celt
		, MMC_TASK *rgelt
		, ULONG *pceltFetched
		);

	STDMETHOD(CopyState)( CMachineEnumTask * pSourceMachineEnumTask );


	CMachineNode * m_pMachineNode;

};


#endif // _IAS_MACHINE_ENUM_TASKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\machinenode.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    MachineNode.h

Abstract:

	Header file for the MachineNode subnode.

	See MachineNode.cpp for implementation.

Revision History:
	mmaguire 12/03/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NAP_MACHINE_NODE_H_)
#define _NAP_MACHINE_NODE_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "SnapinNode.h"
#include "rtradvise.h"

//
//
// where we can find what this class has or uses:
//
#include "PoliciesNode.h"
#include "ConnectionToServer.h"
#include <map>
#include <string>
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Functor needed for CComBSTR comparison used in map below
//////////////////////////////////////////////////////////////////////////////
//class MySort
//{
//
//public:
//
//	MySort()
//	{
//		;
//	}
//
////	bool operator()( const CComBSTR & x, const CComBSTR & y) const throw ()
//
//	bool operator()( const pair< CComBSTR, CMachineNode* > & x, const pair< CComBSTR, CMachineNode* > & y) const throw ()
//	{
//
//		bool bReturnValue = FALSE;
//
//		return bReturnValue;
//
//	}
//
//};



class CComponentData;
class CComponent;


//typedef std::map< string, CMachineNode *, MySort() > SERVERSMAP;
typedef std::map< std::basic_string< wchar_t > , CMachineNode * > SERVERSMAP;


class CMachineNode : public CSnapinNode< CMachineNode, CComponentData, CComponent >
{

public:

	
	// Clipboard format through which this extension snapin receives
	// information about machine it's focussed on.
	static CLIPFORMAT m_CCF_MMC_SNAPIN_MACHINE_NAME;
	
	static void InitClipboardFormat();

	
	// Returns whether we extend a particular GUID and sets the
	// m_enumExtendedSnapin to indicate which snapin we are extending.
	BOOL IsSupportedGUID( GUID & guid );

	// Indicates which standalone snapin we are extending.
	_enum_EXTENDED_SNAPIN m_enumExtendedSnapin;



	HRESULT InitSdoObjects();

	SNAPINMENUID(IDM_MACHINE_NODE)

	BEGIN_SNAPINTOOLBARID_MAP(CMachineNode)
		SNAPINTOOLBARID_ENTRY(IDR_MACHINE_TOOLBAR)
	END_SNAPINTOOLBARID_MAP()

	CSnapInItem * GetExtNodeObject(LPDATAOBJECT pDataObject, CMachineNode * pDataClass );

	CMachineNode();

	~CMachineNode();

	LPOLESTR GetResultPaneColInfo(int nCol);

	// Pointer to the CComponentData object owning this node.
	// A root node doesn't belong to another node, so its
	// m_pParentNode pointer is NULL.
	// Rather it is owned by the unique IComponentData object
	// for this snapin.
	// We pass in this CComponentData pointer during CComponentData initialization.
	// By storing this pointer, we can have access to member
	// variables stored in CComponentData, e.g. a pointer to IConsole.
	// Since all nodes store a pointer to their parent, any node
	// can look its way up the tree and get access to CComponentData.
	CComponentData * m_pComponentData;


	void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault);

	BOOL m_fAlreadyAnalyzedDataClass;
	BOOL m_bConfigureLocal;

	CComBSTR m_bstrServerAddress;


	HRESULT	DataRefresh();
	
	virtual HRESULT OnExpand(	
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			);

	virtual HRESULT OnRename(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			);

	virtual HRESULT OnRemoveChildren(
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type
				);
				
	STDMETHOD(TaskNotify)(
				  IDataObject * pDataObject
				, VARIANT * pvarg
				, VARIANT * pvparam
				);

	STDMETHOD(EnumTasks)(
				  IDataObject * pDataObject
				, BSTR szTaskGroup
				, IEnumTASK** ppEnumTASK
				);

	HRESULT OnTaskPadDefineNetworkAccessPolicy(
				  IDataObject * pDataObject
				, VARIANT * pvarg
				, VARIANT * pvparam
				);


	CComponentData * GetComponentData( void );

	// Pointers to child nodes.
	CPoliciesNode * m_pPoliciesNode; // this is one CPoliciesNode object

	////////////////////////////////////////////////////////////////////////////
	//
	// Asynchrnous connect related...
	//
	////////////////////////////////////////////////////////////////////////////
	HRESULT BeginConnectAction( void );
	HRESULT LoadSdoData(BOOL fDSAvailable);

	////////////////////////////////////////////////////////////////////////////
	//
	// RRAS related
	//
	////////////////////////////////////////////////////////////////////////////

	// OnRRASChange -- to decide if to show RAP node under the machine node
	// Only show RAP node if NT Authentication is selected
	HRESULT OnRRASChange( 
            /* [in] */ LONG_PTR ulConnection,
            /* [in] */ DWORD dwChangeType,
            /* [in] */ DWORD dwObjectType,
            /* [in] */ LPARAM lUserParam,
            /* [in] */ LPARAM lParam);
            
    HRESULT TryShow(BOOL* pbVisible);


	BOOL	m_bServerSupported;
	////////////////////////////////////////////////////////////////////////////
	//
	// SDO related pointers
	//
	////////////////////////////////////////////////////////////////////////////

protected:
	virtual HRESULT SetVerbs( IConsoleVerb * pConsoleVerb );
	BOOL	m_fSdoConnected;
	BOOL	m_fUseActiveDirectory;
	BOOL	m_fDSAvailable;
	CConnectionToServer*	m_pConnectionToServer;

	BOOL	m_fNodeHasUI;


	// For extending snapins like RRAS which have multiple machine views.
	SERVERSMAP m_mapMachineNodes;
	CComPtr< CRtrAdviseSinkForIAS<CMachineNode> >	m_spRtrAdviseSink;
};


_declspec( selectany ) CLIPFORMAT CMachineNode::m_CCF_MMC_SNAPIN_MACHINE_NAME = 0;
// _declspec( selectany ) _enum_EXTENDED_SNAPIN CMachineNode::m_enumExtendedSnapin = INTERNET_AUTHENTICATION_SERVICE_SNAPIN;


#endif // _NAP_MACHINE_NODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\matchcondition.cpp ===
/****************************************************************************************
 * NAME:	MatchCondition.cpp
 *
 * CLASS:	CMatchCondition
 *
 * OVERVIEW
 *
 *				Match type condition
 *				
 *				ex:  MachineType  MATCH <a..z*>
 *
 *
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History:	
 *				1/28/98		Created by	Byao	(using ATL wizard)
 *
 *****************************************************************************************/
#include "precompiled.h"
#include "MatchCondition.h"
#include "MatchCondEdit.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CMatchCondition::CMatchCondition(IIASAttributeInfo*  pCondAttr)
				:CCondition(pCondAttr)
{
    TRACE_FUNCTION("CMatchCondition::CMatchCondition()");
	
    // we don't need to do the parsing since there's no condition text
	m_fParsed = TRUE;  
}


CMatchCondition::CMatchCondition(IIASAttributeInfo* pCondAttr,
								 ATL::CString& strConditionText
								)
				:CCondition(pCondAttr, strConditionText)
{
    TRACE_FUNCTION("CMatchCondition::CMatchCondition()");
	
	//
	// we need initialization later
	//
	m_fParsed = FALSE;	
}


CMatchCondition::~CMatchCondition()
{
    TRACE_FUNCTION("CMatchCondition::~CMatchCondition()");	
}

//+---------------------------------------------------------------------------
//
// Function:  Edit
//
// Class:	  CMatchCondition
// 
// Synopsis:  edit the match-typed condition
//
// Arguments: None
//
// Returns:   HRESULT - 
//
// History:   Created Header    byao	2/20/98 12:42:59 AM
//
//+---------------------------------------------------------------------------
HRESULT CMatchCondition::Edit()
{
    TRACE_FUNCTION("CMatchCondition::Edit()");
	
	HRESULT hr = S_OK;

	if ( !m_fParsed )
	{
		// we need to parse this condition text first
		DebugTrace(DEBUG_NAPMMC_MATCHCOND, "Need to parse condition %ws", (LPCTSTR)m_strConditionText);
		hr = ParseConditionText();

		if ( FAILED(hr) )
		{
			ErrorTrace(ERROR_NAPMMC_MATCHCOND, "Invalid Condition %ws, err=%x", (LPCTSTR)m_strConditionText, hr);
			ShowErrorDialog(NULL, 
							IDS_ERROR_PARSE_CONDITION, 
							(LPTSTR)(LPCTSTR)m_strConditionText, 
							hr
						);
			return hr;
		}
		DebugTrace(DEBUG_NAPMMC_MATCHCOND, "Parsing Succeeded!");
	}

	// now we create a new condition editor object
	DebugTrace(DEBUG_NAPMMC_MATCHCOND, "Calling new CMatchCondEditor ...");
	CMatchCondEditor *pEditor = new CMatchCondEditor();

	if (!pEditor)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		ErrorTrace(ERROR_NAPMMC_MATCHCOND, "Can't new a CMatchCondEditor object: err %x", hr);
		return hr;
	}
	
	pEditor->m_strRegExp = m_strRegExp;

	CComBSTR bstrName;
	hr = m_spAttributeInfo->get_AttributeName( &bstrName );
	_ASSERTE( SUCCEEDED( hr ) );
	pEditor->m_strAttrName = bstrName;

	DebugTrace(DEBUG_NAPMMC_MATCHCOND, 
			   "Start Match condition editor for %ws, %ws", 
			   (LPCTSTR)pEditor->m_strAttrName, 
			   (LPCTSTR)pEditor->m_strRegExp 
			  );

	if ( pEditor->DoModal() == IDOK)
	{
		// user clicked "OK" -- get the regular expression
		m_strRegExp  = pEditor->m_strRegExp;
		//
		// fix up the condition text for SDO
		//

      // Escape any magic characters.
      ::CString raw(m_strRegExp);
      raw.Replace(L"\"", L"\"\"");

		m_strConditionText = bstrName;
		m_strConditionText += L"=" ;
		m_strConditionText += raw;

		hr = S_OK;
	}

	DebugTrace(DEBUG_NAPMMC_MATCHCOND, "New condition: %ws", (LPCTSTR)m_strConditionText);

	// clean up
	if ( pEditor )
	{
		delete pEditor;
	}

	return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  CMatchCondition::GetDisplayText
//
// Synopsis:  Get the displayable text format for this condition,
//			  which should be like this:
//				
//					DialinProperty.NASIPAddress matches "220.23" 
//			  
//			  compared to the condition text:
//				
//					DialinProperty.NASIPAddress = 220.23 
//
// Arguments: None
//
// Returns:   ATL::CString& - the displayable text
//
// History:   Created Header    byao	2/22/98 11:41:28 PM
//
//+---------------------------------------------------------------------------
ATL::CString CMatchCondition::GetDisplayText()
{
	TRACE_FUNCTION("CMatchCondition::GetDisplayText()");
	
	HRESULT hr = S_OK;

	if ( !m_fParsed)
	{
		// we need to parse this condition text first
		DebugTrace(DEBUG_NAPMMC_MATCHCOND, "Need to parse condition %ws", (LPCTSTR)m_strConditionText);
		hr = ParseConditionText();

		if ( FAILED(hr) )
		{
			ErrorTrace(ERROR_NAPMMC_MATCHCOND, "Invalid Condition %ws, err=%x", (LPCTSTR)m_strConditionText, hr);
			ShowErrorDialog(NULL, 
							IDS_ERROR_PARSE_CONDITION, 
							(LPTSTR)(LPCTSTR)m_strConditionText, 
							hr
						);
			return ATL::CString(_T(" "));
		}
	}

	// generate the displayable condition text
	ATL::CString strDispText;

	CComBSTR bstrName;
	hr = m_spAttributeInfo->get_AttributeName( &bstrName );
	_ASSERTE( SUCCEEDED( hr ) );
	strDispText = bstrName;

// ISSUE: The word "matches" below is hardcoded and it shouldn't be.	
	{ ATL::CString	matches;
		matches.LoadString(IDS_TEXT_MATCHES);
		strDispText += matches;
	}
	
	strDispText += L"\"";
	strDispText += m_strRegExp;
	strDispText += L"\" ";

	DebugTrace(DEBUG_NAPMMC_MATCHCOND, "Returning displayable text: %ws", (LPCTSTR)strDispText);
	return strDispText;
}

//+---------------------------------------------------------------------------
//
// Function:  CMatchCondition::ParseConditionText
//
// Synopsis:  Parse the condition text, to get the regular expression.
//
// Arguments: None
//
// Returns:   HRESULT - 
//
// History:   Created Header    byao	2/22/98 11:58:38 PM
//
//+---------------------------------------------------------------------------
HRESULT CMatchCondition::ParseConditionText()
{
	TRACE_FUNCTION("CMatchCondition::ParseConditionText()");

	_ASSERTE( !m_fParsed );
	HRESULT hr = S_OK;

	if (m_fParsed)
	{
		DebugTrace(DEBUG_NAPMMC_MATCHCOND,"Weird ... parsed flag already set!");
		// do nothing
		return S_OK;
	}

    // 
    // parse strConditionText, return the regular expression only
    // 
	WCHAR *pwzCondText = (LPTSTR) ((LPCTSTR)m_strConditionText);

	// look for the '=' in the condition text
	WCHAR *pwzEqualSign = wcschr(pwzCondText, L'=');

	// no '=' found -- something weird has happened
	if ( pwzEqualSign == NULL )
	{
		ErrorTrace(ERROR_NAPMMC_MATCHCOND, "Can't find '=' in the regular expression!");
		return E_UNEXPECTED;
	}
	
	// The right side of the equal sign is the regular expression.
   ::CString raw = pwzEqualSign + 1;

   // Remove any escape sequences.
   raw.Replace(L"\"\"", L"\"");

	m_strRegExp = raw;
	DebugTrace(DEBUG_NAPMMC_MATCHCOND, "Regular expression: %ws", (LPCTSTR)m_strRegExp);

	m_fParsed = TRUE;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\machinenode.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    MachineNode.cpp

Abstract:

	Implementation file for the CMachineNode class.


Revision History:
	mmaguire 12/03/97
	byao	  6/11/98	Added asynchrnous connect

--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"

//
// where we can find declaration for main class in this file:
//

#include "MachineNode.h"
#include "Component.h"
#include "SnapinNode.cpp"	// Template implementation

//
// where we can find declarations needed in this file:
//
#include "NapUtil.h"
#include "MachineEnumTask.h"
#include "NodeTypeGUIDS.h"
#include "ChangeNotification.h"

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
/*++

CMachineNode::IsSupportedGUID

Used to determine whether we extend the node type of a given GUID, and sets
the m_enumExtendedSnapin variable to indicate what snapin we are extending.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CMachineNode::IsSupportedGUID( GUID & guid )
{


	if( IsEqualGUID( guid, InternetAuthenticationServiceGUID_ROOTNODETYPE ) )
	{
		m_enumExtendedSnapin = INTERNET_AUTHENTICATION_SERVICE_SNAPIN;
		return TRUE;
	}
	else
	{
		if( IsEqualGUID( guid, NetworkConsoleGUID_ROOTNODETYPE) )
		{
			m_enumExtendedSnapin = NETWORK_MANAGEMENT_SNAPIN;
			return TRUE;
		}
		else
		{
			if( IsEqualGUID( guid, RoutingAndRemoteAccessGUID_MACHINENODETYPE ) )
			{
				m_enumExtendedSnapin = RRAS_SNAPIN;
				return TRUE;
			}
		}
	}

	return FALSE;
	
}




//////////////////////////////////////////////////////////////////////////////
/*++

CMachineNode::GetExtNodeObject

Depending on which snapin we are extending, when queried for a node object
corresponding to a particular machine, we must decide which node we want
to give a pointer to.

When we extend a snapin like IAS or Network Management, where there is one
instance of a snapin per machine being configured, we simply return a pointer
to "this" -- this CMachineNode object is the single one being administed.

When we extend a snapin like RRAS where there is an "Enterprise" view and
one snapin may need to manage a view of multiple machines, this CMachineNode
will act as a redirector to a CMachineNode in a list of m_mapMachineNodes it
maintains which corresponds to the appropriate machines.

--*/
//////////////////////////////////////////////////////////////////////////////
CSnapInItem * CMachineNode::GetExtNodeObject(LPDATAOBJECT pDataObject, CMachineNode * pDataClass )
{
	TRACE_FUNCTION("CMachineNode::GetExtNodeObject");

	if( m_enumExtendedSnapin == INTERNET_AUTHENTICATION_SERVICE_SNAPIN
		|| m_enumExtendedSnapin == NETWORK_MANAGEMENT_SNAPIN )
	{
		// There is one instance of a machine node per snapin.
		// This machine node is a "virtual root" that shadows the node being extended.
		m_fNodeHasUI = TRUE;
		return this;
	}
	else
	{
		try
		{

			_ASSERTE( m_enumExtendedSnapin == RRAS_SNAPIN );

			// There are many machine nodes and one extension snapin needs to handle them all.

			// We use this function to extract the machine name from the clipboard format.
			// It will set the corrent value in m_bstrServerAddress.
			m_fAlreadyAnalyzedDataClass = FALSE;
			InitDataClass( pDataObject, pDataClass );
			
			// See if we already have a CMachineNode object corresponding to the
			// machine named in m_bstrServerAddress and insert it if we do not.

			SERVERSMAP::iterator theIterator;
			BOOL	bAddedAsLocal = ExtractComputerAddedAsLocal(pDataObject);

			std::basic_string< wchar_t > MyString = m_bstrServerAddress;

			// local machine has special entry
			if(bAddedAsLocal)
				MyString = _T("");
				
			CMachineNode * pMachineNode = NULL;

			theIterator = m_mapMachineNodes.find(MyString);
			if( theIterator == m_mapMachineNodes.end() )
			{
				// We need to insert a new CMachineNode object for m_bstrServerAddress.
				pMachineNode = new CMachineNode();
				pMachineNode->m_pComponentData = m_pComponentData;
				pMachineNode->m_enumExtendedSnapin = m_enumExtendedSnapin;
				
				m_mapMachineNodes.insert( SERVERSMAP::value_type( MyString, pMachineNode ) );

				// ISSUE: We should be able to use the pair returned from insert above,
				// but for now, just use find again.
				theIterator = m_mapMachineNodes.find(MyString);
							
			}
			else
				pMachineNode = (CMachineNode*)theIterator->second;

			// RRAS refresh advise setup F bug 213623:
			if(!pMachineNode->m_spRtrAdviseSink)
				pMachineNode->m_spRtrAdviseSink.p = CRtrAdviseSinkForIAS<CMachineNode>::SetAdvise(pMachineNode, pDataObject);

			pMachineNode->m_fNodeHasUI = TRUE;
			// ~RRAS
				
			
			// We already have a CMachineNode for this object.
			return theIterator->second;

		}

		catch(...)
		{
			// Error.
			return NULL;
		}

	
	}


}


//////////////////////////////////////////////////////////////////////////////
/*++

CMachineNode::OnRRASChange

	// OnRRASChange -- to decide if to show RAP node under the machine node
	// Only show RAP node if NT Authentication is selected

--*/
HRESULT CMachineNode::OnRRASChange(
            /* [in] */ LONG_PTR ulConnection,
            /* [in] */ DWORD dwChangeType,
            /* [in] */ DWORD dwObjectType,
            /* [in] */ LPARAM lUserParam,
            /* [in] */ LPARAM lParam)
{

	HRESULT	hr = S_OK;
	if(m_fNodeHasUI)
		hr = TryShow(NULL);
	
	return S_OK;
}

//==============

//==============

HRESULT CMachineNode::TryShow(BOOL* pbVisible )
{
	HRESULT	hr = S_OK;
	CComPtr<IConsole> spConsole;
	CComPtr<IConsoleNameSpace> spConsoleNameSpace;
	BOOL bShow = FALSE;
		
	if(!m_bServerSupported || !m_fAlreadyAnalyzedDataClass || !m_pPoliciesNode || !m_fNodeHasUI)	
		return hr;

	// when RRAS_SNAPIN extension
	if(m_enumExtendedSnapin == RRAS_SNAPIN)
	{
		BSTR	bstrMachine = NULL;
		
		if(!m_bConfigureLocal)
			bstrMachine = m_bstrServerAddress;
			
		bShow = (IsRRASConfigured(bstrMachine) && IsRRASUsingNTAuthentication(bstrMachine));
	}
	// IAS, show only IAS service is installed on the machine
	else if (INTERNET_AUTHENTICATION_SERVICE_SNAPIN == m_enumExtendedSnapin)
	{
		hr = IfServiceInstalled(m_bstrServerAddress, _T("IAS"), &bShow);
		if(hr != S_OK) return hr;
	}
	else	// always show
	{
		bShow = TRUE;
	}

	// deal with the node
	hr = m_pComponentData->m_spConsole->QueryInterface(
											IID_IConsoleNameSpace,
											(VOID**)(&spConsoleNameSpace) );

	if(S_OK != hr)
		goto Error;

	if ( bShow &&  m_pPoliciesNode->m_scopeDataItem.ID == NULL)	// show the node
	{
			hr = spConsoleNameSpace->InsertItem( &(m_pPoliciesNode->m_scopeDataItem) );
//			_ASSERT( NULL != m_pPoliciesNode->m_scopeDataItem.ID );
	}
	else if (!bShow && m_pPoliciesNode->m_scopeDataItem.ID != NULL)	// hide
	{ // hide the node
			hr = spConsoleNameSpace->DeleteItem( m_pPoliciesNode->m_scopeDataItem.ID, TRUE );
			m_pPoliciesNode->m_scopeDataItem.ID = NULL;
	}
	
	if(hr == S_OK && pbVisible)
		*pbVisible = bShow;
Error:

	return hr;
}

	
//////////////////////////////////////////////////////////////////////////////
/*++

CMachineNode::CMachineNode

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CMachineNode::CMachineNode(): CSnapinNode<CMachineNode, CComponentData, CComponent>( NULL )
{
	TRACE_FUNCTION("CMachineNode::CMachineNode");


	// The children subnodes have not yet been created.
	m_pPoliciesNode = NULL;

	// Set the display name for this object
	m_bstrDisplayName = L"@Some Machine";

	// In IComponentData::Initialize, we are asked to inform MMC of
	// the icons we would like to use for the scope pane.
	// Here we store an index to which of these images we
	// want to be used to display this node
	m_scopeDataItem.nImage =		IDBI_NODE_MACHINE_CLOSED;
	m_scopeDataItem.nOpenImage =	IDBI_NODE_MACHINE_OPEN;


	//
	// initialize all the SDO pointers
	//
	m_fAlreadyAnalyzedDataClass = FALSE;	

	// connected?
	m_fSdoConnected = FALSE;

    // default to not configuring the local machine
    m_bConfigureLocal = FALSE;
	

	m_fUseActiveDirectory = FALSE;
	m_fDSAvailable = FALSE;

	// helper class that connect to server asynchrnously
	m_pConnectionToServer = NULL;
	m_fNodeHasUI = FALSE;

	m_bServerSupported = TRUE;

	m_enumExtendedSnapin = INTERNET_AUTHENTICATION_SERVICE_SNAPIN;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CMachineNode::~CMachineNode

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CMachineNode::~CMachineNode()
{
	TRACE_FUNCTION("CMachineNode::~CMachineNode");

	// RRAS refresh
	if(m_spRtrAdviseSink != NULL)
	{
		m_spRtrAdviseSink->ReleaseSink();
		m_spRtrAdviseSink.Release();
	}
		
	// ~RRAS

	if( NULL != m_pConnectionToServer )
	{
		m_pConnectionToServer->Release(TRUE);
	}

	// Delete children nodes
	delete m_pPoliciesNode;

	// Delete the list of machines in case we are extending a snapin with
	// enterprise view like RRAS.
	SERVERSMAP::iterator theIterator;
	for( theIterator = m_mapMachineNodes.begin(); theIterator != m_mapMachineNodes.end(); ++theIterator )
	{
		delete theIterator->second;
	}
	m_mapMachineNodes.clear();

}



//////////////////////////////////////////////////////////////////////////////
/*++

CMachineNode::GetResultPaneColInfo

See CSnapinNode::GetResultPaneColInfo (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
LPOLESTR CMachineNode::GetResultPaneColInfo(int nCol)
{
	TRACE_FUNCTION("CMachineNode::GetResultPaneColInfo");

	if (nCol == 0)
	{
		return m_bstrDisplayName;
	}

	// TODO : Return the text for other columns
	return OLESTR("Running");
}


HRESULT CMachineNode::OnRemoveChildren(
				  LPARAM arg
				, LPARAM param
				, IComponentData * pComponentData
				, IComponent * pComponent
				, DATA_OBJECT_TYPES type
				)
{

	// policy node will be removed, so we should set the ID to 0
	if(m_pPoliciesNode)
		m_pPoliciesNode->m_scopeDataItem.ID = 0;

	// disconnect RRAS on change notify
	// RRAS refresh
	if(m_spRtrAdviseSink != NULL)
	{
		m_spRtrAdviseSink->ReleaseSink();
		m_spRtrAdviseSink.Release();
	}
	m_fNodeHasUI = FALSE;
	
	return S_OK;

}
//////////////////////////////////////////////////////////////////////////////
/*++

CMachineNode::DataRefresh


--*/
//////////////////////////////////////////////////////////////////////////////

// called to refresh the nodes
HRESULT	CMachineNode::DataRefresh()
{
	HRESULT hr = S_OK;

	CComPtr<ISdo>				spSdo;
	CComPtr<ISdoDictionaryOld>	spDic;
	hr = m_pConnectionToServer->ReloadSdo(&spSdo, &spDic);

	// refresh client node
	if(hr == S_OK)
	{
		hr = m_pPoliciesNode->DataRefresh(spSdo, spDic);
	}
	
	
	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CMachineNode::OnExpand

See CSnapinNode::OnExpand (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CMachineNode::OnExpand(	
						  LPARAM arg
						, LPARAM param
						, IComponentData * pComponentData
						, IComponent * pComponent
						, DATA_OBJECT_TYPES type
						)
{
	TRACE_FUNCTION("CMachineNode::OnExpand");

	IConsoleNameSpace * pConsoleNameSpace;
	HRESULT hr = S_FALSE;

	if( TRUE == arg )
	{

		// we are expanding the root node -- which is the machine node here.


		// Try to create the children of this Machine node
		if( NULL == m_pPoliciesNode )
		{
			m_pPoliciesNode = new CPoliciesNode
										(
											this,
											m_bstrServerAddress,
											m_enumExtendedSnapin == INTERNET_AUTHENTICATION_SERVICE_SNAPIN
										);
		}

		if( NULL == m_pPoliciesNode )
		{
			hr = E_OUTOFMEMORY;

			// Use MessageBox() rather than IConsole::MessageBox() here because the
			// first time this gets called m_ipConsole is not fully initialized
			// ISSUE: The above statement is probably not true for this node.
			::MessageBox( NULL, L"@Unable to allocate new nodes", L"CMachineNode::OnExpand", MB_OK );

			return(hr);
		}



        //
        // we need to get all the SDO pointers, this include the SdoServer,
        // Dictionary, Profile collection, policy collection and condition collection
        //


		//todo: report error when not connected?
		hr = BeginConnectAction();
		if ( FAILED(hr) )
		{
			return hr;
		}
			

		// But to get that, first we need IConsole
		CComPtr<IConsole> spConsole;
		if( pComponentData != NULL )
		{
			 spConsole = ((CComponentData*)pComponentData)->m_spConsole;
		}
		else
		{
			// We should have a non-null pComponent
			 spConsole = ((CComponent*)pComponent)->m_spConsole;
		}
		_ASSERTE( spConsole != NULL );

		hr = spConsole->QueryInterface(IID_IConsoleNameSpace, (VOID**)(&pConsoleNameSpace) );
		_ASSERT( S_OK == hr );


		// This was done in MeanGene's Step 3 -- I'm guessing MMC wants this filled in
		m_pPoliciesNode->m_scopeDataItem.relativeID = (HSCOPEITEM) param;

#ifndef	ALWAYS_SHOW_RAP_NODE
		hr = TryShow(NULL);
#else		
		hr = pConsoleNameSpace->InsertItem( &(m_pPoliciesNode->m_scopeDataItem) );
		_ASSERT( NULL != m_pPoliciesNode->m_scopeDataItem.ID );
#endif
		pConsoleNameSpace->Release();	// Don't forget to do this!

	}
	else	// arg != TRUE so not expanding
	{

		// do nothing for now -- I don't think arg = FALSE is even implemented
		// for MMC v. 1.0 or 1.1
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CMachineNode::OnRename

See CSnapinNode::OnRename (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CMachineNode::OnRename(
			  LPARAM arg
			, LPARAM param
			, IComponentData * pComponentData
			, IComponent * pComponent
			, DATA_OBJECT_TYPES type
			)
{
	TRACE_FUNCTION("MachineNode::OnRename");

	HRESULT hr = S_FALSE;

	//ISSUE: Consider moving this into base CNAPNode class or a CLeafNode class

	OLECHAR * pTemp = new OLECHAR[lstrlen((OLECHAR*) param) + 1];
	
	if ( NULL == pTemp )
	{
		return S_FALSE;
	}

	lstrcpy( pTemp, (OLECHAR*) param );

	m_bstrDisplayName = pTemp;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CMachineNode::SetVerbs

See CSnapinNode::SetVerbs (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CMachineNode::SetVerbs( IConsoleVerb * pConsoleVerb )
{
	TRACE_FUNCTION("CMachineNode::SetVerbs");

	HRESULT hr = S_OK;

	// We want the user to be able to choose Properties on this node
	hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );

	// We want the default verb to be Properties
	hr = pConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES );

	// We want the user to be able to delete this node
	hr = pConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE );

	// We want the user to be able to rename this node
	hr = pConsoleVerb->SetVerbState( MMC_VERB_RENAME, ENABLED, TRUE );



	return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CMachineNode::GetComponentData

This method returns our unique CComponentData object representing the scope
pane of this snapin.

It relies upon the fact that each node has a pointer to its parent,
except for the root node, which instead has a member variable pointing
to CComponentData.

This would be a useful function to use if, for example, you need a reference
to some IConsole but you weren't passed one.  You can use GetComponentData
and then use the IConsole pointer which is a member variable of our
CComponentData object.

--*/
//////////////////////////////////////////////////////////////////////////////
CComponentData * CMachineNode::GetComponentData( void )
{
	TRACE_FUNCTION("CMachineNode::GetComponentData");

	return m_pComponentData;

	return NULL;
}



//+---------------------------------------------------------------------------
//
// Function:  CMachineNode::InitClipboardFormat
//
// Synopsis:  initialize the clipboard format that's used to pass computer name
//			  from the primary snap-in and extension snap-in
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    byao	2/25/98 7:04:33 PM
//
//+---------------------------------------------------------------------------
void CMachineNode::InitClipboardFormat()
{
	TRACE_FUNCTION("CMachineNode::InitClipboardFormat");

	// Init a clipboard format which will allow us to exchange
	// machine name information.
	m_CCF_MMC_SNAPIN_MACHINE_NAME = (CLIPFORMAT) RegisterClipboardFormat(_T("MMC_SNAPIN_MACHINE_NAME"));

}


//+---------------------------------------------------------------------------
//
// Function:  CMachineNode::InitDataClass
//
// Synopsis:  gets passed the IDataObject sent to the extension snapin for this
//				node, queries this IDataObject for the name of the machine
//				which this snapin is extending
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    mmaguire	2/25/98 9:07 PM
//
//+---------------------------------------------------------------------------
void CMachineNode::InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
{
	TRACE_FUNCTION("CMachineNode::InitDataClass");

	// Check for preconditions.
	if( m_fAlreadyAnalyzedDataClass )
	{
		// We have already performed any work we needed to do with the dataobject here.
		return;
	}

	if (pDataObject == NULL)
	{
		return;
	}


	HRESULT hr;
//	OLECHAR szMachineName[IAS_MAX_COMPUTERNAME_LENGTH];
	// Try a large size because RRAS seems to want 2048
	OLECHAR szMachineName[4000];


	// Fill the structures which will tell the IDataObject what information
	// we want it to give us.
	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
	FORMATETC formatetc = { m_CCF_MMC_SNAPIN_MACHINE_NAME,
		NULL,
		DVASPECT_CONTENT,
		-1,
		TYMED_HGLOBAL
	};

	// Allocate enough global memory for the IDataObject to write
	// the max computer name length.
	stgmedium.hGlobal = GlobalAlloc(0, sizeof(OLECHAR)*(IAS_MAX_COMPUTERNAME_LENGTH) );
	if (stgmedium.hGlobal == NULL)
	{
		return;
	}

	// Ask the IDataObject for the computer name.
	hr = pDataObject->GetDataHere(&formatetc, &stgmedium);
	if (SUCCEEDED(hr))
	{
		// Parse the data given back to us.
		
		// Create a stream on HGLOBAL
		CComPtr<IStream> spStream;
		hr = CreateStreamOnHGlobal(stgmedium.hGlobal, FALSE, &spStream);
		if (SUCCEEDED(hr))
		{
			// Read from the stream.
			unsigned long uWritten;
			hr = spStream->Read(szMachineName, sizeof(OLECHAR)*(IAS_MAX_COMPUTERNAME_LENGTH), &uWritten);
			if( SUCCEEDED(hr) )
			{
				m_bstrServerAddress = szMachineName;

				                // check to see if we are configuring the local machine
                CString strLocalMachine;
                DWORD dwSize = MAX_COMPUTERNAME_LENGTH;

                ::GetComputerName(strLocalMachine.GetBuffer(dwSize), &dwSize);
                strLocalMachine.ReleaseBuffer();

				// If the machine name we read was either an empty string,
				// or it equals the name of the current computer,
				// then we are configuring the local machine.
				if ( ! szMachineName[0] || strLocalMachine.CompareNoCase(szMachineName) == 0)
				{
                    m_bConfigureLocal = TRUE;
				}
				else
                    m_bConfigureLocal = FALSE;

			}
			else
			{
				ShowErrorDialog( NULL, USE_DEFAULT, NULL, S_OK, USE_DEFAULT, GetComponentData()->m_spConsole );
			}			
		}

	}

	GlobalFree(stgmedium.hGlobal);

	if( SUCCEEDED( hr ) )
	{
		// If we made it to here with an successful HRESULT, we have successfully analyzed
		// the IDataObject and we set this flag so that we don't do this work again.
		m_fAlreadyAnalyzedDataClass = TRUE;	
	}


}





//////////////////////////////////////////////////////////////////////////////
/*++

CMachineNode::TaskNotify

See CSnapinNode::TaskNotify (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CMachineNode::TaskNotify(
			  IDataObject * pDataObject
			, VARIANT * pvarg
			, VARIANT * pvparam
			)
{
	TRACE_FUNCTION("CMachineNode::TaskNotify");


	// Check for preconditions:
	// None.
	if ( !m_fSdoConnected )
	{
		return S_OK;
	}

	
	HRESULT hr = S_FALSE;


	if (pvarg->vt == VT_I4)
	{
		switch (pvarg->lVal)
		{
		case MACHINE_TASK__DEFINE_NETWORK_ACCESS_POLICY:
			hr = OnTaskPadDefineNetworkAccessPolicy( pDataObject, pvarg, pvparam );
			break;
		default:
			break;
		}


	}

	// ISSUE: What should I be returning here?
	return hr;

}



//////////////////////////////////////////////////////////////////////////////
/*++

CMachineNode::EnumTasks

See CSnapinNode::EnumTasks (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CMachineNode::EnumTasks(
			  IDataObject * pDataObject
			, BSTR szTaskGroup
			, IEnumTASK** ppEnumTASK
			)
{
	TRACE_FUNCTION("CMachineNode::EnumTasks");


	// Check for preconditions:
	// None.
	if ( !m_fSdoConnected )
	{
		return S_OK;
	}

	HRESULT hr = S_OK;
	CMachineEnumTask * pMachineEnumTask = new CMachineEnumTask( this );

	if ( pMachineEnumTask  == NULL )
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		// Make sure release works properly on failure.
		pMachineEnumTask ->AddRef ();

		hr = pMachineEnumTask ->Init( pDataObject, szTaskGroup);
		if( hr == S_OK )
		{
			hr = pMachineEnumTask->QueryInterface( IID_IEnumTASK, (void **)ppEnumTASK );
		}
		
		pMachineEnumTask->Release();
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CMachineNode::OnTaskPadDefineNetworkAccessPolicy

Respond to the Define Network Access Policy taskpad command.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CMachineNode::OnTaskPadDefineNetworkAccessPolicy(
						  IDataObject * pDataObject
						, VARIANT * pvarg
						, VARIANT * pvparam
						)
{
	TRACE_FUNCTION("CMachineNode::OnTaskPadDefineNetworkAccessPolicy");


	// Check for preconditions:
	// None.

	if ( !m_fSdoConnected )
	{
		return S_OK;
	}

	HRESULT hr = S_OK ;
	bool	bDummy =  TRUE;


	// Simulate a call to the OnNewPolicy message on the CPoliciesNode object,
	// just as if the user had clicked on New Policy
	_ASSERTE( m_pPoliciesNode != NULL );
	

	// The process command message will need a pointer to CSnapInObjectRoot
	CComponentData *pComponentData = GetComponentData();
	_ASSERTE( pComponentData != NULL );
	
	hr = m_pPoliciesNode->OnNewPolicy(
							  bDummy		// Not needed.
							, (CSnapInObjectRootBase *) pComponentData
							);

	return hr;
}




//////////////////////////////////////////////////////////////////////////////
/*++

CMachineNode::BeginConnectAction


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CMachineNode::BeginConnectAction( void )
{
	TRACE_FUNCTION("CMachineNode::BeginConnectAction");

	HRESULT hr;

	if( NULL != m_pConnectionToServer )
	{
		// Already begun.
		return S_FALSE;
	}

	m_pConnectionToServer = new CConnectionToServer(
										this,
										m_bstrServerAddress,
										m_enumExtendedSnapin == INTERNET_AUTHENTICATION_SERVICE_SNAPIN
									);
	if( NULL == m_pConnectionToServer )
	{
		ShowErrorDialog( NULL, IDS_ERROR_CANT_CREATE_OBJECT, NULL, S_OK, USE_DEFAULT, GetComponentData()->m_spConsole );
		return E_OUTOFMEMORY;
	}
	
	m_pConnectionToServer->AddRef();

	// This starts the connect action off in another thread.

	CComponentData * pComponentData = GetComponentData();
	_ASSERTE( pComponentData != NULL );
	_ASSERTE( pComponentData->m_spConsole != NULL );

	HWND hWndMainWindow;

	hr = pComponentData->m_spConsole->GetMainWindow( &hWndMainWindow );
	_ASSERTE( SUCCEEDED( hr ) );
	_ASSERTE( NULL != hWndMainWindow );

	// This modeless dialog will take care of calling InitSdoPointers
	// when it is notified by the worker thread it creates that
	// the connect action got an SDO pointer.
	HWND hWndConnectDialog = m_pConnectionToServer->Create( hWndMainWindow );

	if( NULL == hWndConnectDialog )
	{
		// Error -- couldn't create window.
		ShowErrorDialog( NULL, USE_DEFAULT, NULL, S_OK, USE_DEFAULT, GetComponentData()->m_spConsole );
		return E_FAIL;
	}

	if ( m_enumExtendedSnapin != INTERNET_AUTHENTICATION_SERVICE_SNAPIN )
	{
		//
		// don't show the "Connecting ... " window for IAS, because IAS UI
		// already does that
		//
		
		// MAM 07/27/98 -- Don't show any connection window at all -- we will
		// change the policies icon to an hourglass.
		//pConnectionToServer->ShowWindow(SW_SHOW);
	}
	return S_OK;
}


//+---------------------------------------------------------------------------
//
// Function:  CMachineNode::LoadSdoData
//
// Synopsis:  load data from SDO
//
// Arguments: BOOL  fDSAvailable	-- is DS service available for this machine?
//
// Returns:   HRESULT -
//
// History:   Created Header    byao  6/11/98 3:17:21 PM
//								Created for asynchrnous connect call
//+---------------------------------------------------------------------------
HRESULT CMachineNode::LoadSdoData(BOOL  fDSAvailable)
{
	TRACE_FUNCTION("CMachineNode::LoadSdoData");

	HRESULT hr = S_OK;

	
	m_fDSAvailable	= fDSAvailable;

	// Retrieve the SDO interfaces that we obtained during the
	// connect action.
	// No smart pointers here -- prevents needless AddRefing and Releasing.
	ISdo* pSdoService;

	hr = m_pConnectionToServer->GetSdoService( &pSdoService );
	if( FAILED( hr ) || ! pSdoService )
	{
		ErrorTrace(ERROR_NAPMMC_MACHINENODE, "Can't get service Sdo");
		return hr;
	}


	ISdoDictionaryOld * pSdoDictionaryOld;

	hr = m_pConnectionToServer->GetSdoDictionaryOld( &pSdoDictionaryOld );
	if( FAILED( hr ) || ! pSdoDictionaryOld )
	{
		ErrorTrace(ERROR_NAPMMC_MACHINENODE, "Can't get dictionary Sdo");
		return hr;
	}



#ifdef STORE_DATA_IN_DIRECTORY_SERVICE

	//
	// Is the server using Active Directory or the local machine?
	//
	CComVariant var;

	hr = spMachineSdo->GetProperty(PROPERTY_SERVER_USE_ACTIVE_DIRECTORY, &var);
	if ( FAILED(hr) )
	{
		ErrorTrace(ERROR_NAPMMC_MACHINENODE, "Can't get Server_Use_Active_Directory property, err = %x", hr);
		return hr;
	}

	_ASSERTE( V_VT(&var) == VT_BOOL );

	m_fUseActiveDirectory = (V_BOOL(&var)==VARIANT_TRUE);

#endif	// STORE_DATA_IN_DIRECTORY_SERVICE


	// Give the policies node the pointer to the policies sdo collection.
	if ( m_pPoliciesNode )
	{
		hr = m_pPoliciesNode->SetSdo(pSdoService,
									 pSdoDictionaryOld,
									 TRUE,						//  fSdoConnected,
									 m_fUseActiveDirectory,
									 m_fDSAvailable				//  fDSAvailable,	
									);
	}
	
	m_fSdoConnected = TRUE;

	// We want to make sure all views get updated.
	CChangeNotification *pChangeNotification = new CChangeNotification();
	pChangeNotification->m_dwFlags = CHANGE_UPDATE_CHILDREN_OF_SELECTED_NODE;
	hr = GetComponentData()->m_spConsole->UpdateAllViews( NULL, (LPARAM) pChangeNotification, 0);
	pChangeNotification->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\meritnode.h ===
/****************************************************************************************
 * NAME:	MeritNode.h
 *
 * OVERVIEW
 *
 * Helper classes : node with merit value array
 *
 *
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History:	
 *				1/28/98		Created by	Byao	(using ATL wizard)
 *
 *****************************************************************************************/


/****************************************************************************************
 * CLASS:	CMeritNodeArray
 *
 * OVERVIEW
 *
 * A template class that implements an array of nodes with merit value. 
 * This can facilitate the manipulation for policy nodes. The sort is 
 * assumed to be in ascending order
 *
 * History:	
 *				2/9/98		Created by	Byao
 *
 * Comment:  1) The implementation is based on ATL implementation of CSimpleArray
 *			 2) class T must implement SetMerit() and operator ">"
 *
 *****************************************************************************************/
template <class T>
class CMeritNodeArray
{
public:
	T* m_aT;
	int m_nSize;

// Construction/destruction
	CMeritNodeArray() : m_aT(NULL), m_nSize(0)
	{ }


	~CMeritNodeArray()
	{
		RemoveAll();
	}


// Operations
	int GetSize() const
	{
		return m_nSize;
	}

    // 
    // add an item into the array while keeping the internal order
    // 
	BOOL NormalizeMerit(T t)
	{
		// the right position in the array
		for(int i = 0; i < m_nSize; i++)
		{
			m_aT[i]->SetMerit(i+1);
		}
	
		return TRUE;
	}

    // 
    // add an item into the array while keeping the internal order
    // 
	BOOL Add(T t)
	{
		int i, j;

		T* aT = NULL;

		if ( !m_aT)
		{
			aT = (T*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(T) );
		}
		else
		{
			aT = (T*)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, m_aT, (m_nSize + 1) * sizeof(T));
		}

		if(aT == NULL)
			return FALSE;

		m_aT = aT;
		m_nSize++;

        // 
        // search for the right position to insert this item
        // Please note: class T needs to implement the operator ">"
		//
		if (t->GetMerit()) 
		{
			// The new node already has a merit value: then search for 
			// the right position in the array
			for(i = 0; i < m_nSize-1; i++)
			{
				if(m_aT[i]->GetMerit() > t->GetMerit())
					break;
			}

			//
			// we've found the right spot, now we move the items downward,
			// so we can have a space to insert the new items
			//
			for (j = m_nSize-1; j > i ; j--) 
			{
				m_aT[j] = m_aT[j-1];
			}

		}
		else
		{	
			// new node: insert at the end
			i = m_nSize-1; 
		}

        // 
        // now insert the item at the spot
        // 
		SetAtIndex(i, t);
	
		return TRUE;
	}

	//
	// remove an item from the array, while keeping the internal order
	//
	BOOL Remove(T t)
	{
		int nIndex = Find(t);
		if(nIndex == -1)
			return FALSE;

		if(nIndex != (m_nSize - 1))
		{
			for (int i=nIndex; i<m_nSize-1; i++) 
			{
				m_aT[i] = m_aT[i+1];
				m_aT[i]->SetMerit(i+1);
			}
		}

		T* aT = (T*)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, m_aT, (m_nSize - 1) * sizeof(T));

		if(aT != NULL || m_nSize == 1)
			m_aT = aT;
		m_nSize--;
		return TRUE;
	}

	//
	// remove all the nodes from the array
	//
	void RemoveAll()
	{
		if(m_nSize > 0)
		{
			HeapFree(GetProcessHeap(), 0, m_aT);
			m_aT = NULL;
			m_nSize = 0;
		}
	}

	// 
	// Move up the child one spot
	// 
	BOOL MoveUp(T t)
	{
		int nIndex = Find(t);
		T temp;

		if(nIndex == -1)
		{
			// the item "t" not found in the array
			return FALSE;
		}

		if (nIndex == 0)
		{
			// "t" is at the top of the array -- do nothing
			return TRUE;
		}
		
		//
		// exchange "t" and the one on top of "t".
		//
		temp = m_aT[nIndex-1];
		m_aT[nIndex-1] = m_aT[nIndex];
		m_aT[nIndex] = temp;

		m_aT[nIndex-1]->SetMerit(nIndex);
		m_aT[nIndex]->SetMerit(nIndex+1);

		return TRUE;
	}


	//
	// move down the child one spot
	//
	BOOL MoveDown(T t)
	{
		int nIndex = Find(t);
		T temp;

		if(nIndex == -1)
		{
			// the item "t" not found in the array
			return FALSE;
		}

		if (nIndex == m_nSize-1)
		{
			// "t" is at the bottom of the array -- do nothing
			return TRUE;
		}
		
		//
		// exchange "t" and the one below "t".
		//
		temp = m_aT[nIndex+1];
		m_aT[nIndex+1] = m_aT[nIndex];
		m_aT[nIndex] = temp;

		m_aT[nIndex+1]->SetMerit(nIndex+2);
		m_aT[nIndex]->SetMerit(nIndex+1);
		return TRUE;
	}



	T& operator[] (int nIndex) const
	{
		_ASSERTE(nIndex >= 0 && nIndex < m_nSize);
		return m_aT[nIndex];
	}

	T* GetData() const
	{
		return m_aT;
	}

    // 
    // insert the node at position nIndex
    // 
	void SetAtIndex(int nIndex, T& t)
	{
		_ASSERTE(nIndex >= 0 && nIndex < m_nSize);
		m_aT[nIndex] = t;

		if ( !t->GetMerit() )
		{
			// assign merit value only if it doesn't have one
			t->SetMerit(nIndex+1);
		}
	}

	int Find(T& t) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\matchcondedit.h ===
/****************************************************************************************
 * NAME:	MatchCondEdit.h
 *
 * CLASS:	CMatchCondEditor
 *
 * OVERVIEW
 *
 * Internet Authentication Server: NAP Condition Editing Dialog No.2
 *			This dialog box is used to add conditions that only has a single value
 *
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History:	
 *				1/28/98		Created by	Byao	(using ATL wizard)
 *
 *****************************************************************************************/

#ifndef __MatchCondEdit_H_
#define __MatchCondEdit_H_

#include "dialog.h"
#include "atltmp.h"


/////////////////////////////////////////////////////////////////////////////
// CMatchCondEditor
class CMatchCondEditor;
typedef CIASDialog<CMatchCondEditor, FALSE>  MATCHCONDEDITORFALSE;

class CMatchCondEditor : public CIASDialog<CMatchCondEditor, FALSE>
{
public:
	CMatchCondEditor();
	~CMatchCondEditor();

	enum { IDD = IDD_DIALOG_MATCH_COND};

BEGIN_MSG_MAP(CMatchCondEditor)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	COMMAND_CODE_HANDLER(EN_CHANGE, OnChange)
	CHAIN_MSG_MAP(MATCHCONDEDITORFALSE)
END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);


	LRESULT OnChange( 
		  UINT uMsg
		, WPARAM wParam
		, HWND hwnd
		, BOOL& bHandled
		);


public:
	ATL::CString m_strAttrName;		// condition attribute name
	ATL::CString m_strRegExp;		// condition regular expression
};

#endif //__MatchCondEditor_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\matchcondition.h ===
/****************************************************************************************
 * NAME:	MatchCondition.h
 *
 * CLASS:	CMatchCondition
 *
 * OVERVIEW
 *
 *				Match type condition
 *				
 *				ex:  MachineType  MATCH <a..z*>
 *
 *
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History:	
 *				1/28/98		Created by	Byao	(using ATL wizard)
 *
 *****************************************************************************************/

#if !defined(_MATCHCONDITION_H_INCLUDED_)
#define _MATCHCONDITION_H_INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "atltmp.h"


#include "Condition.h"

class CMatchCondition : public CCondition  
{
public:
	CMatchCondition(IIASAttributeInfo* pCondAttr, 
					ATL::CString &strConditionText
				   );
	CMatchCondition(IIASAttributeInfo* pCondAttr);
	virtual ~CMatchCondition();


	HRESULT Edit();
	virtual ATL::CString GetDisplayText();

protected:
	HRESULT ParseConditionText();
	BOOL	m_fParsed;		// whether this condition needs to be parsed first
	ATL::CString m_strRegExp;	// regular expression for this condition
};

#endif // !defined(_MATCHCONDITION_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\matchcondedit.cpp ===
/****************************************************************************************
 * NAME:   MatchCondEdit.cpp
 *
 * CLASS:   CMatchCondEditor
 *
 * OVERVIEW
 *
 * Internet Authentication Server:
 *         This dialog box is used to edit regular-expression
 *         typed Condition
 *
 *         ex.  attr Match <a..z*>
 *
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History:
 *            1/28/98      Created by   Byao   (using ATL wizard)
 *
 *****************************************************************************************/

#include "Precompiled.h"
#include "MatchCondEdit.h"

//+---------------------------------------------------------------------------
//
// Function:  CMatchCondEditor
//
// Class:     CMatchCondEditor
//
// Synopsis:  constructor for CMatchCondEditor
//
// Arguments: LPTSTR pszAttrName - name of the attribute to be edited
//
// Returns:   Nothing
//
// History:   Created byao 1/30/98 6:20:06 PM
//
//+---------------------------------------------------------------------------
CMatchCondEditor::CMatchCondEditor()
{

}

CMatchCondEditor::~CMatchCondEditor()
{

}

LRESULT CMatchCondEditor::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   TRACE_FUNCTION("CMatchCondEditor::OnInitDialog");

   // get the regular expression for this condition
   SetDlgItemText(IDC_EDIT_COND_TEXT, m_strRegExp);

   //todo: change the title to the name of the attribute
   SetWindowText(m_strAttrName);

   return 1;  // Let the system set the focus
}


LRESULT CMatchCondEditor::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
   TRACE_FUNCTION("CMatchCondEditor::OnOK");

   CComBSTR bstr;
   GetDlgItemText(IDC_EDIT_COND_TEXT, (BSTR&) bstr);

   m_strRegExp = bstr;
   m_strRegExp.TrimLeft();
   m_strRegExp.TrimRight();

   EndDialog(wID);
   return 0;
}

LRESULT CMatchCondEditor::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
   TRACE_FUNCTION("CMatchCondEditor::OnCancel");
   EndDialog(wID);
   return 0;
}




//////////////////////////////////////////////////////////////////////////////
/*++

CMatchCondEditor::OnChange

Called when the WM_COMMAND message is sent to our page with the
EN_CHANGE notification.

This is our chance to check to see what the user has touched
and enable or disabled the OK button.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CMatchCondEditor::OnChange(
                       UINT uMsg
                     , WPARAM wParam
                     , HWND hwnd
                     , BOOL& bHandled
                     )
{
   TRACE_FUNCTION("CMatchCondEditor::OnChange");


   // Check for preconditions:
   // None.


   // We don't want to prevent anyone else down the chain from receiving a message.
   bHandled = FALSE;

   CComBSTR bstr;

   GetDlgItemText(IDC_EDIT_COND_TEXT, (BSTR&) bstr);

   ATL::CString text(bstr);
   text.TrimLeft();
   text.TrimRight();

   // cancel if the user didn't type in anything
   if (text.IsEmpty())
   {
      // Disable the OK button.
      ::EnableWindow(GetDlgItem(IDOK), FALSE);
   }
   else
   {
      // Enable the OK button.
      ::EnableWindow(GetDlgItem(IDOK), TRUE);
   }

   return TRUE;   // ISSUE: what do we need to be returning here?
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\naphlp.cpp ===
//////////////////////////////////////////////////////////////////////////////
//  Copyright (C) Microsoft Corporation
//
//  File:       naphlp.cpp
//
//////////////////////////////////////////////////////////////////////////////

#include "Precompiled.h"

// For the Proxy defines
#include "proxyres.h"

#include "naphlp.h"
#include "hlptable.h"
#include "cnctdlg.cpp"
#include "dlgcshlp.cpp"

const CGlobalHelpTable __pGlobalCSHelpTable[] =
{
   DLG_HELP_ENTRY(IDD_COND_SELECT_ATTRIBUTE),
   DLG_HELP_ENTRY(IDD_DIALOG_DISPLAY_GROUPS),
   DLG_HELP_ENTRY(IDD_DIALOG_ENUM_COND),
   DLG_HELP_ENTRY(IDD_DIALOG_MATCH_COND),
   DLG_HELP_ENTRY(IDD_DIALOG_POLICY_LOCATION),
   DLG_HELP_ENTRY(IDD_IAS_ENUM_ATTR),
   DLG_HELP_ENTRY(IDD_IAS_IPADDR_ATTR),
   DLG_HELP_ENTRY(IDD_IAS_MULTIVALUED_EDITOR),
   DLG_HELP_ENTRY(IDD_IAS_SINGLE_ATTR),
   DLG_HELP_ENTRY(IDD_IAS_BOOLEAN_ATTR),
   DLG_HELP_ENTRY(IDD_IAS_IP_FILTER_ATTR),
   DLG_HELP_ENTRY(IDD_IAS_VENDORSPEC_ATTR),
   DLG_HELP_ENTRY(IDD_IAS_VENDORSPEC_ATTR_CONFORMS_NO),
   DLG_HELP_ENTRY(IDD_IAS_VENDORSPEC_ATTR_CONFORMS_YES),
   DLG_HELP_ENTRY(IDD_PROPPAGE_POLICY1),
   DLG_HELP_ENTRY(IDD_NEWRAPWIZ_WELCOME       ),
   DLG_HELP_ENTRY(IDD_NEWRAPWIZ_COMPLETION       ),
   DLG_HELP_ENTRY(IDD_NEWRAPWIZ_SCENARIO       ),
   DLG_HELP_ENTRY(IDD_NEWRAPWIZ_NAME),
   DLG_HELP_ENTRY(IDD_NEWRAPWIZ_AUTHENTICATION ),
   DLG_HELP_ENTRY(IDD_NEWRAPWIZ_ENCRYPTION     ),
   DLG_HELP_ENTRY(IDD_NEWRAPWIZ_EAP          ),
   DLG_HELP_ENTRY(IDD_NEWRAPWIZ_GROUP          ),
   DLG_HELP_ENTRY(IDD_NEWRAPWIZ_CONDITION),
   DLG_HELP_ENTRY(IDD_NEWRAPWIZ_ALLOWDENY),
   DLG_HELP_ENTRY(IDD_NEWRAPWIZ_EDITPROFILE),
   DLG_HELP_ENTRY(IDD_PROPPAGE_LOCAL_FILE_LOGGING1),
   DLG_HELP_ENTRY(IDD_PROPPAGE_LOCAL_FILE_LOGGING2),
   DLG_HELP_ENTRY(IDD_DB_PROPPAGE),
// Now For the Proxy
   DLG_HELP_ENTRY(IDD_SERVER_GROUP),
   DLG_HELP_ENTRY(IDD_SERVER_NAME),
   DLG_HELP_ENTRY(IDD_SERVER_AUTH),
   DLG_HELP_ENTRY(IDD_SERVER_FTLB),
   DLG_HELP_ENTRY(IDD_RESOLVE_SERVER_ADDRESS),
   DLG_HELP_ENTRY(IDD_RESOLVE_CLIENT_ADDRESS),
   DLG_HELP_ENTRY(IDD_PROXY_POLICY),
   DLG_HELP_ENTRY(IDD_PROXY_PROFILE_AUTH),
   DLG_HELP_ENTRY(IDD_PROXY_PROFILE_ACCT),
   DLG_HELP_ENTRY(IDD_PROXY_PROFILE_ATTR),
   DLG_HELP_ENTRY(IDD_EDIT_RULE),
   {0,0}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\nodetypeguids.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    NodeTypeGUIDs.h

Abstract:

	GUIDs we extend

Revision History:
	mmaguire 08/06/98 - created while extending RRAS

--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
//
// where we can find declaration for main class in this file:
//

//
// where we can find declarations needed in this file:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


// GUIDs for node types which we want to extend:

// Root node for Network Console.
extern const GUID NetworkConsoleGUID_ROOTNODETYPE;

// Machine node for Routing and Remote Access (RRAS).
extern const GUID RoutingAndRemoteAccessGUID_MACHINENODETYPE;

// Root node for Internet Authentication Service.
extern const GUID InternetAuthenticationServiceGUID_ROOTNODETYPE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\naputil.h ===
/****************************************************************************************
 * NAME:	NapUtil.h
 *
 * OVERVIEW
 *
 * Internet Authentication Server: utility functions
 *
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History:	
 *				2/12/98		Created by	Byao	
 *****************************************************************************************/

#ifndef _INCLUDE_NAPUTIL_
#define _INCLUDE_NAPUTIL_


HRESULT GetSdoInterfaceProperty(ISdo *pISdo, 
								LONG lPropId, 
								REFIID riid, 
								void ** ppvObject);


#endif	//_INCLUDE_NAPUTIL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\nodetypeguids.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    NodeTypeGUIDs.cpp

Abstract:

	Contains GUIDs and static member variable initializations

Revision History:
	mmaguire 11/6/97 - created using MMC snap-in wizard

--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for stuff in this file:
//
#include "NodeTypeGUIDs.h"
//
// where we can find declarations needed in this file:
//
#include "MachineNode.h"
#include "PoliciesNode.h"
#include "PolicyNode.h"
#include "LoggingMethodsNode.h"
#include "LocalFileLoggingNode.h"
#include "LogMacNd.h"

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


// GUIDs for node types that we extend:

// Root node for Network Console.
static const GUID NetworkConsoleGUID_ROOTNODETYPE=
{ 0xDA1BDD17,0x8E54, 0x11d1, { 0x93, 0xDB, 0x00,0xC0, 0x4F, 0xC3, 0x35, 0x7A } };

// Machine node for Routing and Remote Access RRAS.
static const GUID RoutingAndRemoteAccessGUID_MACHINENODETYPE = 
{ 0x276B4E81, 0xC7F7, 0x11D0, { 0xA3, 0x76, 0x00, 0xC0, 0x4F, 0xC9, 0xDA, 0x04 } };

// Root node for IAS.
static const GUID InternetAuthenticationServiceGUID_ROOTNODETYPE = 
 { 0x2bbe102, 0x6c29, 0x11d1, { 0x95, 0x63, 0x0, 0x60, 0xb0, 0x57, 0x66, 0x42 } };

//
// Machine Node:
//
const GUID*  CMachineNode::m_NODETYPE = &InternetAuthenticationServiceGUID_ROOTNODETYPE;
const TCHAR* CMachineNode::m_SZNODETYPE = _T("02BBE102-6C29-11d1-9563-0060B0576642");
//const TCHAR* CMachineNode::m_SZDISPLAY_NAME = _T("@Machine");
const CLSID* CMachineNode::m_SNAPIN_CLASSID = &CLSID_NAPSnapin;

//
// Policies Node
// {8683FE4A-D948-11d1-ABAE-00C04FC31527}
//
static const GUID CPoliciesNodeGUID_NODETYPE = 
{ 0x8683fe4a, 0xd948, 0x11d1, { 0xab, 0xae, 0x0, 0xc0, 0x4f, 0xc3, 0x15, 0x27 } };
const GUID*  CPoliciesNode::m_NODETYPE = &CPoliciesNodeGUID_NODETYPE;
const TCHAR* CPoliciesNode::m_SZNODETYPE = _T("8683FE4A-D948-11d1-ABAE-00C04FC31527");
//const TCHAR* CPoliciesNode::m_SZDISPLAY_NAME = _T("@Policies");
const CLSID* CPoliciesNode::m_SNAPIN_CLASSID = &CLSID_NAPSnapin;



// 
// Policy Node
// {8683FE4B-D948-11d1-ABAE-00C04FC31527}
//
static const GUID CPolicyNodeGUID_NODETYPE = 
{ 0x8683fe4b, 0xd948, 0x11d1, { 0xab, 0xae, 0x0, 0xc0, 0x4f, 0xc3, 0x15, 0x27 } };
const GUID*  CPolicyNode::m_NODETYPE = &CPolicyNodeGUID_NODETYPE;
const TCHAR* CPolicyNode::m_SZNODETYPE = _T("8683FE4B-D948-11d1-ABAE-00C04FC31527");
//const TCHAR* CPolicyNode::m_SZDISPLAY_NAME = _T("@Policy");
const CLSID* CPolicyNode::m_SNAPIN_CLASSID = &CLSID_NAPSnapin;

//
// Logging stuff
//
static const GUID CLoggingMethodsNodeGUID_NODETYPE = 
{ 0x9a82eb40, 0x75fa, 0x11d1, { 0x95, 0x66, 0x0, 0x60, 0xb0, 0x57, 0x66, 0x42 } };
const GUID*  CLoggingMethodsNode::m_NODETYPE = &CLoggingMethodsNodeGUID_NODETYPE;
const TCHAR* CLoggingMethodsNode::m_SZNODETYPE = _T("9A82EB40-75FA-11d1-9566-0060B0576642");
//const TCHAR* CLoggingMethodsNode::m_SZDISPLAY_NAME = _T("@LoggingMethods");
const CLSID* CLoggingMethodsNode::m_SNAPIN_CLASSID = &CLSID_LoggingSnapin;

static const GUID CLocalFileLoggingNodeGUID_NODETYPE = 
{ 0x9a82eb41, 0x75fa, 0x11d1, { 0x95, 0x66, 0x0, 0x60, 0xb0, 0x57, 0x66, 0x42 } };
const GUID*  CLocalFileLoggingNode::m_NODETYPE = &CLocalFileLoggingNodeGUID_NODETYPE;
const TCHAR* CLocalFileLoggingNode::m_SZNODETYPE = _T("9A82EB41-75FA-11d1-9566-0060B0576642");
//const TCHAR* CLocalFileLoggingNode::m_SZDISPLAY_NAME = _T("@LocalFileLogging");
const CLSID* CLocalFileLoggingNode::m_SNAPIN_CLASSID = &CLSID_LoggingSnapin;

//
// Logging Machine Node:
//
const GUID*  CLoggingMachineNode::m_NODETYPE = &InternetAuthenticationServiceGUID_ROOTNODETYPE;
const TCHAR* CLoggingMachineNode::m_SZNODETYPE = _T("02BBE102-6C29-11d1-9563-0060B0576642");
//const TCHAR* CLoggingMachineNode::m_SZDISPLAY_NAME = _T("@Machine");
const CLSID* CLoggingMachineNode::m_SNAPIN_CLASSID = &CLSID_LoggingSnapin;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\ntgcond.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ntgcond.cpp
//
//--------------------------------------------------------------------------

// NTGCond.cpp: implementation of the CNTGroupsCondition class.
//
//////////////////////////////////////////////////////////////////////

#include "precompiled.h"
#include "NTGCond.h"
#include "textsid.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CNTGroupsCondition::CNTGroupsCondition(IIASAttributeInfo*	pCondAttr,
									   ATL::CString&				strConditionText,
									   HWND					hWndParent,
									   LPTSTR				pszServerAddress
									  )
				   :CCondition(pCondAttr, strConditionText)
{
	m_fParsed		= FALSE; // parsing needed
	m_hWndParent	= hWndParent;
	m_pszServerAddress = pszServerAddress;
}

CNTGroupsCondition::CNTGroupsCondition(IIASAttributeInfo*	pCondAttr,
									   HWND					hWndParent,
									   LPTSTR				pszServerAddress
									 )
				   :CCondition(pCondAttr)

{
	m_fParsed		= TRUE; // no parsing needed
	m_hWndParent	= hWndParent;
	m_pszServerAddress = pszServerAddress;
}

CNTGroupsCondition::~CNTGroupsCondition()
{

}

//+---------------------------------------------------------------------------
//
// Function:  CNTGroupsCondition::Edit
//
// Synopsis:  call user/group picker to pick NT groups
//
// Arguments: None
//
// Returns:   HRESULT - 
//
// History:   Created Header    byao	2/23/98 3:45:35 AM
//
//+---------------------------------------------------------------------------
HRESULT CNTGroupsCondition::Edit()
{
	TRACE_FUNCTION("CNTGroupsCondition::Edit");	
	
	HRESULT hr = S_OK;


	CComPtr<IIASAttributeEditor> spIASGroupsAttributeEditor;

	hr = CoCreateInstance( CLSID_IASGroupsAttributeEditor, NULL, CLSCTX_INPROC_SERVER, IID_IIASAttributeEditor, (LPVOID *) &spIASGroupsAttributeEditor );
	if( FAILED( hr ) )
	{
		return hr;
	}
	if( ! spIASGroupsAttributeEditor )
	{
		return E_FAIL;
	}

	CComVariant varGroupsCondition;

	V_VT(&varGroupsCondition) = VT_BSTR;
	V_BSTR(&varGroupsCondition) = SysAllocString( (LPCTSTR) m_strConditionText );

	// We need to pass the machine name in somehow, so we use the 
	// otherwise unused BSTR * pReserved parameter of this method.
	CComBSTR bstrServerAddress = m_pszServerAddress;

	hr = spIASGroupsAttributeEditor->Edit( NULL, &varGroupsCondition, &bstrServerAddress );
	if( S_OK == hr )
	{

		// Some casting here to make sure that we do a deep copy.
		m_strConditionText = (LPCTSTR) V_BSTR(&varGroupsCondition);

		// Next time we are asked for display text, we want to make sure that we
		// get call the IASGroupsAttributeEditor again.
		m_fParsed = FALSE;
	}
	
	if( FAILED( hr ) )
	{
		ShowErrorDialog(NULL, 
						IDS_ERROR_OBJECT_PICKER,
						NULL, 
						hr
					);
	}

	return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  CNTGroupsCondition::GetDisplayText
//
// Synopsis:  get display text for NT groups
//
// Arguments: None
//
// Returns:   ATL::CString - display string
//
// History:   Created Header   byao	 2/23/98 3:47:52 AM
//
//+---------------------------------------------------------------------------
ATL::CString CNTGroupsCondition::GetDisplayText()
{
	TRACE_FUNCTION("CNTGroupsCondition::GetDisplayText");	

	ATL::CString strDispText;
	HRESULT	hr = S_OK;

	if ( !m_fParsed)
	{

		CComPtr<IIASAttributeEditor> spIASGroupsAttributeEditor;

		hr = CoCreateInstance( CLSID_IASGroupsAttributeEditor, NULL, CLSCTX_INPROC_SERVER, IID_IIASAttributeEditor, (LPVOID *) &spIASGroupsAttributeEditor );
		if ( FAILED(hr) || ! spIASGroupsAttributeEditor )
		{
			ErrorTrace(ERROR_NAPMMC_NTGCONDITION, "CoCreateInstance of Groups editor failed.");
			ShowErrorDialog(NULL, 
							IDS_ERROR_PARSE_CONDITION, 
							(LPTSTR)(LPCTSTR)m_strConditionText, 
							hr
						);
			strDispText = _T("");
			return strDispText;
		}

		CComVariant varGroupsCondition;

		V_VT(&varGroupsCondition) = VT_BSTR;
		V_BSTR(&varGroupsCondition) = SysAllocString( (LPCTSTR) m_strConditionText );

		CComBSTR bstrDisplay;
		CComBSTR bstrDummy;

		// We need to pass the machine name in somehow, so we use the 
		// otherwise unused BSTR * pReserved parameter of this method.
		CComBSTR bstrServerName = m_pszServerAddress;
	
		hr = spIASGroupsAttributeEditor->GetDisplayInfo( NULL, &varGroupsCondition, &bstrDummy, &bstrDisplay, &bstrServerName );
		if( SUCCEEDED(hr) )
		{
			m_strDisplayCondText = bstrDisplay;
		}
		
		
		if ( FAILED(hr) )
		{
			ErrorTrace(ERROR_NAPMMC_NTGCONDITION, "Invalid condition syntax");
			ShowErrorDialog(NULL, 
							IDS_ERROR_PARSE_CONDITION, 
							(LPTSTR)(LPCTSTR)m_strConditionText, 
							hr
						);
			strDispText = _T("");
			return strDispText;
		}



	}

	CComBSTR bstrName;
	hr = m_spAttributeInfo->get_AttributeName( &bstrName );
	_ASSERTE( SUCCEEDED( hr ) );
	strDispText = bstrName;

	{ ATL::CString	matches;
		matches.LoadString(IDS_TEXT_MATCHES);
		strDispText += matches;
	}

	strDispText += _T("\"");
	strDispText += m_strDisplayCondText;
	strDispText += _T("\"");

	DebugTrace(DEBUG_NAPMMC_NTGCONDITION, "GetDisplayText() returning %ws", strDispText);
	return strDispText;
}


//+---------------------------------------------------------------------------
//
// Function:  CNtGroupsCondition::GetConditionText
//
// Synopsis:  Get the condition text for this condition. 
//			  We just need to add the NTGroups prefix to it
//
// Arguments: None
//
// Returns:   WCHAR* - condition text
//
// History:   Created Header    byao	2/22/98 11:38:41 PM
//
//+---------------------------------------------------------------------------
WCHAR*	CNTGroupsCondition::GetConditionText()
{
	TRACE_FUNCTION("CNTGroupsCondition::GetConditionText");	

	WCHAR *pwzCondText;
	
	pwzCondText = new WCHAR[m_strConditionText.GetLength()+128];

	if (pwzCondText == NULL)
	{
		ErrorTrace(ERROR_NAPMMC_NTGCONDITION, "Error creating condition text, err = %x", GetLastError());
		ShowErrorDialog(NULL, IDS_ERROR_SDO_ERROR_GET_CONDTEXT );
		return NULL;
	}

	// now form the condition text
	wcscpy(pwzCondText, NTG_PREFIX);
	wcscat(pwzCondText, _T("(\"") );
	wcscat(pwzCondText, (LPCTSTR)m_strConditionText);
	wcscat(pwzCondText, _T("\")"));

	DebugTrace(DEBUG_NAPMMC_NTGCONDITION, "GetConditionText() returning %ws", pwzCondText);

	return pwzCondText;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\naputil.cpp ===
/****************************************************************************************
 * NAME:	NapUtil.cpp
 *
 * OVERVIEW
 *
 * Internet Authentication Server: utility functions
 *
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History:	
 *				2/12/98		Created by	Byao	
 *****************************************************************************************/

#include "Precompiled.h"
#include "mmcUtility.h"
#include "NapUtil.h"

//+---------------------------------------------------------------------------
//
// Function:  GetSdoInterfaceProperty
//
// Synopsis:  Get an interface property from a SDO through its ISdo interface
//
// Arguments: ISdo *pISdo - Pointer to ISdo
//            LONG lPropId - property id
//            REFIID riid - ref iid
//            void ** ppvObject - pointer to the requested interface property
//
// Returns:   HRESULT - 
//
// History:   Created Header    byao	2/12/98 11:12:55 PM
//
//+---------------------------------------------------------------------------
HRESULT GetSdoInterfaceProperty(ISdo *pISdo, 
								LONG lPropId, 
								REFIID riid, 
								void ** ppvInterface)
{
	CComVariant spVariant;
	CComBSTR	bstr;
	HRESULT		hr = S_OK;

	spVariant.vt = VT_DISPATCH;
	spVariant.pdispVal = NULL;
	hr = pISdo->GetProperty(lPropId, &spVariant);

	if ( FAILED(hr) ) 
	{
		ShowErrorDialog(NULL, IDS_ERROR_SDO_ERROR, NULL, hr );
		return hr;
	}

	_ASSERTE( spVariant.vt == VT_DISPATCH );

    // query the dispatch pointer for interface
	hr = spVariant.pdispVal->QueryInterface( riid, ppvInterface);
	if ( FAILED(hr) )
	{
		ShowErrorDialog(NULL,
						IDS_ERROR_SDO_ERROR_QUERYINTERFACE,
						NULL,
						hr
					);
		return hr;
	}

	
	spVariant.Clear();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\napmmcdll.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation

Module Name:

    NAPMMCDLL.cpp

Abstract:

   Implementation of DLL Exports.

--*/
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES


//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//

//
// where we can find declarations needed in this file:
//
#include "initguid.h"
#include "NAPMMC_i.c"

// For IComponent, IComponentData, and ISnapinAbout COM classes:

#include "Component.h"
#include "About.h"
#include "LogComp.h"
#include "LogAbout.H"

// For AttributeInfo COM classes:

#include "IASAttributeInfo.h"
#include "IASEnumerableAttributeInfo.h"

//
// Need to include this at least once to compile it in from the common directory:
#include "mmcutility.cpp"

// We are hosting a few extra COM objects in this dll:


// For AttributeEditor COM classes:
#include "IASIPAttributeEditor.h"
#include "IASMultivaluedAttributeEditor.h"
#include "IASVendorSpecificAttributeEditor.h"
#include "IASEnumerableAttributeEditor.h"
#include "IASStringAttributeEditor.h"
#include "IASBooleanAttributeEditor.h"
#include "iasipfilterattributeeditor.h"
#include "NTGroups.h"

// For NASVendors COM object:
#include "Vendors.h"

#include <proxyext.h>
#include <proxyres.h>
unsigned int CF_MMC_NodeID = RegisterClipboardFormatW(CCF_NODEID2);

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
   OBJECT_ENTRY(CLSID_NAPSnapin, CComponentData)
   OBJECT_ENTRY(CLSID_NAPSnapinAbout, CSnapinAbout)
   OBJECT_ENTRY(CLSID_LoggingSnapin, CLoggingComponentData)
   OBJECT_ENTRY(CLSID_LoggingSnapinAbout, CLoggingSnapinAbout)
   OBJECT_ENTRY(CLSID_IASAttributeInfo, CAttributeInfo)
   OBJECT_ENTRY(CLSID_IASEnumerableAttributeInfo, CEnumerableAttributeInfo)
   OBJECT_ENTRY(CLSID_IASIPAttributeEditor, CIASIPAttributeEditor)
   OBJECT_ENTRY(CLSID_IASMultivaluedAttributeEditor, CIASMultivaluedAttributeEditor)
   OBJECT_ENTRY(CLSID_IASVendorSpecificAttributeEditor, CIASVendorSpecificAttributeEditor)
   OBJECT_ENTRY(CLSID_IASEnumerableAttributeEditor, CIASEnumerableAttributeEditor)
   OBJECT_ENTRY(CLSID_IASStringAttributeEditor, CIASStringAttributeEditor)
   OBJECT_ENTRY(CLSID_IASBooleanAttributeEditor, CIASBooleanAttributeEditor)
   OBJECT_ENTRY(__uuidof(IASIPFilterAttributeEditor), CIASIPFilterAttributeEditor)
   OBJECT_ENTRY(CLSID_IASGroupsAttributeEditor, CIASGroupsAttributeEditor)
   OBJECT_ENTRY(CLSID_IASNASVendors, CIASNASVendors)
   OBJECT_ENTRY(__uuidof(ProxyExtension), ProxyExtension)
END_OBJECT_MAP()


#if 1  // Use CWinApp for MFC support -- some of the COM objects in this dll use MFC.


class CNAPMMCApp : public CWinApp
{
public:
   virtual BOOL InitInstance();
   virtual int ExitInstance();
};

CNAPMMCApp theApp;

//////////////////////////////////////////////////////////////////////////////
/*++

CNAPMMCApp::InitInstance

   MFC's dll entry point.
   
--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CNAPMMCApp::InitInstance()
{
   _Module.Init(ObjectMap, m_hInstance);
   
   // Initialize static class variables of CSnapInItem.
   CSnapInItem::Init();

   // Initialize any other static class variables.
   CMachineNode::InitClipboardFormat();
   CLoggingMachineNode::InitClipboardFormat();

   return CWinApp::InitInstance();
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNAPMMCApp::ExitInstance

   MFC's dll exit point.
   
--*/
//////////////////////////////////////////////////////////////////////////////
int CNAPMMCApp::ExitInstance()
{
   _Module.Term();

   return CWinApp::ExitInstance();
}

#else // Use CWinApp


//////////////////////////////////////////////////////////////////////////////
/*++

   DllMain


   Remarks
      
      DLL Entry Point

--*/
//////////////////////////////////////////////////////////////////////////////
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
      _Module.Init(ObjectMap, hInstance);
      // Initialize static class variables of CSnapInItem.
      CSnapInItem::Init();

      // Initialize any other static class variables.
      CMachineNode::InitClipboardFormat();

      DisableThreadLibraryCalls(hInstance);
   }
   else if (dwReason == DLL_PROCESS_DETACH)
      _Module.Term();
   return TRUE;    // ok
   }

#endif // Use CWinApp


//////////////////////////////////////////////////////////////////////////////
/*++

   DllCanUnloadNow


   Remarks
      
      Used to determine whether the DLL can be unloaded by OLE

--*/
//////////////////////////////////////////////////////////////////////////////
STDAPI DllCanUnloadNow(void)
{
   return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

   DllGetClassObject


   Remarks
      
      Returns a class factory to create an object of the requested type

--*/
//////////////////////////////////////////////////////////////////////////////
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
   return _Module.GetClassObject(rclsid, riid, ppv);
}


//////////////////////////////////////////////////////////////////////////////
/*++

   DllRegisterServer


   Remarks
      
        Adds entries to the system registry

--*/
//////////////////////////////////////////////////////////////////////////////

STDAPI DllRegisterServer(void)
{
   // Set the protocol.
   TCHAR NapName[IAS_MAX_STRING];
   TCHAR NapName_Indirect[IAS_MAX_STRING];
   TCHAR ModuleName[MAX_PATH];
   TCHAR LoggingName[IAS_MAX_STRING];
   TCHAR LoggingName_Indirect[IAS_MAX_STRING];

   if (!GetModuleFileNameOnly(_Module.GetModuleInstance(), ModuleName, MAX_PATH))
   {
      return E_FAIL;
   }
   
   int iLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_SNAPINNAME_NAP, NapName, IAS_MAX_STRING );
   swprintf(NapName_Indirect, L"@%s,-%-d", ModuleName, IDS_SNAPINNAME_NAP);

   iLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_SNAPINNAME_LOGGING, LoggingName, IAS_MAX_STRING );
   swprintf(LoggingName_Indirect, L"@%s,-%-d", ModuleName, IDS_SNAPINNAME_LOGGING);

    struct _ATL_REGMAP_ENTRY regMap[] = {
        {OLESTR("NAPSNAPIN"), NapName}, // subsitute %NAPSNAPIN% for registry
        {OLESTR("NAPSNAPIN_INDIRECT"), NapName_Indirect}, // subsitute %IASSNAPIN% for registry
        {OLESTR("LOGGINGSNAPIN"), LoggingName}, // subsitute %LOGGINGSNAPIN% for registry
        {OLESTR("LOGGINGSNAPIN_INDIRECT"), LoggingName_Indirect}, // subsitute %IASSNAPIN% for registry
        {0, 0}
    };

   HRESULT hr = _Module.UpdateRegistryFromResource(IDR_NAPSNAPIN, TRUE, regMap);
   if (SUCCEEDED(hr))
   {
      ResourceString proxyName(IDS_PROXY_EXTENSION);
      _ATL_REGMAP_ENTRY entries[] =
      {
         { L"PROXY_EXTENSION", proxyName },
         { NULL, NULL }
      };

      hr = _Module.UpdateRegistryFromResource(
                       IDR_PROXY_REGISTRY,
                       TRUE,
                       entries
                       );
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

   DllUnregisterServer

   Remarks
      
      Removes entries from the system registry

--*/
//////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer(void)
{
   // Set the protocol.
   TCHAR NapName[IAS_MAX_STRING];
   TCHAR LoggingName[IAS_MAX_STRING];
   int iLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_SNAPINNAME_NAP, NapName, IAS_MAX_STRING );
   iLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_SNAPINNAME_LOGGING, LoggingName, IAS_MAX_STRING );

    struct _ATL_REGMAP_ENTRY regMap[] = {
        {OLESTR("NAPSNAPIN"), NapName}, // subsitute %NAPSNAPIN% for registry
        {OLESTR("LOGGINGSNAPIN"), LoggingName}, // subsitute %LOGGINGSNAPIN% for registry
        {0, 0}
    };

   _Module.UpdateRegistryFromResource(IDR_NAPSNAPIN, FALSE, regMap);
   _Module.UpdateRegistryFromResource(IDR_PROXY_REGISTRY, FALSE, NULL);

   return S_OK;
}


#include "resolver.h"
#define NAPMMCAPI
#include "VerifyAddress.h"

HRESULT
WINAPI
IASVerifyClientAddress(
   const wchar_t* address,
   BSTR* result
   )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   *result = 0;

   HRESULT hr;
   try
   {
      ClientResolver resolver(address);
      if (resolver.DoModal() == IDOK)
      {
         *result = SysAllocString(resolver.getChoice());
         if (*result != 0)
         {
            hr = S_OK;
         }
         else
         {
            hr = E_OUTOFMEMORY;
         }
      }
      else
      {
         hr = S_FALSE;
      }
   }
   catch (CException* e)
   {
      e->Delete();
      hr = DISP_E_EXCEPTION;
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\naphlp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       naphlp.h
//
//--------------------------------------------------------------------------
//
// Created by Melissa Simmons
// Used by napmmc.rc

#define  IDH_BUTTON_ADD_CONDITION   800020001
#define  IDH_BUTTON_ADD_GROUP 800020026
#define  IDH_BUTTON_CONDITION_ADD   800020352
#define  IDH_BUTTON_CONDITION_EDIT  800020354
#define  IDH_BUTTON_CONDITION_REMOVE   800020353
#define  IDH_BUTTON_EDITPROFILE  800020357
#define  IDH_BUTTON_ENUMCOND_ADD 800020051
#define  IDH_BUTTON_ENUMCOND_DELETE 800020052
#define  IDH_BUTTON_REMOVE_GROUP 800020027
#define  IDH_EDIT_COND_TEXT   800020075
#define  IDH_EDIT_POLICYNAME  800020350
#define  IDH_EDIT_VENDORID 800020229
#define  IDH_IAS_BUTTON_ADD_VALUE   800020181
#define  IDH_IAS_BUTTON_CONFIGURE   800020232
#define  IDH_IAS_BUTTON_EDIT  800020183
#define  IDH_IAS_BUTTON_MOVE_DOWN   800020180
#define  IDH_IAS_BUTTON_MOVE_UP  800020179
#define  IDH_IAS_BUTTON_REMOVE   800020182
#define  IDH_IAS_COMBO_ENUM_VALUES  800020128
#define  IDH_IAS_COMBO_VENDORID  800020227
#define  IDH_IAS_COMBO_VENDORSPEC_FORMAT  800020276
#define  IDH_IAS_EDIT_ATTRVALUE  800020205
#define  IDH_IAS_EDIT_IPADDR  800020153
#define  IDH_IAS_EDIT_MULTI_ATTR_FORMAT   800020177
#define  IDH_IAS_EDIT_MULTI_ATTR_NAME  800020175
#define  IDH_IAS_EDIT_MULTI_ATTR_NUMBER   800020176
#define  IDH_IAS_EDIT_VENDORSPEC_TYPE  800020275
#define  IDH_IAS_EDIT_VENDORSPEC_VALUE 800020250
#define  IDH_IAS_LIST_MULTI_ATTRS   800020178
#define  IDH_IAS_NO_RADIO_HEX 800020231
#define  IDH_IAS_RADIO_HEX 800020204
#define  IDH_IAS_RADIO_RADIUS 800020230
#define  IDH_IAS_RADIO_STRING 800020203
#define  IDH_IAS_STATIC_ATTRFORMAT  800020127
#define  IDH_IAS_STATIC_ATTRNAME 800020125
#define  IDH_IAS_STATIC_ATTRTYPE 800020126
#define  IDH_LIST_COND_SELATTR   800020000
#define  IDH_LIST_CONDITIONS  800020351
#define  IDH_LIST_ENUMCOND_CHOICE   800020050
#define  IDH_LIST_ENUMCOND_SELECTION   800020053
#define  IDH_LIST_GROUPS   800020025
#define  IDH_RADIO_DENY_DIALIN   800020356
#define  IDH_RADIO_ENTERVERDORID 800020228
#define  IDH_RADIO_GRANT_DIALIN  800020355
#define  IDH_RADIO_SELECTFROMLIST   800020226
#define  IDH_RADIO_STORE_ACTIVEDS   800020100
#define  IDH_RADIO_STORE_LOCAL   800020101
#define  IDH_IAS_STATIC_ATTR_VALUE    800020233

#define  IDH_BUTTON_LOCAL_FILE_LOGGING_PAGE2__BROWSE  800010134
#define  IDH_CHECK_LOCAL_FILE_LOGING_PAGE1__ACCOUNTING   800010100
#define  IDH_CHECK_LOCAL_FILE_LOGING_PAGE1__AUTHENTICATION  800010101
#define  IDH_CHECK_LOCAL_FILE_LOGING_PAGE1__INTERIM_ACCT 800010102
#define  IDH_EDIT_LOCAL_FILE_LOGGING_PAGE2__DIRECTORY 800010133
#define  IDH_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE   800010132
#define  IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY 800010127
#define  IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_IAS1 800010126
#define  IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_ODBC 800010125
#define  IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__LOG_LIMIT   800010131
#define  IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY  800010129
#define  IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__UNLIMITED   800010130
#define  IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY   800010128
#define  IDH_CHECK_DELETE_IF_FULL 800010135

#define  IDH_STATIC_SPECIFY_NAS_VENDOR 900000000
#define  IDH_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_NAME 900000001
#define  IDH_TXT_ATTRIBUTEVALUE     900000002
#define  IDH_TXT_CHOOSEFORMAT    900000003

// help IDs for IDD_NEWRAPWIZ_NAME
#define IDH_NEWRAPWIZ_NAME_POLICYNAME  900000004
#define IDH_NEWRAPWIZ_NAME_SCENARIO    900000005
#define IDH_NEWRAPWIZ_NAME_MANUAL      900000006

// help IDs for IDD_NEWRAPWIZ_GROUP
#define IDH_NEWRAPWIZ_GROUP_REMOVEGROUP 900001020
#define IDH_NEWRAPWIZ_GROUP_USER        900001021
#define IDH_NEWRAPWIZ_GROUP_GROUP       900001022
#define IDH_NEWRAPWIZ_GROUP_ADDGROUP    900001023
#define IDH_NEWRAPWIZ_GROUP_GROUPS      900001024

// help IDs for IDD_NEWRAPWIZ_AUTHENTICATION
#define IDH_NEWRAPWIZ_AUTH_EAP          900001040
#define IDH_NEWRAPWIZ_AUTH_EAP_COMBO    900001041
#define IDH_NEWRAPWIZ_AUTH_CONFIGEAP    900001042
#define IDH_NEWRAPWIZ_AUTH_MSCHAP2      900001043
#define IDH_NEWRAPWIZ_AUTH_MSCHAP       900001044

// help IDs for IDD_NEWRAPWIZ_ENCRYPTION
#define IDH_NEWRAPWIZ_ENCRY_NO          900001061
#define IDH_NEWRAPWIZ_ENCRY_BASIC       900001062
#define IDH_NEWRAPWIZ_ENCRY_STRONG      900001063
#define IDH_NEWRAPWIZ_ENCRY_STRONGEST   900001064
#define  IDH_NEWRAPWIZ_ENCRY_NO_STATIC 900001065

// help IDs for IDD_NEWRAPWIZ_SCENARIO
#define IDH_NEWRAPWIZ_SCENARIO_DIALUP   900001080
#define IDH_NEWRAPWIZ_SCENARIO_VPN      900001081
#define IDH_NEWRAPWIZ_SCENARIO_WIRELESS 900001082
#define IDH_NEWRAPWIZ_SCENARIO_SWITCH   900001083

// help IDs for IDD_IAS_BOOLEAN_ATTR
#define IDH_TXT_PROF_ATTR_SELECT_VALUE 800020090
#define IDH_RADIO_PROF_ATTR_TRUE       800020091
#define IDH_RADIO_PROF_ATTR_FALSE      800020092

// help IDs for IDD_IAS_IP_FILTER_ATTR
#define IDH_BUTTON_FROMCLIENT           800020300
#define IDH_BUTTON_TOCLIENT             800020301
#define IDH_TXT_PROF_ATTR_INPUT_FILTER  800020302
#define IDH_TXT_PROF_ATTR_OUTPUT_FILTER 800020303

const DWORD g_aHelpIDs_IDD_COND_SELECT_ATTRIBUTE[]=
{
   IDC_LIST_COND_SELATTR,IDH_LIST_COND_SELATTR,
   IDC_BUTTON_ADD_CONDITION,IDH_BUTTON_ADD_CONDITION,
   0,0
};

const DWORD g_aHelpIDs_IDD_DIALOG_DISPLAY_GROUPS[]=
{
   IDC_LIST_GROUPS,IDH_LIST_GROUPS,
   IDC_BUTTON_ADD_GROUP,IDH_BUTTON_ADD_GROUP,
   IDC_BUTTON_REMOVE_GROUP,IDH_BUTTON_REMOVE_GROUP,
   0,0
};

const DWORD g_aHelpIDs_IDD_DIALOG_ENUM_COND[]=
{
   IDC_LIST_ENUMCOND_CHOICE,IDH_LIST_ENUMCOND_CHOICE,
   IDC_BUTTON_ENUMCOND_ADD,IDH_BUTTON_ENUMCOND_ADD,
   IDC_BUTTON_ENUMCOND_DELETE,IDH_BUTTON_ENUMCOND_DELETE,
   IDC_LIST_ENUMCOND_SELECTION,IDH_LIST_ENUMCOND_SELECTION,
   0,0
};

const DWORD g_aHelpIDs_IDD_DIALOG_MATCH_COND[]=
{
   IDC_EDIT_COND_TEXT,IDH_EDIT_COND_TEXT,
   0,0
};

const DWORD g_aHelpIDs_IDD_DIALOG_POLICY_LOCATION[]=
{
   IDC_RADIO_STORE_ACTIVEDS,IDH_RADIO_STORE_ACTIVEDS,
   IDC_RADIO_STORE_LOCAL,IDH_RADIO_STORE_LOCAL,
   0,0
};


const DWORD g_aHelpIDs_IDD_IAS_ENUM_ATTR[]=
{
   IDC_IAS_STATIC_ATTRNAME,IDH_IAS_STATIC_ATTRNAME,
   IDC_IAS_STATIC_ATTRTYPE,IDH_IAS_STATIC_ATTRTYPE,
   IDC_IAS_STATIC_ATTRFORMAT,IDH_IAS_STATIC_ATTRFORMAT,
   IDC_IAS_COMBO_ENUM_VALUES,IDH_IAS_COMBO_ENUM_VALUES,
   0,0
};


const DWORD g_aHelpIDs_IDD_IAS_IPADDR_ATTR[]=
{
   IDC_IAS_STATIC_ATTRNAME,IDH_IAS_STATIC_ATTRNAME,
   IDC_IAS_STATIC_ATTRTYPE,IDH_IAS_STATIC_ATTRTYPE,
   IDC_IAS_STATIC_ATTRFORMAT,IDH_IAS_STATIC_ATTRFORMAT,
   IDC_IAS_EDIT_IPADDR,IDH_IAS_EDIT_IPADDR,
   0,0
};

const DWORD g_aHelpIDs_IDD_IAS_MULTIVALUED_EDITOR[]=
{
   IDC_IAS_EDIT_MULTI_ATTR_NAME,IDH_IAS_EDIT_MULTI_ATTR_NAME,
   IDC_IAS_EDIT_MULTI_ATTR_NUMBER,IDH_IAS_EDIT_MULTI_ATTR_NUMBER,
   IDC_IAS_EDIT_MULTI_ATTR_FORMAT,IDH_IAS_EDIT_MULTI_ATTR_FORMAT,
   IDC_IAS_LIST_MULTI_ATTRS,IDH_IAS_LIST_MULTI_ATTRS,
   IDC_IAS_BUTTON_MOVE_UP,IDH_IAS_BUTTON_MOVE_UP,
   IDC_IAS_BUTTON_MOVE_DOWN,IDH_IAS_BUTTON_MOVE_DOWN,
   IDC_IAS_BUTTON_ADD_VALUE,IDH_IAS_BUTTON_ADD_VALUE,
   IDC_IAS_BUTTON_REMOVE,IDH_IAS_BUTTON_REMOVE,
   IDC_IAS_BUTTON_EDIT,IDH_IAS_BUTTON_EDIT,
   0,0
};

const DWORD g_aHelpIDs_IDD_IAS_SINGLE_ATTR[]=
{
   IDC_TXT_ATTRIBUTEVALUE, IDH_TXT_ATTRIBUTEVALUE,
   IDC_TXT_CHOOSEFORMAT, IDH_TXT_CHOOSEFORMAT,
   IDC_IAS_STATIC_ATTRNAME,IDH_IAS_STATIC_ATTRNAME,
   IDC_IAS_STATIC_ATTRTYPE,IDH_IAS_STATIC_ATTRTYPE,
   IDC_IAS_STATIC_ATTRFORMAT,IDH_IAS_STATIC_ATTRFORMAT,
   IDC_RADIO_STRING,IDH_IAS_RADIO_STRING,
   IDC_RADIO_HEX,IDH_IAS_RADIO_HEX,
   IDC_IAS_EDIT_ATTRVALUE,IDH_IAS_EDIT_ATTRVALUE,
   0,0
};

const DWORD g_aHelpIDs_IDD_IAS_BOOLEAN_ATTR[]=
{
   IDC_TXT_ATTRIBUTEVALUE, IDH_TXT_ATTRIBUTEVALUE,
   IDC_IAS_STATIC_ATTRNAME,IDH_IAS_STATIC_ATTRNAME,
   IDC_IAS_STATIC_ATTRTYPE,IDH_IAS_STATIC_ATTRTYPE,
   IDC_IAS_STATIC_ATTRFORMAT,IDH_IAS_STATIC_ATTRFORMAT,
   IDC_TXT_SELECT_VALUE,IDH_TXT_PROF_ATTR_SELECT_VALUE,
   IDC_RADIO_TRUE,IDH_RADIO_PROF_ATTR_TRUE,
   IDC_RADIO_FALSE,IDH_RADIO_PROF_ATTR_FALSE,
   0,0
};

const DWORD g_aHelpIDs_IDD_IAS_IP_FILTER_ATTR[]=
{
   IDC_IAS_STATIC_ATTRNAME, IDH_IAS_STATIC_ATTRNAME,
   IDC_IAS_STATIC_ATTRTYPE, IDH_IAS_STATIC_ATTRTYPE,
   IDC_BUTTON_FROMCLIENT, IDH_BUTTON_FROMCLIENT,
   IDC_BUTTON_TOCLIENT, IDH_BUTTON_TOCLIENT,
   IDC_TXT_PROF_ATTR_INPUT_FILTER, IDH_TXT_PROF_ATTR_INPUT_FILTER,
   IDC_TXT_PROF_ATTR_OUTPUT_FILTER, IDH_TXT_PROF_ATTR_OUTPUT_FILTER,
   0,0
};

const DWORD g_aHelpIDs_IDD_IAS_VENDORSPEC_ATTR[]=
{
   IDC_IAS_STATIC_ATTRNAME,IDH_IAS_STATIC_ATTRNAME,
   IDC_RADIO_SELECTFROMLIST,IDH_RADIO_SELECTFROMLIST,
   IDC_IAS_COMBO_VENDORID,IDH_IAS_COMBO_VENDORID,
   IDC_RADIO_ENTERVERDORID,IDH_RADIO_ENTERVERDORID,
   IDC_EDIT_VENDORID,IDH_EDIT_VENDORID,
   IDC_STATIC_SPECIFY_NAS_VENDOR, IDH_STATIC_SPECIFY_NAS_VENDOR,
   IDC_IAS_RADIO_RADIUS,IDH_IAS_RADIO_RADIUS,
   IDC_IAS_RADIO_HEX,IDH_IAS_NO_RADIO_HEX,
   IDC_IAS_BUTTON_CONFIGURE,IDH_IAS_BUTTON_CONFIGURE,
   IDC_IAS_STATIC_ATTR_VALUE, IDH_IAS_STATIC_ATTR_VALUE,
   0,0
};


const DWORD g_aHelpIDs_IDD_IAS_VENDORSPEC_ATTR_CONFORMS_NO[]=
{
   IDC_IAS_EDIT_VENDORSPEC_VALUE,IDH_IAS_EDIT_VENDORSPEC_VALUE,
   0,0
};

const DWORD g_aHelpIDs_IDD_IAS_VENDORSPEC_ATTR_CONFORMS_YES[]=
{
   IDC_IAS_EDIT_VENDORSPEC_TYPE,IDH_IAS_EDIT_VENDORSPEC_TYPE,
   IDC_IAS_COMBO_VENDORSPEC_FORMAT,IDH_IAS_COMBO_VENDORSPEC_FORMAT,
   IDC_IAS_EDIT_VENDORSPEC_VALUE,IDH_IAS_EDIT_VENDORSPEC_VALUE,
   0,0
};

const DWORD g_aHelpIDs_IDD_PROPPAGE_POLICY1[]=
{
   IDC_LIST_CONDITIONS,IDH_LIST_CONDITIONS,
   IDC_BUTTON_CONDITION_ADD,IDH_BUTTON_CONDITION_ADD,
   IDC_BUTTON_CONDITION_REMOVE,IDH_BUTTON_CONDITION_REMOVE,
   IDC_BUTTON_CONDITION_EDIT,IDH_BUTTON_CONDITION_EDIT,
   IDC_RADIO_GRANT_DIALIN,IDH_RADIO_GRANT_DIALIN,
   IDC_RADIO_DENY_DIALIN,IDH_RADIO_DENY_DIALIN,
   IDC_BUTTON_EDITPROFILE,IDH_BUTTON_EDITPROFILE,
   0,0
};


const DWORD g_aHelpIDs_IDD_NEWRAPWIZ_WELCOME[]=
{
   0,0
};

const DWORD g_aHelpIDs_IDD_NEWRAPWIZ_COMPLETION[]=
{
   0,0
};

const DWORD g_aHelpIDs_IDD_NEWRAPWIZ_NAME[]=
{
   IDC_NEWRAPWIZ_NAME_POLICYNAME,   IDH_NEWRAPWIZ_NAME_POLICYNAME,
   IDC_NEWRAPWIZ_NAME_SCENARIO,     IDH_NEWRAPWIZ_NAME_SCENARIO  ,
   IDC_NEWRAPWIZ_NAME_MANUAL,       IDH_NEWRAPWIZ_NAME_MANUAL   ,
   0,0
};

const DWORD g_aHelpIDs_IDD_NEWRAPWIZ_SCENARIO[]=
{
   IDC_NEWRAPWIZ_SCENARIO_DIALUP,      IDH_NEWRAPWIZ_SCENARIO_DIALUP,
   IDC_NEWRAPWIZ_SCENARIO_VPN,        IDH_NEWRAPWIZ_SCENARIO_VPN,
   IDC_NEWRAPWIZ_SCENARIO_WIRELESS, IDH_NEWRAPWIZ_SCENARIO_WIRELESS,
   IDC_NEWRAPWIZ_SCENARIO_SWITCH,     IDH_NEWRAPWIZ_SCENARIO_SWITCH,
   0,0
};

const DWORD g_aHelpIDs_IDD_NEWRAPWIZ_GROUP[]=
{
   IDC_NEWRAPWIZ_GROUP_REMOVEGROUP,    IDH_NEWRAPWIZ_GROUP_REMOVEGROUP,
   IDC_NEWRAPWIZ_GROUP_USER,         IDH_NEWRAPWIZ_GROUP_USER,
   IDC_NEWRAPWIZ_GROUP_GROUP,       IDH_NEWRAPWIZ_GROUP_GROUP,
   IDC_NEWRAPWIZ_GROUP_ADDGROUP,    IDH_NEWRAPWIZ_GROUP_ADDGROUP,
   IDC_NEWRAPWIZ_GROUP_GROUPS,        IDH_NEWRAPWIZ_GROUP_GROUPS,
   0,0
};

const DWORD g_aHelpIDs_IDD_NEWRAPWIZ_AUTHENTICATION[]=
{
   IDC_NEWRAPWIZ_AUTH_EAP        ,IDH_NEWRAPWIZ_AUTH_EAP        ,
   IDC_NEWRAPWIZ_AUTH_EAP_COMBO  ,IDH_NEWRAPWIZ_AUTH_EAP_COMBO  ,
   IDC_NEWRAPWIZ_AUTH_CONFIGEAP  ,IDH_NEWRAPWIZ_AUTH_CONFIGEAP  ,
   IDC_NEWRAPWIZ_AUTH_MSCHAP2    ,IDH_NEWRAPWIZ_AUTH_MSCHAP2    ,
   IDC_NEWRAPWIZ_AUTH_MSCHAP     ,IDH_NEWRAPWIZ_AUTH_MSCHAP     ,
   0,0
};

const DWORD* g_aHelpIDs_IDD_NEWRAPWIZ_EAP = g_aHelpIDs_IDD_NEWRAPWIZ_AUTHENTICATION;

const DWORD g_aHelpIDs_IDD_NEWRAPWIZ_ENCRYPTION[]=
{
   IDC_NEWRAPWIZ_ENCRY_NO       ,IDH_NEWRAPWIZ_ENCRY_NO       ,
   IDC_NEWRAPWIZ_ENCRY_BASIC    ,IDH_NEWRAPWIZ_ENCRY_BASIC    ,
   IDC_NEWRAPWIZ_ENCRY_STRONG   ,IDH_NEWRAPWIZ_ENCRY_STRONG   ,
   IDC_NEWRAPWIZ_ENCRY_STRONGEST,IDH_NEWRAPWIZ_ENCRY_STRONGEST,
   0,0
};


const DWORD g_aHelpIDs_IDD_NEWRAPWIZ_CONDITION[]=
{
   IDC_LIST_CONDITIONS,IDH_LIST_CONDITIONS,
   IDC_BUTTON_CONDITION_ADD,IDH_BUTTON_CONDITION_ADD,
   IDC_BUTTON_CONDITION_REMOVE,IDH_BUTTON_CONDITION_REMOVE,
   IDC_BUTTON_CONDITION_EDIT,IDH_BUTTON_CONDITION_EDIT,
   0,0
};

const DWORD g_aHelpIDs_IDD_NEWRAPWIZ_ALLOWDENY[]=
{
   IDC_RADIO_GRANT_DIALIN,IDH_RADIO_GRANT_DIALIN,
   IDC_RADIO_DENY_DIALIN,IDH_RADIO_DENY_DIALIN,
   0,0
};


const DWORD g_aHelpIDs_IDD_NEWRAPWIZ_EDITPROFILE[]=
{
   IDC_BUTTON_EDITPROFILE,IDH_BUTTON_EDITPROFILE,
   0,0
};

//These are the same as IAShlp.h

const DWORD g_aHelpIDs_IDD_PROPPAGE_LOCAL_FILE_LOGGING1[]=
{
   IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_ACCOUNTING_PACKETS,IDH_CHECK_LOCAL_FILE_LOGING_PAGE1__ACCOUNTING,
   IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_AUTHENTICATION_PACKETS,IDH_CHECK_LOCAL_FILE_LOGING_PAGE1__AUTHENTICATION,
   IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_INTERIM_ACCOUNTING_PACKETS,IDH_CHECK_LOCAL_FILE_LOGING_PAGE1__INTERIM_ACCT,
   0,0
};

const DWORD g_aHelpIDs_IDD_PROPPAGE_LOCAL_FILE_LOGGING2[]=
{
   IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_ODBC,IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_ODBC,
   IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_IAS1,IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_IAS1,
   IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY,IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY,
   IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY,IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY,
   IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY,IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY,
   IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__UNLIMITED,IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__UNLIMITED,
   IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES,IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__LOG_LIMIT,
   IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE,IDH_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE,
   IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE_UNITS,IDH_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE,
   IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_DIRECTORY,IDH_EDIT_LOCAL_FILE_LOGGING_PAGE2__DIRECTORY,
   IDC_BUTTON_LOCAL_FILE_LOGGING_PAGE2__BROWSE,IDH_BUTTON_LOCAL_FILE_LOGGING_PAGE2__BROWSE,
   IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_NAME , IDH_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_NAME  ,
   IDC_CHECK_DELETE_IF_FULL, IDH_CHECK_DELETE_IF_FULL,
   0,0
};

///////////////////////////////////////////////////////////////////////////////
// Now for the Proxy pages
///////////////////////////////////////////////////////////////////////////////
//#define IDH_BUTTON_ADD_CLIENT__CONFIGURE_CLIENT   800010052
//#define IDH_BUTTON_CLIENT_PAGE1__FIND 800010077
//#define IDH_CHECK_CLIENT_PAGE1__CLIENT_ALWAYS  800010079
//#define IDH_COMBO_ADD_CLIENT__PROTOCOL   800010051
//#define IDH_COMBO_CLIENT_PAGE1__MANUFACTURER   800010078
//#define IDH_EDIT_ADD_CLIENT__NAME  800010050
//#define IDH_EDIT_CLIENT_PAGE1__ADDRESS   800010076
//#define IDH_EDIT_CLIENT_PAGE1__NAME   800010075
//#define IDH_EDIT_CLIENT_PAGE1__SHARED_SECRET   800010080
//#define IDH_EDIT_CLIENT_PAGE1__SHARED_SECRET_CONFIRM 800010081

//#define IDH_BUTTON_RESOLVE_DNS_NAME__USE_THIS_IP 900000000

//#define IDH_BUTTON_REALMS_ADD   800010003
//#define IDH_BUTTON_REALMS_EDIT  800010005
//#define IDH_BUTTON_REALMS_MOVE_DOWN   800010002
//#define IDH_BUTTON_REALMS_MOVE_UP  800010001
//#define IDH_BUTTON_REALMS_REMOVE   800010004
//#define IDH_LIST_REALMS_REPLACEMENTS  800010000

//#define IDH_CHECK_SERVER_PAGE1__CAPTURE_DEBUG_PACKETS   800010152
//#define IDH_CHECK_SERVER_PAGE1__CAPTURE_MALFORMED_PACKETS  800010151
//#define IDH_EDIT_SERVER_PAGE1__NAME   800010150
//#define IDH_EDIT_SERVER_PAGE2_ACCOUNTING_PORT  800010176
//#define IDH_EDIT_SERVER_PAGE2_AUTHENTICATION_PORT 800010175

//#define IDH_EDIT_STARTUP_WIZARD_CONNECT__COMPUTER_NAME  800010277
//#define IDH_RADIO_STARTUP_WIZARD_CONNECT__ANOTHER_COMPUTER 800010276
//#define IDH_RADIO_STARTUP_WIZARD_CONNECT__LOCAL_COMPUTER   800010275

/////////
// Attribute manipulation rule
/////////
// Adv tab.
#define IDH_LIST_PROF_ATTR_ADVLIST  800020022
#define IDH_BUTTON_PROF_ADV_ADD     800020023
#define IDH_BUTTON_PROF_ADV_EDIT    800020024
#define IDH_BUTTON_PROF_ADV_REMOVE  800020046


///////////////////////////////////////////////////////////////////////////////
// RADIUS Server Group properties
///////////////////////////////////////////////////////////////////////////////
#define IDH_EDIT_RSG_PROP_GROUPNAME 800020047
#define IDH_LIST_RSG_PROP_GROUPMEM  800020048
#define IDH_BUTTON_RSG_PROP_ADD     800020028
#define IDH_BUTTON_RSG_PROP_REMOVE  800020029
#define IDH_BUTTON_RSG_PROP_PROP    800020030

const  DWORD g_aHelpIDs_IDD_SERVER_GROUP[]=
{
   IDC_EDIT_NAME,     IDH_EDIT_RSG_PROP_GROUPNAME,
   IDC_LIST_SERVERS,  IDH_LIST_RSG_PROP_GROUPMEM,
   IDC_BUTTON_ADD,    IDH_BUTTON_RSG_PROP_ADD,
   IDC_BUTTON_REMOVE, IDH_BUTTON_RSG_PROP_REMOVE,
   IDC_BUTTON_EDIT,   IDH_BUTTON_RSG_PROP_PROP,
   0,0
};


///////////////////////////////////////////////////////////////////////////////
// Remote RADIUS server properties
///////////////////////////////////////////////////////////////////////////////

//////////
// Address tab
//////////
#define IDH_EDIT_RSG_MEMBER_ADDR_NAME     800020031
#define IDH_BUTTON_RSG_MEMBER_ADDR_VERIFY 800020032

const  DWORD g_aHelpIDs_IDD_SERVER_NAME[]=
{
   IDC_EDIT_NAME,     IDH_EDIT_RSG_MEMBER_ADDR_NAME,
   IDC_BUTTON_VERIFY, IDH_BUTTON_RSG_MEMBER_ADDR_VERIFY,
   0,0
};

//////////
// Authentication / Accounting tab
//////////
#define IDH_EDIT_RSG_MEMBER_AUTHACCT_AUTHPORT     800020033
#define IDH_EDIT_RSG_MEMBER_AUTHACCT_AUTHSECRET   800020034
#define IDH_EDIT_RSG_MEMBER_AUTHACCT_AUTHSECRET2  800020035
#define IDH_EDIT_RSG_MEMBER_AUTHACCT_ACCTPORT     800020036
#define IDH_CHECK_RSG_MEMBER_AUTHACCT_SAMESECRET  800020037
#define IDH_EDIT_RSG_MEMBER_AUTHACCT_ACCTSECRET   800020038
#define IDH_EDIT_RSG_MEMBER_AUTHACCT_ACCTSECRET2  800020039
#define IDH_CHECK_RSG_MEMBER_AUTHACCT_FWDNOTIFIES 800020040

const  DWORD g_aHelpIDs_IDD_SERVER_AUTH[]=
{
   IDC_EDIT_AUTH_PORT,    IDH_EDIT_RSG_MEMBER_AUTHACCT_AUTHPORT,
   IDC_EDIT_AUTH_SECRET1, IDH_EDIT_RSG_MEMBER_AUTHACCT_AUTHSECRET,
   IDC_EDIT_AUTH_SECRET2, IDH_EDIT_RSG_MEMBER_AUTHACCT_AUTHSECRET2,
   IDC_EDIT_ACCT_PORT,    IDH_EDIT_RSG_MEMBER_AUTHACCT_ACCTPORT,
   IDC_CHECK_SAME_SECRET, IDH_CHECK_RSG_MEMBER_AUTHACCT_SAMESECRET,
   IDC_EDIT_ACCT_SECRET1, IDH_EDIT_RSG_MEMBER_AUTHACCT_ACCTSECRET,
   IDC_EDIT_ACCT_SECRET2, IDH_EDIT_RSG_MEMBER_AUTHACCT_ACCTSECRET2,
   IDC_CHECK_ACCT_ONOFF,  IDH_CHECK_RSG_MEMBER_AUTHACCT_FWDNOTIFIES,
   0,0
};

//////////
// Load-balancing tab
//////////
#define IDH_EDIT_RSG_MEMBER_LB_PRIORITY 800020041
#define IDH_EDIT_RSG_MEMBER_LB_WEIGHT   800020042
#define IDH_EDIT_RSG_MEMBER_LB_ADV1     800020043
#define IDH_EDIT_RSG_MEMBER_LB_ADV2     800020044
#define IDH_EDIT_RSG_MEMBER_LB_ADV3     800020045

const  DWORD g_aHelpIDs_IDD_SERVER_FTLB[]=
{
   IDC_EDIT_PRIORITY, IDH_EDIT_RSG_MEMBER_LB_PRIORITY,
   IDC_EDIT_WEIGHT,   IDH_EDIT_RSG_MEMBER_LB_WEIGHT,
   IDC_EDIT_TIMEOUT,  IDH_EDIT_RSG_MEMBER_LB_ADV1,
   IDC_EDIT_MAX_LOST, IDH_EDIT_RSG_MEMBER_LB_ADV2,
   IDC_EDIT_BLACKOUT, IDH_EDIT_RSG_MEMBER_LB_ADV3,
   0,0
};

//////////
// Verify server address dialog.
//////////

#define IDH_EDIT_RSG_VRFYSRV_NAME      800020057
#define IDH_BUTTON_RSG_VRFYSRV_RESOLVE 800020058
#define IDH_LIST_RSG_VRFYSRV_IPADDRS   800020059

const  DWORD g_aHelpIDs_IDD_RESOLVE_SERVER_ADDRESS[]=
{
   IDC_EDIT_NAME,      IDH_EDIT_RSG_VRFYSRV_NAME,
   IDC_BUTTON_RESOLVE, IDH_BUTTON_RSG_VRFYSRV_RESOLVE,
   IDC_LIST_IPADDRS,   IDH_LIST_RSG_VRFYSRV_IPADDRS,
   0,0
};

//////////
// Verify client address dialog.
//////////

#define IDH_EDIT_RSG_VRFYCLNT_NAME      800020060
#define IDH_BUTTON_RSG_VRFYCLNT_RESOLVE 800020061
#define IDH_LIST_RSG_VRFYCLNT_IPADDRS   800020062

const  DWORD g_aHelpIDs_IDD_RESOLVE_CLIENT_ADDRESS[]=
{
   IDC_EDIT_NAME,      IDH_EDIT_RSG_VRFYCLNT_NAME,
   IDC_BUTTON_RESOLVE, IDH_BUTTON_RSG_VRFYCLNT_RESOLVE,
   IDC_LIST_IPADDRS,   IDH_LIST_RSG_VRFYCLNT_IPADDRS,
   0,0
};

///////////////////////////////////////////////////////////////////////////////
// Proxy Policy Properties
///////////////////////////////////////////////////////////////////////////////

//////////
// Policy page
//////////
#define IDH_EDIT_CRP_POLNAME   800020007
#define IDH_LIST_CRP_POLCOND   800020002
#define IDH_BUTTON_CRP_ADD     800020003
#define IDH_BUTTON_CRP_EDIT    800020004
#define IDH_BUTTON_CRP_REMOVE  800020005
#define IDH_BUTTON_CRP_PROFILE 800020006

const  DWORD g_aHelpIDs_IDD_PROXY_POLICY[]=
{
   IDC_EDIT_NAME,                   IDH_EDIT_CRP_POLNAME,
   IDC_LIST_POLICYPAGE1_CONDITIONS, IDH_LIST_CRP_POLCOND,
   IDC_BUTTON_CONDITION_ADD,        IDH_BUTTON_CRP_ADD,
   IDC_BUTTON_CONDITION_EDIT,       IDH_BUTTON_CRP_EDIT,
   IDC_BUTTON_CONDITION_REMOVE,     IDH_BUTTON_CRP_REMOVE,
   IDC_BUTTON_EDITPROFILE,          IDH_BUTTON_CRP_PROFILE,
   0,0
};


///////////////////////////////////////////////////////////////////////////////
// Proxy Profile Properties
///////////////////////////////////////////////////////////////////////////////

//////////
// Authentication tab
//////////
#define IDH_RADIO_PROF_AUTH_LOCAL   800020009
#define IDH_RADIO_PROF_AUTH_REMOTE  800020010
#define IDH_COMBO_PROF_AUTH_GROUPS  800020011
#define IDH_RADIO_PROF_AUTH_UNAUTH  800020012

const  DWORD g_aHelpIDs_IDD_PROXY_PROFILE_AUTH[]=
{
   IDC_RADIO_NONE,    IDH_RADIO_PROF_AUTH_UNAUTH,
   IDC_RADIO_WINDOWS, IDH_RADIO_PROF_AUTH_LOCAL,
   IDC_RADIO_RADIUS,  IDH_RADIO_PROF_AUTH_REMOTE,
   IDC_COMBO_GROUP,   IDH_COMBO_PROF_AUTH_GROUPS,
   0,0
};

//////////
// Accounting tab
//////////
#define IDH_CHECK_PROF_ACCT_REMOTE  800020013
#define IDH_COMBO_PROF_ACCT_GROUPS  800020014

const  DWORD g_aHelpIDs_IDD_PROXY_PROFILE_ACCT[]=
{
   IDC_CHECK_RECORD_ACCT, IDH_CHECK_PROF_ACCT_REMOTE,
   IDC_COMBO_GROUP, IDH_COMBO_PROF_ACCT_GROUPS,
   0,0
};

//////////
// Attribute manipulation tab
//////////
#define IDH_COMBO_PROF_ATTR_ATTRNAME   800020015
#define IDH_LIST_PROF_ATTR_RULELIST 800020016
#define IDH_BUTTON_PROF_ATTR_MOVEUP 800020017
#define IDH_BUTTON_PROF_ATTR_MOVEDOWN  800020018
#define IDH_BUTTON_PROF_ATTR_ADD 800020019
#define IDH_BUTTON_PROF_ATTR_EDIT   800020020
#define IDH_BUTTON_PROF_ATTR_REMOVE 800020021

const  DWORD g_aHelpIDs_IDD_PROXY_PROFILE_ATTR[]=
{
   IDC_COMBO_TARGET,     IDH_COMBO_PROF_ATTR_ATTRNAME,
   IDC_LIST_RULES,       IDH_LIST_PROF_ATTR_RULELIST,
   IDC_BUTTON_MOVE_UP,   IDH_BUTTON_PROF_ATTR_MOVEUP,
   IDC_BUTTON_MOVE_DOWN, IDH_BUTTON_PROF_ATTR_MOVEDOWN,
   IDC_BUTTON_ADD,       IDH_BUTTON_PROF_ATTR_ADD,
   IDC_BUTTON_REMOVE,    IDH_BUTTON_PROF_ATTR_REMOVE,
   IDC_BUTTON_EDIT,      IDH_BUTTON_PROF_ATTR_EDIT,
   0,0
};

//////////
// Edit attribute manipulation rule
//////////
#define IDH_EDIT_PROF_ATTR_RULE_FIND      800020055
#define IDH_EDIT_PROF_ATTR_RULE_REPLACE   800020056

const  DWORD g_aHelpIDs_IDD_EDIT_RULE[]=
{
   IDC_EDIT_RULE_FIND,    IDH_EDIT_PROF_ATTR_RULE_FIND,
   IDC_EDIT_RULE_REPLACE, IDH_EDIT_PROF_ATTR_RULE_REPLACE,
   0,0
};


/////////
// SQL Server property page.
//////////
#define IDH_DB_CHECK_ACCT         800020401
#define IDH_DB_CHECK_AUTH         800020402
#define IDH_DB_CHECK_INTERIM      800020403
#define IDH_DB_EDIT_MAX_SESSIONS  800020404
#define IDH_DB_EDIT_DATA_SOURCE   800020405
#define IDH_DB_BUTTON_CONFIGURE   800020406
#define IDH_DB_BUTTON_CLEAR       800020407

const DWORD g_aHelpIDs_IDD_DB_PROPPAGE[] =
{
   IDC_DB_CHECK_ACCT, IDH_DB_CHECK_ACCT,
   IDC_DB_CHECK_AUTH, IDH_DB_CHECK_AUTH,
   IDC_DB_CHECK_INTERIM, IDH_DB_CHECK_INTERIM,
   IDC_DB_EDIT_MAX_SESSIONS, IDH_DB_EDIT_MAX_SESSIONS,
   IDC_DB_EDIT_DATA_SOURCE, IDH_DB_EDIT_DATA_SOURCE,
   IDC_DB_BUTTON_CONFIGURE, IDH_DB_BUTTON_CONFIGURE,
   IDC_DB_BUTTON_CLEAR, IDH_DB_BUTTON_CLEAR,
   0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\ntgcond.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ntgcond.h
//
//--------------------------------------------------------------------------

// NTGCond.h: interface for the CNTGroupsCondition class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_NTGCOND_H__9F91767B_A693_11D1_BBEB_00C04FC31851__INCLUDED_)
#define AFX_NTGCOND_H__9F91767B_A693_11D1_BBEB_00C04FC31851__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "atltmp.h"

#include "Condition.h"

class CNTGroupsCondition : public CCondition  
{
public:
	CNTGroupsCondition(	IIASAttributeInfo*	pCondAttr, 
						ATL::CString&			strConditionText,
						HWND				hWndParent,
						LPTSTR				pszServerAddress
					  );
	CNTGroupsCondition(IIASAttributeInfo*	pCondAttr,
					   HWND					hWndParent,
					   LPTSTR				pszServerAddress
					  );
	virtual ~CNTGroupsCondition();

	HRESULT Edit();
	virtual ATL::CString GetDisplayText();
	virtual WCHAR* GetConditionText();

protected:
	HWND m_hWndParent;
	LPTSTR	m_pszServerAddress;	
	BOOL	m_fParsed;
	HRESULT ParseConditionText(); // parse the condition text
	ATL::CString m_strDisplayCondText;
};

#endif // !defined(AFX_NTGCOND_H__9F91767B_A693_11D1_BBEB_00C04FC31851__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\ntgroups.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation

Module Name:

   NTGroups.h

Abstract:

   Declaration of the CIASGroupsAttributeEditor class.


   This class is the C++ implementation of the IIASAttributeEditor interface on
   the NTGroups Attribute Editor COM object.

  
   See NTGroups.cpp for implementation.

Revision History:
   mmaguire 08/11/98 - created based on byao's code to add groups


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_GROUPS_ATTRIBUTE_EDITOR_H_)
#define _GROUPS_ATTRIBUTE_EDITOR_H_
#pragma once

#include <objsel.h>
//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
//
// where we can find what this class has or uses:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CIASGroupAttributeEditor
class ATL_NO_VTABLE CIASGroupsAttributeEditor : 
   public CComObjectRootEx<CComSingleThreadModel>,
   public CComCoClass<CIASGroupsAttributeEditor, &CLSID_IASGroupsAttributeEditor>,
   public IDispatchImpl<IIASAttributeEditor, &IID_IIASAttributeEditor, &LIBID_NAPMMCLib>
{
public:
   CIASGroupsAttributeEditor()
   {
   }

   DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CIASGroupsAttributeEditor)
   COM_INTERFACE_ENTRY(IIASAttributeEditor)
   COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()


// IIASAttributeEditor:
public:
   STDMETHOD(GetDisplayInfo)(/*[in]*/ IIASAttributeInfo *pIASAttributeInfo, /*[in]*/ VARIANT *pAttributeValue, /*[out]*/ BSTR *pVendorName, /*[out]*/ BSTR *pValueAsString, /*[in, out]*/ BSTR *pReserved );
   STDMETHOD(Edit)(/*[in]*/ IIASAttributeInfo *pIASAttributeInfo, /*[in]*/ VARIANT *pAttributeValue, /*[in, out]*/ BSTR *pReserved );
};


// We define a class for a list of groups which encapsulates some of the
// problems of maintaining a list of SID/Human Readable NT Groups.

typedef std::pair< CComBSTR /* bstrTextualSid */, CComBSTR /* bstrHumanReadable */ > GROUPPAIR;
typedef std::vector< GROUPPAIR > GROUPLIST;
class GroupList : public GROUPLIST
{

public:
   HRESULT PopulateGroupsFromVariant( VARIANT * pvarGroups );
   HRESULT PopulateVariantFromGroups( VARIANT * pvarGroups );
   HRESULT PickNtGroups( HWND hWndParent );

   // This BSTR is needed because popping up group picker and
   // correctly converting SIDs to HumanReadable text
   // requires machine name.
   CComBSTR m_bstrServerName;


#ifdef DEBUG
   HRESULT DebugPrintGroups();
#endif DEBUG

protected:
   
   HRESULT AddPairToGroups( GROUPPAIR &thePair );

#ifndef OLD_OBJECT_PICKER
   HRESULT AddSelectionSidsToGroup( PDS_SELECTION_LIST pDsSelList );
#else // OLD_OBJECT_PICKER
   HRESULT AddSelectionSidsToGroup( PDSSELECTIONLIST pDsSelList );
#endif // OLD_OBJECT_PICKER

};

// class to populate the groups in list view control ...
class NTGroup_ListView : public GroupList
{
public:
   NTGroup_ListView() : m_hListView ( NULL ), m_hParent(NULL) { };
   void  SetListView(HWND  hListView, HWND hParent = NULL) {m_hListView =  hListView; m_hParent = hParent;};
   
   BOOL PopulateGroupList( int iStartIndex );
   DWORD AddMoreGroups();
   DWORD RemoveSelectedGroups();
   
protected:  
   HWND  m_hListView;
   HWND  m_hParent;
};

#endif // _GROUPS_ATTRIBUTE_EDITOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\ntgroups.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 2001

Module Name:

    NTGroups.cpp

Abstract:

	Implementation file for the CIASGroupsAttributeEditor class.

Revision History:
	mmaguire 08/10/98	- added new intermediate dialog for picking groups using some
							of byao's original implementation

--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include <objsel.h>
#include "NTGroups.h"

//
// where we can find declarations needed in this file:
//
#include <vector>
#include <utility>	// For "pair"
#include <atltmp.h>
#include <initguid.h>
#include <activeds.h>
#include <lmcons.h>
#include <objsel.h>
#include "textsid.h"
#include "dialog.h"
#include "dsrole.h"

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//#define OLD_OBJECT_PICKER




// Small wrapper class for a BYTE pointer to avoid memory leaks.
template <class Pointer>
class SmartPointer
{
public:
	SmartPointer()
	{
		m_Pointer = NULL;
	}

	operator Pointer()
	{
		return( m_Pointer );
	}

	Pointer * operator&()
	{
		return( & m_Pointer );
	}

	virtual ~SmartPointer()
	{
		// Override as necessary.
	};

protected:

	Pointer m_Pointer;
};




/////////////////////////////////////////////////////////////////////////////
// Declarations needed in this file:



PWSTR g_wzObjectSID = _T("objectSid");



// Group list delimiter:
#define DELIMITER L";"

// Utility functions:

static HRESULT ConvertSidToTextualRepresentation( PSID pSid, CComBSTR &bstrTextualSid );
static HRESULT ConvertSidToHumanReadable( PSID pSid, CComBSTR &bstrHumanReadable, LPCTSTR lpSystemName = NULL );

// We needed this because the standard macro doesn't return the value from SNDMSG and
// sometimes we need to know whether the operation succeeded or failed.
static inline LRESULT CustomListView_SetItemState( HWND hwndLV, int i, UINT  data, UINT mask)
{
	LV_ITEM _ms_lvi;
	_ms_lvi.stateMask = mask;
	_ms_lvi.state = data;
	return SNDMSG((hwndLV), LVM_SETITEMSTATE, (WPARAM)i, (LPARAM)(LV_ITEM FAR *)&_ms_lvi);
}


/////////////////////////////////////////////////////////////////////////////
// CDisplayGroupsDialog
class CDisplayGroupsDialog;
typedef CIASDialog<CDisplayGroupsDialog, FALSE>  DISPLAY_GROUPS_FALSE;


class CDisplayGroupsDialog : public DISPLAY_GROUPS_FALSE
{
public:
	CDisplayGroupsDialog( GroupList *pGroups );
	~CDisplayGroupsDialog();

	enum { IDD = IDD_DIALOG_DISPLAY_GROUPS };
	
BEGIN_MSG_MAP(CDisplayGroupsDialog)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDC_BUTTON_ADD_GROUP, OnAdd)
	COMMAND_ID_HANDLER(IDC_BUTTON_REMOVE_GROUP, OnRemove)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnListViewItemChanged)
//	NOTIFY_CODE_HANDLER(NM_DBLCLK, OnListViewDbclk)
	CHAIN_MSG_MAP(DISPLAY_GROUPS_FALSE)
END_MSG_MAP()


	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnListViewItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
	LRESULT OnListViewDbclk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);


protected:
	BOOL PopulateGroupList( int iStartIndex );

private:

	HWND m_hWndGroupList;
	GroupList * m_pGroups;
};





//////////////////////////////////////////////////////////////////////////////
/*++

CIASGroupsAttributeEditor::Edit

IIASAttributeEditor implementation.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASGroupsAttributeEditor::Edit(IIASAttributeInfo * pIASAttributeInfo,  /*[in]*/ VARIANT *pAttributeValue, /*[in, out]*/ BSTR *pReserved )
{
	TRACE_FUNCTION("CIASGroupsAttributeEditor::Edit");

	HRESULT hr = S_OK;

	try	// new could throw as could DoModal
	{
		WCHAR * pszMachineName = NULL;

		// Check for preconditions.
		// We will ignore the pIASAttributeInfo interface pointer -- it is not
		// needed for this attribute editor.
		if( ! pAttributeValue )
		{
			return E_INVALIDARG;
		}
		if( V_VT(pAttributeValue ) !=  VT_BSTR )
		{
			return E_INVALIDARG;
		}

		GroupList Groups;

		// We need to pass the machine name in somehow, so we use the
		// otherwise unused pReserved BSTR *.
		if( pReserved )
		{
			Groups.m_bstrServerName = *pReserved;
		}
		
		Groups.PopulateGroupsFromVariant( pAttributeValue );

		// ISSUE: Need to get szServerAddress in here somehow -- could use reserved.
		CDisplayGroupsDialog * pDisplayGroupsDialog = new CDisplayGroupsDialog( &Groups );

		_ASSERTE( pDisplayGroupsDialog );

		int iResult = pDisplayGroupsDialog->DoModal();
		if( IDOK == iResult )
		{
			// Clear out the old value of the variant.
			VariantClear(pAttributeValue);

			Groups.PopulateVariantFromGroups( pAttributeValue );
			hr = S_OK;
		}
		else
		{
			hr = S_FALSE;
		}
	
	}
	catch(...)
	{
		return E_FAIL;
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASGroupsAttributeEditor::GetDisplayInfo

IIASAttributeEditor implementation.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASGroupsAttributeEditor::GetDisplayInfo(IIASAttributeInfo * pIASAttributeInfo,  /*[in]*/ VARIANT *pAttributeValue, BSTR * pServerName, BSTR * pValueAsString, /*[in, out]*/ BSTR *pReserved )
{
	TRACE_FUNCTION("CIASGroupsAttributeEditor::GetDisplayInfo");

	HRESULT hr = S_OK;


	// Check for preconditions.
	// We will ignore the pIASAttributeInfo interface pointer -- it is not
	// needed for this attribute editor.
	// We will also ignore the pVendorName BSTR pointer -- this doesn't
	// make sense for this attribute editor.
	if( ! pAttributeValue )
	{
		return E_INVALIDARG;
	}
	if( V_VT(pAttributeValue ) !=  VT_BSTR )
	{
		return E_INVALIDARG;
	}
	if( ! pValueAsString )
	{
		return E_INVALIDARG;
	}

	try
	{

		GroupList Groups;
		
		// We need to pass the machine name in somehow, so we use the
		// otherwise unused pReserved BSTR *.
		if( pReserved )
		{
			Groups.m_bstrServerName = *pReserved;
		}
		
		hr = Groups.PopulateGroupsFromVariant( pAttributeValue );
		if( FAILED( hr ) )
		{
			return hr;
		}

		CComBSTR bstrDisplay;

		GroupList::iterator thePair = Groups.begin();

		while( thePair != Groups.end() )
		{
			bstrDisplay += thePair->second;

			thePair++;
			
			if( thePair != Groups.end() )
			{
				bstrDisplay += DELIMITER;
			}
		}

		*pValueAsString = bstrDisplay.Copy();

	}
	catch(...)
	{
		return E_FAIL;
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

ConvertSidToTextualRepresentation

Converts a SID to a BSTR representation. e.g. "S-1-5-32-544"

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT ConvertSidToTextualRepresentation( PSID pSid, CComBSTR &bstrTextualSid )
{
	HRESULT hr = S_OK;

	// convert the SID value to texual format
	WCHAR text[1024];
	DWORD cbText = sizeof(text)/sizeof(WCHAR);
	if( NO_ERROR == IASSidToTextW(pSid, text, &cbText) )
	{
		bstrTextualSid = text;
	}
	else
	{
		return E_FAIL;
	}

	return hr;

}



//////////////////////////////////////////////////////////////////////////////
/*++

ConvertSidToTextualRepresentation

Converts a SID to a humanBSTR representation. e.g. "ias-domain\Users"

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT ConvertSidToHumanReadable( PSID pSid, CComBSTR &bstrHumanReadable, LPCTSTR lpSystemName )
{
	HRESULT hr = S_OK;

	// Find the group name for this sid.
	WCHAR wzUserName[MAX_PATH+1];
	WCHAR wzDomainName[MAX_PATH+1];
	DWORD dwUserNameLen, dwDomainNameLen;
	SID_NAME_USE sidUser = SidTypeGroup;

	ATLTRACE(_T("looking up the account name from the SID value\n"));

	dwUserNameLen = sizeof(wzUserName);
	dwDomainNameLen = sizeof(wzDomainName);

	if (LookupAccountSid(
					lpSystemName,
					pSid,
					wzUserName,
					&dwUserNameLen,
					wzDomainName,
					&dwDomainNameLen,
					&sidUser
				)
		)
	{
		bstrHumanReadable = wzDomainName;
		bstrHumanReadable += L"\\";
		bstrHumanReadable += wzUserName;
	}
	else
	{
#ifdef DEBUG
		DWORD dwError = GetLastError();
		ATLTRACE(_T("Error: %ld\n"), dwError);
#endif // DEBUG
		
		
		return E_FAIL;
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

GroupList::PopulateGroupsFromVariant

Takes a pointer to a variant and populates a GroupList with that data.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT GroupList::PopulateGroupsFromVariant( VARIANT * pvarGroups )
{
	TRACE_FUNCTION("GroupList::PopulateGroupsFromVariant");

	// Check for preconditions.
	_ASSERTE( V_VT(pvarGroups) == VT_BSTR );

	HRESULT hr = S_OK;


	// First, make a local copy.
	// ISSUE: Make sure this copies.
	CComBSTR bstrGroups = V_BSTR(pvarGroups);

	WCHAR *pwzGroupText = bstrGroups;


	// Each group should be separated by a comma or semicolon.
    PWSTR pwzToken = wcstok(pwzGroupText, DELIMITER);
    while (pwzToken)
    {
		PSID pSid = NULL;

		try
		{

			CComBSTR bstrGroupTextualSid = pwzToken;
			CComBSTR bstrGroupName;

			if( NO_ERROR != IASSidFromTextW( pwzToken, &pSid ) )
			{
				// Try the next one.
				throw E_FAIL;
			}


			if( FAILED( ConvertSidToHumanReadable( pSid, bstrGroupName, m_bstrServerName ) ) )
			{
				// Try the next one.
				throw E_FAIL;
			}

			GROUPPAIR thePair = std::make_pair( bstrGroupTextualSid, bstrGroupName );

			push_back( thePair );


			FreeSid( pSid );
			pwzToken = wcstok(NULL, DELIMITER);

		}
		catch(...)
		{
		
			if( pSid )
			{
				FreeSid( pSid );
			}

			pwzToken = wcstok(NULL, DELIMITER);
		}


    }

	
	return hr;

}



//////////////////////////////////////////////////////////////////////////////
/*++

GroupList::PopulateVariantFromGroups

Takes a pointer to a variant and populates the variant with data from a GroupList.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT GroupList::PopulateVariantFromGroups( VARIANT * pAttributeValue )
{
	TRACE_FUNCTION("GroupList::PopulateVariantFromGroups");

	HRESULT hr = S_OK;


	CComBSTR bstrGroupsString;


	GroupList::iterator thePair = begin();
	
	while( thePair != end() )
	{

		bstrGroupsString += thePair->first;

		thePair++;

		if( thePair != end() )
		{
			bstrGroupsString += DELIMITER;
		}

	}

	V_VT(pAttributeValue) = VT_BSTR;
	V_BSTR( pAttributeValue ) = bstrGroupsString.Copy();

	return hr;

}



//////////////////////////////////////////////////////////////////////////////
/*++

GroupList::AddPairToGroups

Adds a pair to a GroupList if a pair with the same SID isn't already in the list.

Note: Does nothing and return S_FALSE if Pair already in groups list.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT GroupList::AddPairToGroups( GROUPPAIR &thePair )
{
	TRACE_FUNCTION("GroupList::AddPairToGroups");

	HRESULT hr = S_OK;

	try
	{

		// First, check to see if the pair is already in the group.

		GroupList::iterator theIterator;

		for( theIterator = begin(); theIterator != end(); ++theIterator )
		{
			if( 0 == wcscmp( theIterator->first, thePair.first ) )
			{
				return S_FALSE;
			}
		}

		push_back( thePair );
	
	}
	catch(...)
	{
		return E_FAIL;
	}
	
	return hr;

}



//////////////////////////////////////////////////////////////////////////////
/*++

GroupList::AddSelectionSidsToGroup

#ifndef OLD_OBJECT_PICKER
Takes a PDS_SELECTION_LIST pointer and adds all groups it points to to a
GroupList.
#else // OLD_OBJECT_PICKER
Takes a PDSSELECTIONLIST pointer and adds all groups it points to to a
GroupList.
#endif // OLD_OBJECT_PICKER

  Returns S_OK if it adds any new groups.
  Returns S_FALSE and does not add entries if they are already in the GroupList.

  E_FAIL on error.

--*/
//////////////////////////////////////////////////////////////////////////////
#ifndef OLD_OBJECT_PICKER
HRESULT GroupList::AddSelectionSidsToGroup(	PDS_SELECTION_LIST pDsSelList	)
#else // OLD_OBJECT_PICKER
HRESULT GroupList::AddSelectionSidsToGroup(	PDSSELECTIONLIST pDsSelList	)
#endif // OLD_OBJECT_PICKER
{
	TRACE_FUNCTION("GroupList::AddSelectionSidsToGroup");


	HRESULT			hr		= S_OK;
	ULONG			i;

#ifndef OLD_OBJECT_PICKER
	PDS_SELECTION	pCur	= &pDsSelList->aDsSelection[0];
#else // OLD_OBJECT_PICKER
	PDSSELECTION	pCur	= &pDsSelList->aDsSelection[0];
#endif // OLD_OBJECT_PICKER
	

	BOOL	bAtLeastOneAdded = FALSE;

	//
	// now let's get the sid value for each selection!
	//

	pCur = &pDsSelList->aDsSelection[0];
	for (i = 0; i < pDsSelList->cItems; ++i, ++pCur)
	{

#ifndef OLD_OBJECT_PICKER
		if (V_VT(&pCur->pvarFetchedAttributes[0]) == (VT_ARRAY|VT_UI1))
#else // OLD_OBJECT_PICKER
		if (V_VT(&pCur->pvarOtherAttributes[0]) == (VT_ARRAY|VT_UI1))
#endif // OLD_OBJECT_PICKER
		{
			// succeeded: we got the SID value back!
			PSID pSid = NULL;
			
#ifndef OLD_OBJECT_PICKER
			hr = SafeArrayAccessData(V_ARRAY(&pCur->pvarFetchedAttributes[0]), &pSid);
#else // OLD_OBJECT_PICKER
			hr = SafeArrayAccessData(V_ARRAY(&pCur->pvarOtherAttributes[0]), &pSid);
#endif // OLD_OBJECT_PICKER
			
			if ( SUCCEEDED(hr) && pSid )
			{
				CComBSTR bstrTextualSid;
				CComBSTR bstrHumanReadable;

				hr = ConvertSidToTextualRepresentation( pSid, bstrTextualSid );
				if( FAILED( hr ) )
				{
					// If we can't get the textual representation of the SID,
					// then we're hosed for this group -- we'll have nothing
					// to save it away as.
					continue;
				}

				hr = ConvertSidToHumanReadable( pSid, bstrHumanReadable, m_bstrServerName );
				if( FAILED( hr ) )
				{
					// For some reason, we couldn't look up a group name.
					// Use the textual SID to display this group.
					bstrHumanReadable = bstrTextualSid;
				}

				GROUPPAIR thePair = std::make_pair( bstrTextualSid, bstrHumanReadable );

				hr = AddPairToGroups( thePair );
				if( S_OK == hr )
				{
					bAtLeastOneAdded = TRUE;
				}


			}

#ifndef OLD_OBJECT_PICKER
			SafeArrayUnaccessData(V_ARRAY(&pCur->pvarFetchedAttributes[0]));
#else // OLD_OBJECT_PICKER
			SafeArrayUnaccessData(V_ARRAY(&pCur->pvarOtherAttributes[0]));
#endif // OLD_OBJECT_PICKER

		}
		else
		{
			// we couldn't get the sid value
			hr = E_FAIL;
		}
	} // for

	// We don't seem to have encountered any errors.
	// Decide on return value based on whether we added any new
	// groups to the list that weren't already there.
	if( bAtLeastOneAdded )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}


	// Small wrapper class for a DsRole BYTE pointer to avoid memory leaks.
	class MyDsRoleBytePointer : public SmartPointer<PBYTE>
	{
	public:
		// We override the destructor to do DsRole specific release.
		~MyDsRoleBytePointer()
		{
			if( m_Pointer )
			{
				DsRoleFreeMemory( m_Pointer );
			}
		}
	};


//+---------------------------------------------------------------------------
//
// Function:  GroupList::PickNtGroups
//
// Synopsis:  pop up the objectPicker UI and choose a set of NT groups
//
// Arguments:
//			 [in]	HWND hWndParent:		parent window;
//			 [in]	LPTSTR pszServerAddress:the machine name
//
//
// Returns:   S_OK if added new groups.
//			  S_FALSE if no new groups in selection.
//			  Error value on fail.
//
// History:   Created Header    byao 2/15/98 12:09:53 AM
//			  Modified			byao 3/11/98  to get domain/group names as well
//			  Modified			mmaguire 08/12/98  made method of GroupList class
//
//+---------------------------------------------------------------------------
HRESULT GroupList::PickNtGroups( HWND hWndParent )
{
#ifndef OLD_OBJECT_PICKER


	HRESULT hr;
	CComPtr<IDsObjectPicker> spDsObjectPicker;

	hr = CoCreateInstance( CLSID_DsObjectPicker
						, NULL
						, CLSCTX_INPROC_SERVER
						, IID_IDsObjectPicker
						, (void **) &spDsObjectPicker
						);
	if( FAILED( hr ) )
	{
		return hr;
	}


	
	// Check to see if we are a DC -- we will use DsRoleGetPrimaryDomainInformation


	LPWSTR szServer = NULL;
	if ( m_bstrServerName && _tcslen(m_bstrServerName) )
	{
		// use machine name for remote machine
		szServer = m_bstrServerName;
	}
	
	MyDsRoleBytePointer dsInfo;

	if( ERROR_SUCCESS != DsRoleGetPrimaryDomainInformation( szServer, DsRolePrimaryDomainInfoBasic, &dsInfo ) )
	{
		return E_FAIL;
	}

	PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pInfo = (PDSROLE_PRIMARY_DOMAIN_INFO_BASIC) (PBYTE) dsInfo;
	if( ! pInfo )
	{
		return E_FAIL;
	}

	BOOL bNotDc;
	if( pInfo->MachineRole == DsRole_RoleBackupDomainController || pInfo->MachineRole == DsRole_RolePrimaryDomainController )
	{
		bNotDc = FALSE;
	}
	else
	{
		bNotDc = TRUE;
	}

	// At the most, we need only three scopes (we may use less).
	DSOP_SCOPE_INIT_INFO aScopes[3];
	ZeroMemory( aScopes, sizeof(aScopes) );

	int iScopeCount = 0;

	// We need to add this first, DSOP_SCOPE_TYPE_TARGET_COMPUTER type
	// scope only if we are not on the DC.


	if( bNotDc )
	{
		// Include a scope for the target computer's scope.
		aScopes[iScopeCount].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
		aScopes[iScopeCount].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;

		// Set what filters to apply for this scope.
		aScopes[iScopeCount].FilterFlags.flDownlevel=	DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS
														| DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS
														;
	}




	// Move on to next scope.
	++iScopeCount;

	// Set the downlevel scopes
	aScopes[iScopeCount].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
	aScopes[iScopeCount].flType = DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN
								| DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
								;

	// Set what filters to apply for this scope.
	aScopes[iScopeCount].FilterFlags.flDownlevel	= DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS
													| DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS
													| DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS
													;



	// Move on to next scope.
	++iScopeCount;

	// For all other scopes, use same as target computer but exclude BUILTIN_GROUPS
	aScopes[iScopeCount].cbSize = sizeof( DSOP_SCOPE_INIT_INFO );
	aScopes[iScopeCount].flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
								| DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
								;
	// Set what filters to apply for this scope.
	aScopes[iScopeCount].FilterFlags.Uplevel.flBothModes	= 0
		/* BUG 263302 -- not to show domain local groups
															| DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE
		 ~ BUG */															
															| DSOP_FILTER_GLOBAL_GROUPS_SE
															;
	aScopes[iScopeCount].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_UNIVERSAL_GROUPS_SE;




	// Now fill up the correct structures and call Initialize.
	DSOP_INIT_INFO InitInfo;
	ZeroMemory( &InitInfo, sizeof(InitInfo) );

	InitInfo.cbSize = sizeof( InitInfo );
	InitInfo.cDsScopeInfos = iScopeCount + 1;
	InitInfo.aDsScopeInfos = aScopes;
	InitInfo.flOptions = DSOP_FLAG_MULTISELECT;

	// Requested attributes:
    InitInfo.cAttributesToFetch = 1;	// We only need the SID value.
	LPTSTR	pSidAttr = g_wzObjectSID;
	LPCTSTR	aptzRequestedAttributes[1];
	aptzRequestedAttributes[0] = pSidAttr;
    InitInfo.apwzAttributeNames = (const WCHAR **)aptzRequestedAttributes;


	if ( m_bstrServerName && _tcslen(m_bstrServerName) )
	{
		// use machine name for remote machine
		InitInfo.pwzTargetComputer = m_bstrServerName;
	}
	else
	{
		// or use NULL for local machine
		InitInfo.pwzTargetComputer = NULL;
	}



 	hr = spDsObjectPicker->Initialize(&InitInfo);
	if( FAILED( hr ) )
	{
		return hr;
	}

	CComPtr<IDataObject> spDataObject;

	hr = spDsObjectPicker->InvokeDialog( hWndParent, &spDataObject );
	if( FAILED( hr ) || hr == S_FALSE )
	{
		// When user selected "Cancel", ObjectPicker will return S_FALSE.
		return hr;
	}
	
	STGMEDIUM stgmedium =
	{
		TYMED_HGLOBAL
		, NULL
	};


	UINT cf = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);
	if( 0 == cf )
	{
		return E_FAIL;
	}


	FORMATETC formatetc =
	{
		(CLIPFORMAT)cf
		, NULL
		, DVASPECT_CONTENT
		, -1
		, TYMED_HGLOBAL
	};

	hr = spDataObject->GetData( &formatetc, &stgmedium );
	if( FAILED( hr ) )
	{
		return hr;
	}


	PDS_SELECTION_LIST pDsSelList = (PDS_SELECTION_LIST) GlobalLock( stgmedium.hGlobal );
	if( ! pDsSelList )
	{
		return E_FAIL;
	}


	hr = AddSelectionSidsToGroup( pDsSelList );

	GlobalUnlock( stgmedium.hGlobal );
	ReleaseStgMedium( &stgmedium );



#else // OLD_OBJECT_PICKER

	
	HRESULT             hr;
    BOOL                fBadArg = FALSE;

    ULONG               flDsObjectPicker = 0;
    ULONG               flUserGroupObjectPicker = 0;
    ULONG               flComputerObjectPicker = 0;
    ULONG               flInitialScope = DSOP_SCOPE_SPECIFIED_MACHINE;


	flDsObjectPicker = flInitialScope
					 | DSOP_SCOPE_DIRECTORY
					 | DSOP_SCOPE_DOMAIN_TREE
					 | DSOP_SCOPE_EXTERNAL_TRUSTED_DOMAINS
					 ;


    flUserGroupObjectPicker =
						   UGOP_GLOBAL_GROUPS
						|  UGOP_ACCOUNT_GROUPS_SE
						|  UGOP_UNIVERSAL_GROUPS_SE
						|  UGOP_RESOURCE_GROUPS_SE
						|  UGOP_LOCAL_GROUPS
						;


    //
    // Call the API
    //
    PDSSELECTIONLIST    pDsSelList = NULL;
	GETUSERGROUPSELECTIONINFO ugsi;

    ZeroMemory(&ugsi, sizeof ugsi);
	ugsi.cbSize				= sizeof(GETUSERGROUPSELECTIONINFO);
	ugsi.hwndParent			= hWndParent;	// parent window

	
	if ( m_bstrServerName && _tcslen(m_bstrServerName) )
	{
		// use machine name for remote machine
		ugsi.ptzComputerName= m_bstrServerName;
	}
	else
	{
		// or use NULL for local machine
		ugsi.ptzComputerName= NULL;
	}

    ugsi.ptzDomainName		= NULL;
    ugsi.flObjectPicker		= OP_MULTISELECT;
    ugsi.flDsObjectPicker	= flDsObjectPicker;
    ugsi.flStartingScope	= flInitialScope;
    ugsi.flUserGroupObjectPickerSpecifiedDomain = flUserGroupObjectPicker;
	ugsi.flUserGroupObjectPickerOtherDomains	= flUserGroupObjectPicker;
    ugsi.ppDsSelList = &pDsSelList;

	
	// requested attributes:
	LPTSTR	pSidAttr = g_wzObjectSID;
	LPCTSTR	aptzRequestedAttributes[1];

	aptzRequestedAttributes[0] = pSidAttr;

    ugsi.cRequestedAttributes = 1;  // we only need the SID value
    ugsi.aptzRequestedAttributes = (const WCHAR **)aptzRequestedAttributes;

    hr = GetUserGroupSelection(&ugsi);

    if (SUCCEEDED(hr) && hr != S_FALSE )
    {
		// when user selected "Cancel", ObjectPicker will return S_FALSE

		// get selected SIDs
		hr = AddSelectionSidsToGroup( pDsSelList );
    }

    if (pDsSelList)
    {
        FreeDsSelectionList(pDsSelList);
    }


#endif // OLD_OBJECT_PICKER


	return hr;
}



/////////////////////////////////////////////////////////////////////////////
// CDisplayGroupsDialog



//////////////////////////////////////////////////////////////////////////////
/*++

CDisplayGroupsDialog::CDisplayGroupsDialog

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CDisplayGroupsDialog::CDisplayGroupsDialog( GroupList *pGroups )
{	
	TRACE_FUNCTION("CDisplayGroupsDialog::CDisplayGroupsDialog");
	
	m_pGroups = pGroups;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CDisplayGroupsDialog::~CDisplayGroupsDialog

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CDisplayGroupsDialog::~CDisplayGroupsDialog()
{

}



//////////////////////////////////////////////////////////////////////////////
/*++

CDisplayGroupsDialog::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CDisplayGroupsDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	TRACE_FUNCTION("CDisplayGroupsDialog::OnInitDialog");

	m_hWndGroupList = GetDlgItem(IDC_LIST_GROUPS);

	//
	// first, set the list box to 2 columns
	//
	LVCOLUMN lvc;
	int iCol;
	WCHAR  achColumnHeader[256];
	HINSTANCE hInst;

	// initialize the LVCOLUMN structure
	lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvc.fmt = LVCFMT_LEFT;
	
	lvc.cx = 300;
	lvc.pszText = achColumnHeader;

	// first column header: name
	hInst = _Module.GetModuleInstance();

	::LoadStringW(hInst, IDS_DISPLAY_GROUPS_FIRSTCOLUMN, achColumnHeader, sizeof(achColumnHeader)/sizeof(achColumnHeader[0]));
	lvc.iSubItem = 0;
	ListView_InsertColumn(m_hWndGroupList, 0,  &lvc);

	//
	// populate the list control with data
	//
	if ( ! PopulateGroupList( 0 ) )
	{		
		ErrorTrace(ERROR_NAPMMC_SELATTRDLG, "PopulateRuleAttrs() failed");
		return 0;
	
	}

	// Set some items based on whether the list is empty or not.
	if( m_pGroups->size() )
	{

		// Select the first item.
		ListView_SetItemState(m_hWndGroupList, 0, LVIS_SELECTED, LVIS_SELECTED);
	
	}
	else
	{

		// The list is empty -- disable the OK button.
		::EnableWindow(GetDlgItem(IDOK), FALSE);

		// Make sure the Remove button is not enabled initially.
		::EnableWindow(GetDlgItem(IDC_BUTTON_REMOVE_GROUP), FALSE);

	}


#ifdef DEBUG
	m_pGroups->DebugPrintGroups();
#endif // DEBUG





	// Set the listview control so that double-click anywhere in row selects.
	ListView_SetExtendedListViewStyleEx(m_hWndGroupList, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);
	

	return 1;  // Let the system set the focus
}



//+---------------------------------------------------------------------------
//
// Function:  OnListViewDbclk
//
// Class:	  CDisplayGroupsDialog
//
// Synopsis:  handle the case where the user has changed a selection
//			  enable/disable OK, CANCEL button accordingly
//
// Arguments: int idCtrl - ID of the list control
//            LPNMHDR pnmh - notification message
//            BOOL& bHandled - handled or not?
//
// Returns:   LRESULT -
//
// History:   Created Header    byao 2/19/98 11:15:30 PM
//				modified mmaguire 08/12/98 for use in Group List dialog
//
//+---------------------------------------------------------------------------
//LRESULT CDisplayGroupsDialog::OnListViewDbclk(int idCtrl,
//										 LPNMHDR pnmh,
//										 BOOL& bHandled)
//{
//	TRACE_FUNCTION("CDisplayGroupsDialog::OnListViewDbclk");
//
//	return OnAdd(idCtrl, IDC_BUTTON_ADD_CONDITION, m_hWndGroupList, bHandled);  // the same as ok;
//}



//////////////////////////////////////////////////////////////////////////////
/*++

CDisplayGroupsDialog::OnAdd

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CDisplayGroupsDialog::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

	TRACE_FUNCTION("CDisplayGroupsDialog::OnAdd");

	HRESULT hr;

#ifdef DEBUG
	m_pGroups->DebugPrintGroups();
#endif // DEBUG


	// Store the previous size of the list.
	int iSize = m_pGroups->size();

	//
	// NTGroups Picker
    //
	hr = m_pGroups->PickNtGroups( m_hWnd );

	
#ifdef DEBUG
	m_pGroups->DebugPrintGroups();
#endif // DEBUG


	//
	// PickNtGroups will return S_FALSE when user cancelled out of the dialog.
	//
	if ( SUCCEEDED(hr) && hr != S_FALSE )
	{
		// Add the new groups to the display's list.
		PopulateGroupList( iSize );

		// Make sure the OK button is enabled.
		::EnableWindow(GetDlgItem(IDOK), TRUE);

	}
	else
	{
		ErrorTrace(ERROR_NAPMMC_NTGCONDITION, "NTGroup picker failed, err = %x", hr);

		if ( hr == E_NOTIMPL )
		{
			// we return this error whether the SID value can't be retrieved
			ShowErrorDialog( m_hWnd,
							IDS_ERROR_OBJECT_PICKER_NO_SIDS,
							NULL,
							hr
						);
		}
		else if ( hr != S_FALSE )
		{
			ShowErrorDialog( m_hWnd,
							IDS_ERROR_OBJECT_PICKER,
							NULL,
							hr
						);
		}
	}

	// ISSUE: This function wants an LRESULT, not and HRESULT
	// -- not sure of importance of return code here.
	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CDisplayGroupsDialog::OnRemove

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CDisplayGroupsDialog::OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	TRACE_FUNCTION("CDisplayGroupsDialog::OnRemove");

#ifdef DEBUG
	m_pGroups->DebugPrintGroups();
#endif // DEBUG


	//
    // Has the user chosen any condition type yet?
    //
	LVITEM lvi;

    // Find out what's selected.
	// MAM: This is not what we want here:		int iIndex = ListView_GetSelectionMark(m_hWndGroupList);
	int iSelected = ListView_GetNextItem(m_hWndGroupList, -1, LVNI_SELECTED);
	DebugTrace(DEBUG_NAPMMC_SELATTRDLG, "Selected item: %d", iSelected );
	
	if( -1 != iSelected )
	{
		// The index inside the attribute list is stored as the lParam of this item.

		m_pGroups->erase( m_pGroups->begin() + iSelected );
		ListView_DeleteItem(m_hWndGroupList, iSelected );

		// The user may have removed all of the groups, leaving an
		// empty listnd out if the user should be able to click OK.
		if( ! m_pGroups->size() )
		{
			// Yes, disable the ok button.
			::EnableWindow(GetDlgItem(IDOK), FALSE);
		}

		// Try to make sure that the same position remains selected.
		if( ! CustomListView_SetItemState(m_hWndGroupList, iSelected, LVIS_SELECTED, LVIS_SELECTED) )
		{
			// We failed to select the same position, probably because we just
			// deleted the last element.  Try to select the position before it.
			ListView_SetItemState(m_hWndGroupList, iSelected -1, LVIS_SELECTED, LVIS_SELECTED);
		}


	}

	
#ifdef DEBUG
	m_pGroups->DebugPrintGroups();
#endif // DEBUG


	return 0;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CDisplayGroupsDialog::OnOK

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CDisplayGroupsDialog::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	TRACE_FUNCTION("CDisplayGroupsDialog::OnOK");

	EndDialog(TRUE);
	return 0;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CDisplayGroupsDialog::OnCancel

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CDisplayGroupsDialog::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	TRACE_FUNCTION("+NAPMMC+:# CDisplayGroupsDialog::OnCancel\n");

	// FALSE will be the return value of the DoModal call on this dialog.
	EndDialog(FALSE);
	return 0;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CDisplayGroupsDialog::PopulateGroupList

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CDisplayGroupsDialog::PopulateGroupList( int iStartIndex )
{
	TRACE_FUNCTION("CDisplayGroupsDialog::PopulateCondAttrs");

	int iIndex;
	WCHAR wzText[MAX_PATH];
	WCHAR * pszNextGroup;

	LVITEM lvi;
	
	lvi.mask = LVIF_TEXT | LVIF_STATE;
	lvi.state = 0;
	lvi.stateMask = 0;
	lvi.iSubItem = 0;
	lvi.iItem = iStartIndex;


	GroupList::iterator thePair;
	for( thePair = m_pGroups->begin() + iStartIndex ; thePair != m_pGroups->end(); ++thePair )
	{
		lvi.pszText = thePair->second;
		ListView_InsertItem(m_hWndGroupList, &lvi);

//		ListView_SetItemText(m_hWndGroupList, iIndex, 1, L"@Not yet implemented");
        		
		++lvi.iItem;
    }

	return TRUE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CDisplayGroupsDialog::OnListViewItemChanged

We enable or disable the Remove button depending on whether an item is selected.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CDisplayGroupsDialog::OnListViewItemChanged(int idCtrl,
											   LPNMHDR pnmh,
											   BOOL& bHandled)
{
	TRACE_FUNCTION("CDisplayGroupsDialog::OnListViewItemChanged");

    // Find out what's selected.
	int iSelected = ListView_GetNextItem(m_hWndGroupList, -1, LVNI_SELECTED);
	

	if (-1 == iSelected )
	{
		if( ::GetFocus() == GetDlgItem(IDC_BUTTON_REMOVE_GROUP))
			::SetFocus(GetDlgItem(IDC_BUTTON_ADD_GROUP));
			
		// The user selected nothing, let's disable the remove button.
		::EnableWindow(GetDlgItem(IDC_BUTTON_REMOVE_GROUP), FALSE);
	}
	else
	{
		// Yes, enable the remove button.
		::EnableWindow(GetDlgItem(IDC_BUTTON_REMOVE_GROUP), TRUE);
	}


	bHandled = FALSE;
	return 0;
}




#ifdef DEBUG
HRESULT GroupList::DebugPrintGroups()
{
	TRACE_FUNCTION("GroupList::DebugPrintGroups");

	DebugTrace(DEBUG_NAPMMC_SELATTRDLG, "Begin GroupList dump" );
	
	GroupList::iterator thePair;
	for( thePair = begin(); thePair != end(); ++thePair )
	{
		thePair->second;
		DebugTrace(DEBUG_NAPMMC_SELATTRDLG, "Group: %ws  %ws", thePair->first, thePair->second );

    }

	DebugTrace(DEBUG_NAPMMC_SELATTRDLG, "End GroupList dump" );

	return S_OK;
}
#endif // DEBUG


//////////////////////////////////////////////////////////////////////////////
/*++

NTGroup_ListView::AddMoreGroups

--*/
//////////////////////////////////////////////////////////////////////////////
DWORD NTGroup_ListView::AddMoreGroups()
{
	if ( m_hListView == NULL )
		return 0;
		
	// Store the previous size of the list.
	int iSize = GroupList::size();

	//
	// NTGroups Picker
    //
	HRESULT hr = GroupList::PickNtGroups( m_hParent );

	
	//
	// PickNtGroups will return S_FALSE when user cancelled out of the dialog.
	//
	if ( SUCCEEDED(hr) && hr != S_FALSE )
	{
		// Add the new groups to the display's list.
		PopulateGroupList( iSize );
	}
	else
	{
		if ( hr == E_NOTIMPL )
		{
			// we return this error whether the SID value can't be retrieved
			ShowErrorDialog( m_hParent,
							IDS_ERROR_OBJECT_PICKER_NO_SIDS,
							NULL,
							hr
						);
		}
		else if ( hr != S_FALSE )
		{
			ShowErrorDialog( m_hParent,
							IDS_ERROR_OBJECT_PICKER,
							NULL,
							hr
						);
		}
	}

	// ISSUE: This function wants an LRESULT, not and HRESULT
	// -- not sure of importance of return code here.
	return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

NTGroup_ListView::RemoveSelectedGroups

--*/
//////////////////////////////////////////////////////////////////////////////
DWORD NTGroup_ListView::RemoveSelectedGroups()
{
	if ( m_hListView == NULL)
		return 0;
	//
    // Has the user chosen any condition type yet?
    //
	LVITEM lvi;

    // Find out what's selected.
	int iSelected = ListView_GetNextItem(m_hListView, -1, LVNI_SELECTED);
	
	if( -1 != iSelected )
	{
		// The index inside the attribute list is stored as the lParam of this item.

		GroupList::erase( GroupList::begin() + iSelected );
		ListView_DeleteItem(m_hListView, iSelected );

		// Try to make sure that the same position remains selected.
		if( ! CustomListView_SetItemState(m_hListView, iSelected, LVIS_SELECTED, LVIS_SELECTED) )
		{
			// We failed to select the same position, probably because we just
			// deleted the last element.  Try to select the position before it.
			ListView_SetItemState(m_hListView, iSelected -1, LVIS_SELECTED, LVIS_SELECTED);
		}


	}

	return (iSelected != -1 ? 1 : 0);
}


//////////////////////////////////////////////////////////////////////////////
/*++

NTGroup_ListView::PopulateGroupList

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL NTGroup_ListView::PopulateGroupList( int iStartIndex )
{
	if ( m_hListView == NULL)
		return 0;

	int iIndex;
	WCHAR wzText[MAX_PATH];
	WCHAR * pszNextGroup;

	LVITEM lvi;
	
	lvi.mask = LVIF_TEXT | LVIF_STATE;
	lvi.state = 0;
	lvi.stateMask = 0;
	lvi.iSubItem = 0;
	lvi.iItem = iStartIndex;


	GroupList::iterator thePair;
	for( thePair = GroupList::begin() + iStartIndex ; thePair != GroupList::end(); ++thePair )
	{
		lvi.pszText = thePair->second;
		ListView_InsertItem(m_hListView, &lvi);
		++lvi.iItem;
    }

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\policiesnode.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation

Module Name:

    PoliciesNode.h

Abstract:

   Header file for the CPoliciesNode subnode.

   See PoliciesNode.cpp for implementation.

Revision History:
   mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NAP_POLICIES_NODE_H_)
#define _NAP_POLICIES_NODE_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "MeritNode.h"
#include "NodeWithResultChildrenList.h"
//
//
// For include file dependency reasons, we have forward declarations here,
// and include the needed header files in our .cpp files.
//
#include "IASAttrList.h"

class CPolicyNode;
class CPolicyPage1;
class CComponentData;
class CComponent;

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////
#define  EXCLUDE_AUTH_TYPE      0x000000001
#define  EXCLUDE_DEFAULT_FRAMED 0x000000002

class CPoliciesNode : public CNodeWithResultChildrenList< CPoliciesNode, CPolicyNode, CMeritNodeArray<CPolicyNode*>, CComponentData, CComponent >
{

public:
   CPoliciesNode( 
                  CSnapInItem* pParentNode,
                  LPTSTR       pszServerAddress,
                  bool         fExtendingIAS
                );

   HRESULT SetSdo( 
                    ISdo*              pSdoMachine,
                    ISdoDictionaryOld* pSdoDictionary,
                    BOOL               fSdoConnected,
                    BOOL               fUseDS,
                    BOOL               fDSAvailable
                 );

   HRESULT SetName(
                     BOOL bPoliciesFromDirectoryService, 
                     LPWSTR szPolicyLocation, 
                     IConsole * pConsole 
                  );

   ~CPoliciesNode();

   // we can't do this because of the way this macro was
   // not written to support subclassing
// BEGIN_SNAPINCOMMAND_MAP(CPoliciesNode, FALSE)
// END_SNAPINCOMMAND_MAP()

   SNAPINMENUID(IDM_POLICIES_NODE)

   BEGIN_SNAPINTOOLBARID_MAP(CPoliciesNode)
   // SNAPINTOOLBARID_ENTRY(IDR_POLICIES_TOOLBAR)
   END_SNAPINTOOLBARID_MAP()

   BEGIN_SNAPINCOMMAND_MAP(CPolicyNode, TRUE)
      SNAPINCOMMAND_ENTRY(ID_MENUITEM_POLICIES_TOP__NEW_POLICY, OnNewPolicy)
      SNAPINCOMMAND_ENTRY(ID_MENUITEM_POLICIES_NEW__POLICY, OnNewPolicy)
   END_SNAPINCOMMAND_MAP() 

   HRESULT OnNewPolicy( bool &bHandled, CSnapInObjectRootBase* pObj );
   void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags);

   STDMETHOD(FillData)(CLIPFORMAT cf, LPSTREAM pStream);
   

   HRESULT  DataRefresh(ISdo* pSdo, ISdoDictionaryOld* pDic);
   
   virtual HRESULT OnRefresh(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         );

   OLECHAR* GetResultPaneColInfo( int nCol );

   CComponentData * GetComponentData( void );

   HRESULT InsertColumns( IHeaderCtrl* pHeaderCtrl );

   HRESULT PopulateResultChildrenList( void );

   HRESULT MoveUpChild( CPolicyNode* pChildNode );
   HRESULT MoveDownChild( CPolicyNode* pChildNode );
   HRESULT NormalizeMerit( CPolicyNode* pAddedChildNode );

   HRESULT RemoveChild( CPolicyNode* pPolicyNode);

   int      GetChildrenCount();

   CPolicyNode* FindChildWithName(LPCTSTR pszName); // search for a child


   bool      m_fExtendingIAS; // are we extending IAS or something else?

   HRESULT AddDefaultProfileAttrs(
              ISdo*  pProfileSdo, 
              DWORD dwFlagExclude = 0
              );

   HRESULT AddProfAttr(ISdoCollection* pProfAttrCollectionSdo,
                  ATTRIBUTEID    AttrId,
                  VARIANT*    pvarValue
                  );

protected:
   BOOL  CheckActivePropertyPages();


   virtual HRESULT SetVerbs( IConsoleVerb * pConsoleVerb );

    //
    // smart pointer to the NAP collection interface
    //
   CComPtr<ISdoCollection> m_spPoliciesCollectionSdo;
   CComPtr<ISdoCollection> m_spProfilesCollectionSdo;
   CComPtr<ISdoDictionaryOld> m_spDictionarySdo;
   CComPtr<ISdo>        m_spDSNameSpaceSdo;
   CComPtr<ISdo>        m_spLocalNameSpaceSdo;
   CComPtr<ISdo>        m_spServiceSdo;

   CComPtr<IIASNASVendors> m_spIASNASVendors;


   // Smart pointer to interface for telling service to reload data.
   CComPtr<ISdoServiceControl>   m_spSdoServiceControl;

   LPTSTR       m_pszServerAddress; // address of the server that NAP currently
                            // connect to
   CIASAttrList m_AttrList;
   BOOL      m_fUseDS;       // shall we use DS for policy location?
   BOOL      m_fDSAvailable;  // is DS available for that machine?

public:  
   BOOL      m_fSdoConnected; // whether the SDOs have been connected

private:
   enum ServerType
   {
      unknown,
      nt4,
      win2k,
      win5_1_or_later
   } m_serverType;

   HRESULT GetServerType(); 
   bool IsWin2kServer() throw();

};

#endif // _NAP_POLICIES_NODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\ownthreaddialog.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ownthreaddialog.h
//
//--------------------------------------------------------------------------



void CreateNewStatisticsWindow(StatsDialog *pWndStats,
							   HWND hWndParent,
							   UINT	nIDD)
{								  
	ModelessThread *	pMT;

	// If the dialog is still up, don't create a new one
	if (pWndStats->GetSafeHwnd())
	{
		::SetActiveWindow(pWndStats->GetSafeHwnd());
		return;
	}

	pMT = new ModelessThread(hWndParent,
							 nIDD,
							 pWndStats->GetSignalEvent(),
							 pWndStats);
	pMT->CreateThread();
}



void WaitForStatisticsWindow(StatsDialog *pWndStats)
{
	if (pWndStats->GetSafeHwnd())
	{
		// Post a cancel to that window
		// Do an explicit post so that it executes on the other thread
		pWndStats->PostMessage(WM_COMMAND, IDCANCEL, 0);

		// Now we need to wait for the event to be signalled so that
		// its memory can be cleaned up
		WaitForSingleObject(pWndStats->GetSignalEvent(), INFINITE);
	}
	
}



void StatsDialog::PostRefresh()
{
	if (GetSafeHwnd())
		PostMessage(WM_COMMAND, IDC_STATSDLG_BTN_REFRESH);
}


void StatsDialog::OnCancel()
{
	DeleteAllItems();
	
	DestroyWindow();

	// Explicitly kill this thread.
	AfxPostQuitMessage(0);
}



StatsDialog::~StatsDialog()
{
	if (m_hEventThreadKilled)
		::CloseHandle(m_hEventThreadKilled);
	m_hEventThreadKilled = 0;
}


StatsDialog::StatsDialog(DWORD dwOptions) :
	m_dwOptions(dwOptions),
	m_ulId(0),
	m_pConfig(NULL),
	m_bAfterInitDialog(FALSE),
	m_fSortDirection(0)
{
	m_sizeMinimum.cx = m_sizeMinimum.cy = 0;

	m_hEventThreadKilled = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	Assert(m_hEventThreadKilled);

	// Initialize the array of buttons
	::ZeroMemory(m_rgBtn, sizeof(m_rgBtn));
	m_rgBtn[INDEX_CLOSE].m_ulId = IDCANCEL;
	m_rgBtn[INDEX_REFRESH].m_ulId = IDC_STATSDLG_BTN_REFRESH;
	m_rgBtn[INDEX_SELECT].m_ulId = IDC_STATSDLG_BTN_SELECT_COLUMNS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\precompiled.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       precompiled.cpp
//
//--------------------------------------------------------------------------

// Precompiled.cpp : source file that includes just the standard includes
//  Precompiled.pch will be the pre-compiled header
//  Precompiled.obj will contain the pre-compiled type information

#include "Precompiled.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\policylocdlg.cpp ===
/****************************************************************************************
 * NAME:	PolicyLocDlg.cpp
 *
 * CLASS:	CPolicyLocationDialog
 *
 * OVERVIEW
 *
 * Internet Authentication Server: 
 *			This dialog box is used to change the Network Access Policy Location 
 *
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History:	
 *				4/12/98		Created by	Byao	
 *
 *****************************************************************************************/

#include "Precompiled.h"
#include "PolicyLocDlg.h"

// Constructor/Destructor
CPolicyLocationDialog::CPolicyLocationDialog(BOOL fChooseDS, BOOL fDSAvailable)
{
	m_fChooseDS		= fChooseDS;
	m_fDSAvailable	= fDSAvailable;
}

CPolicyLocationDialog::~CPolicyLocationDialog()
{
}


LRESULT CPolicyLocationDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	TRACE_FUNCTION("CPolicyLocationDialog::OnInitDialog");

	if ( !m_fDSAvailable )
	{
		::EnableWindow(GetDlgItem(IDC_RADIO_STORE_ACTIVEDS), FALSE);
	}

	if ( m_fChooseDS )
	{
		CheckDlgButton(IDC_RADIO_STORE_ACTIVEDS, BST_CHECKED);
		CheckDlgButton(IDC_RADIO_STORE_LOCAL, BST_UNCHECKED);
	}
	else
	{
		CheckDlgButton(IDC_RADIO_STORE_ACTIVEDS, BST_UNCHECKED);
		CheckDlgButton(IDC_RADIO_STORE_LOCAL, BST_CHECKED);
	}

	return 1;  // Let the system set the focus
}


LRESULT CPolicyLocationDialog::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	TRACE_FUNCTION("CPolicyLocationDialog::OnOK");

	EndDialog(wID);
	return 0;
}


LRESULT CPolicyLocationDialog::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	TRACE_FUNCTION("CPolicyLocationDialog::OnCancel");

	EndDialog(wID);
	return 0;
}



//+---------------------------------------------------------------------------
//
// Function:  CPolicyLocationDialog::OnActiveDS
//
// Synopsis:  User decided to use policies from the Active Directory
//
// Arguments: WORD wNotifyCode - 
//            WORD wID - 
//            HWND hWndCtl - 
//            BOOL& bHandled - 
//
// Returns:   LRESULT - 
//
// History:   Created Header    byao	4/13/98 5:26:42 PM
//
//+---------------------------------------------------------------------------
LRESULT CPolicyLocationDialog::OnActiveDS(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	TRACE_FUNCTION("CPolicyLocationDialog::OnActiveDS");

	if ( wNotifyCode == BN_CLICKED )
	{
		CheckDlgButton(IDC_RADIO_STORE_ACTIVEDS, BST_CHECKED);
		CheckDlgButton(IDC_RADIO_STORE_LOCAL, BST_UNCHECKED);
		m_fChooseDS = TRUE;
	}

	return 0;
}



//+---------------------------------------------------------------------------
//
// Function:  CPolicyLocationDialog::OnLocale
//
// Synopsis:  User has decided to use policies from the local machine
//
// Arguments: WORD wNotifyCode - 
//            WORD wID - 
//            HWND hWndCtl - 
//            BOOL& bHandled - 
//
// Returns:   LRESULT - 
//
// History:   Created Header    byao	4/13/98 5:27:04 PM
//
//+---------------------------------------------------------------------------
LRESULT CPolicyLocationDialog::OnLocale(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	TRACE_FUNCTION("CPolicyLocationDialog::OnLocale");

	if ( wNotifyCode == BN_CLICKED )
	{
		CheckDlgButton(IDC_RADIO_STORE_ACTIVEDS, BST_UNCHECKED);
		CheckDlgButton(IDC_RADIO_STORE_LOCAL, BST_CHECKED);
		m_fChooseDS = FALSE;
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\policylocdlg.h ===
/****************************************************************************************
 * NAME:	PolicyLocDlg.h
 *
 * CLASS:	CPolicyLocationDialog
 *
 * OVERVIEW
 *
 * Internet Authentication Server: NAP Location dialog
 *			This dialog box is used to change the Network Access Policy Location 
 *
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History:	
 *				4/12/98		Created by	Byao	
 *
 *****************************************************************************************/

#ifndef _POLICYLOCDLG_H_
#define _POLICYLOCDLG_H_

#include "dialog.h"

/////////////////////////////////////////////////////////////////////////////
// CPolicyLocationDialog

class CPolicyLocationDialog;
typedef CIASDialog<CPolicyLocationDialog, FALSE>  LOCDLGFALSE;

class CPolicyLocationDialog: public CIASDialog<CPolicyLocationDialog, FALSE>
{
public:
	CPolicyLocationDialog(BOOL fChooseDS, BOOL fDSAvaialble);
	~CPolicyLocationDialog();

	enum { IDD = IDD_DIALOG_POLICY_LOCATION };

BEGIN_MSG_MAP(CPolicyLocationDialog)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	COMMAND_ID_HANDLER(IDC_RADIO_STORE_ACTIVEDS, OnActiveDS)
	COMMAND_ID_HANDLER(IDC_RADIO_STORE_LOCAL, OnLocale)

	CHAIN_MSG_MAP(LOCDLGFALSE)
END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnLocale(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnActiveDS(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

public:
	BOOL	m_fChooseDS;
	BOOL	m_fDSAvailable;
};


#endif //_POLICYLOCDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\policiesnode.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation

Module Name:

    PoliciesNode.cpp

Abstract:

   Implementation file for the CPoliciesNode class.


Revision History:
   mmaguire 12/15/97 - created

--*/
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "PoliciesNode.h"
#include "ComponentData.h" // this must be included before NodeWithResultChildrenList.cpp
#include "Component.h"     // this must be included before NodeWithResultChildrenList.cpp
#include "NodeWithResultChildrenList.cpp" // Implementation of template class.
//
//
// where we can find declarations needed in this file:
//
#include <time.h>
#include "PolicyLocDlg.h"
#include "LocWarnDlg.h"
#include "PolicyNode.h"
#include "MachineNode.h"
#include "mmcUtility.h"
#include "NapUtil.h"
#include "SafeArray.h"
#include "ChangeNotification.h"
#include "sdoias.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// CPoliciesNode::CPoliciesNode
// 
//////////////////////////////////////////////////////////////////////////////
CPoliciesNode::CPoliciesNode( 
                  CSnapInItem* pParentNode,
                  LPTSTR       pszServerAddress,
                  bool         fExtendingIAS
                  )
:CNodeWithResultChildrenList<CPoliciesNode, CPolicyNode, CMeritNodeArray<CPolicyNode*>, CComponentData, CComponent> (pParentNode, (!fExtendingIAS)?RAS_HELP_INDEX:0),
 m_fExtendingIAS(fExtendingIAS),
 m_serverType(unknown)
{
   TRACE_FUNCTION("CPoliciesNode::CPoliciesNode");

   TCHAR lpszName[NAP_MAX_STRING];
   int nLoadStringResult;

   // always initialized to not connected and local
   m_fSdoConnected = FALSE;
   m_fUseDS    = FALSE;
   m_fDSAvailable  = FALSE;
   
   try
   {
      // Set the display name for this object
      nLoadStringResult = LoadString( _Module.GetResourceInstance(),
                              IDS_POLICIES_NODE,
                              lpszName,
                              NAP_MAX_STRING
                           );
      _ASSERT( nLoadStringResult > 0 );

      m_bstrDisplayName = lpszName;

      // In IComponentData::Initialize, we are asked to inform MMC of
      // the icons we would like to use for the scope pane.
      // Here we store an index to which of these images we
      // want to be used to display this node
      m_scopeDataItem.nImage =      IDBI_NODE_POLICIES_OK_CLOSED;
      m_scopeDataItem.nOpenImage =  IDBI_NODE_POLICIES_OK_OPEN;

      // initialize the machine name
      m_pszServerAddress = pszServerAddress;
   }
   catch(...)
   {
      throw;
   }
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPoliciesNode::~CPoliciesNode

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CPoliciesNode::~CPoliciesNode()
{
   TRACE_FUNCTION("CPoliciesNode::~CPoliciesNode");
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPoliciesNode::GetResultPaneColInfo

See CSnapinNode::GetResultPaneColInfo (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
OLECHAR* CPoliciesNode::GetResultPaneColInfo(int nCol)
{
   TRACE_FUNCTION("CPoliciesNode::GetResultPaneColInfo");

   if (nCol == 0 && m_bstrDisplayName != NULL)
      return m_bstrDisplayName;
   
   return NULL;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPoliciesNode::SetVerbs

See CSnapinNode::SetVerbs (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPoliciesNode::SetVerbs( IConsoleVerb * pConsoleVerb )
{
   TRACE_FUNCTION("CPoliciesNode::SetVerbs");

   return pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );

   // We don't want the user deleting or renaming this node, so we
   // don't set the MMC_VERB_RENAME or MMC_VERB_DELETE verbs.
   // By default, when a node becomes selected, these are disabled.
   // hr = pConsoleVerb->SetVerbState( MMC_VERB_OPEN, ENABLED, TRUE );
   // DebugTrace(DEBUG_NAPMMC_POLICIESNODE, "SetVerState() returns %x", hr);
   // hr = pConsoleVerb->SetDefaultVerb( MMC_VERB_OPEN );
   // DebugTrace(DEBUG_NAPMMC_POLICIESNODE, "SetDefaultVerb() returns %x", hr);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPoliciesNode::InsertColumns

See CNodeWithResultChildrenList::InsertColumns (which this method overrides)
for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPoliciesNode::InsertColumns( IHeaderCtrl* pHeaderCtrl )
{
   TRACE_FUNCTION("CPoliciesNode::OnShowInsertColumns");
   
   TCHAR    tzColumnTitle1[IAS_MAX_STRING];
   TCHAR    tzColumnTitle2[IAS_MAX_STRING];
   TCHAR    tzColumnTitle3[IAS_MAX_STRING];

   HRESULT     hr = S_OK;
   HINSTANCE   hInstance = _Module.GetResourceInstance();
   int         iRes;

   iRes = LoadString(hInstance, IDS_POLICY_COLUMN_TITLE1, tzColumnTitle1, IAS_MAX_STRING );
   _ASSERT( iRes > 0 );

   iRes = LoadString(hInstance, IDS_POLICY_COLUMN_TITLE2, tzColumnTitle2, IAS_MAX_STRING );
   _ASSERT( iRes > 0 );

   hr = pHeaderCtrl->InsertColumn( 0, tzColumnTitle1, 0, 260 );
   _ASSERT( S_OK == hr );

   hr = pHeaderCtrl->InsertColumn( 1, tzColumnTitle2, 0, 50 );
   _ASSERT( S_OK == hr );

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPoliciesNode::UpdateMenuState

--*/
//////////////////////////////////////////////////////////////////////////////
void CPoliciesNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
   TRACE_FUNCTION("CPoliciesNode::UpdateMenuState");

   // Check for preconditions:
   // None.

   //
   // disable "New Policy" and "Change Policy Location" menu when
   // not connected
   //
   if (id == ID_MENUITEM_POLICIES_TOP__POLICY_LOCATION  ||
       id == ID_MENUITEM_POLICIES_TOP__NEW_POLICY       ||  
       id == ID_MENUITEM_POLICIES_NEW__POLICY )
   {
      if (!m_fSdoConnected )
      {
         * flags = MFS_GRAYED;
         return;
      }
      else
      {
         *flags = MFS_ENABLED;
         return;
      }
   }
   return;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPoliciesNode::OnRefresh

See CSnapinNode::OnRefresh (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPoliciesNode::OnRefresh(   
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         )
{
   HRESULT   hr = S_OK;

   CWaitCursor WC;

   CComPtr<IConsole> spConsole;

   // We need IConsole
   if( pComponentData != NULL )
   {
       spConsole = ((CComponentData*)pComponentData)->m_spConsole;
   }
   else
   {
       spConsole = ((CComponent*)pComponent)->m_spConsole;
   }
   _ASSERTE( spConsole != NULL );

   // if there is any property page open
   int c = m_ResultChildrenList.GetSize();

   while ( c-- > 0)
   {
      CPolicyNode* pSub = m_ResultChildrenList[c];
      // Call our base class's method to remove the child from its list.
      // The RemoveChild method takes care of removing this node from the
      // UI's list of nodes under the parent and performing a refresh of all relevant views.
      // This returns S_OK if a property sheet for this object already exists
      // and brings that property sheet to the foreground.
      // It returns S_FALSE if the property sheet wasn't found.
      hr = BringUpPropertySheetForNode(
              pSub
            , pComponentData
            , pComponent
            , spConsole
            );

      if( S_OK == hr )
      {
         // We found a property sheet already up for this node.
         ShowErrorDialog( NULL, IDS_ERROR_CLOSE_PROPERTY_SHEET, NULL, hr, 0,  spConsole );
         return hr;
      }
   }

   // reload SDO from
   hr =  ((CMachineNode *) m_pParentNode)->DataRefresh();

   // refresh the node
   hr = CNodeWithResultChildrenList< CPoliciesNode, CPolicyNode, CMeritNodeArray<CPolicyNode*>, CComponentData, CComponent >::OnRefresh( 
           arg, param, pComponentData, pComponent, type);
   
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPoliciesNode::PopulateResultChildrenList

See CNodeWithResultChildrenList::PopulateResultChildrenList (which this method overrides)
for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPoliciesNode::PopulateResultChildrenList( void )
{
   TRACE_FUNCTION("CPoliciesNode::PopulateResultChildrenList");

   HRESULT hr = S_OK;

   CComPtr<IUnknown>    spUnknown;
   CComPtr<IEnumVARIANT>   spEnumVariant;
   CComVariant          spVariant;
   long              ulCount;
   ULONG             ulCountReceived;

   if ( !m_fSdoConnected )
   {
      return E_FAIL;
   }

   if( m_spPoliciesCollectionSdo == NULL )
   {
      ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "NULL policies collection");
      return S_FALSE;   // Is there a better error to return here?
   }

   //
   // has the policies been populated already?
   //
   if ( m_bResultChildrenListPopulated )
   {
      return S_OK;
   }

   m_ResultChildrenList.RemoveAll();

   //
   // how many policies do we have right now?
   //
   m_spPoliciesCollectionSdo->get_Count( & ulCount );
   DebugTrace(DEBUG_NAPMMC_POLICIESNODE, "Number of policies: %d", ulCount);

   if( ulCount > 0 )
   {
      //
      // Get the enumerator for the policies collection.
      //
      hr = m_spPoliciesCollectionSdo->get__NewEnum( (IUnknown **) & spUnknown );
      if ( FAILED(hr) )
      {
         ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "get__NewEnum() failed, err = %x", hr);
         ShowErrorDialog( NULL, IDS_ERROR_SDO_ERROR_ENUMPOLICY, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
         return hr;
      }

      hr = spUnknown->QueryInterface( IID_IEnumVARIANT, (void **) &spEnumVariant );
      if ( FAILED(hr) )
      {
         ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "QueryInterface(IEnumVARIANT) failed, err = %x", hr);
         ShowErrorDialog( NULL, IDS_ERROR_SDO_ERROR_QUERYINTERFACE, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
         return hr;
      }

      _ASSERTE( spEnumVariant != NULL );
      spUnknown.Release();

      // Get the first item.
      hr = spEnumVariant->Next( 1, & spVariant, &ulCountReceived );
      while( SUCCEEDED( hr ) && ulCountReceived == 1 )
      {  
         _ASSERTE( spVariant.vt == VT_DISPATCH );
         _ASSERTE( spVariant.pdispVal != NULL );

         CComPtr<ISdo>  spPolicySdo;
         CComPtr<ISdo>  spProfileSdo;
         CPolicyNode*   pPolicyNode;
         CComVariant       varPolicyName;
         CComVariant       varProfileName;

         //
         // before we create the policy object, we need to make sure the corresponding
         // profile object is also there
         //
         hr = spVariant.pdispVal->QueryInterface( IID_ISdo, (void **) &spPolicySdo );
         _ASSERTE( SUCCEEDED( hr ) );

         //
         // try to find the profile that's associated with this policy sdo
         //
         hr = spPolicySdo->GetProperty(PROPERTY_POLICY_PROFILE_NAME, &varProfileName);
         if ( SUCCEEDED(hr) )
         {
            // found the profile name from the sdo, search whether it
            // is in the profile collection
            _ASSERTE( V_VT(&varProfileName) == VT_BSTR );

            ATLTRACE(_T("PROFILE NAME:%ws\n"), V_BSTR(&varProfileName) );

            DebugTrace(DEBUG_NAPMMC_POLICIESNODE,
                     "Profile name for this policy: %ws",
                     V_BSTR(&varProfileName)
                    );
            CComPtr<IDispatch> spDispatch;

            spDispatch.p = NULL;
            hr = m_spProfilesCollectionSdo->Item(&varProfileName, &spDispatch.p);
            
            if ( !SUCCEEDED(hr) )
            {
               // can't find this profile
               ErrorTrace(ERROR_NAPMMC_POLICIESNODE,
                        "profile %ws not found, err =  %x",
                        V_BSTR(&varProfileName),
                        hr
                       );
               ATLTRACE(_T("PROFILE not found in the profile collection!!!!\n"));
               ShowErrorDialog( NULL, IDS_ERROR_PROFILE_NOEXIST, V_BSTR(&varProfileName), S_OK, USE_DEFAULT, GetComponentData()->m_spConsole );
               goto get_next_policy;
            }

            _ASSERTE( spDispatch.p );

            hr = spDispatch->QueryInterface(IID_ISdo, (VOID**)(&spProfileSdo) );
            if ( ! SUCCEEDED(hr) )
            {
               // invalid profile SDO pointer
               ErrorTrace(ERROR_NAPMMC_POLICIESNODE,
                        "can't get the ISdo pointer for this profile , err = %x",
                        hr
                       );
               ATLTRACE(_T("can't get profile SDO pointer!!!!\n"));
               ShowErrorDialog( NULL, IDS_ERROR_PROFILE_NOEXIST, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
               goto get_next_policy;
            }              
         }
         else
         {
            //
            // can't find profile name for this policy
            // Which means the information in this policy is corrupted
            //
            ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "can't get profile name for this policy, err = %x", hr);
   
            //
            // let's get the policy name so we can report a meaningful error msg
            //
            hr = spPolicySdo->GetProperty(PROPERTY_SDO_NAME, &varPolicyName);
            if ( SUCCEEDED(hr) )
            {
               ATLTRACE(_T("PROFILE not found in the profile collection!!!!\n"));
               ShowErrorDialog( NULL, IDS_ERROR_NO_PROFILE_NAME, V_BSTR(&varPolicyName), S_OK, USE_DEFAULT, GetComponentData()->m_spConsole );
            }
            else
            {
               // can't even get the policy name
               ShowErrorDialog( NULL, IDS_ERROR_NO_PROFILE_NAME, NULL, S_OK, USE_DEFAULT, GetComponentData()->m_spConsole );
            }
            goto get_next_policy;
         }

         //
         // now we have both profile and policy
         //
         
         // Create a new node UI object to represent the sdo object.
         pPolicyNode = new CPolicyNode(  this,           // always a pointer to itself
                                 m_pszServerAddress, // server address
                                 &m_AttrList,      // list of all attributes
                                 FALSE,            // not a brand new node
                                 m_fUseDS,       // use DS or not??
                                 IsWin2kServer() // is a Win2k machine?
                              );
         if( NULL == pPolicyNode )
         {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "Can't create policy node, err = %x", hr);
            ShowErrorDialog( NULL, IDS_ERROR_CANT_CREATE_POLICY, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
            goto  get_next_policy;
         }

         // Pass the newly created node its SDO pointer.
         hr = pPolicyNode->SetSdo(     spPolicySdo
                              , m_spDictionarySdo
                              , spProfileSdo
                              , m_spProfilesCollectionSdo
                              , m_spPoliciesCollectionSdo
                              , m_spSdoServiceControl
                              );
         _ASSERTE( SUCCEEDED( hr ) );
         
         hr = pPolicyNode->LoadSdoData();
         DebugTrace(DEBUG_NAPMMC_POLICIESNODE, "pPoliciNode->LoadSdoData() returned %x", hr);

         // Add the newly created node to the list of Policys.
         AddChildToList(pPolicyNode);

         if ( !SUCCEEDED(hr) )
         {
            //
            // this is actually a hack: we are just trying to save coding work
            // because we can use RemoveChild() for this bad object so all the SDO
            // pointers can also be removed
            //
            RemoveChild(pPolicyNode);
         }

get_next_policy:  // now get the next policy

         // Clear the variant of whatever it had --
         // this will release any data associated with it.
         spVariant.Clear();

         // Get the next item.
         hr = spEnumVariant->Next( 1, & spVariant, &ulCountReceived );
      }
   }
   else
   {
      // There are no items in the enumeration
      // Do nothing.
   }

   //
   // now we need to reset the merit value of every child node, for example,
   // maybe there're only two children, with merit value of 20 and 100. We need
   // to reset them to 1 and 2.
   //
   for (int iIndex=0; iIndex<m_ResultChildrenList.GetSize(); iIndex++)
   {
      m_ResultChildrenList[iIndex]->SetMerit(iIndex+1);
   }

   m_bResultChildrenListPopulated = TRUE;

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPoliciesNode::GetComponentData

This method returns our unique CComponentData object representing the scope
pane of this snapin.

It relies upon the fact that each node has a pointer to its parent,
except for the root node, which instead has a member variable pointing
to CComponentData.

This would be a useful function to use if, for example, you need a reference
to some IConsole but you weren't passed one.  You can use GetComponentData
and then use the IConsole pointer which is a member variable of our
CComponentData object.

--*/
//////////////////////////////////////////////////////////////////////////////
CComponentData * CPoliciesNode::GetComponentData( void )
{
   TRACE_FUNCTION("CPoliciesNode::GetComponentData");

   return ((CMachineNode *) m_pParentNode)->GetComponentData();
}


//+---------------------------------------------------------------------------
//
// Function:  SetSdo
//
// Class: CPoliciesNode
//
// Synopsis:  Initialize the CPoliciesNode using the SDO pointers
//
// Arguments: ISdo*           pMachineSdo    - Server SDO
//         ISdoDictionaryOld* pDictionarySdo - Sdo Dictionary
//          BOOL           fSdoConnected  - is connection successful?
//          BOOL           fUseDS         - is the service using DS?
//         BOOL            fDSAvailable   - is DS available?
//
// Returns:   HRESULT -  how the initialization goes
//
// History:   Created byao 2/6/98 8:03:12 PM
//
//+---------------------------------------------------------------------------
HRESULT CPoliciesNode::SetSdo( ISdo*         pServiceSdo,
                        ISdoDictionaryOld*   pDictionarySdo,
                        BOOL           fSdoConnected,
                        BOOL           fUseDS,
                        BOOL           fDSAvailable
                        )
{
   TRACE_FUNCTION("CPoliciesNode::SetSdo");

   HRESULT hr = S_OK;

   _ASSERTE( pServiceSdo != NULL );
   _ASSERTE( pDictionarySdo != NULL );

    // Initialize all the data members

   m_fSdoConnected = fSdoConnected;
   m_fUseDS    = fUseDS;
   m_fDSAvailable = fDSAvailable;

   // Save away the interface pointers.
   m_spDictionarySdo = pDictionarySdo;
   m_spServiceSdo = pServiceSdo;

   // Get the ISdoServiceControl interface.
   hr = m_spServiceSdo->QueryInterface( IID_ISdoServiceControl, (void **) &m_spSdoServiceControl );
   if ( FAILED(hr) )
   {
      ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "Can't get service control interface, err = %x", hr);
      m_spSdoServiceControl = NULL;
      return hr;
   }

   // We just copied an interface pointer into a smart pointer -- need to AddRef manually.
   // 39470 *RRAS snapin mmc process does not get shut down upon closing if F1 help is used.
   // m_spSdoServiceControl->AddRef();

   // Make sure the name of the policies node will reflect what
   // data source we are using for the policies.

   // We weren't passed an IConsole pointer here, so
   // we use the one we saved in our CComponentData object.
   CComponentData * pComponentData = GetComponentData();
   _ASSERTE( pComponentData != NULL );
   _ASSERTE( pComponentData->m_spConsole != NULL );

   SetName( m_fUseDS, m_pszServerAddress, pComponentData->m_spConsole );

   // Get polices and profiles SDO.
   m_spProfilesCollectionSdo = NULL;
   m_spPoliciesCollectionSdo = NULL;

   hr = ::GetSdoInterfaceProperty(
               m_spServiceSdo,
               PROPERTY_IAS_PROFILES_COLLECTION,
               IID_ISdoCollection,
               (void **) &m_spProfilesCollectionSdo);
   if( FAILED(hr) || ! m_spProfilesCollectionSdo )
   {
      ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "Can't get profiles collection, err = %x", hr);
      m_spProfilesCollectionSdo = NULL;
      return hr;
   }

   // policies collection SDO
   hr = ::GetSdoInterfaceProperty(
               m_spServiceSdo,
               PROPERTY_IAS_POLICIES_COLLECTION,
               IID_ISdoCollection,
               (void **) &m_spPoliciesCollectionSdo);
   if( FAILED(hr) || ! m_spPoliciesCollectionSdo )
   {
      ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "Can't get policies collection, err = %x", hr);
      m_spPoliciesCollectionSdo = NULL;
      return hr;
   }

   // Get the interface pointers required for the vendor list.

   // First need RADIUS protocol object.
   CComPtr<ISdo> spSdoRadiusProtocol;
   hr = ::SDOGetSdoFromCollection(       m_spServiceSdo
                              , PROPERTY_IAS_PROTOCOLS_COLLECTION
                              , PROPERTY_COMPONENT_ID
                              , IAS_PROTOCOL_MICROSOFT_RADIUS
                              , &spSdoRadiusProtocol
                              );
   if( FAILED(hr) || ! spSdoRadiusProtocol )
   {
      ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "Can't get RADIUS protocol object, err = %x", hr);
      return hr;
   }

   CComPtr<ISdoCollection> spSdoVendors;

   hr = ::GetSdoInterfaceProperty(
                             spSdoRadiusProtocol
                           , PROPERTY_RADIUS_VENDORS_COLLECTION
                           , IID_ISdoCollection
                           , (void **) &spSdoVendors
                           );
   if ( FAILED(hr) || ! spSdoVendors )
   {
      ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "Can't get vendors collection, err = %x", hr);
      return hr;
   }

   // Create and initialize the IASNASVendors object.
   // This is a singleton COM object which we will initialize here
   // and which will then be used by other clients in different parts of the UI.
   hr = CoCreateInstance( CLSID_IASNASVendors, NULL, CLSCTX_INPROC_SERVER, IID_IIASNASVendors, (LPVOID *) &m_spIASNASVendors );
   if( SUCCEEDED(hr) )
   {
      HRESULT hrTemp = m_spIASNASVendors->InitFromSdo(spSdoVendors);
   }

   // Initialize the attribute list from the dictionary.
   hr = m_AttrList.Init(m_spDictionarySdo);
   DebugTrace(DEBUG_NAPMMC_POLICIESNODE, "m_AttrList->Init() returned %x", hr);
   return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  DataRefresh -- to support 
//
// Class: CPoliciesNode
//
// Synopsis:  Initialize the CPoliciesNode using the SDO pointers
//
// Arguments: ISdo*           pMachineSdo    - Server SDO
//         ISdoDictionaryOld* pDictionarySdo - Sdo Dictionary
// Returns:   HRESULT -  how the initialization goes
//
// History:   Created byao 2/6/98 8:03:12 PM
//
//+---------------------------------------------------------------------------
HRESULT CPoliciesNode::DataRefresh( ISdo*       pServiceSdo,
                        ISdoDictionaryOld*   pDictionarySdo
                        )
{
   HRESULT hr = S_OK;

   _ASSERTE( pServiceSdo != NULL );
   _ASSERTE( pDictionarySdo != NULL );

   // Save away the interface pointers.
   m_spDictionarySdo.Release();
   m_spServiceSdo.Release();
   
   m_spDictionarySdo = pDictionarySdo;
   m_spServiceSdo = pServiceSdo;

   // Get the ISdoServiceControl interface.
   m_spSdoServiceControl.Release();
   
   hr = m_spServiceSdo->QueryInterface( IID_ISdoServiceControl, (void **) &m_spSdoServiceControl );
   if ( FAILED(hr) )
      return hr;

   // Make sure the name of the policies node will reflect what
   // data source we are using for the policies.

   // We weren't passed an IConsole pointer here, so
   // we use the one we saved in our CComponentData object.
   CComponentData * pComponentData = GetComponentData();
   _ASSERTE( pComponentData != NULL );
   _ASSERTE( pComponentData->m_spConsole != NULL );

   // Get polices and profiles SDO.
   m_spProfilesCollectionSdo = NULL;
   m_spPoliciesCollectionSdo = NULL;

   m_spProfilesCollectionSdo.Release();
   
   hr = ::GetSdoInterfaceProperty(
               m_spServiceSdo,
               PROPERTY_IAS_PROFILES_COLLECTION,
               IID_ISdoCollection,
               (void **) &m_spProfilesCollectionSdo);
   if( FAILED(hr) || ! m_spProfilesCollectionSdo )
   {
      return hr;
   }

   // policies collection SDO
   m_spPoliciesCollectionSdo.Release();
   
   hr = ::GetSdoInterfaceProperty(
               m_spServiceSdo,
               PROPERTY_IAS_POLICIES_COLLECTION,
               IID_ISdoCollection,
               (void **) &m_spPoliciesCollectionSdo);
   if( FAILED(hr) || ! m_spPoliciesCollectionSdo )
   {
      return hr;
   }
   return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  NormalizeMerit
//
// Class:     CPoliciesNode
//
// Synopsis:  move up the merit value of a child node
//
// Arguments: CChildNode * pChildNode - the pointer to the child node
//
// Returns:   HRESULT;
//
// History:   Created byao 2/9/98 2:53:10 PM
//
//+---------------------------------------------------------------------------
HRESULT CPoliciesNode::NormalizeMerit( CPolicyNode* pChildNode )
{
   TRACE_FUNCTION("CPoliciesNode::MoveUpChild");

   // Check for preconditions:
   ATLASSERT(pChildNode);

   // None.
   HRESULT hr = S_OK;
   
   if( m_ResultChildrenList.NormalizeMerit( pChildNode ) )
   {
      //
      // We weren't passed an IConsole pointer here, so
      // we use the one we saved in out CComponentData object.
      // Update all views
      //
      CComponentData * pComponentData = GetComponentData();
      _ASSERTE( pComponentData != NULL );
      _ASSERTE( pComponentData->m_spConsole != NULL );

      // We pass in a pointer to 'this' because we want each
      // of our CComponent objects to update its result pane
      // view if 'this' node is the same as the saved currently
      // selected node.

      
      // Make MMC update this node in all views.
      CChangeNotification *pChangeNotification = new CChangeNotification();
      pChangeNotification->m_dwFlags = CHANGE_RESORT_PARENT;
      pChangeNotification->m_pNode = pChildNode;
      pChangeNotification->m_pParentNode = this;
      hr = pComponentData->m_spConsole->UpdateAllViews( NULL, (LPARAM) pChangeNotification, 0);
      pChangeNotification->Release();


      // Tell the service to reload data.
      HRESULT hrTemp = m_spSdoServiceControl->ResetService();
      if( FAILED( hrTemp ) )
      {
         ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "ISdoServiceControl::ResetService() failed, err = %x", hrTemp);
      }
   }
   else
   {
      // something strange has happened
      _ASSERTE( FALSE );
      hr = S_FALSE;
   }

   return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  MoveUpChild
//
// Class:     CPoliciesNode
//
// Synopsis:  move up the merit value of a child node
//
// Arguments: CChildNode * pChildNode - the pointer to the child node
//
// Returns:   HRESULT;
//
// History:   Created byao 2/9/98 2:53:10 PM
//
//+---------------------------------------------------------------------------
HRESULT CPoliciesNode::MoveUpChild( CPolicyNode* pChildNode )
{
   TRACE_FUNCTION("CPoliciesNode::MoveUpChild");

   // Check for preconditions:
   ATLASSERT(pChildNode);

   // None.
   HRESULT hr = S_OK;
   
   if( m_ResultChildrenList.MoveUp( pChildNode ) )
   {
      //
      // We weren't passed an IConsole pointer here, so
      // we use the one we saved in out CComponentData object.
      // Update all views
      //
      CComponentData * pComponentData = GetComponentData();
      _ASSERTE( pComponentData != NULL );
      _ASSERTE( pComponentData->m_spConsole != NULL );

      // We pass in a pointer to 'this' because we want each
      // of our CComponent objects to update its result pane
      // view if 'this' node is the same as the saved currently
      // selected node.

      // Make MMC update this node in all views.
      CChangeNotification *pChangeNotification = new CChangeNotification();
      pChangeNotification->m_dwFlags = CHANGE_RESORT_PARENT;
      pChangeNotification->m_pNode = pChildNode;
      pChangeNotification->m_pParentNode = this;
      hr = pComponentData->m_spConsole->UpdateAllViews( NULL, (LPARAM) pChangeNotification, 0);
      pChangeNotification->Release();

      // Tell the service to reload data.
      HRESULT hrTemp = m_spSdoServiceControl->ResetService();
      if( FAILED( hrTemp ) )
      {
         ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "ISdoServiceControl::ResetService() failed, err = %x", hrTemp);
      }
   }
   else
   {
      // something strange has happened
      _ASSERTE( FALSE );
      hr = S_FALSE;
   }

   return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  MoveDownChild
//
// Class:     CPoliciesNode
//
// Synopsis:  move down the merit value of a child node
//
// Arguments: CChildNode * pChildNode - the pointer to the child node
//
// Returns:   HRESULT;
//
// History:   Created byao 2/9/98 2:53:10 PM
//
//+---------------------------------------------------------------------------
HRESULT CPoliciesNode::MoveDownChild( CPolicyNode* pChildNode )
{
   TRACE_FUNCTION("CPoliciesNode::MoveDownChild");

   // Check for preconditions:
   ATLASSERT(pChildNode);

   // None.
   HRESULT hr = S_OK;
   
   if( m_ResultChildrenList.MoveDown( pChildNode ) )
   {
      //
      // We weren't passed an IConsole pointer here, so
      // we use the one we saved in out CComponentData object.
      // Update all views
      //

      CComponentData * pComponentData = GetComponentData();
      _ASSERTE( pComponentData != NULL );
      _ASSERTE( pComponentData->m_spConsole != NULL );

      // Make MMC update this node in all views.
      CChangeNotification *pChangeNotification = new CChangeNotification();
      pChangeNotification->m_dwFlags = CHANGE_RESORT_PARENT;
      pChangeNotification->m_pNode = pChildNode;
      pChangeNotification->m_pParentNode = this;
      hr = pComponentData->m_spConsole->UpdateAllViews( NULL, (LPARAM) pChangeNotification, 0);
      pChangeNotification->Release();

      // Tell the service to reload data.
      HRESULT hrTemp = m_spSdoServiceControl->ResetService();
      if( FAILED( hrTemp ) )
      {
         ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "ISdoServiceControl::ResetService() failed, err = %x", hrTemp);
      }
   }
   else
   {
      // something strange has happened
      _ASSERTE( FALSE );
      hr = S_FALSE;
   }
   return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  CPoliciesNode::OnNewPolicy
//
// Synopsis:  to add a policy node
//
// Arguments: IUnknown *pUnknown - IUnknown pointer passed to the snap-in node
//
// Returns:   HRESULT -
//
// History:   Created Header    byao   2/24/98 1:45:12 AM
//
//+---------------------------------------------------------------------------
HRESULT CPoliciesNode::OnNewPolicy(bool &bHandled, CSnapInObjectRootBase* pObj )
{
   TRACE_FUNCTION("CPoliciesNode::OnNewPolicy");
   
   HRESULT hr = S_OK;

   // do nothing if the server is not even connected
   if ( !m_fSdoConnected )
   {
      return S_OK;
   }

   CComPtr<IComponent>     spComponent;
   CComPtr<IComponentData> spComponentData;
   CComPtr<IConsole>    spConsole;
   CComPtr<ISdo>        spProfileSdo = NULL;
   CComPtr<IDispatch>      spPolicyDispatch = NULL;
   CComPtr<IDispatch>      spProfileDispatch = NULL;
   CComPtr<ISdo>        spPolicySdo;
   CPolicyNode*         pPolicyNode = NULL;
   CComBSTR          bstrName;

   // We need to make sure that the result child list as been populated
   // initially from the SDO's, before we add anything new to it,
   // otherwise we may get an item showing up in our list twice.
   // See note for CNodeWithResultChildrenList::AddSingleChildToListAndCauseViewUpdate.
   if ( FALSE == m_bResultChildrenListPopulated )
   {
      hr = PopulateResultChildrenList();
      DebugTrace(ERROR_NAPMMC_POLICIESNODE, "PopulateResultChildrenList() returned %x", hr);

      if( FAILED(hr) )
      {
         goto failure;
      }
      m_bResultChildrenListPopulated = TRUE;
   }

   // One of them should be NULL and the other non-null.
   spComponentData = (IComponentData *)(dynamic_cast<CComponentData*>(pObj));

   if( spComponentData == NULL )
   {
      // It must be a CComponent pointer.
      spComponent = (IComponent *) (dynamic_cast<CComponent*>(pObj));
      _ASSERTE( spComponent != NULL );
   }

   // Attempt to get our local copy of IConsole from either our CComponentData or CComponent.
   if( spComponentData != NULL )
   {
      spConsole = ( (CComponentData *) spComponentData.p )->m_spConsole;
   }
   else
   {  
      // If we don't have pComponentData, we better have pComponent
      _ASSERTE( spComponent != NULL );
      spConsole = ( (CComponent *) spComponent.p )->m_spConsole;
   }

   // Create a new policy node.
   pPolicyNode = new CPolicyNode(
                                   this, 
                                   m_pszServerAddress,  
                                   &m_AttrList, 
                                   TRUE, 
                                   m_fUseDS,
                                   IsWin2kServer() // is a Win2k machine?
                                );
   if( ! pPolicyNode )
   {
      // We failed to create the policy node.
      hr = HRESULT_FROM_WIN32(GetLastError());
      ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "failed to create a policy node, err = %x", hr);

      goto failure;
   }

   // Try to Add a new policy SDO to the policies sdo collection.
   spPolicyDispatch.p = NULL;

   TCHAR tzTempName[MAX_PATH+1];

   do
   {
      //
      // create a temporary name. we used the seconds elapsed as the temp name
      // so the chance of getting identical names is very small
      //
      time_t ltime;
      time(&ltime);
      wsprintf(tzTempName, _T("TempName%ld"), ltime);
      bstrName.Empty();
      bstrName =  tzTempName; // temporary policy name
      hr =  m_spPoliciesCollectionSdo->Add(bstrName, (IDispatch **) &spPolicyDispatch.p );
      
      //
      // we keep looping around until the policy can be successfully added.
      // We will get E_INVALIDARG when the name already exists
      //
   } while ( hr == E_INVALIDARG );

   if( FAILED( hr ) )
   {
      ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "PoliciesCollection->Add() failed, err = %x", hr);
      // We could not create the object.
      ShowErrorDialog( NULL, IDS_ERROR_SDO_ERROR_ADDPOLICY, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
      goto failure;
   }
   DebugTrace(DEBUG_NAPMMC_POLICIESNODE, "policiesCollection->Add() succeeded"); 

   // Query the returned IDispatch interface for an ISdo interface.
   _ASSERTE( spPolicyDispatch.p != NULL );

   hr = spPolicyDispatch.p->QueryInterface( IID_ISdo, (void **) &spPolicySdo );

   if( ! spPolicySdo )
   {
      ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "Can't get ISdo from the new created IDispatch, err = %x", hr);
      // For some reason, we couldn't get the policy sdo.
      ShowErrorDialog( NULL, IDS_ERROR_SDO_ERROR_QUERYINTERFACE, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
      goto failure;
   }
      
   // now we create a new profile with the same name
   hr = m_spProfilesCollectionSdo->Add(bstrName, &spProfileDispatch);
   if ( FAILED(hr) )
   {
      ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "profilesCollection->Add() failed, err = %x", hr);
      ShowErrorDialog( NULL, IDS_ERROR_SDO_ERROR_ADDPROFILE, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
      goto failure;
   }
   DebugTrace(DEBUG_NAPMMC_POLICIESNODE, "profilesCollection->Add() succeeded"); 


   // Query the returned IDispatch interface for an ISdo interface.
   _ASSERTE( spProfileDispatch != NULL );

   hr = spProfileDispatch->QueryInterface(IID_ISdo, (void**)&spProfileSdo);
   if ( spProfileSdo == NULL )
   {
      ATLTRACE(_T("CPoliciesNode::NewPolicy\n"));
      ShowErrorDialog( NULL, IDS_ERROR_SDO_ERROR_QUERYINTERFACE, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
      goto failure;
   }

   //
   // add default attributes to the profiles
   //
   hr = AddDefaultProfileAttrs(spProfileSdo);
   if ( FAILED(hr) )
   {
      ShowErrorDialog( NULL, IDS_ERROR_SDO_ERROR_ADDATTR, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
      goto failure;
   }

   // set the SDO pointers for this policy node
   pPolicyNode->SetSdo(   spPolicySdo
                     , m_spDictionarySdo
                     , spProfileSdo
                     , m_spProfilesCollectionSdo
                     , m_spPoliciesCollectionSdo
                     , m_spSdoServiceControl
                     );

   // no display name yet -- use MUST rename this policy
   
   pPolicyNode->m_bstrDisplayName = _T("");

   //
   // edit the properties of the new added policy
   //
   DebugTrace(DEBUG_NAPMMC_POLICIESNODE, "Bringing up the property page for this policy node...");

   if (m_ResultChildrenList.GetSize())
      pPolicyNode->SetMerit(-1); // cause the policy to be added as the first one
   // else, default will be 0, insert to end
   
   hr = BringUpPropertySheetForNode(
                              pPolicyNode
                              , spComponentData
                              , spComponent
                              , spConsole
                              , TRUE
                              , pPolicyNode->m_bstrDisplayName
                              , FALSE
                              , MMC_PSO_NEWWIZARDTYPE
                              );

   if( S_OK == hr )
   {
      // We finished the wizard.
      if (m_ResultChildrenList.GetSize() > 1) 
         NormalizeMerit(pPolicyNode);
   }
   else
   {
      // There was some error, or the user hit cancel -- we should remove the client
      // from the SDO's.
      CComPtr<IDispatch> spDispatch;
      hr = pPolicyNode->m_spPolicySdo->QueryInterface( IID_IDispatch, (void **) & spDispatch );
      _ASSERTE( SUCCEEDED( hr ) );

      // Remove this client from the Clients collection.
      hr = m_spPoliciesCollectionSdo->Remove( spDispatch );

      spDispatch.Release();
      hr = pPolicyNode->m_spProfileSdo->QueryInterface( IID_IDispatch, (void **) & spDispatch );
      _ASSERTE( SUCCEEDED( hr ) );

      // Remove this client from the Clients collection.
      hr = m_spProfilesCollectionSdo->Remove( spDispatch );

      // Delete the node   
      delete pPolicyNode;
   }

   return hr;

failure:

   if (pPolicyNode)
   {
      delete pPolicyNode;
      pPolicyNode = NULL;

      //
      // delete the policy sdo and the profile sdo from the sdo collections
      //
      //
      // we don't need to report error here because
      // 1) there's nothing more we can do if Remove() fails
      // 2) there must be another error reporting about Adding policy earlier
      //

      if ( spPolicyDispatch )
      {
         m_spPoliciesCollectionSdo->Remove( spPolicyDispatch );
      }

      if ( spProfileDispatch )
      {
         m_spProfilesCollectionSdo->Remove( spProfileDispatch );
      }
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPoliciesNode::RemoveChild

We override our base class's RemoveChild method to insert code that
removes the child from the Sdo's as well.  We then call our base
class's RemoveChild method to remove the UI object from the list
of UI children.


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPoliciesNode::RemoveChild( CPolicyNode* pPolicyNode)
{
   TRACE_FUNCTION("CPoliciesNode::RemoveChild");

   // Check for preconditions:
   _ASSERTE( m_spPoliciesCollectionSdo != NULL );
   _ASSERTE( pPolicyNode != NULL );
   _ASSERTE( pPolicyNode->m_spPolicySdo != NULL );

   HRESULT hr = S_OK;

   // Try to remove the object from the Sdo's

   // Get the IDispatch interface of this policy Sdo.
   CComPtr<IDispatch> spDispatch;

   // remove the policy SDO
   hr = pPolicyNode->m_spPolicySdo->QueryInterface( IID_IDispatch, (void **) & spDispatch );
   _ASSERTE( SUCCEEDED( hr ) );

   // Remove this policy from the policies collection.
   hr = m_spPoliciesCollectionSdo->Remove( spDispatch );
   if( FAILED( hr ) )
   {
      ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "Can't remove the policy SDO from the policies collection, err = %x", hr);
      ShowErrorDialog( NULL, IDS_ERROR_SDO_ERROR_REMOVEPOLICY, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
      return hr;
   }

   spDispatch.Release();
   spDispatch.p = NULL;

   // remove the profile SDO
   hr = pPolicyNode->m_spProfileSdo->QueryInterface( IID_IDispatch, (void **) & spDispatch );
   _ASSERTE( SUCCEEDED( hr ) );

   // Remove this profile from the profiles collection.
   hr = m_spProfilesCollectionSdo->Remove( spDispatch );
   if( FAILED( hr ) )
   {
      ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "Can't remove the profile SDO from the policies collection, err = %x", hr);
      ShowErrorDialog( NULL, IDS_ERROR_SDO_ERROR_REMOVEPROFILE, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
      return hr;
   }

   // Tell the service to reload data.
   HRESULT hrTemp = m_spSdoServiceControl->ResetService();
   if( FAILED( hrTemp ) )
   {
      ErrorTrace(ERROR_NAPMMC_POLICIESNODE, "ISdoServiceControl::ResetService() failed, err = %x", hrTemp);
   }

   // Call our base class's method to remove the child from its list.
   // The RemoveChild method takes care of removing this node from the
   // UI's list of nodes under the parent and performing a refresh of all relevant views.
   CNodeWithResultChildrenList<CPoliciesNode, CPolicyNode, CMeritNodeArray<CPolicyNode*>, CComponentData, CComponent >::RemoveChild( pPolicyNode );

   return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  CPoliciesNode::AddProfAttr
//
// Synopsis:  Add ONE attribute to the profile attribute collection
//
// Argument:  ISdoCollection* pProfAttrCollectionSdo  
//         ATTRIBUTEID     AttrId      - default Attribute ID
//         VARIANT*        pvarValue   - Attribute value for this attribute
// 
// Returns:   succeed or not
//
// History:   Created Header    byao   4/15/98 3:59:38 PM
//
//+---------------------------------------------------------------------------
HRESULT  CPoliciesNode::AddProfAttr(   ISdoCollection*   pProfAttrCollectionSdo,
                           ATTRIBUTEID    AttrId,
                           VARIANT*    pvarValue
                         )
{
   TRACE_FUNCTION("CPoliciesNode::AddProfAttr");

   HRESULT              hr = S_OK;

   CComBSTR          bstr;
   CComPtr<IUnknown>    spUnknown;
   CComPtr<IEnumVARIANT>   spEnumVariant;

   // create default attributes
   CComPtr<IDispatch>   spDispatch;
   spDispatch.p = NULL;

   hr =  m_spDictionarySdo->CreateAttribute( AttrId,(IDispatch**)&spDispatch.p);
   if ( !SUCCEEDED(hr) )
   {
      ShowErrorDialog( NULL, IDS_ERROR_SDO_ERROR_CREATEATTR, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
      return hr;
   }

   _ASSERTE( spDispatch.p != NULL );

   // add this node to profile attribute collection
   hr = pProfAttrCollectionSdo->Add(NULL, (IDispatch**)&spDispatch.p);
   if ( !SUCCEEDED(hr) )
   {
      ShowErrorDialog( NULL, IDS_ERROR_SDO_ERROR_ADDATTR, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
      return hr;
   }

   //
   // get the ISdo pointer for this attribute
   //
   CComPtr<ISdo> spAttrSdo;
   hr = spDispatch->QueryInterface( IID_ISdo, (void **) &spAttrSdo);
   if ( !SUCCEEDED(hr) )
   {
      ShowErrorDialog( NULL, IDS_ERROR_SDO_ERROR_QUERYINTERFACE, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
      return hr;
   }
   _ASSERTE( spAttrSdo != NULL );
            
   // set sdo property for this attribute
   hr = spAttrSdo->PutProperty(PROPERTY_ATTRIBUTE_VALUE, pvarValue);
   if ( !SUCCEEDED(hr) )
   {
      ShowErrorDialog( NULL, IDS_ERROR_SDO_ERROR_PUTPROP_ATTR, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
      return hr;
   }

   return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  CPoliciesNode::AddDefaultAttrs
//
// Synopsis:  Add some default attributes to the newly created profile
//
// Argument:  ISdo*        pProfileSdo - Sdo pointer to the profile
// 
// Returns:   HRESULT return code
//
// History:   Created Header    byao   4/15/98 3:59:38 PM
//
//+---------------------------------------------------------------------------
HRESULT  CPoliciesNode::AddDefaultProfileAttrs(
                           ISdo*  pProfileSdo, 
                           DWORD dwFlagExclude
                           )
{
   TRACE_FUNCTION("CPoliciesNode::AddDefaultAttr");

   HRESULT              hr = S_OK;
   CComVariant          varValue;
    ATTRIBUTEID            AttrId;
   //
    // get the attribute collection of this profile
    //
   CComPtr<ISdoCollection> spProfAttrCollectionSdo;
   hr = ::GetSdoInterfaceProperty(pProfileSdo,
                          (LONG)PROPERTY_PROFILE_ATTRIBUTES_COLLECTION,
                          IID_ISdoCollection,
                          (void **) &spProfAttrCollectionSdo
                         );
   if ( FAILED(hr) )
   {
      return hr;
   }
   _ASSERTE(spProfAttrCollectionSdo);

   //
   // Default Attribute:  ServiceType=Framed, Enumerator
   //
   AttrId = RADIUS_ATTRIBUTE_SERVICE_TYPE;
   
   // Set value
   V_VT(&varValue)   = VT_I4;
   V_I4(&varValue) = 2; // framed

   hr = AddProfAttr(spProfAttrCollectionSdo, AttrId, &varValue);
   if ( !SUCCEEDED(hr) )
   {
      return hr;
   }

// turn it on again: bug : 337330
// #if 0 // not to have this default attribute; bug : 241350

   if ((EXCLUDE_DEFAULT_FRAMED & dwFlagExclude) == 0)
   {
      //
      // Default Attribute:  FrameProtocol=PPP, Enumerator
      //
      AttrId = RADIUS_ATTRIBUTE_FRAMED_PROTOCOL;

      varValue.Clear();
      V_VT(&varValue)   = VT_I4;
      V_I4(&varValue) = 1; // PPP

      hr = AddProfAttr(spProfAttrCollectionSdo, AttrId, &varValue);
      if ( !SUCCEEDED(hr) )
      {
         return hr;
      }
   }
// #endif // not to have this default attribute; bug : 241350
// turn it on again: bug : 337330

   //
   // Default Attribute:  AuthenticationType=MS-CHAPv2, MS-CHAP, Enumerator,multivalued
   //

   if ((EXCLUDE_AUTH_TYPE & dwFlagExclude) == 0)
   {
      AttrId = IAS_ATTRIBUTE_NP_AUTHENTICATION_TYPE;

      CSafeArray<CComVariant, VT_VARIANT> Values = Dim(4);  // 4 values

      Values.Lock();

      varValue.Clear();
      V_VT(&varValue)   =  VT_I4;
      V_I4(&varValue)   =  IAS_AUTH_MSCHAP2;      // MS-CHAPv2
      Values[0] = varValue;

      varValue.Clear();
      V_VT(&varValue)   =  VT_I4;
      V_I4(&varValue)   =  IAS_AUTH_MSCHAP;      // MS-CHAP
      Values[1] = varValue;

      varValue.Clear();
      V_VT(&varValue)   =  VT_I4;
      V_I4(&varValue)   =  IAS_AUTH_MSCHAP2_CPW;      // MS-CHAPv2 Password
      Values[2] = varValue;

      varValue.Clear();
      V_VT(&varValue)   =  VT_I4;
      V_I4(&varValue)   =  IAS_AUTH_MSCHAP_CPW;      // MS-CHAP Password
      Values[3] = varValue;

      Values.Unlock();

      // We need to use a VARIANT and not a CComVariant here because when
      // CSafeArray's destructor gets called, it will destroy the array
      // -- we don't want CComVariant's destructor to do this as well.
      // Ideally, we'd like to use a CComVariant, but once we move Values
      // into a CComVariant, we should "Detach" the memory from
      // CSafeArray so that it no longer controls destruction,
      // but Baogang's CSafeArray class doesn't have a Detach method.
      // ISSUE: Figure out why CSafeArray is causing a problem here
      // but not elsewhere -- this CSafeArray class is largely
      // untested and has been problematic in the past,
      // so we should consider replacing it.
      VARIANT varArray;
      VariantInit( &varArray );
      SAFEARRAY         sa = (SAFEARRAY)Values;
      V_VT(&varArray)      = VT_ARRAY | VT_VARIANT;
      V_ARRAY(&varArray)   = &sa;

   
      hr = AddProfAttr(spProfAttrCollectionSdo, AttrId, &varArray);
   }
   return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  CPoliciesNode::CheckActivePropertyPages
//
// Synopsis:  Check whether any policy property page is up.
//
// Returns:   BOOL    TRUE:   yes, there's at least one property page up
//              FALSE  no,  no property page is found
//
// History:   Created Header    byao   4/16/98 3:59:38 PM
//
//+---------------------------------------------------------------------------
BOOL CPoliciesNode::CheckActivePropertyPages ()
{
   //
   // check whether ANY policy node has a property page up
   //
   for (int iIndex=0; iIndex<m_ResultChildrenList.GetSize(); iIndex++)
   {
      if ( m_ResultChildrenList[iIndex]->m_pPolicyPage1 )
      {
         // We found a property sheet already up for this node.
         return TRUE;
      }
   } // for

   return FALSE;
}


//+---------------------------------------------------------------------------
//
// Function:  CPoliciesNode::FindChildWithName
//
// Synopsis:  try to find a child with the same name
//
// Arguments: LPTSTR pszName - name of the child to look for
//
// Returns:   CPolicyNode* pChild -- pointer to the child with the same name
//         NULL              -- not found
//
// History:   Created Header    byao 4/30/98 4:46:05 PM
//
//+---------------------------------------------------------------------------
CPolicyNode*  CPoliciesNode::FindChildWithName(LPCTSTR pszName)
{
   TRACE_FUNCTION("CPoliciesNode::FindChildWithName");

   int nSize = m_ResultChildrenList.GetSize();

   for (int iIndex=0; iIndex<nSize; iIndex++)
   {
      if ( _tcsicmp(m_ResultChildrenList[iIndex]->m_bstrDisplayName, pszName) == 0 )
      {
         return (CPolicyNode*) m_ResultChildrenList[iIndex];
      }
   }
   return NULL;
}


//+---------------------------------------------------------------------------
//
// Function:  CPoliciesNode::GetChildrenCount
//
// Synopsis:  how many children do you have?
//
// Arguments: None
//
// Returns:   int -
//
// History:   Created Header  byao  6/2/98 6:10:43 PM
//
//+---------------------------------------------------------------------------
int CPoliciesNode::GetChildrenCount()
{
   TRACE_FUNCTION("CPoliciesNode::GetChildrenCount");

   return m_ResultChildrenList.GetSize();
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPoliciesNode::SetName



--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPoliciesNode::SetName( BOOL bPoliciesFromDirectoryService, LPWSTR szPolicyLocation, IConsole * pConsole )
{
   WCHAR lpszTemp[NAP_MAX_STRING];
   int nLoadStringResult;
   HRESULT hr = S_OK;

   // Get the base name for the policies node.
   lpszTemp[0] = NULL;
   nLoadStringResult = LoadString( _Module.GetResourceInstance(),
                              IDS_POLICIES_NODE,
                              lpszTemp,
                              NAP_MAX_STRING
                           );
   _ASSERT( nLoadStringResult > 0 );

   // Put the base name into our display string.
   m_bstrDisplayName = lpszTemp;

   if( pConsole )
   {
      // We were passed an IConsole pointer.
      // We should use it to update the MMC scope pane display for this node.

      CComQIPtr< IConsoleNameSpace, &IID_IConsoleNameSpace > spConsoleNameSpace( pConsole );
      if( ! spConsoleNameSpace )
      {
         return E_FAIL;
      }
      hr = spConsoleNameSpace->SetItem( & m_scopeDataItem );
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPoliciesNode::FillData

The server node need to override CSnapInItem's implementation of this so that 
we can
also support a clipformat for exchanging machine names with any snapins 
extending us.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CPoliciesNode::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
   ATLTRACE(_T("# CClientsNode::FillData\n"));
   
   // Check for preconditions:
   // None.
   
   HRESULT hr = DV_E_CLIPFORMAT;
   ULONG uWritten = 0;

   if (cf == CF_MMC_NodeID)
   {
      ::CString   SZNodeID = (LPCTSTR)GetSZNodeType();

      if (m_fExtendingIAS)
      {
         SZNodeID += L":Ext_IAS:";
      }

      SZNodeID += m_pszServerAddress;

      DWORD dwIdSize = 0;

      SNodeID2* NodeId = NULL;
      BYTE *id = NULL;
      DWORD textSize = (SZNodeID.GetLength()+ 1) * sizeof(TCHAR);

      dwIdSize = textSize + sizeof(SNodeID2);

      try
      {
         NodeId = (SNodeID2 *)_alloca(dwIdSize);
      }
      catch(...)
      {
         return E_OUTOFMEMORY;
      }

      NodeId->dwFlags = 0;
      NodeId->cBytes = textSize;
      memcpy(NodeId->id,(BYTE*)(LPCTSTR)SZNodeID, textSize);

      return pStream->Write(NodeId, dwIdSize, &uWritten);
   }

   // Call the method which we're overriding to let it handle the
   // rest of the possible cases as usual.
   return CNodeWithResultChildrenList< CPoliciesNode, CPolicyNode, CMeritNodeArray<CPolicyNode*>, CComponentData, CComponent >::FillData( cf, pStream );
}


//////////////////////////////////////////////////////////////////////////////
// CPoliciesNode::IsWin2kServer
//////////////////////////////////////////////////////////////////////////////
bool CPoliciesNode::IsWin2kServer() throw ()
{
   if (m_serverType == unknown)
   {
      HRESULT hr = GetServerType();
      ASSERT(SUCCEEDED(hr));
   }

   return m_serverType == win2k;
}


//////////////////////////////////////////////////////////////////////////////
// CPoliciesNode::GetServerType
//////////////////////////////////////////////////////////////////////////////
HRESULT CPoliciesNode::GetServerType()
{
   const WCHAR KEY[]   = L"Software\\Microsoft\\Windows NT\\CurrentVersion";
   const WCHAR VALUE[] = L"CurrentBuildNumber";
   const unsigned int WIN2K_BUILD = 2195;

   LONG error;

   HKEY hklm = HKEY_LOCAL_MACHINE;

   // Only do a remote connect when machineName is specified.
   CRegKey remote;
   if (m_pszServerAddress && m_pszServerAddress[0])
   {
      error = RegConnectRegistryW(
                  m_pszServerAddress,
                  HKEY_LOCAL_MACHINE,
                  &remote.m_hKey
                  );
      if (error) { return error; }

      hklm = remote;
   }

   CRegKey currentVersion;
   error = currentVersion.Open(hklm, KEY, KEY_READ);
   if (error) { return error; }

   WCHAR data[16];
   DWORD dataLen = sizeof(data);
   error = currentVersion.QueryValue(data, VALUE, &dataLen);
   if (error) { return error; }

   unsigned int buildNum = _wtol(data);
   if(buildNum < WIN2K_BUILD)
   {
      m_serverType = nt4;
   }
   else if (buildNum == WIN2K_BUILD)
   {
      m_serverType = win2k;
   }
   else
   {
      m_serverType = win5_1_or_later;
   }

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\policynode.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation

Module Name:

    PolicyNode.cpp

Abstract:

   Implementation file for the CPolicyNode class.


Revision History:
   mmaguire 12/15/97 - created

--*/
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "PolicyNode.h"
#include "Component.h"
#include "SnapinNode.cpp"  // Template implementation
//
//
// where we can find declarations needed in this file:
//
#include "PoliciesNode.h"
#include "PolicyPage1.h"
#include "rapwz_name.h"
#include "rapwz_cond.h"
#include "rapwz_allow.h"
#include "rapwz_profile.h"
#include "NapUtil.h"
#include "ChangeNotification.h"

#include "rapwiz.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyNode::CPolicyNode

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CPolicyNode::CPolicyNode( CSnapInItem * pParentNode,
                    LPTSTR    pszServerAddress,
                    CIASAttrList*   pAttrList,
                    BOOL         fBrandNewNode,
                    BOOL         fUseActiveDirectory,
                    bool         isWin2k
                  )
   :CSnapinNode<CPolicyNode, CComponentData, CComponent>( pParentNode ),
    m_isWin2k(isWin2k)
{
   TRACE_FUNCTION("CPolicyNode::CPolicyNode");

   _ASSERTE( pAttrList != NULL );

   // For the help files
   m_helpIndex = (!((CPoliciesNode *)m_pParentNode )->m_fExtendingIAS)?RAS_HELP_INDEX:0;

   // Here we store an index to which of these images we
   // want to be used to display this node
   m_scopeDataItem.nImage =      IDBI_NODE_POLICY;

   //
   // initialize the merit value. This value will be set when the node is added
   // to a MeritNodeArray.
   // This is handled in call back API: SetMerit()
   //
   m_nMeritValue = 0;

   // initialize the machine name
   m_pszServerAddress = pszServerAddress;

   // no property page when initialized
   m_pPolicyPage1 = NULL ;

   //
   // initialize the condition attribute list
   //
   m_pAttrList = pAttrList;

   // yes, it is a new node
   m_fBrandNewNode = fBrandNewNode;

   // are we using active directory
   m_fUseActiveDirectory = fUseActiveDirectory;

   //
   // get the location for the policy
   //
   TCHAR tszLocationStr[IAS_MAX_STRING];
   HINSTANCE   hInstance = _Module.GetResourceInstance();

   if ( m_fUseActiveDirectory)
   {
      // active directory
      int iRes = LoadString(hInstance,
                       IDS_POLICY_LOCATION_ACTIVEDS,
                       tszLocationStr,
                       IAS_MAX_STRING
                      );
      _ASSERT( iRes > 0 );
   }
   else
   {
         // local or remote machine
         if (m_pszServerAddress && _tcslen(m_pszServerAddress)>0)
         {
            _tcscpy(tszLocationStr, m_pszServerAddress);
         }
         else
         {
            // local machine
            int iRes = LoadString(hInstance,
                             IDS_POLICY_LOCATION_LOCAL,
                             tszLocationStr,
                             IAS_MAX_STRING
                            );
            _ASSERT( iRes > 0 );

            if ( !tszLocationStr )
            {
               // resource has been corrupted -- we hard code it then.
               // this way we will guarantee tzLocationStr won't be NULL.
               _tcscpy(tszLocationStr, _T("Local Machine"));
            }
         }
   }

   m_ptzLocation = new TCHAR[_tcslen(tszLocationStr)+1];
   if ( m_ptzLocation )
   {
      _tcscpy(m_ptzLocation, tszLocationStr);
   }

   // to remember the object, so can use used within UPdateToolbarBotton
   m_pControBarNotifySnapinObj = NULL;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyNode::~CPolicyNode

Destructor

--*/
//////////////////////////////////////////////////////////////////////////////
CPolicyNode::~CPolicyNode()
{
   TRACE_FUNCTION("CPolicyNode::~CPolicyNode");

   if ( m_ptzLocation )
   {
      delete[] m_ptzLocation;
   }
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyNode::CreatePropertyPages

See CSnapinNode::CreatePropertyPages (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP  CPolicyNode::CreatePropertyPages (
                 LPPROPERTYSHEETCALLBACK pPropertySheetCallback
               , LONG_PTR hNotificationHandle
               , IUnknown* pUnk
               , DATA_OBJECT_TYPES type
               )
{
   TRACE_FUNCTION("CPolicyNode::CreatePropertyPages");

   HRESULT hr = S_OK;

#ifndef NO_ADD_POLICY_WIZARD

   if( IsBrandNew() )
   {
      // We are adding a new policy -- use the wizard pages.

      // four old pages
      CNewRAPWiz_Name * pNewRAPWiz_Name = NULL;
      CNewRAPWiz_Condition * pNewRAPWiz_Condition = NULL;
      CNewRAPWiz_AllowDeny * pNewRAPWiz_AllowDeny = NULL;
      CNewRAPWiz_EditProfile * pNewRAPWiz_EditProfile = NULL;

      // four new pages
      CPolicyWizard_Start* pNewRAPWiz_Start = NULL;
      CPolicyWizard_Scenarios*   pNewRAPWiz_Scenarios = NULL;
      CPolicyWizard_Groups*   pNewRAPWiz_Group = NULL;
      CPolicyWizard_Authentication* pNewRAPWiz_Authentication = NULL;
      CPolicyWizard_Encryption*  pNewRAPWiz_Encryption = NULL;
      CPolicyWizard_Encryption_VPN* pNewRAPWiz_Encryption_VPN = NULL;
      CPolicyWizard_EAP*   pNewRAPWiz_EAP = NULL;
      CPolicyWizard_Finish*   pNewRAPWiz_Finish = NULL;

      try
      {
         TCHAR lpszTabName[IAS_MAX_STRING];
         int nLoadStringResult;

         //===================================
         //
         // new pages wizard pages
         //

         // wizard data object
         CComPtr<CRapWizardData> spRapWizData;

         CComObject<CRapWizardData>* pRapWizData;
         CComObject<CRapWizardData>::CreateInstance(&pRapWizData);

         spRapWizData = pRapWizData;
         // set context information
         spRapWizData->SetInfo(m_pszServerAddress, this, m_spDictionarySdo, m_spPolicySdo, m_spProfileSdo, m_spPoliciesCollectionSdo, m_spProfilesCollectionSdo, m_spSdoServiceControl, m_pAttrList);

         //
         // Create each of the four old wizard pages.
         nLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_ADD_POLICY_WIZ_TAB_NAME, lpszTabName, IAS_MAX_STRING );
         _ASSERT( nLoadStringResult > 0 );

         // scenario page
         pNewRAPWiz_Start = new CPolicyWizard_Start(spRapWizData, hNotificationHandle, lpszTabName);

         // scenario page
         pNewRAPWiz_Scenarios = new CPolicyWizard_Scenarios(spRapWizData, hNotificationHandle, lpszTabName);

         // group page
         pNewRAPWiz_Group = new CPolicyWizard_Groups(spRapWizData, hNotificationHandle, lpszTabName);

         // authen page
         pNewRAPWiz_Authentication = new CPolicyWizard_Authentication(spRapWizData, hNotificationHandle, lpszTabName);

         // encryption page
         pNewRAPWiz_Encryption = new CPolicyWizard_Encryption(spRapWizData, hNotificationHandle, lpszTabName);
         pNewRAPWiz_Encryption_VPN = new CPolicyWizard_Encryption_VPN(spRapWizData, hNotificationHandle, lpszTabName);

         // EAP page
         pNewRAPWiz_EAP = new CPolicyWizard_EAP(spRapWizData, hNotificationHandle, lpszTabName);

         // finish page
         pNewRAPWiz_Finish = new CPolicyWizard_Finish(spRapWizData, hNotificationHandle, lpszTabName);

         // These pages will take care of deleting themselves when they
         // receive the PSPCB_RELEASE message.
         // We specify TRUE for the bOwnsNotificationHandle parameter in one of the pages
         // so that this page's destructor will be responsible for freeing the
         // notification handle.  Only one page per sheet should do this.
         pNewRAPWiz_Name = new CNewRAPWiz_Name(spRapWizData,  hNotificationHandle, lpszTabName, TRUE );
         if( ! pNewRAPWiz_Name ) throw E_OUTOFMEMORY;


         pNewRAPWiz_Condition = new CNewRAPWiz_Condition(spRapWizData, hNotificationHandle, m_pAttrList, lpszTabName );
         if( ! pNewRAPWiz_Condition) throw E_OUTOFMEMORY;


         pNewRAPWiz_AllowDeny = new CNewRAPWiz_AllowDeny(spRapWizData, hNotificationHandle, lpszTabName );
         if( ! pNewRAPWiz_AllowDeny ) throw E_OUTOFMEMORY;


         pNewRAPWiz_EditProfile = new CNewRAPWiz_EditProfile(
                                         spRapWizData,
                                         hNotificationHandle,
                                         m_pAttrList,
                                         lpszTabName,
                                         FALSE,
                                         m_isWin2k
                                         );
         if( ! pNewRAPWiz_EditProfile ) throw E_OUTOFMEMORY;

         // Marshall pointers to pNewRAPWiz_Name

         // Pass the pages our SDO's.  These don't need to be marshalled
         // as wizard pages run in the same thread.

         // Add each of the pages to the MMC property sheet.
         hr = pPropertySheetCallback->AddPage( pNewRAPWiz_Start->Create() );
         if( FAILED(hr) ) throw hr;

         hr = pPropertySheetCallback->AddPage( pNewRAPWiz_Name->Create() );
         if( FAILED(hr) ) throw hr;

         hr = pPropertySheetCallback->AddPage( pNewRAPWiz_Scenarios->Create() );
         if( FAILED(hr) ) throw hr;

         hr = pPropertySheetCallback->AddPage( pNewRAPWiz_Group->Create() );
         if( FAILED(hr) ) throw hr;

         hr = pPropertySheetCallback->AddPage( pNewRAPWiz_Authentication->Create() );
         if( FAILED(hr) ) throw hr;

         hr = pPropertySheetCallback->AddPage( pNewRAPWiz_Encryption->Create() );
         if( FAILED(hr) ) throw hr;

         hr = pPropertySheetCallback->AddPage( pNewRAPWiz_Encryption_VPN->Create() );
         if( FAILED(hr) ) throw hr;

         hr = pPropertySheetCallback->AddPage( pNewRAPWiz_EAP->Create() );
         if( FAILED(hr) ) throw hr;

         hr = pPropertySheetCallback->AddPage( pNewRAPWiz_Condition->Create() );
         if( FAILED(hr) ) throw hr;

         hr = pPropertySheetCallback->AddPage( pNewRAPWiz_AllowDeny->Create() );
         if( FAILED(hr) ) throw hr;

         hr = pPropertySheetCallback->AddPage( pNewRAPWiz_EditProfile->Create() );
         if( FAILED(hr) ) throw hr;

         hr = pPropertySheetCallback->AddPage( pNewRAPWiz_Finish->Create() );
         if( FAILED(hr) ) throw hr;

         // This node is no longer new.
         SetBrandNew(FALSE);
      }
      catch(...)
      {
         // Delete whatever was successfully allocated.
         delete pNewRAPWiz_Name;
         delete pNewRAPWiz_Condition;
         delete pNewRAPWiz_AllowDeny;
         delete pNewRAPWiz_EditProfile;
         delete pNewRAPWiz_Scenarios;
         delete pNewRAPWiz_Authentication;
         delete pNewRAPWiz_Encryption;
         delete pNewRAPWiz_Encryption_VPN;
         delete pNewRAPWiz_EAP;
         delete pNewRAPWiz_Finish;

         ShowErrorDialog( NULL, IDS_ERROR_CANT_CREATE_OBJECT, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );

         return E_OUTOFMEMORY;
      }
   }
   else
   {
      // We are editing an existing policy -- use the property sheet.

      // This page will take care of deleting itself when it
      // receives the PSPCB_RELEASE message.

      //
      TCHAR tszTabName[IAS_MAX_STRING];
      HINSTANCE   hInstance = _Module.GetResourceInstance();

      // load tab name, currently "Settings"
      int iRes = LoadString(hInstance,
                          IDS_POLICY_PROPERTY_PAGE_TABNAME,
                          tszTabName,
                          IAS_MAX_STRING
                         );
      if ( iRes <= 0 )
      {
         _tcscpy(tszTabName, _T("Settings"));
      }

      m_pPolicyPage1 = new CPolicyPage1(
                              hNotificationHandle,
                              this,
                              m_pAttrList,
                              tszTabName,
                              TRUE,
                              m_isWin2k
                              );
      if( NULL == m_pPolicyPage1 )
      {
         hr = HRESULT_FROM_WIN32(GetLastError());
         ErrorTrace(ERROR_NAPMMC_POLICYNODE, ("Can't create property pages, err = %x"), hr);
         goto failure;
      }

      //
      // marshall the Policy Sdo pointer
      //
      hr = CoMarshalInterThreadInterfaceInStream(
                    IID_ISdo                 //Reference to the identifier of the interface
                  , m_spPolicySdo                  //Pointer to the interface to be marshaled
                  , &( m_pPolicyPage1->m_pStreamPolicySdoMarshall ) //Address of output variable that receives the IStream interface pointer for the marshaled interface
                  );
      if ( FAILED(hr) )
      {
         ShowErrorDialog( NULL, IDS_ERROR_MARSHALL, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
         goto failure;
      }

      //
      // marshall the Dictionary Sdo pointer
      //
      hr = CoMarshalInterThreadInterfaceInStream(
                    IID_ISdoDictionaryOld
                  , m_spDictionarySdo
                  , &( m_pPolicyPage1->m_pStreamDictionarySdoMarshall )
                  );
      if ( FAILED(hr) )
      {
         ShowErrorDialog( NULL, IDS_ERROR_MARSHALL, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
         goto failure;
      }

      //
      // marshall the Profile Sdo pointer
      //
      hr = CoMarshalInterThreadInterfaceInStream(
                    IID_ISdo
                  , m_spProfileSdo
                  , &( m_pPolicyPage1->m_pStreamProfileSdoMarshall )
                  );
      if ( FAILED(hr) )
      {
         ShowErrorDialog( NULL, IDS_ERROR_MARSHALL, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
         goto failure;
      }

      //
      // marshall the Profile collection Sdo pointer
      //
      hr = CoMarshalInterThreadInterfaceInStream(
                    IID_ISdoCollection
                  , m_spProfilesCollectionSdo
                  , &( m_pPolicyPage1->m_pStreamProfilesCollectionSdoMarshall )
                  );
      if ( FAILED(hr) )
      {
         ShowErrorDialog( NULL, IDS_ERROR_MARSHALL, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
         goto failure;
      }

      //
      // marshall the Policy collection Sdo pointer
      //
      hr = CoMarshalInterThreadInterfaceInStream(
                    IID_ISdoCollection
                  , m_spPoliciesCollectionSdo
                  , &( m_pPolicyPage1->m_pStreamPoliciesCollectionSdoMarshall )
                  );
      if ( FAILED(hr) )
      {
         ShowErrorDialog( NULL, IDS_ERROR_MARSHALL, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
         goto failure;
      }


      // Marshall the Service Control Sdo pointer.
      hr = CoMarshalInterThreadInterfaceInStream(
                    IID_ISdoServiceControl
                  , m_spSdoServiceControl
                  , &( m_pPolicyPage1->m_pStreamSdoServiceControlMarshall )
                  );
      if ( FAILED(hr) )
      {
         ShowErrorDialog( NULL, IDS_ERROR_MARSHALL, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
         goto failure;
      }


      // add the property pages

      hr = pPropertySheetCallback->AddPage(m_pPolicyPage1->Create());
      _ASSERT( SUCCEEDED( hr ) );

      return hr;

   failure:

      if (m_pPolicyPage1)
      {
         delete m_pPolicyPage1;
         m_pPolicyPage1 = NULL;
      }

      return hr;
   }

   return hr;

#else // NO_ADD_POLICY_WIZARD

   // This page will take care of deleting itself when it
   // receives the PSPCB_RELEASE message.

   //
   TCHAR tszTabName[IAS_MAX_STRING];
   HINSTANCE   hInstance = _Module.GetResourceInstance();

   // load tab name, currently "Settings"
   int iRes = LoadString(hInstance,
                       IDS_POLICY_PROPERTY_PAGE_TABNAME,
                       tszTabName,
                       IAS_MAX_STRING
                      );
   if ( iRes <= 0 )
   {
      _tcscpy(tszTabName, _T("Settings"));
   }

   m_pPolicyPage1 = new CPolicyPage1(
                           hNotificationHandle,
                           this,
                           m_pAttrList,
                           tszTabName,
                           TRUE,
                           m_isWin2k
                           );
   if( NULL == m_pPolicyPage1 )
   {
      hr = HRESULT_FROM_WIN32(GetLastError());
      ErrorTrace(ERROR_NAPMMC_POLICYNODE, ("Can't create property pages, err = %x"), hr);
      goto failure;
   }

   //
   // marshall the Policy Sdo pointer
   //
   hr = CoMarshalInterThreadInterfaceInStream(
                 IID_ISdo                 //Reference to the identifier of the interface
               , m_spPolicySdo                  //Pointer to the interface to be marshaled
               , &( m_pPolicyPage1->m_pStreamPolicySdoMarshall ) //Address of output variable that receives the IStream interface pointer for the marshaled interface
               );
   if ( FAILED(hr) )
   {
      ShowErrorDialog( NULL, IDS_ERROR_MARSHALL, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
      goto failure;
   }

   //
   // marshall the Dictionary Sdo pointer
   //
   hr = CoMarshalInterThreadInterfaceInStream(
                 IID_ISdoDictionaryOld
               , m_spDictionarySdo
               , &( m_pPolicyPage1->m_pStreamDictionarySdoMarshall )
               );
   if ( FAILED(hr) )
   {
      ShowErrorDialog( NULL, IDS_ERROR_MARSHALL, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
      goto failure;
   }

   //
   // marshall the Profile Sdo pointer
   //
   hr = CoMarshalInterThreadInterfaceInStream(
                 IID_ISdo
               , m_spProfileSdo
               , &( m_pPolicyPage1->m_pStreamProfileSdoMarshall )
               );
   if ( FAILED(hr) )
   {
      ShowErrorDialog( NULL, IDS_ERROR_MARSHALL, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
      goto failure;
   }

   //
   // marshall the Profile collection Sdo pointer
   //
   hr = CoMarshalInterThreadInterfaceInStream(
                 IID_ISdoCollection
               , m_spProfilesCollectionSdo
               , &( m_pPolicyPage1->m_pStreamProfilesCollectionSdoMarshall )
               );
   if ( FAILED(hr) )
   {
      ShowErrorDialog( NULL, IDS_ERROR_MARSHALL, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
      goto failure;
   }
   //
   // marshall the Policy collection Sdo pointer
   //
   hr = CoMarshalInterThreadInterfaceInStream(
                 IID_ISdoCollection
               , m_spPoliciesCollectionSdo
               , &( m_pPolicyPage1->m_pStreamPoliciesCollectionSdoMarshall )
               );
   if ( FAILED(hr) )
   {
      ShowErrorDialog( NULL, IDS_ERROR_MARSHALL, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
      goto failure;
   }

   // add the property pages

   hr = pPropertySheetCallback->AddPage(m_pPolicyPage1->Create());
   _ASSERT( SUCCEEDED( hr ) );

   return hr;

failure:

   if (m_pPolicyPage1)
   {
      delete m_pPolicyPage1;
      m_pPolicyPage1 = NULL;
   }

   return hr;

#endif // NO_ADD_POLICY_WIZARD
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyNode::QueryPagesFor

See CSnapinNode::QueryPagesFor (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP  CPolicyNode::QueryPagesFor ( DATA_OBJECT_TYPES type )
{
   TRACE_FUNCTION("CPolicyNode::QueryPagesFor");

   // S_OK means we have pages to display
   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyNode::GetResultPaneColInfo

See CSnapinNode::GetResultPaneColInfo (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
OLECHAR* CPolicyNode::GetResultPaneColInfo(int nCol)
{
   TRACE_FUNCTION("CPolicyNode::GetResultPaneColInfo");

   if (nCol == 0 && m_bstrDisplayName != NULL)
      return m_bstrDisplayName;

   switch( nCol )
   {
   case 0:
         return m_bstrDisplayName;
         break;

   case 1:
         // display the merit value for this policy node
         wsprintf(m_tszMeritString, L"%d", m_nMeritValue);
         return m_tszMeritString;
         break;

   case 2: return m_ptzLocation;
         break;

   default:
         // ISSUE: error -- should we assert here?
         return L"@Invalid column";

   }
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyNode::OnRename

See CSnapinNode::OnRename (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPolicyNode::OnRename(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         )
{
   TRACE_FUNCTION("CPolicyNode::OnRename");

   // Check for preconditions:
   _ASSERTE( pComponentData != NULL || pComponent != NULL );

   CComPtr<IConsole> spConsole;
   HRESULT hr = S_FALSE;
   CComVariant spVariant;
   CComBSTR bstrError;

   try
   {
      // We need IConsole
      if( pComponentData != NULL )
      {
          spConsole = ((CComponentData*)pComponentData)->m_spConsole;
      }
      else
      {
          spConsole = ((CComponent*)pComponent)->m_spConsole;
      }
      _ASSERTE( spConsole != NULL );

      // This returns S_OK if a property sheet for this object already exists
      // and brings that property sheet to the foreground.
      // It returns S_FALSE if the property sheet wasn't found.
      hr = BringUpPropertySheetForNode(
                 this
               , pComponentData
               , pComponent
               , spConsole
               );

      if( FAILED( hr ) )
      {
         return hr;
      }

      if( S_OK == hr )
      {
         // We found a property sheet already up for this node.
         ShowErrorDialog( NULL, IDS_ERROR_CLOSE_PROPERTY_SHEET, NULL, S_OK, USE_DEFAULT, GetComponentData()->m_spConsole );
         return hr;
      }

      // We didn't find a property sheet already up for this node.
      _ASSERTE( S_FALSE == hr );

      {
         ::CString str = (OLECHAR *) param;
         str.TrimLeft();
         str.TrimRight();
         if (str.IsEmpty())
         {
            ShowErrorDialog( NULL, IDS_ERROR__POLICYNAME_EMPTY);
            hr = S_FALSE;
            return hr;
         }
      }

      // Make a BSTR out of the new name.
      spVariant.vt = VT_BSTR;
      spVariant.bstrVal = SysAllocString( (OLECHAR *) param );
      _ASSERTE( spVariant.bstrVal != NULL );


      // Try to change the name of the policy -- pass the new BSTR to the Sdo.
      hr = m_spPolicySdo->PutProperty( PROPERTY_SDO_NAME, &spVariant );
      if( FAILED( hr ) )
      {
         ErrorTrace(DEBUG_NAPMMC_POLICYNODE, "Couldn't put policy name, err = %x", hr);
         throw hr;
      }

      // Need to change the name of the associated profile as well.
      hr = m_spProfileSdo->PutProperty( PROPERTY_SDO_NAME, &spVariant );
      if( FAILED( hr ) )
      {
         ErrorTrace(DEBUG_NAPMMC_POLICYNODE, "Couldn't put profile name, err = %x", hr);
         throw hr;
      }

      hr = m_spProfileSdo->Apply();
      if( FAILED( hr ) )
      {

         ErrorTrace(DEBUG_NAPMMC_POLICYNODE, "Couldn't apply profile change, err = %x", hr);
         throw hr;
      }

      // Set the profile association in the policy.
      hr = m_spPolicySdo->PutProperty(PROPERTY_POLICY_PROFILE_NAME, &spVariant );
      if( FAILED(hr) )
      {
         ErrorTrace(DEBUG_NAPMMC_POLICYNODE, "Couldn't put profile name for this policy, err = %x", hr);
         throw hr;
      }

      hr = m_spPolicySdo->Apply();
      if( FAILED( hr ) )
      {
         ErrorTrace(DEBUG_NAPMMC_POLICYNODE, "Couldn't apply policy change, err = %x", hr);
         throw hr;
      }

      // ISSUE: We will need to invest some time here to make sure that if the two calls above fail,
      // we change things back to a state where they will work -- this seems to be mostly a
      // limitation of the SDO's here -- what if my attempt to change it back fails?


      // Tell the service to reload data.
      HRESULT hrTemp = m_spSdoServiceControl->ResetService();
      if( FAILED( hrTemp ) )
      {
         ErrorTrace(ERROR_NAPMMC_POLICYNODE, "ISdoServiceControl::ResetService() failed, err = %x", hrTemp);
      }

      m_bstrDisplayName = spVariant.bstrVal;

      // Insure that MMC refreshes all views of this object
      // to reflect the renaming.

      CChangeNotification *pChangeNotification = new CChangeNotification();
      pChangeNotification->m_dwFlags = CHANGE_UPDATE_RESULT_NODE;
      pChangeNotification->m_pNode = this;
      hr = spConsole->UpdateAllViews( NULL, (LPARAM) pChangeNotification, 0);
      pChangeNotification->Release();
   }
   catch(...)
   {
      if(hr == DB_E_NOTABLE)  // assume, the RPC connection has problem
      {
         ShowErrorDialog(NULL, IDS_ERROR__NOTABLE_TO_WRITE_SDO, NULL, S_OK, USE_DEFAULT, GetComponentData()->m_spConsole);
      }
      else if(hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) || hr == E_INVALIDARG)
      {
         ShowErrorDialog(NULL, IDS_ERROR_INVALID_POLICYNAME, NULL, S_OK, USE_DEFAULT, GetComponentData()->m_spConsole);
      }
      else
      {
         ShowErrorDialog(NULL, IDS_ERROR_RENAMEPOLICY, NULL, S_OK, USE_DEFAULT, GetComponentData()->m_spConsole);
      }
      hr = S_FALSE;
   }
   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyNode::OnDelete

See CSnapinNode::OnDelete (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPolicyNode::OnDelete(
        LPARAM arg
      , LPARAM param
      , IComponentData * pComponentData
      , IComponent * pComponent
      , DATA_OBJECT_TYPES type
      , BOOL fSilent
      )
{
   TRACE_FUNCTION("CPolicyNode::OnDelete");

   // Check for preconditions:
   _ASSERTE( pComponentData != NULL || pComponent != NULL );
   _ASSERTE( m_pParentNode != NULL );

   HRESULT hr = S_OK;

   // First try to see if a property sheet for this node is already up.
   // If so, bring it to the foreground.

   // It seems to be acceptable to query IPropertySheetCallback for an IPropertySheetProvider.

   // But to get that, first we need IConsole
   CComPtr<IConsole> spConsole;
   if( pComponentData != NULL )
   {
       spConsole = ((CComponentData*)pComponentData)->m_spConsole;
   }
   else
   {
      // We should have a non-null pComponent
       spConsole = ((CComponent*)pComponent)->m_spConsole;
   }
   _ASSERTE( spConsole != NULL );

   // This returns S_OK if a property sheet for this object already exists
   // and brings that property sheet to the foreground.
   // It returns S_FALSE if the property sheet wasn't found.
   hr = BringUpPropertySheetForNode(
              this
            , pComponentData
            , pComponent
            , spConsole
            );

   if( FAILED( hr ) )
   {
      return hr;
   }

   if( S_OK == hr )
   {
      // We found a property sheet already up for this node.
      ShowErrorDialog( NULL, IDS_ERROR_CLOSE_PROPERTY_SHEET, NULL, S_OK, USE_DEFAULT, GetComponentData()->m_spConsole );
      return hr;
   }

   // We didn't find a property sheet already up for this node.
   _ASSERTE( S_FALSE == hr );


   if( FALSE == fSilent )
   {
      // Is this the last policy?
      if  (  ((CPoliciesNode *)m_pParentNode )->GetChildrenCount() == 1 )
      {
         int iLoadStringResult;
         WCHAR szPolicyDeleteQuery[IAS_MAX_STRING];
         WCHAR szTemp[IAS_MAX_STRING];

         iLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_ERROR_ZERO_POLICY, szTemp, IAS_MAX_STRING );
         _ASSERT( iLoadStringResult > 0 );
         swprintf( szPolicyDeleteQuery, szTemp, m_bstrDisplayName );

         int iResult = ShowErrorDialog(
                          NULL
                        , 1
                        , szPolicyDeleteQuery
                        , S_OK
                        , IDS_POLICY_NODE__DELETE_POLICY__PROMPT_TITLE
                        , spConsole
                        , MB_YESNO | MB_ICONQUESTION
                        );

         if( IDYES != iResult )
         {
            // The user didn't confirm the delete operation.
            return S_FALSE;
         }
      }
      else
      {
         // It is not the last policy, but we want to ask the user
         // to confirm the policy deletion anyway.

         int iLoadStringResult;
         WCHAR szPolicyDeleteQuery[IAS_MAX_STRING];
         WCHAR szTemp[IAS_MAX_STRING];

         iLoadStringResult = LoadString(  _Module.GetResourceInstance(), IDS_POLICY_NODE__DELETE_POLICY__PROMPT, szTemp, IAS_MAX_STRING );
         _ASSERT( iLoadStringResult > 0 );
         swprintf( szPolicyDeleteQuery, szTemp, m_bstrDisplayName );

         int iResult = ShowErrorDialog(
                          NULL
                        , 1
                        , szPolicyDeleteQuery
                        , S_OK
                        , IDS_POLICY_NODE__DELETE_POLICY__PROMPT_TITLE
                        , spConsole
                        , MB_YESNO | MB_ICONQUESTION
                        );


         if( IDYES != iResult )
         {
            // The user didn't confirm the delete operation.
            return S_FALSE;
         }
      }
   }

   // Try to delete the underlying data.
   hr = ((CPoliciesNode *) m_pParentNode )->RemoveChild( this );
   if( SUCCEEDED( hr ) )
   {
      delete this;
   }
   // Looks like RemoveChild takes care of putting up an error dialog if anything went wrong.

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyNode::SetVerbs

See CSnapinNode::SetVerbs (which this method overrides) for detailed info.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPolicyNode::SetVerbs( IConsoleVerb * pConsoleVerb )
{
   TRACE_FUNCTION("CPolicyNode::SetVerbs");

   HRESULT hr = S_OK;

   // We want the user to be able to choose Properties on this node
   hr = pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );

   // We want Properties to be the default
   hr = pConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES );

   // We want the user to be able to delete this node
   hr = pConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE );

   // We want the user to be able to rename this node
   hr = pConsoleVerb->SetVerbState( MMC_VERB_RENAME, ENABLED, TRUE );

   // We want to enable copy/paste
   hr = pConsoleVerb->SetVerbState( MMC_VERB_COPY, ENABLED, FALSE);
   hr = pConsoleVerb->SetVerbState( MMC_VERB_PASTE, ENABLED, FALSE );

   return hr;
}


HRESULT CPolicyNode::ControlbarNotify(IControlbar *pControlbar,
        IExtendControlbar *pExtendControlbar,
      CSimpleMap<UINT, IUnknown*>* pToolbarMap,
      MMC_NOTIFY_TYPE event,
        LPARAM arg,
      LPARAM param,
      CSnapInObjectRootBase* pObj,
      DATA_OBJECT_TYPES type)
{
   m_pControBarNotifySnapinObj = pObj;

   return CSnapinNode< CPolicyNode, CComponentData, CComponent >::ControlbarNotify(pControlbar,
                                                               pExtendControlbar,
                                                               pToolbarMap,
                                                               event,
                                                               arg,
                                                               param,
                                                               pObj,
                                                               type);
}


//+---------------------------------------------------------------------------
//
// Function:  CPolicyNode::OnPolicyMoveUp
//
// Synopsis:  move the policy node one level up
//
// Arguments:  bool &bHandled - is this command handled?
//             CSnapInObjectRoot* pObj -
//
// Returns:   HRESULT -
//
// History:   Created Header    byao   3/5/98 9:56:37 PM
//
//+---------------------------------------------------------------------------
HRESULT CPolicyNode::OnPolicyMoveUp( bool &bHandled, CSnapInObjectRootBase* pObj )
{
   // HACK ... HACK  -- not supposed to assume this
   // but at least we can do something better is this is true

      CComponent* pComp = NULL;

      try{
         pComp = dynamic_cast<CComponent*>(pObj);
      }
      catch(...)
      {

      }

      if(pComp
         && pComp->m_nLastClickedColumn == 1 /* order */
         && (pComp->m_dwLastSortOptions & RSI_DESCENDING) != 0)      // DESCENDING
      {
         ((CPoliciesNode *) m_pParentNode )->MoveDownChild( this );
      }
      else  // normal
      {
         ((CPoliciesNode *) m_pParentNode )->MoveUpChild( this );
      }

      bHandled = TRUE;

      return S_OK;
}


//+---------------------------------------------------------------------------
//
// Function:  CPolicyNode::OnPolicyMoveDown
//
// Synopsis:  move down the policy node one level
//
// Arguments:  bool &bHandled -
//            CSnapInObjectRoot* pObj -
//
// Returns:   HRESULT -
//
// History:   Created Header    byao   3/5/98 9:57:31 PM
//
//+---------------------------------------------------------------------------
HRESULT CPolicyNode::OnPolicyMoveDown( bool &bHandled, CSnapInObjectRootBase* pObj )
{
   // HACK ... HACK  -- not supposed to assume this
   // but at least we can do something better is this is true

      CComponent* pComp = NULL;

      try{
         pComp = dynamic_cast<CComponent*>(pObj);
      }
      catch(...)
      {

      }

      if(pComp
         && pComp->m_nLastClickedColumn == 1 /* order */
         && (pComp->m_dwLastSortOptions & RSI_DESCENDING) != 0)      // DESCENDING
      {
         ((CPoliciesNode *) m_pParentNode )->MoveUpChild( this );
      }
      else  // normal
      {
         ((CPoliciesNode *) m_pParentNode )->MoveDownChild( this );
      }
      bHandled = TRUE;

      return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyNode::GetComponentData

This method returns our unique CComponentData object representing the scope
pane of this snapin.

It relies upon the fact that each node has a pointer to its parent,
except for the root node, which instead has a member variable pointing
to CComponentData.

This would be a useful function to use if, for example, you need a reference
to some IConsole but you weren't passed one.  You can use GetComponentData
and then use the IConsole pointer which is a member variable of our
CComponentData object.

--*/
//////////////////////////////////////////////////////////////////////////////
CComponentData * CPolicyNode::GetComponentData( void )
{
   TRACE_FUNCTION("CPolicyNode::GetComponentData");

   return ((CPoliciesNode *) m_pParentNode)->GetComponentData();
}


//+---------------------------------------------------------------------------
//
// Function:  SetMerit
//
// Class: CPolicyNode
//
// Synopsis:  set the merit value of the policy node
//
// Arguments: int nMeritValue - Merit value
//
// Returns:   TRUE : succeed
//         FALSE - otherwise
//
// History:   Created byao 2/9/98 1:43:37 PM
//
// Note: when this node is added to the array list, the add API will call
//     back this function to set the merit value
//+---------------------------------------------------------------------------
BOOL CPolicyNode::SetMerit(int nMeritValue)
{
   TRACE_FUNCTION("CPolicyNode::SetMerit");
   HRESULT hr = S_OK;

   if(m_nMeritValue != nMeritValue)
   {
      m_nMeritValue = nMeritValue;

      //
      // set this property in the SDO policy object also
      //
      CComVariant var;

      V_VT(&var) = VT_I4;
      V_I4(&var) = m_nMeritValue;

      hr = m_spPolicySdo->PutProperty( PROPERTY_POLICY_MERIT, &var);

      //
      // save this property.
      //
      m_spPolicySdo->Apply();
   }
   return (SUCCEEDED(hr));
}


//+---------------------------------------------------------------------------
//
// Function:  GetMerit
//
// Class: CPolicyNode
//
// Synopsis:  get the merit value of the policy node
//
// Arguments: None
//
// Returns:   merit value
//
// History:   Created byao 2/9/98 1:43:37 PM
//
//+---------------------------------------------------------------------------
int CPolicyNode::GetMerit()
{
   return m_nMeritValue;
}


//+---------------------------------------------------------------------------
//
// Function:  SetSdo
//
// Class: CPolicyNode
//
// Synopsis:  Initialize the Sdo pointers in the policy object
//
// Arguments: ISdo * pSdoPolicy - pointer to the policy SDO
//
// Returns:   HRESULT - how does it go?
//
// History:   Created Header    byao   2/15/98 6:08:40 PM
//
//+---------------------------------------------------------------------------
HRESULT CPolicyNode::SetSdo(  ISdo * pPolicySdo
                     , ISdoDictionaryOld * pDictionarySdo
                     , ISdo* pProfileSdo
                     , ISdoCollection* pProfilesCollectionSdo
                     , ISdoCollection* pPoliciesCollectionSdo
                     , ISdoServiceControl * pSdoServiceControl
                  )
{
   TRACE_FUNCTION("CPolicyNode::SetSdo");

   // Check for preconditions:
   _ASSERTE( pPolicySdo != NULL );
   _ASSERTE( pDictionarySdo != NULL );
   _ASSERTE( pProfileSdo != NULL );
   _ASSERTE( pProfilesCollectionSdo != NULL );
   _ASSERTE( pProfilesCollectionSdo != NULL );
   _ASSERTE( pSdoServiceControl != NULL );

   // Save our sdo pointer.
   m_spPolicySdo           = pPolicySdo;
   m_spDictionarySdo       = pDictionarySdo;
   m_spProfileSdo          = pProfileSdo;
   m_spProfilesCollectionSdo  = pProfilesCollectionSdo;
   m_spPoliciesCollectionSdo  = pPoliciesCollectionSdo;
   m_spSdoServiceControl      = pSdoServiceControl;

   return S_OK;
}


//+---------------------------------------------------------------------------
//
// Function:   LoadSdoData
//
// Class:      CPolicyNode
//
// Synopsis:   Load data from SDO pointers
//
// Returns:    HRESULT - how does it go?
//
// History:    Created Header    byao  3/10/98 6:08:40 PM
//
//+---------------------------------------------------------------------------
HRESULT CPolicyNode::LoadSdoData()
{
   TRACE_FUNCTION("CPolicyNode::LoadSdoData");

   HRESULT hr = S_OK;
   CComVariant var;

   if ( !m_spPolicySdo )
   {
      return E_INVALIDARG;
   }

   // Set the display name for this object.
   hr = m_spPolicySdo->GetProperty( PROPERTY_SDO_NAME, &var );
   if ( FAILED(hr) )
   {
      ShowErrorDialog( NULL, IDS_ERROR_SDO_ERROR_GETPROP_POLICYNAME, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
      return hr;
   }
   _ASSERTE( V_VT(&var) == VT_BSTR );
   m_bstrDisplayName = V_BSTR(&var);

   var.Clear();
   hr = m_spPolicySdo->GetProperty( PROPERTY_POLICY_MERIT, &var );
   if ( FAILED(hr) )
   {
      ShowErrorDialog( NULL, IDS_ERROR_SDO_ERROR_GETPROP_POLICYMERIT, NULL, hr, USE_DEFAULT, GetComponentData()->m_spConsole );
      return hr;
   }

   _ASSERTE( V_VT(&var) == VT_I4);
   m_nMeritValue = V_I4(&var);

   return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  CPolicyNode::UpdateMenuState
//
// Synopsis:  update MoveUp/MoveDown menu status according to the policy order
//
// Arguments: UINT id -
//            LPTSTR pBuf -
//            UINT *flags -
//
// Returns:   Nothing
//
// History:   Created Header    byao 6/2/98 5:31:53 PM
//
//+---------------------------------------------------------------------------
void CPolicyNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
   TRACE_FUNCTION("CPolicyNode::UpdateMenuState");

   // Check for preconditions:
   BOOL  bReverse = FALSE;

   // need to trap this call ControlBarNotify and remember the component --- in pObj and then ...
   if(m_pControBarNotifySnapinObj)
   {
      CComponent* pComp = NULL;

      try{
         pComp = dynamic_cast<CComponent*>(m_pControBarNotifySnapinObj);
      }
      catch(...)
      {

      }

      if(pComp
         && pComp->m_nLastClickedColumn == 1 /* order */
         && (pComp->m_dwLastSortOptions & RSI_DESCENDING) != 0)      // DESCENDING
      {
         bReverse = TRUE;
      }
   }

   // Set the state of the appropriate context menu items.
   if( (id == ID_MENUITEM_POLICY_TOP__MOVE_UP && !bReverse) ||  (id == ID_MENUITEM_POLICY_TOP__MOVE_DOWN && bReverse))
   {
      if ( 1 == m_nMeritValue )
      {
         //
         // we should disable the MoveUp menu when it's already the first
         //
         *flags = MFS_GRAYED;
      }
      else
      {
         *flags = MFS_ENABLED;
      }
   }
   else
   {
      if( (id == ID_MENUITEM_POLICY_TOP__MOVE_DOWN && !bReverse) || (id == ID_MENUITEM_POLICY_TOP__MOVE_UP && bReverse))
      {
         if ( m_nMeritValue ==  ((CPoliciesNode *)m_pParentNode)->GetChildrenCount()  )
         {
            //
            // we should disable the MoveDown menu when it's already the last
            //
            *flags = MFS_GRAYED;
         }
         else
         {
            *flags = MFS_ENABLED;
         }
      }
   }
}


//+---------------------------------------------------------------------------
//
// Function:  CPolicyNode::UpdateToolbarButton
//
// Synopsis:  update MoveUp/MoveDown toolbar button
//
// Arguments: UINT id -
//            BYTE fsState -
//
// Returns:   Nothing
//
// History:   Created Header    byao 6/2/98 5:31:53 PM
//
//+---------------------------------------------------------------------------
BOOL CPolicyNode::UpdateToolbarButton(UINT id, BYTE fsState)
{
   TRACE_FUNCTION("CPolicyNode::UpdateToolbarButton");

   BOOL  bReverse = FALSE;

   // need to trap this call ControlBarNotify and remember the component --- in pObj and then ...
   if(m_pControBarNotifySnapinObj)
   {
      CComponent* pComp = NULL;

      try{
         pComp = dynamic_cast<CComponent*>(m_pControBarNotifySnapinObj);
      }
      catch(...)
      {

      }

      if(pComp
         && pComp->m_nLastClickedColumn == 1 /* order */
         && (pComp->m_dwLastSortOptions & RSI_DESCENDING) != 0)      // DESCENDING
      {
         bReverse = TRUE;
      }
   }

   // Check for preconditions:
   // None.

   // Set whether the buttons should be enabled.
   if (fsState == ENABLED)
   {
      if(( id == ID_BUTTON_POLICY_MOVEUP && (!bReverse)) || (id == ID_BUTTON_POLICY_MOVEDOWN  && bReverse))
      {
         if ( 1 == m_nMeritValue )
         {
            return FALSE;
         }
         else
         {
            return TRUE;
         }
      }
      else
      {
         if(( id == ID_BUTTON_POLICY_MOVEDOWN  && (!bReverse)) || (id == ID_BUTTON_POLICY_MOVEUP && bReverse))
         {
            if ( m_nMeritValue ==  ((CPoliciesNode *)m_pParentNode)->GetChildrenCount()  )
            {
               return FALSE;
            }
            else
            {
               return TRUE;
            }
         }
      }
   }

   // For all other possible button ID's and states, the correct answer here is FALSE.
   return FALSE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyNode::OnPropertyChange

This is our own custom response to the MMCN_PROPERTY_CHANGE notification.

MMC never actually sends this notification to our snapin with a specific lpDataObject,
so it would never normally get routed to a particular node but we have arranged it
so that our property pages can pass the appropriate CSnapInItem pointer as the param
argument.  In our CComponent::Notify override, we map the notification message to
the appropriate node using the param argument.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CPolicyNode::OnPropertyChange(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         )
{
   TRACE_FUNCTION("CPolicyNode::OnPropertyChange");

   // Check for preconditions:
   // None.

   return LoadSdoData();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\policypage1.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation

Module Name: PolicyPage1.cpp

Abstract:
   Implementation file for the CPolicyPage1 class.
   We implement the class needed to handle the first property page for a Policy node.

--*/
//////////////////////////////////////////////////////////////////////////////

#include "Precompiled.h"
#include "PolicyPage1.h"
#include "NapUtil.h"
#include "PolicyNode.h"
#include "PoliciesNode.h"
#include "Condition.h"
#include "EnumCondition.h"
#include "MatchCondition.h"
#include "TodCondition.h"
#include "NtGCond.h"
#include "rasprof.h"
#include "ChangeNotification.h"
#include "policiesnode.h"

#include "tregkey.h"


//+---------------------------------------------------------------------------
//
// Function:   CPolicyPage1
//
// Class:      CPolicyPage1
//
// Synopsis:   class constructor
//
// Arguments:   CPolicyNode *pPolicyNode - policy node for this property page
//          CIASAttrList *pAttrList -- attribute list
//              TCHAR* pTitle = NULL -
//
// Returns:     Nothing
//
// History:     Created Header    byao 2/16/98 4:31:52 PM
//
//+---------------------------------------------------------------------------
CPolicyPage1::CPolicyPage1( 
                           LONG_PTR hNotificationHandle, 
                           CPolicyNode *pPolicyNode,
                           CIASAttrList *pIASAttrList,
                           TCHAR* pTitle, 
                           BOOL bOwnsNotificationHandle, 
                           bool isWin2k
                           )
   :CIASPropertyPage<CPolicyPage1>(hNotificationHandle,
                                   pTitle, 
                                   bOwnsNotificationHandle),
    m_isWin2k(isWin2k)

{
   TRACE_FUNCTION("CPolicyPage1::CPolicyPage1");

   m_pPolicyNode = pPolicyNode;
   m_pIASAttrList = pIASAttrList;
   
   m_fDialinAllowed = TRUE;
}

//+---------------------------------------------------------------------------
//
// Function:   CPolicyPage1
//
// Class:      CPolicyPage1
//
// Synopsis:   class destructor
//
// Returns:     Nothing
//
// History:     Created Header    byao 2/16/98 4:31:52 PM
//
//+---------------------------------------------------------------------------
CPolicyPage1::~CPolicyPage1()
{  
   TRACE_FUNCTION("CPolicyPage1::~CPolicyPage1");

   // release all the marshalled sdo pointers
   if ( m_pStreamDictionarySdoMarshall )
   {
      m_pStreamDictionarySdoMarshall->Release();
      m_pStreamDictionarySdoMarshall = NULL;
   }

   if ( m_pStreamPoliciesCollectionSdoMarshall)
   {
      m_pStreamPoliciesCollectionSdoMarshall ->Release();
      m_pStreamPoliciesCollectionSdoMarshall = NULL;
   }

   if ( m_pStreamProfilesCollectionSdoMarshall )
   {
      m_pStreamProfilesCollectionSdoMarshall ->Release();
      m_pStreamProfilesCollectionSdoMarshall = NULL;
   }

   if ( m_pStreamProfileSdoMarshall )
   {
      m_pStreamProfileSdoMarshall ->Release();
      m_pStreamProfileSdoMarshall = NULL;
   }

   if ( m_pStreamPolicySdoMarshall )
   {
      m_pStreamPolicySdoMarshall->Release();
      m_pStreamPolicySdoMarshall = NULL;
   }


   if ( m_pStreamSdoServiceControlMarshall )
   {
      m_pStreamSdoServiceControlMarshall ->Release();
      m_pStreamSdoServiceControlMarshall = NULL;
   }

   // clear the property page pointer in the policy node
   m_pPolicyNode->m_pPolicyPage1 = NULL;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyPage1::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CPolicyPage1::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   TRACE_FUNCTION("CPolicyPage1::OnInitDialog");

   HRESULT              hr = S_OK;
   BOOL              fRet;
   CComPtr<IUnknown>    spUnknown;
   CComPtr<IEnumVARIANT>   spEnumVariant;
   long              ulCount;
   ULONG             ulCountReceived;

   fRet = GetSdoPointers();
   if (!fRet)
   {
      ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "GetSdoPointers() failed, err = %x", GetLastError());
      return fRet;
   }

   //get the condition collection for this SDO
   m_spConditionCollectionSdo = NULL;
   hr = ::GetSdoInterfaceProperty(
               m_spPolicySdo,
               PROPERTY_POLICY_CONDITIONS_COLLECTION,
               IID_ISdoCollection,
               (void **)&m_spConditionCollectionSdo);
   if ( FAILED(hr) )
   {
      ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "Can't get condition collection Sdo, err = %x", hr);
      return FALSE;
   }

   condList.finalConstruct(
                m_hWnd,
                m_pIASAttrList,
                ALLOWEDINCONDITION,
                m_spDictionarySdo,
                m_spConditionCollectionSdo,
                m_pPolicyNode->m_pszServerAddress,
                m_pPolicyNode->m_bstrDisplayName
                );
   if (!condList.onInitDialog()) { return FALSE; }

   hr = GetDialinSetting(m_fDialinAllowed);
   if ( FAILED(hr) )
   {
      ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "GetDialinSetting() returns %x", hr);
      return FALSE;
   }

   if ( m_fDialinAllowed )
   {
      CheckDlgButton(IDC_RADIO_DENY_DIALIN, BST_UNCHECKED);
      CheckDlgButton(IDC_RADIO_GRANT_DIALIN, BST_CHECKED);
   }
   else
   {
      CheckDlgButton(IDC_RADIO_GRANT_DIALIN, BST_UNCHECKED);
      CheckDlgButton(IDC_RADIO_DENY_DIALIN, BST_CHECKED);
   }

   // Set the IDC_STATIC_GRANT_OR_DENY_TEXT static text box to be the appropriate text.

   TCHAR szText[NAP_MAX_STRING];
   int iLoadStringResult;

   UINT uTextID = m_fDialinAllowed ? IDS_POLICY_GRANT_ACCESS_INFO : IDS_POLICY_DENY_ACCESS_INFO;

   iLoadStringResult = LoadString(  _Module.GetResourceInstance(), uTextID, szText, NAP_MAX_STRING );
   _ASSERT( iLoadStringResult > 0 );

   SetDlgItemText(IDC_STATIC_GRANT_OR_DENY_TEXT, szText );
   SetModified(FALSE);
   return TRUE;   // ISSUE: what do we need to be returning here?
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyPage1::OnConditionAdd

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CPolicyPage1::OnConditionAdd(UINT uMsg, WPARAM wParam, HWND hWnd, BOOL& bHandled)
{
   BOOL modified = FALSE;
   HRESULT hr = condList.onAdd(modified);
   if (modified) { SetModified(TRUE); }
   return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyPage1::OnDialinCheck

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CPolicyPage1::OnDialinCheck(UINT uMsg, WPARAM wParam, HWND hWnd, BOOL& bHandled)
{
   TRACE_FUNCTION("CPolicyPage1::OnDialinCheck");

   m_fDialinAllowed = IsDlgButtonChecked(IDC_RADIO_GRANT_DIALIN);
   SetModified(TRUE);

   // Set the IDC_STATIC_GRANT_OR_DENY_TEXT static text box to be the appropriate text.

   TCHAR szText[NAP_MAX_STRING];
   int iLoadStringResult;

   UINT uTextID = m_fDialinAllowed ? IDS_POLICY_GRANT_ACCESS_INFO : IDS_POLICY_DENY_ACCESS_INFO;

   iLoadStringResult = LoadString(  _Module.GetResourceInstance(), uTextID, szText, NAP_MAX_STRING );
   _ASSERT( iLoadStringResult > 0 );

   SetDlgItemText(IDC_STATIC_GRANT_OR_DENY_TEXT, szText );

   return 0;
}


//////////////////////////////////////////////////////////////////////////////
// SetRegistryFootPrint
//////////////////////////////////////////////////////////////////////////////
HRESULT  SetRegistryFootPrint(LPCTSTR servername)
{
   {
      RegKey   RemoteAccessParames;
      LONG  lRes = RemoteAccessParames.Create(
                     RAS_REG_ROOT, 
                     REGKEY_REMOTEACCESS_PARAMS,
                     REG_OPTION_NON_VOLATILE, 
                     KEY_WRITE, 
                     NULL, 
                     servername);
               
      if (lRes != ERROR_SUCCESS)
         return HRESULT_FROM_WIN32(lRes);
   
      //================================================
      // save the values to the key
      DWORD regValue = REGVAL_VAL_USERSCONFIGUREDWITHMMC;
      lRes = RemoteAccessParames.SetValue(REGVAL_NAME_USERSCONFIGUREDWITHMMC, regValue);
   }

   return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyPage1::OnApply

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CPolicyPage1::OnApply()
{
   TRACE_FUNCTION("CPolicyPage1::OnApply");

   WCHAR    wzName[IAS_MAX_STRING];
   HRESULT     hr = S_OK;
   int         iIndex;

   CPoliciesNode* pPoliciesNode = (CPoliciesNode*)m_pPolicyNode->m_pParentNode;

   GetSdoPointers();

   if (!condList.onApply()) { return FALSE; }

   try
   {
      //
      // now we save the policy properties
      //
      CComVariant    var;

      // policy merit value
      V_VT(&var)  = VT_I4;
      V_I4(&var)  = m_pPolicyNode->GetMerit();
      hr = m_spPolicySdo->PutProperty(PROPERTY_POLICY_MERIT, &var);
      if( FAILED(hr) )
      {
         ErrorTrace(DEBUG_NAPMMC_POLICYPAGE1, "Failed to save Merit Value to the policy, err = %x", hr);
         ShowErrorDialog( m_hWnd
                      , IDS_ERROR_SDO_ERROR_PUTPROP_POLICYMERIT
                      , NULL
                      , hr
                     );
         throw hr;
      }
      var.Clear();

      // Commit the changes to the policy.
      hr = m_spPolicySdo->Apply();
      if( FAILED( hr ) )
      {
         // can't commit on Policy
         ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "PolicySdo->Apply() failed, err = %x", hr);
         if(hr == DB_E_NOTABLE)  // assume, the RPC connection has problem
         {
            ShowErrorDialog( m_hWnd, IDS_ERROR__NOTABLE_TO_WRITE_SDO );
         }
         else 
         {
            ShowErrorDialog( m_hWnd, IDS_ERROR_SDO_ERROR_POLICY_APPLY, NULL, hr );
         }

         throw hr;
      }
      
      V_VT(&var)     = VT_BSTR;
      V_BSTR(&var)   = SysAllocString(wzName);

      // Set dialin-bit in profile
      hr = SetDialinSetting(m_fDialinAllowed);
      if ( FAILED(hr) )
      {  
         ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "SetDialinSettings() failed, err = %x", hr);
         ShowErrorDialog( m_hWnd, IDS_ERROR_SDO_ERROR_SETDIALIN, NULL, hr);
         throw hr;
      }

      // Commit changes to the profile.
      hr = m_spProfileSdo->Apply();
      if( FAILED( hr ) )
      {
         // can't commit on Profiles
         ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "ProfileSdo->Apply() failed, err = %x", hr);
         if(hr == DB_E_NOTABLE)  // assume, the RPC connection has problem
            ShowErrorDialog( m_hWnd, IDS_ERROR__NOTABLE_TO_WRITE_SDO );
         else 
            ShowErrorDialog( m_hWnd, IDS_ERROR_SDO_ERROR_PROFILE_APPLY, NULL, hr );
         throw hr;
      }

      // Tell the service to reload data.
      HRESULT hrTemp = m_spSdoServiceControl->ResetService();
      if( FAILED( hrTemp ) )
      {
         ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "ISdoServiceControl::ResetService() failed, err = %x", hrTemp);
      }

      SetRegistryFootPrint((LPCTSTR)m_pPolicyNode->m_pszServerAddress);

      // reset the dirty bit
      SetModified(FALSE);

      //
      // notify the main component
      // it seems we don't need to do this when the node is brand new!
      //

      // The data was accepted, so notify the main context of our snapin
      // that it may need to update its views.
      CChangeNotification * pChangeNotification = new CChangeNotification();
      pChangeNotification->m_dwFlags = CHANGE_UPDATE_RESULT_NODE;
      pChangeNotification->m_pNode = m_pPolicyNode;
      hr = PropertyChangeNotify( (LPARAM) pChangeNotification );
      _ASSERTE( SUCCEEDED( hr ) );
   }
   catch(...)
   {
      // Can't save policy or profile.
      return FALSE;
   }

   return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
/*++
CPolicyPage1::OnQueryCancel

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CPolicyPage1::OnQueryCancel()
{
   return CIASPropertyPage<CPolicyPage1>::OnQueryCancel();
}


// move code from OnQueryCancel to OnCancel to avoid error 0x8001010d when user is being log off
BOOL CPolicyPage1::OnCancel()
{
   TRACE_FUNCTION("CPolicyPage1::OnQueryCancel");
   HRESULT  hr = S_OK;

   hr = m_spPolicySdo->Restore();
   if ( FAILED(hr) )
   {
      if(hr != 0x8001010d)
         ShowErrorDialog(m_hWnd, IDS_ERROR_CANT_RESTORE_POLICY, NULL, hr);
      else
         ShowErrorDialog(m_hWnd, IDS_ERROR_CANT_RESTORE_POLICY, NULL);
   }

   hr = m_spProfileSdo->Restore();
   if ( FAILED(hr) )
   {
      if(hr != 0x8001010d)
         ShowErrorDialog(m_hWnd, IDS_ERROR_CANT_RESTORE_PROFILE, NULL, hr);
      else
         ShowErrorDialog(m_hWnd, IDS_ERROR_CANT_RESTORE_PROFILE, NULL);
   }

   return TRUE;
}

//+---------------------------------------------------------------------------
//
// Function:  OnConditionList
//
// Class:     CConditionPage1
//
// Synopsis:  message handler for the condition list box
//
// Arguments: UINT uNotifyCode - notification code
//            UINT uID -  ID of the control
//            HWND hWnd - HANDLE of the window
//            BOOL &bHandled - whether the handler has processed the msg
//
// Returns:   LRESULT - S_OK: succeeded
//                 S_FALSE: otherwise
//
// History:   Created byao 2/2/98 4:51:35 PM
//
//+---------------------------------------------------------------------------
LRESULT CPolicyPage1::OnConditionList(UINT uNotifyCode, UINT uID, HWND hWnd, BOOL &bHandled)
{
   TRACE_FUNCTION("CPolicyPage1::OnConditionList");

   if (uNotifyCode == LBN_DBLCLK)
   {
      // edit the condition
      OnConditionEdit(uNotifyCode, uID, hWnd, bHandled);
   }
   
   return S_OK;
}


//+---------------------------------------------------------------------------
//
// Function:  OnConditionEdit
//
// Class:     CConditionPage1
//
// Synopsis:  message handler for the condition list box -- user pressed the Edit button
//         we need to edit a particular condition
//
// Arguments: UINT uNotifyCode - notification code
//            UINT uID -  ID of the control
//            HWND hWnd - HANDLE of the window
//            BOOL &bHandled - whether the handler has processed the msg
//
// Returns:   LRESULT - S_OK: succeeded
//                 S_FALSE: otherwise
//
// History:   Created byao 2/21/98 4:51:35 PM
//
//+---------------------------------------------------------------------------
LRESULT CPolicyPage1::OnConditionEdit(UINT uNotifyCode, UINT uID, HWND hWnd, BOOL &bHandled)
{
   TRACE_FUNCTION("CPolicyPage1::OnConditionEdit");

   BOOL modified = FALSE;
   HRESULT hr = condList.onEdit(modified, bHandled);
   if (modified) { SetModified(TRUE); }
   return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  OnConditionRemove
//
// Class:     CConditionPage1
//
// Synopsis:  message handler for the condition list box -- user pressed "Remove"
//         we need to remove this condition
//
// Arguments: UINT uNotifyCode - notification code
//            UINT uID -  ID of the control
//            HWND hWnd - HANDLE of the window
//            BOOL &bHandled - whether the handler has processed the msg
//
// Returns:   LRESULT - S_OK: succeeded
//                 S_FALSE: otherwise
//
// History:   Created byao 2/22/98 4:51:35 PM
//
//+---------------------------------------------------------------------------
LRESULT CPolicyPage1::OnConditionRemove(UINT uMsg, WPARAM wParam, HWND hWnd, BOOL& bHandled)
{
   TRACE_FUNCTION("CPolicyPage1::OnConditionRemove");

   BOOL modified = FALSE;
   HRESULT hr = condList.onRemove(modified, bHandled);
   if (modified) { SetModified(TRUE); }
   return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  CPolicyPage1::GetSdoPointers
//
// Synopsis:  UnMarshall all passed in sdo pointers. These interface pointers
//         have to be unmarshalled first, because MMC PropertyPages run in a
//         separated thread
//       
//         Also get the condition collection sdo from the policy sdo
//
// Arguments: None
//
// Returns:   TRUE;     succeeded
//         FALSE: otherwise
//
// History:   Created Header    byao   2/22/98 1:35:39 AM
//
//+---------------------------------------------------------------------------
BOOL CPolicyPage1::GetSdoPointers()
{
   TRACE_FUNCTION("CPolicyPage1::GetSdoPointers");

   HRESULT hr;

   // Unmarshall the dictionary SDO pointer.
   if ( m_pStreamDictionarySdoMarshall)
   {
      if ( m_spDictionarySdo )
      {
         m_spDictionarySdo.Release();
         m_spDictionarySdo = NULL;
      }

      hr =  CoGetInterfaceAndReleaseStream(
                       m_pStreamDictionarySdoMarshall 
                     , IID_ISdoDictionaryOld          
                     , (LPVOID *) &m_spDictionarySdo
                     );

      // CoGetInterfaceAndReleaseStream releases this pointer even if it fails.
      // We set it to NULL so that our destructor doesn't try to release this again.
      m_pStreamDictionarySdoMarshall = NULL;

      if( FAILED(hr) || m_spDictionarySdo == NULL )
      {
         ShowErrorDialog(m_hWnd,
                     IDS_ERROR_UNMARSHALL,
                     NULL,
                     hr
                  );
         return FALSE;
      }
   }

   // Unmarshall the profile SDO interface pointers.
   if ( m_pStreamProfileSdoMarshall)
   {
      if ( m_spProfileSdo )
      {
         m_spProfileSdo.Release();
         m_spProfileSdo = NULL;
      }

      hr =  CoGetInterfaceAndReleaseStream(
                       m_pStreamProfileSdoMarshall 
                     , IID_ISdo  
                     , (LPVOID *) &m_spProfileSdo
                     );

      // CoGetInterfaceAndReleaseStream releases this pointer even if it fails.
      // We set it to NULL so that our destructor doesn't try to release this again.
      m_pStreamProfileSdoMarshall = NULL;

      if( FAILED( hr) || m_spProfileSdo == NULL )
      {
         ShowErrorDialog(m_hWnd,
                     IDS_ERROR_UNMARSHALL,
                     NULL,
                     hr
                  );
         return FALSE;
      }
   }

   // Unmarshall the policy SDO interface pointers.
   if ( m_pStreamPolicySdoMarshall)
   {
      m_spPolicySdo.Release();
      m_spPolicySdo = NULL;

      hr =  CoGetInterfaceAndReleaseStream(
                       m_pStreamPolicySdoMarshall  
                     , IID_ISdo        
                     , (LPVOID *) &m_spPolicySdo
                     );

      // CoGetInterfaceAndReleaseStream releases this pointer even if it fails.
      // We set it to NULL so that our destructor doesn't try to release this again.
      m_pStreamPolicySdoMarshall = NULL;

      if( FAILED( hr) || m_spPolicySdo == NULL )
      {
         ShowErrorDialog(m_hWnd,
                     IDS_ERROR_UNMARSHALL,
                     NULL,
                     hr
                  );

         return FALSE;
      }
   }

   // Unmarshall the profile collection SDO interface pointers.
   if ( m_pStreamProfilesCollectionSdoMarshall )
   {
      if ( m_spProfilesCollectionSdo )
      {
         m_spProfilesCollectionSdo.Release();
         m_spProfilesCollectionSdo = NULL;
      }

      hr =  CoGetInterfaceAndReleaseStream(
                       m_pStreamProfilesCollectionSdoMarshall  
                     , IID_ISdoCollection 
                     , (LPVOID *) &m_spProfilesCollectionSdo
                     );

      // CoGetInterfaceAndReleaseStream releases this pointer even if it fails.
      // We set it to NULL so that our destructor doesn't try to release this again.
      m_pStreamProfilesCollectionSdoMarshall = NULL;

      if( FAILED( hr) || m_spProfilesCollectionSdo == NULL )
      {
         ShowErrorDialog(m_hWnd,
                     IDS_ERROR_UNMARSHALL,
                     NULL,
                     hr
                  );
         return FALSE;
      }
   }

   // Unmarshall the policy collection SDO interface pointers.
   if ( m_pStreamPoliciesCollectionSdoMarshall )
   {
      if ( m_spPoliciesCollectionSdo )
      {
         m_spPoliciesCollectionSdo.Release();
         m_spPoliciesCollectionSdo = NULL;
      }

      hr =  CoGetInterfaceAndReleaseStream(
                       m_pStreamPoliciesCollectionSdoMarshall  
                     , IID_ISdoCollection 
                     , (LPVOID *) &m_spPoliciesCollectionSdo
                     );

      // CoGetInterfaceAndReleaseStream releases this pointer even if it fails.
      // We set it to NULL so that our destructor doesn't try to release this again.
      m_pStreamPoliciesCollectionSdoMarshall = NULL;

      if( FAILED( hr) || m_spPoliciesCollectionSdo == NULL )
      {
         ShowErrorDialog(m_hWnd,
                     IDS_ERROR_UNMARSHALL,
                     NULL,
                     hr
                  );
         return FALSE;
      }
   }

   // Unmarshall the policy collection SDO interface pointers.
   if ( m_pStreamSdoServiceControlMarshall )
   {
      if ( m_spSdoServiceControl )
      {
         m_spSdoServiceControl.Release();
         m_spSdoServiceControl = NULL;
      }

      hr =  CoGetInterfaceAndReleaseStream(
                       m_pStreamSdoServiceControlMarshall
                     , IID_ISdoServiceControl   
                     , (LPVOID *) &m_spSdoServiceControl
                     );

      // CoGetInterfaceAndReleaseStream releases this pointer even if it fails.
      // We set it to NULL so that our destructor doesn't try to release this again.
      m_pStreamSdoServiceControlMarshall = NULL;

      if( FAILED( hr) || ! m_spSdoServiceControl )
      {
         ShowErrorDialog(m_hWnd,
                     IDS_ERROR_UNMARSHALL,
                     NULL,
                     hr
                  );
         return FALSE;
      }
   }

   //
   // get the condition collection of this sdo
   //
   if ( m_spPolicySdo )
   {
      if ( m_spConditionCollectionSdo )
      {
         m_spConditionCollectionSdo.Release();
         m_spConditionCollectionSdo = NULL;
      }

      hr = ::GetSdoInterfaceProperty(
                  m_spPolicySdo,
                  PROPERTY_POLICY_CONDITIONS_COLLECTION,
                  IID_ISdoCollection,
                  (void **) &m_spConditionCollectionSdo);
      
      if( FAILED( hr) || m_spConditionCollectionSdo == NULL )
      {
         ShowErrorDialog(m_hWnd,
                     IDS_ERROR_UNMARSHALL,
                     NULL,
                     hr
                  );

         return FALSE;
      }
   }

   return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyPage1::OnEditProfile

--*/
//////////////////////////////////////////////////////////////////////////////

//////////
// Signature of the entry point to the profile editing DLL.
//////////
typedef HRESULT (APIENTRY *OPENRAS_IASPROFILEDLG)(
            LPCWSTR pszMachineName,
            ISdo* pProfile,            // profile SDO pointer
            ISdoDictionaryOld*   pDictionary,   // dictionary SDO pointer
            BOOL  bReadOnly,           // if the dlg is for readonly
            DWORD dwTabFlags,          // what to show
            void  *pvData              // additional data
   );

LRESULT CPolicyPage1::OnEditProfile(UINT uMsg, WPARAM wParam, HWND hwnd, BOOL& bHandled)
{
   TRACE_FUNCTION("CPolicyPage1::OnEditProfile");

   OPENRAS_IASPROFILEDLG   pfnProfileEditor = NULL;

   HRESULT     hr       = S_OK;
   HMODULE     hProfileDll = NULL;

   hProfileDll = LoadLibrary(_T("rasuser.dll"));
   if ( NULL == hProfileDll )
   {
      hr = HRESULT_FROM_WIN32(GetLastError());
      ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "LoadLibrary() failed, err = %x", hr);

      ShowErrorDialog(m_hWnd, IDS_ERROR_CANT_FIND_PROFILEDLL, NULL, hr);
      return 0;
   }
   
   pfnProfileEditor = (OPENRAS_IASPROFILEDLG) GetProcAddress(hProfileDll, "OpenRAS_IASProfileDlg");
   if ( NULL == pfnProfileEditor )
   {
      hr = HRESULT_FROM_WIN32(GetLastError());
      ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "GetProcAddress() failed, err = %x", hr);

      ShowErrorDialog(m_hWnd, IDS_ERROR_CANT_FIND_PROFILEAPI, NULL, hr);
      FreeLibrary(hProfileDll);
      return 0;
   }

   // findout if this is extending RRAS or IAS
   
   CPoliciesNode* pPoliciesNode = dynamic_cast<CPoliciesNode*>(m_pPolicyNode->m_pParentNode);

   DWORD dwFlags = RAS_IAS_PROFILEDLG_SHOW_IASTABS;
   if(pPoliciesNode != NULL)
   {
      if(!pPoliciesNode->m_fExtendingIAS)
         dwFlags = RAS_IAS_PROFILEDLG_SHOW_RASTABS;
   }

   if(m_isWin2k)
   {
      dwFlags |= RAS_IAS_PROFILEDLG_SHOW_WIN2K;
   }

   //
   // now we do have this profile sdo, call the API
   //
   hr = pfnProfileEditor(
               m_pPolicyNode->m_pszServerAddress,
               m_spProfileSdo,
               m_spDictionarySdo,
               FALSE,
               dwFlags,
               (void *)&(m_pIASAttrList->m_AttrList)
            );
   FreeLibrary(hProfileDll);
   DebugTrace(DEBUG_NAPMMC_POLICYPAGE1, "OpenRAS_IASProfileDlg() returned %x", hr);
   if ( FAILED(hr) )
   {
      return hr;
   }

   return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  CPolicyPage1::GetDialinSetting
//
// Synopsis:  Check whether the user is allowed to dial in. This function will
//         set the dialin bit
//
// Argument:  BOOL& fDialinAllowed;
//
// Returns:   succeed or not
//
// History:   Created Header    byao   2/27/98 3:59:38 PM
//
//+---------------------------------------------------------------------------
HRESULT  CPolicyPage1::GetDialinSetting(BOOL& fDialinAllowed)
{
   TRACE_FUNCTION("CPolicyPage1::GetDialinSetting");

   long              ulCount;
   ULONG             ulCountReceived;
   HRESULT              hr = S_OK;

   CComBSTR          bstr;
   CComPtr<IUnknown>    spUnknown;
   CComPtr<IEnumVARIANT>   spEnumVariant;
   CComVariant          var;

   // by default, dialin is allowed
   fDialinAllowed = TRUE;

   //
    // get the attribute collection of this profile
    //
   CComPtr<ISdoCollection> spProfAttrCollectionSdo;
   hr = ::GetSdoInterfaceProperty(m_spProfileSdo,
                          (LONG)PROPERTY_PROFILE_ATTRIBUTES_COLLECTION,
                          IID_ISdoCollection,
                          (void **) &spProfAttrCollectionSdo
                         );
   if ( FAILED(hr) )
   {
      return hr;
   }
   _ASSERTE(spProfAttrCollectionSdo);


   // We check the count of items in our collection and don't bother getting the
   // enumerator if the count is zero.
   // This saves time and also helps us to a void a bug in the the enumerator which
   // causes it to fail if we call next when it is empty.
   hr = spProfAttrCollectionSdo->get_Count( & ulCount );
   DebugTrace(DEBUG_NAPMMC_POLICYPAGE1, "Number of prof attributes: %d", ulCount);
   if ( FAILED(hr) )
   {
      ShowErrorDialog(m_hWnd,
                  IDS_ERROR_SDO_ERROR_PROFATTRCOLLECTION,
                  NULL,
                  hr);
      return hr;
   }


   if ( ulCount > 0)
   {
      // Get the enumerator for the attribute collection.
      hr = spProfAttrCollectionSdo->get__NewEnum( (IUnknown **) & spUnknown );
      if ( FAILED(hr) )
      {
         ShowErrorDialog(m_hWnd,
                     IDS_ERROR_SDO_ERROR_PROFATTRCOLLECTION,
                     NULL,
                     hr);
         return hr;
      }

      hr = spUnknown->QueryInterface( IID_IEnumVARIANT, (void **) &spEnumVariant );
      spUnknown.Release();
      if ( FAILED(hr) )
      {
         ShowErrorDialog(m_hWnd,
                     IDS_ERROR_SDO_ERROR_QUERYINTERFACE,
                     NULL,
                     hr);
         return hr;
      }
      _ASSERTE( spEnumVariant != NULL );

      // Get the first item.
      hr = spEnumVariant->Next( 1, &var, &ulCountReceived );
      while( SUCCEEDED( hr ) && ulCountReceived == 1 )
      {
         // Get an sdo pointer from the variant we received.
         _ASSERTE( V_VT(&var) == VT_DISPATCH );
         _ASSERTE( V_DISPATCH(&var) != NULL );

         CComPtr<ISdo> spSdo;
         hr = V_DISPATCH(&var)->QueryInterface( IID_ISdo, (void **) &spSdo );
         if ( !SUCCEEDED(hr))
         {
            ShowErrorDialog(m_hWnd,
                        IDS_ERROR_SDO_ERROR_QUERYINTERFACE,
                        NULL
                     );
            return hr;
         }

            //
            // get attribute ID
            //
         var.Clear();
         hr = spSdo->GetProperty(PROPERTY_ATTRIBUTE_ID, &var);
         if ( !SUCCEEDED(hr) )
         {
            ShowErrorDialog(m_hWnd, IDS_ERROR_SDO_ERROR_GETATTRINFO, NULL, hr);
            return hr;
         }

         _ASSERTE( V_VT(&var) == VT_I4 );       
         DWORD dwAttrId = V_I4(&var);
         
         if ( dwAttrId == (DWORD)IAS_ATTRIBUTE_ALLOW_DIALIN)
         {
            // found this one in the profile, check for its value
            var.Clear();
            hr = spSdo->GetProperty(PROPERTY_ATTRIBUTE_VALUE, &var);
            if ( !SUCCEEDED(hr) )
            {
               ShowErrorDialog(m_hWnd, IDS_ERROR_SDO_ERROR_GETATTRINFO, NULL, hr);
               return hr;
            }

            _ASSERTE( V_VT(&var)== VT_BOOL);
            fDialinAllowed = ( V_BOOL(&var)==VARIANT_TRUE);
            return S_OK;
         }

         // Clear the variant of whatever it had --
         // this will release any data associated with it.
         var.Clear();

         // Get the next item.
         hr = spEnumVariant->Next( 1, &var, &ulCountReceived );
         if ( !SUCCEEDED(hr))
         {
            ShowErrorDialog(m_hWnd,
                        IDS_ERROR_SDO_ERROR_PROFATTRCOLLECTION,
                        NULL,
                        hr
                     );
            return hr;
         }
      } // while
   } // if

   return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  CPolicyPage1::SetDialinSetting
//
// Synopsis:  set the dialin bit into the profile
//
// Argument:  BOOL& fDialinAllowed;
//
// Returns:   succeed or not
//
// History:   Created Header    byao   2/27/98 3:59:38 PM
//
//+---------------------------------------------------------------------------
HRESULT  CPolicyPage1::SetDialinSetting(BOOL fDialinAllowed)
{
   TRACE_FUNCTION("CPolicyPage1::SetDialinSetting");

   long              ulCount;
   ULONG             ulCountReceived;
   HRESULT              hr = S_OK;

   CComBSTR          bstr;
   CComPtr<IUnknown>    spUnknown;
   CComPtr<IEnumVARIANT>   spEnumVariant;
   CComVariant          var;

   //
    // get the attribute collection of this profile
    //
   CComPtr<ISdoCollection> spProfAttrCollectionSdo;
   hr = ::GetSdoInterfaceProperty(m_spProfileSdo,
                          (LONG)PROPERTY_PROFILE_ATTRIBUTES_COLLECTION,
                          IID_ISdoCollection,
                          (void **) &spProfAttrCollectionSdo
                         );
   if ( FAILED(hr) )
   {
      return hr;
   }
   _ASSERTE(spProfAttrCollectionSdo);

   // We check the count of items in our collection and don't bother getting the
   // enumerator if the count is zero.
   // This saves time and also helps us to a void a bug in the the enumerator which
   // causes it to fail if we call next when it is empty.
   hr = spProfAttrCollectionSdo->get_Count( & ulCount );
   if ( FAILED(hr) )
   {
      ShowErrorDialog(m_hWnd,
                  IDS_ERROR_SDO_ERROR_PROFATTRCOLLECTION,
                  NULL,
                  hr);
      return hr;
   }

   if ( ulCount > 0)
   {
      // Get the enumerator for the attribute collection.
      hr = spProfAttrCollectionSdo->get__NewEnum( (IUnknown **) & spUnknown );
      if ( FAILED(hr) )
      {
         ShowErrorDialog(m_hWnd,
                     IDS_ERROR_SDO_ERROR_PROFATTRCOLLECTION,
                     NULL,
                     hr);
         return hr;
      }

      hr = spUnknown->QueryInterface( IID_IEnumVARIANT, (void **) &spEnumVariant );
      spUnknown.Release();
      if ( FAILED(hr) )
      {
         ShowErrorDialog(m_hWnd,
                     IDS_ERROR_SDO_ERROR_QUERYINTERFACE,
                     NULL,
                     hr
                  );
         return hr;
      }
      _ASSERTE( spEnumVariant != NULL );

      // Get the first item.
      hr = spEnumVariant->Next( 1, &var, &ulCountReceived );
      while( SUCCEEDED( hr ) && ulCountReceived == 1 )
      {
         // Get an sdo pointer from the variant we received.
         _ASSERTE( V_VT(&var) == VT_DISPATCH );
         _ASSERTE( V_DISPATCH(&var) != NULL );

         CComPtr<ISdo> spSdo;
         hr = V_DISPATCH(&var)->QueryInterface( IID_ISdo, (void **) &spSdo );
         if ( !SUCCEEDED(hr))
         {
            ShowErrorDialog(m_hWnd,
                        IDS_ERROR_SDO_ERROR_QUERYINTERFACE,
                        NULL
                     );
            return hr;
         }

            //
            // get attribute ID
            //
         var.Clear();
         hr = spSdo->GetProperty(PROPERTY_ATTRIBUTE_ID, &var);
         if ( !SUCCEEDED(hr) )
         {
            ShowErrorDialog(m_hWnd, IDS_ERROR_SDO_ERROR_GETATTRINFO, NULL, hr);
            return hr;
         }

         _ASSERTE( V_VT(&var) == VT_I4 );       
         DWORD dwAttrId = V_I4(&var);
         

         if ( dwAttrId == (DWORD)IAS_ATTRIBUTE_ALLOW_DIALIN )
         {
            // found this one in the profile, check for its value
            var.Clear();
            V_VT(&var) = VT_BOOL;
            V_BOOL(&var) = fDialinAllowed ? VARIANT_TRUE: VARIANT_FALSE ;
            hr = spSdo->PutProperty(PROPERTY_ATTRIBUTE_VALUE, &var);
            if ( !SUCCEEDED(hr) )
            {
               ShowErrorDialog(m_hWnd, IDS_ERROR_SDO_ERROR_SETDIALIN, NULL, hr);
               return hr;
            }
            return S_OK;
         }

         // Clear the variant of whatever it had --
         // this will release any data associated with it.
         var.Clear();

         // Get the next item.
         hr = spEnumVariant->Next( 1, &var, &ulCountReceived );
         if ( !SUCCEEDED(hr))
         {
            ShowErrorDialog(m_hWnd,
                        IDS_ERROR_SDO_ERROR_PROFATTRCOLLECTION,
                        NULL,
                        hr);
            return hr;
         }
      } // while
   } // if

   // if we reach here, it means we either haven't found the attribute,
   // or the profile doesn't have anything in its attribute collection.
   if ( !fDialinAllowed )
   {
      // we don't need to do anything if dialin is allowed, becuase if this
      // attribute is not in the profile, then dialin is by default allowed

      // but we need to add this attribute to the profile if it's DENIED
      // create the SDO for this attribute
      CComPtr<IDispatch>   spDispatch;
      hr =  m_spDictionarySdo->CreateAttribute( (ATTRIBUTEID)IAS_ATTRIBUTE_ALLOW_DIALIN,
                                      (IDispatch**)&spDispatch.p);
      if ( !SUCCEEDED(hr) )
      {
         ShowErrorDialog(m_hWnd,
                     IDS_ERROR_SDO_ERROR_SETDIALIN,
                     NULL,
                     hr
                  );
         return hr;
      }

      _ASSERTE( spDispatch.p != NULL );

      // add this node to profile attribute collection
      hr = spProfAttrCollectionSdo->Add(NULL, (IDispatch**)&spDispatch.p);
      if ( !SUCCEEDED(hr) )
      {
         ShowErrorDialog(m_hWnd,
                     IDS_ERROR_SDO_ERROR_SETDIALIN,
                     NULL,
                     hr
                  );
         return hr;
      }

      //
      // get the ISdo pointer
      //
      CComPtr<ISdo> spAttrSdo;
      hr = spDispatch->QueryInterface( IID_ISdo, (void **) &spAttrSdo);
      if ( !SUCCEEDED(hr) )
      {
         ShowErrorDialog(m_hWnd,
                     IDS_ERROR_SDO_ERROR_QUERYINTERFACE,
                     NULL,
                     hr
                  );
         return hr;
      }

      _ASSERTE( spAttrSdo != NULL );
            
      // set sdo property for this attribute
      CComVariant var;

      // set value
      V_VT(&var) = VT_BOOL;
      V_BOOL(&var) = VARIANT_FALSE;
            
      hr = spAttrSdo->PutProperty(PROPERTY_ATTRIBUTE_VALUE, &var);
      if ( !SUCCEEDED(hr) )
      {
         ShowErrorDialog(m_hWnd, IDS_ERROR_SDO_ERROR_SETDIALIN, NULL, hr );
         return hr;
      }

      var.Clear();

   } // if (!dialinallowed)

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\policypage1.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation

Module Name:

   PolicyPage1.h

Abstract:

   Header file for the CPolicyPage1 class.

   This is our handler class for the first CPolicyNode property page.

   See PolicyPage1.cpp for implementation.

--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NAP_POLICY_PAGE_1_H_)
#define _NAP_POLICY_PAGE_1_H_

//===============================================================
// for local case, neet to set footprint after saving data
#define RAS_REG_ROOT          HKEY_LOCAL_MACHINE
#define REGKEY_REMOTEACCESS_PARAMS  L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters"
#define REGVAL_NAME_USERSCONFIGUREDWITHMMC  L"UsersConfiguredWithMMC"
#define REGVAL_VAL_USERSCONFIGUREDWITHMMC   1


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "PropertyPage.h"
//
//
// where we can find what this class has or uses:
//
class CPolicyNode;
#include "Condition.h"
#include "IASAttrList.h"
#include "condlist.h"
#include "atltmp.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


class CPolicyPage1 : public CIASPropertyPage<CPolicyPage1>
{

public :

   // ISSUE: how is base class initialization going to work with subclassing???
   CPolicyPage1(     
           LONG_PTR hNotificationHandle
         , CPolicyNode *pPolicyNode
         , CIASAttrList *pIASAttrList
         , TCHAR* pTitle = NULL
         , BOOL bOwnsNotificationHandle = FALSE
         , bool isWin2k = false
         );

   ~CPolicyPage1();

   // This is the ID of the dialog resource we want for this class.
   // An enum is used here because the correct value of
   // IDD must be initialized before the base class's constructor is called
   enum { IDD = IDD_PROPPAGE_POLICY1 };

   BEGIN_MSG_MAP(CPolicyPage1)
      MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
      COMMAND_ID_HANDLER(IDC_BUTTON_CONDITION_ADD, OnConditionAdd)
      COMMAND_ID_HANDLER(IDC_BUTTON_CONDITION_REMOVE, OnConditionRemove)
      COMMAND_ID_HANDLER(IDC_LIST_CONDITIONS, OnConditionList)
      COMMAND_ID_HANDLER(IDC_BUTTON_CONDITION_EDIT, OnConditionEdit)
      COMMAND_ID_HANDLER( IDC_BUTTON_EDITPROFILE, OnEditProfile )
      COMMAND_ID_HANDLER( IDC_RADIO_DENY_DIALIN, OnDialinCheck)
      COMMAND_ID_HANDLER( IDC_RADIO_GRANT_DIALIN, OnDialinCheck)
      CHAIN_MSG_MAP(CIASPropertyPage<CPolicyPage1>)
   END_MSG_MAP()

   LRESULT OnInitDialog(
        UINT uMsg
      , WPARAM wParam
      , LPARAM lParam
      , BOOL& bHandled
      );

   LRESULT OnConditionAdd(
        UINT uMsg
      , WPARAM wParam
      , HWND hWnd
      , BOOL& bHandled
      );

   LRESULT OnEditProfile(
        UINT uMsg
      , WPARAM wParam
      , HWND hWnd
      , BOOL& bHandled
      );

   LRESULT OnDialinCheck(
        UINT uMsg
      , WPARAM wParam
      , HWND hWnd
      , BOOL& bHandled
      );

   LRESULT OnConditionRemove(
        UINT uMsg
      , WPARAM wParam
      , HWND hWnd
      , BOOL& bHandled
      );

   LRESULT OnConditionList(
        UINT uNotifyCode,
        UINT uID,
        HWND hWnd,
        BOOL &bHandled
       );

   LRESULT OnConditionEdit(
        UINT uNotifyCode,
        UINT uID,
        HWND hWnd,
        BOOL &bHandled
       );

   BOOL OnApply();
   BOOL OnQueryCancel();
   BOOL OnCancel();

public:
   BOOL m_fDialinAllowed;
   
   // Pointer to streams into which this page's Sdo interface
   // pointers will be marshalled.
   LPSTREAM m_pStreamPolicySdoMarshall;   // marshalled policy sdo pointer
   LPSTREAM m_pStreamDictionarySdoMarshall; // marshalled dictionary sdo pointer
   LPSTREAM m_pStreamProfileSdoMarshall; // marshalled profile sdo
   LPSTREAM m_pStreamProfilesCollectionSdoMarshall; // marshalled profile collection sdo
   LPSTREAM m_pStreamPoliciesCollectionSdoMarshall; // marshalled policy collection sdo
   LPSTREAM m_pStreamSdoServiceControlMarshall; // marshalled policy collection sdo

protected:

   BOOL  GetSdoPointers();
   HRESULT  GetDialinSetting(BOOL &fDialinAllowed);
   HRESULT  SetDialinSetting(BOOL fDialinAllowed);

   CPolicyNode *m_pPolicyNode;   // policy node pointer
   CIASAttrList *m_pIASAttrList; // condition attribute list

   bool m_isWin2k;
   // condition collection -- created in the page
   CComPtr<ISdoCollection> m_spConditionCollectionSdo; // condition collection

   // profile sdos
   CComPtr<ISdoDictionaryOld> m_spDictionarySdo;  // dictionary sdo pointer
   CComPtr<ISdo>        m_spProfileSdo;            // profiles collection sdo pointer
   CComPtr<ISdo>        m_spPolicySdo;          // policy sdo pointer
   CComPtr<ISdoCollection> m_spProfilesCollectionSdo;    // profile collection Sdo
   CComPtr<ISdoCollection> m_spPoliciesCollectionSdo;    // policy collection Sdo

   // Smart pointer to interface for telling service to reload data.
   CComPtr<ISdoServiceControl>   m_spSdoServiceControl;

   //
   // condition list
   //
   ConditionList condList;
};

#endif // _NAP_POLICY_PAGE_1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\policynode.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation

Module Name:

    PolicyNode.h

Abstract:

   Header file for the CPolicyNode subnode

   See PolicyNode.cpp for implementation.

Revision History:
   mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NAP_POLICY_NODE_H_)
#define _NAP_POLICY_NODE_H_


//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "SnapinNode.h"
#include "Condition.h"
//
//
// For include file dependency reasons, we have forward declarations here,
// and include the needed header files in our .cpp files.
//

#include "IASAttrList.h"

class CPoliciesNode;
class CPolicyPage1;
class CPolicyPage2;
class CComponentData;
class CComponent;

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

// policy node

class CPolicyNode : public CSnapinNode< CPolicyNode, CComponentData, CComponent >
{

public:
   CPolicyNode(CSnapInItem*   pParentNode,
            LPTSTR         pszServerAddress,
            CIASAttrList*  pAttrList,
            BOOL        fBrandNewNode,
            BOOL        fUseActiveDirectory,
            bool        isWin2k
         );

   ~CPolicyNode();

public:
   SNAPINMENUID(IDM_POLICY_NODE)

   BEGIN_SNAPINTOOLBARID_MAP(CPolicyNode)
      SNAPINTOOLBARID_ENTRY(IDR_POLICY_TOOLBAR)
   END_SNAPINTOOLBARID_MAP()

   BEGIN_SNAPINCOMMAND_MAP(CPolicyNode, TRUE)
      SNAPINCOMMAND_ENTRY(ID_MENUITEM_POLICY_TOP__MOVE_UP, OnPolicyMoveUp)
      SNAPINCOMMAND_ENTRY(ID_BUTTON_POLICY_MOVEUP, OnPolicyMoveUp)
      SNAPINCOMMAND_ENTRY(ID_MENUITEM_POLICY_TOP__MOVE_DOWN, OnPolicyMoveDown)
      SNAPINCOMMAND_ENTRY(ID_BUTTON_POLICY_MOVEDOWN, OnPolicyMoveDown)
   END_SNAPINCOMMAND_MAP() 

   HRESULT OnPolicyMoveUp( bool &bHandled, CSnapInObjectRootBase* pObj );
   HRESULT OnPolicyMoveDown( bool &bHandled, CSnapInObjectRootBase* pObj );

   STDMETHOD(CreatePropertyPages)(
        LPPROPERTYSHEETCALLBACK pPropertySheetCallback
      , LONG_PTR handle
      , IUnknown* pUnk
      , DATA_OBJECT_TYPES type
      );

   STDMETHOD(ControlbarNotify)(IControlbar *pControlbar,
      IExtendControlbar *pExtendControlbar,
      CSimpleMap<UINT, IUnknown*>* pToolbarMap,
      MMC_NOTIFY_TYPE event,
      LPARAM arg, 
      LPARAM param,
      CSnapInObjectRootBase* pObj,
      DATA_OBJECT_TYPES type);

   STDMETHOD(QueryPagesFor)( DATA_OBJECT_TYPES type );

   OLECHAR* GetResultPaneColInfo(int nCol);
   void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags);
   BOOL UpdateToolbarButton(UINT id, BYTE fsState);


   virtual HRESULT OnRename(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         );
   
   virtual HRESULT OnDelete(
           LPARAM arg
         , LPARAM param
         , IComponentData * pComponentData
         , IComponent * pComponent
         , DATA_OBJECT_TYPES type
         , BOOL fSilent
         );
   virtual HRESULT OnPropertyChange(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );


   virtual HRESULT SetVerbs( IConsoleVerb * pConsoleVerb );

   CComponentData * GetComponentData( void );

   int GetMerit();
   BOOL SetMerit(int nMeritValue);

   //
   // set the sdo pointer. Here we just need the PolicySdo pointer
   //
   HRESULT SetSdo(     ISdo *pPolicySdo
               , ISdoDictionaryOld *pDictionarySdo
               , ISdo *pProfileSdo
               , ISdoCollection *pProfilesCollectionSdo
               , ISdoCollection *pPoliciesCollectionSdo
               , ISdoServiceControl * pSdoServiceControl
             );

   HRESULT LoadSdoData();

   BOOL IsBrandNew() { return m_fBrandNewNode;}
   void SetBrandNew(BOOL fBrandNew) { m_fBrandNewNode = fBrandNew; }


   LPTSTR         m_pszServerAddress; // server name
   CPolicyPage1*  m_pPolicyPage1;      // pointer to the property page of this node

   CComPtr<ISdo>        m_spPolicySdo;
   CComPtr<ISdo>        m_spProfileSdo;

protected:
    // Interface pointers to the Sdo objects.
   CComPtr<ISdoDictionaryOld> m_spDictionarySdo;
   CComPtr<ISdoCollection> m_spProfilesCollectionSdo;
   CComPtr<ISdoCollection> m_spPoliciesCollectionSdo;


   // Smart pointer to interface for telling service to reload data.
   CComPtr<ISdoServiceControl>   m_spSdoServiceControl;

   // pointer to the global condition attribute list
   //
   CIASAttrList *m_pAttrList;

private:
   int      m_nMeritValue;       // a numeric value, actually invoking sequence
   TCHAR m_tszMeritString[64];   // merit value in string format
   BOOL  m_fBrandNewNode;     // is this a new node?
   BOOL  m_fUseActiveDirectory;  // Are we getting this policy from active directory?
   LPTSTR   m_ptzLocation;
   bool m_isWin2k;
   CSnapInObjectRootBase* m_pControBarNotifySnapinObj;

};

#endif // _NAP_CLIENT_NODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\rapwiz.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the RAP wizard classes.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef RAPWIZ_H
#define RAPWIZ_H
#pragma once

#include "atltmp.h"
#include "helper.h"
#include "ntgroups.h"
#include "EapProfile.h"
#include "PropertyPage.h"

class CPolicyNode;

#define  DIALUP_PORT_CONDITION   L"MATCH(\"NAS-Port-Type=^0$|^2$|^3$|^4$\")"
#define  VPN_PORT_CONDITION   L"MATCH(\"NAS-Port-Type=^5$\")"
#define  WIRELESS_PORT_CONDITION L"MATCH(\"NAS-Port-Type=^18$|^19$\")"
#define  SWITCH_PORT_CONDITION   L"MATCH(\"NAS-Port-Type=^15$\")"

#define  DONT_CARE   0xff

void SetWizardLargeFont(HWND hWnd, int controlId);

struct CRapWizScenario
{
   DWORD m_dwScenarioID;

   // affect authentication, encryption, eap page
   BOOL  m_bAllowClear;
   // TRUE: show the No ENcryption box
   // FALSE: not to show
   // DONT_CARE: the page is not shown, so when the scenario is used, the encryption attributes should be cleared

   // affect EAP
   BOOL  m_bAllowEncryptionEAP;
   BOOL  m_bAllowClearEAP;

   // Exclude flags
   DWORD m_excludeFlag;

   // pre-conditions
   LPCTSTR  m_lpszPreCond;

   // write -- manual set to FALSE
   BOOL  m_bSheetWriteSDO;

   // determine page order
   DWORD*   m_pdwPages;
};

class CIASAttrList;
// policy creation wizard
class CRapWizardData : public CComObjectRootEx<CComSingleThreadModel>, public IUnknown
{
   BEGIN_COM_MAP(CRapWizardData)
      COM_INTERFACE_ENTRY(IUnknown)
   END_COM_MAP()
public:
   CRapWizardData();
   void SetInfo(LPCTSTR czMachine, CPolicyNode* pNode, ISdoDictionaryOld* pDic, ISdo* pPolicy, ISdo* pProfile, ISdoCollection* pPolicyCol, ISdoCollection* pProfileCol, ISdoServiceControl* pServiceCtrl, CIASAttrList* pAttrList) ;
   DWORD GetNextPageId(LPCTSTR pszCurrTemplate);
   DWORD GetPrevPageId(LPCTSTR pszCurrTemplate);
   BOOL  SetScenario(DWORD dwScenario);
   CRapWizScenario* GetScenario()   {     return m_Scenarios[m_dwScenarioIndex]; };
   CRapWizScenario** GetAllScenarios()    {     return m_Scenarios;  };
   BOOL GetSettingsText(::CString& str);

   // called by pages to finish the job
   BOOL OnWizardFinish(HWND hWnd);

   // called by when entering the finish page
   BOOL OnWizardPreFinish(HWND hWnd);

   // User bit or group
   DWORD m_dwUserOrGroup;

   // group
   NTGroup_ListView  m_NTGroups;

   // authentication
   BOOL  m_bEAP;
   DWORD m_dwEAPProvider;
   EapProfile m_eapProfile;

   BOOL  m_bMSCHAP;
   BOOL  m_bMSCHAP2;

   // encryption
   BOOL  m_bEncrypt_No;
   BOOL  m_bEncrypt_Basic;
   BOOL  m_bEncrypt_Strong;
   BOOL  m_bEncrypt_Strongest;

   // Allow/deny dialin
   BOOL m_bAllowDialin;

   // policy data
   // Policy and profile SDO's.
   CComPtr<ISdoDictionaryOld> m_spDictionarySdo;  // dictionary sdo pointer
   CComPtr<ISdo>        m_spProfileSdo;            // profiles collection sdo pointer
   CComPtr<ISdo>        m_spPolicySdo;          // policy sdo pointer
   CComPtr<ISdoCollection> m_spProfilesCollectionSdo;    // profile collection Sdo
   CComPtr<ISdoCollection> m_spPoliciesCollectionSdo;    // policy collection Sdo
   CComPtr<ISdoServiceControl>   m_spSdoServiceControl;
   CIASAttrList*        m_pAttrList;

   // related to MMC
   CPolicyNode *m_pPolicyNode;   // policy node pointer

   // information for population the finished page
   ::CString   m_strPolicyName;
   ::CString   m_strEAPProvider;


protected:
   // Scenario
   DWORD m_dwScenarioIndex;

   // page sequence information
   static CRapWizScenario* m_Scenarios[];
};


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NewPolicyStartPage
//
// DESCRIPTION
//
//    Implements the Welcome page.
//
///////////////////////////////////////////////////////////////////////////////
class CPolicyWizard_Start : public CIASWizard97Page<CPolicyWizard_Start, 0, 0>
{
public:
   CPolicyWizard_Start(
         CRapWizardData* WizData
         ,  LONG_PTR hNotificationHandle
         , TCHAR* pTitle = NULL
         , BOOL bOwnsNotificationHandle = FALSE
         ) : m_spWizData(WizData),
            CIASWizard97Page<CPolicyWizard_Start, 0, 0>(hNotificationHandle,pTitle, bOwnsNotificationHandle)
         {
            _ASSERTE(WizData);
         };

   enum { IDD = IDD_NEWRAPWIZ_WELCOME };


   BOOL OnWizardNext()
   {
      // reset the dirty bit
      SetModified(FALSE);

      return m_spWizData->GetNextPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);
   };

   LRESULT OnInitDialog(
        UINT uMsg
      , WPARAM wParam
      , LPARAM lParam
      , BOOL& bHandled
      )
   {
      SetWizardLargeFont(m_hWnd, IDC_NEWRAPWIZ_STATIC_LARGE);

      return TRUE;
   };

   virtual BOOL OnSetActive()
   {
      ::PropSheet_SetWizButtons(GetParent(), PSWIZB_NEXT);

      return TRUE;
   };

protected:
   CComPtr<CRapWizardData>    m_spWizData;

public:
   BEGIN_MSG_MAP(CPolicyWizard_Start)
      MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
// we have problem with chaining the wizard class, so we chain it's base class instead
//    CHAIN_MSG_MAP( CIASWizard97Page<CPolicyWizard_Start, 0, 0> )
      CHAIN_MSG_MAP( CIASPropertyPageNoHelp<CPolicyWizard_Start> )
   END_MSG_MAP()


};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    CPolicyWizard_Finish
//
// DESCRIPTION
//
//    Implements the completion page.
//
///////////////////////////////////////////////////////////////////////////////
class CPolicyWizard_Finish : public CIASWizard97Page<CPolicyWizard_Finish, 0, 0>
{
public:
   CPolicyWizard_Finish(CRapWizardData* WizData
         ,  LONG_PTR hNotificationHandle
         , TCHAR* pTitle = NULL
         , BOOL bOwnsNotificationHandle = FALSE
         ) : m_spWizData(WizData),
            CIASWizard97Page<CPolicyWizard_Finish, 0, 0>(hNotificationHandle,pTitle, bOwnsNotificationHandle)
         {
            AfxInitRichEdit();
            _ASSERTE(WizData);
         };

   enum { IDD = IDD_NEWRAPWIZ_COMPLETION };


   BEGIN_MSG_MAP(CPolicyWizard_Finish)
      MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

// we have problem with chaining the wizard class, so we chain it's base class instead
//    CHAIN_MSG_MAP( CIASWizard97Page<CPolicyWizard_Finish, 0, 0> )
      CHAIN_MSG_MAP( CIASPropertyPageNoHelp<CPolicyWizard_Finish> )
   END_MSG_MAP()


   BOOL OnWizardBack() { return m_spWizData->GetPrevPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);};

   virtual BOOL OnWizardFinish()
   {
      // reset the dirty bit
      SetModified(FALSE);

      return m_spWizData->OnWizardFinish(m_hWnd);
   };


   LRESULT OnInitDialog(
        UINT uMsg
      , WPARAM wParam
      , LPARAM lParam
      , BOOL& bHandled
      )
   {
      SetWizardLargeFont(m_hWnd, IDC_NEWRAPWIZ_STATIC_LARGE);
      return TRUE;
   };

   virtual BOOL OnSetActive()
   {
      ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_FINISH);
      m_spWizData->OnWizardPreFinish(m_hWnd);

      // populate the text on the page ...
      HWND  hWnd = GetDlgItem(IDC_NEWRAPWIZ_FINISH_POLICYNAME);
      if (hWnd)
         ::SetWindowText(hWnd, (LPCTSTR)m_spWizData->m_strPolicyName);

      hWnd = GetDlgItem(IDC_NEWRAPWIZ_FINISH_SETTINGS);
      ::CString   str;
      if(hWnd && m_spWizData->GetSettingsText(str))
         ::SetWindowText(hWnd, (LPCTSTR)str);

      return TRUE;
   };

protected:
   // CRichEditCtrl tasks;
   CComPtr<CRapWizardData>    m_spWizData;
};

////////////////////////////////////////////////////////////////////////////////////////
//
//
//
// CPolicyWizard_Scenarios
//
//
//
////////////////////////////////////////////////////////////////////////////////////////
class CPolicyWizard_Scenarios : public CIASWizard97Page<CPolicyWizard_Scenarios, IDS_NEWRAPWIZ_SCENARIO_TITLE, IDS_NEWRAPWIZ_SCENARIO_SUBTITLE>
{

public :

   // ISSUE: how is base class initialization going to work with subclassing???
   CPolicyWizard_Scenarios(
         CRapWizardData* WizData
         ,  LONG_PTR hNotificationHandle
         , TCHAR* pTitle = NULL
         , BOOL bOwnsNotificationHandle = FALSE
         );

   ~CPolicyWizard_Scenarios();

   // This is the ID of the dialog resource we want for this class.
   // An enum is used here because the correct value of
   // IDD must be initialized before the base class's constructor is called
   enum { IDD = IDD_NEWRAPWIZ_SCENARIO };

   BEGIN_MSG_MAP(CPolicyWizard_Scenarios)
      MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
      COMMAND_ID_HANDLER( IDC_NEWRAPWIZ_SCENARIO_VPN, OnScenario)
      COMMAND_ID_HANDLER( IDC_NEWRAPWIZ_SCENARIO_DIALUP, OnScenario)
      COMMAND_ID_HANDLER( IDC_NEWRAPWIZ_SCENARIO_WIRELESS, OnScenario)
      COMMAND_ID_HANDLER( IDC_NEWRAPWIZ_SCENARIO_SWITCH, OnScenario)
      CHAIN_MSG_MAP(CIASPropertyPageNoHelp<CPolicyWizard_Scenarios>)
   END_MSG_MAP()

   LRESULT OnInitDialog(
        UINT uMsg
      , WPARAM wParam
      , LPARAM lParam
      , BOOL& bHandled
      );


   LRESULT OnScenario(
        UINT uMsg
      , WPARAM wParam
      , HWND hWnd
      , BOOL& bHandled
      );

   BOOL OnWizardNext();
   BOOL OnWizardBack() { return m_spWizData->GetPrevPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);};
   BOOL OnSetActive();

public:

protected:
   CComPtr<CRapWizardData>    m_spWizData;

};

////////////////////////////////////////////////////////////////////////////////////////
//
//
//
// CPolicyWizard_Groups
//
//
//
////////////////////////////////////////////////////////////////////////////////////////
class CPolicyWizard_Groups : public CIASWizard97Page<CPolicyWizard_Groups, IDS_NEWRAPWIZ_GROUP_TITLE, IDS_NEWRAPWIZ_GROUP_SUBTITLE>
{

public :

   // ISSUE: how is base class initialization going to work with subclassing???
   CPolicyWizard_Groups(
         CRapWizardData* WizData
         ,  LONG_PTR hNotificationHandle
         , TCHAR* pTitle = NULL
         , BOOL bOwnsNotificationHandle = FALSE
         );

   ~CPolicyWizard_Groups();

   // This is the ID of the dialog resource we want for this class.
   // An enum is used here because the correct value of
   // IDD must be initialized before the base class's constructor is called
   enum { IDD = IDD_NEWRAPWIZ_GROUP };

   BEGIN_MSG_MAP(CPolicyWizard_Groups)
      MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
      COMMAND_ID_HANDLER( IDC_NEWRAPWIZ_GROUP_USER, OnUserOrGroup)
      COMMAND_ID_HANDLER( IDC_NEWRAPWIZ_GROUP_GROUP, OnUserOrGroup)
      COMMAND_ID_HANDLER( IDC_NEWRAPWIZ_GROUP_ADDGROUP, OnAddGroups)
      COMMAND_ID_HANDLER( IDC_NEWRAPWIZ_GROUP_REMOVEGROUP, OnRemoveGroup)
      NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnListViewItemChanged)
      CHAIN_MSG_MAP(CIASPropertyPageNoHelp<CPolicyWizard_Groups>)
   END_MSG_MAP()

   LRESULT OnInitDialog(
        UINT uMsg
      , WPARAM wParam
      , LPARAM lParam
      , BOOL& bHandled
      );


   LRESULT OnUserOrGroup(
        UINT uMsg
      , WPARAM wParam
      , HWND hWnd
      , BOOL& bHandled
      );

   LRESULT OnRemoveGroup(
        UINT uMsg
      , WPARAM wParam
      , HWND hWnd
      , BOOL& bHandled
      );

   LRESULT OnAddGroups(
        UINT uMsg
      , WPARAM wParam
      , HWND hWnd
      , BOOL& bHandled
      );

   void  SetBtnState();

   LRESULT OnListViewItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

   BOOL OnWizardNext();
   BOOL OnWizardBack() { return m_spWizData->GetPrevPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);};
   BOOL OnSetActive();

public:

protected:
   CComPtr<CRapWizardData>    m_spWizData;

};


////////////////////////////////////////////////////////////////////////////////////////
//
//
//
// CPolicyWizard_Authentication
//
//
//
////////////////////////////////////////////////////////////////////////////////////////
class CPolicyWizard_Authentication : public
   CIASWizard97Page<CPolicyWizard_Authentication, IDS_NEWRAPWIZ_AUTHENTICATION_TITLE, IDS_NEWRAPWIZ_AUTHENTICATION_SUBTITLE>
{

public :

   // ISSUE: how is base class initialization going to work with subclassing???
   CPolicyWizard_Authentication(
         CRapWizardData* WizData
         ,  LONG_PTR hNotificationHandle
         , TCHAR* pTitle = NULL
         , BOOL bOwnsNotificationHandle = FALSE
         );

   ~CPolicyWizard_Authentication();

   // This is the ID of the dialog resource we want for this class.
   // An enum is used here because the correct value of
   // IDD must be initialized before the base class's constructor is called
   enum { IDD = IDD_NEWRAPWIZ_AUTHENTICATION };

   BEGIN_MSG_MAP(CPolicyWizard_Authentication)
      MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
      COMMAND_ID_HANDLER( IDC_NEWRAPWIZ_AUTH_EAP, OnAuthSelect)
      COMMAND_ID_HANDLER( IDC_NEWRAPWIZ_AUTH_MSCHAP2, OnAuthSelect)
      COMMAND_ID_HANDLER( IDC_NEWRAPWIZ_AUTH_MSCHAP, OnAuthSelect)
      COMMAND_ID_HANDLER( IDC_NEWRAPWIZ_AUTH_CONFIGEAP, OnConfigEAP)
      COMMAND_CODE_HANDLER(CBN_SELCHANGE, OnSelectedEAPChanged)
      CHAIN_MSG_MAP(CIASPropertyPageNoHelp<CPolicyWizard_Authentication>)
   END_MSG_MAP()

   virtual LRESULT OnInitDialog(
        UINT uMsg
      , WPARAM wParam
      , LPARAM lParam
      , BOOL& bHandled
      );


   LRESULT OnAuthSelect(
        UINT uMsg
      , WPARAM wParam
      , HWND hWnd
      , BOOL& bHandled
      );

   LRESULT OnConfigEAP(
        UINT uMsg
      , WPARAM wParam
      , HWND hWnd
      , BOOL& bHandled
      );

   LRESULT OnSelectedEAPChanged(
        UINT uMsg
      , WPARAM wParam
      , HWND hwnd
      , BOOL& bHandled
   );

   virtual BOOL OnWizardNext();
   virtual BOOL OnWizardBack() { return m_spWizData->GetPrevPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);};
   virtual BOOL OnSetActive();

protected:
   CComboBox               m_EapBox;
   AuthProviderArray       m_EAPProviders;
   CComPtr<CRapWizardData>    m_spWizData;

   void ResetEAPList();
};


////////////////////////////////////////////////////////////////////////////////////////
//
//
//
// CPolicyWizard_EAP
//
//
//
////////////////////////////////////////////////////////////////////////////////////////
class CPolicyWizard_EAP : public CPolicyWizard_Authentication
{

public :

   // ISSUE: how is base class initialization going to work with subclassing???
   CPolicyWizard_EAP(
         CRapWizardData* WizData
         ,  LONG_PTR hNotificationHandle
         , TCHAR* pTitle = NULL
         , BOOL bOwnsNotificationHandle = FALSE
         ) : CPolicyWizard_Authentication(WizData, hNotificationHandle, pTitle, bOwnsNotificationHandle)
         {
            // otherwise the ATL frame work will take the CPolicyWizard_Authentication's IDD
            ((PROPSHEETPAGE*)(*this))->pszTemplate = MAKEINTRESOURCE(IDD);
            SetTitleIds(IDS_NEWRAPWIZ_EAP_TITLE, IDS_NEWRAPWIZ_EAP_SUBTITLE);
            _ASSERTE(WizData);

         };

   ~CPolicyWizard_EAP(){};

   // This is the ID of the dialog resource we want for this class.
   // An enum is used here because the correct value of
   // IDD must be initialized before the base class's constructor is called
   enum { IDD = IDD_NEWRAPWIZ_EAP };

   BEGIN_MSG_MAP(CPolicyWizard_EAP)
      MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
      CHAIN_MSG_MAP(CPolicyWizard_Authentication)
   END_MSG_MAP()

   LRESULT OnInitDialog(
        UINT uMsg
      , WPARAM wParam
      , LPARAM lParam
      , BOOL& bHandled
      );

   BOOL OnWizardNext()
   {  // reset the dirty bit
      SetModified(FALSE);

      return m_spWizData->GetNextPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);
   };

   BOOL OnWizardBack() { return m_spWizData->GetPrevPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);};
   BOOL OnSetActive();

};


////////////////////////////////////////////////////////////////////////////////////////
//
//
//
// CPolicyWizard_Encryption
//
//
//
////////////////////////////////////////////////////////////////////////////////////////
class CPolicyWizard_Encryption : public
   CIASWizard97Page<CPolicyWizard_Encryption, IDS_NEWRAPWIZ_ENCRYPTION_TITLE, IDS_NEWRAPWIZ_ENCRYPTION_SUBTITLE>
{

public :

   // ISSUE: how is base class initialization going to work with subclassing???
   CPolicyWizard_Encryption(
         CRapWizardData* WizData
         ,  LONG_PTR hNotificationHandle
         , TCHAR* pTitle = NULL
         , BOOL bOwnsNotificationHandle = FALSE
         );

   ~CPolicyWizard_Encryption();

   // This is the ID of the dialog resource we want for this class.
   // An enum is used here because the correct value of
   // IDD must be initialized before the base class's constructor is called
   enum { IDD = IDD_NEWRAPWIZ_ENCRYPTION };

   BEGIN_MSG_MAP(CPolicyWizard_Encryption)
      MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
      COMMAND_ID_HANDLER( IDC_NEWRAPWIZ_ENCRY_NO, OnEncryptionSelect)
      COMMAND_ID_HANDLER( IDC_NEWRAPWIZ_ENCRY_BASIC, OnEncryptionSelect)
      COMMAND_ID_HANDLER( IDC_NEWRAPWIZ_ENCRY_STRONG, OnEncryptionSelect)
      COMMAND_ID_HANDLER( IDC_NEWRAPWIZ_ENCRY_STRONGEST, OnEncryptionSelect)
      CHAIN_MSG_MAP(CIASPropertyPageNoHelp<CPolicyWizard_Encryption>)
   END_MSG_MAP()

   LRESULT OnInitDialog(
        UINT uMsg
      , WPARAM wParam
      , LPARAM lParam
      , BOOL& bHandled
      );


   LRESULT OnEncryptionSelect(
        UINT uMsg
      , WPARAM wParam
      , HWND hWnd
      , BOOL& bHandled
      );

   BOOL OnWizardNext();
   BOOL OnWizardBack() { return m_spWizData->GetPrevPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);};
   BOOL OnSetActive();

public:

protected:
   CComPtr<CRapWizardData>    m_spWizData;

};


////////////////////////////////////////////////////////////////////////////////////////
//
//
//
// CPolicyWizard_Encryption_VPN
//
//
//
////////////////////////////////////////////////////////////////////////////////////////
class CPolicyWizard_Encryption_VPN : public CPolicyWizard_Encryption
{
public:
   // This is the ID of the dialog resource we want for this class.
   // An enum is used here because the correct value of
   // IDD must be initialized before the base class's constructor is called
   enum { IDD = IDD_NEWRAPWIZ_ENCRYPTION_VPN };
   // ISSUE: how is base class initialization going to work with subclassing???
   CPolicyWizard_Encryption_VPN(
         CRapWizardData* WizData
         ,  LONG_PTR hNotificationHandle
         , TCHAR* pTitle = NULL
         , BOOL bOwnsNotificationHandle = FALSE
         ) : CPolicyWizard_Encryption(WizData, hNotificationHandle, pTitle, bOwnsNotificationHandle)
         {
            // otherwise the ATL frame work will take the CPolicyWizard_Authentication's IDD
            ((PROPSHEETPAGE*)(*this))->pszTemplate = MAKEINTRESOURCE(IDD);
         };
};

#endif // RAPWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\rapwz_allow.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name: AddPolicyWizardPage3.cpp

Abstract:
	Implementation file for the CNewRAPWiz_AllowDeny class.
	We implement the class needed to handle the first property page for a Policy node.

Revision History:
	mmaguire 12/15/97 - created
	byao	 1/22/98	Modified for Network Access Policy

--*/
//////////////////////////////////////////////////////////////////////////////


#include "Precompiled.h"
#include "rapwz_allow.h"
#include "NapUtil.h"
#include "PolicyNode.h"
#include "PoliciesNode.h"
#include "ChangeNotification.h"


//+---------------------------------------------------------------------------
//
// Function:  	CNewRAPWiz_AllowDeny
//
// Class:		CNewRAPWiz_AllowDeny
//
// Synopsis:	class constructor
//
// Arguments:   CPolicyNode *pPolicyNode - policy node for this property page
//				CIASAttrList *pAttrList -- attribute list
//              TCHAR* pTitle = NULL -
//
// Returns:     Nothing
//
// History:     Created Header    byao 2/16/98 4:31:52 PM
//
//+---------------------------------------------------------------------------
CNewRAPWiz_AllowDeny::CNewRAPWiz_AllowDeny( 
				CRapWizardData* pWizData,
				LONG_PTR hNotificationHandle,
				TCHAR* pTitle, BOOL bOwnsNotificationHandle
				)
			 : CIASWizard97Page<CNewRAPWiz_AllowDeny, IDS_NEWRAPWIZ_ALLOWDENY_TITLE, IDS_NEWRAPWIZ_ALLOWDENY_SUBTITLE> ( hNotificationHandle, pTitle, bOwnsNotificationHandle ),
			 m_spWizData(pWizData)
{
	TRACE_FUNCTION("CNewRAPWiz_AllowDeny::CNewRAPWiz_AllowDeny");

	m_fDialinAllowed = TRUE;
}

//+---------------------------------------------------------------------------
//
// Function:  	CNewRAPWiz_AllowDeny
//
// Class:		CNewRAPWiz_AllowDeny
//
// Synopsis:	class destructor
//
// Returns:     Nothing
//
// History:     Created Header    byao 2/16/98 4:31:52 PM
//
//+---------------------------------------------------------------------------
CNewRAPWiz_AllowDeny::~CNewRAPWiz_AllowDeny()
{	
	TRACE_FUNCTION("CNewRAPWiz_AllowDeny::~CNewRAPWiz_AllowDeny");

}

//////////////////////////////////////////////////////////////////////////////
/*++

CNewRAPWiz_AllowDeny::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CNewRAPWiz_AllowDeny::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	TRACE_FUNCTION("CNewRAPWiz_AllowDeny::OnInitDialog");

	HRESULT					hr = S_OK;
	BOOL					fRet;
	CComPtr<IUnknown>		spUnknown;
	CComPtr<IEnumVARIANT>	spEnumVariant;
	long					ulCount;
	ULONG					ulCountReceived;


	hr = GetDialinSetting(m_fDialinAllowed);
	if ( FAILED(hr) )
	{
		ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "GetDialinSetting() returns %x", hr);
		return FALSE;
	}

	if ( m_fDialinAllowed )
	{
		CheckDlgButton(IDC_RADIO_DENY_DIALIN, BST_UNCHECKED);
		CheckDlgButton(IDC_RADIO_GRANT_DIALIN, BST_CHECKED);
	}
	else
	{
		CheckDlgButton(IDC_RADIO_GRANT_DIALIN, BST_UNCHECKED);
		CheckDlgButton(IDC_RADIO_DENY_DIALIN, BST_CHECKED);
	}



	// Set the IDC_STATIC_GRANT_OR_DENY_TEXT static text box to be the appropriate text.

///	TCHAR szText[NAP_MAX_STRING];
///	int iLoadStringResult;
///
///	UINT uTextID = m_fDialinAllowed ? IDS_POLICY_GRANT_ACCESS_INFO : IDS_POLICY_DENY_ACCESS_INFO;
///
///	iLoadStringResult = LoadString(  _Module.GetResourceInstance(), uTextID, szText, NAP_MAX_STRING );
///	_ASSERT( iLoadStringResult > 0 );
///
///	SetDlgItemText(IDC_STATIC_GRANT_OR_DENY_TEXT, szText );


	SetModified(FALSE);
	return TRUE;	// ISSUE: what do we need to be returning here?
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNewRAPWiz_AllowDeny::OnDialinCheck

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CNewRAPWiz_AllowDeny::OnDialinCheck(UINT uMsg, WPARAM wParam, HWND hWnd, BOOL& bHandled)
{
	TRACE_FUNCTION("CNewRAPWiz_AllowDeny::OnDialinCheck");

	m_fDialinAllowed = IsDlgButtonChecked(IDC_RADIO_GRANT_DIALIN);
	SetModified(TRUE);


	// Set the IDC_STATIC_GRANT_OR_DENY_TEXT static text box to be the appropriate text.

	TCHAR szText[NAP_MAX_STRING];
	int iLoadStringResult;

	UINT uTextID = m_fDialinAllowed ? IDS_POLICY_GRANT_ACCESS_INFO : IDS_POLICY_DENY_ACCESS_INFO;

	iLoadStringResult = LoadString(  _Module.GetResourceInstance(), uTextID, szText, NAP_MAX_STRING );
	_ASSERT( iLoadStringResult > 0 );

	SetDlgItemText(IDC_STATIC_GRANT_OR_DENY_TEXT, szText );

	return 0;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNewRAPWiz_AllowDeny::OnWizardNext

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CNewRAPWiz_AllowDeny::OnWizardNext()
{
	TRACE_FUNCTION("CNewRAPWiz_AllowDeny::OnWizardNext");

	WCHAR		wzName[256];
	HRESULT		hr = S_OK;
	int			iIndex;

	

	// Set dialin-bit in profile.
	hr = SetDialinSetting(m_fDialinAllowed);
	if ( FAILED(hr) )
	{	
		ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "SetDialinSettings() failed, err = %x", hr);
		ShowErrorDialog( m_hWnd, IDS_ERROR_SDO_ERROR_SETDIALIN, NULL, hr);
		goto failure;
	}

	// reset the dirty bit
	SetModified(FALSE);

	return m_spWizData->GetNextPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);

failure:
	//
	// we can't do anything more than just close the property page
	//
	return FALSE;
}


//////////////////////////////////////////////////////////////////////////////
/*++
CNewRAPWiz_AllowDeny::OnQueryCancel

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CNewRAPWiz_AllowDeny::OnQueryCancel()
{
	TRACE_FUNCTION("CNewRAPWiz_AllowDeny::OnQueryCancel");

	return TRUE;
}




//+---------------------------------------------------------------------------
//
// Function:  CNewRAPWiz_AllowDeny::GetDialinSetting
//
// Synopsis:  Check whether the user is allowed to dial in. This function will
//			  set the dialin bit
//
// Argument:  BOOL& fDialinAllowed;
//
// Returns:   succeed or not
//
// History:   Created Header    byao	2/27/98 3:59:38 PM
//
//+---------------------------------------------------------------------------
HRESULT	CNewRAPWiz_AllowDeny::GetDialinSetting(BOOL& fDialinAllowed)
{
	TRACE_FUNCTION("CNewRAPWiz_AllowDeny::GetDialinSetting");

	long					ulCount;
	ULONG					ulCountReceived;
	HRESULT					hr = S_OK;

	CComBSTR				bstr;
	CComPtr<IUnknown>		spUnknown;
	CComPtr<IEnumVARIANT>	spEnumVariant;
	CComVariant				var;

	// by default, dialin is allowed
	fDialinAllowed = FALSE;

	//
    // get the attribute collection of this profile
    //
	CComPtr<ISdoCollection> spProfAttrCollectionSdo;
	hr = ::GetSdoInterfaceProperty(m_spWizData->m_spProfileSdo,
								  (LONG)PROPERTY_PROFILE_ATTRIBUTES_COLLECTION,
								  IID_ISdoCollection,
								  (void **) &spProfAttrCollectionSdo
								 );
	if ( FAILED(hr) )
	{
		return hr;
	}
	_ASSERTE(spProfAttrCollectionSdo);


	// We check the count of items in our collection and don't bother getting the
	// enumerator if the count is zero.
	// This saves time and also helps us to a void a bug in the the enumerator which
	// causes it to fail if we call next when it is empty.
	hr = spProfAttrCollectionSdo->get_Count( & ulCount );
	DebugTrace(DEBUG_NAPMMC_POLICYPAGE1, "Number of prof attributes: %d", ulCount);
	if ( FAILED(hr) )
	{
		ShowErrorDialog(m_hWnd,
						IDS_ERROR_SDO_ERROR_PROFATTRCOLLECTION,
						NULL,
						hr);
		return hr;
	}


	if ( ulCount > 0)
	{
		// Get the enumerator for the attribute collection.
		hr = spProfAttrCollectionSdo->get__NewEnum( (IUnknown **) & spUnknown );
		if ( FAILED(hr) )
		{
			ShowErrorDialog(m_hWnd,
							IDS_ERROR_SDO_ERROR_PROFATTRCOLLECTION,
							NULL,
							hr);
			return hr;
		}

		hr = spUnknown->QueryInterface( IID_IEnumVARIANT, (void **) &spEnumVariant );
		spUnknown.Release();
		if ( FAILED(hr) )
		{
			ShowErrorDialog(m_hWnd,
							IDS_ERROR_SDO_ERROR_QUERYINTERFACE,
							NULL,
							hr);
			return hr;
		}
		_ASSERTE( spEnumVariant != NULL );

		// Get the first item.
		hr = spEnumVariant->Next( 1, &var, &ulCountReceived );
		while( SUCCEEDED( hr ) && ulCountReceived == 1 )
		{
			// Get an sdo pointer from the variant we received.
			_ASSERTE( V_VT(&var) == VT_DISPATCH );
			_ASSERTE( V_DISPATCH(&var) != NULL );

			CComPtr<ISdo> spSdo;
			hr = V_DISPATCH(&var)->QueryInterface( IID_ISdo, (void **) &spSdo );
			if ( !SUCCEEDED(hr))
			{
				ShowErrorDialog(m_hWnd,
								IDS_ERROR_SDO_ERROR_QUERYINTERFACE,
								NULL
							);
				return hr;
			}

            //
            // get attribute ID
            //
			var.Clear();
			hr = spSdo->GetProperty(PROPERTY_ATTRIBUTE_ID, &var);
			if ( !SUCCEEDED(hr) )
			{
				ShowErrorDialog(m_hWnd, IDS_ERROR_SDO_ERROR_GETATTRINFO, NULL, hr);
				return hr;
			}

			_ASSERTE( V_VT(&var) == VT_I4 );			
			DWORD dwAttrId = V_I4(&var);
			
			if ( dwAttrId == (DWORD)IAS_ATTRIBUTE_ALLOW_DIALIN)
			{
				// found this one in the profile, check for its value
				var.Clear();
				hr = spSdo->GetProperty(PROPERTY_ATTRIBUTE_VALUE, &var);
				if ( !SUCCEEDED(hr) )
				{
					ShowErrorDialog(m_hWnd, IDS_ERROR_SDO_ERROR_GETATTRINFO, NULL, hr);
					return hr;
				}

				_ASSERTE( V_VT(&var)== VT_BOOL);
				fDialinAllowed = ( V_BOOL(&var)==VARIANT_TRUE);
				return S_OK;
			}

			// Clear the variant of whatever it had --
			// this will release any data associated with it.
			var.Clear();

			// Get the next item.
			hr = spEnumVariant->Next( 1, &var, &ulCountReceived );
			if ( !SUCCEEDED(hr))
			{
				ShowErrorDialog(m_hWnd,
								IDS_ERROR_SDO_ERROR_PROFATTRCOLLECTION,
								NULL,
								hr
							);
				return hr;
			}
		} // while
	} // if

	return hr;
}



//+---------------------------------------------------------------------------
//
// Function:  CNewRAPWiz_AllowDeny::SetDialinSetting
//
// Synopsis:  set the dialin bit into the profile
//
// Argument:  BOOL& fDialinAllowed;
//
// Returns:   succeed or not
//
// History:   Created Header    byao	2/27/98 3:59:38 PM
//
//+---------------------------------------------------------------------------
HRESULT	CNewRAPWiz_AllowDeny::SetDialinSetting(BOOL fDialinAllowed)
{
	TRACE_FUNCTION("CNewRAPWiz_AllowDeny::SetDialinSetting");

	long					ulCount;
	ULONG					ulCountReceived;
	HRESULT					hr = S_OK;

	CComBSTR				bstr;
	CComPtr<IUnknown>		spUnknown;
	CComPtr<IEnumVARIANT>	spEnumVariant;
	CComVariant				var;

	//
    // get the attribute collection of this profile
    //
	CComPtr<ISdoCollection> spProfAttrCollectionSdo;
	hr = ::GetSdoInterfaceProperty(m_spWizData->m_spProfileSdo,
								  (LONG)PROPERTY_PROFILE_ATTRIBUTES_COLLECTION,
								  IID_ISdoCollection,
								  (void **) &spProfAttrCollectionSdo
								 );
	if ( FAILED(hr) )
	{
		return hr;
	}
	_ASSERTE(spProfAttrCollectionSdo);



	// We check the count of items in our collection and don't bother getting the
	// enumerator if the count is zero.
	// This saves time and also helps us to a void a bug in the the enumerator which
	// causes it to fail if we call next when it is empty.
	hr = spProfAttrCollectionSdo->get_Count( & ulCount );
	if ( FAILED(hr) )
	{
		ShowErrorDialog(m_hWnd,
						IDS_ERROR_SDO_ERROR_PROFATTRCOLLECTION,
						NULL,
						hr);
		return hr;
	}


	if ( ulCount > 0)
	{
		// Get the enumerator for the attribute collection.
		hr = spProfAttrCollectionSdo->get__NewEnum( (IUnknown **) & spUnknown );
		if ( FAILED(hr) )
		{
			ShowErrorDialog(m_hWnd,
							IDS_ERROR_SDO_ERROR_PROFATTRCOLLECTION,
							NULL,
							hr);
			return hr;
		}

		hr = spUnknown->QueryInterface( IID_IEnumVARIANT, (void **) &spEnumVariant );
		spUnknown.Release();
		if ( FAILED(hr) )
		{
			ShowErrorDialog(m_hWnd,
							IDS_ERROR_SDO_ERROR_QUERYINTERFACE,
							NULL,
							hr
						);
			return hr;
		}
		_ASSERTE( spEnumVariant != NULL );

		// Get the first item.
		hr = spEnumVariant->Next( 1, &var, &ulCountReceived );
		while( SUCCEEDED( hr ) && ulCountReceived == 1 )
		{
			// Get an sdo pointer from the variant we received.
			_ASSERTE( V_VT(&var) == VT_DISPATCH );
			_ASSERTE( V_DISPATCH(&var) != NULL );

			CComPtr<ISdo> spSdo;
			hr = V_DISPATCH(&var)->QueryInterface( IID_ISdo, (void **) &spSdo );
			if ( !SUCCEEDED(hr))
			{
				ShowErrorDialog(m_hWnd,
								IDS_ERROR_SDO_ERROR_QUERYINTERFACE,
								NULL
							);
				return hr;
			}

            //
            // get attribute ID
            //
			var.Clear();
			hr = spSdo->GetProperty(PROPERTY_ATTRIBUTE_ID, &var);
			if ( !SUCCEEDED(hr) )
			{
				ShowErrorDialog(m_hWnd, IDS_ERROR_SDO_ERROR_GETATTRINFO, NULL, hr);
				return hr;
			}

			_ASSERTE( V_VT(&var) == VT_I4 );			
			DWORD dwAttrId = V_I4(&var);
			

			if ( dwAttrId == (DWORD)IAS_ATTRIBUTE_ALLOW_DIALIN )
			{
				// found this one in the profile, check for its value
				var.Clear();
				V_VT(&var) = VT_BOOL;
				V_BOOL(&var) = fDialinAllowed ? VARIANT_TRUE: VARIANT_FALSE ;
				hr = spSdo->PutProperty(PROPERTY_ATTRIBUTE_VALUE, &var);
				if ( !SUCCEEDED(hr) )
				{
					ShowErrorDialog(m_hWnd, IDS_ERROR_SDO_ERROR_SETDIALIN, NULL, hr);
					return hr;
				}
				return S_OK;
			}

			// Clear the variant of whatever it had --
			// this will release any data associated with it.
			var.Clear();

			// Get the next item.
			hr = spEnumVariant->Next( 1, &var, &ulCountReceived );
			if ( !SUCCEEDED(hr))
			{
				ShowErrorDialog(m_hWnd,
								IDS_ERROR_SDO_ERROR_PROFATTRCOLLECTION,
								NULL,
								hr);
				return hr;
			}
		} // while
	} // if

	// if we reach here, it means we either haven't found the attribute,
	// or the profile doesn't have anything in its attribute collection.
	if ( !fDialinAllowed )
	{
		// we don't need to do anything if dialin is allowed, becuase if this
		// attribute is not in the profile, then dialin is by default allowed

		// but we need to add this attribute to the profile if it's DENIED
				// create the SDO for this attribute
		CComPtr<IDispatch>	spDispatch;
		hr =  m_spWizData->m_spDictionarySdo->CreateAttribute( (ATTRIBUTEID)IAS_ATTRIBUTE_ALLOW_DIALIN,
												  (IDispatch**)&spDispatch.p);
		if ( !SUCCEEDED(hr) )
		{
			ShowErrorDialog(m_hWnd,
							IDS_ERROR_SDO_ERROR_SETDIALIN,
							NULL,
							hr
						);
			return hr;
		}

		_ASSERTE( spDispatch.p != NULL );

		// add this node to profile attribute collection
 		hr = spProfAttrCollectionSdo->Add(NULL, (IDispatch**)&spDispatch.p);
		if ( !SUCCEEDED(hr) )
		{
			ShowErrorDialog(m_hWnd,
							IDS_ERROR_SDO_ERROR_SETDIALIN,
							NULL,
							hr
						);
			return hr;
		}

		//
		// get the ISdo pointer
		//
		CComPtr<ISdo> spAttrSdo;
		hr = spDispatch->QueryInterface( IID_ISdo, (void **) &spAttrSdo);
		if ( !SUCCEEDED(hr) )
		{
			ShowErrorDialog(m_hWnd,
							IDS_ERROR_SDO_ERROR_QUERYINTERFACE,
							NULL,
							hr
						);
			return hr;
		}

		_ASSERTE( spAttrSdo != NULL );
				
		// set sdo property for this attribute
		CComVariant var;

		// set value
		V_VT(&var) = VT_BOOL;
		V_BOOL(&var) = VARIANT_FALSE;
				
		hr = spAttrSdo->PutProperty(PROPERTY_ATTRIBUTE_VALUE, &var);
		if ( !SUCCEEDED(hr) )
		{
			ShowErrorDialog(m_hWnd, IDS_ERROR_SDO_ERROR_SETDIALIN, NULL, hr );
			return hr;
		}

		var.Clear();

	} // if (!dialinallowed)

	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNewRAPWiz_AllowDeny::OnSetActive

Return values:

	TRUE if the page can be made active
	FALSE if the page should be be skipped and the next page should be looked at.

Remarks:

	If you want to change which pages are visited based on a user's
	choices in a previous page, return FALSE here as appropriate.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CNewRAPWiz_AllowDeny::OnSetActive()
{
	ATLTRACE(_T("# CNewRAPWiz_AllowDeny::OnSetActive\n"));
	
	// MSDN docs say you need to use PostMessage here rather than SendMessage.
	::PropSheet_SetWizButtons(GetParent(),  PSWIZB_BACK | PSWIZB_NEXT );

	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\rapwz_allow.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

	AddPolicyWizardPage3.h

Abstract:

	Header file for the CNewRAPWiz_AllowDeny class.

	This is our handler class for the first CPolicyNode property page.

	See AddPolicyWizardPage3.cpp for implementation.

Revision History:
	mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NAP_ADD_POLICY_WIZPAGE_3_H_)
#define _NAP_ADD_POLICY_WIZPAGE_3_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "PropertyPage.h"
//
//
// where we can find what this class has or uses:
//
class CPolicyNode;
#include "atltmp.h"

#include "rapwiz.h"

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


class CNewRAPWiz_AllowDeny : public CIASWizard97Page<CNewRAPWiz_AllowDeny, IDS_NEWRAPWIZ_ALLOWDENY_TITLE, IDS_NEWRAPWIZ_ALLOWDENY_SUBTITLE>
{

public :

	// ISSUE: how is base class initialization going to work with subclassing???
	CNewRAPWiz_AllowDeny( 		
				CRapWizardData* pWizData,
			  LONG_PTR hNotificationHandle
			, TCHAR* pTitle = NULL
			, BOOL bOwnsNotificationHandle = FALSE
			);

	~CNewRAPWiz_AllowDeny();

	// This is the ID of the dialog resource we want for this class.
	// An enum is used here because the correct value of
	// IDD must be initialized before the base class's constructor is called
	enum { IDD = IDD_NEWRAPWIZ_ALLOWDENY };

	BEGIN_MSG_MAP(CNewRAPWiz_AllowDeny)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER( IDC_RADIO_GRANT_DIALIN, OnDialinCheck)
		COMMAND_ID_HANDLER( IDC_RADIO_DENY_DIALIN, OnDialinCheck)
		CHAIN_MSG_MAP(CIASPropertyPageNoHelp<CNewRAPWiz_AllowDeny>)
	END_MSG_MAP()

	LRESULT OnInitDialog(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);


	LRESULT OnDialinCheck(
		  UINT uMsg
		, WPARAM wParam
		, HWND hWnd
		, BOOL& bHandled
		);

	BOOL OnWizardNext();
	BOOL OnSetActive();
	BOOL OnQueryCancel();
	BOOL OnWizardBack() { return m_spWizData->GetPrevPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);};


public:
	BOOL m_fDialinAllowed;
	
protected:

	HRESULT	GetDialinSetting(BOOL &fDialinAllowed);
	HRESULT	SetDialinSetting(BOOL fDialinAllowed);

	// wizard shareed data
	CComPtr<CRapWizardData>	m_spWizData;

};

#endif // _NAP_ADD_POLICY_WIZPAGE_3_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\rapwiz.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation

Module Name: rapwiz.cpp

Abstract:
   We implement the class needed to handle the property pages for a RAP Policy wizard.

Revision History:
   History:     Created Header    05/04/00 4:31:52 PM

--*/
//////////////////////////////////////////////////////////////////////////////

#include "Precompiled.h"
#include "iasattrlist.h"
#include "condlist.h"
#include "rapwiz.h"
#include "NapUtil.h"
#include "PolicyNode.h"
#include "PoliciesNode.h"
#include "ChangeNotification.h"
#include "dialinusr.h"
#include "safearray.h"
#include "rrascfg.h"
#include "proxyres.h"
#include "ias.h"
#include "varvec.h"

HRESULT InternalGetEapProviders(
                                   LPCWSTR machineName,
                                   AuthProviderArray *pProvList
                                );


//=======================================================================================
//
//
//          CRapWizardData
//
//
//=======================================================================================
// page sequence information
// page id array ends with 0
DWORD __SCEN_NAME_GRP_AUTH_ENCY__[] = {
         IDD_NEWRAPWIZ_WELCOME,
         IDD_NEWRAPWIZ_NAME,
         IDD_NEWRAPWIZ_SCENARIO,
         IDD_NEWRAPWIZ_GROUP,
         IDD_NEWRAPWIZ_AUTHENTICATION,
         IDD_NEWRAPWIZ_ENCRYPTION,
         IDD_NEWRAPWIZ_COMPLETION,
         0};

DWORD __SCEN_NAME_GRP_AUTH_ENCY_VPN__[] = {
         IDD_NEWRAPWIZ_WELCOME,
         IDD_NEWRAPWIZ_NAME,
         IDD_NEWRAPWIZ_SCENARIO,
         IDD_NEWRAPWIZ_GROUP,
         IDD_NEWRAPWIZ_AUTHENTICATION,
         IDD_NEWRAPWIZ_ENCRYPTION_VPN,
         IDD_NEWRAPWIZ_COMPLETION,
         0};

DWORD __SCEN_NAME_GRP_EAP_ENCY_WIRELESS__[] = {
         IDD_NEWRAPWIZ_WELCOME,
         IDD_NEWRAPWIZ_NAME,
         IDD_NEWRAPWIZ_SCENARIO,
         IDD_NEWRAPWIZ_GROUP,
         IDD_NEWRAPWIZ_EAP,
         IDD_NEWRAPWIZ_COMPLETION,
         0};

DWORD __SCEN_NAME_GRP_EAP__[] = {
         IDD_NEWRAPWIZ_WELCOME,
         IDD_NEWRAPWIZ_NAME,
         IDD_NEWRAPWIZ_SCENARIO,
         IDD_NEWRAPWIZ_GROUP,
         IDD_NEWRAPWIZ_EAP,
         IDD_NEWRAPWIZ_COMPLETION,
         0};

DWORD __SCEN_NAME_COND_ALLW_PROF__[] = {
         IDD_NEWRAPWIZ_WELCOME,
         IDD_NEWRAPWIZ_NAME,
         IDD_NEWRAPWIZ_CONDITION,
         IDD_NEWRAPWIZ_ALLOWDENY,
         IDD_NEWRAPWIZ_EDITPROFILE,
         IDD_NEWRAPWIZ_COMPLETION,
         0};

// top scenarios
CRapWizScenario Scenario_Senarios =
{
   IDC_NEWRAPWIZ_NAME_SCENARIO,  // ID
   FALSE,                        // No encr
   TRUE,                         // E_EAP
   FALSE,                        // C_EAP
   EXCLUDE_AUTH_TYPE,      // Exclude flags (authentication, FramedProtocol)
   VPN_PORT_CONDITION,           // Pre-condition
   TRUE,                         // bSDO
   __SCEN_NAME_GRP_AUTH_ENCY__   // pagelist
};

CRapWizScenario Scenario_Manual =
{
   IDC_NEWRAPWIZ_NAME_MANUAL,
   DONT_CARE,
   DONT_CARE,
   DONT_CARE,
   DONT_CARE,
   NULL,
   FALSE,
   __SCEN_NAME_COND_ALLW_PROF__
};

// sub scenarios
CRapWizScenario Scenario_VPN =
{
   IDC_NEWRAPWIZ_SCENARIO_VPN,
   FALSE,
   TRUE,
   FALSE,
   EXCLUDE_AUTH_TYPE,
   VPN_PORT_CONDITION,
   TRUE,
   __SCEN_NAME_GRP_AUTH_ENCY_VPN__
};

CRapWizScenario Scenario_DialUp =
{
   IDC_NEWRAPWIZ_SCENARIO_DIALUP,
   TRUE,
   TRUE,
   TRUE,
   EXCLUDE_AUTH_TYPE,
   DIALUP_PORT_CONDITION,
   TRUE,
   __SCEN_NAME_GRP_AUTH_ENCY__
};

CRapWizScenario Scenario_Wireless =
{
   IDC_NEWRAPWIZ_SCENARIO_WIRELESS,
   DONT_CARE,
   TRUE,
   FALSE,
   EXCLUDE_AUTH_TYPE | EXCLUDE_DEFAULT_FRAMED,
   WIRELESS_PORT_CONDITION,
   TRUE,
   __SCEN_NAME_GRP_EAP_ENCY_WIRELESS__
};

CRapWizScenario Scenario_Switch =
{
   IDC_NEWRAPWIZ_SCENARIO_SWITCH,
   DONT_CARE,
   TRUE,
   TRUE,
   EXCLUDE_AUTH_TYPE | EXCLUDE_DEFAULT_FRAMED,
   SWITCH_PORT_CONDITION,
   TRUE,
   __SCEN_NAME_GRP_EAP__
};

CRapWizScenario*
CRapWizardData::m_Scenarios[] = {
         &Scenario_Senarios,
         &Scenario_Manual,
         &Scenario_VPN,
         &Scenario_DialUp,
         &Scenario_Wireless,
         &Scenario_Switch,
         NULL};


CRapWizardData::CRapWizardData():
      // scenario
      m_dwScenarioIndex(0),
      // user / group
      m_dwUserOrGroup(IDC_NEWRAPWIZ_GROUP_GROUP),

      // authentication
      m_bMSCHAP(FALSE),
      m_bMSCHAP2(TRUE),
      m_bEAP(FALSE),
      m_dwEAPProvider(0),

      // encryption
      m_bEncrypt_No(FALSE),
      m_bEncrypt_Basic(TRUE),
      m_bEncrypt_Strong(TRUE),
      m_bEncrypt_Strongest(TRUE),
      m_pPolicyNode(NULL),

      // Dialin
      m_bAllowDialin(FALSE)
{
}

void CRapWizardData::SetInfo(LPCTSTR   czMachine, CPolicyNode* pNode, ISdoDictionaryOld* pDic, ISdo* pPolicy, ISdo* pProfile, ISdoCollection* pPolicyCol, ISdoCollection* pProfileCol, ISdoServiceControl* pServiceCtrl, CIASAttrList* pAttrList)
{
   // related to MMC
   m_pPolicyNode = pNode;

   m_NTGroups.m_bstrServerName = czMachine;

   // SDO pointers
   m_spDictionarySdo = pDic;
   m_spPolicySdo = pPolicy;
   m_spProfileSdo = pProfile;
   m_spPoliciesCollectionSdo = pPolicyCol;
   m_spProfilesCollectionSdo = pProfileCol;
   m_spSdoServiceControl = pServiceCtrl;
   m_pAttrList = pAttrList;
}

DWORD CRapWizardData::GetNextPageId(LPCTSTR pszCurrTemplate)
{
   DWORD* pdwPages = m_Scenarios[m_dwScenarioIndex]->m_pdwPages;
   if ( pdwPages == NULL )
      return 0;

   if (pszCurrTemplate == MAKEINTRESOURCE(0))
      return pdwPages[0];

   int i = 0;
   while ( pdwPages[i] != 0 && MAKEINTRESOURCE(pdwPages[i]) != pszCurrTemplate ) i++;

   if ( MAKEINTRESOURCE(pdwPages[i]) == pszCurrTemplate )
   {
      if (pdwPages[i+1] == 0)
         // this allows the page to finish
         return TRUE;
      else
         return pdwPages[i+1];
   }
   else
      return NULL;
}

DWORD CRapWizardData::GetPrevPageId(LPCTSTR pszCurrTemplate)
{
   DWORD* pdwPages = m_Scenarios[m_dwScenarioIndex]->m_pdwPages;
   // when there is no previous page
   if ( pdwPages == NULL  || pszCurrTemplate == MAKEINTRESOURCE(0) || MAKEINTRESOURCE(pdwPages[0]) == pszCurrTemplate)
      return NULL;

   int i = 0;
   while ( pdwPages[i] != 0 && MAKEINTRESOURCE(pdwPages[i]) != pszCurrTemplate ) i++;

   if ( MAKEINTRESOURCE(pdwPages[i]) == pszCurrTemplate )
      return pdwPages[i - 1];
   else
      return NULL;
}

BOOL  CRapWizardData::SetScenario(DWORD dwScenario)
{
   BOOL  bRet = FALSE;

   int i = 0;

   while (m_Scenarios[i] != 0)
   {
      if (m_Scenarios[i]->m_dwScenarioID == dwScenario)
      {
         m_dwScenarioIndex = i;
         if (m_Scenarios[i]->m_bAllowClear == FALSE)
            m_bEncrypt_No = FALSE;
         else if (m_Scenarios[i]->m_bAllowClear == DONT_CARE)
         {
            // this will cause finish not to populate the attribute
            m_bEncrypt_No = TRUE;
            m_bEncrypt_Basic = TRUE;
            m_bEncrypt_Strong = TRUE;
            m_bEncrypt_Strongest = TRUE;
         }
         bRet = TRUE;
         break;
      }
      i++;
   }
   return bRet;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CRapWizardData::GetSettingsText

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CRapWizardData::GetSettingsText(::CString& settingsText)
{
   BOOL  bRet = TRUE;
   ::CString   strOutput;
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   try{
      strOutput.LoadString(IDS_NEWRAPWIZ_COMPLETION_CONDITION);


      // condition text -- get condition text from sdo
      // Policy name.
      CComBSTR policyName;
      policyName = m_strPolicyName;

      //get the condition collection for this SDO
      CComPtr<ISdoCollection> spConditions;

      // ====================
      // conditions
      ::GetSdoInterfaceProperty(
            m_spPolicySdo,
            PROPERTY_POLICY_CONDITIONS_COLLECTION,
            IID_ISdoCollection,
            (void **)&spConditions);

      // List of conditions.
      ConditionList condList;
      condList.finalConstruct(
               NULL,
               m_pAttrList,
               ALLOWEDINCONDITION,
               m_spDictionarySdo,
               spConditions,
               m_pPolicyNode->m_pszServerAddress,
               policyName
               );
      strOutput += condList.getDisplayText();


      // profile text
      // if manual , then only display information -- it was set manually
      ::CString temp1;
      if (!m_Scenarios[m_dwScenarioIndex]->m_bSheetWriteSDO)
      {
         temp1.LoadString(IDS_NEWRAPWIZ_COMPLETION_MANUALSET);
         strOutput += temp1;
      }
      else
      {
         ::CString sep;

         // authentication
         temp1.LoadString(IDS_NEWRAPWIZ_COMPLETION_AUTHEN);
         strOutput += temp1;

         if (m_bEAP)
         {
            ::CString  temp2;

            temp1.LoadString(IDS_AUTHEN_METHOD_EAP);
            temp2.Format(temp1, m_strEAPProvider);
            strOutput += temp2;
            sep.LoadString(IDS_NEWRAPWIZ_ITEM_SEP);
         }

         if (m_bMSCHAP)
         {
            temp1.LoadString(IDS_AUTHEN_METHOD_MSCHAP);

            strOutput += sep;
            strOutput += temp1;
            sep.LoadString(IDS_NEWRAPWIZ_ITEM_SEP);
         }

         if (m_bMSCHAP2)
         {
            temp1.LoadString(IDS_AUTHEN_METHOD_MSCHAP2);

            strOutput += sep;
            strOutput += temp1;
         }

         // encryption
         temp1.LoadString(IDS_NEWRAPWIZ_COMPLETION_ENCRY);
         strOutput += temp1;
         sep = L"";

         if (m_bEncrypt_Basic)
         {
            temp1.LoadString(IDS_ENCYP_METHOD_BASIC);

            strOutput += sep;
            strOutput += temp1;
            sep.LoadString(IDS_NEWRAPWIZ_ITEM_SEP);
         }

         if (m_bEncrypt_Strong)
         {
            temp1.LoadString(IDS_ENCYP_METHOD_STRONG);

            strOutput += sep;
            strOutput += temp1;
            sep.LoadString(IDS_NEWRAPWIZ_ITEM_SEP);
         }

         if (m_bEncrypt_Strongest)
         {
            temp1.LoadString(IDS_ENCYP_METHOD_STRONGEST);

            strOutput += sep;
            strOutput += temp1;
            sep.LoadString(IDS_NEWRAPWIZ_ITEM_SEP);
         }

         if (m_bEncrypt_No)
         {
            temp1.LoadString(IDS_ENCYP_METHOD_NO);

            strOutput += sep;
            strOutput += temp1;
         }
      }
      settingsText = strOutput;
   }
   catch(...)
   {
      bRet = FALSE;
   }

   return bRet;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CRapWizardData::OnWizardPreFinish

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CRapWizardData::OnWizardPreFinish(HWND hWnd)
{
   HRESULT     hr = S_OK;
   //
   // when on manual scenario, the condition and profile data are already written in SDO -- but no persisted yet
   // when on other scenario, the data are kept in RapWizardData, so we need to write the data to sdo
   if (!m_Scenarios[m_dwScenarioIndex]->m_bSheetWriteSDO)   // no write the addtional data into SDO
      return TRUE;

   // clean up profile, and policy object -- in case use used manual
   //get the condition collection for this SDO
   CComPtr<ISdoCollection> spConditions;
   CComPtr<ISdoCollection> spProfileProperties;
   VARIANT  var;
   VariantInit(&var);
   CComBSTR bstrName;
   CComPtr<IDispatch>   spDisp;
   CComPtr<ISdo>     spCond;

   // ====================
   // conditions
   hr = ::GetSdoInterfaceProperty(
            m_spPolicySdo,
            PROPERTY_POLICY_CONDITIONS_COLLECTION,
            IID_ISdoCollection,
            (void **)&spConditions);

   if ( FAILED(hr) )
   {
      ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "Can't get condition collection Sdo, err = %x", hr);
      return FALSE;
   }

   // clean up conditions
   spConditions->RemoveAll();

   // preconditions based on scenario
   if ( m_Scenarios[m_dwScenarioIndex]->m_lpszPreCond)
   {
      bstrName = L"PreCondition0";

      // prepare new condition
      spDisp.Release();
      hr = spConditions->Add(bstrName, &spDisp);
      ASSERT(hr == S_OK);
      spCond.Release();
      hr = spDisp->QueryInterface(IID_ISdo, (void**)&spCond);
      ASSERT(hr == S_OK);

      VariantClear(&var);
      V_VT(&var) = VT_BSTR;
      V_BSTR(&var) = SysAllocString(m_Scenarios[m_dwScenarioIndex]->m_lpszPreCond);

      // put condition with SDO
      hr = spCond->PutProperty(PROPERTY_CONDITION_TEXT, &var);
      VariantClear(&var);

      if( FAILED (hr) )
      {
         ErrorTrace(DEBUG_NAPMMC_POLICYPAGE1, "Couldn't save this condition, err = %x", hr);
         ShowErrorDialog( hWnd
                , IDS_ERROR_SDO_ERROR_PUTPROP_CONDTEXT
                , NULL
                , hr
               );
         return FALSE;
      }
   }

   // windows group condition
   if(m_dwUserOrGroup == IDC_NEWRAPWIZ_GROUP_GROUP)
   {

      bstrName = L"GrpCondition";

      // prepare new condition
      spDisp.Release();
      hr = spConditions->Add(bstrName, &spDisp);
      ASSERT(hr == S_OK);
      spCond.Release();
      hr = spDisp->QueryInterface(IID_ISdo, (void**)&spCond);
      ASSERT(hr == S_OK);

      m_NTGroups.PopulateVariantFromGroups(&var);
      ::CString str;

      // now form the condition text
      str =  NTG_PREFIX;
      str += _T("(\"");
      str += V_BSTR(&var);
      str += _T("\")");
      VariantClear(&var);
      V_VT(&var) = VT_BSTR;
      V_BSTR(&var) = SysAllocString((LPCTSTR)str);

      // put condition with SDO
      hr = spCond->PutProperty(PROPERTY_CONDITION_TEXT, &var);
      VariantClear(&var);

      if( FAILED (hr) )
      {
         ErrorTrace(DEBUG_NAPMMC_POLICYPAGE1, "Couldn't save this condition, err = %x", hr);
         ShowErrorDialog( hWnd
                , IDS_ERROR_SDO_ERROR_PUTPROP_CONDTEXT
                , NULL
                , hr
               );
         return FALSE;
      }
   }

   // ====================
   // profile properties
   hr = ::GetSdoInterfaceProperty(
         m_spProfileSdo,
         PROPERTY_PROFILE_ATTRIBUTES_COLLECTION,
         IID_ISdoCollection,
         (void **)&spProfileProperties);

   if ( FAILED(hr) )
   {
      ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "Can't get property collection Sdo, err = %x", hr);
      return FALSE;
   }

   // clean up profiles -- in case use went to manual mode first, and then came back to other scenarios
   spProfileProperties->RemoveAll();

   ((CPoliciesNode*)m_pPolicyNode->m_pParentNode)->AddDefaultProfileAttrs(
      m_spProfileSdo,
      m_Scenarios[m_dwScenarioIndex]->m_excludeFlag
      );

   // authentication -- attributes
   DWORD MyArray[6];
   DWORD dwNextCel = 0;

   if (m_bEAP && m_dwEAPProvider != 0)
   {
      MyArray[dwNextCel++] = IAS_AUTH_EAP;

      VariantClear(&var);
      CVariantVector<VARIANT> eapArray(&var, 1);

      VARIANT  varEap;
      VariantInit(&varEap);
      V_VT(&varEap) =  VT_I4;
      V_I4(&varEap) = m_dwEAPProvider;

      eapArray[0] = varEap;

      ((CPoliciesNode*)m_pPolicyNode->m_pParentNode)->AddProfAttr(spProfileProperties, IAS_ATTRIBUTE_NP_ALLOWED_EAP_TYPE, &var);

      VariantClear(&var);

      m_eapProfile.ClearExcept(static_cast<BYTE>(m_dwEAPProvider));
      if (!m_eapProfile.IsEmpty())
      {
         HRESULT hr = m_eapProfile.Store(var);
         if (SUCCEEDED(hr))
         {
            static_cast<CPoliciesNode*>(
               m_pPolicyNode->m_pParentNode
               )->AddProfAttr(
                     spProfileProperties,
                     IAS_ATTRIBUTE_EAP_CONFIG,
                     &var
                     );

            VariantClear(&var);
         }
      }
   }

   if (m_bMSCHAP)
   {
      MyArray[dwNextCel++] = IAS_AUTH_MSCHAP;
      MyArray[dwNextCel++] = IAS_AUTH_MSCHAP_CPW;
   }

   if (m_bMSCHAP2)
   {
      MyArray[dwNextCel++] = IAS_AUTH_MSCHAP2;
      MyArray[dwNextCel++] = IAS_AUTH_MSCHAP2_CPW;
   }

   // put new value
   CSafeArray<CComVariant, VT_VARIANT> Values = Dim(dwNextCel);  // 2 values

   Values.Lock();

   for ( int i = 0; i < dwNextCel; i++)
   {
      VariantClear(&var);
      V_VT(&var)  =  VT_I4;
      V_I4(&var)  =  MyArray[i];
      Values[i] = var;
      VariantClear(&var);
   }


   Values.Unlock();


   if(dwNextCel > 0)
   {
      SAFEARRAY         sa = (SAFEARRAY)Values;
      V_VT(&var)     = VT_ARRAY | VT_VARIANT;
      V_ARRAY(&var)  = &sa;

      ((CPoliciesNode*)m_pPolicyNode->m_pParentNode)->AddProfAttr(spProfileProperties, IAS_ATTRIBUTE_NP_AUTHENTICATION_TYPE, &var);

      // not to call VariantClear, since the SAFEARRAY is not allocated using normal way
      VariantInit(&var);
   }

   // encryption
   DWORD EncPolicy = 0;
   DWORD EncType = 0;

   // ignore the default case -- allow anything, -- remove the attributes
   if (!(m_bEncrypt_No && m_bEncrypt_Basic && m_bEncrypt_Strong && m_bEncrypt_Strongest))
   {

      if(m_bEncrypt_No)
         EncPolicy = RAS_EP_ALLOW;
      else
         EncPolicy = RAS_EP_REQUIRE;

      if ( m_bEncrypt_Basic )
         EncType |= RAS_ET_BASIC;

      if ( m_bEncrypt_Strong )
         EncType |= RAS_ET_STRONG;

      if ( m_bEncrypt_Strongest )
         EncType |= RAS_ET_STRONGEST;


      V_VT(&var) = VT_I4;
      V_I4(&var) = EncType;
      ((CPoliciesNode*)m_pPolicyNode->m_pParentNode)->AddProfAttr(spProfileProperties, RAS_ATTRIBUTE_ENCRYPTION_TYPE, &var);
      VariantClear(&var);

      V_VT(&var) = VT_I4;
      V_I4(&var) = EncPolicy;

      ((CPoliciesNode*)m_pPolicyNode->m_pParentNode)->AddProfAttr(spProfileProperties, RAS_ATTRIBUTE_ENCRYPTION_POLICY, &var);
      VariantClear(&var);
   }

   // Dialin
   V_VT(&var) = VT_BOOL;
   V_I4(&var) = (m_bAllowDialin)? VARIANT_TRUE : VARIANT_FALSE;
   ((CPoliciesNode*)m_pPolicyNode->m_pParentNode)->AddProfAttr(spProfileProperties, IAS_ATTRIBUTE_ALLOW_DIALIN, &var);
   VariantClear(&var);

   return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CRapWizardData::OnWizardFinish

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CRapWizardData::OnWizardFinish(HWND hWnd)
{

   HRESULT     hr = S_OK;
   try
   {

      // We should just be able to Apply here because the user has hit the Finish button.
      hr = m_spPolicySdo->Apply();
      if( FAILED( hr ) )
      {
         // can't commit on Policy
         ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "PolicySdo->Apply() failed, err = %x", hr);
         if(hr == DB_E_NOTABLE)  // assume, the RPC connection has problem
            ShowErrorDialog( hWnd, IDS_ERROR__NOTABLE_TO_WRITE_SDO );
         else if(hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
            ShowErrorDialog( hWnd, IDS_ERROR_INVALID_POLICYNAME );
         else
            ShowErrorDialog( hWnd, IDS_ERROR_SDO_ERROR_POLICY_APPLY, NULL, hr );
         throw hr;
      }

      hr = m_spProfileSdo->Apply();

      if( FAILED( hr ) )
      {
         if(hr == DB_E_NOTABLE)  // assume, the RPC connection has problem
            ShowErrorDialog( hWnd, IDS_ERROR__NOTABLE_TO_WRITE_SDO );
         else
         {
            // can't commit on Profiles
            ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "ProfileSdo->Apply() failed, err = %x", hr);
            ShowErrorDialog( hWnd, IDS_ERROR_SDO_ERROR_PROFILE_APPLY, NULL, hr );
         }
         throw hr;
      }


      // Tell the service to reload data.
      HRESULT hrTemp = m_spSdoServiceControl->ResetService();
      if( FAILED( hrTemp ) )
      {
         ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "ISdoServiceControl::ResetService() failed, err = %x", hrTemp);
      }


      // Make sure the node object knows about any changes we made to SDO while in proppage.
      m_pPolicyNode->LoadSdoData();

      // Add the child to the UI's list of nodes and end this dialog.
      DebugTrace(DEBUG_NAPMMC_POLICYPAGE1, "Adding the brand new node...");
      CPoliciesNode* pPoliciesNode = (CPoliciesNode*)(m_pPolicyNode->m_pParentNode);
      pPoliciesNode->AddSingleChildToListAndCauseViewUpdate( m_pPolicyNode );

   }
   catch(...)
   {
      return FALSE;
   }

   // reset the dirty bit
   return TRUE;
}

//=======================================================================================
//
//
//          CPolicyWizard_Scenarios
//
//
//=======================================================================================

//+---------------------------------------------------------------------------
//
// Function:   CPolicyWizard_Scenarios
// History:     Created Header    05/04/00 4:31:52 PM
//
//+---------------------------------------------------------------------------
CPolicyWizard_Scenarios::CPolicyWizard_Scenarios( CRapWizardData* pWizData, LONG_PTR hNotificationHandle,
                     TCHAR* pTitle, BOOL bOwnsNotificationHandle
                   )
          : m_spWizData(pWizData)
          , CIASWizard97Page<CPolicyWizard_Scenarios, IDS_NEWRAPWIZ_SCENARIO_TITLE, IDS_NEWRAPWIZ_SCENARIO_SUBTITLE>( hNotificationHandle, pTitle, bOwnsNotificationHandle )
{
   TRACE_FUNCTION("CPolicyWizard_Scenarios::CPolicyWizard_Scenarios");
   _ASSERTE(pWizData);

}

//+---------------------------------------------------------------------------
//
// Function:   CPolicyWizard_Scenarios
// History:     Created Header    05/04/00 4:31:52 PM
//
//+---------------------------------------------------------------------------
CPolicyWizard_Scenarios::~CPolicyWizard_Scenarios()
{
   TRACE_FUNCTION("CPolicyWizard_Scenarios::~CPolicyWizard_Scenarios");

}

//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Scenarios::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CPolicyWizard_Scenarios::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   TRACE_FUNCTION("CPolicyWizard_Scenarios::OnInitDialog");

   // uncheck all

   // check the default selected one
   CheckDlgButton(IDC_NEWRAPWIZ_SCENARIO_VPN, BST_CHECKED);

   // clean dirty bit
   SetModified(FALSE);
   return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Scenarios::OnDialinCheck

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CPolicyWizard_Scenarios::OnScenario(UINT uMsg, WPARAM wParam, HWND hWnd, BOOL& bHandled)
{
   TRACE_FUNCTION("CPolicyWizard_Scenarios::OnScenario");

   SetModified(TRUE);

   return 0;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Scenarios::OnWizardNext

// History:     Created Header    05/04/00 4:31:52 PM

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CPolicyWizard_Scenarios::OnWizardNext()
{
   TRACE_FUNCTION("CPolicyWizard_Scenarios::OnWizardNext");
   DWORD dwScenaro = 0;
   CRapWizScenario** pS = m_spWizData->GetAllScenarios();

   while(*pS != NULL)
   {
      if (IsDlgButtonChecked((*pS)->m_dwScenarioID))
      {
         dwScenaro = (*pS)->m_dwScenarioID;
         break;
      }
      pS++;
   }

   if (dwScenaro == 0)
      return FALSE;

   // reset the dirty bit
   SetModified(FALSE);
   m_spWizData->SetScenario(dwScenaro);

   return m_spWizData->GetNextPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);
}



//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Scenarios::OnSetActive

Return values:

   TRUE if the page can be made active
   FALSE if the page should be be skipped and the next page should be looked at.

Remarks:

   If you want to change which pages are visited based on a user's
   choices in a previous page, return FALSE here as appropriate.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CPolicyWizard_Scenarios::OnSetActive()
{
   ATLTRACE(_T("# CPolicyWizard_Scenarios::OnSetActive\n"));

   // MSDN docs say you need to use PostMessage here rather than SendMessage.
   ::PropSheet_SetWizButtons(GetParent(), PSWIZB_NEXT | PSWIZB_BACK);

   return TRUE;
}




//=======================================================================================
//
//
//          CPolicyWizard_Groups
//
//
//=======================================================================================

//+---------------------------------------------------------------------------
//
// Function:   CPolicyWizard_Groups
// History:     Created Header    05/04/00 4:31:52 PM
//
//+---------------------------------------------------------------------------
CPolicyWizard_Groups::CPolicyWizard_Groups( CRapWizardData* pWizData, LONG_PTR hNotificationHandle,
                     TCHAR* pTitle, BOOL bOwnsNotificationHandle
                   )
          : m_spWizData(pWizData)
          , CIASWizard97Page<CPolicyWizard_Groups, IDS_NEWRAPWIZ_GROUP_TITLE, IDS_NEWRAPWIZ_GROUP_SUBTITLE>( hNotificationHandle, pTitle, bOwnsNotificationHandle )
{
   TRACE_FUNCTION("CPolicyWizard_Scenarios::CPolicyWizard_Scenarios");
   _ASSERTE(pWizData);

}

//+---------------------------------------------------------------------------
//
// Function:   CPolicyWizard_Scenarios
// History:     Created Header    05/04/00 4:31:52 PM
//
//+---------------------------------------------------------------------------
CPolicyWizard_Groups::~CPolicyWizard_Groups()
{
   TRACE_FUNCTION("CPolicyWizard_Groups::~CPolicyWizard_Groups");

}

//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Groups::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CPolicyWizard_Groups::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   TRACE_FUNCTION("CPolicyWizard_Groups::OnInitDialog");

   // uncheck all
   CheckDlgButton(IDC_NEWRAPWIZ_GROUP_USER, BST_UNCHECKED);
   CheckDlgButton(IDC_NEWRAPWIZ_GROUP_GROUP, BST_UNCHECKED);

   // check the default selected one
   CheckDlgButton(m_spWizData->m_dwUserOrGroup, BST_CHECKED);

   SetBtnState();

   // listview init
   HWND hList = GetDlgItem(IDC_NEWRAPWIZ_GROUP_GROUPS);

   //
   // first, set the list box to 2 columns
   //
   LVCOLUMN lvc;
   int iCol;
   WCHAR  achColumnHeader[256];
   HINSTANCE hInst;

   // initialize the LVCOLUMN structure
   lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
   lvc.fmt = LVCFMT_LEFT;

   lvc.cx = 300;
   lvc.pszText = achColumnHeader;

   // first column header: name
   hInst = _Module.GetModuleInstance();

   ::LoadStringW(hInst, IDS_DISPLAY_GROUPS_FIRSTCOLUMN, achColumnHeader, sizeof(achColumnHeader)/sizeof(achColumnHeader[0]));
   lvc.iSubItem = 0;
   ListView_InsertColumn(hList, 0,  &lvc);

   // Set the listview control so that double-click anywhere in row selects.
   ListView_SetExtendedListViewStyleEx(hList, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);

   //

   // link the list view with help class
   m_spWizData->m_NTGroups.SetListView(GetDlgItem(IDC_NEWRAPWIZ_GROUP_GROUPS), this->m_hWnd);

   m_spWizData->m_NTGroups.PopulateGroupList( 0 );

   // Set some items based on whether the list is empty or not.
   if( m_spWizData->m_NTGroups.size() )
   {

      // Select the first item.
      ListView_SetItemState(hList, 0, LVIS_SELECTED, LVIS_SELECTED);

   }
   else
   {
      // Make sure the Remove button is not enabled initially.
      ::EnableWindow(GetDlgItem(IDC_NEWRAPWIZ_GROUP_REMOVEGROUP), FALSE);
   }


   // clean dirty bit
   SetModified(FALSE);
   return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Scenarios::OnUserOrGroup

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CPolicyWizard_Groups::OnUserOrGroup(UINT uMsg, WPARAM wParam, HWND hWnd, BOOL& bHandled)
{
   BOOL bGroup = IsDlgButtonChecked(IDC_NEWRAPWIZ_GROUP_GROUP);

// ::EnableWindow(GetDlgItem(IDC_NEWRAPWIZ_GROUP_GROUPS), bGroup);
   SetBtnState();
// ::EnableWindow(GetDlgItem(IDC_NEWRAPWIZ_GROUP_ADDGROUP), bGroup);

   SetModified(TRUE);

   return 0;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Scenarios::OnUserOrGroup

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CPolicyWizard_Groups::OnRemoveGroup(UINT uMsg, WPARAM wParam, HWND hWnd, BOOL& bHandled)
{
   m_spWizData->m_NTGroups.RemoveSelectedGroups();
   SetBtnState();
   SetModified(TRUE);


   return 0;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Scenarios::OnUserOrGroup

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CPolicyWizard_Groups::OnAddGroups(UINT uMsg, WPARAM wParam, HWND hWnd, BOOL& bHandled)
{
   m_spWizData->m_NTGroups.AddMoreGroups();
   SetBtnState();
   SetModified(TRUE);

   return 0;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CNewRAPWiz_AllowDeny::OnWizardNext

// History:     Created Header    05/04/00 4:31:52 PM

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CPolicyWizard_Groups::OnWizardNext()
{
   DWORD dwScenaro = 0;

   if (IsDlgButtonChecked(IDC_NEWRAPWIZ_GROUP_GROUP))
   {
      m_spWizData->m_dwUserOrGroup = IDC_NEWRAPWIZ_GROUP_GROUP;
      m_spWizData->m_bAllowDialin = TRUE;
   }
   else if (IsDlgButtonChecked(IDC_NEWRAPWIZ_GROUP_USER))
   {
      m_spWizData->m_dwUserOrGroup = IDC_NEWRAPWIZ_GROUP_USER;
      m_spWizData->m_bAllowDialin = FALSE;
   }
   else
   {
      return FALSE;
   }

   // reset the dirty bit
   SetModified(FALSE);

   return m_spWizData->GetNextPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);
}



//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Groups::OnSetActive

Return values:

   TRUE if the page can be made active
   FALSE if the page should be be skipped and the next page should be looked at.

Remarks:

   If you want to change which pages are visited based on a user's
   choices in a previous page, return FALSE here as appropriate.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CPolicyWizard_Groups::OnSetActive()
{
   ATLTRACE(_T("# CPolicyWizard_Groups::OnSetActive\n"));

   // MSDN docs say you need to use PostMessage here rather than SendMessage.
   SetBtnState();

   return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Groups::OnListViewItemChanged

We enable or disable the Remove button depending on whether an item is selected.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CPolicyWizard_Groups::OnListViewItemChanged(int idCtrl,
                                    LPNMHDR pnmh,
                                    BOOL& bHandled)
{
   SetBtnState();

   bHandled = FALSE;
   return 0;
}

void  CPolicyWizard_Groups::SetBtnState()
{
   BOOL bGroup = IsDlgButtonChecked(IDC_NEWRAPWIZ_GROUP_GROUP);

   ::EnableWindow(GetDlgItem(IDC_NEWRAPWIZ_GROUP_GROUPS), bGroup);
   ::EnableWindow(GetDlgItem(IDC_NEWRAPWIZ_GROUP_GROUPTEXT), bGroup);
   ::EnableWindow(GetDlgItem(IDC_NEWRAPWIZ_GROUP_ADDGROUP), bGroup);

   // remove button
    // Find out what's selected.
   int iSelected = ListView_GetNextItem(GetDlgItem(IDC_NEWRAPWIZ_GROUP_GROUPS), -1, LVNI_SELECTED);


   if (-1 == iSelected || !bGroup)
   {
      if( ::GetFocus() == GetDlgItem(IDC_NEWRAPWIZ_GROUP_REMOVEGROUP))
         ::SetFocus(GetDlgItem(IDC_NEWRAPWIZ_GROUP_ADDGROUP));

      // The user selected nothing, let's disable the remove button.
      ::EnableWindow(GetDlgItem(IDC_NEWRAPWIZ_GROUP_REMOVEGROUP), FALSE);
   }
   else
   {
      // Yes, enable the remove button.
      ::EnableWindow(GetDlgItem(IDC_NEWRAPWIZ_GROUP_REMOVEGROUP), TRUE);
   }

   // next button
   if(bGroup && m_spWizData->m_NTGroups.size() < 1)
      ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK);
   else
      ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT);


}



//=======================================================================================
//
//
//          CPolicyWizard_Authentication
//
//
//=======================================================================================

//+---------------------------------------------------------------------------
//
// Function:   CPolicyWizard_Authentication
// History:     Created Header    05/04/00 4:31:52 PM
//
//+---------------------------------------------------------------------------
CPolicyWizard_Authentication::CPolicyWizard_Authentication( CRapWizardData* pWizData, LONG_PTR hNotificationHandle,
                     TCHAR* pTitle, BOOL bOwnsNotificationHandle
                   )
          : m_spWizData(pWizData)
          , CIASWizard97Page<CPolicyWizard_Authentication, IDS_NEWRAPWIZ_AUTHENTICATION_TITLE, IDS_NEWRAPWIZ_AUTHENTICATION_SUBTITLE>( hNotificationHandle, pTitle, bOwnsNotificationHandle )
{
   TRACE_FUNCTION("CPolicyWizard_Authentication::CPolicyWizard_Authentication");
   _ASSERTE(pWizData);

}

//+---------------------------------------------------------------------------
//
// Function:   CPolicyWizard_Authentication
// History:     Created Header    05/04/00 4:31:52 PM
//
//+---------------------------------------------------------------------------
CPolicyWizard_Authentication::~CPolicyWizard_Authentication()
{
   TRACE_FUNCTION("CPolicyWizard_Authentication::~CPolicyWizard_Authentication");

}

//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Authentication::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CPolicyWizard_Authentication::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   TRACE_FUNCTION("CPolicyWizard_Authentication::OnInitDialog");

   // check the default values ...
   if (m_spWizData->m_bMSCHAP)
      CheckDlgButton(IDC_NEWRAPWIZ_AUTH_MSCHAP, BST_CHECKED);

   if (m_spWizData->m_bMSCHAP2)
      CheckDlgButton(IDC_NEWRAPWIZ_AUTH_MSCHAP2, BST_CHECKED);

   if (m_spWizData->m_bEAP)
      CheckDlgButton(IDC_NEWRAPWIZ_AUTH_EAP, BST_CHECKED);

   ::EnableWindow(GetDlgItem(IDC_NEWRAPWIZ_AUTH_EAP_COMBO), m_spWizData->m_bEAP);
   ::EnableWindow(GetDlgItem(IDC_NEWRAPWIZ_AUTH_CONFIGEAP), m_spWizData->m_bEAP);

   // populate EAP providers
   HRESULT hr = InternalGetEapProviders(
                               m_spWizData->m_pPolicyNode->m_pszServerAddress,
                               &m_EAPProviders);
   m_EapBox.Attach(GetDlgItem (IDC_NEWRAPWIZ_AUTH_EAP_COMBO));

   ResetEAPList();

   // clean dirty bit
   SetModified(FALSE);
   return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Authentication::ResetEAPlist

--*/
//////////////////////////////////////////////////////////////////////////////
void CPolicyWizard_Authentication::ResetEAPList()
{
   m_EapBox.ResetContent();
   for(int i = 0; i < m_EAPProviders.GetSize(); i++)
   {
      // VPN only shows the ones support encryption
      BOOL  bAdd = FALSE;

      if (m_EAPProviders[i].m_fSupportsEncryption && m_spWizData->GetScenario()->m_bAllowEncryptionEAP)
      {
         int iComboIndex = m_EapBox.AddString( m_EAPProviders[i].m_stServerTitle );

         if(iComboIndex != CB_ERR)
            m_EapBox.SetItemData(iComboIndex, i);
      }

      if (!m_EAPProviders[i].m_fSupportsEncryption && m_spWizData->GetScenario()->m_bAllowClearEAP)
      {
         int iComboIndex = m_EapBox.AddString( m_EAPProviders[i].m_stServerTitle );

         if(iComboIndex != CB_ERR)
            m_EapBox.SetItemData(iComboIndex, i);
      }
   };

   if(m_EAPProviders.GetSize() > 0)
      m_EapBox.SetCurSel(0);

   BOOL  b;
   OnSelectedEAPChanged(0,0,0, b);
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Authentication::OnUserOrGroup

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CPolicyWizard_Authentication::OnAuthSelect(UINT uMsg, WPARAM wParam, HWND hWnd, BOOL& bHandled)
{
   m_spWizData->m_bEAP  = IsDlgButtonChecked(IDC_NEWRAPWIZ_AUTH_EAP);
   m_spWizData->m_bMSCHAP2 = IsDlgButtonChecked(IDC_NEWRAPWIZ_AUTH_MSCHAP2);
   m_spWizData->m_bMSCHAP = IsDlgButtonChecked(IDC_NEWRAPWIZ_AUTH_MSCHAP);

   ::EnableWindow(GetDlgItem(IDC_NEWRAPWIZ_AUTH_EAP_COMBO), m_spWizData->m_bEAP);

   if(m_spWizData->m_bEAP)
   {
      BOOL  b;
      OnSelectedEAPChanged(0,0,0, b);
   }
   else
      ::EnableWindow(GetDlgItem(IDC_NEWRAPWIZ_AUTH_CONFIGEAP), m_spWizData->m_bEAP);

   SetModified(TRUE);

    // Find out what's selected.
   int iSelected = m_EapBox.GetCurSel();;

   if ((m_spWizData->m_bEAP && iSelected != -1)|| m_spWizData->m_bMSCHAP2 || m_spWizData->m_bMSCHAP)
      // MSDN docs say you need to use PostMessage here rather than SendMessage.
      ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT);
   else
      ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK);

   return 0;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Authentication::OnConfigEAP

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CPolicyWizard_Authentication::OnConfigEAP(
                                         UINT uMsg,
                                         WPARAM wParam,
                                         HWND hWnd,
                                         BOOL& bHandled
                                         )
{
   // Find out what's selected.
   int iSelected = m_EapBox.GetCurSel();
   if (iSelected == -1)
   {
      return S_OK;
   }

   DWORD index = m_EapBox.GetItemData(iSelected);
   if (m_EAPProviders[index].m_stConfigCLSID.IsEmpty())
   {
      return S_OK;
   }

   HRESULT hr;

   do
   {
      GUID guid;
      hr = CLSIDFromString(
              const_cast<wchar_t*>(
                 static_cast<const wchar_t*>(
                    m_EAPProviders[index].m_stConfigCLSID
                    )
                 ),
              &guid
              );
      if (FAILED(hr))
      {
         break;
      }

      // Create the EAP provider object
      CComPtr<IEAPProviderConfig> spEAPConfig;
      hr = CoCreateInstance(
              guid,
              0,
              CLSCTX_INPROC_SERVER,
              __uuidof(IEAPProviderConfig),
              reinterpret_cast<void**>(&spEAPConfig)
              );
      if (FAILED(hr))
      {
         break;
      }

      // Configure this EAP provider
      // EAP configure displays its own error message, so no hr is kept
      DWORD dwId = _wtol(m_EAPProviders[index].m_stKey);
      ULONG_PTR uConnection = 0;
      hr = spEAPConfig->Initialize(
                           m_spWizData->m_pPolicyNode->m_pszServerAddress,
                           dwId,
                           &uConnection
                           );
      if (SUCCEEDED(hr))
      {
         CComPtr<IEAPProviderConfig2> spEAPConfig2;
         hr = spEAPConfig->QueryInterface(
                              __uuidof(IEAPProviderConfig2),
                              reinterpret_cast<void**>(&spEAPConfig2)
                              );
         if (SUCCEEDED(hr))
         {
            EapProfile::ConstConfigData inData;
            m_spWizData->m_eapProfile.Get(static_cast<BYTE>(dwId), inData);
            EapProfile::ConfigData outData = { 0, 0 };
            hr = spEAPConfig2->ServerInvokeConfigUI2(
                                  dwId,
                                  uConnection,
                                  m_hWnd,
                                  inData.value,
                                  inData.length,
                                  &(outData.value),
                                  &(outData.length)
                                  );
            if (SUCCEEDED(hr))
            {
               hr = m_spWizData->m_eapProfile.Set(
                                                 static_cast<BYTE>(dwId),
                                                 outData
                                                 );
               CoTaskMemFree(outData.value);
            }
         }
         else
         {
            // Bring up the configuration UI for this EAP
            hr = spEAPConfig->ServerInvokeConfigUI(
                                 dwId,
                                 uConnection,
                                 m_hWnd,
                                 0,
                                 0
                                 );
         }

         spEAPConfig->Uninitialize(dwId, uConnection);
      }
   }
   while (false);

   if (FAILED(hr))
   {
      ShowErrorDialog(m_hWnd, IDS_FAILED_CONFIG_EAP, NULL, hr, 0);
   }

   SetModified(TRUE);

   return 0;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Authentication::OnWizardNext

// History:     Created Header    05/04/00 4:31:52 PM

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CPolicyWizard_Authentication::OnWizardNext()
{
   // reset the dirty bit
   SetModified(FALSE);

   return m_spWizData->GetNextPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);
}



//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Groups::OnSetActive

Return values:

   TRUE if the page can be made active
   FALSE if the page should be be skipped and the next page should be looked at.

Remarks:

   If you want to change which pages are visited based on a user's
   choices in a previous page, return FALSE here as appropriate.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CPolicyWizard_Authentication::OnSetActive()
{
   ATLTRACE(_T("# CPolicyWizard_Groups::OnSetActive\n"));

   ResetEAPList();

    // Find out what's selected.
   int iSelected = m_EapBox.GetCurSel();;
   if(   m_spWizData->m_bEAP && iSelected == -1)
      ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK);
   else
      ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT);

   return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Groups::OnListViewItemChanged

We enable or disable the Remove button depending on whether an item is selected.

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CPolicyWizard_Authentication::OnSelectedEAPChanged(
        UINT uMsg
      , WPARAM wParam
      , HWND hwnd
      , BOOL& bHandled
   )
{
    // Find out what's selected.
   int iSelected = m_EapBox.GetCurSel();;

   if (-1 == iSelected )
   {
      if( ::GetFocus() == GetDlgItem(IDC_NEWRAPWIZ_AUTH_CONFIGEAP))
         ::SetFocus(GetDlgItem(IDC_NEWRAPWIZ_AUTH_EAP_COMBO));

      // The user selected nothing, let's disable the remove button.
      ::EnableWindow(GetDlgItem(IDC_NEWRAPWIZ_AUTH_CONFIGEAP), FALSE);

      m_spWizData->m_dwEAPProvider = 0;
   }
   else
   {
      // enable configure button if it's configrable
      DWORD index = m_EapBox.GetItemData(iSelected);
      m_spWizData->m_dwEAPProvider = _ttol(m_EAPProviders[index].m_stKey);
      m_spWizData->m_strEAPProvider = m_EAPProviders[index].m_stServerTitle;
      ::EnableWindow(GetDlgItem(IDC_NEWRAPWIZ_AUTH_CONFIGEAP), (!m_EAPProviders[index].m_stConfigCLSID.IsEmpty()));
   }

   bHandled = FALSE;
   return 0;
}


//=======================================================================================
//
//
//          CPolicyWizard_EAP
//
//
//=======================================================================================


//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_EAP::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CPolicyWizard_EAP::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   TRACE_FUNCTION("CPolicyWizard_EAP::OnInitDialog");

   m_spWizData->m_bEAP  = TRUE;
   m_spWizData->m_bMSCHAP2 = FALSE;
   m_spWizData->m_bMSCHAP = FALSE;
   // populate EAP providers
   HRESULT hr = InternalGetEapProviders(
                              m_spWizData->m_pPolicyNode->m_pszServerAddress,
                              &m_EAPProviders);
   m_EapBox.Attach(GetDlgItem (IDC_NEWRAPWIZ_AUTH_EAP_COMBO));

   ResetEAPList();

   // clean dirty bit
   SetModified(FALSE);
   return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_EAP::OnSetActive

Return values:

   TRUE if the page can be made active
   FALSE if the page should be be skipped and the next page should be looked at.

Remarks:

   If you want to change which pages are visited based on a user's
   choices in a previous page, return FALSE here as appropriate.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CPolicyWizard_EAP::OnSetActive()
{
   ATLTRACE(_T("# CPolicyWizard_Groups::OnSetActive\n"));

   ResetEAPList();

   ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT);


   return TRUE;
}


//=======================================================================================
//
//
//          CPolicyWizard_Encryption
//
//
//=======================================================================================

//+---------------------------------------------------------------------------
//
// Function:   CPolicyWizard_Encryption
// History:     Created Header    05/04/00 4:31:52 PM
//
//+---------------------------------------------------------------------------
CPolicyWizard_Encryption::CPolicyWizard_Encryption( CRapWizardData* pWizData, LONG_PTR hNotificationHandle,
                     TCHAR* pTitle, BOOL bOwnsNotificationHandle
                   )
          : m_spWizData(pWizData)
          , CIASWizard97Page<CPolicyWizard_Encryption, IDS_NEWRAPWIZ_ENCRYPTION_TITLE, IDS_NEWRAPWIZ_ENCRYPTION_SUBTITLE>( hNotificationHandle, pTitle, bOwnsNotificationHandle )
{
   TRACE_FUNCTION("CPolicyWizard_Encryption::CPolicyWizard_Encryption");
   _ASSERTE(pWizData);

}

//+---------------------------------------------------------------------------
//
// Function:   CPolicyWizard_Encryption
// History:     Created Header    05/04/00 4:31:52 PM
//
//+---------------------------------------------------------------------------
CPolicyWizard_Encryption::~CPolicyWizard_Encryption()
{
   TRACE_FUNCTION("CPolicyWizard_Encryption::~CPolicyWizard_Encryption");

}

//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Encryption::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CPolicyWizard_Encryption::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   TRACE_FUNCTION("CPolicyWizard_Encryption::OnInitDialog");

   // don't show No encryption with VPN IDC_NEWRAPWIZ_ENCRY_NO_STATIC
   if (m_spWizData->GetScenario()->m_bAllowClear)
   {
      ::ShowWindow(GetDlgItem(IDC_NEWRAPWIZ_ENCRY_NO), SW_SHOW);
   }
   else
   {
      ::ShowWindow(GetDlgItem(IDC_NEWRAPWIZ_ENCRY_NO), SW_HIDE);
   }

   // check the default values ...
   if (m_spWizData->m_bEncrypt_No)
      CheckDlgButton(IDC_NEWRAPWIZ_ENCRY_NO, BST_CHECKED);

   if (m_spWizData->m_bEncrypt_Basic)
      CheckDlgButton(IDC_NEWRAPWIZ_ENCRY_BASIC, BST_CHECKED);

   if (m_spWizData->m_bEncrypt_Strong)
      CheckDlgButton(IDC_NEWRAPWIZ_ENCRY_STRONG, BST_CHECKED);

   if (m_spWizData->m_bEncrypt_Strongest)
      CheckDlgButton(IDC_NEWRAPWIZ_ENCRY_STRONGEST, BST_CHECKED);

   // clean dirty bit
   SetModified(FALSE);
   return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Encryption::OnEncryptionSelect

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CPolicyWizard_Encryption::OnEncryptionSelect(UINT uMsg, WPARAM wParam, HWND hWnd, BOOL& bHandled)
{
   m_spWizData->m_bEncrypt_No = IsDlgButtonChecked(IDC_NEWRAPWIZ_ENCRY_NO);
   m_spWizData->m_bEncrypt_Basic = IsDlgButtonChecked(IDC_NEWRAPWIZ_ENCRY_BASIC);
   m_spWizData->m_bEncrypt_Strong = IsDlgButtonChecked(IDC_NEWRAPWIZ_ENCRY_STRONG);
   m_spWizData->m_bEncrypt_Strongest = IsDlgButtonChecked(IDC_NEWRAPWIZ_ENCRY_STRONGEST);

   // reset the dirty bit
   SetModified(TRUE);

   if (m_spWizData->m_bEncrypt_No || m_spWizData->m_bEncrypt_Basic || m_spWizData->m_bEncrypt_Strong || m_spWizData->m_bEncrypt_Strongest)
   // MSDN docs say you need to use PostMessage here rather than SendMessage.
      ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT  );
   else
      ::PropSheet_SetWizButtons(GetParent(),  PSWIZB_BACK);


   return 0;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Encryption::OnWizardNext

// History:     Created Header    05/04/00 4:31:52 PM

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CPolicyWizard_Encryption::OnWizardNext()
{
   m_spWizData->m_bEncrypt_No = IsDlgButtonChecked(IDC_NEWRAPWIZ_ENCRY_NO);
   m_spWizData->m_bEncrypt_Basic = IsDlgButtonChecked(IDC_NEWRAPWIZ_ENCRY_BASIC);
   m_spWizData->m_bEncrypt_Strong = IsDlgButtonChecked(IDC_NEWRAPWIZ_ENCRY_STRONG);
   m_spWizData->m_bEncrypt_Strongest = IsDlgButtonChecked(IDC_NEWRAPWIZ_ENCRY_STRONGEST);

   // reset the dirty bit
   SetModified(FALSE);

   return m_spWizData->GetNextPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);
}



//////////////////////////////////////////////////////////////////////////////
/*++

CPolicyWizard_Encryption::OnSetActive

Return values:

   TRUE if the page can be made active
   FALSE if the page should be be skipped and the next page should be looked at.

Remarks:

   If you want to change which pages are visited based on a user's
   choices in a previous page, return FALSE here as appropriate.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CPolicyWizard_Encryption::OnSetActive()
{
   // MSDN docs say you need to use PostMessage here rather than SendMessage.
   if (m_spWizData->m_bEncrypt_No || m_spWizData->m_bEncrypt_Basic || m_spWizData->m_bEncrypt_Strong || m_spWizData->m_bEncrypt_Strongest)
   // MSDN docs say you need to use PostMessage here rather than SendMessage.
      ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT  );
   else
      ::PropSheet_SetWizButtons(GetParent(),  PSWIZB_BACK);


   // don't show No encryption with VPN IDC_NEWRAPWIZ_ENCRY_NO_STATIC
   if (m_spWizData->GetScenario()->m_bAllowClear)
   {
      ::ShowWindow(GetDlgItem(IDC_NEWRAPWIZ_ENCRY_NO), SW_SHOW);
   }
   else
   {
      ::ShowWindow(GetDlgItem(IDC_NEWRAPWIZ_ENCRY_NO), SW_HIDE);
   }


   return TRUE;
}


void SetWizardLargeFont(HWND hWnd, int controlId)
{
   static CFont largeFont;
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   CWnd  wnd;
   wnd.Attach(::GetDlgItem(hWnd, controlId));
   if (wnd.m_hWnd)
   {
      ::CString FontSize;
      ::CString FontName;

      FontSize.LoadString(IDS_LARGE_FONT_SIZE);
      FontName.LoadString(IDS_LARGE_FONT_NAME);
      // If we don't have the large font yet, ...
      if (!(HFONT)largeFont)
      {
         // ... create it.
         largeFont.CreatePointFont(
                       10 * _wtoi((LPCTSTR)FontSize),
                       FontName
                       );
      }

      wnd.SetFont(&largeFont);
      wnd.Detach();
   }
}


HRESULT InternalGetEapProviders(
                                   LPCWSTR machineName,
                                   AuthProviderArray *pProvList
                                )
{
   typedef HRESULT (GET_EAP_PROVIDERS)(
                                     LPCWSTR machineName,
                                     AuthProviderArray *pProvList
                                   );

   GET_EAP_PROVIDERS* pGetEapProviders = NULL;

   HRESULT     hr       = S_OK;
   HMODULE rasUserDll = LoadLibraryW(L"rasuser.dll");
   if (rasUserDll == NULL)
   {
      hr = HRESULT_FROM_WIN32(GetLastError());
      IASTracePrintf("ERROR InternalGetEapProviders LoadLibrary(rasuser.dll)"
                     "failed. hr = %x ", hr);

      ShowErrorDialog(NULL, IDS_ERROR_CANT_FIND_PROFILEDLL, NULL, hr);
      return hr;
   }

   pGetEapProviders = (GET_EAP_PROVIDERS*) GetProcAddress(
                                                   rasUserDll,
                                                   "GetEapProviders");
   if (pGetEapProviders == NULL)
   {
      hr = HRESULT_FROM_WIN32(GetLastError());
      ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "GetProcAddress() failed, err = %x", hr);

      ShowErrorDialog(NULL, IDS_ERROR_CANT_FIND_PROFILEAPI, NULL, hr);
   }
   else
   {
      hr = pGetEapProviders(machineName, pProvList);
   }
   FreeLibrary(rasUserDll);
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\rapwz_cond.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name: AddPolicyWizardPage2.cpp

Abstract:
	Implementation file for the CNewRAPWiz_Condition class.
	We implement the class needed to handle the first property page for a Policy node.

Revision History:
	mmaguire 12/15/97 - created
	byao	 1/22/98	Modified for Network Access Policy

--*/
//////////////////////////////////////////////////////////////////////////////


#include "Precompiled.h"
#include "rapwz_cond.h"
#include "NapUtil.h"
#include "PolicyNode.h"
#include "PoliciesNode.h"
#include "Condition.h"
#include "EnumCondition.h"
#include "MatchCondition.h"
#include "TodCondition.h"
#include "NtGCond.h"
#include "rasprof.h"
#include "ChangeNotification.h"


//+---------------------------------------------------------------------------
//
// Function:  	CNewRAPWiz_Condition
//
// Class:		CNewRAPWiz_Condition
//
// Synopsis:	class constructor
//
// Arguments:   CPolicyNode *pPolicyNode - policy node for this property page
//				CIASAttrList *pAttrList -- attribute list
//              TCHAR* pTitle = NULL -
//
// Returns:     Nothing
//
// History:     Created Header    byao 2/16/98 4:31:52 PM
//
//+---------------------------------------------------------------------------
CNewRAPWiz_Condition::CNewRAPWiz_Condition( 
				CRapWizardData* pWizData,
				LONG_PTR hNotificationHandle,
						    CIASAttrList *pIASAttrList,
							TCHAR* pTitle, BOOL bOwnsNotificationHandle
						 )
			 : CIASWizard97Page<CNewRAPWiz_Condition, IDS_NEWRAPWIZ_CONDITION_TITLE, IDS_NEWRAPWIZ_CONDITION_SUBTITLE> ( hNotificationHandle, pTitle, bOwnsNotificationHandle ),
			  m_spWizData(pWizData)
{
	TRACE_FUNCTION("CNewRAPWiz_Condition::CNewRAPWiz_Condition");

	m_pIASAttrList = pIASAttrList;
}

//+---------------------------------------------------------------------------
//
// Function:  	CNewRAPWiz_Condition
//
// Class:		CNewRAPWiz_Condition
//
// Synopsis:	class destructor
//
// Returns:     Nothing
//
// History:     Created Header    byao 2/16/98 4:31:52 PM
//
//+---------------------------------------------------------------------------
CNewRAPWiz_Condition::~CNewRAPWiz_Condition()
{	
	TRACE_FUNCTION("CNewRAPWiz_Condition::~CNewRAPWiz_Condition");

	CCondition*	pCondition;

	// delete all the conditions in the list
	for (int iIndex=0; iIndex<m_ConditionList.GetSize(); iIndex++)
	{
		pCondition = m_ConditionList[iIndex];
		if ( pCondition )
		{
			delete pCondition;
		}
	}
	m_ConditionList.RemoveAll();

}

//////////////////////////////////////////////////////////////////////////////
/*++

CNewRAPWiz_Condition::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CNewRAPWiz_Condition::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	TRACE_FUNCTION("CNewRAPWiz_Condition::OnInitDialog");

	HRESULT					hr = S_OK;
	BOOL					fRet;
	CComPtr<IUnknown>		spUnknown;
	CComPtr<IEnumVARIANT>	spEnumVariant;
	long					ulCount;
	ULONG					ulCountReceived;

	fRet = GetSdoPointers();
	if (!fRet)
	{
		ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "GetSdoPointers() failed, err = %x", GetLastError());
		return fRet;
	}

    //
    // initialize the condition attribute list
    //
	hr = m_pIASAttrList->Init(m_spWizData->m_spDictionarySdo);
	if ( FAILED(hr) )
	{
		// Inside Init() there're already error reporting
		ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "m_pIASAttrList->Init() failed, err = %x", hr);
		return FALSE;
	}

	if (m_ConditionList.GetSize() == 0)
	{
		//get the condition collection for this SDO
		m_spConditionCollectionSdo = NULL;
		hr = ::GetSdoInterfaceProperty(
						m_spWizData->m_spPolicySdo,
						PROPERTY_POLICY_CONDITIONS_COLLECTION,
						IID_ISdoCollection,
						(void **)&m_spConditionCollectionSdo);
		if ( FAILED(hr) )
		{
			ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "Can't get condition collection Sdo, err = %x", hr);
			return FALSE;
		}

		
		// how many conditions do we have for this policy right now?
		m_spConditionCollectionSdo->get_Count( & ulCount );
		DebugTrace(DEBUG_NAPMMC_POLICYPAGE1, "Number of conditions %d", ulCount);
		
		CComVariant varCond;
		CCondition *pCondition;

		if( ulCount > 0 )
		{
			//
			// Get the enumerator for the conditions collection.
			//
			hr = m_spConditionCollectionSdo->get__NewEnum( (IUnknown **) & spUnknown );
			if ( FAILED(hr) )
			{
				ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "get__NewEnum() failed, err = %x", hr);
				ShowErrorDialog(m_hWnd, IDS_ERROR_SDO_ERROR_ENUMCOND, NULL, hr);
				return FALSE;
			}


			hr = spUnknown->QueryInterface( IID_IEnumVARIANT, (void **) &spEnumVariant );
			if ( FAILED(hr) )
			{
				ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "QueryInterface(IEnumVARIANT) failed, err = %x", hr);
				ShowErrorDialog(m_hWnd, IDS_ERROR_SDO_ERROR_QUERYINTERFACE, NULL, hr);
				return FALSE;
			}


			_ASSERTE( spEnumVariant != NULL );
			spUnknown.Release();

			// Get the first item.
			hr = spEnumVariant->Next( 1, &varCond, &ulCountReceived );

			while( SUCCEEDED( hr ) && ulCountReceived == 1 )
			{
				// Get an sdo pointer from the variant we received.
				_ASSERTE( V_VT(&varCond) == VT_DISPATCH );
				_ASSERTE( V_DISPATCH(&varCond) != NULL );

				CComPtr<ISdo> spConditionSdo;
				hr = varCond.pdispVal->QueryInterface( IID_ISdo, (void **) &spConditionSdo );
				_ASSERTE( SUCCEEDED( hr ) );

				//
				// get condition text
				//
				CComVariant			varCondProp;
				ATL::CString		strCondText, strExternCondText, strCondAttr;
				ATTRIBUTEID AttrId;
				CONDITIONTYPE CondType;

				// get condition text -- with AttributeMatch, TimeOfDay, NTMembership
				// prefix strings
				hr = spConditionSdo->GetProperty(PROPERTY_CONDITION_TEXT,
												 &varCondProp);

				if ( FAILED(hr) )
				{
					ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "Can't get condition text, err = %x", hr);
					ShowErrorDialog(m_hWnd,
									IDS_ERROR_SDO_ERROR_GET_CONDTEXT,
									NULL,
									hr
								   );
					return FALSE;
				}

				_ASSERTE( V_VT(&varCondProp) == VT_BSTR);
				strExternCondText = V_BSTR(&varCondProp);
				DebugTrace(DEBUG_NAPMMC_POLICYPAGE1, "ConditionText: %ws",strExternCondText);

				// we are done with this condition sdo
				spConditionSdo.Release();
				
				varCondProp.Clear();

				// now we need to strip off the unnecessary prefix string in
				// the condition text
				hr = StripCondTextPrefix(
							strExternCondText,
							strCondText,
							strCondAttr,
							&CondType
						);

				if (  FAILED(hr) )
				{	
					ErrorTrace(ERROR_NAPMMC_POLICYPAGE1,"StripCondTextPrefix() failed, err = %x", hr);
					ShowErrorDialog(m_hWnd,
									IDS_ERROR_INVALID_COND_SYNTAX,
									m_spWizData->m_pPolicyNode->m_bstrDisplayName
								);
					
					// go to the next condition
					varCond.Clear();
					hr = spEnumVariant->Next( 1, &varCond, &ulCountReceived );
					continue;
				}
				DebugTrace(DEBUG_NAPMMC_POLICYPAGE1,
						   "ConditionText: %ws, CondAttr: %ws, CondType: %d",
						   strCondText,
						   strCondAttr,
						   (int)CondType
						  );
				
				switch(CondType)
				{
				case IAS_TIMEOFDAY_CONDITION:  AttrId = IAS_ATTRIBUTE_NP_TIME_OF_DAY; break;
				case IAS_NTGROUPS_CONDITION:   AttrId = IAS_ATTRIBUTE_NTGROUPS;  break;
				case IAS_MATCH_CONDITION: {
						   BSTR bstrName = SysAllocString(strCondAttr);
						   if ( bstrName == NULL )
						   {
								ShowErrorDialog(m_hWnd,
												IDS_ERROR_CANT_CREATE_CONDATTR,
												(LPTSTR)(LPCTSTR)strCondAttr,
												hr
											);
								return FALSE;
						   }

						   hr = m_spWizData->m_spDictionarySdo->GetAttributeID(bstrName, &AttrId);
						   if ( FAILED(hr) )
						   {
							    ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "GetAttributeID() failed, err = %x", hr);
								ShowErrorDialog(m_hWnd,
												IDS_ERROR_SDO_ERROR_GETATTROD,
												bstrName,
												hr
											);
								SysFreeString(bstrName);
								return FALSE;
						   }						
						   SysFreeString(bstrName);
						}
						break;
				}

				// GetAt can throw exceptions.
				try
				{

					//
					// find the condition attribute ID in the attribute list
					//
					int nAttrIndex = m_pIASAttrList->Find(AttrId);

					if (nAttrIndex == -1)
					{
						//
						// the attribute is not even found in the attribute list
						//
						ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, " Can't find this condattr in the list");
						ShowErrorDialog(m_hWnd, IDS_ERROR_CANT_FIND_ATTR);
						return FALSE;
					}

					switch( AttrId )
					{
						case IAS_ATTRIBUTE_NP_TIME_OF_DAY:
								// time of day condition
								pCondition = (CCondition*) new CTodCondition(m_pIASAttrList->GetAt(nAttrIndex),
																			 strCondText
																			 );
								break;

						case IAS_ATTRIBUTE_NTGROUPS:
								// nt group condition
								pCondition = (CCondition*) new CNTGroupsCondition(m_pIASAttrList->GetAt(nAttrIndex),
																				  strCondText,
																				  m_hWnd,
																				  m_spWizData->m_pPolicyNode->m_pszServerAddress
																				);
					
						break;

						default:
						{
							CComPtr<IIASAttributeInfo> spAttributeInfo = m_pIASAttrList->GetAt(nAttrIndex);
							_ASSERTE(spAttributeInfo);

							ATTRIBUTESYNTAX as;
							hr = spAttributeInfo->get_AttributeSyntax( &as );
							_ASSERTE( SUCCEEDED(hr) );

							if( as == IAS_SYNTAX_ENUMERATOR )
							{
								// enum-type condition
								CEnumCondition *pEnumCondition = new CEnumCondition(m_pIASAttrList->GetAt(nAttrIndex),
																					strCondText
																				   );
								pCondition = pEnumCondition;

							}
							else
							{
								// match condition
								pCondition = (CCondition*) new CMatchCondition(m_pIASAttrList->GetAt(nAttrIndex),
																			   strCondText
																			  );
							}
						}
						break;
				
					} // switch
					
					
					// Add the newly created node to the list of Policys.
					m_ConditionList.Add(pCondition);


					// get the next condition
					varCond.Clear();
					hr = spEnumVariant->Next( 1, &varCond, &ulCountReceived );

				}
				catch(...)
				{
					ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "Exception thrown while populating condition list");
					continue;
				}

			} // while
		} // if
	}

	hr = PopulateConditions();
	if ( FAILED(hr) )
	{
		ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "PopulateConditions() returns %x", hr);
		return FALSE;
	}


	SetModified(FALSE);
	return TRUE;	// ISSUE: what do we need to be returning here?
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNewRAPWiz_Condition::OnConditionAdd

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CNewRAPWiz_Condition::OnConditionAdd(UINT uMsg, WPARAM wParam, HWND hWnd, BOOL& bHandled)
{
	TRACE_FUNCTION("CNewRAPWiz_Condition::OnConditionAdd");

	HRESULT hr = S_OK;
	CCondition *pCondition;

    // create the dialog box to select a condition attribute
	CSelCondAttrDlg * pSelCondAttrDlg = new CSelCondAttrDlg(m_pIASAttrList);
	if (NULL == pSelCondAttrDlg)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "Can't create the CSelCondAttrDlg, err = %x", hr);		
		ShowErrorDialog(m_hWnd, IDS_ERROR_CANT_CREATE_OBJECT, NULL, hr);
		return hr;
	}

	// Put up the dialog.
	int iResult = pSelCondAttrDlg -> DoModal();

	// The pSelCondAttrDlg->DoModal call returns TRUE if the user selected something.
	if( iResult && pSelCondAttrDlg->m_nSelectedCondAttr != -1)
	{
		//
		// The user selected something and chose OK -- create the condition object
		//
		IIASAttributeInfo* pSelectedAttr = m_pIASAttrList->GetAt(pSelCondAttrDlg->m_nSelectedCondAttr);

		ATTRIBUTEID id;
		pSelectedAttr->get_AttributeID( &id );
		switch( id )			
		{
		
		case IAS_ATTRIBUTE_NP_TIME_OF_DAY:
			// time of day condition

			pCondition = (CCondition*) new CTodCondition(pSelectedAttr);
			break;

		case IAS_ATTRIBUTE_NTGROUPS	:
			// nt group condition

			pCondition = (CCondition*) new CNTGroupsCondition(
														pSelectedAttr,
														m_hWnd,
														m_spWizData->m_pPolicyNode->m_pszServerAddress
													);
			break;

		default:
            //
            // is this attribute an enumerator?
            //
			ATTRIBUTESYNTAX as;
			pSelectedAttr->get_AttributeSyntax( &as );
			if ( as == IAS_SYNTAX_ENUMERATOR )
			{

				// enum-type condition
				CEnumCondition *pEnumCondition = new CEnumCondition(pSelectedAttr);
	
				pCondition = pEnumCondition;
			}
			else
			{
				// match condition
				pCondition = (CCondition*) new CMatchCondition(pSelectedAttr);
							
			}
			break;

		} // switch
			
		if ( pCondition==NULL)
		{
			hr = E_OUTOFMEMORY;
			ShowErrorDialog(m_hWnd, IDS_ERROR_CANT_CREATE_COND, NULL, hr);
			goto failure;
		}
		
        //
        // now edit the condition
        //
		hr = pCondition->Edit();
		if ( FAILED(hr) )
		{
			ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "pCondition->Edit() returns %x", hr);
			return hr;
		}


		// if the condition text is empty, then do nothing
		if ( pCondition->m_strConditionText.GetLength() == 0)
		{
			delete pSelCondAttrDlg;
			delete pCondition;
			return S_OK;
		}
			
		
        //
        // now, update the UI: add the new condition to the listbox
        //
		
		if (m_ConditionList.GetSize())
		{
			// before we do that, add an "AND" to the current last condition
			ATL::CString strDispCondText;

			SendDlgItemMessage(	IDC_LIST_POLICYPAGE1_CONDITIONS,
								LB_DELETESTRING,
								m_ConditionList.GetSize()-1,
							    0L);
			strDispCondText = m_ConditionList[m_ConditionList.GetSize()-1]->GetDisplayText() + _T(" AND");

			SendDlgItemMessage(	IDC_LIST_POLICYPAGE1_CONDITIONS,
								LB_ADDSTRING,
								0,
							    (LPARAM)(LPCTSTR)strDispCondText);
		}

		SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS,
						   LB_ADDSTRING,
						   0,
						   (LPARAM)(LPCTSTR)pCondition->GetDisplayText());
		
		SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS,
						   LB_SETCURSEL,
						   SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS, LB_GETCOUNT, 0,0L)-1,
						   (LPARAM)(LPCTSTR)pCondition->GetDisplayText());
		::EnableWindow(GetDlgItem(IDC_BUTTON_CONDITION_REMOVE), TRUE);
		::EnableWindow(GetDlgItem(IDC_BUTTON_CONDITION_EDIT), TRUE);

		//
		// add this condition to the condition list
		//
		m_ConditionList.Add((CCondition*)pCondition);

		// set the dirty bit
		SetModified(TRUE);
	} // if  // iResult

	delete pSelCondAttrDlg;

	AdjustHoritontalScroll();

	return TRUE;	// ISSUE: what do we need to be returning here?



failure:
	if (pSelCondAttrDlg)
	{
		delete pSelCondAttrDlg;
	}

	if (pCondition)
	{
		delete pCondition;
	}
	return hr;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNewRAPWiz_Condition::OnWizardNext

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CNewRAPWiz_Condition::OnWizardNext()
{
	TRACE_FUNCTION("CNewRAPWiz_Condition::OnWizardNext");

	HRESULT		hr = S_OK;

	CPoliciesNode* pPoliciesNode = (CPoliciesNode*)m_spWizData->m_pPolicyNode->m_pParentNode;

	BOOL fRet = GetSdoPointers();
	if (!fRet)
	{
		ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "GetSdoPointers() failed, err = %x", GetLastError());
		return FALSE;
	}

	//
	// do we have any conditions for this policy?
	// We don't allow policy with no conditions
	//
	if ( ! m_ConditionList.GetSize() )
	{
		ErrorTrace(DEBUG_NAPMMC_POLICYPAGE1, "The policy has no condition");
		ShowErrorDialog(m_hWnd
						, IDS_ERROR_ZERO_CONDITION_POLICY
						, NULL
						);
		return FALSE;
	}


	// Save the conditions to the SDO
	hr = WriteConditionListToSDO( m_ConditionList, m_spConditionCollectionSdo, m_hWnd );
	if( FAILED( hr ) )
	{
		// We output an error message in the function.
		return FALSE;
	}
	

	// reset the dirty bit
	SetModified(FALSE);
	return m_spWizData->GetNextPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);
}


//////////////////////////////////////////////////////////////////////////////
/*++
CNewRAPWiz_Condition::OnQueryCancel

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CNewRAPWiz_Condition::OnQueryCancel()
{
	TRACE_FUNCTION("CNewRAPWiz_Condition::OnQueryCancel");

	return TRUE;
}


//+---------------------------------------------------------------------------
//
// Function:  PopulateConditions
//
// Class:	  CNewRAPWiz_Condition
//
// Synopsis:  populate the conditions for a particular policy
//
// Arguments: None
//
// Returns:   HRESULT - S_OK: succeed
//					    S_FALSE : if failed
//
// History:   Created byao		2/2/98 4:01:26 PM
//
//+---------------------------------------------------------------------------
HRESULT CNewRAPWiz_Condition::PopulateConditions()
{
	TRACE_FUNCTION("CNewRAPWiz_Condition::PopulateConditions");

	SendDlgItemMessage(	IDC_LIST_POLICYPAGE1_CONDITIONS,
					    LB_RESETCONTENT,
						0,
						0L
					);
	ATL::CString strDispCondText;

	for (int iIndex=0; iIndex<m_ConditionList.GetSize(); iIndex++)
	{
		strDispCondText = m_ConditionList[iIndex]->GetDisplayText();

		if ( iIndex != m_ConditionList.GetSize()-1 )
		{
			// it's not the last condition, then we put an 'AND' at the
			// end of the condition text
			strDispCondText += " AND";
		}

		// display it
		SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS,
						   LB_ADDSTRING,
						   0,
						   (LPARAM)(LPCTSTR)strDispCondText);

	}

	if ( m_ConditionList.GetSize() == 0)
	{
		// no condition, then disable "Remove" and "Edit"
		::EnableWindow(GetDlgItem(IDC_BUTTON_CONDITION_REMOVE), FALSE);
		::EnableWindow(GetDlgItem(IDC_BUTTON_CONDITION_EDIT), FALSE);
	}
	else
	{
		SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS, LB_SETCURSEL, 0, 0L);
		::EnableWindow(GetDlgItem(IDC_BUTTON_CONDITION_EDIT), TRUE);
		::EnableWindow(GetDlgItem(IDC_BUTTON_CONDITION_REMOVE), TRUE);
	}

	AdjustHoritontalScroll();

	return S_OK;
}




//+---------------------------------------------------------------------------
//
// Function:  OnConditionList
//
// Class:	  CConditionPage1
//
// Synopsis:  message handler for the condition list box
//
// Arguments: UINT uNotifyCode - notification code
//            UINT uID -  ID of the control
//            HWND hWnd - HANDLE of the window
//            BOOL &bHandled - whether the handler has processed the msg
//
// Returns:   LRESULT - S_OK: succeeded
//					    S_FALSE: otherwise
//
// History:   Created byao	2/2/98 4:51:35 PM
//
//+---------------------------------------------------------------------------
LRESULT CNewRAPWiz_Condition::OnConditionList(UINT uNotifyCode, UINT uID, HWND hWnd, BOOL &bHandled)
{
	TRACE_FUNCTION("CNewRAPWiz_Condition::OnConditionList");

	if (uNotifyCode == LBN_DBLCLK)
	{
		// edit the condition
		OnConditionEdit(uNotifyCode, uID, hWnd, bHandled);
	}
	
	return S_OK;
}


//+---------------------------------------------------------------------------
//
// Function:  OnConditionEdit
//
// Class:	  CConditionPage1
//
// Synopsis:  message handler for the condition list box -- user pressed the Edit button
//			  we need to edit a particular condition
//
// Arguments: UINT uNotifyCode - notification code
//            UINT uID -  ID of the control
//            HWND hWnd - HANDLE of the window
//            BOOL &bHandled - whether the handler has processed the msg
//
// Returns:   LRESULT - S_OK: succeeded
//					    S_FALSE: otherwise
//
// History:   Created byao	2/21/98 4:51:35 PM
//
//+---------------------------------------------------------------------------
LRESULT CNewRAPWiz_Condition::OnConditionEdit(UINT uNotifyCode, UINT uID, HWND hWnd, BOOL &bHandled)
{
	TRACE_FUNCTION("CNewRAPWiz_Condition::OnConditionEdit");

	LRESULT lRes, lCurSel;

	//
	// Has the user selected someone from the condition list?
	//
	lCurSel = SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS,
								 LB_GETCURSEL,
								 0,
								 0L);
	if (lCurSel == LB_ERR)
	{
		// no selection -- do nothing
		bHandled = TRUE;
		return S_OK;
	}
		
	//
	// Edit the condition
	//
	CCondition *pCondition = m_ConditionList[lCurSel];
	HRESULT hr = pCondition->Edit();
	
    //
    // change the displayed condition text
    //
	
	// is this the last condition?
	ATL::CString strDispCondText = m_ConditionList[lCurSel]->GetDisplayText();

	if ( lCurSel != m_ConditionList.GetSize()-1 )
	{
		// put an extra 'AND' at the end
		strDispCondText += _T(" AND");
	}

	// replace it with new
	lRes = SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS,
							  LB_INSERTSTRING,
							  lCurSel,
							  (LPARAM)(LPCTSTR)strDispCondText);

	// delete the old text
	lRes = SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS,
							  LB_DELETESTRING,
							  lCurSel+1,
							  0L);

	// set the dirty bit
	SetModified(TRUE);

	bHandled = TRUE;

	AdjustHoritontalScroll();

	return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  OnConditionRemove
//
// Class:	  CConditionPage1
//
// Synopsis:  message handler for the condition list box -- user pressed "Remove"
//			  we need to remove this condition
//
// Arguments: UINT uNotifyCode - notification code
//            UINT uID -  ID of the control
//            HWND hWnd - HANDLE of the window
//            BOOL &bHandled - whether the handler has processed the msg
//
// Returns:   LRESULT - S_OK: succeeded
//					    S_FALSE: otherwise
//
// History:   Created byao	2/22/98 4:51:35 PM
//
//+---------------------------------------------------------------------------
LRESULT CNewRAPWiz_Condition::OnConditionRemove(UINT uMsg, WPARAM wParam, HWND hWnd, BOOL& bHandled)
{
	TRACE_FUNCTION("CNewRAPWiz_Condition::OnConditionRemove");

	LRESULT lCurSel;
	HRESULT hr;

	//
	// Has the user selected someone from the condition list?
	//
	lCurSel = SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS,
								 LB_GETCURSEL,
								 0,
								 0L);
	if (lCurSel == LB_ERR)
	{
		//
		// no selection -- do nothing
		//
		bHandled = TRUE;
		return S_OK;
	}


	// check whether this is the last one in the list.
	// if it is, we also need to delete the " AND" operator from
	// the next-to-last item
	if ( lCurSel!=0 && lCurSel == m_ConditionList.GetSize()-1 )
	{
		// delete the old one with an " AND"
		hr = SendDlgItemMessage( IDC_LIST_POLICYPAGE1_CONDITIONS,
								 LB_DELETESTRING,
								 lCurSel-1,
							     0L
							   );

		// insert the one without 'AND"
		hr = SendDlgItemMessage( IDC_LIST_POLICYPAGE1_CONDITIONS,
								 LB_INSERTSTRING,
								 lCurSel-1,
							     (LPARAM)(LPCTSTR)m_ConditionList[lCurSel-1]->GetDisplayText());
	}

	// delete the condition
	CCondition *pCondition = m_ConditionList[lCurSel];
	
	m_ConditionList.Remove(pCondition);
	delete pCondition;
		
	// delete the old text
	hr = SendDlgItemMessage(  IDC_LIST_POLICYPAGE1_CONDITIONS,
							  LB_DELETESTRING,
							  lCurSel,
							  0L);

	bHandled = TRUE;

	// set the dirty bit
	SetModified(TRUE);

	if ( m_ConditionList.GetSize() == 0)
	{
		// no condition, then disable "Remove" and "Edit"
		::EnableWindow(GetDlgItem(IDC_BUTTON_CONDITION_REMOVE), FALSE);
		::EnableWindow(GetDlgItem(IDC_BUTTON_CONDITION_EDIT), FALSE);
	}
	else
	{
		// re-select another condition
		if ( lCurSel > 0 )
		{
			lCurSel--;
		}

		SendDlgItemMessage(IDC_LIST_POLICYPAGE1_CONDITIONS, LB_SETCURSEL, lCurSel, 0L);
	}

	//
	// adjust the scroll bar
	//
	AdjustHoritontalScroll();
	
	return hr;
}



//+---------------------------------------------------------------------------
//
// Function:  CNewRAPWiz_Condition::GetSdoPointers
//
// Synopsis:  UnMarshall all passed in sdo pointers. These interface pointers
//			  have to be unmarshalled first, because MMC PropertyPages run in a
//			  separated thread
//			
//			  Also get the condition collection sdo from the policy sdo
//
// Arguments: None
//
// Returns:   TRUE;		succeeded
//			  FALSE:	otherwise
//
// History:   Created Header    byao	2/22/98 1:35:39 AM
//
//+---------------------------------------------------------------------------
BOOL CNewRAPWiz_Condition::GetSdoPointers()
{
	TRACE_FUNCTION("CNewRAPWiz_Condition::GetSdoPointers");

	HRESULT hr;

    // Get the condition collection of this SDO.
	if ( m_spWizData->m_spPolicySdo )
	{
		if ( m_spConditionCollectionSdo )
		{
			m_spConditionCollectionSdo.Release();
			m_spConditionCollectionSdo = NULL;
		}

		hr = ::GetSdoInterfaceProperty(
						m_spWizData->m_spPolicySdo,
						PROPERTY_POLICY_CONDITIONS_COLLECTION,
						IID_ISdoCollection,
						(void **) &m_spConditionCollectionSdo);
		
		if( FAILED( hr) || m_spConditionCollectionSdo == NULL )
		{
			ShowErrorDialog(m_hWnd,
							IDS_ERROR_UNMARSHALL,
							NULL,
							hr
						);

			return FALSE;
		}
	}

	return TRUE;
}



//+---------------------------------------------------------------------------
//
// Function:  CNewRAPWiz_Condition::StripCondTextPrefix
//
// Synopsis:  strip off the prefix such as "AttributeMatch", "TimeOfDay", NtMemberShip"
//			  from the condition text
//
// Arguments:
//				[in]CString			strExternCondText  -- original condition text
//				[out]CString		strCondText		   -- stripped condition text
//				[out]CString		strCondAttr		   -- condition attribute name
//				[out]CONDITIONTYPE* pCondType		   -- what type of condition?
//
// Returns:   HRESULT -
//
// History:   Created Header    byao	2/27/98 3:59:38 PM
//
//+---------------------------------------------------------------------------
HRESULT CNewRAPWiz_Condition::StripCondTextPrefix(
							ATL::CString& strExternCondText,
							ATL::CString& strCondText,
							ATL::CString& strCondAttr,
							CONDITIONTYPE* pCondType
						)
{
	TRACE_FUNCTION("CNewRAPWiz_Condition::StripCondTextPrefix");

	HRESULT hr = S_OK;

	// is it an empty string
	if ( strExternCondText.GetLength() == 0 )
	{
		ErrorTrace(ERROR_NAPMMC_POLICYPAGE1,"Can't parse prefix: empty condition text");
		return E_INVALIDARG;
	}

	// a temporary copy
	ATL::CString strTempStr = (LPCTSTR)strExternCondText;
	WCHAR	*pwzCondText = (WCHAR*)(LPCTSTR)strTempStr;

	strCondAttr = _T("");
	strCondText = _T("");
	
	// condition text will look like : AttributeMatch("attr=<reg>")
	// strip off the "AttributeMatch(" prefix
	WCHAR	*pwzBeginCond = wcschr(pwzCondText, _T('('));
	WCHAR	*pwzEndCond = wcsrchr(pwzCondText, _T(')'));

	if ( ( pwzBeginCond == NULL ) || ( pwzEndCond == NULL ) )
	{
		ErrorTrace(ERROR_NAPMMC_POLICYPAGE1,"Can't parse prefix: no ( or ) found");
		return E_INVALIDARG;
	}

	//
	// now we should decide what kind of condition this is:
	//
	*pwzBeginCond = _T('\0');
	DebugTrace(DEBUG_NAPMMC_POLICYPAGE1, "ConditionType: %ws", pwzCondText);

	if ( _wcsicmp(pwzCondText, TOD_PREFIX) == 0 )
	{
		*pCondType = IAS_TIMEOFDAY_CONDITION;
	}
	else if ( _wcsicmp(pwzCondText, NTG_PREFIX) == 0 )
	{
		*pCondType = IAS_NTGROUPS_CONDITION;
	}
	else if ( _wcsicmp(pwzCondText, MATCH_PREFIX ) == 0  )
	{
		*pCondType = IAS_MATCH_CONDITION;
	}
	else
	{
		return E_INVALIDARG;
	}

	// skip the '(' sign
	pwzBeginCond += 2 ;

	// skip the ')' sign
	*(pwzEndCond-1) = _T('\0');

	// So right now the string between pwzBeginCond and pwzEndCond is the
	// real condition text
	strCondText = pwzBeginCond;

	if ( IAS_MATCH_CONDITION == *pCondType )
	{
		// for match-type condition, we need to get the condition attribute name
		WCHAR *pwzEqualSign = wcschr(pwzBeginCond, _T('='));

		if ( pwzEqualSign == NULL )
		{
			ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "Can't parse : there's no = found");
			return E_INVALIDARG;
		}
	
		*pwzEqualSign = _T('\0');

		strCondAttr = pwzBeginCond;
	}
	else
	{
		strCondAttr = _T("");
	}

	DebugTrace(DEBUG_NAPMMC_POLICYPAGE1, "Condition Attr: %ws", strCondAttr);
	return S_OK;
}



//+---------------------------------------------------------------------------
//
// Function:  AdjustHoritontalScroll
//
// Class:	  CConditionPage1
//
// Synopsis:  message handler for the condition list box
//
// History:   Created byao	2/2/98 4:51:35 PM
//
//+---------------------------------------------------------------------------
void CNewRAPWiz_Condition::AdjustHoritontalScroll()
{
	TRACE_FUNCTION("CNewRAPWiz_Condition::AdjustHorizontalScroll()");

	//
	// According to the maximum length of all list box items,
	// set the horizontal scrolling range
	//
	HDC hDC = ::GetDC(GetDlgItem(IDC_LIST_POLICYPAGE1_CONDITIONS));
	int iItemCount = m_ConditionList.GetSize();
	int iMaxLength = 0;

    for (int iIndex=0; iIndex<iItemCount; iIndex++)
	{
		ATL::CString strCondText;
		strCondText = m_ConditionList[iIndex]->GetDisplayText();

		SIZE  szText;
		
		if ( GetTextExtentPoint32(hDC, (LPCTSTR)strCondText, strCondText.GetLength(), &szText) )
		{
			DebugTrace(DEBUG_NAPMMC_POLICYPAGE1,
					   "Condition: %ws, Length %d, PixelSize %d",
					   (LPCTSTR)strCondText,
					   strCondText.GetLength(),
					   szText.cx
					);
			if (iMaxLength < szText.cx )
			{
				iMaxLength = szText.cx;
			}
		}
		DebugTrace(DEBUG_NAPMMC_POLICYPAGE1, "Maximum item length is %d", iMaxLength);
	}

	SendDlgItemMessage( IDC_LIST_POLICYPAGE1_CONDITIONS,
						LB_SETHORIZONTALEXTENT,
						iMaxLength,
						0L);

}



//////////////////////////////////////////////////////////////////////////////
/*++

CNewRAPWiz_Condition::OnSetActive

Return values:

	TRUE if the page can be made active
	FALSE if the page should be be skipped and the next page should be looked at.

Remarks:

	If you want to change which pages are visited based on a user's
	choices in a previous page, return FALSE here as appropriate.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CNewRAPWiz_Condition::OnSetActive()
{
	ATLTRACE(_T("# CNewRAPWiz_Condition::OnSetActive\n"));
	
	// MSDN docs say you need to use PostMessage here rather than SendMessage.
	::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT );

	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\precompiled.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       precompiled.h
//
//--------------------------------------------------------------------------

// Precompiled.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(_PRECOMPILED_INCLUDED_)
#define _PRECOMPILED_INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#define _ATL_APARTMENT_THREADED

#include <new>
#define _INC_NEW

// MFC standard includes needed for attributeeditor classes in this dll:
#include <afx.h>
#include <afxwin.h>
#include <afxdisp.h>
#include <afxdlgs.h>
#include <afxmt.h>
#include <afxcmn.h>
#include <afxtempl.h>


#ifdef BUILDING_IN_DEVSTUDIO
#else
#include <windows.h>
#include <shellapi.h>
#endif

#include "atlbase.h"
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

extern DWORD   g_dwTraceHandle;

#ifndef ATLASSERT
#define ATLASSERT _ASSERTE
#endif // ATLASSERT


#include "atlcom.h"
#include "atlwin.h"
#include "atlsnap.h"
#include "atlapp.h"

#include <htmlhelp.h>

#include <rtutils.h>
#include <oledberr.h>

#if __RPCNDR_H_VERSION__ < 440             // This may be needed when building
#define __RPCNDR_H_VERSION__ 440           // on NT5 (1671) to prevent MIDL errors
#define MIDL_INTERFACE(x) interface
#endif

#include "iasdebug.h"
#include "sdoias.h"
#include "iascomp.h"
#include "napmmc.h"
#include "Globals.h"
#include "dialog.h"
#include "propertypage.h"
#include "dlgcshlp.h"

#include "MMCUtility.h"
#include "SdoHelperFuncs.h"
#include "iastrace.h"

#endif // if !(defined _precompiled_include_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\rapwz_cond.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

	AddPolicyWizardPage2.h

Abstract:

	Header file for the CNewRAPWiz_Condition class.

	This is our handler class for the first CPolicyNode property page.

	See AddPolicyWizardPage2.cpp for implementation.

Revision History:
	mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NAP_ADD_POLICY_WIZPAGE_2_H_)
#define _NAP_ADD_POLICY_WIZPAGE_2_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "PropertyPage.h"
//
//
// where we can find what this class has or uses:
//
class CPolicyNode;
#include "Condition.h"
#include "IASAttrList.h"
#include "SelCondAttr.h"
#include "atltmp.h"

#include "rapwiz.h"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


class CNewRAPWiz_Condition : public CIASWizard97Page<CNewRAPWiz_Condition, IDS_NEWRAPWIZ_CONDITION_TITLE, IDS_NEWRAPWIZ_CONDITION_SUBTITLE>
{

public :

	// ISSUE: how is base class initialization going to work with subclassing???
	CNewRAPWiz_Condition( 		
					CRapWizardData* pWizData,
			  LONG_PTR hNotificationHandle
			, CIASAttrList *pIASAttrList
			, TCHAR* pTitle = NULL
			, BOOL bOwnsNotificationHandle = FALSE
			);

	~CNewRAPWiz_Condition();

	// This is the ID of the dialog resource we want for this class.
	// An enum is used here because the correct value of
	// IDD must be initialized before the base class's constructor is called
	enum { IDD = IDD_NEWRAPWIZ_CONDITION };

	BEGIN_MSG_MAP(CNewRAPWiz_Condition)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER(IDC_BUTTON_CONDITION_ADD, OnConditionAdd)
		COMMAND_ID_HANDLER(IDC_BUTTON_CONDITION_REMOVE, OnConditionRemove)
		COMMAND_ID_HANDLER(IDC_LIST_CONDITIONS, OnConditionList)
		COMMAND_ID_HANDLER(IDC_BUTTON_CONDITION_EDIT, OnConditionEdit)
		CHAIN_MSG_MAP(CIASPropertyPageNoHelp<CNewRAPWiz_Condition>)
	END_MSG_MAP()

	LRESULT OnInitDialog(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);

	LRESULT OnConditionAdd(
		  UINT uMsg
		, WPARAM wParam
		, HWND hWnd
		, BOOL& bHandled
		);

	LRESULT OnConditionRemove(
		  UINT uMsg
		, WPARAM wParam
		, HWND hWnd
		, BOOL& bHandled
		);

	LRESULT OnConditionList(
		  UINT uNotifyCode,
		  UINT uID,
		  HWND hWnd,
		  BOOL &bHandled
		 );

	LRESULT OnConditionEdit(
		  UINT uNotifyCode,
		  UINT uID,
		  HWND hWnd,
		  BOOL &bHandled
		 );

	void AdjustHoritontalScroll();

	BOOL OnWizardNext();
	BOOL OnSetActive();
	BOOL OnQueryCancel();
	BOOL OnWizardBack() { return m_spWizData->GetPrevPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);};


public:

protected:

	HRESULT PopulateConditions();

	HRESULT	StripCondTextPrefix(
						ATL::CString& strExternCondText,
						ATL::CString& strCondText,
						ATL::CString& strCondAttr,
						CONDITIONTYPE*	pdwCondType
						);

	CIASAttrList *m_pIASAttrList; // condition attribute list

	BOOL GetSdoPointers();

	// condition collection -- created in the page
	CComPtr<ISdoCollection> m_spConditionCollectionSdo; // condition collection



	//
	// condition list pointer
	//
	CSimpleArray<CCondition*> m_ConditionList;


	// wizard shareed data
	CComPtr<CRapWizardData>	m_spWizData;

};

#endif // _NAP_ADD_POLICY_WIZPAGE_2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\rapwz_name.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name: AddPolicyWizardPage1.cpp

Abstract:
	Implementation file for the CNewRAPWiz_Name class.
	We implement the class needed to handle the first property page for a Policy node.

Revision History:
	mmaguire 12/15/97 - created
	byao	 1/22/98	Modified for Network Access Policy

--*/
//////////////////////////////////////////////////////////////////////////////


#include "Precompiled.h"
#include "rapwz_name.h"
#include "NapUtil.h"
#include "PolicyNode.h"
#include "PoliciesNode.h"
#include "ChangeNotification.h"



//+---------------------------------------------------------------------------
//
// Function:  	CNewRAPWiz_Name
//
// Class:		CNewRAPWiz_Name
//
// Synopsis:	class constructor
//
// Arguments:   CPolicyNode *pPolicyNode - policy node for this property page
//				CIASAttrList *pAttrList -- attribute list
//              TCHAR* pTitle = NULL -
//
// Returns:     Nothing
//
// History:     Created Header    byao 2/16/98 4:31:52 PM
//
//+---------------------------------------------------------------------------
CNewRAPWiz_Name::CNewRAPWiz_Name( 
				CRapWizardData* pWizData,
				LONG_PTR hNotificationHandle, 
				TCHAR* pTitle, BOOL bOwnsNotificationHandle
			 )
			 : CIASWizard97Page<CNewRAPWiz_Name, IDS_NEWRAPWIZ_NAME_TITLE, IDS_NEWRAPWIZ_NAME_SUBTITLE> ( hNotificationHandle, pTitle, bOwnsNotificationHandle ),
			  m_spWizData(pWizData)

{
	TRACE_FUNCTION("CNewRAPWiz_Name::CNewRAPWiz_Name");

	// Add the help button to the page
//	m_psp.dwFlags |= PSP_HASHELP;
	
}

//+---------------------------------------------------------------------------
//
// Function:  	CNewRAPWiz_Name
//
// Class:		CNewRAPWiz_Name
//
// Synopsis:	class destructor
//
// Returns:     Nothing
//
// History:     Created Header    byao 2/16/98 4:31:52 PM
//
//+---------------------------------------------------------------------------
CNewRAPWiz_Name::~CNewRAPWiz_Name()
{	
	TRACE_FUNCTION("CNewRAPWiz_Name::~CNewRAPWiz_Name");

}

//////////////////////////////////////////////////////////////////////////////
/*++

CNewRAPWiz_Name::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CNewRAPWiz_Name::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	TRACE_FUNCTION("CNewRAPWiz_Name::OnInitDialog");

	HRESULT					hr = S_OK;
	BOOL					fRet;
	CComPtr<IUnknown>		spUnknown;
	CComPtr<IEnumVARIANT>	spEnumVariant;
	long					ulCount;
	ULONG					ulCountReceived;

    //
    // set the policy name on the page
    //
	SetDlgItemText(IDC_NEWRAPWIZ_NAME_POLICYNAME, m_spWizData->m_pPolicyNode->m_bstrDisplayName);
	// check the default selected one
	CheckDlgButton(IDC_NEWRAPWIZ_NAME_SCENARIO, BST_CHECKED);


	SetModified(FALSE);
	return TRUE;	// ISSUE: what do we need to be returning here?
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNewRAPWiz_Name::OnWizardNext

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CNewRAPWiz_Name::OnWizardNext()
{
	TRACE_FUNCTION("CNewRAPWiz_Name::OnWizardNext");

	HRESULT		hr = S_OK;
	WCHAR		wzName[IAS_MAX_STRING];

	// get the new policy name
	if ( !GetDlgItemText(IDC_NEWRAPWIZ_NAME_POLICYNAME, wzName, IAS_MAX_STRING) )
	{
		// We couldn't retrieve a BSTR,
		// so we need to initialize this variant to a null BSTR.
		ErrorTrace(DEBUG_NAPMMC_POLICYPAGE1, "Couldn't get policy name from UI");
		ShowErrorDialog(m_hWnd, IDS_ERROR_INVALID_POLICYNAME, wzName);
		return FALSE; // can't apply
	}

	{
		::CString str = (OLECHAR *) wzName;
		str.TrimLeft();
		str.TrimRight();
		if (str.IsEmpty())
		{
			ShowErrorDialog( NULL, IDS_ERROR__POLICYNAME_EMPTY);
			return FALSE; // can't apply
		}
	}


	// invalid name?
	if ( _tcscmp(wzName, m_spWizData->m_pPolicyNode->m_bstrDisplayName ) !=0 &&
		 !ValidPolicyName(wzName)
	   )
	{
		// name is changed, and is invalid
		ErrorTrace(DEBUG_NAPMMC_POLICYPAGE1, "Invalid policy name");
		ShowErrorDialog(m_hWnd, IDS_ERROR_INVALID_POLICYNAME);
		return FALSE;
	}


	CComVariant var;

	V_VT(&var)		= VT_BSTR;
	V_BSTR(&var)	= SysAllocString(wzName);
	
	// Put the policy name -- the DS schema has been changed so that rename works.
	hr = m_spWizData->m_spPolicySdo->PutProperty( PROPERTY_SDO_NAME, &var );
	if( FAILED( hr ) )
	{
		ErrorTrace(DEBUG_NAPMMC_POLICYPAGE1, "Couldn't change policy name, err = %x", hr);
		if(hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) || hr == E_INVALIDARG)
			ShowErrorDialog( m_hWnd, IDS_ERROR_INVALID_POLICYNAME );
		else		
			ShowErrorDialog( m_hWnd, IDS_ERROR_RENAMEPOLICY );
		return FALSE;
	}


	// Change the profile name to be whatever the policy name is -- the DS schema has been changed so that rename works.
	hr = m_spWizData->m_spProfileSdo->PutProperty( PROPERTY_SDO_NAME, &var );
	if( FAILED( hr ) )
	{
		ErrorTrace(DEBUG_NAPMMC_POLICYPAGE1, "Couldn't change profile name, err = %x", hr);
		ShowErrorDialog( m_hWnd, IDS_ERROR_RENAMEPOLICY );
		return FALSE;
	}


	// Put the profile name associated with the policy -- the DS schema has been changed so that rename works.
	hr = m_spWizData->m_spPolicySdo->PutProperty(PROPERTY_POLICY_PROFILE_NAME, &var);
	if( FAILED(hr) )
	{
		ErrorTrace(DEBUG_NAPMMC_POLICYPAGE1, "Couldn't save profile name for this policy, err = %x", hr);
		ShowErrorDialog( m_hWnd
						 , IDS_ERROR_SDO_ERROR_PUTPROP_POLICY_PROFILENAME
						 , NULL
						 , hr
						);
		return FALSE;
	}


	var.Clear();


	// Policy merit value (the evaluation order).
	V_VT(&var)	= VT_I4;
	V_I4(&var)	= m_spWizData->m_pPolicyNode->GetMerit();
	hr = m_spWizData->m_spPolicySdo->PutProperty(PROPERTY_POLICY_MERIT, &var);
	if( FAILED(hr) )
	{
		ErrorTrace(DEBUG_NAPMMC_POLICYPAGE1, "Failed to save Merit Value to the policy, err = %x", hr);
		ShowErrorDialog( m_hWnd
						 , IDS_ERROR_SDO_ERROR_PUTPROP_POLICYMERIT
						 , NULL
						 , hr
						);
		return FALSE;
	}


	DWORD dwScenaro = 0;

	if (IsDlgButtonChecked(IDC_NEWRAPWIZ_NAME_SCENARIO))
		dwScenaro = IDC_NEWRAPWIZ_NAME_SCENARIO;
	else if (IsDlgButtonChecked(IDC_NEWRAPWIZ_NAME_MANUAL))
		dwScenaro = IDC_NEWRAPWIZ_NAME_MANUAL;
	
	if (dwScenaro == 0)
		return FALSE;

	// reset the dirty bit
	m_spWizData->SetScenario(dwScenaro);

	// reset the dirty bit
	SetModified(FALSE);

	// store this name with the m_spWizData
	m_spWizData->m_strPolicyName = wzName;

	return m_spWizData->GetNextPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);
}


//////////////////////////////////////////////////////////////////////////////
/*++
CNewRAPWiz_Name::OnQueryCancel

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CNewRAPWiz_Name::OnQueryCancel()
{
	TRACE_FUNCTION("CNewRAPWiz_Name::OnQueryCancel");

	return TRUE;
}



//+---------------------------------------------------------------------------
//
// Function:  OnPolicyNameEdit
//
// Class:	  CConditionPage1
//
// Synopsis:  message handler for the policy name edit box -- user
//			  has done something that might have changed the name
//			  We need to set the dirty bit
//
// Arguments: UINT uNotifyCode - notification code
//            UINT uID -  ID of the control
//            HWND hWnd - HANDLE of the window
//            BOOL &bHandled - whether the handler has processed the msg
//
// Returns:   LRESULT - S_OK: succeeded
//					    S_FALSE: otherwise
//
// History:   Created byao		2/22/98 4:51:35 PM
//
//+---------------------------------------------------------------------------
LRESULT CNewRAPWiz_Name::OnPolicyNameEdit(UINT uMsg, WPARAM wParam, HWND hWnd, BOOL& bHandled)
{
	TRACE_FUNCTION("CNewRAPWiz_Name::OnPolicyNameEdit");
	WCHAR		wzName[IAS_MAX_STRING];

	// get the new policy name
	if ( !GetDlgItemText(IDC_NEWRAPWIZ_NAME_POLICYNAME, wzName, IAS_MAX_STRING) )
	{
		return 0; // can't apply
	}

	if ( _tcscmp(wzName, m_spWizData->m_pPolicyNode->m_bstrDisplayName ) !=0 )
	{
		// set the dirty bit
		SetModified(TRUE);
	}

	bHandled = TRUE;
	return 0;
}

//+---------------------------------------------------------------------------
//
// Function:  OnPath
//
// Class:	  CNewRAPWiz_Name
//
// Synopsis:  message handler for the policy name edit box -- user
//			  has done something that might have changed the name
//			  We need to set the dirty bit
//
// Arguments: UINT uNotifyCode - notification code
//            UINT uID -  ID of the control
//            HWND hWnd - HANDLE of the window
//            BOOL &bHandled - whether the handler has processed the msg
//
// Returns:   LRESULT - S_OK: succeeded
//					    S_FALSE: otherwise
//
// History:   Created byao		2/22/98 4:51:35 PM
//
//+---------------------------------------------------------------------------
LRESULT CNewRAPWiz_Name::OnPath(UINT uMsg, WPARAM wParam, HWND hWnd, BOOL& bHandled)
{
	// set the dirty bit
	SetModified(TRUE);

	bHandled = TRUE;
	return S_OK;
}



//+---------------------------------------------------------------------------
//
// Function:  CNewRAPWiz_Name::ValidPolicyName
//
// Synopsis:  Check whether this is a valid policy name
//
// Arguments: LPCTSTR pszName - policy name
//
// Returns:   BOOL - TRUE: valid name
//
// History:   Created Header    byao	3/14/98 1:47:05 AM
//
//+---------------------------------------------------------------------------
BOOL CNewRAPWiz_Name::ValidPolicyName(LPCTSTR pszName)
{
	TRACE_FUNCTION("CNewRAPWiz_Name::ValidPolicyName");

	int iIndex;
	int iLen;
	
	// is this an empty string?

	iLen = wcslen(pszName);
	if ( !iLen )
	{
		ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "Empty policy name");
		return FALSE;
	}
		
	// is this a string that only has white spaces?
	for (iIndex=0; iIndex < iLen; iIndex++)
	{
		if (pszName[iIndex] != _T(' ')  &&
			pszName[iIndex] != _T('\t') &&
			pszName[iIndex] != _T('\n')
		   )
		{
			break;
		}
	}
	if ( iIndex == iLen )	
	{
		ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "This policy name has only white spaces");
		return FALSE;
	}

	//
	// does this name already exist?
	//
	if ( ((CPoliciesNode*)(m_spWizData->m_pPolicyNode->m_pParentNode))->FindChildWithName(pszName) )
	{
		ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "This policy name already exists");
		return FALSE;
	}

	return TRUE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CNewRAPWiz_Name::OnSetActive

Return values:

	TRUE if the page can be made active
	FALSE if the page should be be skipped and the next page should be looked at.

Remarks:

	If you want to change which pages are visited based on a user's
	choices in a previous page, return FALSE here as appropriate.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CNewRAPWiz_Name::OnSetActive()
{
	ATLTRACE(_T("# CNewRAPWiz_Name::OnSetActive\n"));
	
	// MSDN docs say you need to use PostMessage here rather than SendMessage.
	::PropSheet_SetWizButtons(GetParent(), PSWIZB_NEXT | PSWIZB_BACK);

	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\rasprof.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       rasprof.h
//
//--------------------------------------------------------------------------

#ifndef  _RAS_IAS_PROFILE_H_
#define  _RAS_IAS_PROFILE_H_

#include "sdoias.h"

#define  RAS_IAS_PROFILEDLG_SHOW_RASTABS  0x00000001
#define  RAS_IAS_PROFILEDLG_SHOW_IASTABS  0x00000002
#define  RAS_IAS_PROFILEDLG_SHOW_WIN2K    0x00000004

#define DllImport    __declspec( dllimport )
#define DllExport    __declspec( dllexport )

DllExport HRESULT OpenRAS_IASProfileDlg(
   ISdo* pProfile,      // profile SDO pointer
   ISdoDictionaryOld*   pDictionary,   // dictionary SDO pointer
   BOOL  bReadOnly,     // if the dlg is for readonly
   DWORD dwTabFlags,    // what to show
   void  *pvData        // additional data
);

#endif //   _RAS_IAS_PROFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\rapwz_profile.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation

Module Name:

   AddPolicyWizardPage4.h

Abstract:

   Header file for the CNewRAPWiz_EditProfile class.

   This is our handler class for the first CPolicyNode property page.

   See AddPolicyWizardPage4.cpp for implementation.

Revision History:
   mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NAP_ADD_POLICY_WIZPAGE_4_H_)
#define _NAP_ADD_POLICY_WIZPAGE_4_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "PropertyPage.h"
//
//
// where we can find what this class has or uses:
//
class CPolicyNode;
#include "Condition.h"
#include "IASAttrList.h"
#include "atltmp.h"

#include "rapwiz.h"

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

class CNewRAPWiz_EditProfile : public CIASWizard97Page<CNewRAPWiz_EditProfile, IDS_NEWRAPWIZ_EDITPROFILE_TITLE, IDS_NEWRAPWIZ_EDITPROFILE_SUBTITLE>

{
public :

   // ISSUE: how is base class initialization going to work with subclassing???
   CNewRAPWiz_EditProfile(
            CRapWizardData* pWizData,
           LONG_PTR hNotificationHandle
         , CIASAttrList *pIASAttrList
         , TCHAR* pTitle
         , BOOL bOwnsNotificationHandle
         , bool isWin2k
         );

   ~CNewRAPWiz_EditProfile();

   // This is the ID of the dialog resource we want for this class.
   // An enum is used here because the correct value of
   // IDD must be initialized before the base class's constructor is called
   enum { IDD = IDD_NEWRAPWIZ_EDITPROFILE };

   BEGIN_MSG_MAP(CNewRAPWiz_EditProfile)
      MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
      COMMAND_ID_HANDLER( IDC_BUTTON_EDITPROFILE, OnEditProfile )
      CHAIN_MSG_MAP(CIASPropertyPageNoHelp<CNewRAPWiz_EditProfile>)
   END_MSG_MAP()

   LRESULT OnInitDialog(
        UINT uMsg
      , WPARAM wParam
      , LPARAM lParam
      , BOOL& bHandled
      );

   LRESULT OnEditProfile(
        UINT uMsg
      , WPARAM wParam
      , HWND hWnd
      , BOOL& bHandled
      );

   BOOL OnWizardNext();
   BOOL OnSetActive();
   BOOL OnQueryCancel();
   BOOL OnWizardBack() { return m_spWizData->GetPrevPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);};

protected:

   CIASAttrList *m_pIASAttrList; // condition attribute list

   // wizard shareed data
   CComPtr<CRapWizardData> m_spWizData;
   bool m_isWin2k;
};

#endif // _NAP_ADD_POLICY_WIZPAGE_4_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by NAPMMC.rc
//
#define IDC_BUTTON_HELP                 3
#define IDS_PROJNAME                    100
#define IDB_NAPSNAPIN_16                101
#define IDB_NAPSNAPIN_32                102
#define IDD_NAPSNAPIN                   104
#define IDM_CLIENT_NODE                 104
#define IDS_NAPSNAPIN_DESC              105
#define IDM_MACHINE_NODE                105
#define IDS_ABOUT__SNAPIN_DESCRIPTION   105
#define IDS_NAPSNAPIN_PROVIDER          106
#define IDM_POLICIES_NODE               106
#define IDM_ROOT_NODE                   107
#define IDR_NAPSNAPIN                   108
#define IDM_LOGGING_NODE                108
#define IDS_CLIENTS_NODE                108
#define IDM_LOGGING_METHODS_NODE        108
#define IDS_CLIENTS_NODE__NAME          108
#define IDS_ROOT_NAME                   109
#define IDM_CLIENTS_NODE                109
#define IDS_ROOT_NODE__NAME             109
#define IDS_POLICIES_NODE               110
#define IDM_POLICY_NODE                 110
#define IDS_LOGGING_METHODS_NODE        111
#define IDM_LOCAL_FILE_LOGGING_NODE     111
#define IDS_LOGGING_METHODS_NODE__NAME  111
#define IDS_CLIENT_PAGE1__TAB_NAME      112
#define IDS_LOCAL_FILE_LOGGING_PAGE1__TAB_NAME 113
#define IDS_LOCAL_FILE_LOGGING_PAGE2__TAB_NAME 114
#define IDS_LOCAL_FILE_LOGGING_NODE__NAME 115
#define IDS_MACHINE_PAGE1__TAB_NAME     116
#define IDS_MACHINE_PAGE2__TAB_NAME     117
#define IDS_RULE_SELATTR_FIRSTCOLUMN    118
#define IDS_RULE_SELATTR_SECONDCOLUMN   119
#define IDS_TOD_DIALOG_TITLE            121
#define IDS_ERROR__GENERIC              122
#define IDS_ERROR__GENERIC_TITLE        123
#define IDS_ERROR_SDO_ERROR             124
#define IDS_ERROR_CANT_CREATE_OBJECT    125
#define IDS_ERROR_OLE_ERROR             126
#define IDS_ERROR_CANT_FIND_ATTR        127
#define IDS_ERROR_INVALID_COND_SYNTAX   128
#define IDS_ERROR_PROFILE_NOEXIST       129
#define IDS_ERROR_CLOSE_PROPERTY_SHEET  130
#define IDS_ERROR_PARSE_CONDITION       131
#define IDS_ERROR_UNMARSHALL            132
#define IDS_ERROR_MARSHALL              133
#define IDS_ERROR_ADDATTRIBUTE          134
#define IDS_ERROR_TIMEOFDAY             135
#define IDS_ERROR_POLICY_EXISTS         136
#define IDS_TASKPAD_TEXT__DEFINE_NETWORK_ACCCESS_POLICY 137
#define IDS_TASKPAD_HELP_TEXT__DEFINE_NETWORK_ACCCESS_POLICY 138
#define IDS_POLICY_COLUMN_TITLE1        139
#define IDS_POLICY_COLUMN_TITLE2        140
#define IDS_ERROR_INVALID_POLICYNAME    141
#define IDS_ERROR_CANT_INIT_ATTR        142
#define IDS_ERROR_CANT_FIND_PROFILEDLL  143
#define IDS_ERROR_CANT_FIND_PROFILEAPI  144
#define IDS_POLICIES_NODE_DISCONNECTED  145
#define IDS_ERROR_CANT_FIND_LOGHOURSDLL 146
#define IDS_ERROR_CANT_FIND_LOGHOURSAPI 147
#define IDS_ERROR_OBJECT_PICKER         148
#define IDS_ERROR__NO_SDO               149
#define IDS_ERROR__CANT_READ_DATA_FROM_SDO 150
#define IDS_LOGGING_METHODS_NODE__LOGGING_METHOD 151
#define IDS_LOGGING_METHODS_NODE__DESCRIPTION 152
#define IDS_ERROR__CANT_WRITE_DATA_TO_SDO 153
#define IDS_LOCAL_FILE_LOGGING_BROWSE_DIALOG__TITLE 154
#define IDS_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_SIZE_REACHES_FORMAT 156
#define IDS_LOCAL_FILE_LOGGING_PAGE2__DAILY_FORMAT 157
#define IDS_LOCAL_FILE_LOGGING_PAGE2__WEEKLY_FORMAT 158
#define IDS_LOCAL_FILE_LOGGING_PAGE2__MONTHLY_FORMAT 159
#define   IDS_FAILED_CONFIG_EAP            160
#define IDS_ERROR__NO_CONNECTION_ATTEMPTED 168
#define IDS_ERROR__CONNECTION_IN_PROGRESS 169
#define IDS_ERROR__CONNECTION_ATTEMPT_FAILED 170
#define IDS_ERROR__CONNECTION_INTERRUPTED 171
#define IDI_NAP_SNAPIN_IMAGE            201
#define IDC_CHECK1                      202
#define IDR_CLIENT2_TOOLBAR             202
#define IDR_CLIENT1_TOOLBAR             203
#define IDC_CHECK5                      203
#define IDC_CHECK_IGNORE_DIALIN         203
#define IDC_BUTTON1                     204
#define IDR_CLIENTS_TOOLBAR             204
#define IDI_RESULT_NODE_LOGGING_METHOD  204
#define IDC_EDIT_CLIENT_PAGE1_NAME      205
#define IDC_BUTTON3                     205
#define IDC_BUTTON2                     205
#define IDI_PROPSHEET_PROFILE           205
#define IDC_EDIT_CLIENT_PAGE1__NAME     205
#define IDC_EDIT_CLIENT_PAGE1_IP1       206
#define IDC_BUTTON4                     206
#define IDI_RESULT_NODE_CLIENT          206
#define IDC_EDIT_CLIENT_PAGE1__IP1      206
#define IDI_LOCATION_WARNING            206
#define IDD_CONNECT_TO_MACHINE          207
#define IDC_EDIT_CLIENT_PAGE1_IP2       207
#define IDI_RESULT_NODE_POLICY          207
#define IDC_EDIT_CLIENT_PAGE1__IP2      207
#define IDD_PROPPAGE_CLIENT1            208
#define IDC_EDIT_CLIENT_PAGE1_IP3       208
#define IDC_EDIT_CLIENT_PAGE1__IP3      208
#define IDC_EDIT_CLIENT_PAGE1_IP4       209
#define IDD_PROPPAGE_MACHINE1           209
#define IDC_EDIT_CLIENT_PAGE1__IP4      209
#define IDC_COMBO1                      210
#define IDD_PROPPAGE_MACHINE2           210
#define IDC_CHECK2                      211
#define IDD_ADD_CLIENT                  211
#define IDD_PROPPAGE_LOCAL_FILE_LOGGING1 212
#define IDC_EDIT_CLIENT_PAGE1_SHARED_SECRET 213
#define IDD_PROPPAGE_LOCAL_FILE_LOGGING2 213
#define IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET 213
#define IDC_EDIT_CLIENT_PAGE1_SHARED_SECRET_CONFIRM 214
#define IDD_PROPPAGE_POLICIES1          214
#define IDC_EDIT_CLIENT_PAGE1__SHARED_SECRET_CONFIRM 214
#define IDC_BUTTON_CLIENT_PAGE1_FIND    215
#define IDD_PROPPAGE_POLICIES2          215
#define IDC_BUTTON_CLIENT_PAGE1__FIND   215
#define IDC_EDIT1                       216
#define IDC_EDIT_MACHINE_PAGE2_AUTHENTICATION 216
#define IDD_PROPPAGE_POLICY1            216
#define IDC_EDIT_MACHINE_PAGE2_AUTHENTICATION_PORT 216
#define IDC_EDIT_VENDORID               216
#define IDC_CHECK3                      217
#define IDD_PROPPAGE_POLICY2            217
#define IDC_EDIT3                       217
#define IDC_EDIT2                       218
#define IDC_EDIT_MACHINE_PAGE2_ACCOUNTING 218
#define IDD_ADD_POLICY                  218
#define IDC_EDIT_MACHINE_PAGE2_ACCOUNTING_PORT 218
#define IDC_EDIT_MACHINE_PAGE1_NAME     219
#define IDD_PROPPAGE_PROFILE1           219
#define IDC_EDIT_MACHINE_PAGE1__NAME    219
#define IDC_CHECK4                      220
#define IDD_PROPPAGE_PROFILE2           220
#define IDD_PROPPAGE_PROFILE3           221
#define IDC_RADIO_STORE_ACTIVEDS        221
#define IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_IAS1 221
#define IDC_RADIO_STORE_LOCAL           222
#define IDD_PROPPAGE_PROFILE4           222
#define IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_ODBC 222
#define IDD_PROPPAGE_PROFILE5           223
#define IDC_RADIO_STORE_ACTIVEDS2       223
#define IDC_RADIO_STORE_LOCALE          223
#define IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__UNLIMITED 223
#define IDD_TIME_OF_DAY_CONSTRAINTS     224
#define IDC_RADIO_STORE_ACTIVEDS3       224
#define IDD_RESOLVE_DNS_NAME            225
#define IDC_BUTTON_POLICY_PAGE2_EDIT_PROFILE 226
#define IDC_BUTTON_EDITPROFILE          226
#define IDR_MACHINE_TOOLBAR             227
#define IDC_EDIT4                       228
#define IDR_LOGGING_METHODS_TOOLBAR     228
#define IDC_SPIN3                       229
#define IDR_POLICIES_TOOLBAR            229
#define IDC_SPIN4                       230
#define IDB_BITMAP1                     230
#define IDC_EDIT5                       231
#define IDC_CHECK6                      232
#define IDR_HTML3                       232
#define IDC_EDIT6                       233
#define IDD_RULEDIALOG1                 233
#define IDD_RULE_MULTIVALUE_ATTRIBUTE   233
#define IDD_DIALOG_ENUM_COND            233
#define IDC_EDIT7                       234
#define IDC_LISTVIEWCTRL1               237
#define IDC_RULE_SELECT_ATTRIBUTE       237
#define IDC_BUTTON_PROFILE_PAGE3_EDIT   238
#define IDC_EDIT_CONNECT_TO_SERVER__DNS_NAME 240
#define IDC_EDIT_ADD_CLIENT__CLIENT_NAME 241
#define IDC_EDIT_ADD_CLIENT__NAME       241
#define IDC_EDIT_ADD_POLICY__POLICY_NAME 242
#define IDC_BUTTON_ADD_CLIENT__CONFIGURE_CLIENT 244
#define IDC_COMBO_CLIENT_PAGE1__MANUFACTURER 245
#define IDD_RULE_SELECT_ATTRIBUTE       246
#define IDD_COND_SELECT_ATTRIBUTE       246
#define IDC_CHECK_CLIENT_PAGE1__CLIENT_ALWAYS_SENDS_SIGNATURE 247
#define IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__ENABLE_LOGGING 248
#define IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_ACCOUNTING_PACKETS 249
#define IDD_RULE_SINGLEVALUE_ATTRIBUTE  249
#define IDD_DIALOG_MATCH_COND           249
#define IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_AUTHENTICATION_PACKETS 250
#define IDD_DIALOG_POLICY_LOCATION      250
#define IDC_CHECK_LOCAL_FILE_LOGING_PAGE1__LOG_INTERIM_ACCOUNTING_PACKETS 251
#define IDR_POLICY_TOOLBAR              251
#define IDD_DIALOG_POLICY_WARNING       251
#define IDC_CHECK_LOCAL_FILE_LOGGING_PAGE2__AUTOMATICALLY_OPEN_NEW_LOG 252
#define IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY 253
#define IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY 254
#define IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY 255
#define IDC_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES 256
#define IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE 257
#define IDC_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_DIRECTORY 258
#define IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_NAME 259
#define IDC_CHECK_LOCAL_FILE_LOGGING_PAGE2__USE_V1_FORMAT 260
#define IDC_BUTTON_LOCAL_FILE_LOGGING_PAGE2__BROWSE 261
#define IDC_CHECK_MACHINE_PAGE1__CAPTURE_APPLICATION_EVENTS 262
#define IDC_CHECK_MACHINE_PAGE1__CAPTURE_MALFORMED_PACKETS 263
#define IDC_CHECK_MACHINE_PAGE1__CAPTURE_DEBUG_PACKETS 264
#define IDC_COMBO_ADD_CLIENT__PROTOCOL  265
#define IDC_EDIT_RESOLVE_DNS_NAME__DNS_NAME 266
#define IDC_STATIC_RESULT               267
#define IDC_LIST1                       268
#define IDC_LIST_RULEDLG2_SELECTION     268
#define IDC_LIST_POLICYPAGE1_CONDITIONS 268
#define IDC_LIST_ENUMCOND_SELECTION     268
#define IDC_LIST_CONDITIONS             268
#define IDC_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE_UNITS 268
#define IDC_LIST2                       269
#define IDC_LIST_RULEDLG2_CHOICE        269
#define IDC_LIST_ENUMCOND_CHOICE        269
#define IDC_BUTTON5                     270
#define IDC_CONNECTION_STATUS__DIALOG__STATUS 270
#define IDC_BUTTON_RULE_ADD             272
#define IDC_BUTTON_CONDITION_ADD        272
#define IDC_BUTTON_RULE_REMOVE          273
#define IDC_BUTTON_CONDITION_REMOVE     273
#define IDC_BUTTON_RULE_EDIT            274
#define IDC_BUTTON_CONDITION_EDIT       274
#define IDC_LIST_RULE_SELATTR           282
#define IDC_LIST_COND_SELATTR           282
#define IDC_BUTTON_RULEDLG1_ADD         283
#define IDC_BUTTON_ENUMCOND_ADD         283
#define IDC_BUTTON_RULEDLG1_DELETE      284
#define IDC_BUTTON_ENUMCOND_DELETE      284
#define IDC_EDIT_COND_TEXT              287
#define IDC_RADIO_GRANT_DIALIN          290
#define IDC_RADIO_DENY_DIALIN           291
#define IDC_BUTTON_REMOVE_GROUP         292
#define IDC_TXT_ATTRIBUTEVALUE          295
#define IDC_TXT_CHOOSEFORMAT            296
#define IDC_RADIO_STRING                297
#define IDC_RADIO_HEX                   298
#define IDC_RADIO_SELECTFROMLIST        299
#define IDC_RADIO_ENTERVERDORID         300
#define IDC_CHECK_DELETE_IF_FULL        301
#define IDD_DB_PROPPAGE                 302
#define IDC_DB_CHECK_ACCT               303
#define IDC_DB_CHECK_AUTH               304
#define IDC_DB_CHECK_INTERIM            305
#define IDC_DB_EDIT_MAX_SESSIONS        306
#define IDC_DB_EDIT_DATA_SOURCE         307
#define IDC_DB_BUTTON_CONFIGURE         308
#define IDC_DB_BUTTON_CLEAR             309
#define IDS_DB_NODE_NAME                310
#define IDS_DB_NOT_CONFIGURED           311
#define IDS_DB_E_TITLE                  312
#define IDS_DB_E_CANT_READ_DB_CONFIG    313
#define IDS_DB_E_CANT_WRITE_DB_CONFIG   314
#define IDS_DB_E_CANT_WRITE_SDO_CONFIG  315
#define IDS_DB_E_CANT_INIT_DIALOG       316
#define IDS_DB_E_INVALID_SESSIONS       317
#define IDS_IAS_ATTRIBUTE_EDITOR_PROJNAME 30100
#define IDS_IAS_MULTI_ATTR_COLUMN_NAME  30101
#define IDR_IAS_IPATTRIBUTEEDITOR       30102
#define IDS_IAS_MULTI_ATTR_COLUMN_VENDOR 30102
#define IDR_IAS_MULTIVALUEDATTRIBUTEEDITOR 30103
#define IDS_IAS_MULTI_ATTR_COLUMN_VALUE 30103
#define IDS_IAS_MULTI_ATTR_COLUMN_DESCRIPTION 30104
#define IDS_IAS_IP_EDITOR_TITLE         30105
#define IDS_IAS_MULTIVALUED_EDITOR_TITLE 30106
#define IDR_IAS_VENDORSPECIFICATTRIBUTEEDITOR 30107
#define IDS_IAS_ERR_INVALID_VSAHEX      30107
#define IDR_IAS_ENUMERABLEATTRIBUTEEDITOR 30108
#define IDS_IAS_ERR_ADVANCED            30108
#define IDR_IAS_STRINGATTRIBUTEEDITOR   30109
#define IDS_IAS_ERR_INVALIDINTEGER      30109
#define IDS_IAS_ERR_INVALID_UINT        30110
#define IDS_IAS_ERR_INVALIDBOOL         30111
#define IDC_IAS_EDIT_IPADDR             30201
#define IDC_IAS_STATIC_ATTRNAME         30202
#define IDC_IAS_STATIC_ATTRTYPE         30203
#define IDC_IAS_STATIC_ATTRFORMAT       30204
#define IDC_IAS_LIST_MULTI_ATTRS        30206
#define IDC_IAS_EDIT_MULTI_ATTR_NAME    30207
#define IDC_IAS_EDIT_MULTI_ATTR_FORMAT  30208
#define IDC_IAS_EDIT_MULTI_ATTR_NUMBER  30209
#define IDC_IAS_EDIT_MULTI_ATTR_NEW_VALUE 30210
#define IDC_IAS_BUTTON_ADD_VALUE        30211
#define IDC_IAS_BUTTON_ADD_VALUE2       30212
#define IDC_IAS_BUTTON_REMOVE           30212
#define IDC_IAS_BUTTON_MOVE_UP          30213
#define IDC_IAS_BUTTON_MOVE_DOWN        30214
#define IDD_IAS_MULTI_ATTR              30215
#define IDC_IAS_BUTTON_EDIT             30215
#define IDD_IAS_ENUM_ATTR               30216
#define IDD_IAS_IPADDR_ATTR             30217
#define IDD_IAS_MULTIVALUED_EDITOR      30218
#define IDD_IAS_VENDORSPEC_ATTR         30219
#define IDC_STATIC_SPECIFY_NAS_VENDOR   20220
#define IDC_IAS_EDIT_ATTRVALUE          30221
#define IDC_IAS_COMBO_ENUM_VALUES       30222
#define IDC_IAS_COMBO_VENDORID          30223
#define IDC_IAS_RADIO_HEX               30224
#define IDC_IAS_RADIO_RADIUS            30225
#define IDC_IAS_EDIT_VENDORSPEC_TYPE    30226
#define IDC_IAS_COMBO_VENDORSPEC_FORMAT 30227
#define IDC_IAS_EDIT_VENDORSPEC_VALUE   30228
#define IDD_IAS_SINGLE_ATTR             30229
#define IDS_IAS_VSA_FORMAT_STR          30230
#define IDS_IAS_VSA_FORMAT_DEC          30231
#define IDS_IAS_VSA_FORMAT_HEX          30232
#define IDS_IAS_ERR_SDOERROR_GETPROPERTY 30233
#define IDS_IAS_ERR_SDOERROR_QUERYINTERFACE 30234
#define IDC_IAS_BUTTON_CONFIGURE        30235
#define IDD_IAS_VENDORSPEC_ATTR_CONFORMS_NO 30236
#define IDD_IAS_VENDORSPEC_ATTR_CONFORMS_YES 30237
#define IDC_IAS_STATIC_ATTR_VALUE       30238
#define IDD_DIALOG_DISPLAY_GROUPS       30241
#define ID_BUTTON32768                  32768
#define ID_BUTTON32769                  32769
#define ID_BUTTON32770                  32770
#define ID_BUTTON32771                  32771
#define ID_BUTTON32772                  32772
#define ID_BUTTON32773                  32773
#define ID_BUTTON32774                  32774
#define ID_MENUITEM32775                32775
#define ID_MENUITEM_DO_SOMETHING_TO_CLIENT 32777
#define ID_MENUITEM_MACHINE_TOP__START_SERVICE 32778
#define ID_MENUITEM_MACHINE_TOP__STOP_SERVICE 32779
#define ID_MENUITEM_CLIENTS_NEW__CLIENT 32780
#define ID_MENUITEM_ROOT_TOP__CONNECT_TO_SERVER 32781
#define ID_MENUITEM_CLIENTS_TOP__NEW_CLIENT 32783
#define ID_BUTTON32785                  32785
#define ID_BUTTON32786                  32786
#define ID_BUTTON32787                  32787
#define ID_BUTTON32788                  32788
#define ID_MENUITEM_POLICIES_TOP__NEW_POLICY 32790
#define ID_MENUITEM_POLICIES_NEW__POLICY 32791
#define ID_MENUITEM_POLICY_TOP__MOVE_UP 32792
#define ID_MENUITEM_POLICY_TOP__MOVE_DOWN 32793
#define ID_BUTTON_MACHINE__START_SERVICE 32794
#define ID_BUTTON_MACHINE__STOP_SERVICE 32795
#define ID_BUTTON_POLICY_MOVEDOWN       32797
#define ID_BUTTON_POLICY_MOVEUP         32798
#define IDS_HTMLHELP_PATH               32799
#define IDS_ERROR_OBJECT_PICKER_NO_SIDS 32800
#define ID_MENUITEM_POLICIES_TOP__POLICY_LOCATION 32800
#define IDS_POLICY_COLUMN_TITLE3        32801
#define IDS_POLICY_LOCATION_ACTIVEDS    32802
#define IDS_POLICY_LOCATION_LOCAL       32803
#define IDS_ERROR_CANT_CONNECT          32804
#define IDS_ERROR_SDO_ERROR_GETATTRINFO 32805
#define IDS_ERROR_SDO_ERROR_ENUMATTR    32806
#define IDS_ERROR_SDO_ERROR_ENUMPOLICY  32807
#define IDS_ERROR_SDO_ERROR_QUERYINTERFACE 32808
#define IDS_ERROR_CANT_CREATE_POLICY    32809
#define IDS_ERROR_SDO_ERROR_ADDPOLICY   32810
#define IDS_ERROR_SDO_ERROR_ADDPROFILE  32811
#define IDS_ERROR_SDO_ERROR_REMOVEPROFILE 32812
#define IDS_ERROR_SDO_ERROR_REMOVEPOLICY 32813
#define IDS_ERROR_SDO_ERROR_PUTPROP_SERVERDS 32814
#define IDS_ERROR_SDO_ERROR_SERVERAPPLY 32815
#define IDS_ERROR_SDO_ERROR_ADDATTR     32816
#define IDS_ERROR_SDO_ERROR_CREATEATTR  32817
#define IDS_ERROR_SDO_ERROR_PUTPROP_ATTR 32818
#define IDS_ERROR_SDO_ERROR_PUTPROP_POLICYNAME 32819
#define IDS_ERROR_SDO_ERROR_PUTPROP_POLICY_PROFILENAME 32820
#define IDS_ERROR_SDO_ERROR_PUTPROP_PROFILENAME 32821
#define IDS_ERROR_SDO_ERROR_POLICY_APPLY 32822
#define IDS_ERROR_SDO_ERROR_PROFILE_APPLY 32823
#define IDS_ERROR_SDO_ERROR_GETPROP_POLICYNAME 32824
#define IDS_ERROR_SDO_ERROR_GETPROP_POLICYMERIT 32825
#define IDS_ERROR_SDO_ERROR_ENUMCOND    32826
#define IDS_ERROR_SDO_ERROR_GET_CONDTEXT 32827
#define IDS_ERROR_CANT_CREATE_CONDATTR  32828
#define IDS_ERROR_SDO_ERROR_GETATTROD   32829
#define IDS_ERROR_CANT_CREATE_COND      32830
#define IDS_ERROR_SDO_ERROR_PUTPROP_POLICYMERIT 32831
#define IDS_ERROR_SDO_ERROR_ADDCOND     32832
#define IDS_ERROR_SDO_ERROR_PUTPROP_CONDTEXT 32833
#define IDS_ERROR_SDO_ERROR_PROFATTRCOLLECTION 32834
#define IDS_ERROR_SDO_ERROR_SETDIALIN   32835
#define IDS_ERROR_CANT_EDIT_CONDITION   32836
#define IDS_ERROR_RENAMEPROFILE         32837
#define IDS_ERROR_RENAMEPOLICY          32838
#define IDS_POLICY_PROPERTY_PAGE_TABNAME 32839
#define IDS_ERROR_NO_PROFILE_NAME       32840
#define IDS_ERROR_ZERO_CONDITION_POLICY 32841
#define IDS_ERROR_ZERO_POLICY           32842
#define IDS_ERROR_DS_NAMESPACE_EMPTY    32843
#define IDS_ERROR_LOCAL_NAMESPACE_EMPTY 32844
#define IDS_ERROR_PRESS_TO_RESTORE      32845
#define IDS_ERROR_CANT_RESTORE_POLICY   32846
#define IDS_ERROR_CANT_RESTORE_PROFILE  32847
#define IDS_WARNING_NEED_RESTART_SERVICE 32848
#define IDS_ERROR_CANT_GET_DOMAININFO   32849
#define IDS_ERROR_CANT_GET_SERVERSDO    32850
#define IDS_ERROR_CANT_GET_SERVERINFOSDO 32851
#define IDS_CONNECTION_CONNECTING_TO_STR 32852
#define IDB_STATIC_FOLDER_32            32853
#define IDS_ERROR__NOT_A_VALID_DIRECTORY 32853
#define IDB_STATIC_FOLDER_OPEN_16       32854
#define IDB_STATIC_FOLDER_16            32855
#define IDC_STATIC_GRANT_OR_DENY_TEXT   32857
#define IDS_POLICY_DENY_ACCESS_INFO     32858
#define IDS_POLICY_GRANT_ACCESS_INFO    32859
#define IDS_POLICIES_NODE_FROM_DIRECTORY_SERVICE 32860
#define IDS_POLICIES_NODE_FROM_LOCAL_MACHINE 32861
#define IDS_ADD_POLICY_WIZ_TAB_NAME 32862
#define   IDS_SNAPINNAME_NAP            32866
#define   IDS_SNAPINNAME_LOGGING         32867
#define IDC_BUTTON_ADD_CONDITION        32868
#define IDS_POLICY_NODE__DELETE_POLICY__PROMPT 32869
#define IDC_BUTTON_ADD_GROUP            32869
#define IDS_POLICY_NODE__DELETE_POLICY__PROMPT_TITLE 32870
#define IDC_LIST_GROUPS                 32871
#define IDC_ADD_GROUP                   32872
#define IDC_REMOVE_GROUP                32873
#define IDS_DISPLAY_GROUPS_FIRSTCOLUMN  32874
#define IDS_DISPLAY_GROUPS_SECONDCOLUMN 32875
#define IDC_IAS_IPADDR_VENDORSPEC_VALUE 32876
#define IDS_ERROR__LOGGING_TITLE        32877
#define IDS_ERROR__LOCAL_FILE_LOGGING_READING_ENBABLE 32914
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_ENABLE 32915
#define IDS_ERROR__LOCAL_FILE_LOGGING_READING_ACCOUNTING_PACKETS 32916
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_ACCOUNTING_PACKETS 32917
#define IDS_ERROR__LOCAL_FILE_LOGGING_READING_AUTHENTICATION_PACKETS 32920
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_AUTHENTICATION_PACKETS 32921
#define IDS_ERROR__LOCAL_FILE_LOGGING_READING_INTERIM_ACCOUNTING_PACKETS 32922
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_INTERIM_ACCOUNTING_PACKETS 32923
#define IDS_ERROR__LOCAL_FILE_LOGGING_READING_AUTOMATICALLY_OPEN_NEW_LOG 32924
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_AUTOMATICALLY_OPEN_NEW_LOG 32925
#define IDS_ERROR__LOCAL_FILE_LOGGING_READING_NEW_LOG_FREQUENCY 32926
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_NEW_LOG_FREQUENCY 32927
#define IDS_ERROR__LOCAL_FILE_LOGGING_READING_WHEN_LOG_FILE_SIZE 32928
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_WHEN_LOG_FILE_SIZE 32929
#define IDS_ERROR__LOCAL_FILE_LOGGING_READING_LOG_FILE_DIRECTORY 32930
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_LOG_FILE_DIRECTORY 32931
#define IDS_ERROR__LOCAL_FILE_LOGGING_READING_LOG_FILE_FORMAT 32932
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_LOG_FILE_FORMAT 32933
#define IDS_ERROR__LOCAL_FILE_LOGGING_WRITING_WHEN_LOG_FILE_SIZE_NOT_ZERO 32946
#define IDS_IAS_VSA_FORMAT_INetAddr     32947
#define IDS_IAS_VAS_VENDOR_ID         32948
#define IDS_ERROR__POLICYNAME_EMPTY      32949
#define IDS_ERROR__NOTABLE_TO_WRITE_SDO   32950
#define IDS_ERROR__RESTART_SNAPIN      32951
#define IDS_IAS_ERR_INVALIDCHARINPASSWORD 32952
#define   IDS_TEXT_MATCHES            32953

// Now for the Boolean attribute editor
#define IDD_IAS_BOOLEAN_ATTR              32954
#define IDC_TXT_SELECT_VALUE              32955
#define IDC_RADIO_TRUE                    32956
#define IDC_RADIO_FALSE                   32957
#define IDS_BOOLEAN_TRUE                  32958
#define IDS_BOOLEAN_FALSE                 32959

// Now for the IP Filter attribute editor
#define IDD_IAS_IP_FILTER_ATTR            32960
#define IDC_BUTTON_FROMCLIENT             32961
#define IDC_BUTTON_TOCLIENT               32962
#define IDC_TXT_PROF_ATTR_INPUT_FILTER    32963
#define IDC_TXT_PROF_ATTR_OUTPUT_FILTER   32964
#define IDS_ERROR_IP_FILTER_TOO_BIG       32965

// dialog IDs
#define IDD_NEWRAPWIZ_SCENARIO          1000
#define IDD_NEWRAPWIZ_GROUP             1001
#define IDD_NEWRAPWIZ_AUTHENTICATION    1002
#define IDD_NEWRAPWIZ_ENCRYPTION        1003
#define IDD_NEWRAPWIZ_NAME               1004
#define IDD_NEWRAPWIZ_CONDITION         1005
#define IDD_NEWRAPWIZ_ALLOWDENY         1006
#define IDD_NEWRAPWIZ_EDITPROFILE       1007
#define IDD_NEWRAPWIZ_EAP               1008
#define   IDD_NEWRAPWIZ_WELCOME         1009
#define IDD_NEWRAPWIZ_COMPLETION      1010
#define IDD_NEWRAPWIZ_ENCRYPTION_VPN    1011

// control IDs for IDD_NEWRAPWIZ_GROUP
#define IDC_NEWRAPWIZ_GROUP_REMOVEGROUP 1020
#define IDC_NEWRAPWIZ_GROUP_USER        1021
#define IDC_NEWRAPWIZ_GROUP_GROUP       1022
#define IDC_NEWRAPWIZ_GROUP_ADDGROUP    1023
#define IDC_NEWRAPWIZ_GROUP_GROUPS      1024
#define IDC_NEWRAPWIZ_GROUP_GROUPTEXT   1025

// control IDs for IDD_NEWRAPWIZ_AUTHENTICATION
#define IDC_NEWRAPWIZ_AUTH_EAP          1040
#define IDC_NEWRAPWIZ_AUTH_EAP_COMBO    1041
#define IDC_NEWRAPWIZ_AUTH_CONFIGEAP    1042
#define IDC_NEWRAPWIZ_AUTH_MSCHAP2      1043
#define IDC_NEWRAPWIZ_AUTH_MSCHAP       1044

// control IDs for IDD_NEWRAPWIZ_ENCRYPTION
#define IDC_NEWRAPWIZ_ENCRY_NO          1061
#define IDC_NEWRAPWIZ_ENCRY_BASIC       1062
#define IDC_NEWRAPWIZ_ENCRY_STRONG      1063
#define IDC_NEWRAPWIZ_ENCRY_STRONGEST   1064

// control IDs for IDD_NEWRAPWIZ_SCENARIO
#define IDC_NEWRAPWIZ_SCENARIO_DIALUP   1080
#define IDC_NEWRAPWIZ_SCENARIO_VPN      1081
#define IDC_NEWRAPWIZ_SCENARIO_WIRELESS 1082
#define IDC_NEWRAPWIZ_SCENARIO_SWITCH   1083

// control IDs for IDD_NEWRAPWIZ_NAME
#define IDC_NEWRAPWIZ_NAME_POLICYNAME   1100
#define   IDC_NEWRAPWIZ_NAME_SCENARIO      1101
#define   IDC_NEWRAPWIZ_NAME_MANUAL      1102

// control IDS for welcome and completion page
#define   IDC_NEWRAPWIZ_STATIC_LARGE      1120
#define   IDC_NEWRAPWIZ_FINISH_POLICYNAME   1121
#define IDC_NEWRAPWIZ_FINISH_SETTINGS   1122

#define IDB_RAP_WATERMARK            1140
#define IDB_RAP_HEADER               1141

// title and subtile ids for rap wizard
#define IDS_NEWRAPWIZ_NAME_TITLE            2160
#define IDS_NEWRAPWIZ_NAME_SUBTITLE            2161
#define IDS_NEWRAPWIZ_SCENARIO_TITLE         2162
#define IDS_NEWRAPWIZ_SCENARIO_SUBTITLE         2163
#define IDS_NEWRAPWIZ_GROUP_TITLE            2164
#define IDS_NEWRAPWIZ_GROUP_SUBTITLE         2165
#define IDS_NEWRAPWIZ_AUTHENTICATION_TITLE      2166
#define IDS_NEWRAPWIZ_AUTHENTICATION_SUBTITLE   2167
#define IDS_NEWRAPWIZ_ENCRYPTION_TITLE         2168
#define IDS_NEWRAPWIZ_ENCRYPTION_SUBTITLE      2169
#define IDS_NEWRAPWIZ_EAP_TITLE               2170
#define IDS_NEWRAPWIZ_EAP_SUBTITLE            2171
#define IDS_NEWRAPWIZ_CONDITION_TITLE         2172
#define IDS_NEWRAPWIZ_CONDITION_SUBTITLE      2173
#define IDS_NEWRAPWIZ_ALLOWDENY_TITLE         2174
#define IDS_NEWRAPWIZ_ALLOWDENY_SUBTITLE      2175
#define IDS_NEWRAPWIZ_EDITPROFILE_TITLE         2176
#define IDS_NEWRAPWIZ_EDITPROFILE_SUBTITLE      2177


#define IDS_NEWRAPWIZ_COMPLETION_CONDITION      2186
#define IDS_NEWRAPWIZ_COMPLETION_MANUALSET      2187
#define IDS_NEWRAPWIZ_COMPLETION_AUTHEN         2188
#define IDS_NEWRAPWIZ_COMPLETION_ENCRY         2189
#define IDS_NEWRAPWIZ_ITEM_SEP               2190
#define IDS_AUTHEN_METHOD_MSCHAP            2191
#define IDS_AUTHEN_METHOD_MSCHAP2            2192
#define IDS_AUTHEN_METHOD_EAP               2193
#define IDS_ENCYP_METHOD_NO                  2194
#define IDS_ENCYP_METHOD_BASIC               2195
#define IDS_ENCYP_METHOD_STRONG               2196
#define IDS_ENCYP_METHOD_STRONGEST            2197



// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\rapwz_name.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

	AddPolicyWizardPage1.h

Abstract:

	Header file for the CNewRAPWiz_Name class.

	This is our handler class for the first CPolicyNode property page.

	See AddPolicyWizardPage1.cpp for implementation.

Revision History:
	mmaguire 12/15/97 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NAP_ADD_POLICY_WIZPAGE_1_H_)
#define _NAP_ADD_POLICY_WIZPAGE_1_H_

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include "PropertyPage.h"
//
//
// where we can find what this class has or uses:
//
class CPolicyNode;
#include "atltmp.h"
#include "rapwiz.h"

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////


class CNewRAPWiz_Name : public CIASWizard97Page<CNewRAPWiz_Name, IDS_NEWRAPWIZ_NAME_TITLE, IDS_NEWRAPWIZ_NAME_SUBTITLE>
{

public :

	// ISSUE: how is base class initialization going to work with subclassing???
	CNewRAPWiz_Name(
				CRapWizardData* pWizData,
			  LONG_PTR hNotificationHandle
			, TCHAR* pTitle = NULL
			, BOOL bOwnsNotificationHandle = TRUE
			);

	~CNewRAPWiz_Name();

	// This is the ID of the dialog resource we want for this class.
	// An enum is used here because the correct value of
	// IDD must be initialized before the base class's constructor is called
	enum { IDD = IDD_NEWRAPWIZ_NAME };

	BEGIN_MSG_MAP(CNewRAPWiz_Name)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER(IDC_NEWRAPWIZ_NAME_POLICYNAME, OnPolicyNameEdit)
		COMMAND_ID_HANDLER(IDC_NEWRAPWIZ_NAME_SCENARIO, OnPath)
		COMMAND_ID_HANDLER(IDC_NEWRAPWIZ_NAME_MANUAL, OnPath)
		CHAIN_MSG_MAP(CIASPropertyPageNoHelp<CNewRAPWiz_Name>)
	END_MSG_MAP()

	LRESULT OnInitDialog(
		  UINT uMsg
		, WPARAM wParam
		, LPARAM lParam
		, BOOL& bHandled
		);

	LRESULT OnPolicyNameEdit(
		  UINT uMsg
		, WPARAM wParam
		, HWND hWnd
		, BOOL& bHandled
		);

	LRESULT OnPath(
		  UINT uMsg
		, WPARAM wParam
		, HWND hWnd
		, BOOL& bHandled
		);

	BOOL OnWizardNext();
	BOOL OnSetActive();
	BOOL OnQueryCancel();
	BOOL OnWizardBack() { return m_spWizData->GetPrevPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);};


public:
	BOOL ValidPolicyName(LPCTSTR pszName);
	
protected:
	// wizard shareed data
	CComPtr<CRapWizardData>	m_spWizData;

};

#endif // _NAP_ADD_POLICY_WIZPAGE_1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\rtradvise.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation

Module Name:

    rtradvise.cpp

Abstract:
    this class implement IRtrAdviseSink interface to redirect notification of changes
    to the snapin node


Author:

    Wei Jiang 1/7/99

Revision History:
   weijiang 1/7/99 - created 


--*/
//////////////////////////////////////////////////////////////////////////////
#include "Precompiled.h"
#include "rtradvise.h"

const IID IID_IRtrAdviseSink = {0x66A2DB14,0xD706,0x11d0,{0xA3,0x7B,0x00,0xC0,0x4F,0xC9,0xDA,0x04}};


const IID IID_IRouterRefresh = {0x66a2db15,0xd706,0x11d0,{0xa3,0x7b,0x00,0xc0,0x4f,0xc9,0xda,0x04}};


const IID IID_IRouterRefreshAccess = {0x66a2db1c,0xd706,0x11d0,{0xa3,0x7b,0x00,0xc0,0x4f,0xc9,0xda,0x04}};


//----------------------------------------------------------------------------
// Function:    ConnectRegistry
//
// Connects to the registry on the specified machine
//----------------------------------------------------------------------------

DWORD ConnectRegistry(
    IN  LPCTSTR pszMachine,         // NULL if local
    OUT HKEY*   phkeyMachine
    ) {

    //
    // if no machine name was specified, connect to the local machine.
    // otherwise, connect to the specified machine
    //

    DWORD dwErr = NO_ERROR;
   if (NULL == pszMachine)
   {
        *phkeyMachine = HKEY_LOCAL_MACHINE;
    }
    else
   {
        //
        // Make the connection
        //

        dwErr = ::RegConnectRegistry(
                    (LPTSTR)pszMachine, HKEY_LOCAL_MACHINE, phkeyMachine
                    );
    }

    return dwErr;
}


//----------------------------------------------------------------------------
// Function:    DisconnectRegistry
//
// Disconnects the specified config-handle. The handle is assumed to have been
// acquired by calling 'ConnectRegistry'.
//----------------------------------------------------------------------------

VOID DisconnectRegistry(
    IN  HKEY    hkeyMachine
    ) {

    if (hkeyMachine != HKEY_LOCAL_MACHINE)
   {
      ::RegCloseKey(hkeyMachine);
   }
}


DWORD ReadRegistryStringValue(LPCTSTR pszMachine, LPCTSTR pszKeyUnderLocalMachine, LPCTSTR pszName, ::CString& strValue)
{
   HKEY  rootk = NULL;
   HKEY  k = NULL;
   DWORD ret = NO_ERROR;
   if((ret = ConnectRegistry(pszMachine, &rootk)) != NO_ERROR)
      goto Error;

   // Cool, we have a machine registry entry, now get the
   // path down to the routertype key
   ret = RegOpenKeyEx(rootk, pszKeyUnderLocalMachine, 0, KEY_READ, &k);
   if (ret != NO_ERROR)
      goto Error;

   // Ok, at this point we just need to get the RouterType value from
   // the key
   {
      DWORD type = REG_SZ;
      TCHAR value[MAX_PATH];
      DWORD len = MAX_PATH;
      ret = ::RegQueryValueEx(k, pszName, 0, &type, (LPBYTE )value, &len);
      if(ret == ERROR_SUCCESS)
         strValue = value;
   }


Error:
   if(rootk)
      DisconnectRegistry(rootk);
   if(k)
      RegCloseKey(k);

   return ret;
}

DWORD ReadRegistryDWORDValue(LPCTSTR pszMachine, LPCTSTR pszKeyUnderLocalMachine, LPCTSTR pszName, DWORD* pdwValue)
{
   HKEY  rootk = NULL;
   HKEY  k = NULL;
   DWORD ret = NO_ERROR;
   if((ret = ConnectRegistry(pszMachine, &rootk)) != NO_ERROR)
      goto Error;

   // Cool, we have a machine registry entry, now get the
   // path down to the routertype key
   ret = RegOpenKeyEx(rootk, pszKeyUnderLocalMachine, 0, KEY_READ, &k);
   if (ret != NO_ERROR)
      goto Error;

   {
   // Ok, at this point we just need to get the RouterType value from
   // the key
   DWORD type = REG_DWORD;
   DWORD len = sizeof(DWORD);
   ret = ::RegQueryValueEx(k, pszName, 0, &type, (LPBYTE )pdwValue, &len);
   }

Error:
   if(rootk)
      DisconnectRegistry(rootk);
   if(k)
      RegCloseKey(k);

   return ret;
}


//----------------------------------------------------------------------------
//
// helper functions to check if RRAS is using NT Authentication
//
//----------------------------------------------------------------------------

BOOL  IsRRASUsingNTAuthentication(LPCTSTR pszMachine) // when NULL: local machine
{
   ::CString   str;
   BOOL  ret = FALSE;

   if(ERROR_SUCCESS == ReadRegistryStringValue(pszMachine, 
                                    RegKeyRouterAuthenticationProviders, 
                                    RegValueName_RouterActiveAuthenticationProvider, 
                                    str))
   {
      ret = (str.CompareNoCase(NTRouterAuthenticationProvider) == 0);
   }

   return ret;
}

//----------------------------------------------------------------------------
//
// helper functions to check if RRAS is configured
//
//----------------------------------------------------------------------------

BOOL  IsRRASConfigured(LPCTSTR pszMachine)   // when NULL: local machine
{
   DWORD dwConfig= 0;

   ReadRegistryDWORDValue(pszMachine, 
                  RegRemoteAccessKey, 
                  RegRtrConfigured, 
                  &dwConfig);

   return (dwConfig != 0);
}


//----------------------------------------------------------------------------
//
// helper function to check if RRAS is using NT accounting for logging
//
//----------------------------------------------------------------------------

BOOL  IsRRASUsingNTAccounting(LPCTSTR pszMachine)     // when NULL, local machine
{

   ::CString   str;
   BOOL  ret = FALSE;

   if(ERROR_SUCCESS == ReadRegistryStringValue(pszMachine, 
                                    RegKeyRouterAccountingProviders, 
                                    RegValueName_RouterActiveAccountingProvider, 
                                    str))
   {
      ret = (str.CompareNoCase(NTRouterAccountingProvider) == 0);
   }

   return ret;

};


static unsigned int  s_cfComputerAddedAsLocal = RegisterClipboardFormat(L"MMC_MPRSNAP_COMPUTERADDEDASLOCAL");

BOOL ExtractComputerAddedAsLocal(LPDATAOBJECT lpDataObject)
{
    BOOL    fReturn = FALSE;
    BOOL *  pReturn;
    pReturn = Extract<BOOL>(lpDataObject, (CLIPFORMAT) s_cfComputerAddedAsLocal, -1);
    if (pReturn)
    {
        fReturn = *pReturn;
        GlobalFree(pReturn);
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\rapwz_profile.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation

Module Name: rapwz_profile.cpp

Abstract:
   Implementation file for the CNewRAPWiz_EditProfile class.
   We implement the class needed to handle the first property page for a Policy node.

Revision History:
   mmaguire 12/15/97 - created
   byao   1/22/98 Modified for Network Access Policy

--*/
//////////////////////////////////////////////////////////////////////////////


#include "Precompiled.h"
#include "rapwz_profile.h"
#include "NapUtil.h"
#include "PolicyNode.h"
#include "PoliciesNode.h"
#include "rasprof.h"
#include "ChangeNotification.h"


//+---------------------------------------------------------------------------
//
// Function:   CNewRAPWiz_EditProfile
//
// Class:      CNewRAPWiz_EditProfile
//
// Synopsis:   class constructor
//
// Arguments:   CPolicyNode *pPolicyNode - policy node for this property page
//          CIASAttrList *pAttrList -- attribute list
//              TCHAR* pTitle = NULL -
//
// Returns:     Nothing
//
// History:     Created Header    byao 2/16/98 4:31:52 PM
//
//+---------------------------------------------------------------------------
CNewRAPWiz_EditProfile::CNewRAPWiz_EditProfile(
            CRapWizardData* pWizData,
            LONG_PTR hNotificationHandle,
            CIASAttrList *pIASAttrList,
            TCHAR* pTitle, BOOL bOwnsNotificationHandle,
            bool isWin2k
                   )
          : CIASWizard97Page<CNewRAPWiz_EditProfile, IDS_NEWRAPWIZ_EDITPROFILE_TITLE, IDS_NEWRAPWIZ_EDITPROFILE_SUBTITLE> ( hNotificationHandle, pTitle, bOwnsNotificationHandle ),
          m_spWizData(pWizData),
          m_isWin2k(isWin2k)
{
   TRACE_FUNCTION("CNewRAPWiz_EditProfile::CNewRAPWiz_EditProfile");

   m_pIASAttrList = pIASAttrList;
}

//+---------------------------------------------------------------------------
//
// Function:   CNewRAPWiz_EditProfile
//
// Class:      CNewRAPWiz_EditProfile
//
// Synopsis:   class destructor
//
// Returns:     Nothing
//
// History:     Created Header    byao 2/16/98 4:31:52 PM
//
//+---------------------------------------------------------------------------
CNewRAPWiz_EditProfile::~CNewRAPWiz_EditProfile()
{  
   TRACE_FUNCTION("CNewRAPWiz_EditProfile::~CNewRAPWiz_EditProfile");

}

//////////////////////////////////////////////////////////////////////////////
/*++

CNewRAPWiz_EditProfile::OnInitDialog

--*/
//////////////////////////////////////////////////////////////////////////////
LRESULT CNewRAPWiz_EditProfile::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   TRACE_FUNCTION("CNewRAPWiz_EditProfile::OnInitDialog");

   HRESULT              hr = S_OK;
   BOOL              fRet;
   CComPtr<IUnknown>    spUnknown;
   CComPtr<IEnumVARIANT>   spEnumVariant;
   long              ulCount;
   ULONG             ulCountReceived;

   SetModified(FALSE);
   return TRUE;   // ISSUE: what do we need to be returning here?
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNewRAPWiz_EditProfile::OnWizardFinish

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CNewRAPWiz_EditProfile::OnWizardNext()
{

   // reset the dirty bit
   SetModified(FALSE);

   return m_spWizData->GetNextPageId(((PROPSHEETPAGE*)(*this))->pszTemplate);
   
}


//////////////////////////////////////////////////////////////////////////////
/*++
CNewRAPWiz_EditProfile::OnQueryCancel

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CNewRAPWiz_EditProfile::OnQueryCancel()
{
   TRACE_FUNCTION("CNewRAPWiz_EditProfile::OnQueryCancel");

   return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNewRAPWiz_EditProfile::OnEditProfile

--*/
//////////////////////////////////////////////////////////////////////////////

//////////
// Signature of the entry point to the profile editing DLL.
//////////
typedef HRESULT (APIENTRY *OPENRAS_IASPROFILEDLG)(
            LPCWSTR pszMachineName,
            ISdo* pProfile,            // profile SDO pointer
            ISdoDictionaryOld*   pDictionary,   // dictionary SDO pointer
            BOOL  bReadOnly,           // if the dlg is for readonly
            DWORD dwTabFlags,          // what to show
            void  *pvData              // additional data
   );

LRESULT CNewRAPWiz_EditProfile::OnEditProfile(UINT uMsg, WPARAM wParam, HWND hwnd, BOOL& bHandled)
{
   TRACE_FUNCTION("CNewRAPWiz_EditProfile::OnEditProfile");

   OPENRAS_IASPROFILEDLG   pfnProfileEditor = NULL;

   HRESULT     hr       = S_OK;
   HMODULE     hProfileDll = NULL;

   hProfileDll = LoadLibrary(_T("rasuser.dll"));
   if ( NULL == hProfileDll )
   {
      hr = HRESULT_FROM_WIN32(GetLastError());
      ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "LoadLibrary() failed, err = %x", hr);

      ShowErrorDialog(m_hWnd, IDS_ERROR_CANT_FIND_PROFILEDLL, NULL, hr);
      return 0;
   }
   
   pfnProfileEditor = (OPENRAS_IASPROFILEDLG) GetProcAddress(hProfileDll, "OpenRAS_IASProfileDlg");
   if ( NULL == pfnProfileEditor )
   {
      hr = HRESULT_FROM_WIN32(GetLastError());
      ErrorTrace(ERROR_NAPMMC_POLICYPAGE1, "GetProcAddress() failed, err = %x", hr);

      ShowErrorDialog(m_hWnd, IDS_ERROR_CANT_FIND_PROFILEAPI, NULL, hr);
      FreeLibrary(hProfileDll);
      return 0;
   }

   // findout if this is extending RRAS or IAS
   
   CPoliciesNode* pPoliciesNode = dynamic_cast<CPoliciesNode*>(m_spWizData->m_pPolicyNode->m_pParentNode);

   DWORD dwFlags = RAS_IAS_PROFILEDLG_SHOW_IASTABS;
   if(pPoliciesNode != NULL)
   {
      if(!pPoliciesNode->m_fExtendingIAS)
         dwFlags = RAS_IAS_PROFILEDLG_SHOW_RASTABS;
   }

   if(m_isWin2k)
   {
      dwFlags |= RAS_IAS_PROFILEDLG_SHOW_WIN2K;
   }
   
   //
   // now we do have this profile sdo, call the API
   //
   hr = pfnProfileEditor(
               m_spWizData->m_pPolicyNode->m_pszServerAddress,
               m_spWizData->m_spProfileSdo,
               m_spWizData->m_spDictionarySdo,
               FALSE,
               dwFlags,
               (void *)&(m_pIASAttrList->m_AttrList)
            );
   FreeLibrary(hProfileDll);
   DebugTrace(DEBUG_NAPMMC_POLICYPAGE1, "OpenRAS_IASProfileDlg() returned %x", hr);
   if ( FAILED(hr) )
   {
      return hr;
   }

   return hr;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CNewRAPWiz_EditProfile::OnSetActive

Return values:

   TRUE if the page can be made active
   FALSE if the page should be be skipped and the next page should be looked at.

Remarks:

   If you want to change which pages are visited based on a user's
   choices in a previous page, return FALSE here as appropriate.

--*/
//////////////////////////////////////////////////////////////////////////////
BOOL CNewRAPWiz_EditProfile::OnSetActive()
{
   ATLTRACE(_T("# CNewRAPWiz_EditProfile::OnSetActive\n"));
   
   // MSDN docs say you need to use PostMessage here rather than SendMessage.
   ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT);

   return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\rtradvise.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation

Module Name:

    rtradvise.h

Abstract:
    this class implement IRtrAdviseSink interface to redirect notification of changes
    to the snapin node


Author:

    Wei Jiang 1/7/99

Revision History:
   weijiang 1/7/99 - created 


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_IAS_MMC_RTRADVISE_H_)
#define _IAS_MMC_RTRADVISE_H_

#include <rrasui.h>
#include <winreg.h>
#include "iastrace.h"

#define RegKeyRouterAccountingProviders _T("System\\CurrentControlSet\\Services\\RemoteAccess\\Accounting\\Providers")
#define RegKeyRouterAuthenticationProviders  _T("System\\CurrentControlSet\\Services\\RemoteAccess\\Authentication\\Providers")
#define RegRemoteAccessKey _T("System\\CurrentControlSet\\Services\\RemoteAccess")
#define RegRtrConfigured   _T("ConfigurationFlags")
#define NTRouterAccountingProvider _T("{1AA7F846-C7F5-11D0-A376-00C04FC9DA04}")
#define NTRouterAuthenticationProvider _T("{1AA7F841-C7F5-11D0-A376-00C04FC9DA04}")
#define RegValueName_RouterActiveAuthenticationProvider _T("ActiveProvider")
#define RegValueName_RouterActiveAccountingProvider _T("ActiveProvider")

//----------------------------------------------------------------------------
// Function:    ConnectRegistry
//
// Connects to the registry on the specified machine
//----------------------------------------------------------------------------

DWORD ConnectRegistry(
    IN  LPCTSTR pszMachine,         // NULL if local
    OUT HKEY*   phkeyMachine
    );



//----------------------------------------------------------------------------
// Function:    DisconnectRegistry
//
// Disconnects the specified config-handle. The handle is assumed to have been
// acquired by calling 'ConnectRegistry'.
//----------------------------------------------------------------------------

VOID DisconnectRegistry(    IN  HKEY    hkeyMachine    );


DWORD ReadRegistryStringValue(LPCTSTR pszMachine, LPCTSTR pszKeyUnderLocalMachine, LPCTSTR pszName, ::CString& strValue);
DWORD ReadRegistryDWORDValue(LPCTSTR pszMachine, LPCTSTR pszKeyUnderLocalMachine, LPCTSTR pszName, DWORD* pdwValue);

BOOL  IsRRASConfigured(LPCTSTR pszMachine);  // when NULL: local machine

//----------------------------------------------------------------------------
//
// helper functions to check if RRAS is using NT Authentication
//
//----------------------------------------------------------------------------

BOOL  IsRRASUsingNTAuthentication(LPCTSTR pszMachine);   // when NULL: local machine

//----------------------------------------------------------------------------
//
// helper function to check if RRAS is using NT accounting for logging
//
//----------------------------------------------------------------------------

BOOL  IsRRASUsingNTAccounting(LPCTSTR pszMachine);    // when NULL, local machine


/////////////////////////////////////////////////////////////////////////////
// CRtrAdviseSinkForIAS
template <class TSnapinNode>
class ATL_NO_VTABLE CRtrAdviseSinkForIAS : 
   public CComObjectRoot,
   public IRtrAdviseSink
{
BEGIN_COM_MAP(CRtrAdviseSinkForIAS)
   COM_INTERFACE_ENTRY(IRtrAdviseSink)
END_COM_MAP()
public:
   CRtrAdviseSinkForIAS() : m_pSnapinNode(NULL){};
   ~CRtrAdviseSinkForIAS()
   {
      ReleaseSink();
   };

   // Need to call ReleaseSink when the snapin node is removed, 
   void ReleaseSink()
   {
      if(m_pSnapinNode)
      {
         IASTracePrintf("UnadviseRefresh, snapinnode: ", (DWORD_PTR)m_pSnapinNode);
         ASSERT(m_spRouterRefresh != NULL);
         m_spRouterRefresh->UnadviseRefresh(m_ulConnection);
         m_spRouterRefresh.Release();
         m_pSnapinNode = NULL;
      };
   };
   
public:  
   STDMETHOD(OnChange)( 
            /* [in] */ LONG_PTR ulConnection,
            /* [in] */ DWORD dwChangeType,
            /* [in] */ DWORD dwObjectType,
            /* [in] */ LPARAM lUserParam,
            /* [in] */ LPARAM lParam)
    {
      if(m_pSnapinNode)
         return m_pSnapinNode->OnRRASChange(ulConnection, dwChangeType, dwObjectType, lUserParam, lParam);
      else
         return S_OK;
    };

   // the object is created within the static function, and 
   static CRtrAdviseSinkForIAS<TSnapinNode>* SetAdvise(TSnapinNode* pSnapinNode, IDataObject* pRRASDataObject)
   {

      if(pSnapinNode == NULL || pRRASDataObject == NULL)
         return NULL;
      // RRAS refresh advise setup F bug 213623: 
      CComPtr<IRouterRefreshAccess>    spRefreshAccess;
      CComPtr<IRouterRefresh>          spRouterRefresh;
      CComObject< CRtrAdviseSinkForIAS<TSnapinNode> >*   pSink = NULL;           
      
      pRRASDataObject->QueryInterface(IID_IRouterRefreshAccess, (void**)&spRefreshAccess);
      
      if(spRefreshAccess != NULL)
         spRefreshAccess->GetRefreshObject(&spRouterRefresh);
         
      if(spRouterRefresh != NULL)
      {
         if(S_OK == CComObject< CRtrAdviseSinkForIAS<TSnapinNode> >::CreateInstance(&pSink))
         {
            ASSERT(pSink);
            pSink->AddRef();
            LONG_PTR ulConnection;

            IASTracePrintf("AdviseRefresh, snapinnode: ", (DWORD_PTR)pSnapinNode);
            spRouterRefresh->AdviseRefresh(pSink, &ulConnection, (LONG_PTR)pSnapinNode);
            pSink->m_ulConnection = ulConnection;
            pSink->m_pSnapinNode = pSnapinNode;
            pSink->m_spRouterRefresh = spRouterRefresh;
         }
      }

      // ~RRAS

      return pSink;
   };

public:
   LONG_PTR          m_ulConnection;
   TSnapinNode*         m_pSnapinNode;
   CComPtr<IRouterRefresh> m_spRouterRefresh;
};

BOOL ExtractComputerAddedAsLocal(LPDATAOBJECT lpDataObject);

//
// Extracts a data type from a data object
//
template <class TYPE>
TYPE* Extract(LPDATAOBJECT lpDataObject, CLIPFORMAT cf, int nSize)
{
    ASSERT(lpDataObject != NULL);

    TYPE* p = NULL;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { cf, NULL, 
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL 
                          };

    int len;

   // Allocate memory for the stream
    if (nSize == -1)
   {
      len = sizeof(TYPE);
   }
   else
   {
      //int len = (cf == CDataObject::m_cfWorkstation) ? 
      //    ((MAX_COMPUTERNAME_LENGTH+1) * sizeof(TYPE)) : sizeof(TYPE);   
      len = nSize;
   }

    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, len);
    
    // Get the workstation name from the data object
    do 
    {
        if (stgmedium.hGlobal == NULL)
            break;

        if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
            break;
        
        p = reinterpret_cast<TYPE*>(stgmedium.hGlobal);

        if (p == NULL)
            break;

    } while (FALSE); 

    return p;
}

#endif // _IAS_MMC_RTRADVISE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\safearray.h ===
/****************************************************************************************
 * NAME:	SafeArray.h
 *
 * CLASS:	CSafeArray
 *
 * OVERVIEW
 *
 * Internet Authentication Server: Utility class for SafeArray
 *
 * Copyright (c) 1998, Microsoft Corporation.  All Rights Reserved.
 *
 * History:	
 *				3/1/98	Created		byao
 *						This file is created according to the online web document:
 *						"Ole Development: Article 5: The Safe OLE Way of Handling Arrays"
 *						by Bruce McKinney,  http://tahiti/oledev/olecome/article5.htm"
 *					
 *				5/14/98	Modified	byao
 *						CSafeArray used 0x80 as a contructed flag in fFeature.
 *						This flag is now used in the official Win32API header file
 *						We get rid of this flag, and added another private member for 
 *						the same purpose
 *
 *
 *****************************************************************************************/
 
#ifndef _SAFEARRAY_H_
#define _SAFEARRAY_H_

// Dim class encapsulates an array dimension
//@B Dim
class Dim : public SAFEARRAYBOUND
{
public:
	Dim(const long iLo, const long iHi)
	{ cElements = abs(iHi - iLo) + 1; lLbound = iLo; }
	Dim(const long c)
	{ cElements = c; lLbound = 0; }
	const Dim & operator=(const Dim & dim) 
	{ cElements = dim.cElements; lLbound = dim.lLbound; return *this; }
	const Dim & operator=(const long c) 
	{ cElements = c; lLbound = 0; return *this; }
	~Dim() {}
	long Elements() { return cElements; }
	long LBound() { return lLbound; }
	long UBound() { return lLbound + cElements - 1; }
};
//@E Dim

// CSafeArray container class for OLE types

//@B CSafeArray1
template<class T, VARTYPE vt> 
class CSafeArray 
{
public:
	// Constructors
	CSafeArray();
	CSafeArray(SAFEARRAY * psaSrc);
	CSafeArray(Dim & dim);
    // Copy constructor
	CSafeArray(const CSafeArray & saSrc);

	// Destructor
	~CSafeArray(); 

	// Operator equal
	const CSafeArray & operator=(const CSafeArray & saSrc);

	// Indexing
	T & Get(long i);
	T & Set(T & t, long i);
	T & operator[](const long i);    // C++ style (0-indexed)
	T & operator()(const long i);    // Basic style (LBound-indexed)
//@E CSafeArray1

	// Type casts
	operator SAFEARRAY(); 
	operator SAFEARRAY() const; 

//	operator Variant(); 
//	operator Variant() const; 

	// Operations
	BOOL ReDim(Dim & dim);
	long LBound();
	long UBound();
	long Elements();
	long Dimensions();
    BOOL IsSizable();
	void Lock();
	void Unlock();

//@B CSafeArray2
private:
	SAFEARRAY * psa;
	BOOL m_fConstructed;  // is this safe array constructed?

    void Destroy();
};
//@E CSafeArray2

// Private helpers

template<class T, VARTYPE vt> 
inline void CSafeArray<T,vt>::Destroy()
{
    m_fConstructed = FALSE;
	HRESULT hres = SafeArrayDestroy(psa);
    if (hres) 
	{
		throw hres;
	}
}

// Constructors
template<class T, VARTYPE vt> 
inline CSafeArray<T,vt>::CSafeArray() 
{ 
    Dim dim(0);
	
	psa	= SafeArrayCreate(vt, 1, &dim); 
    if (psa == NULL) 
	{
		throw E_OUTOFMEMORY;
	}
    m_fConstructed	= TRUE;
}


template<class T, VARTYPE vt> 
inline CSafeArray<T,vt>::CSafeArray(SAFEARRAY * psaSrc) 
{ 
    if (SafeArrayGetDim(psaSrc) != 1) throw E_INVALIDARG;
    
	HRESULT hres	= SafeArrayCopy(psaSrc, &psa);
	if (hres) 
	{
		throw hres;
	}
    m_fConstructed	= TRUE;
}

template<class T, VARTYPE vt> 
inline CSafeArray<T,vt>::CSafeArray(const CSafeArray & saSrc) 
{
    HRESULT hres	= SafeArrayCopy(saSrc.psa, &psa);
    if (hres) 
	{
		throw hres;
	}

    m_fConstructed	= TRUE;
}


template<class T, VARTYPE vt> 
inline CSafeArray<T,vt>::CSafeArray(Dim & dim) 
{
	psa = SafeArrayCreate(vt, 1, &dim); 
    if (psa == NULL) 
	{
		throw E_OUTOFMEMORY;
	}

    m_fConstructed	= TRUE;
} 

// Destructor
template<class T, VARTYPE vt> 
inline CSafeArray<T,vt>::~CSafeArray()
{
	if (m_fConstructed) {
        Destroy();
    }
} 
	
// Operator = 
template<class T, VARTYPE vt> 
const CSafeArray<T,vt> & CSafeArray<T,vt>::operator=(const CSafeArray & saSrc)
{
    if (psa) 
	{
        SafeArrayDestroy(psa);
    }

    HRESULT hres = SafeArrayCopy(saSrc.psa, &psa);
    if (hres) 
	{
		throw hres;
	}
    m_fConstructed = TRUE;
    return *this;
}

// Type casts
template<class T, VARTYPE vt> 
inline CSafeArray<T,vt>::operator SAFEARRAY()
{
    return *psa; 
}

template<class T, VARTYPE vt> 
CSafeArray<T,vt>::operator SAFEARRAY() const
{
    static SAFEARRAY * psaT;
    SafeArrayCopy(psa, &psaT);
    return *psaT;
}

/*
template<class T, VARTYPE vt> 
CSafeArray<T,vt>::operator Variant() 
{
    return Variant(psa);
}

template<class T, VARTYPE vt> 
CSafeArray<T,vt>::operator Variant() const
{
    static Variant v(psa);
    return v;
}
*/

// Indexing
template<class T, VARTYPE vt> 
T & CSafeArray<T,vt>::Get(long i)
{
	static T tRes;
	HRESULT hres = SafeArrayGetElement(psa, &i, &tRes);
	if (hres) throw hres;
	return tRes;
}

//@B Indexing
template<class T, VARTYPE vt> 
inline T & CSafeArray<T,vt>::Set(T & t, long i)
{
	HRESULT hres = SafeArrayPutElement(psa, &i, (T *)&t);
	if (hres) throw hres;
    return t;
}

template<class T, VARTYPE vt> 
inline T & CSafeArray<T,vt>::operator[](const long i)
{
    if (i < 0 || i > Elements() - 1) throw DISP_E_BADINDEX;
	return ((T*)psa->pvData)[i];
}

template<class T, VARTYPE vt> 
T & CSafeArray<T,vt>::operator()(const long i)
{
    if (i < LBound() || i > UBound()) throw DISP_E_BADINDEX;
	return ((T*)psa->pvData)[i - LBound()];
}
//@E Indexing

// Operations
template<class T, VARTYPE vt> 
BOOL CSafeArray<T,vt>::ReDim(Dim &dim)
{
    if (!IsSizable()) {
        return FALSE;
    }
	HRESULT hres = SafeArrayRedim(psa, &dim);
	if (hres) throw hres;
    return TRUE;
}

template<class T, VARTYPE vt> 
long CSafeArray<T,vt>::LBound()
{
	long iRes;
	HRESULT hres = SafeArrayGetLBound(psa, 1, &iRes);
	if (hres) throw hres;
	return iRes;
}

template<class T, VARTYPE vt> 
inline long CSafeArray<T,vt>::Elements()
{
	return psa->rgsabound[0].cElements;
}

template<class T, VARTYPE vt> 
long CSafeArray<T,vt>::UBound()
{
	long iRes;
	HRESULT hres = SafeArrayGetUBound(psa, 1, &iRes);
	if (hres) throw hres;
	return iRes;
}

template<class T, VARTYPE vt> 
inline long CSafeArray<T,vt>::Dimensions()
{
	return 1;
}

template<class T, VARTYPE vt> 
inline BOOL CSafeArray<T,vt>::IsSizable()
{
    return (psa->fFeatures & FADF_FIXEDSIZE) ? FALSE : TRUE;
}

template<class T, VARTYPE vt>
inline void CSafeArray<T,vt>::Lock()
{
	HRESULT hres = SafeArrayLock(psa);
	if (hres) 
	{
		throw hres;
	}
}

template<class T, VARTYPE vt>
inline void CSafeArray<T,vt>::Unlock()
{
	HRESULT hres = SafeArrayUnlock(psa);
	if (hres) 
	{
		throw hres;
	}
}


#endif // _SAFEARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\selcondattr.cpp ===
/****************************************************************************************
 * NAME:	SelCondAttr.h
 *
 * CLASS:	CSelCondAttrDlg
 *
 * OVERVIEW
 *
 * Internet Authentication Server: NAP Rule Editing Dialog
 *			This dialog box is used to display all condition types that users
 *			can choose from when adding a rule
 *
 * Copyright (C) Microsoft Corporation, 1998 - 2001 .  All Rights Reserved.
 *
 * History:
 *				1/28/98		Created by	Byao	(using ATL wizard)
 *
 *****************************************************************************************/
#include "precompiled.h"

#include "TimeOfDay.h"
#include "selcondattr.h"
#include "iasdebug.h"

/////////////////////////////////////////////////////////////////////////////
// CSelCondAttrDlg

CSelCondAttrDlg::CSelCondAttrDlg(CIASAttrList* pAttrList, LONG attrFilter)
				:m_pAttrList(pAttrList), m_filter(attrFilter)
{
	TRACE_FUNCTION("CSelCondAttrDlg::CSelCondAttrDlg");

    //
    // index of the condition attribute that has been selected
    // This value is initialized to -1 == INVALID_VALUE
	//
	// The caller of this dialog box will need to know this index
	// in order to get the correct condition attribute object
	// in pCondAttrList
	//
	m_nSelectedCondAttr = -1;
}


CSelCondAttrDlg::~CSelCondAttrDlg()
{

}


//+---------------------------------------------------------------------------
//
// Function:  OnInitDialog
//
// Class:	  CSelCondAttrDlg
//
// Synopsis:  init the dialog
//
// Arguments: UINT uMsg -
//            WPARAM wParam -
//            LPARAM lParam -
//            BOOL& bHandled -
//
// Returns:   LRESULT -
//
// History:   Created Header    2/16/98 8:44:35 PM
//
//+---------------------------------------------------------------------------
LRESULT CSelCondAttrDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	TRACE_FUNCTION("CSelCondAttrDlg::OnInitDialog");

	m_hWndAttrList = GetDlgItem(IDC_LIST_COND_SELATTR);

	//
	// first, set the list box to 2 columns
	//
	LVCOLUMN lvc;
	int iCol;
	WCHAR  achColumnHeader[256];
	HINSTANCE hInst;

	// initialize the LVCOLUMN structure
	lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvc.fmt = LVCFMT_LEFT;

	lvc.cx = 120;
	lvc.pszText = achColumnHeader;

	// first column header: name
	hInst = _Module.GetModuleInstance();

	::LoadStringW(hInst, IDS_RULE_SELATTR_FIRSTCOLUMN, achColumnHeader, sizeof(achColumnHeader)/sizeof(achColumnHeader[0]));
	lvc.iSubItem = 0;
	ListView_InsertColumn(m_hWndAttrList, 0,  &lvc);

	lvc.cx = 400;
	lvc.pszText = achColumnHeader;

	// second columns: description

	::LoadStringW(hInst, IDS_RULE_SELATTR_SECONDCOLUMN, achColumnHeader, sizeof(achColumnHeader)/sizeof(achColumnHeader[0]));
	lvc.iSubItem = 1;
	ListView_InsertColumn(m_hWndAttrList, 1, &lvc);

	//
	// populate the list control with bogus data
	//
	if (!PopulateCondAttrs())
	{
		ErrorTrace(ERROR_NAPMMC_SELATTRDLG, "PopulateRuleAttrs() failed");
		return 0;

	}


	// Make sure the Add button is not enabled initially.
	// We will enable it when the user selects something.
	::EnableWindow(GetDlgItem(IDC_BUTTON_ADD_CONDITION), FALSE);


	return 1;  // Let the system set the focus
}


//+---------------------------------------------------------------------------
//
// Function:  OnListViewDbclk
//
// Class:	  CSelCondAttrDlg
//
// Synopsis:  handle the case where the user has changed a selection
//			  enable/disable OK, CANCEL button accordingly
//
// Arguments: int idCtrl - ID of the list control
//            LPNMHDR pnmh - notification message
//            BOOL& bHandled - handled or not?
//
// Returns:   LRESULT -
//
// History:   Created Header    byao 2/19/98 11:15:30 PM
//
//+---------------------------------------------------------------------------
LRESULT CSelCondAttrDlg::OnListViewDbclk(int idCtrl,
										 LPNMHDR pnmh,
										 BOOL& bHandled)
{
	TRACE_FUNCTION("CSelCondAttrDlg::OnListViewDbclk");

	return OnOK((WORD)idCtrl, IDC_BUTTON_ADD_CONDITION, m_hWndAttrList, bHandled);  // the same as ok;
}

//+---------------------------------------------------------------------------
//
// Function:  OnOK
//
// Class:	  CSelCondAttrDlg
//
// Synopsis:  The user has clicked OK; We will decide whether we need to
//			  put up another dialogbox depending on whether he has actually
//			  selected a condition type
//
// Arguments: WORD wNotifyCode -
//            WORD wID -
//            HWND hWndCtl -
//            BOOL& bHandled -
//
// Returns:   LRESULT -
//					S_FALSE: failed
//					S_OK:	 succeeded
//
// History:   Created	byao   1/30/98 5:54:55 PM
//
//+---------------------------------------------------------------------------
LRESULT CSelCondAttrDlg::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	TRACE_FUNCTION("CSelCondAttrDlg::OnOK");

	//
    // Has the user chosen any condition type yet?
    //
	LVITEM lvi;

    // Find out what's selected.
	// MAM: This is not what we want here:		int iIndex = ListView_GetSelectionMark(m_hWndAttrList);
	int iIndex = ListView_GetNextItem(m_hWndAttrList, -1, LVNI_SELECTED);
	DebugTrace(DEBUG_NAPMMC_SELATTRDLG, "Selected item: %d", iIndex);

	if (iIndex != -1)
	{
		// The index inside the attribute list is stored as the lParam of this item.

		lvi.iItem		= iIndex;
		lvi.iSubItem	= 0;
		lvi.mask		= LVIF_PARAM;

		ListView_GetItem(m_hWndAttrList, &lvi);

		DebugTrace(DEBUG_NAPMMC_SELATTRDLG, "The actual index in the list is %ld", lvi.lParam);
		m_nSelectedCondAttr = lvi.lParam;


		//
		// Close the condition selection dialog box -- only if something was selected.
		//
		// TRUE will be the return value of the DoModal call on this dialog.
		EndDialog(TRUE);


	}

	// ISSUE: This function wants an LRESULT, not and HRESULT
	// -- not sure of importance of return code here.
	return S_OK;
}


LRESULT CSelCondAttrDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	TRACE_FUNCTION("+NAPMMC+:# CSelCondAttrDlg::OnCancel\n");

	// FALSE will be the return value of the DoModal call on this dialog.
	EndDialog(FALSE);
	return 0;
}


//+---------------------------------------------------------------------------
//
// Function:  PopulateCondAttrs
//
// Class:	  CSelCondAttrDlg
//
// Synopsis:  populate the condition types in the list control
//
// Arguments: None
//
// Returns:   BOOL -
//				TRUE:	if succeed
//				FALSE:	otherwise
//
// History:   Created	byao	1/30/98 3:10:35 PM
//
//+---------------------------------------------------------------------------

BOOL CSelCondAttrDlg::PopulateCondAttrs()
{
	TRACE_FUNCTION("CSelCondAttrDlg::PopulateCondAttrs");

	_ASSERTE( m_pAttrList != NULL );

	int iIndex;
	WCHAR wzText[MAX_PATH];

	LVITEM lvi;

	lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
	lvi.state = 0;
	lvi.stateMask = 0;
	lvi.iSubItem = 0;

	//
	// insert the item
	//
	int jRow = 0;
	for (iIndex=0; iIndex < (int) m_pAttrList->size(); iIndex++)
	{
		lvi.iItem = jRow;

		CComPtr<IIASAttributeInfo> spAttributeInfo = m_pAttrList->GetAt(iIndex);
		_ASSERTE( spAttributeInfo );

		LONG lRestriction;
		spAttributeInfo->get_AttributeRestriction( &lRestriction );

		if ( lRestriction & m_filter )
		{
//			DebugTrace(DEBUG_NAPMMC_SELATTRDLG, "Inserting %ws", (LPCTSTR)m_pAttrList->GetAt(iIndex)->m_pszName);

			// set the item data to the index of this attribute
			// Since only a subset of the attribute can be used in the condition
			// we store the actual index to the attribute list as the item data
			lvi.lParam = iIndex;

			// name
			CComBSTR bstrName;
			spAttributeInfo->get_AttributeName( &bstrName );
			lvi.pszText = bstrName;
			int iRowIndex = ListView_InsertItem(m_hWndAttrList, &lvi);

			if(iRowIndex != -1)
			{
				// description
				CComBSTR bstrDescription;
				spAttributeInfo->get_AttributeDescription( &bstrDescription );
				ListView_SetItemText(m_hWndAttrList, iRowIndex, 1, bstrDescription);
			}
			jRow++; // go to the next Row
		}
	}

	return TRUE;
}


//+---------------------------------------------------------------------------
//
// Function:  OnListViewItemChanged
//
// Class:	  CSelCondAttrDlg
//
// Synopsis:  handle the case where the user has changed a selection
//			  enable/disable OK, CANCEL button accordingly
//
// Arguments: int idCtrl - ID of the list control
//            LPNMHDR pnmh - notification message
//            BOOL& bHandled - handled or not?
//
// Returns:   LRESULT -
//
// History:   Created Header    byao 2/19/98 11:15:30 PM
//
//+---------------------------------------------------------------------------
LRESULT CSelCondAttrDlg::OnListViewItemChanged(int idCtrl,
											   LPNMHDR pnmh,
											   BOOL& bHandled)
{
	TRACE_FUNCTION("CSelCondAttrDlg::OnListViewItemChanged");

    // Find out what's selected.
	// MAM: This is not what we want here:	int iCurSel = ListView_GetSelectionMark(m_hWndAttrList);
	int iCurSel = ListView_GetNextItem(m_hWndAttrList, -1, LVNI_SELECTED);


	if (-1 == iCurSel)
	{
		// The user selected nothing, let's disable the ok button.
		::EnableWindow(GetDlgItem(IDC_BUTTON_ADD_CONDITION), FALSE);
	}
	else
	{
		// Yes, enable the ok button.
		::EnableWindow(GetDlgItem(IDC_BUTTON_ADD_CONDITION), TRUE);
	}

	bHandled = FALSE;
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\textmap.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    textmap.h
//
// SYNOPSIS
//
//    This file declares functions for converting Time of Day restriction
//    hour maps to and from a textual representation.
//
// MODIFICATION HISTORY
//
//    02/05/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _TEXTMAP_H_
#define _TEXTMAP_H_

#ifdef __cplusplus
extern "C" {
#endif

#define IAS_HOUR_MAP_LENGTH (21)

DWORD
WINAPI
IASHourMapFromText(
    IN PCWSTR szText,
    OUT PBYTE pHourMap
    );

DWORD
WINAPI
LocalizeTimeOfDayConditionText(
    IN PCWSTR szText,
    OUT ::CString& newString
    );

#ifdef __cplusplus
}
#endif
#endif  // _TEXTMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\selcondattr.h ===
/****************************************************************************************
 * NAME:	SelCondAttrDlg.h
 *
 * CLASS:	CSelCondAttrDlg
 *
 * OVERVIEW
 *
 * Internet Authentication Server: NAP Rule Editing Dialog
 *			This dialog box is used to display all condition types that users 
 *			can choose from when adding a rule
 *
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History:	
 *				1/28/98		Created by	Byao	(using ATL wizard)
 *
 *****************************************************************************************/

#ifndef __RULESELATTRDIALOG_H_
#define __RULESELATTRDIALOG_H_

#include "dialog.h"
#include "IASAttrList.h"

/////////////////////////////////////////////////////////////////////////////
// CSelCondAttrDlg
class CSelCondAttrDlg;
typedef CIASDialog<CSelCondAttrDlg, FALSE>  SELECT_CONDITION_ATTRIBUTE_FALSE;


class CSelCondAttrDlg : public CIASDialog<CSelCondAttrDlg, FALSE>
{
public:
	CSelCondAttrDlg(CIASAttrList *pAttrList, LONG attrFilter = ALLOWEDINCONDITION);
	~CSelCondAttrDlg();

	enum { IDD = IDD_COND_SELECT_ATTRIBUTE };
	
BEGIN_MSG_MAP(CSelCondAttrDlg)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDC_BUTTON_ADD_CONDITION, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnListViewItemChanged)
	NOTIFY_CODE_HANDLER(NM_DBLCLK, OnListViewDbclk)
	CHAIN_MSG_MAP(SELECT_CONDITION_ATTRIBUTE_FALSE)
END_MSG_MAP()


	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnListViewItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
	LRESULT OnListViewDbclk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

public:
	//
	// the following public members will be accessed from outside
	// this dialog box
	//
	int m_nSelectedCondAttr;

protected:
	BOOL PopulateCondAttrs();
	CIASAttrList *m_pAttrList;
   LONG m_filter;

private:
	HWND m_hWndAttrList;
};

#endif //__RULESELECTATTRIBUTE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\textsid.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    textsid.c
//
// SYNOPSIS
//
//    This file defines functions for converting Security Indentifiers (SIDs)
//    to and from a textual representation.
//
// MODIFICATION HISTORY
//
//    01/18/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#define IAS_LEAN_AND_MEAN

#include "precompiled.h"
#include <ias.h>
#include <stdio.h>
#include "textsid.h"

DWORD
WINAPI
IASSidToTextW( 
    IN PSID pSid,
    OUT PWSTR szTextualSid,
    IN OUT PDWORD pdwBufferLen
    )
{ 
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;

    // Ensure input parameters are valid.
    if ((szTextualSid == NULL && pdwBufferLen != 0) || !IsValidSid(pSid))
    {
       return ERROR_INVALID_PARAMETER;
    }

    // obtain SidIdentifierAuthority
    psia=GetSidIdentifierAuthority(pSid);

    // obtain SidSubSuthority count
    dwSubAuthorities=*GetSidSubAuthorityCount(pSid);

    //////////
    // compute buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //////////
    dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1);

    //////////
    // check provided buffer length.
    // If not large enough, indicate proper size and return error.
    //////////
    if (*pdwBufferLen < dwSidSize)
    {
        *pdwBufferLen = dwSidSize;

        return ERROR_INSUFFICIENT_BUFFER;
    }

    ////////// 
    // prepare S-SID_REVISION-
    ////////// 
    dwSidSize=swprintf(szTextualSid, L"S-%lu-", dwSidRev );

    //////////
    // prepare SidIdentifierAuthority
    //////////
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        dwSidSize+=swprintf(szTextualSid + lstrlenW(szTextualSid),
                            L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                            (USHORT)psia->Value[0],
                            (USHORT)psia->Value[1],
                            (USHORT)psia->Value[2],
                            (USHORT)psia->Value[3],
                            (USHORT)psia->Value[4],
                            (USHORT)psia->Value[5]);
    }
    else
    {
        dwSidSize+=swprintf(szTextualSid + wcslen(szTextualSid),
                            L"%lu",
                            (ULONG)(psia->Value[5]      ) +
                            (ULONG)(psia->Value[4] <<  8) +
                            (ULONG)(psia->Value[3] << 16) +
                            (ULONG)(psia->Value[2] << 24) );
    }

    //////////
    // loop through SidSubAuthorities
    //////////
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        dwSidSize+=swprintf(szTextualSid + dwSidSize,
                            L"-%lu",
                            *GetSidSubAuthority(pSid, dwCounter));
    }

    return NO_ERROR;
} 


DWORD
WINAPI
IASSidFromTextW(
    IN PCWSTR szTextualSid,
    OUT PSID *pSid
    )
{
   DWORDLONG rawsia;
   DWORD revision;
   DWORD subAuth[8];
   SID_IDENTIFIER_AUTHORITY sia;
   int fields;

   if (szTextualSid == NULL || pSid == NULL)
   {
      return ERROR_INVALID_PARAMETER;
   }

   ////////// 
   // Scan the input string.
   ////////// 
   fields = swscanf(szTextualSid,
                    L"S-%lu-%I64u-%lu-%lu-%lu-%lu-%lu-%lu-%lu-%lu",
                    &revision,
                    &rawsia,
                    subAuth,
                    subAuth + 1,
                    subAuth + 2,
                    subAuth + 3,
                    subAuth + 4,
                    subAuth + 5,
                    subAuth + 6,
                    subAuth + 7);

   ////////// 
   // We must have at least three fields (revision, identifier authority, and
   // at least one sub authority), the current revision, and a 48-bit SIA.
   ////////// 
   if (fields < 3 || revision != SID_REVISION || rawsia > 0xffffffffffffI64)
   {
      return ERROR_INVALID_PARAMETER;
   }

   ////////// 
   // Pack the SID_IDENTIFIER_AUTHORITY.
   ////////// 
   sia.Value[0] = (UCHAR)((rawsia >> 40) & 0xff);
   sia.Value[1] = (UCHAR)((rawsia >> 32) & 0xff);
   sia.Value[2] = (UCHAR)((rawsia >> 24) & 0xff);
   sia.Value[3] = (UCHAR)((rawsia >> 16) & 0xff);
   sia.Value[4] = (UCHAR)((rawsia >>  8) & 0xff);
   sia.Value[5] = (UCHAR)((rawsia      ) & 0xff);

   ////////// 
   // Allocate the SID. Must be freed through FreeSid().
   ////////// 
   if (!AllocateAndInitializeSid(&sia,
                                 (BYTE)(fields - 2),
                                 subAuth[0],
                                 subAuth[1],
                                 subAuth[2],
                                 subAuth[3],
                                 subAuth[4],
                                 subAuth[5],
                                 subAuth[6],
                                 subAuth[7],
                                 pSid))
   {
      return GetLastError();
   }

   return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\textsid.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    textsid.h
//
// SYNOPSIS
//
//    This file declares functions for converting Security Indentifiers (SIDs)
//    to and from a textual representation.
//
// MODIFICATION HISTORY
//
//    01/18/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _TEXTSID_H_
#define _TEXTSID_H_

#ifdef __cplusplus
extern "C" {
#endif

DWORD
WINAPI
IASSidToTextW( 
    IN PSID pSid,
    OUT PWSTR szTextualSid,
    IN OUT PDWORD pdwBufferLen
    );

DWORD
WINAPI
IASSidFromTextW(
    IN PCWSTR szTextualSid,
    OUT PSID *pSid
    );

#ifdef __cplusplus
}
#endif
#endif  // _TEXTSID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\textmap.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    textmap.cpp
//
// SYNOPSIS
//
//    This file defines functions for converting Time of Day restriction
//    hour maps to and from a textual representation.
//
// MODIFICATION HISTORY
//
//    02/05/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include "precompiled.h"
#include <ias.h>
#include "Parser.h"
#include "textmap.h"

//////////
// Definition of whitespace.
//////////
#define WSP L" "

//////////
// Valid delimiters for days.
//////////
#define DELIM L",;|"

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    TimeOfDayParser
//
// DESCRIPTION
//
//    This class extends Parser to extract hour maps from a string.
//
///////////////////////////////////////////////////////////////////////////////
class TimeOfDayParser : public Parser
{
public:

   TimeOfDayParser(PWSTR source) throw ()
      : Parser(source) { }

   // Extract time of day in the format hh:mm.
   void extractTime(ULONG* hour, ULONG* minute) throw (ParseError)
   {
      *hour = extractUnsignedLong();
      skip(WSP);

      // Minutes are optional.
      if (*current == L':')
      {
         ++current;

         *minute = extractUnsignedLong();
      }
      else
      {
         *minute = 0;
      }

      if (*hour > 24 || *minute > 59 || (*hour == 24 && *minute != 0))
      {
         throw ParseError();
      }
   }

   // Extracts a single day's hour map.
   void extractDay(PBYTE hourMap) throw (ParseError)
   {
      // Get the day of week (an integer from 0-6).
      ULONG dayOfWeek = extractUnsignedLong();
      skip(WSP);

      if (dayOfWeek > 6) { throw ParseError(); }
      
      do
      {
         // Get the start time of the range.
         ULONG startHour, startMinute;
         extractTime(&startHour, &startMinute);
         skip(WSP);

         ignore(L'-');

         // Get the end time of the range.
         ULONG endHour, endMinute;
         extractTime(&endHour, &endMinute);
         skip(WSP);

         // Make sure the values are legit.
         if (startHour * 60 + startMinute > endHour * 60 + endMinute)
         {
            throw ParseError();
         }

         // Set all bits in the range.
         for (size_t i=startHour; i<endHour; ++i)
         {
            hourMap[dayOfWeek * 3 + i / 8] |= 0x80 >> (i % 8);
         }

      } while (more());
   }
};


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASTextToHourMap
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASHourMapFromText(
    IN PCWSTR szText,
    OUT PBYTE pHourMap
    )
{
   if (szText == NULL || pHourMap == NULL)
   {
      return ERROR_INVALID_PARAMETER;
   }

   memset(pHourMap, 0, IAS_HOUR_MAP_LENGTH);

   ////////// 
   // Make a local copy so we can modify the text.
   ////////// 

   PWSTR copy = (PWSTR)_alloca((wcslen(szText) + 1) * sizeof(WCHAR));

   wcscpy(copy, szText);

   ////////// 
   // Parse the text.
   ////////// 

   try
   {
      // Each day should be separated by a comma or semicolon.
      PWSTR token = wcstok(copy, DELIM);

      while (token)
      {
         TimeOfDayParser parser(token);

         parser.extractDay(pHourMap);

         token = wcstok(NULL, DELIM);
      }
   }
   catch (Parser::ParseError)
   {
      return ERROR_INVALID_DATA;
   }

   return NO_ERROR;
}

static UINT	daysOfWeekLCType[7] = {LOCALE_SABBREVDAYNAME7, LOCALE_SABBREVDAYNAME1 , LOCALE_SABBREVDAYNAME2 , LOCALE_SABBREVDAYNAME3 , LOCALE_SABBREVDAYNAME4 ,
				LOCALE_SABBREVDAYNAME5 , LOCALE_SABBREVDAYNAME6 };

DWORD
WINAPI
LocalizeTimeOfDayConditionText(
    IN PCWSTR szText,
    OUT ::CString& newString
    )
{

   if (szText == NULL)
   {
      return ERROR_INVALID_PARAMETER;
   }


	newString.Empty();
	
   ////////// 
   // Make a local copy so we can modify the text.
   ////////// 

   PWSTR copy = (PWSTR)_alloca((wcslen(szText) + 1) * sizeof(WCHAR));

   wcscpy(copy, szText);

   ////////// 
   // Parse the text.
   ////////// 

   try
   {
      // Each day should be separated by a comma or semicolon.
      PWSTR token = copy;
      PWSTR	copyHead = copy;
      TCHAR	tempName[MAX_PATH];
      

      while (*token)
      {
		// find the day of week from token
		while(*token != 0 && (*token < L'0' || *token > L'6'))
			token++;

		if(*token >= L'0' && *token <= L'6' &&  0 != GetLocaleInfo(LOCALE_USER_DEFAULT, daysOfWeekLCType[(*token - L'0')], tempName, MAX_PATH - 1))
		{
			// write the string before the day of week
			if(token > copyHead)
			{
				*token = 0;
				newString += copyHead;		
			}

			// write localized string
			newString += tempName;

			// next copy should from here
			copyHead = ++token;
		}

		// find the head of next day
        while (*token != 0 && *token != L';' && *token != L',' && *token != L'|')
        	token ++;
      }

      // copy the rest to the string
		newString += copyHead;		
		
   }
   catch (Parser::ParseError)
   {
      return ERROR_INVALID_DATA;
   }

   return NO_ERROR;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\timeofday.h ===
/****************************************************************************************
 * NAME:	TimeOfDay.h
 *
 * OVERVIEW
 *
 * Header file for getting the Time of Day constraint
 *  
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History:	
 *				2/14/98		Created by	Byao	
 *
 *****************************************************************************************/

#ifndef _INCLUDE_TIMEOFDAY_
#define _INCLUDE_TIMEOFDAY_

#include "atltmp.h"


HRESULT GetTODConstaint(ATL::CString &strHourMap);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\timeofday.cpp ===
/****************************************************************************************
 * NAME:	TimeOfDay.cpp
 *
 * OVERVIEW
 *
 * APIs for getting the Time of Day constraint
 *  
 * Copyright (C) Microsoft Corporation, 1998 - 1999 .  All Rights Reserved.
 *
 * History:	
 *				2/14/98		Created by	Byao	
 *
 *****************************************************************************************/
#include "precompiled.h"


//
// declarations for IAS mapping APIs
//
#include "textmap.h"

//
// declaration for the API
#include "TimeOfDay.h"
#include "iasdebug.h"

static BYTE		bitSetting[8] = { 0x80, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x1};

//+---------------------------------------------------------------------------
//
// Function:  ReverseHourMap
//
// Synopsis:  reverse each byte in the hour map
//				
// we have to do this because LogonUI changes the way HourMap is stored(they
// reversed all the bit. We need to do this so our conversion code can leave
// intact.
//
// Arguments: [in] BYTE* map - hour map
//			  [in] INT nByte - how many bytes are in this hour map	
//			  
// History:   byao	4/10/98 10:33:57 PM
//
//+---------------------------------------------------------------------------
void ReverseHourMap(BYTE *map, int nByte)
{
	int i, j;
	BYTE temp;

	for (i=0; i<nByte; i++)
	{
		temp = 0;
		for (j=0;j<8;j++)
		{
			// set the value temp
			if ( map[i] & bitSetting[j] )
			{
				temp |= bitSetting[7-j];
			}
		}
		map[i] = temp;
	}
}

//+---------------------------------------------------------------------------
//
// Function:  HourMapToStr
//
// Synopsis:  convert the 21-byte hour map to a text string in the following
//			  format: 
//				0 8:30-9:30 10:30-15:30; 2 10:00-14:00
//				
//
// Arguments: [in]	BYTE* map - hour map
//			  [out] ATL::CString& strHourMap  - hour map in string format
//
// History:   Created Header		byao	2/14/98 10:33:57 PM
//
//+---------------------------------------------------------------------------
void HourMapToStr(BYTE* map, ATL::CString& strHourMap) 
{
	int			sh, eh;	// start hour, (min), end hour (min)
	BYTE*		pHourMap;
	int			i, j;

	//
	// todo: change to a safer allocation method
	//
	WCHAR		wzTmpStr[128] = L"";
	WCHAR		wzStr[2048] = L"";
	WCHAR		wzHourStr[8192] = L"";

	BOOL		bFirstDay=TRUE;

	pHourMap = map;
	
	for( i = 0; i < 7; i++)	// for each day
	{
		// if any value for this day
		if(*pHourMap || *(pHourMap + 1) || *(pHourMap + 2))
		{
			// the string for this day
				if (bFirstDay) 
				{
					wsprintf(wzTmpStr, _T("%1d"), i);	
					bFirstDay = FALSE;
				}
				else
				{
					wsprintf(wzTmpStr, _T("; %1d"), i);	
				}
				wcscpy(wzStr, wzTmpStr);

				sh = -1; eh = -1;	// not start yet
				for(j = 0; j < 24; j++)	// for every hour
				{
					int	k = j / 8;
					int m = j % 8;
					if(*(pHourMap + k) & bitSetting[m])	// this hour is on
					{
						if(sh == -1)	sh = j;			// set start hour is empty
						eh = j;							// extend end hour
					}
					else	// this is not on
					{
						if(sh != -1)		// some hours need to write out
						{
							wsprintf(wzTmpStr,_T(" %02d:00-%02d:00"), sh, eh + 1);
							wcscat(wzStr, wzTmpStr);
							sh = -1; eh = -1;
						}
					}
				}
				if(sh != -1)
				{
					wsprintf(wzTmpStr, _T(" %02d:00-%02d:00"), sh, eh + 1);
					wcscat(wzStr, wzTmpStr);
					sh = -1; eh = -1;
				}
		
				wcscat(wzHourStr, wzStr);
		}
		pHourMap += 3;
	}

    strHourMap = wzHourStr;

	return;
}		


//+---------------------------------------------------------------------------
//
// Function:  GetTODConstaint
//
// Synopsis:  Get the time of day constraint
//			  This is implemented by calling an API in NT team
//			  LogonScheduleDialog(...);
//
// Arguments: [in/out] ATL::CString &strHourMap - TOD constraint in text format
//
// Returns:   HRESULT - 
//
// History:   Created Header    byao 2/14/98 10:36:27 PM
//
//+---------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFN_LOGONSCHEDULEDIALOGEX)(
						  HWND hwndParent		// parent window
						, BYTE ** pprgbData		// pointer to pointer to array of 21 bytes
						, LPCTSTR pszTitle		// dialog title
						, DWORD dwFlags			// in what format to accept the time
						);

HRESULT GetTODConstaint( ATL::CString &strHourMap )
{
	TRACE_FUNCTION("::GetTODConstraint");

	BYTE	TimeOfDayHoursMap[21];
	BYTE*	pMap = &(TimeOfDayHoursMap[0]);
	ATL::CString strDialogTitle;
	DWORD	dwRet;
	HRESULT hr	= S_OK;
	PFN_LOGONSCHEDULEDIALOGEX  pfnLogonScheduleDialogEx = NULL; 
	HMODULE					 hLogonScheduleDLL		= NULL;

	ZeroMemory(TimeOfDayHoursMap, 21);

    // 
    // convert the TOD constraint string to HourMap
    // 
	dwRet = IASHourMapFromText(strHourMap, pMap);
   
	if (NO_ERROR != dwRet)
		goto win32_error;

	// ReverseHourMap() will reverse each byte of the hour map, basically
 	// reverse every bit in the byte.
	// we have to do this because LogonUI changes the way HourMap is stored(they
	// reversed all the bit. We need to do this so our conversion code can leave
	// intact.
	//
	// We reverse it here so it can be understood by the LogonSchedule api
	//
	ReverseHourMap(pMap,21);

    // 
    // get the new TOD Constaint
    // 
	if (!strDialogTitle.LoadString(IDS_TOD_DIALOG_TITLE))
		goto win32_error;

	hLogonScheduleDLL = LoadLibrary(_T("loghours.dll"));
	if ( NULL == hLogonScheduleDLL )
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		ErrorTrace(ERROR_NAPMMC_TIMEOFDAY, "LoadLibrary() failed, err = %x", hr);

		ShowErrorDialog(NULL, IDS_ERROR_CANT_FIND_LOGHOURSDLL, NULL, hr);
		goto win32_error;
	}
	
	pfnLogonScheduleDialogEx = (PFN_LOGONSCHEDULEDIALOGEX) GetProcAddress(hLogonScheduleDLL, "DialinHoursDialogEx");
	if ( ! pfnLogonScheduleDialogEx )
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		ErrorTrace(ERROR_NAPMMC_TIMEOFDAY, "GetProcAddress() failed for DialinHoursDialogEx, err = %x", hr);

		ShowErrorDialog(NULL, IDS_ERROR_CANT_FIND_LOGHOURSAPI, NULL, hr);
		FreeLibrary(hLogonScheduleDLL);
		goto win32_error;
	}
	
	//
	// now we do have this DLL, call the API
	//
	hr = pfnLogonScheduleDialogEx(	  NULL		// We don't have an HWND available to pass, but NULL asks the dialog to display itself modally as desired.
									, (BYTE**)&pMap
									, strDialogTitle
									, 1		// This is defined in loghrapi.h (which we don't have access to) to mean "accept in local time".
									);
	FreeLibrary(hLogonScheduleDLL);
	DebugTrace(DEBUG_NAPMMC_TIMEOFDAY, "LogonScheduleDialogEx() returned %x", hr);

	if ( FAILED(hr) )
	{
		goto win32_error;
	}

    // 
    // convert the hourmap to a text string
    // 
	// We need to reverse it first so our conversion code can understand it.
	//
	ReverseHourMap(pMap,21);
	HourMapToStr(pMap, strHourMap) ;

	return S_OK;

win32_error:
	ShowErrorDialog(NULL,
					IDS_ERROR_TIMEOFDAY, 
					NULL, 
					HRESULT_FROM_WIN32(GetLastError())
				);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\tregkey.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1999 **/
/**********************************************************************/

/*
    FILE HISTORY:
        
*/

#include <precompiled.h>

#include <stdlib.h>
#include <memory.h>
#include <ctype.h>

//#include "tfschar.h"
#include "tregkey.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//  Convert a CStringList to the REG_MULTI_SZ format
DWORD StrList2MULTI_SZ(CStringList & strList, DWORD * pcbSize, BYTE ** ppbData)
{
    DWORD dwErr = 0 ;

    POSITION pos ;
    CString * pstr ;
    int cbTotal = 0 ;

    //  Walk the list accumulating sizes
    for ( pos = strList.GetHeadPosition() ;
          pos != NULL && (pstr = & strList.GetNext( pos )) ; ) 
    {
        cbTotal += pstr->GetLength() + 1 ;
    }

	// Add on space for two NULL characters
	cbTotal += 2;

    //  Allocate and fill a temporary buffer
    if (*pcbSize = (cbTotal * sizeof(TCHAR) ) )
    {
        TRY
        {
            *ppbData = new BYTE[ *pcbSize] ;

			// NULL out the data buffer
			::ZeroMemory(*ppbData, *pcbSize);

            BYTE * pbData = *ppbData ;

            //  Populate the buffer with the strings.
            for ( pos = strList.GetHeadPosition() ;
                pos != NULL && (pstr = & strList.GetNext( pos )) ; ) 
            {
                int cb = (pstr->GetLength() + 1) * sizeof(TCHAR) ;
                ::memcpy( pbData, (LPCTSTR) *pstr, cb ) ;
                pbData += cb ;
            }

			// Assert that we have not passed the end of the buffer
			_ASSERTE((pbData - *ppbData) < (int) *pcbSize);

			// Assert that we have an extra NULL character
			_ASSERTE(*((TCHAR *)pbData) == 0);
        }
        CATCH_ALL(e)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    else
    {
        *ppbData = NULL;
    }

    return dwErr ;
}

//  Convert a REG_MULTI_SZ format to the CStringList 
DWORD MULTI_SZ2StrList(LPCTSTR pstrMulti_Sz, CStringList& strList)
{
	DWORD	dwErr = NOERROR;

	strList.RemoveAll();
	
        //  Catch exceptions trying to build the list
    TRY
    {
        if (pstrMulti_Sz)
        {
            while ( lstrlen(pstrMulti_Sz) )
            {
                strList.AddTail( pstrMulti_Sz ) ;
                pstrMulti_Sz += lstrlen( pstrMulti_Sz ) + 1 ;
            }
        }
    }
    CATCH_ALL(e)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY ;
    }
    END_CATCH_ALL

	return dwErr;
}


/*!--------------------------------------------------------------------------
	RegKey::RegKey
		Constructor
	Author: KennT
 ---------------------------------------------------------------------------*/
RegKey::RegKey()
	: m_hKey(0)
{
}


/*!--------------------------------------------------------------------------
	RegKey::~RegKey
		Destructor
	Author: KennT
 ---------------------------------------------------------------------------*/
RegKey::~RegKey ()
{
	Close();
}

/*!--------------------------------------------------------------------------
	RegKey::Open
		
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD RegKey::Open( HKEY hKeyParent,
					LPCTSTR pszSubKey,
					REGSAM regSam,
					LPCTSTR pszServerName)
{
    HKEY	hkBase = NULL ;
	DWORD	dwErr = 0;

	Close();

	// If we have a server name, try to open a remote connection
    if ( pszServerName ) 
		dwErr = ::RegConnectRegistry((LPTSTR) pszServerName, hKeyParent, &hkBase);
    else
        hkBase = hKeyParent ;

    if ( dwErr == 0 ) 
    {
        if ( pszSubKey )
		{
            dwErr = ::RegOpenKeyEx( hkBase, pszSubKey, 0, regSam, & m_hKey ) ;
		}
        else
        {
            m_hKey = hkBase ;
            hkBase = NULL ;	// set to NULL so that the key doesn't get closed
        }

        if ( hkBase && (hkBase != hKeyParent) )
            ::RegCloseKey( hkBase ) ;
    }
    
    if ( dwErr ) 
        m_hKey = NULL ;

	return dwErr;
}


/*!--------------------------------------------------------------------------
	RegKey::Create
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD RegKey::Create(
					 HKEY hKeyBase, 
					 LPCTSTR pszSubKey,
					 DWORD dwOptions,
					 REGSAM regSam,
					 LPSECURITY_ATTRIBUTES pSecAttr,
					 LPCTSTR pszServerName )
{
    HKEY	hkBase = NULL ;
    LONG	dwErr = 0;
	DWORD	dwDisposition;

	Close();
    
    if ( pszServerName ) 
    {
        // This is a remote connection.
        dwErr = ::RegConnectRegistry( (LPTSTR) pszServerName, hKeyBase, &hkBase );
    }
    else
        hkBase = hKeyBase ;

    if (dwErr == 0)
    {
        LPTSTR szEmpty = _T("");

        dwErr = ::RegCreateKeyEx( hkBase, pszSubKey, 
								  0, szEmpty, 
								  dwOptions, regSam,  pSecAttr,
								  & m_hKey, 
								  & dwDisposition ) ;

        if ( hkBase && (hkBase != hKeyBase) )
            ::RegCloseKey( hkBase ) ;
    }
	
    if ( dwErr )
        m_hKey = NULL ;

	return dwErr;
}

/*!--------------------------------------------------------------------------
	RegKey::Close
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD RegKey::Close()
{
	DWORD	dwErr = 0;
	if (m_hKey)
		dwErr = ::RegCloseKey(m_hKey);
	m_hKey = 0;
	return dwErr;
}


/*!--------------------------------------------------------------------------
	RegKey::Detach
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HKEY RegKey::Detach()
{
	HKEY hKey = m_hKey;
	m_hKey = NULL;
	return hKey;
}

/*!--------------------------------------------------------------------------
	RegKey::Attach
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void RegKey::Attach(HKEY hKey)
{
	_ASSERTE(m_hKey == NULL);
	m_hKey = hKey;
}


/*!--------------------------------------------------------------------------
	RegKey::DeleteSubKey
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD RegKey::DeleteSubKey(LPCTSTR lpszSubKey)
{
	_ASSERTE(m_hKey != NULL);
	return RegDeleteKey(m_hKey, lpszSubKey);
}

/*!--------------------------------------------------------------------------
	RegKey::DeleteValue
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD RegKey::DeleteValue(LPCTSTR lpszValue)
{
	_ASSERTE(m_hKey != NULL);
	return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
}


/*!--------------------------------------------------------------------------
	RegKey::RecurseDeleteKey
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD RegKey::RecurseDeleteKey(LPCTSTR lpszKey)
{
 	RegKey	key;
	DWORD	dwRes = key.Open(m_hKey, lpszKey, KEY_READ | KEY_WRITE);
	if (dwRes != ERROR_SUCCESS)
		return dwRes;
	
	FILETIME time;
	TCHAR szBuffer[256];
	DWORD dwSize = 256;
	
	while (RegEnumKeyEx(key, 0, szBuffer, &dwSize, NULL, NULL, NULL,
						&time)==ERROR_SUCCESS)
	{
		dwRes = key.RecurseDeleteKey(szBuffer);
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
		dwSize = 256;
	}
	key.Close();
	return DeleteSubKey(lpszKey);
}


/*!--------------------------------------------------------------------------
	RegKey::RecurseDeleteSubKeys
		Deletes the subkeys of the current key.
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD RegKey::RecurseDeleteSubKeys()
{
	FILETIME time;
	TCHAR szBuffer[256];
	DWORD dwSize = 256;
    DWORD   dwRes;

	while (RegEnumKeyEx(m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
						&time)==ERROR_SUCCESS)
	{
        dwRes = RecurseDeleteKey(szBuffer);
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
		dwSize = 256;
	}
    return ERROR_SUCCESS;
}


/*!--------------------------------------------------------------------------
	RegKey::PrepareValue
		Prepare to read a value by finding the value's size.  This will
		allocate space for the data.  The data needs to be freed separately
		by 'delete'.
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD RegKey::PrepareValue( LPCTSTR pszValueName, 
							DWORD * pdwType,
							DWORD * pcbSize,
							BYTE ** ppbData )
{
	DWORD	dwErr = 0;
    
    BYTE chDummy[2] ;
    DWORD cbData = 0 ;

    do
    {
        //  Set the resulting buffer size to 0.
        *pcbSize = 0 ;
        *ppbData = NULL ;

        dwErr = ::RegQueryValueEx( m_hKey, 
								 pszValueName, 
								 0, pdwType, 
								 chDummy, & cbData ) ;

        //  The only error we should get here is ERROR_MORE_DATA, but
        //  we may get no error if the value has no data.
        if ( dwErr == 0 ) 
        {
            cbData = sizeof (LONG) ;  //  Just a fudgy number
        }
        else
            if ( dwErr != ERROR_MORE_DATA ) 
                break ;

        //  Allocate a buffer large enough for the data.

        *ppbData = new BYTE [ (*pcbSize = cbData) + sizeof (LONG) ] ;
		_ASSERTE(*ppbData);

        //  Now that have a buffer, re-fetch the value.

        dwErr = ::RegQueryValueEx( m_hKey, 
								   pszValueName, 
								   0, pdwType, 
								   *ppbData, &cbData ) ;

    } while ( FALSE ) ;

    if ( dwErr ) 
    {
        delete [] *ppbData ;
		*ppbData = NULL;
		*pcbSize = 0;
    }

    return dwErr ;
}


DWORD RegKey::QueryTypeAndSize(LPCTSTR pszValueName, DWORD *pdwType, DWORD *pdwSize)
{
	return ::RegQueryValueEx(m_hKey, pszValueName, NULL, pdwType,
							  NULL, pdwSize);
}

DWORD RegKey::QueryValueExplicit(LPCTSTR pszValueName,
								 DWORD *pdwType,
								 DWORD *pdwSize,
								 LPBYTE *ppbData)
{
	DWORD	dwErr = 0;
	DWORD	dwType;
	DWORD	cbData;
	BYTE *	pbData = NULL;
	
	_ASSERTE(pdwType);
	_ASSERTE(pdwSize);
	_ASSERTE(ppbData);

	dwErr = PrepareValue( pszValueName, &dwType, &cbData, &pbData );
	if (dwErr == ERROR_SUCCESS)
	{
		if (dwType != REG_MULTI_SZ)
		{
			dwErr = ERROR_INVALID_PARAMETER;
		}
		else
		{
			*pdwType = dwType;
			*pdwSize = cbData;
			*ppbData = pbData;
			pbData = NULL;
		}
	}
	delete pbData;
	
	return dwErr;
}

//  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
//  if data exists but not in correct form to deliver into result object.

DWORD RegKey::QueryValue( LPCTSTR pszValueName, CString& strResult )
{
	DWORD	dwErr = 0;
    
    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( dwErr = PrepareValue( pszValueName, &dwType, &cbData, &pabData ) )
            break ;
   
        if (( dwType != REG_SZ ) && (dwType != REG_EXPAND_SZ))
        {
            dwErr = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Guarantee that the data looks like a string
        pabData[cbData] = 0 ;

        //  Catch exceptions trying to assign to the caller's string
        TRY
        {
            strResult = (LPCTSTR) pabData ;
        }
        CATCH_ALL(e)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    } 
    while ( FALSE ) ;

	delete [] pabData ;

    return dwErr ; 
}


DWORD RegKey::QueryValue ( LPCTSTR pchValueName, CStringList & strList ) 
{
    DWORD dwErr = 0 ;
    
    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;
    LPTSTR pbTemp, pbTempLimit;

    do
    {
        if ( dwErr = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;
   
        if ( dwType != REG_MULTI_SZ ) 
        {
            dwErr = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Guarantee that the trailing data looks like a string
        pabData[cbData] = 0 ;
        pbTemp = (LPTSTR) pabData ;
        pbTempLimit = & pbTemp[MaxCchFromCb(cbData)-1] ;

        dwErr = MULTI_SZ2StrList(pbTemp, strList);

    } 
    while ( FALSE ) ;

    delete [] pabData ;

    return dwErr ; 
}

/*!--------------------------------------------------------------------------
	RegKey::QueryValue
		Gets the DWORD value for this key. Returns ERROR_INVALID_PARAMETER
		if the value is not a REG_DWORD.
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD RegKey::QueryValue( LPCTSTR pszValueName, DWORD& dwResult ) 
{
	DWORD	dwErr;
    DWORD	cbData = sizeof(DWORD);
	DWORD	dwType = REG_DWORD;

	dwErr = ::RegQueryValueEx( m_hKey, 
							   pszValueName, 
							   0, &dwType, 
							   (LPBYTE) &dwResult, &cbData ) ;

	if ((dwErr == ERROR_SUCCESS) && (dwType != REG_DWORD))
		dwErr = ERROR_INVALID_PARAMETER;
		
    if ( dwErr )
		dwResult = 0;

    return dwErr;
}

DWORD RegKey::QueryValue ( LPCTSTR pchValueName, LPTSTR pszDestBuffer, DWORD cchSize, BOOL fExpandSz)
{
	DWORD	dwErr;
    DWORD	cbData = MinCbNeededForCch(cchSize);
	DWORD	dwType = REG_SZ;
	TCHAR *	pszBuffer = (TCHAR *) _alloca(MinCbNeededForCch(cchSize));

	dwErr = ::RegQueryValueEx( m_hKey, 
							   pchValueName, 
							   0, &dwType,
							   (LPBYTE) pszBuffer, &cbData ) ;

	if ((dwErr == ERROR_SUCCESS) &&
		(dwType != REG_SZ) &&
		(dwType != REG_EXPAND_SZ) &&
	    (dwType != REG_MULTI_SZ))
		dwErr = ERROR_INVALID_PARAMETER;

	
	if (dwErr == ERROR_SUCCESS)
	{
		if ((dwType == REG_EXPAND_SZ) && fExpandSz)
			ExpandEnvironmentStrings(pszBuffer, pszDestBuffer, cchSize);
		else
			::CopyMemory(pszDestBuffer, pszBuffer, cbData);
	}

    return dwErr;
}


DWORD RegKey::QueryValue ( LPCTSTR pszValueName, CByteArray & abResult )
{
    DWORD dwErr = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( dwErr = PrepareValue( pszValueName, & dwType, & cbData, & pabData ) )
            break ;
   
        if ( dwType != REG_BINARY ) 
        {
            dwErr = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Catch exceptions trying to grow the result array
        TRY
        {
            abResult.SetSize( cbData ) ;
        }
        CATCH_ALL(e)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL

        if ( dwErr ) 
            break ;

        //  Move the data to the result array.
        for ( DWORD i = 0 ; i < cbData ; i++ ) 
        {
            abResult[i] = pabData[i] ;
        }
    } 
    while ( FALSE ) ;

    // Memory leak....
    //if ( dwErr )
    //{
        delete [] pabData ;
    //}
    
    return dwErr ; 
}

DWORD RegKey::QueryValue ( LPCTSTR pszValueName, void * pvResult, DWORD cbSize )
{
	DWORD	dwErr;
	DWORD	dwType = REG_BINARY;

	dwErr = ::RegQueryValueEx( m_hKey, 
							   pszValueName, 
							   0, &dwType, 
							   (LPBYTE) pvResult, &cbSize ) ;

	if ((dwErr == ERROR_SUCCESS) && (dwType != REG_BINARY))
		dwErr = ERROR_INVALID_PARAMETER;
		
    return dwErr;
}

DWORD RegKey::SetValueExplicit(LPCTSTR pszValueName,
							   DWORD dwType,
							   DWORD dwSize,
							   LPBYTE pbData)
{
    return ::RegSetValueEx( *this, 
                    pszValueName,
                    0,
                    dwType,
					pbData,
					dwSize);
}

//  Overloaded value setting members.
DWORD RegKey::SetValue ( LPCTSTR pszValueName, LPCTSTR pszValue,
						 BOOL fRegExpand)
{
    DWORD dwErr = 0;
    DWORD dwType = fRegExpand ? REG_EXPAND_SZ : REG_SZ;

    dwErr = ::RegSetValueEx( *this, 
                    pszValueName,
                    0,
                    dwType,
                    (const BYTE *) pszValue,
					// This is not the correct string length
					// for DBCS strings
					pszValue ? CbStrLen(pszValue) : 0);

    return dwErr ;
}

DWORD RegKey::SetValue ( LPCTSTR pszValueName, CStringList & strList ) 
{

    DWORD dwErr = 0;
    
    DWORD cbSize ;
    BYTE * pbData = NULL ;

    dwErr = FlattenValue( strList, & cbSize, & pbData ) ;

    if ( dwErr == 0 ) 
    {
        dwErr = ::RegSetValueEx( *this, 
                       pszValueName,
                       0,
                       REG_MULTI_SZ,
                       pbData, 
                       cbSize ) ;
    }

    delete pbData ;

    return dwErr ;
}

DWORD RegKey::SetValue ( LPCTSTR pszValueName, DWORD & dwResult )
{
    DWORD dwErr = 0;

    dwErr = ::RegSetValueEx( *this, 
                    pszValueName,
                    0,
                    REG_DWORD,
                    (const BYTE *) & dwResult,
                    sizeof dwResult ) ;

    return dwErr ;
}

DWORD RegKey::SetValue ( LPCTSTR pszValueName, CByteArray & abResult )
{

    DWORD dwErr = 0;

    DWORD cbSize ;
    BYTE * pbData = NULL ;

    dwErr = FlattenValue( abResult, & cbSize, & pbData ) ;

    if ( dwErr == 0 ) 
    {
        dwErr = ::RegSetValueEx( *this, 
                       pszValueName,
                       0,
                       REG_BINARY,
                       pbData, 
                       cbSize ) ;
    }

    delete pbData ;

    return dwErr ;
}

DWORD RegKey::SetValue ( LPCTSTR pszValueName, void * pvResult, DWORD cbSize )
{

    DWORD dwErr = 0;

    dwErr = ::RegSetValueEx( *this, 
                       pszValueName,
                       0,
                       REG_BINARY,
                       (const BYTE *)pvResult, 
                       cbSize ) ;

    return dwErr ;
}

DWORD RegKey::FlattenValue ( 
							 CStringList & strList, 
							 DWORD * pcbSize, 
							 BYTE ** ppbData )
{
	return StrList2MULTI_SZ(strList, pcbSize, ppbData);
}

DWORD RegKey::FlattenValue ( 
							 CByteArray & abData,
							 DWORD * pcbSize,
							 BYTE ** ppbData )
{
    DWORD dwErr = 0 ;
    
    DWORD i ;

    //  Allocate and fill a temporary buffer
    if (*pcbSize = (DWORD)abData.GetSize())
    {
        TRY
        {
            *ppbData = new BYTE[*pcbSize] ;

            for ( i = 0 ; i < *pcbSize ; i++ ) 
            {
                (*ppbData)[i] = abData[i] ;
            }

        }
        CATCH_ALL(e)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    else
    {
        *ppbData = NULL;
    }

    return dwErr ;
}


DWORD RegKey::QueryKeyInfo ( CREGKEY_KEY_INFO * pRegKeyInfo ) 
{
    DWORD dwErr = 0 ;

    pRegKeyInfo->dwClassNameSize = sizeof pRegKeyInfo->chBuff - 1 ;

    dwErr = ::RegQueryInfoKey( *this,
                     pRegKeyInfo->chBuff,
                     & pRegKeyInfo->dwClassNameSize,
                     NULL,
                     & pRegKeyInfo->dwNumSubKeys,
                     & pRegKeyInfo->dwMaxSubKey,
                     & pRegKeyInfo->dwMaxClass,
                     & pRegKeyInfo->dwMaxValues,
                     & pRegKeyInfo->dwMaxValueName,
                     & pRegKeyInfo->dwMaxValueData,
                     & pRegKeyInfo->dwSecDesc,
                     & pRegKeyInfo->ftKey ) ;

    return dwErr ;
}


RegValueIterator::RegValueIterator()
    : m_pRegKey( NULL ),
    m_pszBuffer( NULL ),
    m_cbBuffer( 0 ) 
{
}

HRESULT RegValueIterator::Init(RegKey *pRegKey)
{
    DWORD dwErr = 0 ;
    RegKey::CREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    m_pRegKey= pRegKey;

    dwErr = pRegKey->QueryKeyInfo( & regKeyInfo ) ;

    if ( dwErr == 0 ) 
    {
		m_cbBuffer = regKeyInfo.dwMaxValueName + sizeof (DWORD) ;
		delete [] m_pszBuffer;
		m_pszBuffer = new TCHAR [ m_cbBuffer ] ;
		_ASSERTE(m_pszBuffer);
    }
	return HRESULT_FROM_WIN32(dwErr);
}

RegValueIterator::~RegValueIterator() 
{
    delete [] m_pszBuffer ;
}

HRESULT RegValueIterator::Next( CString * pstrName, DWORD * pdwType )
{
    DWORD dwErr = 0 ;
    
    DWORD dwNameLength = m_cbBuffer ;

    dwErr = ::RegEnumValue( *m_pRegKey,
                  m_dwIndex,
                  m_pszBuffer,
                  & dwNameLength,
                  NULL,
                  pdwType,
                  NULL,
                  NULL ) ;
    
    if ( dwErr == 0 ) 
    {
        m_dwIndex++ ;

		*pstrName = m_pszBuffer ;
    }
    
    return HRESULT_FROM_WIN32(dwErr) ;
}


RegKeyIterator::RegKeyIterator()
    : m_pregkey(NULL),
    m_pszBuffer(NULL),
    m_cbBuffer( 0 ) 
{
}

HRESULT RegKeyIterator::Init(RegKey *pregkey)
{
    DWORD dwErr = 0 ;
    RegKey::CREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

	m_pregkey= pregkey;

    dwErr = pregkey->QueryKeyInfo( & regKeyInfo ) ;

    if ( dwErr == 0 ) 
    {
		m_cbBuffer = regKeyInfo.dwMaxSubKey + sizeof(DWORD);
		delete [] m_pszBuffer;
		m_pszBuffer = new TCHAR[m_cbBuffer];
    }

	return HRESULT_FROM_WIN32(dwErr);
}

RegKeyIterator::~RegKeyIterator () 
{
    delete [] m_pszBuffer ;
}

HRESULT RegKeyIterator::Reset()
{
	m_dwIndex = 0;
	return S_OK;
}


/*!--------------------------------------------------------------------------
	RegKeyIterator::Next
		Returns the name (and optional last write time) of the next key.
		Return S_FALSE if there are no other items to be returned.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RegKeyIterator::Next ( CString * pstrName, CTime * pTime ) 
{
    DWORD dwErr = 0;

    FILETIME ftDummy ;
    DWORD dwNameSize = m_cbBuffer;

    dwErr = ::RegEnumKeyEx( *m_pregkey, 
							m_dwIndex, 
							m_pszBuffer,
							& dwNameSize, 
							NULL,
							NULL,
							NULL,
							& ftDummy ) ;    
    if ( dwErr == 0 ) 
    {
        m_dwIndex++ ;

        if ( pTime ) 
        {
			*pTime = ftDummy ;
        }

		if (pstrName)
		{
            *pstrName = m_pszBuffer ;
        }
    }
    
    return (dwErr == ERROR_NO_MORE_ITEMS) ? S_FALSE : HRESULT_FROM_WIN32(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\vendors.h ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation

Module Name:

   Vendors.h

Abstract:

   Declaration of the CIASNASVendors class.


   This class is the C++ implementation of the IIASNASVendors interface on
   the NASVendors COM object.

  
   See Vendors.cpp for implementation.

Revision History:
   mmaguire 11/04/98 - created


--*/
//////////////////////////////////////////////////////////////////////////////

#if !defined(_NAS_VENDORS_H_)
#define _NAS_VENDORS_H_
#pragma once

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// where we can find what this class derives from:
//
#include <vector>
//
// where we can find what this class has or uses:
//
#include <utility>   // For "pair"
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

typedef std::pair< CComBSTR, LONG > VendorPair;

/////////////////////////////////////////////////////////////////////////////
// CIASGroupAttributeEditor
class ATL_NO_VTABLE CIASNASVendors : 
   public CComObjectRootEx<CComSingleThreadModel>
   , public CComCoClass<CIASNASVendors, &CLSID_IASNASVendors>
   , public IDispatchImpl<IIASNASVendors, &IID_IIASNASVendors, &LIBID_NAPMMCLib>
   , std::vector< VendorPair >
{
public:
   CIASNASVendors();

   DECLARE_NO_REGISTRY()

DECLARE_CLASSFACTORY_SINGLETON(CIASNASVendors)

BEGIN_COM_MAP(CIASNASVendors)
   COM_INTERFACE_ENTRY(IIASNASVendors)
   COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()


// IIASNASVendors:
public:
      STDMETHOD( InitFromSdo )( /* [in] */ ISdoCollection *pSdoVendorsCollection );
      STDMETHOD( get_Size )( /* [retval][out] */ long *plCount );
      STDMETHOD( get_VendorName )( long lIndex, /* [retval][out] */ BSTR *pbstrVendorName );
      STDMETHOD( get_VendorID )( long lIndex, /* [retval][out] */ long *plVendorID );
        STDMETHOD( get_VendorIDToOrdinal )( long lVendorID, /* [retval][out] */ long *plIndex );
protected:
   BOOL m_bUninitialized;
};

HRESULT MakeVendorNameFromVendorID(DWORD dwVendorId, BSTR* pbstrVendorName );

#endif // _NAS_VENDORS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\vendors.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    Vendors.cpp

Abstract:

	Implementation file for NAS Vendor ID info.

Revision History:
	mmaguire	02/19/98	created
	byao		3/13/98		Modified.  use '0' for RADIUS
	mmaguire	11/04/98	Revamped to be a static COM object populated from the SDO's.
  
--*/
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
// standard includes:
//
#include "Precompiled.h"
//
// where we can find declaration for main class in this file:
//
#include "Vendors.h"
//
// where we can find declarations needed in this file:
//
//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
/*++

CIASNASVendors::CIASNASVendors

Constructor

--*/
//////////////////////////////////////////////////////////////////////////////
CIASNASVendors::CIASNASVendors()
{
	m_bUninitialized = TRUE;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASNASVendors::InitFromSdo

IIASNASVendors implementation.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASNASVendors::InitFromSdo( /* [in] */ ISdoCollection *pSdoVendors )
{

	// Check to see if we've already been initialized.
	if( ! m_bUninitialized )
	{
		return S_FALSE;
	}


	HRESULT					hr = S_OK;
	CComPtr<IUnknown>		spUnknown;
	CComPtr<IEnumVARIANT>	spEnumVariant;
	CComVariant				spVariant;
	long					ulCount;
	ULONG					ulCountReceived; 

	if( ! pSdoVendors )
	{
		return E_FAIL;	// Is there a better error to return here?
	}


	try	// push_back can throw exceptions.
	{

		// We check the count of items in our collection and don't bother getting the 
		// enumerator if the count is zero.  
		// This saves time and also helps us to avoid a bug in the the enumerator which
		// causes it to fail if we call next when it is empty.
		pSdoVendors->get_Count( & ulCount );

		if( ulCount > 0 )
		{

			// Get the enumerator for the Clients collection.
			hr = pSdoVendors->get__NewEnum( (IUnknown **) & spUnknown );
			if( FAILED( hr ) || ! spUnknown )
			{
				return E_FAIL;
			}

			hr = spUnknown->QueryInterface( IID_IEnumVARIANT, (void **) &spEnumVariant );
			spUnknown.Release();
			if( FAILED( hr ) || ! spEnumVariant )
			{
				return E_FAIL;
			}

			// Get the first item.
			hr = spEnumVariant->Next( 1, & spVariant, &ulCountReceived );

			while( SUCCEEDED( hr ) && ulCountReceived == 1 )
			{
			
				// Get an sdo pointer from the variant we received.
				if( spVariant.vt != VT_DISPATCH || ! spVariant.pdispVal )
				{
					_ASSERTE( FALSE );
					continue;
				}

				CComPtr<ISdo> spSdo;
				hr = spVariant.pdispVal->QueryInterface( IID_ISdo, (void **) &spSdo );
				spVariant.Clear();
				if( FAILED( hr ) )
				{
					_ASSERTE( FALSE );
					continue;
				}


				// Get Vendor Name.
				hr = spSdo->GetProperty( PROPERTY_SDO_NAME, &spVariant );
				if( FAILED( hr ) )
				{
					_ASSERTE( FALSE );
					continue;
				}

				_ASSERTE( spVariant.vt == VT_BSTR );
				CComBSTR bstrVendorName = spVariant.bstrVal;
				spVariant.Clear();


				// Get Vendor ID.
				hr = spSdo->GetProperty( PROPERTY_NAS_VENDOR_ID, &spVariant );
				if( FAILED( hr ) )
				{
					_ASSERTE( FALSE );
					continue;
				}

				_ASSERTE( spVariant.vt == VT_I4 );
				LONG lVendorID = spVariant.lVal;
				spVariant.Clear();


				// Add the vendor infor to the list of vendors.
				push_back( std::make_pair(bstrVendorName, lVendorID) );


				// Get the next item.
				hr = spEnumVariant->Next( 1, & spVariant, &ulCountReceived );

			} 

		}
		else
		{
			// There are no items in the enumeration
			// Do nothing.
		}

	}
	catch(...)
	{
		return E_FAIL;
	}

	m_bUninitialized = FALSE;

	return hr;	
	
}




//////////////////////////////////////////////////////////////////////////////
/*++

CIASNASVendors::get_Size

IIASNASVendors implementation.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASNASVendors::get_Size( /* [retval][out] */ long *plCount )
{

	if( m_bUninitialized )
	{
		return OLE_E_BLANK;
	}

	*plCount = size();

	return S_OK;
	
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASNASVendors::get_VendorName

IIASNASVendors implementation.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASNASVendors::get_VendorName( long lIndex, /* [retval][out] */ BSTR *pbstrVendorName )
{
	if( m_bUninitialized )
	{
		return OLE_E_BLANK;
	}
	
	
	try
	{
		*pbstrVendorName = operator[]( lIndex ).first.Copy();
	}
	catch(...)
	{
		return ERROR_NOT_FOUND;
	}

	return S_OK;	
	
	
	
	
}

 HRESULT MakeVendorNameFromVendorID(DWORD dwVendorId, BSTR* pbstrVendorName )
 {
 	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	if(!pbstrVendorName)	return E_INVALIDARG;
	::CString str, str1;
	str1.LoadString(IDS_IAS_VAS_VENDOR_ID);
	str.Format(str1, dwVendorId);

	USES_CONVERSION;
	*pbstrVendorName = T2BSTR((LPTSTR)(LPCTSTR)str);
	return S_OK;
 }

//////////////////////////////////////////////////////////////////////////////
/*++

CIASNASVendors::get_VendorID

IIASNASVendors implementation.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASNASVendors::get_VendorID( long lIndex, /* [retval][out] */ long *plVendorID )
{
	if( m_bUninitialized )
	{
		return OLE_E_BLANK;
	}
	
	
	try
	{
		*plVendorID = operator[]( lIndex ).second;
	}
	catch(...)
	{
		return ERROR_NOT_FOUND;
	}

	return S_OK;	
	
}



//////////////////////////////////////////////////////////////////////////////
/*++

CIASNASVendors::get_VendorIDToOrdinal

IIASNASVendors implementation.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CIASNASVendors::get_VendorIDToOrdinal( long lVendorID, /* [retval][out] */ long *plIndex )
{
	if( m_bUninitialized )
	{
		return OLE_E_BLANK;
	}
		
	try
	{

		for (int i = 0; i < size() ; ++i)
		{
			if( lVendorID == operator[](i).second )
			{
				*plIndex = i;
				return S_OK;
			}
		}

	}
	catch(...)
	{
		return E_FAIL;
	}

	// When we can't find a vendor, we have arranged the dictionary so
	// that the zero'th vendor is the default "RADIUS Standard" so 
	// use this as the fallback.
	*plIndex = 0;
	return S_FALSE;
		
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\todcondition.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       todcondition.cpp
//
//--------------------------------------------------------------------------

// TodCondition.cpp: implementation of the CTodCondition class.
//
//////////////////////////////////////////////////////////////////////

#include "precompiled.h"
#include "TodCondition.h"
#include "timeofday.h"
#include "iasdebug.h"
#include "textmap.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTodCondition::CTodCondition(IIASAttributeInfo* pCondAttr,
							 ATL::CString& strConditionText
							)
  			  :CCondition(pCondAttr, strConditionText)
{
}

CTodCondition::CTodCondition(IIASAttributeInfo* pCondAttr)
  			  :CCondition(pCondAttr)
{
}


CTodCondition::~CTodCondition()
{

}

HRESULT CTodCondition::Edit()
{
	TRACE_FUNCTION("CTodCondition::Edit");
	// 
    // time of day constraint
    // 
	ATL::CString strTOD = m_strConditionText;
	HRESULT hr = S_OK;
	
	// get the new time of day constraint
	hr = ::GetTODConstaint(strTOD); 
	DebugTrace(DEBUG_NAPMMC_TODCONDITION, "GetTodConstraint() returned %x",hr);

	m_strConditionText = strTOD;
	
	return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  CTodCondition::GetDisplayText
//
// Synopsis:  Get the displayable text for this condition. 
//			  We just need to add the attribute name in front of the Hourmap string
//
// Arguments: None
//
// Returns:   ATL::CString& - displayable text
//
// History:   Created Header    byao	2/22/98 11:38:41 PM
//
//+---------------------------------------------------------------------------
ATL::CString CTodCondition::GetDisplayText()
{
	TRACE_FUNCTION("CTodCondition::GetDisplayText");

	HRESULT hr;

	::CString strLocalizedConditionText;
	// default implementation: as as condition text
	ATL::CString strDisplayText;

	
	CComBSTR bstrName;
	hr = m_spAttributeInfo->get_AttributeName( &bstrName );
	_ASSERTE( SUCCEEDED( hr ) );
	strDisplayText = bstrName;

	{ ATL::CString	matches;
		matches.LoadString(IDS_TEXT_MATCHES);
		strDisplayText += matches;
	}
	
	strDisplayText += _T("\"");
	if(NO_ERROR != LocalizeTimeOfDayConditionText(m_strConditionText, strLocalizedConditionText))
		strLocalizedConditionText = m_strConditionText;

	if(!strLocalizedConditionText.IsEmpty())
		strDisplayText += strLocalizedConditionText;
	strDisplayText += _T("\"");

	DebugTrace(DEBUG_NAPMMC_TODCONDITION, "GetDisplayText() returning %ws", (LPCTSTR)strDisplayText);
	return strDisplayText;
}


//+---------------------------------------------------------------------------
//
// Function:  CTodCondition::GetConditionText
//
// Synopsis:  Get the condition text for this condition. 
//			  We just need to add the TimeOfDay prefix to it
//
// Arguments: None
//
// Returns:   WCHAR* - condition text
//
// History:   Created Header    byao	2/22/98 11:38:41 PM
//
//+---------------------------------------------------------------------------
WCHAR*	CTodCondition::GetConditionText()
{
	TRACE_FUNCTION("CTodCondition::GetConditionText");
	WCHAR *pwzCondText;
	
	pwzCondText = new WCHAR[m_strConditionText.GetLength()+128];

	if (pwzCondText == NULL)
	{
		ShowErrorDialog(NULL, IDS_ERROR_SDO_ERROR_GET_CONDTEXT);
		return NULL;
	}

	// now form the condition text
	wcscpy(pwzCondText, TOD_PREFIX);
	wcscat(pwzCondText, _T("(\"") );
	wcscat(pwzCondText, (LPCTSTR)m_strConditionText);
	wcscat(pwzCondText, _T("\")") );


	DebugTrace(DEBUG_NAPMMC_TODCONDITION, "GetConditionText() returning %ws", (LPCTSTR)pwzCondText);
	return pwzCondText;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\todcondition.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       todcondition.h
//
//--------------------------------------------------------------------------

// TodCondition.h: interface for the CTodCondition class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_TODCONDITION_H__9F91767A_A693_11D1_BBEB_00C04FC31851__INCLUDED_)
#define AFX_TODCONDITION_H__9F91767A_A693_11D1_BBEB_00C04FC31851__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "atltmp.h"


#include "Condition.h"

class CTodCondition : public CCondition  
{
public:
	CTodCondition(IIASAttributeInfo* pCondAttr,
				  ATL::CString& strConditionText
				 );
	CTodCondition(IIASAttributeInfo* pCondAttr);
	virtual ~CTodCondition();

	HRESULT Edit();
	virtual ATL::CString GetDisplayText();
	virtual WCHAR* GetConditionText();

};

#endif // !defined(AFX_TODCONDITION_H__9F91767A_A693_11D1_BBEB_00C04FC31851__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\nap\tregkey.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    regkey.h

    FILE HISTORY:
        
*/

#ifndef _TREGKEY_H
#define _TREGKEY_H

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

/*---------------------------------------------------------------------------
	String length functions
 ---------------------------------------------------------------------------*/

#define StrLen			lstrlen
#define StrLenA			lstrlenA
#define StrLenW			lstrlenW
#define StrLenOle		StrLenW

//
//	CbStrLenA() is inaccurate for DBCS strings!  It will return the
//	incorrect number of bytes needed.
//

#define CbStrLenA(psz)	((StrLenA(psz)+1)*sizeof(char))
#define CbStrLenW(psz)	((StrLenW(psz)+1)*sizeof(WCHAR))

#ifdef _UNICODE
	#define CbStrLen(psz)	CbStrLenW(psz)
#else
	#define CbStrLen(psz)	CbStrLenA(psz)
#endif


//
//  Maximum size of a Registry class name
//
#define CREGKEY_MAX_CLASS_NAME MAX_PATH

#ifndef MaxCchFromCb
// Given a cb (count of bytes) this is the maximal number of characters
// that can be in this string
#define MaxCchFromCb(cb)		((cb) / sizeof(TCHAR))
#endif

#ifndef MinTCharNeededForCch
// that needs to be allocated to hold the string
#define MinTCharNeededForCch(ch)	((ch) * (2/sizeof(TCHAR)))
#endif 

#ifndef MinCbNeededForCch
#define MinCbNeededForCch(ch)		(sizeof(TCHAR)*MinTCharNeededForCch(ch))
#endif 



#ifndef TFS_EXPORT_CLASS
#define TFS_EXPORT_CLASS
#endif

//  Convert a CStringList to the REG_MULTI_SZ format
DWORD StrList2MULTI_SZ(CStringList & strList, DWORD * pcbSize, BYTE ** ppbData);

//  Convert a REG_MULTI_SZ format to the CStringList 
DWORD MULTI_SZ2StrList(LPCTSTR pbMulti_Sz, CStringList & strList);

//
//  Wrapper for a Registry key handle.
//
class TFS_EXPORT_CLASS RegKey
{

public:
    //
    //  Key information return structure
    //
    typedef struct
    {
        TCHAR chBuff [CREGKEY_MAX_CLASS_NAME] ;
        DWORD dwClassNameSize,	// size of the class string
              dwNumSubKeys,		// number of subkeys
              dwMaxSubKey,		// longest subkey name length
              dwMaxClass,		// longest class string length
              dwMaxValues,		// number of value entries
              dwMaxValueName,	// longest value name length
              dwMaxValueData,	// longest value data length
              dwSecDesc ;		// security descriptor length
        FILETIME ftKey ;
    } CREGKEY_KEY_INFO ;

	//	Standard constructor
	//		To get at keys, you will have to open/create the key
	RegKey();
    ~RegKey ();

	DWORD Create(HKEY hKeyParent,
				 LPCTSTR lpszKeyName,
				 DWORD dwOptions = REG_OPTION_NON_VOLATILE,
				 REGSAM samDesired = KEY_ALL_ACCESS,
				 LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
				 LPCTSTR pszServerName = NULL);
	
	DWORD Open(HKEY hKeyParent,
			   LPCTSTR pszSubKey,
			   REGSAM samDesired = KEY_ALL_ACCESS,
			   LPCTSTR pszServerName = NULL);
	DWORD Close();
	HKEY Detach();
	void Attach(HKEY hKey);
	DWORD DeleteSubKey(LPCTSTR lpszSubKey);
	DWORD RecurseDeleteKey(LPCTSTR lpszKey);
	DWORD DeleteValue(LPCTSTR lpszValue);

    // Deletes the subkeys of the current key (does NOT delete the
    // current key).
    DWORD RecurseDeleteSubKeys();
    //
    //  Allow a RegKey to be used anywhere an HKEY is required.
    //
    operator HKEY () const
    {
        return m_hKey ;
    }

    //
    //  Fill a key information structure
    //
    DWORD QueryKeyInfo ( CREGKEY_KEY_INFO * pRegKeyInfo ) ;

	DWORD QueryTypeAndSize(LPCTSTR pszValueName, DWORD *pdwType, DWORD *pdwSize);

    //
    //  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
    //  if data exists but not in correct form to deliver into result object.
    //
    DWORD QueryValue ( LPCTSTR pchValueName, ::CString & strResult ) ;
    DWORD QueryValue ( LPCTSTR pchValueName, CStringList & strList ) ;
    DWORD QueryValue ( LPCTSTR pchValueName, DWORD & dwResult ) ;
    DWORD QueryValue ( LPCTSTR pchValueName, CByteArray & abResult ) ;
    DWORD QueryValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize );
	DWORD QueryValue ( LPCTSTR pchValueName, LPTSTR pszDestBuffer, DWORD cbSize, BOOL fExpandSz);

	DWORD QueryValueExplicit(LPCTSTR pchValueName,
							 DWORD *pdwType,
							 DWORD *pdwSize,
							 LPBYTE *ppbData);

    //  Overloaded value setting members.
    DWORD SetValue ( LPCTSTR pchValueName, LPCTSTR pszValue,
					 BOOL fRegExpand = FALSE) ;
    DWORD SetValue ( LPCTSTR pchValueName, CStringList & strList ) ;
    DWORD SetValue ( LPCTSTR pchValueName, DWORD & dwResult ) ;
    DWORD SetValue ( LPCTSTR pchValueName, CByteArray & abResult ) ;
    DWORD SetValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize );

	DWORD SetValueExplicit(LPCTSTR pchValueName,
						   DWORD dwType,
						   DWORD dwSize,
						   LPBYTE pbData);
	
protected:
    HKEY m_hKey;

    //  Prepare to read a value by finding the value's size.
	DWORD PrepareValue (
        LPCTSTR pchValueName,
        DWORD * pdwType,
        DWORD * pcbSize,
        BYTE ** ppbData
        );

    //  Convert a CStringList to the REG_MULTI_SZ format
    static DWORD FlattenValue (
        CStringList & strList,
        DWORD * pcbSize,
        BYTE ** ppbData
        );

    //  Convert a CByteArray to a REG_BINARY block
    static DWORD FlattenValue (
        CByteArray & abData,
        DWORD * pcbSize,
        BYTE ** ppbData
        );
};

//
//  Iterate the values of a key, return the name and type
//  of each.
//
class TFS_EXPORT_CLASS RegValueIterator
{
protected:
	RegKey *	m_pRegKey;
    DWORD m_dwIndex ;
    TCHAR * m_pszBuffer ;
    DWORD m_cbBuffer ;

public:
    RegValueIterator();
    ~ RegValueIterator () ;

	HRESULT	Init(RegKey *pRegKey);

    //
    // Get the name (and optional last write time) of the next key.
    //
    HRESULT Next ( ::CString * pstName, DWORD * pdwType ) ;

    //
    // Reset the iterator
    //
    void Reset ()
    {
        m_dwIndex = 0 ;
    }
};

//
//  Iterate the sub-key names of a key.
//

class TFS_EXPORT_CLASS RegKeyIterator
{
public:
	RegKeyIterator();
	~RegKeyIterator();
	
	HRESULT	Init(RegKey *pRegKey);

	HRESULT	Next(::CString *pstName, CTime *pTime = NULL);
	HRESULT	Reset();

protected:
	RegKey *	m_pregkey;
	DWORD		m_dwIndex;
	TCHAR *		m_pszBuffer;
	DWORD		m_cbBuffer;
};


#endif _TREGKEY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\grouppage.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    grouppage.cpp
//
// SYNOPSIS
//
//    Defines the class ServerGroupPage.
//
// MODIFICATION HISTORY
//
//    02/20/2000    Original version.
//    04/19/2000    Marshall SDOs across apartments.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <grouppage.h>
#include <serverprop.h>

CSysColorImageList::CSysColorImageList(
                        HINSTANCE hInst,
                        UINT nID
                        )
   :  m_hInst(hInst),
      m_hRsrc(::FindResource(m_hInst, MAKEINTRESOURCE(nID), RT_BITMAP))
{
   CreateSysColorImageList();
}

void CSysColorImageList::OnSysColorChange()
{
   DeleteImageList();
   CreateSysColorImageList();
}

void CSysColorImageList::CreateSysColorImageList()
{
   CBitmap bmp;
   bmp.Attach(AfxLoadSysColorBitmap(m_hInst, m_hRsrc));

   // Get the dimensions of the bitmap.
   BITMAP bm;
   bmp.GetBitmap(&bm);

   // Assume square images (cx == cy).
   Create(bm.bmHeight, bm.bmHeight, ILC_COLORDDB, bm.bmWidth / bm.bmHeight, 2);

   Add(&bmp, CLR_NONE);
}

///////////////////////////////////////////////////////////////////////////////
//
//  Functions for sorting each column.
//
///////////////////////////////////////////////////////////////////////////////

int compareAddress(Sdo& s1, Sdo& s2)
{
   CComBSTR v1, v2;
   s1.getValue(PROPERTY_RADIUSSERVER_ADDRESS, v1, L"");
   s2.getValue(PROPERTY_RADIUSSERVER_ADDRESS, v2, L"");
   return wcscmp(v1, v2);
}

int comparePriority(Sdo& s1, Sdo& s2)
{
   LONG v1, v2;
   s1.getValue(PROPERTY_RADIUSSERVER_PRIORITY, v1, 1);
   s2.getValue(PROPERTY_RADIUSSERVER_PRIORITY, v2, 1);
   return (int)(v1 - v2);
}

int compareWeight(Sdo& s1, Sdo& s2)
{
   LONG v1, v2;
   s1.getValue(PROPERTY_RADIUSSERVER_WEIGHT, v1, 50);
   s2.getValue(PROPERTY_RADIUSSERVER_WEIGHT, v2, 50);
   return (int)(v1 - v2);
}

//////////
// CompareProc for sorting the ListCtrl.
//////////
int
CALLBACK
CompareProc(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort
    )
{
   Sdo s1((ISdo*)lParam1), s2((ISdo*)lParam2);
   switch (lParamSort)
   {
      case 0:
         return compareAddress(s1, s2);
      case 1:
         return comparePriority(s1, s2);
      case 2:
         return compareWeight(s1, s2);
      case 3:
         return -compareAddress(s1, s2);
      case 4:
         return -comparePriority(s1, s2);
      case 5:
         return -compareWeight(s1, s2);
   }
   return 0;
}

ServerList::ServerList()
   : removeButton(NULL),
     editButton(NULL),
     sortIcons(AfxGetResourceHandle(), IDB_PROXY_SORT),
     sortColumn(0)
{
   // All columns are initially in ascending order.
   descending[0] = descending[1] = descending[2] = false;
}

void ServerList::onInitDialog(HWND dialog, Sdo& serverGroup)
{
   /////////
   // Get the servers collection.
   /////////

   serverGroup.getValue(
                   PROPERTY_RADIUSSERVERGROUP_SERVERS_COLLECTION,
                   servers
                   );

   /////////
   // Subclass the list control and save the button handles.
   /////////

   if (!serverList.SubclassWindow(::GetDlgItem(dialog, IDC_LIST_SERVERS)))
   {
      AfxThrowNotSupportedException();
   }
   removeButton = GetDlgItem(dialog, IDC_BUTTON_REMOVE);
   editButton = GetDlgItem(dialog, IDC_BUTTON_EDIT);

   /////////
   // Load the image strip with the server icon.
   /////////

   serverIcons.Create(IDB_PROXY_SMALL_ICONS, 16, 0, RGB(255, 0, 255));
   serverList.SetImageList(&serverIcons, LVSIL_SMALL);

   /////////
   // Set the column headers.
   /////////

   RECT rect;
   serverList.GetClientRect(&rect);
   LONG width = rect.right - rect.left;

   ResourceString nameCol(IDS_SERVER_COLUMN_NAME);
   serverList.InsertColumn(0, nameCol, LVCFMT_LEFT, width - 150);

   ResourceString priorityCol(IDS_SERVER_COLUMN_PRIORITY);
   serverList.InsertColumn(1, priorityCol, LVCFMT_LEFT, 75);

   ResourceString weightCol(IDS_SERVER_COLUMN_WEIGHT);
   serverList.InsertColumn(2, weightCol, LVCFMT_LEFT, 75);

   serverList.SetExtendedStyle(
                  serverList.GetExtendedStyle() | LVS_EX_FULLROWSELECT
                  );

   CHeaderCtrl* hdr = serverList.GetHeaderCtrl();
   if (hdr) { hdr->SetImageList(&sortIcons); }
}

void ServerList::onSysColorChange()
{
   sortIcons.OnSysColorChange();

   CHeaderCtrl* hdr = serverList.GetHeaderCtrl();
   if (hdr)
   {
      hdr->SetImageList(&sortIcons);
   }
}

void ServerList::onColumnClick(int column)
{
   LVCOLUMN lvcol;
   memset(&lvcol, 0, sizeof(lvcol));
   lvcol.mask = LVCF_FMT | LVCF_IMAGE;
   lvcol.fmt  = LVCFMT_IMAGE | LVCFMT_BITMAP_ON_RIGHT;

   // Reset the previous column's sort icon with blank icon.
   lvcol.iImage = -1;
   serverList.SetColumn(sortColumn, &lvcol);

   // If the user clicked on a new column, ...
   if (column != sortColumn)
   {
      // ... we use the existing sort order ...
      sortColumn = column;
   }
   else
   {
      // ... otherwise we flip it.
      descending[column] = !descending[column];
   }

   // Set the sort icon for new column.
   lvcol.iImage = (descending[sortColumn]) ? 1 : 0;
   serverList.SetColumn(sortColumn, &lvcol);

   sort();
}

void ServerList::onServerChanged()
{
   // We only enable remove and edit when a server is selected.
   BOOL enable = serverList.GetSelectedCount() > 0;
   EnableWindow(removeButton, enable);
   EnableWindow(editButton, enable);
}

bool ServerList::onAdd()
{
   bool modified = false;

   // Create a new server ...
   Sdo sdo = servers.create();
   // ... and a new server property sheet.
   ServerProperties props(sdo, IDS_SERVER_CAPTION_ADD);
   if (props.DoModal() == IDOK)
   {
      // Add this to the added list ...
      added.push_back(sdo);

      // ... and the list control.
      updateServer(sdo, 0, true);

      // Re-sort the list.
      sort();
      modified = true;
   }
   else
   {
      // User never applied the new server, so remove it.
      servers.remove(sdo);
   }

   return modified;
}

bool ServerList::onEdit()
{
   bool modified = false;

   LVITEM lvi;
   memset(&lvi, 0, sizeof(lvi));

   // Get the item selected.
   lvi.iItem = serverList.GetNextItem(-1, LVNI_SELECTED);
   if (lvi.iItem >= 0)
   {
      // Get the lParam that contains the ISdo pointer.
      lvi.mask = LVIF_PARAM;
      if (serverList.GetItem(&lvi) && lvi.lParam)
      {
         // Create an Sdo ...
         Sdo sdo((ISdo*)lvi.lParam);
         // ... and a property sheet.
         ServerProperties props(sdo);
         if (props.DoModal() == IDOK)
         {
            // Add it to the dirty list if it's not already there.
            if (!dirty.contains(sdo) && !added.contains(sdo))
            {
               dirty.push_back(sdo);
            }

            // Update the entry in the list control.
            updateServer(sdo, lvi.iItem, false);

            // Re-sort the list.
            sort();
            modified = true;
         }
      }
   }

   return modified;
}

bool ServerList::onRemove()
{
   bool modified = false;

   LVITEM lvi;
   memset(&lvi, 0, sizeof(lvi));

   // Get the selected item ...
   lvi.iItem = serverList.GetNextItem(-1, LVNI_SELECTED);
   if (lvi.iItem >= 0)
   {
      // ... and the associated SDO.
      lvi.mask = LVIF_PARAM;
      if (serverList.GetItem(&lvi) && lvi.lParam)
      {
         // Add to the removed list ...
         removed.push_back((ISdo*)lvi.lParam);

         // ... and remove from the list control.
         serverList.DeleteItem(lvi.iItem);
         modified = true;
      }
   }

   return modified;
}

void ServerList::setData()
{
   serverList.DeleteAllItems();
   serverList.SetItemCount(servers.count());

   original.clear();
   original.reserve(servers.count());

   Sdo server;
   SdoEnum sdoEnum(servers.getNewEnum());
   for (UINT nItem = 0; sdoEnum.next(server); ++nItem)
   {
      updateServer(server, nItem, true);

      // We add each server to the 'original' vector solely to hold a reference
      // to the COM proxy.
      original.push_back(server);
   }

   sort();
}

void ServerList::saveChanges(bool apply)
{
   SdoIterator i;

   if (apply)
   {
      // Persist all the dirty servers.
      for (i = dirty.begin(); i != dirty.end(); ++i)
      {
         Sdo(*i).apply();
      }
   
      // Persist all the added servers.
      for (i = added.begin(); i != added.end(); ++i)
      {
         Sdo(*i).apply();
      }
   }

   // Remove all the deleted servers.
   for (i = removed.begin(); i != removed.end(); ++i)
   {
      servers.remove(*i);
   }

   // Clear the collections.
   dirty.clear();
   added.clear();
   removed.clear();
}

void ServerList::discardChanges()
{
   // Restore the dirty servers.
   SdoIterator i;
   for (i = dirty.begin(); i != dirty.end(); ++i)
   {
      Sdo(*i).restore();
   }
   dirty.clear();

   // Remove the added servers.
   for (i = added.begin(); i != added.end(); ++i)
   {
      servers.remove(*i);
   }
   added.clear();

   // Clear the deleted servers.
   removed.clear();
}

void ServerList::sort()
{
   int column = sortColumn;
   if (descending[column]) { column += 3; }

   serverList.SortItems(CompareProc, column);
}

void ServerList::updateServer(
                     Sdo& server,
                     UINT nItem,
                     bool create
                     )
{
   // Get the server's name.
   CComBSTR name;
   server.getValue(PROPERTY_RADIUSSERVER_ADDRESS, name);

   // Initialize an LVITEM.
   LVITEM lvi;
   memset(&lvi, 0, sizeof(LVITEM));
   lvi.iItem = nItem;
   lvi.pszText = name;

   if (create)
   {
      // If we're creating, we have to set everything.
      lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
      lvi.iImage = IMAGE_RADIUS_SERVER;
      lvi.lParam = (LPARAM)(ISdo*)server;
      lvi.iItem = serverList.InsertItem(&lvi);
   }
   else
   {
      // Otherwise we just set the text.
      lvi.mask = LVIF_TEXT;
      serverList.SetItem(&lvi);
   }

   LONG value;
   WCHAR sz[12];

   // Update priority ...
   server.getValue(PROPERTY_RADIUSSERVER_PRIORITY, value);
   serverList.SetItemText(lvi.iItem, 1, _ltow(value, sz, 10));

   // ... and weight.
   server.getValue(PROPERTY_RADIUSSERVER_WEIGHT, value);
   serverList.SetItemText(lvi.iItem, 2, _ltow(value, sz, 10));
}

ServerGroupPage::ServerGroupPage(
                     LONG_PTR notifyHandle,
                     LPARAM notifyParam,
                     Sdo& groupSdo,
                     bool useName
                     )
   : SnapInPropertyPage(notifyHandle, notifyParam, true, IDD_SERVER_GROUP),
     selfStream(groupSdo)
{
   if (useName) { groupSdo.getName(name); }
}

BOOL ServerGroupPage::OnInitDialog()
{
   // Unmarshal the server group SDO.
   selfStream.get(self);

   // Initialize the server list control.
   servers.onInitDialog(m_hWnd, self);

   // Let our base class initialize.
   return SnapInPropertyPage::OnInitDialog();
}

void ServerGroupPage::OnSysColorChange()
{
   servers.onSysColorChange();
}

void ServerGroupPage::onAdd()
{
   if (servers.onAdd()) { SetModified(); }
}

void ServerGroupPage::onEdit()
{
   if (servers.onEdit()) { SetModified(); }
}

void ServerGroupPage::onRemove()
{
   if (servers.onRemove()) { SetModified(); }
}

void ServerGroupPage::onColumnClick(
                          NMLISTVIEW *pNMListView,
                          LRESULT* pResult
                          )
{
   servers.onColumnClick(pNMListView->iSubItem);
}

void ServerGroupPage::onItemActivate(
                          NMITEMACTIVATE* pNMItemAct,
                          LRESULT* pResult
                          )
{
   if (servers.onEdit()) { SetModified(); }
}

void ServerGroupPage::onServerChanged(
                          NMLISTVIEW* pNMListView,
                          LRESULT* pResult
                          )
{
   servers.onServerChanged();
}

void ServerGroupPage::getData()
{
   // There must be at least one server.
   if (servers.isEmpty())
   {
      fail(IDC_LIST_SERVERS, IDS_GROUP_E_NO_SERVERS, false);
   }

   getValue(IDC_EDIT_NAME, name);

   // The user must specify a name ...
   if (name.Length() == 0)
   {
      fail(IDC_EDIT_NAME, IDS_GROUP_E_NAME_EMPTY);
   }

   // The name must be unique.
   if (!self.setName(name))
   {
      fail(IDC_EDIT_NAME, IDS_GROUP_E_NOT_UNIQUE);
   }
}

void ServerGroupPage::setData()
{
   setValue(IDC_EDIT_NAME, name);

   servers.setData();
}

void ServerGroupPage::saveChanges()
{
   // We have to update ourself first otherwise we won't be able to update
   // our children when creating a new group.
   self.apply();

   servers.saveChanges();
}

void ServerGroupPage::discardChanges()
{
   // Restore ourself.
   self.restore();

   // Restore the servers.
   servers.discardChanges();
}

BEGIN_MESSAGE_MAP(ServerGroupPage, SnapInPropertyPage)
   ON_BN_CLICKED(IDC_BUTTON_ADD, onAdd)
   ON_BN_CLICKED(IDC_BUTTON_EDIT, onEdit)
   ON_BN_CLICKED(IDC_BUTTON_REMOVE, onRemove)
   ON_EN_CHANGE(IDC_EDIT_NAME, onChange)
   ON_NOTIFY(LVN_COLUMNCLICK, IDC_LIST_SERVERS, onColumnClick)
   ON_NOTIFY(LVN_ITEMACTIVATE, IDC_LIST_SERVERS, onItemActivate)
   ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_SERVERS, onServerChanged)
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\hiddenworker.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class HiddenDialogWithWorker.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <hiddenworker.h>

HiddenDialogWithWorker::HiddenDialogWithWorker()
   : worker(0)
{
}


HiddenDialogWithWorker::~HiddenDialogWithWorker() throw ()
{
   if (worker != 0)
   {
      WaitForSingleObject(worker, INFINITE);
      CloseHandle(worker);
   }
}


void HiddenDialogWithWorker::Start()
{
   if (!Create(IDD_HIDDEN_WORKER))
   {
      AfxThrowLastError();
   }
}


BOOL HiddenDialogWithWorker::OnInitDialog()
{
   worker = CreateThread(0, 0, StartRoutine, this, 0, 0);
   if (worker == 0)
   {
      AfxThrowLastError();
   }

   return CDialog::OnInitDialog();
}


LRESULT HiddenDialogWithWorker::OnThreadMessage(WPARAM wParam, LPARAM lParam)
{
   DestroyWindow();
   OnComplete(lParam);
   return 0;
}


BEGIN_MESSAGE_MAP(HiddenDialogWithWorker, CDialog)
   ON_MESSAGE(threadMessage, OnThreadMessage)
END_MESSAGE_MAP()


DWORD WINAPI HiddenDialogWithWorker::StartRoutine(void* arg) throw ()
{
   HiddenDialogWithWorker* obj = static_cast<HiddenDialogWithWorker*>(arg);

   LPARAM result = obj->DoWork();

   obj->PostMessage(threadMessage, 0, result);

   return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\groupwiz.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    groupwiz.h
//
// SYNOPSIS
//
//    Declares the classes that implement the new RADIUS server group wizard.
//
// MODIFICATION HISTORY
//
//    03/07/2000    Original version.
//    04/19/2000    Marshall SDOs across apartments.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef GROUPWIZ_H
#define GROUPWIZ_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <grouppage.h>

class NewGroupWizard;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NewGroupStartPage
//
// DESCRIPTION
//
//    Implements the Welcome page.
//
///////////////////////////////////////////////////////////////////////////////
class NewGroupStartPage : public SnapInPropertyPage
{
public:
   NewGroupStartPage(NewGroupWizard& wizard);

protected:
   virtual BOOL OnInitDialog();
   virtual BOOL OnSetActive();

   DEFINE_ERROR_CAPTION(IDS_GROUP_E_CAPTION);

private:
   NewGroupWizard& parent;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NewGroupNamePage
//
// DESCRIPTION
//
//    Implements the page where the user enters the group name.
//
///////////////////////////////////////////////////////////////////////////////
class NewGroupNamePage : public SnapInPropertyPage
{
public:
   NewGroupNamePage(NewGroupWizard& wizard);

   PCWSTR getName() const throw ()
   { return name; }

protected:
   virtual LRESULT OnWizardBack();
   virtual LRESULT OnWizardNext();

   afx_msg void onChangeName();

   DECLARE_MESSAGE_MAP()

   DEFINE_ERROR_CAPTION(IDS_GROUP_E_CAPTION);

   virtual void setData();

   void setButtons();

private:
   NewGroupWizard& parent;
   CComBSTR name;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NewGroupNovicePage
//
// DESCRIPTION
//
//    Implements the page where the user enters the primary and backup server.
//
///////////////////////////////////////////////////////////////////////////////
class NewGroupNovicePage : public SnapInPropertyPage
{
public:
   NewGroupNovicePage(NewGroupWizard& wizard);

   PCWSTR getPrimaryServer() const throw ()
   { return primary; }

   PCWSTR getBackupServer() const throw ()
   { return hasBackup ? (PCWSTR)backup : NULL; }

protected:
   virtual LRESULT OnWizardBack();
   virtual LRESULT OnWizardNext();

   afx_msg void onChangePrimary();
   afx_msg void onChangeHasBackup();
   afx_msg void onChangeBackup();
   afx_msg void onVerifyPrimary();
   afx_msg void onVerifyBackup();

   DECLARE_MESSAGE_MAP()

   DEFINE_ERROR_CAPTION(IDS_GROUP_E_CAPTION);

   virtual void setData();

   void setControlState();

private:
   NewGroupWizard& parent;
   CComBSTR primary;
   bool hasBackup;
   CComBSTR backup;
   CComBSTR secret;
   CComBSTR confirm;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NewGroupServersPage
//
// DESCRIPTION
//
//    Implements the page displaying the list of servers in the group.
//
///////////////////////////////////////////////////////////////////////////////
class NewGroupServersPage : public SnapInPropertyPage
{
public:
   NewGroupServersPage(NewGroupWizard& wizard);

protected:
   virtual BOOL OnInitDialog();
   virtual void OnSysColorChange();
   virtual LRESULT OnWizardBack();

   afx_msg void onAdd();
   afx_msg void onEdit();
   afx_msg void onRemove();
   afx_msg void onColumnClick(NMLISTVIEW* listView, LRESULT* result);
   afx_msg void onItemActivate(NMITEMACTIVATE* itemActivate, LRESULT* result);
   afx_msg void onServerChanged(NMLISTVIEW* listView, LRESULT* result);

   DECLARE_MESSAGE_MAP()

   DEFINE_ERROR_CAPTION(IDS_GROUP_E_CAPTION);

   virtual void getData();
   virtual void setData();

   void setButtons();

private:
   NewGroupWizard& parent;
   ServerList servers;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NewGroupFinishPage
//
// DESCRIPTION
//
//    Implements the Completion page.
//
///////////////////////////////////////////////////////////////////////////////
class NewGroupFinishPage : public SnapInPropertyPage
{
public:
   NewGroupFinishPage(
       NewGroupWizard& wizard,
       bool promptForNewPolicy = false
       );

   bool createNewPolicy() const throw ()
   { return createPolicy; }

protected:
   virtual BOOL OnInitDialog();
   virtual LRESULT OnWizardBack();

   DEFINE_ERROR_CAPTION(IDS_GROUP_E_CAPTION);

   virtual void setData();
   virtual void saveChanges();

private:
   NewGroupWizard& parent;
   CStatic text;
   bool allowCreate;
   bool createPolicy;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NewGroupWizard
//
// DESCRIPTION
//
//    Implements the New RADIUS Server Group wizard.
//
///////////////////////////////////////////////////////////////////////////////
class NewGroupWizard : public CPropertySheetEx
{
public:
   NewGroupWizard(
       SdoConnection& connection,
       SnapInView* snapInView = NULL,
       bool promptForNewPolicy = false
       );

   virtual INT_PTR DoModal();

   bool createNewPolicy() const throw ()
   { return finish.createNewPolicy(); }

   CString getFinishText();

   //////////
   // Public properties used by the wizard pages.
   //////////

   Sdo group;      // The group being created.
   LONG advanced;  // Wizard mode.

protected:
   virtual BOOL OnInitDialog();

private:
   SdoConnection& cxn;
   SnapInView* view;
   SdoStream<Sdo> groupStream;

   NewGroupStartPage start;
   NewGroupNamePage name;
   NewGroupNovicePage novice;
   NewGroupServersPage servers;
   NewGroupFinishPage finish;
};

#endif // GROUPWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\groupwiz.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    groupwiz.cpp
//
// SYNOPSIS
//
//    Defines the classes that implement the new RADIUS server group wizard.
//
// MODIFICATION HISTORY
//
//    03/07/2000    Original version.
//    04/19/2000    Marshall SDOs across apartments.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <groupwiz.h>
#include <resolver.h>
#include <iaslimits.h>

NewGroupStartPage::NewGroupStartPage(NewGroupWizard& wizard)
   : SnapInPropertyPage(IDD_NEWGROUP_WELCOME, 0, 0, false),
     parent(wizard)
{
}

BOOL NewGroupStartPage::OnInitDialog()
{
   SnapInPropertyPage::OnInitDialog();
   setLargeFont(IDC_STATIC_LARGE);
   return TRUE;
}

BOOL NewGroupStartPage::OnSetActive()
{
   SnapInPropertyPage::OnSetActive();
   parent.SetWizardButtons(PSWIZB_NEXT);
   return TRUE;
}

NewGroupNamePage::NewGroupNamePage(NewGroupWizard& wizard)
   : SnapInPropertyPage(
         IDD_NEWGROUP_NAME,
         IDS_NEWGROUP_NAME_TITLE,
         IDS_NEWGROUP_NAME_SUBTITLE,
         false
         ),
     parent(wizard)
{
}

LRESULT NewGroupNamePage::OnWizardBack()
{
   // Save the state of the radio button.
   getRadio(IDC_RADIO_TYPICAL, IDC_RADIO_CUSTOM, parent.advanced);
   return 0;
}

LRESULT NewGroupNamePage::OnWizardNext()
{
   if (!parent.group.setName(name))
   {
      failNoThrow(IDC_EDIT_NAME, IDS_GROUP_E_NOT_UNIQUE);
      return -1;
   }

   getRadio(IDC_RADIO_TYPICAL, IDC_RADIO_CUSTOM, parent.advanced);
   return parent.advanced ? IDD_NEWGROUP_SERVERS : IDD_NEWGROUP_NOVICE;
}

void NewGroupNamePage::onChangeName()
{
   getValue(IDC_EDIT_NAME, name);
   setButtons();
}

void NewGroupNamePage::setData()
{
   setValue(IDC_EDIT_NAME, name);
   setRadio(IDC_RADIO_TYPICAL, IDC_RADIO_CUSTOM, parent.advanced);
   setButtons();
}

void NewGroupNamePage::setButtons()
{
   parent.SetWizardButtons(
              name.Length() ? (PSWIZB_BACK | PSWIZB_NEXT) : PSWIZB_BACK
              );
}

BEGIN_MESSAGE_MAP(NewGroupNamePage, SnapInPropertyPage)
   ON_EN_CHANGE(IDC_EDIT_NAME, onChangeName)
END_MESSAGE_MAP()

NewGroupNovicePage::NewGroupNovicePage(NewGroupWizard& wizard)
   : SnapInPropertyPage(
         IDD_NEWGROUP_NOVICE,
         IDS_NEWGROUP_NOVICE_TITLE,
         IDS_NEWGROUP_NOVICE_SUBTITLE,
         false
         ),
     parent(wizard),
     hasBackup(true)
{
}

LRESULT NewGroupNovicePage::OnWizardBack()
{
   // Save the secrets.
   getValue(IDC_EDIT_AUTH_SECRET1, secret);
   getValue(IDC_EDIT_AUTH_SECRET2, confirm);
   return 0;
}

LRESULT NewGroupNovicePage::OnWizardNext()
{
   // Get the secret.
   getValue(IDC_EDIT_AUTH_SECRET1, secret);

   // Make sure the confirmation matches the secret.
   getValue(IDC_EDIT_AUTH_SECRET2, confirm);
   if (wcscmp(secret, confirm))
   {
      failNoThrow(IDC_EDIT_AUTH_SECRET1, IDS_SERVER_E_SECRET_MATCH);
      return -1;
   }

   // Get the servers collection.
   SdoCollection servers;
   parent.group.getValue(
                    PROPERTY_RADIUSSERVERGROUP_SERVERS_COLLECTION,
                    servers
                    );

   // Remove any exisiting servers.
   servers.removeAll();

   // Create the primary server.
   Sdo primarySdo = servers.create();
   primarySdo.setValue(PROPERTY_RADIUSSERVER_ADDRESS, primary);
   primarySdo.setValue(PROPERTY_RADIUSSERVER_AUTH_SECRET, secret);

   if (hasBackup)
   {
      // Create the backup server.
      Sdo backupSdo = servers.create();
      backupSdo.setValue(PROPERTY_RADIUSSERVER_ADDRESS, backup);
      backupSdo.setValue(PROPERTY_RADIUSSERVER_AUTH_SECRET, secret);
      backupSdo.setValue(PROPERTY_RADIUSSERVER_PRIORITY, 2L);
   }

   return IDD_NEWGROUP_COMPLETION;
}

void NewGroupNovicePage::onChangePrimary()
{
   getValue(IDC_EDIT_PRIMARY, primary);
   setControlState();
}

void NewGroupNovicePage::onChangeHasBackup()
{
   getValue(IDC_CHECK_BACKUP, hasBackup);
   setControlState();
}

void NewGroupNovicePage::onChangeBackup()
{
   getValue(IDC_EDIT_BACKUP, backup);
   setControlState();
}

void NewGroupNovicePage::onVerifyPrimary()
{
   ServerResolver resolver(primary);
   if (resolver.DoModal() == IDOK)
   {
      primary = resolver.getChoice();
      setValue(IDC_EDIT_PRIMARY, primary);
      setControlState();
   }
}

void NewGroupNovicePage::onVerifyBackup()
{
   ServerResolver resolver(backup);
   if (resolver.DoModal() == IDOK)
   {
      backup = resolver.getChoice();
      setValue(IDC_EDIT_BACKUP, backup);
      setControlState();
   }
}

void NewGroupNovicePage::setData()
{
   setValue(IDC_EDIT_PRIMARY, primary);
   setValue(IDC_CHECK_BACKUP, hasBackup);
   setValue(IDC_EDIT_BACKUP, backup);
   setValue(IDC_EDIT_AUTH_SECRET1, secret);
   setValue(IDC_EDIT_AUTH_SECRET2, confirm);
   setControlState();
}

void NewGroupNovicePage::setControlState()
{
   enableControl(IDC_EDIT_BACKUP, hasBackup);
   enableControl(IDC_BUTTON_VERIFY_BACKUP, hasBackup);

   DWORD buttons = PSWIZB_BACK;

   // We always require a primary. We also require a backup if the box is
   // checked.
   if (primary.Length() && (!hasBackup || backup.Length()))
   {
      buttons |= PSWIZB_NEXT;
   }

   parent.SetWizardButtons(buttons);
}

BEGIN_MESSAGE_MAP(NewGroupNovicePage, SnapInPropertyPage)
   ON_EN_CHANGE(IDC_EDIT_PRIMARY, onChangePrimary)
   ON_EN_CHANGE(IDC_EDIT_BACKUP, onChangeBackup)
   ON_BN_CLICKED(IDC_CHECK_BACKUP, onChangeHasBackup)
   ON_BN_CLICKED(IDC_BUTTON_VERIFY_PRIMARY, onVerifyPrimary)
   ON_BN_CLICKED(IDC_BUTTON_VERIFY_BACKUP, onVerifyBackup)
END_MESSAGE_MAP()

NewGroupServersPage::NewGroupServersPage(NewGroupWizard& wizard)
   : SnapInPropertyPage(
         IDD_NEWGROUP_SERVERS,
         IDS_NEWGROUP_SERVERS_TITLE,
         IDS_NEWGROUP_SERVERS_SUBTITLE,
         false
         ),
     parent(wizard)
{
}

BOOL NewGroupServersPage::OnInitDialog()
{
   servers.onInitDialog(m_hWnd, parent.group);
   return SnapInPropertyPage::OnInitDialog();
}

void NewGroupServersPage::OnSysColorChange()
{
   servers.onSysColorChange();
}

LRESULT NewGroupServersPage::OnWizardBack()
{
   return IDD_NEWGROUP_NAME;
}

void NewGroupServersPage::onAdd()
{
   if (servers.onAdd())
   {
      // If the user makes any changes to the server list, we put him in
      // advanced mode.
      parent.advanced = 1;
      setButtons();
   }
}

void NewGroupServersPage::onEdit()
{
   if (servers.onEdit())
   {
      // If the user makes any changes to the server list, we put him in
      // advanced mode.
      parent.advanced = 1;
   }
}

void NewGroupServersPage::onRemove()
{
   if (servers.onRemove())
   {
      // If the user makes any changes to the server list, we put him in
      // advanced mode.
      parent.advanced = 1;
      setButtons();
   }
}

void NewGroupServersPage::onColumnClick(NMLISTVIEW* listView, LRESULT* result)
{
   servers.onColumnClick(listView->iSubItem);
}

void NewGroupServersPage::onItemActivate(
                              NMITEMACTIVATE* itemActivate,
                              LRESULT* result
                              )
{
   onEdit();
}

void NewGroupServersPage::onServerChanged(
                              NMLISTVIEW* listView,
                              LRESULT* result
                              )
{
   servers.onServerChanged();
}

void NewGroupServersPage::getData()
{
   servers.saveChanges(false);
}

void NewGroupServersPage::setData()
{
   servers.setData();
   setButtons();
}

void NewGroupServersPage::setButtons()
{
   parent.SetWizardButtons(
              servers.isEmpty() ? PSWIZB_BACK : (PSWIZB_BACK | PSWIZB_NEXT)
              );
}

BEGIN_MESSAGE_MAP(NewGroupServersPage, SnapInPropertyPage)
   ON_BN_CLICKED(IDC_BUTTON_ADD, onAdd)
   ON_BN_CLICKED(IDC_BUTTON_EDIT, onEdit)
   ON_BN_CLICKED(IDC_BUTTON_REMOVE, onRemove)
   ON_EN_CHANGE(IDC_EDIT_NAME, onChange)
   ON_NOTIFY(LVN_COLUMNCLICK, IDC_LIST_SERVERS, onColumnClick)
   ON_NOTIFY(LVN_ITEMACTIVATE, IDC_LIST_SERVERS, onItemActivate)
   ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_SERVERS, onServerChanged)
END_MESSAGE_MAP()

NewGroupFinishPage::NewGroupFinishPage(
                        NewGroupWizard& wizard,
                        bool promptForNewPolicy
                        )
   : SnapInPropertyPage(IDD_NEWGROUP_COMPLETION, 0, 0,  false),
     parent(wizard),
     allowCreate(promptForNewPolicy),
     createPolicy(true)
{
}

BOOL NewGroupFinishPage::OnInitDialog()
{
   setLargeFont(IDC_STATIC_LARGE);
   initControl(IDC_STATIC_FINISH, text);

   showControl(IDC_STATIC_CREATE_POLICY, allowCreate);
   showControl(IDC_CHECK_CREATE_POLICY, allowCreate);

   return SnapInPropertyPage::OnInitDialog();
}

LRESULT NewGroupFinishPage::OnWizardBack()
{
   return parent.advanced ? IDD_NEWGROUP_SERVERS : IDD_NEWGROUP_NOVICE;
}
void NewGroupFinishPage::setData()
{
   setValue(IDC_CHECK_CREATE_POLICY, createPolicy);
   parent.SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);
   text.SetWindowText(parent.getFinishText());
}

void NewGroupFinishPage::saveChanges()
{
   // This is a good time to get the status of the check box.
   getValue(IDC_CHECK_CREATE_POLICY, createPolicy);

   // We have to persist the group first. The SDOs won't let you persist a
   // child if the parent doesn't exist.
   parent.group.apply();

   // Get the servers collection.
   SdoCollection servers;
   parent.group.getValue(
                    PROPERTY_RADIUSSERVERGROUP_SERVERS_COLLECTION,
                    servers
                    );

   // Persist each server.
   Sdo server;
   SdoEnum sdoEnum = servers.getNewEnum();
   while (sdoEnum.next(server))
   {
      server.apply();
   }
}

NewGroupWizard::NewGroupWizard(
                    SdoConnection& connection,
                    SnapInView* snapInView,
                    bool promptForNewPolicy
                    )
   : CPropertySheetEx(
         (UINT)0,
         NULL,
         0,
         LoadBitmapW(
             AfxGetResourceHandle(),
             MAKEINTRESOURCEW(IDB_PROXY_SERVER_WATERMARK)
             ),
         NULL,
         LoadBitmapW(
             AfxGetResourceHandle(),
             MAKEINTRESOURCEW(IDB_PROXY_SERVER_HEADER)
             )
         ),
     advanced(0),
     cxn(connection),
     view(snapInView),
     start(*this),
     name(*this),
     novice(*this),
     servers(*this),
     finish(*this, promptForNewPolicy)
{
   m_psh.dwFlags |= PSH_WIZARD97;

   AddPage(&start);
   AddPage(&name);
   AddPage(&novice);
   AddPage(&servers);
   AddPage(&finish);
}

INT_PTR NewGroupWizard::DoModal()
{
   // Create a new group.
   Sdo newGroup = cxn.getServerGroups().tryCreate();
   if (!newGroup)
   {
      return IAS_E_LICENSE_VIOLATION;
   }

   // Save it in a stream, so we can access it from OnInitDialog.
   groupStream.marshal(newGroup);

   // Invoke the wizard.
   int retval = CPropertySheetEx::DoModal();

   if (retval == IDCANCEL)
   {
      // User cancelled, so remove the group.
      cxn.getServerGroups().remove(newGroup);
   }
   else if (view)
   {
      // User created a group, so send a propertyChanged notification.
      cxn.propertyChanged(
              *view,
              PROPERTY_IAS_RADIUSSERVERGROUPS_COLLECTION
              );
   }

   return retval;
}

CString NewGroupWizard::getFinishText()
{
   CString text;

   if (!advanced)
   {
      if (novice.getBackupServer())
      {
         text.FormatMessage(
                  IDS_NEWGROUP_FINISH_TYPICAL,
                  name.getName(),
                  novice.getPrimaryServer(),
                  novice.getBackupServer()
                  );
      }
      else
      {
         text.FormatMessage(
                  IDS_NEWGROUP_FINISH_TYPICAL,
                  name.getName(),
                  novice.getPrimaryServer(),
                  ResourceString(IDS_NEWGROUP_NO_BACKUP)
                  );
      }
   }
   else
   {
      text.FormatMessage(
               IDS_NEWGROUP_FINISH_CUSTOM,
               name.getName()
               );
   }

   return text;
}

BOOL NewGroupWizard::OnInitDialog()
{
   // Retrieve the group from the stream.
   groupStream.get(group);

   return CPropertySheetEx::OnInitDialog();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\hiddenworker.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class HiddenDialogWithWorker.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef HIDDENWORKER_H
#define HIDDENWORKER_H
#pragma once

class HiddenDialogWithWorker : public CDialog
{
public:
   HiddenDialogWithWorker();
   virtual ~HiddenDialogWithWorker() throw ();

   // Start the worker thread.
   void Start();

private:
   // Invoked in the worker thread.
   virtual LPARAM DoWork() throw () = 0;
   // Invoked in the dialog thread after the worker completes.
   virtual void OnComplete(LPARAM result) throw () = 0;

   virtual BOOL OnInitDialog();
   afx_msg LRESULT OnThreadMessage(WPARAM wParam, LPARAM lParam);

   DECLARE_MESSAGE_MAP()

   // Message signaling that the thread is complete.
   static const UINT threadMessage = WM_USER + 1;

   // Start routine for the worker thread.
   static DWORD WINAPI StartRoutine(void* arg) throw ();

   // Handle to the worker thread.
   HANDLE worker;

   // Not implemented.
   HiddenDialogWithWorker(const HiddenDialogWithWorker&);
   HiddenDialogWithWorker& operator=(const HiddenDialogWithWorker&);
};

#endif // HIDDENWORKER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\grouppage.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    grouppage.h
//
// SYNOPSIS
//
//    Declares the class ServerGroupPage
//
// MODIFICATION HISTORY
//
//    02/20/2000    Original version.
//    04/19/2000    Marshall SDOs across apartments.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef GROUPPAGE_H
#define GROUPPAGE_H
#if _MSC_VER >= 1000
#pragma once
#endif

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    CSysColorImageList
//
// DESCRIPTION
//
//    I stole this from MMC.
//
///////////////////////////////////////////////////////////////////////////////
class CSysColorImageList : public CImageList
{
public:
   CSysColorImageList(HINSTANCE hInst, UINT nID);

   void OnSysColorChange();

   operator HIMAGELIST() const
   {
      return (CImageList::operator HIMAGELIST());
   }

private:
    void CreateSysColorImageList();

    HINSTANCE   m_hInst;
    HRSRC       m_hRsrc;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ServerList
//
// DESCRIPTION
//
//    Encapsulates the functionality for manipulating a list of RADIUS servers.
//
///////////////////////////////////////////////////////////////////////////////
class ServerList
{
public:
   ServerList();

   void onInitDialog(HWND dialog, Sdo& serverGroup);
   void onSysColorChange();
   void onColumnClick(int column);
   void onServerChanged();
   bool onAdd();
   bool onEdit();
   bool onRemove();

   void getData();
   void setData();
   void saveChanges(bool apply = true);
   void discardChanges();

   bool isEmpty()
   { return serverList.GetItemCount() == 0; }

protected:
   // Sort the server list.
   void sort();
   // Add or update an item in the server list.
   void updateServer(Sdo& server, UINT nItem, bool create);

   typedef ObjectVector<ISdo> SdoVector;
   typedef ObjectVector<ISdo>::iterator SdoIterator;

   SdoCollection servers;        // Servers in this group.
   HWND removeButton;            // Handle to remove button.
   HWND editButton;              // Handle to edit button.
   CImageList serverIcons;       // ImageList for the ListCtrl.
   CSysColorImageList sortIcons; // ImageList for the HeaderCtrl.
   CListCtrl serverList;         // Server ListCtrl.
   SdoVector original;           // Original set of server SDOs.
   SdoVector dirty;              // Servers that have been edited.
   SdoVector added;              // Servers that have been added.
   SdoVector removed;            // Servers that have been removed.
   int sortColumn;               // Current sort column.
   bool descending[3];           // Sort order for each column.

   // Not implemented.
   ServerList(const ServerList&);
   ServerList& operator=(const ServerList&);
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ServerGroupPage
//
// DESCRIPTION
//
//    Implements the lone property page for a RADIUS server group.
//
///////////////////////////////////////////////////////////////////////////////
class ServerGroupPage : public SnapInPropertyPage
{
public:
   ServerGroupPage(
       LONG_PTR notifyHandle,
       LPARAM notifyParam,
       Sdo& groupSdo,
       bool useName = true
       );

protected:
   virtual BOOL OnInitDialog();
   virtual void OnSysColorChange();

   afx_msg void onAdd();
   afx_msg void onEdit();
   afx_msg void onRemove();

   afx_msg void onColumnClick(NMLISTVIEW* listView, LRESULT* result);
   afx_msg void onItemActivate(NMITEMACTIVATE* itemActivate, LRESULT* result);
   afx_msg void onServerChanged(NMLISTVIEW* listView, LRESULT* result);

   DECLARE_MESSAGE_MAP()

   DEFINE_ERROR_CAPTION(IDS_GROUP_E_CAPTION);

   // From SnapInPropertyPage
   virtual void getData();
   virtual void setData();
   virtual void saveChanges();
   virtual void discardChanges();

private:
   SdoStream<Sdo> selfStream;  // Marshal the SDO to the dialog thread.
   Sdo self;                   // The SDO we're editing.
   CComBSTR name;              // Group name.
   ServerList servers;         // Servers in this group.
};

#endif  // GROUPPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\policypage.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    policypage.cpp
//
// SYNOPSIS
//
//    Defines the class ProxyPolicyPage.
//
// MODIFICATION HISTORY
//
//    03/01/2000    Original version.
//    04/19/2000    Marshall SDOs across apartments.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <policypage.h>
#include <profileprop.h>

ProxyPolicyPage::ProxyPolicyPage(
                     LONG_PTR notifyHandle,
                     LPARAM notifyParam,
                     Sdo& policySdo,
                     Sdo& profileSdo,
                     SdoConnection& connection,
                     bool useName
                     )
 : SnapInPropertyPage(notifyHandle, notifyParam, true, IDD_PROXY_POLICY),
   policyStream(policySdo),
   profileStream(profileSdo),
   cxn(connection)
{
   if (useName) { policySdo.getName(name); }
}

BOOL ProxyPolicyPage::OnInitDialog()
{
   // Unmarshal the interfaces.
   policyStream.get(policy);
   profileStream.get(profile);

   // Get the conditions.
   policy.getValue(PROPERTY_POLICY_CONDITIONS_COLLECTION, conditions);

   SnapInPropertyPage::OnInitDialog();

   initControl(IDC_LIST_POLICYPAGE1_CONDITIONS, listBox);

   condList.finalConstruct(
                m_hWnd,
                cxn.getCIASAttrList(),
                ALLOWEDINPROXYCONDITION,
                cxn.getDictionary(),
                conditions,
                cxn.getMachineName(),
                name
                );
   return condList.onInitDialog();
}

void ProxyPolicyPage::onAddCondition()
{
   BOOL modified = FALSE;
   condList.onAdd(modified);
   if (modified) { SetModified(); }
}

void ProxyPolicyPage::onEditCondition()
{
   BOOL handled, modified = FALSE;
   condList.onEdit(modified, handled);
   if (modified) { SetModified(); }
}

void ProxyPolicyPage::onRemoveCondition()
{
   BOOL handled, modified = FALSE;
   condList.onRemove(modified, handled);
   if (modified) { SetModified(); }
}

void ProxyPolicyPage::onEditProfile()
{
   ProxyProfileProperties sheet(profile, cxn);
   if (sheet.DoModal() != IDCANCEL)
   {
      SetModified();
   }
}

void ProxyPolicyPage::getData()
{
   // There must be at least one condition.
   if (listBox.GetCount() == 0)
   {
      fail(IDC_LIST_POLICYPAGE1_CONDITIONS, IDS_POLICY_E_NO_CONDITIONS, false);
   }

   getValue(IDC_EDIT_NAME, name);

   // The user must specify a name ...
   if (name.Length() == 0)
   {
      fail(IDC_EDIT_NAME, IDS_POLICY_E_NAME_EMPTY);
   }

   // The name must be unique.
   if (!policy.setName(name))
   {
      fail(IDC_EDIT_NAME, IDS_POLICY_E_NOT_UNIQUE);
   }
}

void ProxyPolicyPage::setData()
{
   setValue(IDC_EDIT_NAME, name);
}

void ProxyPolicyPage::saveChanges()
{
   if (!condList.onApply()) { AfxThrowUserException(); }

   policy.setValue(PROPERTY_POLICY_PROFILE_NAME, name);
   policy.apply();

   profile.setName(name);
   profile.apply();
}

void ProxyPolicyPage::discardChanges()
{
   policy.restore();
   profile.restore();
   SdoCollection attributes;
   profile.getValue(PROPERTY_PROFILE_ATTRIBUTES_COLLECTION, attributes);
   attributes.reload();
}

BEGIN_MESSAGE_MAP(ProxyPolicyPage, SnapInPropertyPage)
   ON_BN_CLICKED(IDC_BUTTON_CONDITION_ADD, onAddCondition)
   ON_BN_CLICKED(IDC_BUTTON_CONDITION_EDIT, onEditCondition)
   ON_BN_CLICKED(IDC_BUTTON_CONDITION_REMOVE, onRemoveCondition)
   ON_BN_CLICKED(IDC_BUTTON_EDITPROFILE, onEditProfile)
   ON_LBN_DBLCLK(IDC_LIST_CONDITIONS, onEditCondition)
   ON_EN_CHANGE(IDC_EDIT_NAME, onChange)
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\objvec.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    objvec.h
//
// SYNOPSIS
//
//    Declares the class ObjectVector.
//
// MODIFICATION HISTORY
//
//    02/08/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef OBJVEC_H
#define OBJVEC_H
#if _MSC_VER >= 1000
#pragma once
#endif

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ObjectVector<T>
//
// DESCRIPTION
//
//    Maintains an array of reference counted objects.
//
///////////////////////////////////////////////////////////////////////////////
template <class T>
class ObjectVector
{
public:
   typedef int (__cdecl *SortFn)(
                             const T* const* t1,
                             const T* const* t2
                             ) throw ();

   ObjectVector() throw ()
      : first(NULL), last(NULL), cap(NULL)
   { }

   ~ObjectVector() throw ()
   {
      clear();
      delete[] first;
   }

   // Removes and releases all the objects in the array, but doesn't release
   // the array itself, i.e., after this call size() will return zero but
   // capacity() is unchanged.
   void clear() throw ()
   {
      while (last > first) (*--last)->Release();
   }

   bool contains(T* elem) throw ()
   {
      for (T** i = first; i != last; ++i)
      {
         if (*i == elem) { return true; }
      }

      return false;
   }

   // Returns true if the array is empty.
   bool empty() const throw ()
   { return first == last; }

   bool erase(T* elem) throw ()
   {
      for (T** i = first; i != last; ++i)
      {
         if (*i == elem)
         {
            --last;
            memmove(i, i + 1, (last - i) * sizeof(T*));
            return true;
         }
      }
      return false;
   }

   // Add 'elem' to the end of the array, resizing if necessary.
   void push_back(T* elem)
   {
      if (last == cap) { reserve(empty() ? 1 : capacity() * 2); }
      (*last++ = elem)->AddRef();
   }

   // Reserve space for at least 'nelem' items in the array. Useful to avoid
   // lots of resizing when you know in advance how many items you're planning
   // to store.
   void reserve(size_t nelem)
   {
      if (nelem > capacity())
      {
         T** t = new (AfxThrow) T*[nelem];
         memcpy(t, first, size() * sizeof(T*));
         last = t + size();
         cap = t + nelem;
         delete[] first;
         first = t;
      }
   }

   void sort(SortFn pfn) throw ()
   { qsort((void*)begin(), size(), sizeof(T*), (CompFn)pfn); }

   // Swap the contents of this with v.
   void swap(ObjectVector& v) throw ()
   {
      T** firstTmp = first;
      T** lastTmp = last;
      T** capTmp = cap;
      first = v.first;
      last = v.last;
      cap = v.cap;
      v.first = firstTmp;
      v.last = lastTmp;
      v.cap = capTmp;
   }

   // Returns the capacity of the array.
   size_t capacity() const throw ()
   { return cap - first; }

   // Returns the number of objects stored in the array.
   size_t size() const throw ()
   { return last - first; }

   typedef T* const* iterator;

   // Methods to iterate the array elements.
   iterator begin() const throw ()
   { return first; }
   iterator end() const throw ()
   { return last; }

   T* operator[](size_t index) const throw ()
   { return first[index]; }

private:
   typedef int (__cdecl *CompFn)(const void*, const void*);

   T** first;    // Begining of the array.
   T** last;     // End of the elements.
   T** cap;      // End of allocated storage.

   // Not implemented.
   ObjectVector(const ObjectVector&);
   ObjectVector& operator=(const ObjectVector&);
};

#endif // OBJVEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\policypage.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    policypage.h
//
// SYNOPSIS
//
//    Declares the class ProxyPolicyPage
//
// MODIFICATION HISTORY
//
//    03/01/2000    Original version.
//    04/19/2000    Marshall SDOs across apartments.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef POLICYPAGE_H
#define POLICYPAGE_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <condlist.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ProxyPolicyPage
//
// DESCRIPTION
//
//    Implements the property page for a proxy policy.
//
///////////////////////////////////////////////////////////////////////////////
class ProxyPolicyPage : public SnapInPropertyPage
{
public:
   ProxyPolicyPage(
       LONG_PTR notifyHandle,
       LPARAM notifyParam,
       Sdo& policySdo,
       Sdo& profileSdo,
       SdoConnection& connection,
       bool useName = true
       );

protected:
   virtual BOOL OnInitDialog();

   afx_msg void onAddCondition();
   afx_msg void onEditCondition();
   afx_msg void onRemoveCondition();
   afx_msg void onEditProfile();

   DECLARE_MESSAGE_MAP()

   DEFINE_ERROR_CAPTION(IDS_POLICY_E_CAPTION);

   // From SnapInPropertyPage.
   virtual void getData();
   virtual void setData();
   virtual void saveChanges();
   virtual void discardChanges();

private:
   SdoStream<Sdo> policyStream;
   SdoStream<Sdo> profileStream;
   Sdo policy;
   Sdo profile;
   SdoConnection& cxn;
   SdoCollection conditions;
   CComBSTR name;
   CListBox listBox;
   ConditionList condList;
};

#endif // POLICYPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\profileprop.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    profileprop.h
//
// SYNOPSIS
//
//    Declares the classes that make up the proxy profile property sheet.
//
// MODIFICATION HISTORY
//
//    03/02/2000    Original version.
//    04/19/2000    Marshall SDOs across apartments.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef PROFILEPROP_H
#define PROFILEPROP_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include "dlgcshlp.h"

class ProxyProfileProperties;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ProfileProvPage
//
// DESCRIPTION
//
//    Base class for the tabs that allow you to choose a RADIUS server group.
//
///////////////////////////////////////////////////////////////////////////////
class ProfileProvPage : public SnapInPropertyPage
{
public:
   ProfileProvPage(UINT nIDTemplate, SdoConnection& connection)
      : SnapInPropertyPage(nIDTemplate),
        cxn(connection),
        providerType(1),
        invalidGroup(CB_ERR)
   { }

protected:
   DEFINE_ERROR_CAPTION(IDS_POLICY_E_CAPTION);

   virtual void getData();
   virtual void setData();

   SdoConnection& cxn;
   LONG providerType;
   int invalidGroup;
   CComBSTR providerName;
   CComboBox groupsCombo;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ProfileAuthPage
//
// DESCRIPTION
//
//    Implements the Authentication tab.
//
///////////////////////////////////////////////////////////////////////////////
class ProfileAuthPage : public ProfileProvPage
{
public:
   ProfileAuthPage(SdoConnection& connection, SdoProfile& p);

protected:
   afx_msg void onProviderClick();

   DECLARE_MESSAGE_MAP()

   virtual void getData();
   virtual void setData();
   virtual void saveChanges();

private:
   SdoProfile& profile;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ProfileAcctPage
//
// DESCRIPTION
//
//    Implements the Accounting tab.
//
///////////////////////////////////////////////////////////////////////////////
class ProfileAcctPage : public ProfileProvPage
{
public:
   ProfileAcctPage(SdoConnection& connection, SdoProfile& p);

protected:
   afx_msg void onCheckRecord();

   DECLARE_MESSAGE_MAP()

   virtual void getData();
   virtual void setData();
   virtual void saveChanges();

private:
   SdoProfile& profile;
   bool record;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ProfileAttrPage
//
// DESCRIPTION
//
//    Implements the attribute manipulation page.
//
///////////////////////////////////////////////////////////////////////////////
class ProfileAttrPage : public SnapInPropertyPage
{
public:
   ProfileAttrPage(SdoConnection& cxn, SdoProfile& p);
   ~ProfileAttrPage() throw ();

protected:
   virtual BOOL OnInitDialog();

   afx_msg void onAdd();
   afx_msg void onEdit();
   afx_msg void onRemove();
   afx_msg void onMoveUp();
   afx_msg void onMoveDown();
   afx_msg void onRuleActivate(NMITEMACTIVATE* itemActivate, LRESULT* result);
   afx_msg void onRuleChanged(NMLISTVIEW* listView, LRESULT* result);

   DECLARE_MESSAGE_MAP()

   DEFINE_ERROR_CAPTION(IDS_POLICY_E_CAPTION);

   virtual void getData();
   virtual void setData();
   virtual void saveChanges();

   void swapItems(int item1, int item2);

private:
   SdoProfile& profile;
   SdoDictionary::IdName* targets;
   ULONG numTargets;
   LONG targetId;
   CComVariant rules;
   CComboBox ruleTarget;
   CListCtrl ruleList;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ProxyProfileProperties
//
// DESCRIPTION
//
//    Implements the proxy profile property sheet.
//
///////////////////////////////////////////////////////////////////////////////
class ProxyProfileProperties : public CPropertySheet
{
public:
   ProxyProfileProperties(
       Sdo& profileSdo,
       SdoConnection& connection
       );
   ~ProxyProfileProperties();

   virtual INT_PTR DoModal();

protected:
   virtual BOOL OnInitDialog();

   afx_msg LRESULT onChanged(WPARAM wParam, LPARAM lParam);
   afx_msg void onOkOrApply();

   DECLARE_MESSAGE_MAP()

private:
   SdoProfile profile;
   SdoStream<SdoProfile> profileStream;

   ProfileAuthPage auth;
   ProfileAcctPage acct;
   ProfileAttrPage attr;

   HMODULE rasuser;             // DLL exporting the advanced page.
   HPROPSHEETPAGE advanced;     // The advanced property page.
   bool applied;                // true if any changes have been applied.
   bool modified;               // true if any pages have been modified.
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    RuleEditor
//
// DESCRIPTION
//
//    Implements the dialog for editing attribute manipulation rules.
//
///////////////////////////////////////////////////////////////////////////////
class RuleEditor : public CHelpDialog
{
public:
   RuleEditor(PCWSTR szFind = L"", PCWSTR szReplace = L"");

   PCWSTR getFindString() const throw ()
   { return find; }

   PCWSTR getReplaceString() const throw ()
   { return replace; }

protected:
   virtual void DoDataExchange(CDataExchange* pDX);

   ::CString find;
   ::CString replace;
};

#endif // PROFILEPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\proxyext.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    proxyext.cpp
//
// SYNOPSIS
//
//    Defines the class ProxyExtension
//
// MODIFICATION HISTORY
//
//    02/19/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <proxyext.h>
#include <proxynode.h>

// The GUID of the node we're going to extend.
class __declspec(uuid("02BBE102-6C29-11d1-9563-0060B0576642")) IASNode;

ProxyExtension::ProxyExtension() throw ()
   : moveUp(IDS_POLICY_MOVE_UP), moveDown(IDS_POLICY_MOVE_DOWN)
{
   buttons[0].nBitmap       = 0;
   buttons[0].idCommand     = 0;
   buttons[0].fsState       = TBSTATE_ENABLED;
   buttons[0].fsType        = TBSTYLE_BUTTON;
   buttons[0].lpButtonText  = L"";
   buttons[0].lpTooltipText = moveUp;

   buttons[1].nBitmap       = 1;
   buttons[1].idCommand     = 1;
   buttons[1].fsState       = TBSTATE_ENABLED;
   buttons[1].fsType        = TBSTYLE_BUTTON;
   buttons[1].lpButtonText  = L"";
   buttons[1].lpTooltipText = moveDown;

   toolbars[0].nImages      = 2;
   toolbars[0].hbmp         = LoadBitmap(
                                  _Module.GetResourceInstance(),
                                  MAKEINTRESOURCE(IDB_PROXY_TOOLBAR)
                                  );
   toolbars[0].crMask       = RGB(255, 0, 255);
   toolbars[0].nButtons     = 2;
   toolbars[0].lpButtons    = buttons;
   memset(toolbars + 1, 0, sizeof(toolbars[1]));

   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   AfxInitRichEdit();
}

ProxyExtension::~ProxyExtension() throw ()
{ }

const SnapInToolbarDef* ProxyExtension::getToolbars() const throw ()
{ return toolbars; }

STDMETHODIMP ProxyExtension::Initialize(LPUNKNOWN pUnknown)
{
   try
   {
      // Let our base class initialize.
      CheckError(SnapInView::Initialize(pUnknown));

      // Install the scope pane icons.
      setImageStrip(IDB_PROXY_SMALL_ICONS, IDB_PROXY_LARGE_ICONS, TRUE);
   }
   CATCH_AND_RETURN();

   return S_OK;
}

STDMETHODIMP ProxyExtension::Notify(
                                 LPDATAOBJECT lpDataObject,
                                 MMC_NOTIFY_TYPE event,
                                 LPARAM arg,
                                 LPARAM param
                                 )
{
   // We only have to do something special if we're expanding and we haven't
   // created the Proxy node yet.
   if (event == MMCN_EXPAND && arg && !node)
   {
      // Is this the main IAS node ?
      GUID guid;
      ExtractNodeType(lpDataObject, &guid);
      if (guid == __uuidof(IASNode))
      {
         try
         {
            node = new (AfxThrow) ProxyNode(
                                      *this,
                                      lpDataObject,
                                      (HSCOPEITEM)param
                                      );
         }
         CATCH_AND_RETURN();

         return S_OK;
      }
   }

   // For everything else we delegate to our base class.
   return SnapInView::Notify(lpDataObject, event, arg, param);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\proxynode.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    proxynode.cpp
//
// SYNOPSIS
//
//    Defines the class ProxyNode.
//
// MODIFICATION HISTORY
//
//    02/19/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <proxynode.h>
#include <proxypolicies.h>
#include <servergroups.h>

//////////
// From mmcutility.cpp
//////////
HRESULT IfServiceInstalled(
            LPCWSTR lpszMachine,
            LPCWSTR lpszService,
            BOOL* pBool
            );

//////////
// Helper function to get the NT build number of a machine.
//////////
LONG GetBuildNumber(LPCWSTR machineName, PLONG buildNum) throw ()
{
   const WCHAR KEY[]   = L"Software\\Microsoft\\Windows NT\\CurrentVersion";
   const WCHAR VALUE[] = L"CurrentBuildNumber";

   LONG error;

   HKEY hklm = HKEY_LOCAL_MACHINE;

   // Only do a remote connect when machineName is specified.
   CRegKey remote;
   if (machineName && machineName[0])
   {
      error = RegConnectRegistryW(
                  machineName,
                  HKEY_LOCAL_MACHINE,
                  &remote.m_hKey
                  );
      if (error) { return error; }

      hklm = remote;
   }

   CRegKey currentVersion;
   error = currentVersion.Open(hklm, KEY, KEY_READ);
   if (error) { return error; }

   WCHAR data[16];
   DWORD dataLen = sizeof(data);
   error = currentVersion.QueryValue(data, VALUE, &dataLen);
   if (error) { return error; }

   *buildNum = _wtol(data);

   return NO_ERROR;
}


inline ProxyNode::Connector::Connector()
{
}


void ProxyNode::Connector::BeginConnect(
                              ProxyNode& owner,
                              SnapInView& view,
                              IDataObject* parentData,
                              HSCOPEITEM parentId
                              ) throw ()
{
   node = &owner;
   nameSpace = view.getNameSpace();
   dataObject = parentData;
   relativeID = parentId;

   Start();
}


LPARAM ProxyNode::Connector::DoWork() throw ()
{
   return static_cast<LPARAM>(node->connect(dataObject));
}


void ProxyNode::Connector::OnComplete(LPARAM result) throw ()
{
   node->setConnectResult(
            nameSpace,
            relativeID,
            static_cast<ProxyNode::State>(result)
            );
}


ProxyNode::ProxyNode(
               SnapInView& view,
               IDataObject* parentData,
               HSCOPEITEM parentId
               )
   : SnapInPreNamedItem(IDS_PROXY_NODE),
     state(CONNECTING),
     title(IDS_PROXY_VIEW_TITLE),
     body(IDS_PROXY_VIEW_BODY)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   // Begin the connect action.
   worker.BeginConnect(*this, view, parentData, parentId);
}

HRESULT ProxyNode::getResultViewType(
                       LPOLESTR* ppViewType,
                       long* pViewOptions
                       ) throw ()
{
   // Set our result view to the MessageView control.
   *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;
   return StringFromCLSID(CLSID_MessageView, ppViewType);
}

HRESULT ProxyNode::onExpand(
                       SnapInView& view,
                       HSCOPEITEM itemId,
                       BOOL expanded
                       )
{
   if (!expanded || state != CONNECTED) { return S_FALSE; }

   SCOPEDATAITEM sdi;
   memset(&sdi, 0, sizeof(sdi));
   sdi.mask = SDI_STR       |
              SDI_PARAM     |
              SDI_IMAGE     |
              SDI_OPENIMAGE |
              SDI_CHILDREN  |
              SDI_PARENT;
   sdi.displayname = MMC_CALLBACK;
   sdi.cChildren = 0;
   sdi.relativeID = itemId;

   // Create the ProxyPolicies node ...
   policies = new (AfxThrow) ProxyPolicies(connection);
   // ... and insert.
   sdi.nImage = IMAGE_CLOSED_PROXY_POLICY_NODE;
   sdi.nOpenImage = IMAGE_OPEN_PROXY_POLICY_NODE;
   sdi.lParam = (LPARAM)(SnapInDataItem*)policies;
   CheckError(view.getNameSpace()->InsertItem(&sdi));
   policies->setScopeId(sdi.ID);

   // Create the ServerGroups node ...
   groups = new (AfxThrow) ServerGroups(connection);
   // ... and insert.
   sdi.nImage = IMAGE_CLOSED_SERVER_GROUP_NODE;
   sdi.nOpenImage = IMAGE_OPEN_SERVER_GROUPS_NODE;
   sdi.lParam = (LPARAM)(SnapInDataItem*)groups;
   CheckError(view.getNameSpace()->InsertItem(&sdi));
   groups->setScopeId(sdi.ID);

   // All went well.
   state = EXPANDED;

   return S_OK;
}

HRESULT ProxyNode::onShow(
                       SnapInView& view,
                       HSCOPEITEM itemId,
                       BOOL selected
                       )
{
   if (!selected) { return S_FALSE; }

   // Get the IMessageView interface ...
   CComPtr<IUnknown> unk;
   CheckError(view.getConsole()->QueryResultView(&unk));
   CComPtr<IMessageView> msgView;
   CheckError(unk->QueryInterface(
                       __uuidof(IMessageView),
                       (PVOID*)&msgView
                       ));

   // ... and set our information. We don't care if this fails.
   msgView->SetIcon(Icon_Information);
   msgView->SetTitleText(title);
   msgView->SetBodyText(body);

   return S_OK;
}


HRESULT ProxyNode::onContextHelp(SnapInView& view) throw ()
{
   return view.displayHelp(L"ias_ops.chm::/sag_ias_crp_node.htm");
}


ProxyNode::State ProxyNode::connect(IDataObject* dataObject) throw ()
{
   HGLOBAL global = NULL;

   // We'll assume that the node is suppressed until we've verified that the
   // target machine (1) has IAS installed and (2) supports proxy policies.
   State newState = SUPPRESSED;

   try
   {
      // Extract the machine name from the parentData.
      UINT cf = RegisterClipboardFormatW(L"MMC_SNAPIN_MACHINE_NAME");
      ExtractData(
          dataObject,
          (CLIPFORMAT)cf,
          4096,
          &global
          );
      PCWSTR machine = (PCWSTR)global;

      // Get the build number of the machine.
      LONG error, buildNum;
      error = GetBuildNumber(machine, &buildNum);
      if (error) { AfxThrowOleException(HRESULT_FROM_WIN32(error)); }

      // If the machine supports proxy policies, ...
      if (buildNum >= 2220)
      {
         // ... ensure that IAS is actually installed.
         BOOL installed;
         CheckError(IfServiceInstalled(machine, L"IAS", &installed));
         if (installed)
         {
            connection.connect(machine);
            newState = CONNECTED;
         }
      }
   }
   catch (...)
   {
      // Something went wrong.
      newState = FAILED;
   }

   GlobalFree(global);

   return newState;
}

void ProxyNode::setConnectResult(
                   IConsoleNameSpace2* nameSpace,
                   HSCOPEITEM relativeID,
                   State newState
                   ) throw ()
{
   // Don't add the node if we're suppressed.
   if (newState != SUPPRESSED)
   {
      SCOPEDATAITEM sdi;
      ZeroMemory(&sdi, sizeof(SCOPEDATAITEM));
      sdi.mask = SDI_STR       |
                 SDI_IMAGE     |
                 SDI_OPENIMAGE |
                 SDI_CHILDREN  |
                 SDI_PARENT    |
                 SDI_PARAM;
      sdi.displayname = MMC_CALLBACK;
      sdi.lParam      = (LPARAM)this;
      sdi.relativeID  = relativeID;

      if (newState == CONNECTED)
      {
         sdi.nImage      = IMAGE_CLOSED_PROXY_NODE;
         sdi.nOpenImage  = IMAGE_OPEN_PROXY_NODE;
         sdi.cChildren   = 2;
      }
      else
      {
         sdi.nImage      = IMAGE_CLOSED_BAD_PROXY_NODE;
         sdi.nOpenImage  = IMAGE_OPEN_BAD_PROXY_NODE;
      }

      nameSpace->InsertItem(&sdi);
   }

   // We don't update the state until everything is finished.
   state = newState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\profileprop.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the classes that make up the proxy profile property sheet.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <profileprop.h>
#include <condlist.h>

void ProfileProvPage::getData()
{
   if (groupsCombo.IsWindowEnabled())
   {
      if (groupsCombo.GetCurSel() == invalidGroup)
      {
         fail(IDC_COMBO_GROUP, IDS_POLICY_E_GROUP_INVALID);
      }

      getValue(IDC_COMBO_GROUP, providerName);
   }
   else
   {
      providerName.Empty();
   }
}

void ProfileProvPage::setData()
{
   initControl(IDC_COMBO_GROUP, groupsCombo);
   groupsCombo.ResetContent();

   // Make sure that the provider name is specified if and only if the provider
   // type is RADIUS. In theory, we should never break this constraint, but we
   // may as well repair it just in case.
   if (providerType == 2)
   {
      if (!providerName) { providerType = 1; }
   }
   else
   {
      providerName.Empty();
   }

   // Flag indicating whether the group specified in providerName exists.
   bool groupExists = false;

   // Get the server groups.
   SdoCollection serverGroups = cxn.getServerGroups();

   // Are there any server groups configured?
   if (serverGroups.count())
   {
      // Yes, so add them to the combo box.
      Sdo group;
      SdoEnum sdoEnum = serverGroups.getNewEnum();
      while (sdoEnum.next(group))
      {
         CComBSTR name;
         group.getName(name);
         int index = groupsCombo.AddString(name);

         // We'll also look for our provider. We can't use
         // CComboBox::FindStringExact because it's not case-sensitive.
         if (providerName && !wcscmp(name, providerName))
         {
            // Select it in the combo box.
            groupsCombo.SetCurSel(index);
            // Set the flag.
            groupExists = true;
         }
      }
   }

   if (providerName && !groupExists)
   {
      // The provider name is no longer a valid server group. We'll add it in
      // anyway, so we don't change the existing policy.
      invalidGroup = groupsCombo.AddString(providerName);
      groupsCombo.SetCurSel(invalidGroup);
   }

   // If there aren't groups, ...
   if (!groupsCombo.GetCount())
   {
      // ... add the <None configured> string, and ..
      groupsCombo.AddString(ResourceString(IDS_POLICY_NO_GROUPS));
      // ... don't let the user choose RADIUS.
      enableControl(IDC_RADIO_RADIUS, false);
   }

   // If the provider isn't RADIUS, disable the combo box.
   if (providerType != 2)
   {
      groupsCombo.EnableWindow(FALSE);
   }

   // Make sure something is selected.
   if (groupsCombo.GetCurSel() == CB_ERR)
   {
      groupsCombo.SetCurSel(0);
   }
}

ProfileAuthPage::ProfileAuthPage(SdoConnection& connection, SdoProfile& p)
   : ProfileProvPage(IDD_PROXY_PROFILE_AUTH, connection),
     profile(p)
{
   profile.getValue(IAS_ATTRIBUTE_AUTH_PROVIDER_TYPE, providerType);
   profile.getValue(IAS_ATTRIBUTE_AUTH_PROVIDER_NAME, providerName);
}

void ProfileAuthPage::onProviderClick()
{
   groupsCombo.EnableWindow(IsDlgButtonChecked(IDC_RADIO_RADIUS));
   SetModified();
}

void ProfileAuthPage::getData()
{
   ProfileProvPage::getData();
   getRadio(IDC_RADIO_NONE, IDC_RADIO_RADIUS, providerType);
}

void ProfileAuthPage::setData()
{
   ProfileProvPage::setData();
   setRadio(IDC_RADIO_NONE, IDC_RADIO_RADIUS, providerType);
}

void ProfileAuthPage::saveChanges()
{
   profile.setValue(IAS_ATTRIBUTE_AUTH_PROVIDER_TYPE, providerType);

   if (providerName)
   {
      profile.setValue(IAS_ATTRIBUTE_AUTH_PROVIDER_NAME, providerName);
   }
   else
   {
      profile.clearValue(IAS_ATTRIBUTE_AUTH_PROVIDER_NAME);
   }
}

BEGIN_MESSAGE_MAP(ProfileAuthPage, SnapInPropertyPage)
   ON_BN_CLICKED(IDC_RADIO_NONE, onProviderClick)
   ON_BN_CLICKED(IDC_RADIO_WINDOWS, onProviderClick)
   ON_BN_CLICKED(IDC_RADIO_RADIUS, onProviderClick)
   ON_CBN_SELCHANGE(IDC_COMBO_GROUP, onChange)
END_MESSAGE_MAP()


ProfileAcctPage::ProfileAcctPage(SdoConnection& connection, SdoProfile& p)
   : ProfileProvPage(IDD_PROXY_PROFILE_ACCT, connection),
     profile(p)

{
   profile.getValue(IAS_ATTRIBUTE_ACCT_PROVIDER_TYPE, providerType);
   record = (providerType == 2);
   profile.getValue(IAS_ATTRIBUTE_ACCT_PROVIDER_NAME, providerName);
}

void ProfileAcctPage::onCheckRecord()
{
   groupsCombo.EnableWindow(IsDlgButtonChecked(IDC_CHECK_RECORD_ACCT));
   SetModified();
}

void ProfileAcctPage::getData()
{
   ProfileProvPage::getData();
   getValue(IDC_CHECK_RECORD_ACCT, record);
   providerType = record ? 2 : 1;
}

void ProfileAcctPage::setData()
{
   ProfileProvPage::setData();
   setValue(IDC_CHECK_RECORD_ACCT, record);
}

void ProfileAcctPage::saveChanges()
{
   if (record)
   {
      profile.setValue(IAS_ATTRIBUTE_ACCT_PROVIDER_TYPE, 2L);
      profile.setValue(IAS_ATTRIBUTE_ACCT_PROVIDER_NAME, providerName);
   }
   else
   {
      profile.clearValue(IAS_ATTRIBUTE_ACCT_PROVIDER_TYPE);
      profile.clearValue(IAS_ATTRIBUTE_ACCT_PROVIDER_NAME);
   }
}

BEGIN_MESSAGE_MAP(ProfileAcctPage, SnapInPropertyPage)
   ON_BN_CLICKED(IDC_CHECK_RECORD_ACCT, onCheckRecord)
   ON_CBN_SELCHANGE(IDC_COMBO_GROUP, onChange)
END_MESSAGE_MAP()

ProfileAttrPage::ProfileAttrPage(SdoConnection& cxn, SdoProfile& p)
   : SnapInPropertyPage(IDD_PROXY_PROFILE_ATTR),
     profile(p),
     targetId(RADIUS_ATTRIBUTE_USER_NAME)
{
   numTargets = cxn.getDictionary().enumAttributeValues(
                                        IAS_ATTRIBUTE_MANIPULATION_TARGET,
                                        targets
                                        );

   profile.getValue(IAS_ATTRIBUTE_MANIPULATION_TARGET, targetId);
   profile.getValue(IAS_ATTRIBUTE_MANIPULATION_RULE, rules);
}

ProfileAttrPage::~ProfileAttrPage() throw ()
{
   delete[] targets;
}

BOOL ProfileAttrPage::OnInitDialog()
{
   // Initialize the controls.
   initControl(IDC_COMBO_TARGET, ruleTarget);
   initControl(IDC_LIST_RULES, ruleList);

   /////////
   // Populate the target combo box.
   /////////

   for (ULONG i = 0; i < numTargets; ++i)
   {
      int index = ruleTarget.AddString(targets[i].name);

      ruleTarget.SetItemData(index, targets[i].id);
   }

   ruleTarget.SetCurSel(0);

   /////////
   // Set the column headers for the rules list.
   /////////

   RECT rect;
   ruleList.GetClientRect(&rect);
   LONG width = rect.right - rect.left;

   ResourceString findCol(IDS_RULE_COLUMN_FIND);
   ruleList.InsertColumn(0, findCol, LVCFMT_LEFT, (width + 1) / 2);

   ResourceString replaceCol(IDS_RULE_COLUMN_REPLACE);
   ruleList.InsertColumn(1, replaceCol, LVCFMT_LEFT, width / 2);

   ruleList.SetExtendedStyle(
                  ruleList.GetExtendedStyle() | LVS_EX_FULLROWSELECT
                  );

   return SnapInPropertyPage::OnInitDialog();
}

void ProfileAttrPage::onAdd()
{
   RuleEditor editor;
   if (editor.DoModal() == IDOK)
   {
      int index = ruleList.InsertItem(
                               ruleList.GetItemCount(),
                               editor.getFindString()
                               );
      ruleList.SetItemText(index, 1, editor.getReplaceString());

      SetModified();
   }

   onRuleChanged(NULL, NULL);
}

void ProfileAttrPage::onEdit()
{
   int item = ruleList.GetNextItem(-1, LVNI_SELECTED);
   if (item != -1)
   {
      RuleEditor editor(
                     ruleList.GetItemText(item, 0),
                     ruleList.GetItemText(item, 1)
                     );

      if (editor.DoModal() == IDOK)
      {
         ruleList.SetItemText(item, 0, editor.getFindString());
         ruleList.SetItemText(item, 1, editor.getReplaceString());
         SetModified();
      }
   }
}

void ProfileAttrPage::onRemove()
{
   int item = ruleList.GetNextItem(-1, LVNI_SELECTED);
   if (item != -1)
   {
      ruleList.DeleteItem(item);
      SetModified();
   }
}

void ProfileAttrPage::onMoveUp()
{
   int item = ruleList.GetNextItem(-1, LVNI_SELECTED);
   if (item > 0)
   {
      swapItems(item, item - 1);
   }
}

void ProfileAttrPage::onMoveDown()
{
   int item = ruleList.GetNextItem(-1, LVNI_SELECTED);
   if (item >= 0 && item < ruleList.GetItemCount() - 1)
   {
      swapItems(item, item + 1);
   }
}

void ProfileAttrPage::onRuleActivate(NMITEMACTIVATE*, LRESULT*)
{
   onEdit();
}

void ProfileAttrPage::onRuleChanged(NMLISTVIEW*, LRESULT*)
{
   int item = ruleList.GetNextItem(-1, LVNI_SELECTED);

   enableControl(
       IDC_BUTTON_MOVE_UP,
       (item > 0)
       );
   enableControl(
       IDC_BUTTON_MOVE_DOWN,
       (item >= 0 && item < ruleList.GetItemCount() - 1)
       );
   enableControl(
       IDC_BUTTON_REMOVE,
       (item != -1)
       );
   enableControl(
       IDC_BUTTON_EDIT,
       (item != -1)
       );
}

void ProfileAttrPage::getData()
{
   targetId = ruleTarget.GetItemData(ruleTarget.GetCurSel());

   rules.Clear();
   int nelem = ruleList.GetItemCount();
   if (nelem)
   {
      SAFEARRAYBOUND rgsabound = { 2 * nelem, 0 };
      V_VT(&rules) = VT_ARRAY | VT_VARIANT;
      V_ARRAY(&rules) = SafeArrayCreate(VT_VARIANT, 1, &rgsabound);
      if (!V_ARRAY(&rules)) { AfxThrowOleException(E_OUTOFMEMORY); }

      VARIANT* v = (VARIANT*)V_ARRAY(&rules)->pvData;

      for (int i = 0; i < nelem; i++)
      {
         V_VT(v) = VT_BSTR;
         V_BSTR(v) = SysAllocString(ruleList.GetItemText(i, 0));
         if (!V_BSTR(v)) { AfxThrowOleException(E_OUTOFMEMORY); }
         ++v;

         V_VT(v) = VT_BSTR;
         V_BSTR(v) = SysAllocString(ruleList.GetItemText(i, 1));
         if (!V_BSTR(v)) { AfxThrowOleException(E_OUTOFMEMORY); }
         ++v;
      }
   }
}

void ProfileAttrPage::setData()
{
   for (ULONG i = 0; i < numTargets; ++i)
   {
      if (targets[i].id == targetId)
      {
         ruleTarget.SelectString(-1, targets[i].name);
         break;
      }
   }

   /////////
   // Populate the existing rules.
   /////////

   ruleList.DeleteAllItems();

   if (V_VT(&rules) != VT_EMPTY)
   {
      ULONG nelem = V_ARRAY(&rules)->rgsabound[0].cElements / 2;
      VARIANT* v = (VARIANT*)V_ARRAY(&rules)->pvData;

      ruleList.SetItemCount(nelem);

      // Initialize an LVITEM.
      LVITEM lvi;
      memset(&lvi, 0, sizeof(LVITEM));
      lvi.mask = LVIF_TEXT;

      for (ULONG i = 0; i < nelem; ++i)
      {
         lvi.iItem = i;
         lvi.iSubItem = 0;
         lvi.pszText = V_BSTR(&v[i * 2]);
         lvi.iItem = ruleList.InsertItem(&lvi);

         lvi.iSubItem = 1;
         lvi.pszText = V_BSTR(&v[i * 2 + 1]);
         ruleList.SetItem(&lvi);
      }
   }

   onRuleChanged(NULL, NULL);
}

void ProfileAttrPage::saveChanges()
{
   if (V_VT(&rules) != VT_EMPTY)
   {
      profile.setValue(IAS_ATTRIBUTE_MANIPULATION_RULE, rules);
      profile.setValue(IAS_ATTRIBUTE_MANIPULATION_TARGET, targetId);
   }
   else
   {
      profile.clearValue(IAS_ATTRIBUTE_MANIPULATION_RULE);
      profile.clearValue(IAS_ATTRIBUTE_MANIPULATION_TARGET);
   }
}

BEGIN_MESSAGE_MAP(ProfileAttrPage, SnapInPropertyPage)
   ON_BN_CLICKED(IDC_BUTTON_ADD, onAdd)
   ON_BN_CLICKED(IDC_BUTTON_REMOVE, onRemove)
   ON_BN_CLICKED(IDC_BUTTON_EDIT, onEdit)
   ON_BN_CLICKED(IDC_BUTTON_MOVE_UP, onMoveUp)
   ON_BN_CLICKED(IDC_BUTTON_MOVE_DOWN, onMoveDown)
   ON_NOTIFY(LVN_ITEMACTIVATE, IDC_LIST_RULES, onRuleActivate)
   ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_RULES, onRuleChanged)
   ON_CBN_SELCHANGE(IDC_COMBO_TARGET, onChange)
END_MESSAGE_MAP()

void ProfileAttrPage::swapItems(int item1, int item2)
{
   ::CString find    = ruleList.GetItemText(item1, 0);
   ::CString replace = ruleList.GetItemText(item1, 1);

   ruleList.SetItemText(item1, 0, ruleList.GetItemText(item2, 0));
   ruleList.SetItemText(item1, 1, ruleList.GetItemText(item2, 1));

   ruleList.SetItemText(item2, 0, find);
   ruleList.SetItemText(item2, 1, replace);

   ruleList.SetItemState(item2, LVIS_SELECTED, LVIS_SELECTED);

   SetModified();
}

/////////
// Various definitions for the advanced page API exported from rasuser.dll
/////////

const WCHAR RASUSER_DLL[] = L"rasuser.dll";
const CHAR CREATE_PROC[] = "IASCreateProfileAdvancedPage";
const CHAR DELETE_PROC[] = "IASDeleteProfileAdvancedPage";

typedef HPROPSHEETPAGE (WINAPI *IASCreateProfileAdvancedPage_t)(
                                    ISdo* pProfile,
                                    ISdoDictionaryOld* pDictionary,
                                    LONG lFilter,
                                    void* pvData
                                    );

typedef BOOL (WINAPI *IASDeleteProfileAdvancedPage_t)(
                          HPROPSHEETPAGE  hPage
                          );

ProxyProfileProperties::ProxyProfileProperties(
                            Sdo& profileSdo,
                            SdoConnection& connection
                            )
   : CPropertySheet(IDS_PROFILE_CAPTION),
     profile(connection, profileSdo),
     profileStream(profile),
     auth(connection, profile),
     acct(connection, profile),
     attr(connection, profile),
     rasuser(NULL),
     advanced(NULL),
     applied(false),
     modified(false)
{
   AddPage(&auth);
   AddPage(&acct);
   AddPage(&attr);

   // Load the DLL with the advanced page.
   rasuser = LoadLibraryW(RASUSER_DLL);
   if (!rasuser) { AfxThrowLastError(); }

   // Look up the create proc.
   IASCreateProfileAdvancedPage_t IASCreateProfileAdvancedPage =
      (IASCreateProfileAdvancedPage_t)GetProcAddress(rasuser, CREATE_PROC);
   if (!IASCreateProfileAdvancedPage) { AfxThrowLastError(); }

   // Create the property page.
   advanced = IASCreateProfileAdvancedPage(
                  profileSdo,
                  connection.getDictionary(),
                  ALLOWEDINPROXYPROFILE,
                  ExtractCIASAttrList(connection.getCIASAttrList())
                  );
   if (!advanced) { AfxThrowLastError(); }
}

ProxyProfileProperties::~ProxyProfileProperties() throw ()
{
   if (rasuser)
   {
      // Look up the delete proc.
      IASDeleteProfileAdvancedPage_t IASDeleteProfileAdvancedPage =
         (IASDeleteProfileAdvancedPage_t)GetProcAddress(rasuser, DELETE_PROC);

      if (IASDeleteProfileAdvancedPage)
      {
         // Delete the property page.
         IASDeleteProfileAdvancedPage(advanced);
      }

      // Free the DLL.
      FreeLibrary(rasuser);
   }
}

BOOL ProxyProfileProperties::OnInitDialog()
{
   // Unmarshal the profile.
   profileStream.get(profile);

   // We use PostMessage since we can't add the page while handling WM_INIT.
   PostMessage(PSM_ADDPAGE, 0, (LPARAM)advanced);

   BOOL bResult = CPropertySheet::OnInitDialog();
   ModifyStyleEx(0, WS_EX_CONTEXTHELP);
   return bResult;
}

INT_PTR ProxyProfileProperties::DoModal()
{
   CPropertySheet::DoModal();
   return applied ? IDOK : IDCANCEL;
}

LRESULT ProxyProfileProperties::onChanged(WPARAM wParam, LPARAM lParam)
{
   // One of our pages sent the PSM_CHANGED message.
   modified = true;
   // Forward to the PropertySheet.
   return Default();
}

void ProxyProfileProperties::onOkOrApply()
{
   // The user clicked OK or Apply.
   if (modified)
   {
      // The modified pages have now been written.
      applied = true;
      modified = false;
   }
   Default();
}

BEGIN_MESSAGE_MAP(ProxyProfileProperties, CPropertySheet)
   ON_BN_CLICKED(IDOK, onOkOrApply)
   ON_BN_CLICKED(ID_APPLY_NOW, onOkOrApply)
   ON_MESSAGE(PSM_CHANGED, onChanged)
END_MESSAGE_MAP()

RuleEditor::RuleEditor(PCWSTR szFind, PCWSTR szReplace)
   : CHelpDialog(IDD_EDIT_RULE),
     find(szFind),
     replace(szReplace)
{ }

void RuleEditor::DoDataExchange(CDataExchange* pDX)
{
   DDX_Text(pDX, IDC_EDIT_RULE_FIND, find);
   if (pDX->m_bSaveAndValidate && find.IsEmpty())
   {
      MessageBox(
          ResourceString(IDS_POLICY_E_FIND_EMPTY),
          ResourceString(IDS_POLICY_E_CAPTION),
          MB_ICONWARNING
          );
      pDX->Fail();
   }
   DDX_Text(pDX, IDC_EDIT_RULE_REPLACE, replace);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\policywiz.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    policywiz.h
//
// SYNOPSIS
//
//    Declares the classes that implement the new proxy policy wizard.
//
// MODIFICATION HISTORY
//
//    03/11/2000    Original version.
//    04/19/2000    Marshall SDOs across apartments.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef POLICYWIZ_H
#define POLICYWIZ_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <condlist.h>

class NewPolicyWizard;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NewPolicyStartPage
//
// DESCRIPTION
//
//    Implements the Welcome page.
//
///////////////////////////////////////////////////////////////////////////////
class NewPolicyStartPage : public SnapInPropertyPage
{
public:
   NewPolicyStartPage(NewPolicyWizard& wizard);

protected:
   virtual BOOL OnInitDialog();
   virtual BOOL OnSetActive();

   DEFINE_ERROR_CAPTION(IDS_POLICY_E_CAPTION);

private:
   NewPolicyWizard& parent;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NewPolicyNamePage
//
// DESCRIPTION
//
//    Implements the page where the user chooses the policy name.
//
///////////////////////////////////////////////////////////////////////////////
class NewPolicyNamePage : public SnapInPropertyPage
{
public:
   NewPolicyNamePage(NewPolicyWizard& wizard);

   PCWSTR getName() const throw ()
   { return name; }

protected:
   virtual LRESULT OnWizardNext();

   afx_msg void onButtonClick();
   afx_msg void onChangeName();

   DECLARE_MESSAGE_MAP()

   DEFINE_ERROR_CAPTION(IDS_POLICY_E_CAPTION);

   virtual void setData();

   void setButtons();

private:
   NewPolicyWizard& parent;
   CComBSTR name;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NewPolicyTypePage
//
// DESCRIPTION
//
//    Implements the page where the user chooses the policy type.
//
///////////////////////////////////////////////////////////////////////////////
class NewPolicyTypePage : public SnapInPropertyPage
{
public:
   NewPolicyTypePage(NewPolicyWizard& wizard);

protected:
   virtual LRESULT OnWizardNext();

   afx_msg void onButtonClick(UINT id);

   DECLARE_MESSAGE_MAP()

   DEFINE_ERROR_CAPTION(IDS_POLICY_E_CAPTION);

   virtual void setData();
   void setControlState();

private:
   NewPolicyWizard& parent;
   LONG outerType;
   LONG innerType;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NewPolicyOutsourcePage
//
// DESCRIPTION
//
//    Implements the page for outsourced dial.
//
///////////////////////////////////////////////////////////////////////////////
class NewPolicyOutsourcePage : public SnapInPropertyPage
{
public:
   NewPolicyOutsourcePage(NewPolicyWizard& wizard);

   PCWSTR getRealm() const throw ()
   { return realm; }

   bool isStripped() const throw ()
   { return strip; }

protected:
   virtual LRESULT OnWizardBack();
   virtual LRESULT OnWizardNext();

   afx_msg void onChangeRealm();

   DECLARE_MESSAGE_MAP()

   DEFINE_ERROR_CAPTION(IDS_POLICY_E_CAPTION);

   virtual void setData();

   void setButtons();

private:
   NewPolicyWizard& parent;
   CComBSTR realm;
   bool strip;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NewPolicyDirectPage
//
// DESCRIPTION
//
//    Implements the page for dial-up and VPN directly to the corp.
//
///////////////////////////////////////////////////////////////////////////////
class NewPolicyDirectPage : public SnapInPropertyPage
{
public:
   NewPolicyDirectPage(NewPolicyWizard& wizard);

protected:
   virtual BOOL OnInitDialog();
   virtual BOOL OnSetActive();
   virtual LRESULT OnWizardBack();

   DEFINE_ERROR_CAPTION(IDS_POLICY_E_CAPTION);

private:
   NewPolicyWizard& parent;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NewPolicyForwardPage
//
// DESCRIPTION
//
//    Implements the page for forwarding to a RADIUS server group.
//
///////////////////////////////////////////////////////////////////////////////
class NewPolicyForwardPage : public SnapInPropertyPage
{
public:
   NewPolicyForwardPage(NewPolicyWizard& wizard);

   PCWSTR getRealm() const throw ()
   { return realm; }

   PCWSTR getGroup() const throw ()
   { return providerName; }

   bool isStripped() const throw ()
   { return strip; }

protected:
   virtual LRESULT OnWizardBack();
   virtual LRESULT OnWizardNext();

   afx_msg void onChangeRealm();
   afx_msg void onNewGroup();

   DECLARE_MESSAGE_MAP()

   DEFINE_ERROR_CAPTION(IDS_POLICY_E_CAPTION);

   virtual void setData();

   void setButtons();

private:
   NewPolicyWizard& parent;
   SdoCollection serverGroups;
   CComboBox groupsCombo;
   CComBSTR realm;
   CComBSTR providerName;
   bool strip;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NewPolicyConditionPage
//
// DESCRIPTION
//
//    Implements the page for editing the conditions.
//
///////////////////////////////////////////////////////////////////////////////
class NewPolicyConditionPage : public SnapInPropertyPage
{
public:
   NewPolicyConditionPage(NewPolicyWizard& wizard);

protected:
   virtual BOOL OnInitDialog();
   virtual LRESULT OnWizardBack();
   virtual LRESULT OnWizardNext();

   afx_msg void onAdd();
   afx_msg void onEdit();
   afx_msg void onRemove();

   DECLARE_MESSAGE_MAP()

   DEFINE_ERROR_CAPTION(IDS_POLICY_E_CAPTION);

   virtual void setData();

   void setButtons();

private:
   NewPolicyWizard& parent;
   CListBox listBox;
   ConditionList condList;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NewPolicyProfilePage
//
// DESCRIPTION
//
//    Implements the page for editing the profile.
//
///////////////////////////////////////////////////////////////////////////////
class NewPolicyProfilePage : public SnapInPropertyPage
{
public:
   NewPolicyProfilePage(NewPolicyWizard& wizard);

protected:
   virtual BOOL OnSetActive();

   afx_msg void onEditProfile();

   DECLARE_MESSAGE_MAP()

   DEFINE_ERROR_CAPTION(IDS_POLICY_E_CAPTION);

private:
   NewPolicyWizard& parent;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NewPolicyFinishPage
//
// DESCRIPTION
//
//    Implements the completion page.
//
///////////////////////////////////////////////////////////////////////////////
class NewPolicyFinishPage : public SnapInPropertyPage
{
public:
   NewPolicyFinishPage(NewPolicyWizard& wizard);

protected:
   virtual BOOL OnInitDialog();
   virtual LRESULT OnWizardBack();

   DEFINE_ERROR_CAPTION(IDS_POLICY_E_CAPTION);

   virtual void setData();
   virtual void saveChanges();

private:
   NewPolicyWizard& parent;
   CRichEditCtrl tasks;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NewPolicyWizard
//
// DESCRIPTION
//
//    Implements the new proxy policy wizard.
//
///////////////////////////////////////////////////////////////////////////////
class NewPolicyWizard : public CPropertySheetEx
{
public:
   NewPolicyWizard(
       SdoConnection& connection,
       SnapInView* snapInView = NULL
       );

   virtual INT_PTR DoModal();

   ::CString getFinishText();

   enum Type
   {
      OUTSOURCED,
      DIRECT,
      FORWARD,
      CUSTOM
   };

   Type getType() const throw ();

   SdoConnection& cxn;
   SnapInView* view;

   //////////
   // Public properties used by the wizard pages.
   //////////

   Sdo policy;
   Sdo profile;
   SdoCollection conditions;
   SdoProfile attributes;
   LONG custom;
   LONG radius;
   LONG dialin;

protected:
   virtual BOOL OnInitDialog();

private:
   SdoStream<Sdo> policyStream;
   SdoStream<Sdo> profileStream;

   NewPolicyStartPage start;
   NewPolicyNamePage name;
   NewPolicyTypePage type;
   NewPolicyOutsourcePage outsource;
   NewPolicyDirectPage direct;
   NewPolicyForwardPage forward;
   NewPolicyConditionPage condition;
   NewPolicyProfilePage profilePage;
   NewPolicyFinishPage finish;
};

#endif // POLICYWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\policywiz.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    policywiz.cpp
//
// SYNOPSIS
//
//    Defines the  classes that implement the new proxy policy wizard.
//
// MODIFICATION HISTORY
//
//    03/11/2000    Original version.
//    04/19/2000    Marshall SDOs across apartments.
//    05/15/2000    Don't reset the list of conditions every time we display
//                  the conditions wizard page.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <profileprop.h>
#include <groupwiz.h>
#include <policywiz.h>

// Set a policy to match on a given realm.
void SetRealmCondition(SdoCollection& conditions, PCWSTR realm)
{
   // Remove any existing conditions.
   conditions.removeAll();

   // Create a new condition object.
   Sdo condition = conditions.create();

   // Form the match condition.
   CComBSTR text = L"MATCH(\"User-Name=";
   text.Append(realm);
   text.Append(L"\")");
   if (!text) { AfxThrowOleException(E_OUTOFMEMORY); }

   // Set the condition text.
   condition.setValue(PROPERTY_CONDITION_TEXT, text);
}

// Add a rule to a profile to strip a realm.
void AddRealmStrippingRule(SdoProfile& profile, PCWSTR realm)
{
   // Target is always User-Name for realms.
   profile.setValue(IAS_ATTRIBUTE_MANIPULATION_TARGET, 1L);

   CComVariant rule;

   // Allocate a SAFEARRAY to hold the rule.
   SAFEARRAYBOUND rgsabound = { 2 , 0 };
   V_VT(&rule) = VT_ARRAY | VT_VARIANT;
   V_ARRAY(&rule) = SafeArrayCreate(VT_VARIANT, 1, &rgsabound);
   if (!V_ARRAY(&rule)) { AfxThrowOleException(E_OUTOFMEMORY); }

   VARIANT* v = (VARIANT*)V_ARRAY(&rule)->pvData;

   // Find the realm.
   V_VT(v) = VT_BSTR;
   V_BSTR(v) = SysAllocString(realm);
   if (!V_BSTR(v)) { AfxThrowOleException(E_OUTOFMEMORY); }
   ++v;

   // Replace with nothing.
   V_VT(v) = VT_BSTR;
   V_BSTR(v) = SysAllocString(L"");
   if (!V_BSTR(v)) { AfxThrowOleException(E_OUTOFMEMORY); }

   // Add the attribute to the profile.
   profile.setValue(IAS_ATTRIBUTE_MANIPULATION_RULE, rule);
}

NewPolicyStartPage::NewPolicyStartPage(NewPolicyWizard& wizard)
   : SnapInPropertyPage(IDD_NEWPOLICY_WELCOME, 0, 0, false),
     parent(wizard)
{
}

BOOL NewPolicyStartPage::OnInitDialog()
{
   SnapInPropertyPage::OnInitDialog();
   setLargeFont(IDC_STATIC_LARGE);
   return TRUE;
}

BOOL NewPolicyStartPage::OnSetActive()
{
   SnapInPropertyPage::OnSetActive();
   parent.SetWizardButtons(PSWIZB_NEXT);
   return TRUE;
}

NewPolicyNamePage::NewPolicyNamePage(NewPolicyWizard& wizard)
   : SnapInPropertyPage(
         IDD_NEWPOLICY_NAME,
         IDS_NEWPOLICY_NAME_TITLE,
         IDS_NEWPOLICY_NAME_SUBTITLE,
         false
         ),
     parent(wizard)
{
}

LRESULT NewPolicyNamePage::OnWizardNext()
{
   // Make sure the name is unique.
   if (!parent.policy.setName(name))
   {
      failNoThrow(IDC_EDIT_NAME, IDS_POLICY_E_NOT_UNIQUE);
      return -1;
   }

   // Keep the profile in sync with the policy.
   parent.policy.setValue(PROPERTY_POLICY_PROFILE_NAME, name);
   parent.profile.setName(name);

   // Advance based on the type.
   if (parent.getType() == NewPolicyWizard::CUSTOM)
   {
      return IDD_NEWPOLICY_CONDITIONS;
   }
   else
   {
      return IDD_NEWPOLICY_TYPE;
   }
}

void NewPolicyNamePage::onButtonClick()
{
   getRadio(IDC_RADIO_TYPICAL, IDC_RADIO_CUSTOM, parent.custom);
}

void NewPolicyNamePage::onChangeName()
{
   getValue(IDC_EDIT_NAME, name);
   setButtons();
}

void NewPolicyNamePage::setData()
{
   setValue(IDC_EDIT_NAME, name);
   setRadio(IDC_RADIO_TYPICAL, IDC_RADIO_CUSTOM, parent.custom);
   setButtons();
}

void NewPolicyNamePage::setButtons()
{
   parent.SetWizardButtons(
              name.Length() ? (PSWIZB_BACK | PSWIZB_NEXT) : PSWIZB_BACK
              );
}

BEGIN_MESSAGE_MAP(NewPolicyNamePage, SnapInPropertyPage)
   ON_BN_CLICKED(IDC_RADIO_TYPICAL, onButtonClick)
   ON_BN_CLICKED(IDC_RADIO_CUSTOM, onButtonClick)
   ON_EN_CHANGE(IDC_EDIT_NAME, onChangeName)
END_MESSAGE_MAP()

NewPolicyTypePage::NewPolicyTypePage(NewPolicyWizard& wizard)
   : SnapInPropertyPage(
         IDD_NEWPOLICY_TYPE,
         IDS_NEWPOLICY_TYPE_TITLE,
         IDS_NEWPOLICY_TYPE_SUBTITLE,
         false
         ),
     parent(wizard)
{
}

LRESULT NewPolicyTypePage::OnWizardNext()
{
   switch (parent.getType())
   {
      case NewPolicyWizard::OUTSOURCED:
         return IDD_NEWPOLICY_OUTSOURCE;

      case NewPolicyWizard::DIRECT:
         return IDD_NEWPOLICY_NOTNEEDED;

      default:
         return IDD_NEWPOLICY_FORWARD;
   }
}

void NewPolicyTypePage::onButtonClick(UINT id)
{
   switch (id)
   {
      case IDC_RADIO_LOCAL:
      case IDC_RADIO_FORWARD:
         getRadio(IDC_RADIO_LOCAL, IDC_RADIO_FORWARD, parent.radius);
         setControlState();
         break;

      case IDC_RADIO_OUTSOURCE:
      case IDC_RADIO_DIRECT:
         getRadio(IDC_RADIO_OUTSOURCE, IDC_RADIO_DIRECT, parent.dialin);
   }
}

void NewPolicyTypePage::setData()
{
   // Set the radio buttons.
   setRadio(IDC_RADIO_LOCAL, IDC_RADIO_FORWARD, parent.radius);
   setRadio(IDC_RADIO_OUTSOURCE, IDC_RADIO_DIRECT, parent.dialin);

   // Update the control state.
   setControlState();
}

void NewPolicyTypePage::setControlState()
{
   // Enable/disable the inner radio buttons.
   enableControl(IDC_RADIO_OUTSOURCE, !parent.radius);
   enableControl(IDC_RADIO_DIRECT, !parent.radius);

   // Enable the wizard buttons.
   parent.SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
}

BEGIN_MESSAGE_MAP(NewPolicyTypePage, SnapInPropertyPage)
   ON_CONTROL_RANGE(
       BN_CLICKED,
       IDC_RADIO_LOCAL,
       IDC_RADIO_DIRECT,
       onButtonClick
       )
END_MESSAGE_MAP()

NewPolicyOutsourcePage::NewPolicyOutsourcePage(NewPolicyWizard& wizard)
   : SnapInPropertyPage(
         IDD_NEWPOLICY_OUTSOURCE,
         IDS_NEWPOLICY_OUTSRC_TITLE,
         IDS_NEWPOLICY_OUTSRC_SUBTITLE,
         false
         ),
     parent(wizard),
     strip(true)
{
}

LRESULT NewPolicyOutsourcePage::OnWizardBack()
{
   // Save the strip checkbox.
   getValue(IDC_CHECK_STRIP, strip);
   return IDD_NEWPOLICY_TYPE;
}

LRESULT NewPolicyOutsourcePage::OnWizardNext()
{
   // The policy triggers based on realm.
   SetRealmCondition(parent.conditions, realm);

   // We use Windows authentication.
   parent.attributes.clear();
   parent.attributes.setValue(IAS_ATTRIBUTE_AUTH_PROVIDER_TYPE, 1L);

   // If the user wants to strip the realm, ...
   getValue(IDC_CHECK_STRIP, strip);
   if (strip)
   {
      // ... then add a rule.
      AddRealmStrippingRule(parent.attributes, realm);
   }

   return IDD_NEWPOLICY_COMPLETION;
}

void NewPolicyOutsourcePage::onChangeRealm()
{
   getValue(IDC_EDIT_REALM, realm);
   setButtons();
}

void NewPolicyOutsourcePage::setData()
{
   setValue(IDC_EDIT_REALM, realm);
   setValue(IDC_CHECK_STRIP, strip);
   setButtons();
}

void NewPolicyOutsourcePage::setButtons()
{
   parent.SetWizardButtons(
              realm.Length() ? (PSWIZB_BACK | PSWIZB_NEXT) : PSWIZB_BACK
              );
}

BEGIN_MESSAGE_MAP(NewPolicyOutsourcePage, SnapInPropertyPage)
   ON_EN_CHANGE(IDC_EDIT_REALM, onChangeRealm)
END_MESSAGE_MAP()

NewPolicyDirectPage::NewPolicyDirectPage(NewPolicyWizard& wizard)
   : SnapInPropertyPage(IDD_NEWPOLICY_NOTNEEDED, 0, 0, false),
     parent(wizard)
{
}

BOOL NewPolicyDirectPage::OnInitDialog()
{
   SnapInPropertyPage::OnInitDialog();
   setLargeFont(IDC_STATIC_LARGE);
   return TRUE;
}

BOOL NewPolicyDirectPage::OnSetActive()
{
   SnapInPropertyPage::OnSetActive();
   parent.SetWizardButtons(PSWIZB_FINISH | PSWIZB_BACK);
   return TRUE;
}

LRESULT NewPolicyDirectPage::OnWizardBack()
{
   return IDD_NEWPOLICY_TYPE;
}

NewPolicyForwardPage::NewPolicyForwardPage(NewPolicyWizard& wizard)
   : SnapInPropertyPage(
         IDD_NEWPOLICY_FORWARD,
         IDS_NEWPOLICY_FWD_TITLE,
         IDS_NEWPOLICY_FWD_SUBTITLE,
         false
         ),
     parent(wizard),
     strip(true)
{
}

LRESULT NewPolicyForwardPage::OnWizardBack()
{
   // Save the data.
   getValue(IDC_CHECK_STRIP, strip);
   getValue(IDC_COMBO_GROUP, providerName);
   return IDD_NEWPOLICY_TYPE;
}

LRESULT NewPolicyForwardPage::OnWizardNext()
{
   // The policy triggers based on realm.
   SetRealmCondition(parent.conditions, realm);

   // Get the RADIUS server group.
   getValue(IDC_COMBO_GROUP, providerName);

   parent.attributes.clear();

   // Set both authentication and accounting to use the group.
   parent.attributes.setValue(IAS_ATTRIBUTE_AUTH_PROVIDER_TYPE, 2L);
   parent.attributes.setValue(IAS_ATTRIBUTE_AUTH_PROVIDER_NAME, providerName);
   parent.attributes.setValue(IAS_ATTRIBUTE_ACCT_PROVIDER_TYPE, 2L);
   parent.attributes.setValue(IAS_ATTRIBUTE_ACCT_PROVIDER_NAME, providerName);

   // If the user wants to strip the realm, ...
   getValue(IDC_CHECK_STRIP, strip);
   if (strip)
   {
      // ... then add a rule.
      AddRealmStrippingRule(parent.attributes, realm);
   }

   return IDD_NEWPOLICY_COMPLETION;
}

void NewPolicyForwardPage::onChangeRealm()
{
   getValue(IDC_EDIT_REALM, realm);
   setButtons();
}

void NewPolicyForwardPage::onNewGroup()
{
   // Fire up the wizard.
   NewGroupWizard wizard(parent.cxn, parent.view);
   if (wizard.DoModal() != IDCANCEL)
   {
      // Set the provider name to the group just created.
      wizard.group.getName(providerName);

      // Repopulate the combo box.
      setData();
   }
}

void NewPolicyForwardPage::setData()
{
   // Set the realm information.
   setValue(IDC_EDIT_REALM, realm);
   setValue(IDC_CHECK_STRIP, strip);

   initControl(IDC_COMBO_GROUP, groupsCombo);
   groupsCombo.ResetContent();

   // Get the server groups collection if necessary.
   if (!serverGroups) { serverGroups = parent.cxn.getServerGroups(); }

   // Are there any server groups configured?
   if (serverGroups.count())
   {
      // Yes, so add them to the combo box.
      Sdo group;
      SdoEnum sdoEnum = serverGroups.getNewEnum();
      while (sdoEnum.next(group))
      {
         CComBSTR name;
         group.getName(name);
         int index = groupsCombo.AddString(name);

         // We'll also look for our provider. We can't use
         // CComboBox::FindStringExact because it's not case-sensitive.
         if (providerName && !wcscmp(name, providerName))
         {
            // Select it in the combo box.
            groupsCombo.SetCurSel(index);
         }
      }
      groupsCombo.EnableWindow(TRUE);
   }
   else
   {
      // If there aren't groups, add the <None configured> string.
      groupsCombo.AddString(ResourceString(IDS_POLICY_NO_GROUPS));
      groupsCombo.EnableWindow(FALSE);
   }

   // Make sure something is selected.
   if (groupsCombo.GetCurSel() == CB_ERR)
   {
      groupsCombo.SetCurSel(0);
   }

   setButtons();
}

void NewPolicyForwardPage::setButtons()
{
   DWORD buttons = PSWIZB_BACK;
   if (realm.Length() && serverGroups.count())
   {
      buttons |= PSWIZB_NEXT;
   }

   parent.SetWizardButtons(buttons);
}

BEGIN_MESSAGE_MAP(NewPolicyForwardPage, SnapInPropertyPage)
   ON_EN_CHANGE(IDC_EDIT_REALM, onChangeRealm)
   ON_BN_CLICKED(IDC_BUTTON_NEWGROUP, onNewGroup)
END_MESSAGE_MAP()

NewPolicyConditionPage::NewPolicyConditionPage(NewPolicyWizard& wizard)
   : SnapInPropertyPage(
         IDD_NEWPOLICY_CONDITIONS,
         IDS_NEWPOLICY_COND_TITLE,
         IDS_NEWPOLICY_COND_SUBTITLE,
         false
         ),
     parent(wizard)
{
}

BOOL NewPolicyConditionPage::OnInitDialog()
{
   initControl(IDC_LIST_POLICYPAGE1_CONDITIONS, listBox);

   CComBSTR name;
   parent.policy.getName(name);

   condList.finalConstruct(
                m_hWnd,
                parent.cxn.getCIASAttrList(),
                ALLOWEDINPROXYCONDITION,
                parent.cxn.getDictionary(),
                parent.conditions,
                parent.cxn.getMachineName(),
                name
                );

   condList.onInitDialog();

   return SnapInPropertyPage::OnInitDialog();
}

LRESULT NewPolicyConditionPage::OnWizardBack()
{
   return IDD_NEWPOLICY_NAME;
}

LRESULT NewPolicyConditionPage::OnWizardNext()
{
   condList.onApply();
   return 0;
}

void NewPolicyConditionPage::onAdd()
{
   BOOL modified = FALSE;
   condList.onAdd(modified);
   if (modified) { setButtons(); }
}

void NewPolicyConditionPage::onEdit()
{
   BOOL handled, modified = FALSE;
   condList.onEdit(modified, handled);
}

void NewPolicyConditionPage::onRemove()
{
   BOOL handled, modified = FALSE;
   condList.onRemove(modified, handled);
   if (modified) { setButtons(); }
}

void NewPolicyConditionPage::setData()
{
   setButtons();
}

void NewPolicyConditionPage::setButtons()
{
   parent.SetWizardButtons(
              listBox.GetCount() ? (PSWIZB_BACK | PSWIZB_NEXT) : PSWIZB_BACK
              );
}

BEGIN_MESSAGE_MAP(NewPolicyConditionPage, SnapInPropertyPage)
   ON_BN_CLICKED(IDC_BUTTON_CONDITION_ADD, onAdd)
   ON_BN_CLICKED(IDC_BUTTON_CONDITION_EDIT, onEdit)
   ON_BN_CLICKED(IDC_BUTTON_CONDITION_REMOVE, onRemove)
   ON_LBN_DBLCLK(IDC_LIST_CONDITIONS, onEdit)
END_MESSAGE_MAP()

NewPolicyProfilePage::NewPolicyProfilePage(NewPolicyWizard& wizard)
   : SnapInPropertyPage(
         IDD_NEWPOLICY_PROFILE,
         IDS_NEWPOLICY_PROF_TITLE,
         IDS_NEWPOLICY_PROF_SUBTITLE,
         false
         ),
     parent(wizard)
{
}

BOOL NewPolicyProfilePage::OnSetActive()
{
   SnapInPropertyPage::OnSetActive();
   parent.SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
   return TRUE;
}

void NewPolicyProfilePage::onEditProfile()
{
   ProxyProfileProperties profile(parent.profile, parent.cxn);
   profile.DoModal();
}

BEGIN_MESSAGE_MAP(NewPolicyProfilePage, SnapInPropertyPage)
   ON_BN_CLICKED(IDC_BUTTON_EDIT, onEditProfile)
END_MESSAGE_MAP()

NewPolicyFinishPage::NewPolicyFinishPage(NewPolicyWizard& wizard)
   : SnapInPropertyPage(IDD_NEWPOLICY_COMPLETION, 0, 0, false),
     parent(wizard)
{
}

BOOL NewPolicyFinishPage::OnInitDialog()
{
   setLargeFont(IDC_STATIC_LARGE);

   initControl(IDC_RICHEDIT_TASKS, tasks);

   return SnapInPropertyPage::OnInitDialog();
}

LRESULT NewPolicyFinishPage::OnWizardBack()
{
   switch (parent.getType())
   {
      case NewPolicyWizard::OUTSOURCED:
         return IDD_NEWPOLICY_OUTSOURCE;

      case NewPolicyWizard::FORWARD:
         return IDD_NEWPOLICY_FORWARD;

      default:
         return IDD_NEWPOLICY_PROFILE;
   }
}

void NewPolicyFinishPage::setData()
{
   parent.SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);
   tasks.SetWindowText(parent.getFinishText());
}

void NewPolicyFinishPage::saveChanges()
{
   // Persist the policy and profile.
   parent.policy.apply();
   parent.profile.apply();
}

NewPolicyWizard::NewPolicyWizard(
                     SdoConnection& connection,
                     SnapInView* snapInView
                     )
   : CPropertySheetEx(
         (UINT)0,
         NULL,
         0,
         LoadBitmapW(
             AfxGetResourceHandle(),
             MAKEINTRESOURCEW(IDB_PROXY_POLICY_WATERMARK)
         ),
         NULL,
         LoadBitmapW(
             AfxGetResourceHandle(),
             MAKEINTRESOURCEW(IDB_PROXY_POLICY_HEADER)
             )
         ),
     cxn(connection),
     view(snapInView),
     attributes(connection),
     custom(0),
     radius(0),
     dialin(0),
     start(*this),
     name(*this),
     type(*this),
     outsource(*this),
     direct(*this),
     forward(*this),
     condition(*this),
     profilePage(*this),
     finish(*this)
{
   m_psh.dwFlags |= PSH_WIZARD97;

   AddPage(&start);
   AddPage(&name);
   AddPage(&type);
   AddPage(&outsource);
   AddPage(&direct);
   AddPage(&forward);
   AddPage(&condition);
   AddPage(&profilePage);
   AddPage(&finish);
}

INT_PTR NewPolicyWizard::DoModal()
{
   int retval = CPropertySheetEx::DoModal();

   if (retval == IDCANCEL || getType() == DIRECT)
   {
      // Unmarshal the SDOs.
      policyStream.get(policy);
      profileStream.get(profile);

      // User cancelled, so remove the policy and profile.
      cxn.getProxyPolicies().remove(policy);
      cxn.getProxyProfiles().remove(profile);
   }
   else if (view)
   {
      // User created a policy, so send a propertyChanged notification.
      cxn.propertyChanged(
              *view,
              PROPERTY_IAS_PROXYPOLICIES_COLLECTION
              );
   }

   return retval;
}

// Returns a string representation for a provider.
::CString GetProvider(
              SdoProfile& profile,
              ATTRIBUTEID typeId,
              ATTRIBUTEID nameId
              )
{
   // Get the provider type. Default is Windows.
   LONG type = 1;
   profile.getValue(typeId, type);

   // Convert to a string.
   ::CString provider;
   switch (type)
   {
      case 1:
      {
         // Windows.
         provider.LoadString(IDS_NEWPOLICY_PROVIDER_WINDOWS);
         break;
      }

      case 2:
      {
         // RADIUS, so use the server group name.
         CComBSTR name;
         profile.getValue(nameId, name);
         provider = name;
         break;
      }

      default:
      {
         // None.
         provider.LoadString(IDS_NEWPOLICY_PROVIDER_NONE);
      }
   }

   return provider;
}

::CString NewPolicyWizard::getFinishText()
{
   using ::CString;

   /////////
   // Get the insertion strings.
   /////////

   // Policy name.
   CComBSTR policyName;
   policy.getName(policyName);

   // List of conditions.
   ConditionList condList;
   condList.finalConstruct(
                NULL,
                cxn.getCIASAttrList(),
                ALLOWEDINPROXYCONDITION,
                cxn.getDictionary(),
                conditions,
                cxn.getMachineName(),
                policyName
                );
   CString conditionText = condList.getDisplayText();

   // Authentication provider.
   CString authProvider = GetProvider(
                              attributes,
                              IAS_ATTRIBUTE_AUTH_PROVIDER_TYPE,
                              IAS_ATTRIBUTE_AUTH_PROVIDER_NAME
                              );

   // Accounting provider.
   CString acctProvider = GetProvider(
                              attributes,
                              IAS_ATTRIBUTE_ACCT_PROVIDER_TYPE,
                              IAS_ATTRIBUTE_ACCT_PROVIDER_NAME
                              );

   //////////
   // Format the finish text.
   //////////

   CString finishText;
   finishText.FormatMessage(
                  IDS_NEWPOLICY_FINISH_TEXT,
                  (PCWSTR)policyName,
                  (PCWSTR)conditionText,
                  (PCWSTR)authProvider,
                  (PCWSTR)acctProvider
                  );

   return finishText;
}

NewPolicyWizard::Type NewPolicyWizard::getType() const throw ()
{
   if (custom) { return CUSTOM; }

   if (radius) { return FORWARD; }

   if (dialin) { return DIRECT; }

   return OUTSOURCED;
}

BOOL NewPolicyWizard::OnInitDialog()
{
   // Create the new policy and save it in a stream so we can access it from
   // DoModal.
   policy = cxn.getProxyPolicies().create();
   policyStream.marshal(policy);

   // Create the corresponding profile.
   profile = cxn.getProxyProfiles().create();
   profileStream.marshal(profile);

   // Set the merit to zero, so it'll be the highest priority policy.
   policy.setValue(PROPERTY_POLICY_MERIT, 0L);

   // Get the conditions collection.
   policy.getValue(PROPERTY_POLICY_CONDITIONS_COLLECTION, conditions);

   // Load the profile attributes.
   attributes = profile;

   // The auth provider is mandatory, so we'll default it to Windows for now.
   attributes.setValue(IAS_ATTRIBUTE_AUTH_PROVIDER_TYPE, 1L);

   return CPropertySheetEx::OnInitDialog();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\proxyext.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    proxyext.h
//
// SYNOPSIS
//
//    Declares the class ProxyExtension
//
// MODIFICATION HISTORY
//
//    02/19/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef PROXYEXT_H
#define PROXYEXT_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <proxyres.h>
#include <snapwork.h>

class ProxyNode;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ProxyExtension
//
// DESCRIPTION
//
//    Implements IComponentData for the IAS Proxy extension snap-in.
//
///////////////////////////////////////////////////////////////////////////////
class __declspec(uuid("4d208bd4-c96b-492b-b727-3d1aed56db7e")) ProxyExtension;
class ProxyExtension :
   public SnapInView,
   public CComCoClass< ProxyExtension, &__uuidof(ProxyExtension) >
{
public:

DECLARE_NOT_AGGREGATABLE(ProxyExtension);
DECLARE_NO_REGISTRY();

   ProxyExtension() throw ();
   ~ProxyExtension() throw ();

   virtual const SnapInToolbarDef* getToolbars() const throw ();

   // IComponentData
   STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
   STDMETHOD(Notify)(
                 LPDATAOBJECT lpDataObject,
                 MMC_NOTIFY_TYPE event,
                 LPARAM arg,
                 LPARAM param
                 );

private:
   CComPtr<ProxyNode> node;  // The lone proxy node.

   // Toolbar definition.
   ResourceString moveUp;
   ResourceString moveDown;
   MMCBUTTON buttons[2];
   SnapInToolbarDef toolbars[2];
};

#endif // PROXYEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\proxynode.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    proxynode.h
//
// SYNOPSIS
//
//    Declares the class ProxyNode
//
// MODIFICATION HISTORY
//
//    02/19/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef PROXYNODE_H
#define PROXYNODE_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <hiddenworker.h>

class ProxyPolicies;
class ServerGroups;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ProxyNode
//
// DESCRIPTION
//
//    The data item for the Proxy node.
//
///////////////////////////////////////////////////////////////////////////////
class __declspec(uuid("fab6fa0a-1e4f-4c2e-bc07-692cf4adaec1")) ProxyNode;
class ProxyNode : public SnapInPreNamedItem
{
public:
   ProxyNode(
       SnapInView& view,
       IDataObject* parentData,
       HSCOPEITEM parentId
       );

   // SnapInDataItem methods.
   const GUID* getNodeType() const throw ()
   { return &__uuidof(this); }

   virtual HRESULT getResultViewType(
                       LPOLESTR* ppViewType,
                       long* pViewOptions
                       ) throw ();
   virtual HRESULT onExpand(
                       SnapInView& view,
                       HSCOPEITEM itemId,
                       BOOL expanded
                       );
   virtual HRESULT onShow(
                       SnapInView& view,
                       HSCOPEITEM itemId,
                       BOOL selected
                       );

   virtual HRESULT onContextHelp(SnapInView& view) throw ();

private:
   class Connector : private HiddenDialogWithWorker
   {
   public:
      Connector();

      void BeginConnect(
              ProxyNode& owner,
              SnapInView& view,
              IDataObject* parentData,
              HSCOPEITEM parentId
              ) throw ();

   private:
      virtual LPARAM DoWork() throw ();
      virtual void OnComplete(LPARAM result) throw ();

      ProxyNode* node;
      CComPtr<IConsoleNameSpace2> nameSpace;
      CComPtr<IDataObject> dataObject;
      HSCOPEITEM relativeID;

      // Not implemented.
      Connector(const Connector&);
      Connector& operator=(const Connector&);
   };

   friend class Connector;

   enum State
   {
      CONNECTING,
      CONNECTED,
      EXPANDED,
      SUPPRESSED,
      FAILED
   };

   // Called by the Connector.
   State connect(IDataObject* dataObject) throw ();
   void setConnectResult(
           IConsoleNameSpace2* nameSpace,
           HSCOPEITEM relativeID,
           State newState
           ) throw ();

   // Current state of the node.
   State state;
   // Title text for the result pane message view.
   ResourceString title;
   // Body text for the result pane message view.
   ResourceString body;
   // Connection to the SDOs.
   SdoConnection connection;
   // Child proxy policy node.
   CComPtr<ProxyPolicies> policies;
   // Child server groups node.
   CComPtr<ServerGroups> groups;
   // Handle to the connect thread.
   Connector worker;
};

#endif // PROXYNODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\proxypch.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    proxypch.h
//
// SYNOPSIS
//
//    Precompiled header file for the proxy extension snap-in.
//
// MODIFICATION HISTORY
//
//    02/10/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef PROXYPCH_H
#define PROXYPCH_H
#if _MSC_VER >= 1000
#pragma once
#endif

// Make sure we're always using Unicode APIs.
#ifndef UNICODE
   #define UNICODE
#endif
#ifndef _UNICODE
   #define _UNICODE
#endif

// MFC support.
#include <afxwin.h>
#include <afxcmn.h>
#include <afxdisp.h>
#include <afxext.h>

// No-throw new operator.
#include <new>

// MMC
#include <mmc.h>

// ATL
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

// Our SDO ...
#include <objvec.h>
#include <sdowrap.h>
// ... and MMC helpers.
#include <snapwork.h>
using namespace SnapIn;

// Contextual help 
#include "dlgcshlp.h"

// Resource defines.
#include "proxyres.h"

#endif // PROXYPCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\proxypolicies.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    proxypolicies.cpp
//
// SYNOPSIS
//
//    Defines the classes ProxyPolicy and ProxyPolicies.
//
// MODIFICATION HISTORY
//
//    02/10/2000    Original version.
//    04/19/2000    SdoScopeItem::getSelf returns by value, not reference.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <proxypolicies.h>
#include <policypage.h>
#include <policywiz.h>
#include <proxynode.h>

ProxyPolicy::ProxyPolicy(
                 SdoScopeItem& owner,
                 ISdo* sdo
                 )
   : SdoResultItem(owner, sdo)
{
   // Cache an integer ...
   self.getValue(PROPERTY_POLICY_MERIT, merit);
   // ... and string version of our merit.
   _ltow(merit, szMerit, 10);
}

Sdo& ProxyPolicy::getProfile()
{
   if (!profile)
   {
      profile = getParent().getCxn().getProxyProfiles().find(name);
   }

   return profile;
}

ULONG ProxyPolicy::getToolbarFlags(const SnapInView& view) throw ()
{
   // Is the order reversed ?
   BOOL reversed = (view.getSortColumn() == 1) &&
                   (view.getSortOption() & RSI_DESCENDING);
   ULONG flags = reversed ? ORDER_REVERSED : 0;

   // Are we the highest priority policy?
   if (merit != 1)
   {
      flags |= reversed ? MOVE_DN_ALLOWED : MOVE_UP_ALLOWED;
   }

   // Are we the lowest priority policy?
   if (merit != parent.getNumItems())
   {
      flags |= reversed ? MOVE_UP_ALLOWED : MOVE_DN_ALLOWED;
   }

   return flags;
}

void ProxyPolicy::setMerit(LONG newMerit)
{
   // Check if it's dirty to save excessive writes to the SDOs.
   if (newMerit != merit)
   {
      merit = newMerit;
      _ltow(merit, szMerit, 10);
      self.setValue(PROPERTY_POLICY_MERIT, merit);
      self.apply();
   }
}

PCWSTR ProxyPolicy::getDisplayName(int column) const throw ()
{
   return column ? szMerit : name;
}

HRESULT ProxyPolicy::addMenuItems(
                         SnapInView& view,
                         LPCONTEXTMENUCALLBACK callback,
                         long insertionAllowed
                         )
{
   static ResourceString moveUp(IDS_POLICY_MOVE_UP);
   static ResourceString moveDown(IDS_POLICY_MOVE_DOWN);
   static ResourceString moveUpStatusBar(IDS_POLICY_MOVE_UP_STATUS_BAR);
   static ResourceString moveDownStatusBar(IDS_POLICY_MOVE_DOWN_STATUS_BAR);

   if (insertionAllowed & CCM_INSERTIONALLOWED_TOP)
   {
      ULONG flags = getToolbarFlags(view);

      CONTEXTMENUITEM cmi;
      memset(&cmi, 0, sizeof(cmi));
      cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;

      cmi.strName = moveUp;
      cmi.strStatusBarText = moveUpStatusBar;
      cmi.lCommandID = 0;
      cmi.fFlags = (flags & MOVE_UP_ALLOWED) ? MF_ENABLED : MF_GRAYED;
      callback->AddItem(&cmi);

      cmi.strName = moveDown;
      cmi.strStatusBarText = moveDownStatusBar;
      cmi.lCommandID = 1;
      cmi.fFlags = (flags & MOVE_DN_ALLOWED) ? MF_ENABLED : MF_GRAYED;
      callback->AddItem(&cmi);
   }

   return S_OK;
}

int ProxyPolicy::compare(
                     SnapInDataItem& item,
                     int column
                     ) throw ()
{
   if (column == 0)
   {
      return wcscmp(name, static_cast<ProxyPolicy&>(item).name);
   }
   else
   {
      LONG merit2 = static_cast<ProxyPolicy&>(item).merit;

      if (merit < merit2) { return -1; }
      if (merit > merit2) { return +1; }
      return 0;
   }
}

HRESULT ProxyPolicy::createPropertyPages(
                         SnapInView& view,
                         LPPROPERTYSHEETCALLBACK provider,
                         LONG_PTR handle
                         )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   ProxyPolicyPage* page = new ProxyPolicyPage(
                                   handle,
                                   (LPARAM)this,
                                   self,
                                   getProfile(),
                                   getParent().getCxn()
                                   );
   page->addToMMCSheet(provider);

   return S_OK;
}

HRESULT ProxyPolicy::onDelete(
                         SnapInView& view
                         )
{
   HRESULT hr = SdoResultItem::onDelete(view);

   if (hr == S_OK)
   {
      getParent().getCxn().getProxyProfiles().remove(getProfile());

      // We have to renumber the policies to refresh the view.
      view.updateAllViews(parent);
   }

   return hr;
}

HRESULT ProxyPolicy::onMenuCommand(
                         SnapInView& view,
                         long commandId
                         )
{
   return getParent().movePolicy(view, *this, commandId);
}

HRESULT ProxyPolicy::onRename(
                         SnapInView& view,
                         LPCOLESTR newName
                         )
{
   // Make sure we have the profile before we rename otherwise, we won't be
   // able to find it.
   getProfile();

   HRESULT hr = SdoResultItem::onRename(view, newName);

   if (hr == S_OK)
   {
      self.setValue(PROPERTY_POLICY_PROFILE_NAME, name);
      self.apply();
      profile.setName(name);
      profile.apply();
   }

   return hr;
}

HRESULT ProxyPolicy::onToolbarButtonClick(
                         SnapInView& view,
                         int buttonId
                         )
{
   return getParent().movePolicy(view, *this, buttonId);
}

HRESULT ProxyPolicy::onToolbarSelect(
                         SnapInView& view,
                         BOOL scopeItem,
                         BOOL selected
                         )
{
   if (selected)
   {
      // Attach the toolbar ...
      IToolbar* toolbar = view.attachToolbar(TOOLBAR_POLICY);

      // ... and set button state according to the toolbar flags.
      ULONG flags = getToolbarFlags(view);
      toolbar->SetButtonState(
                   0,
                   ENABLED,
                   ((flags & MOVE_UP_ALLOWED) ? TRUE : FALSE)
                   );
      toolbar->SetButtonState(
                   1,
                   ENABLED,
                   ((flags & MOVE_DN_ALLOWED) ? TRUE : FALSE)
                   );
   }
   else
   {
      // We're going away so detach.
      view.detachToolbar(TOOLBAR_POLICY);
   }

   return S_OK;
}

HRESULT ProxyPolicy::onContextHelp(SnapInView& view) throw ()
{
   return view.displayHelp(L"ias_ops.chm::/sag_ias_crp_policies.htm");
}


int __cdecl ProxyPolicy::SortByMerit(
                             const SdoResultItem* const* t1,
                             const SdoResultItem* const* t2
                             ) throw ()
{
   return ((const ProxyPolicy*)*t1)->merit - ((const ProxyPolicy*)*t2)->merit;
}

UINT ProxyPolicy::mapResourceId(ResourceId id) const throw ()
{
   static UINT resourceIds[] =
   {
      IMAGE_PROXY_POLICY,
      IDS_POLICY_DELETE_CAPTION,
      IDS_POLICY_DELETE_LOCAL,
      IDS_POLICY_DELETE_REMOTE,
      IDS_POLICY_DELETE_LAST_LOCAL,
      IDS_POLICY_DELETE_LAST_REMOTE,
      IDS_POLICY_E_CAPTION,
      IDS_POLICY_E_RENAME,
      IDS_POLICY_E_NAME_EMPTY
   };

   return resourceIds[id];
}

ProxyPolicies::ProxyPolicies(SdoConnection& connection)
   : SdoScopeItem(
         connection,
         IDS_POLICY_NODE,
         IDS_POLICY_E_CAPTION,
         IDS_POLICY_MENU_TOP,
         IDS_POLICY_MENU_NEW,
         IDS_POLICY_MENU_STATUS_BAR
         ),
     nameColumn(IDS_POLICY_COLUMN_NAME),
     orderColumn(IDS_POLICY_COLUMN_ORDER)
{
}

ProxyPolicies::~ProxyPolicies() throw ()
{ }

HRESULT ProxyPolicies::movePolicy(
                           SnapInView& view,
                           ProxyPolicy& policy,
                           LONG commandId
                           )
{
   // Get the current toolbar flags.
   ULONG flags = policy.getToolbarFlags(view);

   // Use the current merit as the starting point ...
   LONG newMerit = policy.getMerit();

   // ... and adjust depending on the the button clicked.
   switch (commandId)
   {
      case 0:
      {
         if (!(flags & ProxyPolicy::MOVE_UP_ALLOWED)) { return S_FALSE; }
         (flags & ProxyPolicy::ORDER_REVERSED) ? ++newMerit : --newMerit;
         break;
      }

      case 1:
      {
         if (!(flags & ProxyPolicy::MOVE_DN_ALLOWED)) { return S_FALSE; }
         (flags & ProxyPolicy::ORDER_REVERSED) ? --newMerit : ++newMerit;
         break;
      }

      default:
         return S_FALSE;
   }

   // Swap their merits.
   ProxyPolicy& policy2 = getPolicyByMerit(newMerit);
   policy2.setMerit(policy.getMerit());
   policy.setMerit(newMerit);

   // Re-sort our vector.
   items.sort(ProxyPolicy::SortByMerit);

   // If the view isn't sorted, ...
   if (view.getSortOption() & RSI_NOSORTICON)
   {
      // ... we'll sort by merit anyway.
      view.getResultData()->Sort(1, RSI_NOSORTICON, 0);
   }
   else
   {
      view.reSort();
   }

   // Update the toolbar buttons based on the new state.
   policy.onToolbarSelect(view, FALSE, TRUE);

   // The configuration has changed, so tell IAS to reload.
   cxn.resetService();

   return S_OK;
}

HRESULT ProxyPolicies::onContextHelp(SnapInView& view) throw ()
{
   return view.displayHelp(L"ias_ops.chm::/sag_ias_crp_policies.htm");
}


SdoCollection ProxyPolicies::getSelf()
{
   return cxn.getProxyPolicies();
}

void ProxyPolicies::getResultItems(SdoEnum& src, ResultItems& dst)
{
   // Convert the SDOs to ProxyPolicy objects.
   Sdo itemSdo;
   while (src.next(itemSdo))
   {
      CComPtr<ProxyPolicy> newItem(new (AfxThrow) ProxyPolicy(
                                                      *this,
                                                      itemSdo
                                                      ));

      dst.push_back(newItem);
   }

   // Sort by merit.
   dst.sort(ProxyPolicy::SortByMerit);

   // Normalize.
   LONG merit = 0;
   for (ResultIterator i = dst.begin(); i != dst.end(); ++i)
   {
      ((ProxyPolicy*)*i)->setMerit(++merit);
   }
}

void ProxyPolicies::insertColumns(IHeaderCtrl2* headerCtrl)
{
   CheckError(headerCtrl->InsertColumn(0, nameColumn, LVCFMT_LEFT, 235));
   CheckError(headerCtrl->InsertColumn(1, orderColumn, LVCFMT_LEFT, 100));
}

HRESULT ProxyPolicies::onMenuCommand(
                           SnapInView& view,
                           long commandId
                           )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   // Fire up the wizard.
   NewPolicyWizard wizard(cxn, &view);
   if (wizard.DoModal() != IDCANCEL)
   {
      // We've changed every policy, so refresh the view.
      view.updateAllViews(*this);

      // Tell the service to reload
      cxn.resetService();
   }

   return S_OK;
}

void ProxyPolicies::propertyChanged(SnapInView& view, IASPROPERTIES id)
{
   if (id == PROPERTY_IAS_PROXYPOLICIES_COLLECTION)
   {
      view.updateAllViews(*this);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\proxypolicies.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    proxypolicies.h
//
// SYNOPSIS
//
//    Declares the classes ProxyPolicy and ProxyPolicies.
//
// MODIFICATION HISTORY
//
//    02/10/2000    Original version.
//    04/19/2000    SdoScopeItem::getSelf returns by value, not reference.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef PROXYPOLICIES_H
#define PROXYPOLICIES_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <sdonode.h>

class ProxyPolicies;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ProxyPolicy
//
// DESCRIPTION
//
//    Implements SnapInDataItem for a proxy policy result pane item.
//
///////////////////////////////////////////////////////////////////////////////
class ProxyPolicy : public SdoResultItem
{
public:
   ProxyPolicy(
       SdoScopeItem& owner,
       ISdo* sdo
       );

   // Returns parent as a ProxyPolicies ref (instead of a SdoScopeItem).
   ProxyPolicies& getParent() const throw ();

   Sdo& getProfile();

   // Flags returned by getToolbarFlags below.
   enum ToolbarFlags
   {
      MOVE_UP_ALLOWED = 0x1,
      MOVE_DN_ALLOWED = 0x2,
      ORDER_REVERSED  = 0x4
   };

   // Analyzes the view to determine the current state of the Toolbar.
   ULONG getToolbarFlags(const SnapInView& view) throw ();

   // Get and set the merit. Used for normalizing and reordering.
   LONG getMerit() const throw ()
   { return merit; }
   void setMerit(LONG newMerit);

   virtual PCWSTR getDisplayName(int column = 0) const throw ();

   virtual HRESULT addMenuItems(
                       SnapInView& view,
                       LPCONTEXTMENUCALLBACK callback,
                       long insertionAllowed
                       );
   virtual int compare(
                   SnapInDataItem& item,
                   int column
                   ) throw ();
   virtual HRESULT createPropertyPages(
                       SnapInView& view,
                       LPPROPERTYSHEETCALLBACK provider,
                       LONG_PTR handle
                       );
   virtual HRESULT onDelete(
                       SnapInView& view
                       );
   virtual HRESULT onMenuCommand(
                       SnapInView& view,
                       long commandId
                       );
   virtual HRESULT onRename(
                       SnapInView& view,
                       LPCOLESTR newName
                       );
   virtual HRESULT onToolbarButtonClick(
                       SnapInView& view,
                       int buttonId
                       );
   virtual HRESULT onToolbarSelect(
                       SnapInView& view,
                       BOOL scopeItem,
                       BOOL selected
                       );

   virtual HRESULT onContextHelp(SnapInView& view) throw ();

   // Function to sort an ObjectVector of ProxyPolicy's.
   static int __cdecl SortByMerit(
                          const SdoResultItem* const* t1,
                          const SdoResultItem* const* t2
                          ) throw ();

protected:
   virtual UINT mapResourceId(ResourceId id) const throw ();

private:
   Sdo profile;
   LONG merit;
   WCHAR szMerit[10];
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ProxyPolicies
//
// DESCRIPTION
//
//    Implements SnapInDataItem for the proxy policies scope pane node.
//
///////////////////////////////////////////////////////////////////////////////
class __declspec(uuid("3ad3b34e-6e1b-486c-ad73-d42f8fdcd41b")) ProxyPolicies;
class ProxyPolicies : public SdoScopeItem
{
public:
   ProxyPolicies(SdoConnection& connection);
   ~ProxyPolicies() throw ();

   // Returns the ProxyPolicy with a given merit.
   ProxyPolicy& getPolicyByMerit(LONG merit) const throw ()
   { return *static_cast<ProxyPolicy*>(items[merit - 1]); }

   const GUID* getNodeType() const throw ()
   { return &__uuidof(this); }

   // Move a ProxyPolicy in response to a command.
   HRESULT movePolicy(
               SnapInView& view,
               ProxyPolicy& policy,
               LONG commandId
               );

   virtual HRESULT onContextHelp(SnapInView& view) throw ();

protected:
   virtual SdoCollection getSelf();
   virtual void getResultItems(SdoEnum& src, ResultItems& dst);
   virtual void insertColumns(IHeaderCtrl2* headerCtrl);

   virtual HRESULT onMenuCommand(
                       SnapInView& view,
                       long commandId
                       );

   virtual void propertyChanged(SnapInView& view, IASPROPERTIES id);

private:
   ResourceString nameColumn;
   ResourceString orderColumn;
};

inline ProxyPolicies& ProxyPolicy::getParent() const throw ()
{
   return static_cast<ProxyPolicies&>(parent);
}

#endif // PROXYPOLICIES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\resolver.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    Defines the class Resolver and its subclasses.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <resolver.h>
#include <winsock2.h>
#include <svcguid.h>
#include <iasapi.h>

Resolver::Resolver(UINT dialog, PCWSTR dnsName, CWnd* pParent)
   : CHelpDialog(dialog, pParent),
     name(dnsName),
     choice(name)
{
   WSADATA wsaData;
   WSAStartup(MAKEWORD(2, 0), &wsaData);
}

Resolver::~Resolver()
{
   WSACleanup();
}

BOOL Resolver::IsAddress(PCWSTR sz) const throw ()
{
   return FALSE;
}

BOOL Resolver::OnInitDialog()
{
   /////////
   // Subclass the list control.
   /////////

   if (!results.SubclassWindow(::GetDlgItem(m_hWnd, IDC_LIST_IPADDRS)))
   {
      AfxThrowNotSupportedException();
   }

   /////////
   // Set the column header.
   /////////

   RECT rect;
   results.GetClientRect(&rect);
   LONG width = rect.right - rect.left;

   ResourceString addrsCol(IDS_RESOLVER_COLUMN_ADDRS);
   results.InsertColumn(0, addrsCol, LVCFMT_LEFT, width);

   results.SetExtendedStyle(results.GetExtendedStyle() | LVS_EX_FULLROWSELECT);

   return CHelpDialog::OnInitDialog();
}

void Resolver::DoDataExchange(CDataExchange* pDX)
{
   CHelpDialog::DoDataExchange(pDX);

   DDX_Text(pDX, IDC_EDIT_NAME, name);

   if (pDX->m_bSaveAndValidate)
   {
      int item = results.GetNextItem(-1, LVNI_SELECTED);
      choice = (item >= 0) ? results.GetItemText(item, 0) : name;
   }
}

void Resolver::OnResolve()
{
   // Remove the existing result set.
   results.DeleteAllItems();

   // Get the name to resolve.
   UpdateData();

   if (IsAddress(name))
   {
      // It's already an address, so no need to resolve.
      results.InsertItem(0, name);
   }
   else
   {
      // Change the cursor to busy signal since this will block.
      BeginWaitCursor();

      // Resolve the hostname.
      PHOSTENT he = IASGetHostByName(name);

      // The blocking part is over, so restore the cursor.
      EndWaitCursor();

      if (he)
      {
         // Add the IP addresses to the combo box.
         for (ULONG i = 0; he->h_addr_list[i] && i < 8; ++i)
         {
            PBYTE p = (PBYTE)he->h_addr_list[i];

            WCHAR szAddr[16];
            wsprintfW(szAddr, L"%u.%u.%u.%u", p[0], p[1], p[2], p[3]);

            results.InsertItem(i, szAddr);
         }

         // Free the results.
         LocalFree(he);
      }
      else
      {
         OnResolveError();
      }
   }

   // If we have at least one result ...
   if (results.GetItemCount() > 0)
   {
      // Make the OK button the default ...
      setButtonStyle(IDOK, BS_DEFPUSHBUTTON, true);
      setButtonStyle(IDC_BUTTON_RESOLVE, BS_DEFPUSHBUTTON, false);

      // ... and give it the focus.
      setFocusControl(IDOK);
   }
}

BEGIN_MESSAGE_MAP(Resolver, CHelpDialog)
   ON_BN_CLICKED(IDC_BUTTON_RESOLVE, OnResolve)
END_MESSAGE_MAP()


void Resolver::setButtonStyle(int controlId, long flags, bool set)
{
   // Get the button handle.
   HWND button = ::GetDlgItem(m_hWnd, controlId);

   // Retrieve the current style.
   long style = ::GetWindowLong(button, GWL_STYLE);

   // Update the flags.
   if (set)
   {
      style |= flags;
   }
   else
   {
      style &= ~flags;
   }

   // Set the new style.
   ::SendMessage(button, BM_SETSTYLE, LOWORD(style), MAKELPARAM(1,0));
}

void Resolver::setFocusControl(int controlId)
{
   ::SetFocus(::GetDlgItem(m_hWnd, controlId));
}

ServerResolver::ServerResolver(PCWSTR dnsName, CWnd* pParent)
   : Resolver(IDD_RESOLVE_SERVER_ADDRESS, dnsName, pParent)
{
}

void ServerResolver::OnResolveError()
{
   ResourceString text(IDS_SERVER_E_NO_RESOLVE);
   ResourceString caption(IDS_SERVER_E_CAPTION);
   MessageBox(text, caption, MB_ICONWARNING);
}

ClientResolver::ClientResolver(PCWSTR dnsName, CWnd* pParent)
   : Resolver(IDD_RESOLVE_CLIENT_ADDRESS, dnsName, pParent)
{
}

void ClientResolver::OnResolveError()
{
   ResourceString text(IDS_CLIENT_E_NO_RESOLVE);
   ResourceString caption(IDS_CLIENT_E_CAPTION);
   MessageBox(text, caption, MB_ICONWARNING);
}

BOOL ClientResolver::IsAddress(PCWSTR sz) const throw ()
{
   ULONG width;
   return (sz != 0) && (IASStringToSubNetW(sz, &width) != INADDR_NONE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\proxyres.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    resource.h
//
// SYNOPSIS
//
//    Resource IDs for the proxy extension snap-in.
//
// MODIFICATION HISTORY
//
//    02/01/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef PROXYRES_H
#define PROXYRES_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include "resource.h"

// Registry file for the proxy extension.
#define IDR_PROXY_REGISTRY               0x400

// Bitmaps used for the image strips.
#define IDB_PROXY_SMALL_ICONS            0x401
#define IDB_PROXY_LARGE_ICONS            0x402
#define IDB_PROXY_SORT                   0x403

// Watermarks
#define IDB_PROXY_POLICY_WATERMARK       0x404
#define IDB_PROXY_POLICY_HEADER          0x405
#define IDB_PROXY_SERVER_WATERMARK       0x406
#define IDB_PROXY_SERVER_HEADER          0x407


// Offsets of icons within the image strip.
#define IMAGE_OPEN_PROXY_NODE            0x000
#define IMAGE_CLOSED_PROXY_NODE          0x001
#define IMAGE_OPEN_BAD_PROXY_NODE        0x002
#define IMAGE_CLOSED_BAD_PROXY_NODE      0x003
#define IMAGE_OPEN_PROXY_POLICY_NODE     0x004
#define IMAGE_CLOSED_PROXY_POLICY_NODE   0x005
#define IMAGE_PROXY_POLICY               0x006
#define IMAGE_OPEN_SERVER_GROUPS_NODE    0x007
#define IMAGE_CLOSED_SERVER_GROUP_NODE   0x008
#define IMAGE_RADIUS_SERVER_GROUP        0x009
#define IMAGE_RADIUS_SERVER              0x00A

// Bitmaps used for the toolbars.
#define IDB_PROXY_TOOLBAR   IDR_POLICY_TOOLBAR

// Toolbar indices
#define TOOLBAR_POLICY                   0x000

#define IDS_PROXY_EXTENSION              0x410
#define IDS_LARGE_FONT_NAME              0x411
#define IDS_LARGE_FONT_SIZE              0x412
#define IDS_PROXY_NODE                   0x413
#define IDS_PROXY_VIEW_TITLE             0x414
#define IDS_PROXY_VIEW_BODY              0x415
#define IDS_PROXY_E_CLOSE_SHEET          0x416
#define IDS_PROXY_E_CLOSE_ALL_SHEETS     0x417
#define IDS_PROXY_E_SDO_CONNECT          0x418
#define IDS_PROXY_E_SDO_READ             0x419
#define IDS_PROXY_E_SDO_WRITE            0x41A

#define IDS_GROUP_NODE                   0x420
#define IDS_GROUP_COLUMN_NAME            0x421
#define IDS_GROUP_MENU_TOP               0x422
#define IDS_GROUP_MENU_NEW               0x423
#define IDS_GROUP_DELETE_CAPTION         0x424
#define IDS_GROUP_DELETE_LOCAL           0x425
#define IDS_GROUP_DELETE_REMOTE          0x426
#define IDS_GROUP_E_CAPTION              0x427
#define IDS_GROUP_E_NOT_UNIQUE           0x428
#define IDS_GROUP_E_RENAME               0x429
#define IDS_GROUP_E_NAME_EMPTY           0x42A
#define IDS_GROUP_E_NO_SERVERS           0x42B
#define IDS_GROUP_MENU_STATUS_BAR        0x42C
#define IDS_GROUP_E_LICENSE              0x42D

#define IDS_POLICY_NODE                  0x430
#define IDS_POLICY_COLUMN_NAME           0x431
#define IDS_POLICY_COLUMN_ORDER          0x432
#define IDS_POLICY_MOVE_UP               0x433
#define IDS_POLICY_MOVE_DOWN             0x434
#define IDS_POLICY_MENU_TOP              0x435
#define IDS_POLICY_MENU_NEW              0x436
#define IDS_POLICY_DELETE_CAPTION        0x437
#define IDS_POLICY_DELETE_LOCAL          0x438
#define IDS_POLICY_DELETE_REMOTE         0x439
#define IDS_POLICY_NO_GROUPS             0x43A
#define IDS_POLICY_E_CAPTION             0x43B
#define IDS_POLICY_E_NOT_UNIQUE          0x43C
#define IDS_POLICY_E_RENAME              0x43D
#define IDS_POLICY_E_NAME_EMPTY          0x43E
#define IDS_POLICY_E_NO_CONDITIONS       0x43F
#define IDS_POLICY_E_GROUP_INVALID       0x440
#define IDS_POLICY_E_FIND_EMPTY          0x441
#define IDS_POLICY_DELETE_LAST_LOCAL     0x442
#define IDS_POLICY_DELETE_LAST_REMOTE    0x443
#define IDS_POLICY_MOVE_UP_STATUS_BAR    0x444
#define IDS_POLICY_MOVE_DOWN_STATUS_BAR  0x445
#define IDS_POLICY_MENU_STATUS_BAR       0x446

#define IDS_PROFILE_CAPTION              0x448

#define IDS_RULE_COLUMN_FIND             0x450
#define IDS_RULE_COLUMN_REPLACE          0x451

#define IDS_SERVER_COLUMN_NAME           0x460
#define IDS_SERVER_COLUMN_PRIORITY       0x461
#define IDS_SERVER_COLUMN_WEIGHT         0x462
#define IDS_SERVER_CAPTION               0x463
#define IDS_SERVER_CAPTION_ADD           0x464
#define IDS_SERVER_E_CAPTION             0x465
#define IDS_SERVER_E_NAME_EMPTY          0x466
#define IDS_SERVER_E_AUTH_PORT_EMPTY     0x467
#define IDS_SERVER_E_PORT_RANGE          0x468
#define IDS_SERVER_E_SECRET_MATCH        0x469
#define IDS_SERVER_E_ACCT_PORT_EMPTY     0x46A
#define IDS_SERVER_E_PRIORITY_EMPTY      0x46B
#define IDS_SERVER_E_PRIORITY_RANGE      0x46C
#define IDS_SERVER_E_WEIGHT_EMPTY        0x46D
#define IDS_SERVER_E_WEIGHT_RANGE        0x46E
#define IDS_SERVER_E_TIMEOUT_EMPTY       0x46F
#define IDS_SERVER_E_TIMEOUT_RANGE       0x470
#define IDS_SERVER_E_MAXLOST_EMPTY       0x471
#define IDS_SERVER_E_MAXLOST_RANGE       0x472
#define IDS_SERVER_E_BLACKOUT_EMPTY      0x473
#define IDS_SERVER_E_BLACKOUT_RANGE      0x474
#define IDS_SERVER_E_NO_RESOLVE          0x475

#define IDS_NEWGROUP_NAME_TITLE          0x480
#define IDS_NEWGROUP_NAME_SUBTITLE       0x481
#define IDS_NEWGROUP_NOVICE_TITLE        0x482
#define IDS_NEWGROUP_NOVICE_SUBTITLE     0x483
#define IDS_NEWGROUP_SERVERS_TITLE       0x484
#define IDS_NEWGROUP_SERVERS_SUBTITLE    0x485
#define IDS_NEWGROUP_FINISH_TYPICAL      0x486
#define IDS_NEWGROUP_FINISH_CUSTOM       0x487
#define IDS_NEWGROUP_NO_BACKUP           0x488

#define IDS_NEWPOLICY_TYPE_TITLE         0x490
#define IDS_NEWPOLICY_TYPE_SUBTITLE      0x491
#define IDS_NEWPOLICY_NAME_TITLE         0x492
#define IDS_NEWPOLICY_NAME_SUBTITLE      0x493
#define IDS_NEWPOLICY_OUTSRC_TITLE       0x494
#define IDS_NEWPOLICY_OUTSRC_SUBTITLE    0x495
#define IDS_NEWPOLICY_NONE_TITLE         0x496
#define IDS_NEWPOLICY_NONE_SUBTITLE      0x497
#define IDS_NEWPOLICY_FWD_TITLE          0x498
#define IDS_NEWPOLICY_FWD_SUBTITLE       0x499
#define IDS_NEWPOLICY_COND_TITLE         0x49A
#define IDS_NEWPOLICY_COND_SUBTITLE      0x49B
#define IDS_NEWPOLICY_PROF_TITLE         0x49C
#define IDS_NEWPOLICY_PROF_SUBTITLE      0x49D
#define IDS_NEWPOLICY_FINISH_TEXT        0x49E
#define IDS_NEWPOLICY_PROVIDER_NONE      0x49F
#define IDS_NEWPOLICY_PROVIDER_WINDOWS   0x4A0

#define IDS_RESOLVER_COLUMN_ADDRS        0x4B0

#define IDS_CLIENT_E_CAPTION             0x4C0
#define IDS_CLIENT_E_NO_RESOLVE          0x4C1

// Generic control IDs
#define IDC_EDIT_NAME                    0x800
#define IDC_BUTTON_ADD                   0x801
#define IDC_BUTTON_REMOVE                0x802
#define IDC_BUTTON_EDIT                  0x803
#define IDC_STATIC_LARGE                 0x804

// RADIUS Server Group properties
#define IDD_SERVER_GROUP                 0x810
#define IDC_LIST_SERVERS                 0x815

// Remote RADIUS server properties
#define IDD_SERVER_NAME                  0x820
#define IDD_SERVER_AUTH                  0x821
#define IDD_SERVER_FTLB                  0x822
#define IDC_BUTTON_VERIFY                0x823
#define IDC_EDIT_AUTH_PORT               0x824
#define IDC_EDIT_AUTH_SECRET1            0x825
#define IDC_EDIT_AUTH_SECRET2            0x826
#define IDC_EDIT_ACCT_PORT               0x827
#define IDC_CHECK_SAME_SECRET            0x828
#define IDC_EDIT_ACCT_SECRET1            0x829
#define IDC_EDIT_ACCT_SECRET2            0x82A
#define IDC_CHECK_ACCT_ONOFF             0x82B
#define IDC_EDIT_PRIORITY                0x82C
#define IDC_EDIT_WEIGHT                  0x82D
#define IDC_EDIT_TIMEOUT                 0x82E
#define IDC_EDIT_MAX_LOST                0x82F
#define IDC_EDIT_BLACKOUT                0x830

// Verify address dialog.
#define IDD_RESOLVE_SERVER_ADDRESS       0x838
#define IDD_RESOLVE_CLIENT_ADDRESS       0x839
#define IDC_BUTTON_RESOLVE               0x83A
#define IDC_LIST_IPADDRS                 0x83B

// Proxy Policy Properties
#define IDD_PROXY_POLICY                 0x840
#define IDD_PROXY_PROFILE_AUTH           0x841
#define IDD_PROXY_PROFILE_ACCT           0x842
#define IDD_PROXY_PROFILE_ATTR           0x843
#define IDC_RADIO_NONE                   0x844
#define IDC_RADIO_WINDOWS                0x845
#define IDC_RADIO_RADIUS                 0x846
#define IDC_COMBO_GROUP                  0x847
#define IDC_CHECK_RECORD_ACCT            0x846 // Same as IDC_RADIO_RADIUS
#define IDC_COMBO_TARGET                 0x849
#define IDC_LIST_RULES                   0x84A
#define IDC_BUTTON_MOVE_UP               0x84B
#define IDC_BUTTON_MOVE_DOWN             0x84C

// Attribute manipulation rule
#define IDD_EDIT_RULE                    0x850
#define IDC_EDIT_RULE_FIND               0x851
#define IDC_EDIT_RULE_REPLACE            0x852

// New RADIUS Server Group Wizard
#define IDD_NEWGROUP_WELCOME             0x860
#define IDD_NEWGROUP_NAME                0x861
#define IDD_NEWGROUP_NOVICE              0x862
#define IDD_NEWGROUP_SERVERS             0x863
#define IDD_NEWGROUP_COMPLETION          0x864
#define IDC_RADIO_TYPICAL                0x865
#define IDC_RADIO_CUSTOM                 0x866
#define IDC_EDIT_PRIMARY                 0x867
#define IDC_BUTTON_VERIFY_PRIMARY        0x868
#define IDC_CHECK_BACKUP                 0x869
#define IDC_EDIT_BACKUP                  0x86A
#define IDC_BUTTON_VERIFY_BACKUP         0x86B
#define IDC_STATIC_FINISH                0x86C
#define IDC_STATIC_CREATE_POLICY         0x86D
#define IDC_CHECK_CREATE_POLICY          0x86E

// New Proxy Policy Wizard
#define IDD_NEWPOLICY_WELCOME            0x880
#define IDD_NEWPOLICY_NAME               0x881
#define IDD_NEWPOLICY_TYPE               0x882
#define IDD_NEWPOLICY_OUTSOURCE          0x883
#define IDD_NEWPOLICY_NOTNEEDED          0x884
#define IDD_NEWPOLICY_FORWARD            0x885
#define IDD_NEWPOLICY_CONDITIONS         0x886
#define IDD_NEWPOLICY_PROFILE            0x887
#define IDD_NEWPOLICY_COMPLETION         0x888
#define IDC_RADIO_LOCAL                  0x889
#define IDC_RADIO_FORWARD                0x88A
#define IDC_RADIO_OUTSOURCE              0x88C
#define IDC_RADIO_DIRECT                 0x88D
#define IDC_EDIT_REALM                   0x88E
#define IDC_CHECK_STRIP                  0x88F
#define IDC_BUTTON_NEWGROUP              0x890
#define IDC_RICHEDIT_TASKS               0x891

// Hidden dialog used for worker threads.
#define IDD_HIDDEN_WORKER                0x0CF

#endif // PROXYRES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\sdonode.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    sdonode.cpp
//
// SYNOPSIS
//
//    Defines the classes SdoResultItem and SdoScopeItem.
//
// MODIFICATION HISTORY
//
//    02/10/2000    Original version.
//    04/25/2000    Don't add result item unless pane is active.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <sdonode.h>
#include <proxynode.h>

SdoResultItem::SdoResultItem(
                   SdoScopeItem& owner,
                   ISdo* sdo
                   )
   : parent(owner), self(sdo)
{
   self.getName(name);
}

HRESULT SdoResultItem::queryPagesFor() throw ()
{ return S_OK; }

HRESULT SdoResultItem::onDelete(
                           SnapInView& view
                           )
{
   // Can't delete it with the properties open.
   if (view.isPropertySheetOpen(*this))
   {
      int retval;
      view.formatMessageBox(
               mapResourceId(ERROR_CAPTION),
               IDS_PROXY_E_CLOSE_SHEET,
               TRUE,
               MB_OK | MB_ICONWARNING,
               &retval
               );
      return S_FALSE;
   }

   // Confirm the delete operation.
   int retval;

   bool isLast = (parent.getNumItems() == 1);

   if (parent.getCxn().isLocal())
   {
      view.formatMessageBox(
               mapResourceId(DELETE_TITLE),
               isLast?mapResourceId(DELETE_LAST_LOCAL)
                     :mapResourceId(DELETE_LOCAL),
               FALSE,
               MB_YESNO | MB_ICONQUESTION,
               &retval,
               name
               );
   }
   else
   {
      view.formatMessageBox(
               mapResourceId(DELETE_TITLE),
               isLast?mapResourceId(DELETE_LAST_REMOTE)
                     :mapResourceId(DELETE_REMOTE),
               FALSE,
               MB_YESNO | MB_ICONQUESTION,
               &retval,
               name,
               parent.getCxn().getMachineName()
               );
   }

   if (retval != IDYES) { return S_FALSE; }

   // It passed the tests, so ask our parent to delete us.
   parent.deleteResultItem(view, *this);
   // Tell the service to reload
   parent.getCxn().resetService();

   return S_OK;
}

HRESULT SdoResultItem::onPropertyChange(
                           SnapInView& view,
                           BOOL scopeItem
                           )
{
   // Reload our name.
   self.getName(name);
   // Update the result pane.
   view.updateResultItem(*this);
   // Tell the service to reload
   parent.getCxn().resetService();
   return S_OK;
}

HRESULT SdoResultItem::onRename(
                           SnapInView& view,
                           LPCOLESTR newName
                           )
{
   // Can't rename with the properties open.
   if (view.isPropertySheetOpen(*this))
   {
      int retval;
      view.formatMessageBox(
               mapResourceId(ERROR_CAPTION),
               IDS_PROXY_E_CLOSE_SHEET,
               TRUE,
               MB_OK | MB_ICONWARNING,
               &retval
               );
      return S_FALSE;
   }

   // Turn newName into a BSTR ...
   CComBSTR bstrNewName(newName);
   if (!bstrNewName) { AfxThrowOleException(E_OUTOFMEMORY); }
   // ... and trim off the fat.
   SdoTrimBSTR(bstrNewName);

   // Names can't be empty.
   if (bstrNewName.Length() == 0)
   {
      int retval;
      view.formatMessageBox(
               mapResourceId(ERROR_CAPTION),
               mapResourceId(ERROR_NAME_EMPTY),
               TRUE,
               MB_OK | MB_ICONWARNING,
               &retval
               );
      return S_FALSE;
   }

   // This will fail if the name isn't unique.
   if (!self.setName(bstrNewName))
   {
      int retval;
      view.formatMessageBox(
               mapResourceId(ERROR_CAPTION),
               mapResourceId(ERROR_NOT_UNIQUE),
               FALSE,
               MB_OK | MB_ICONWARNING,
               &retval,
               (BSTR)name
               );
      return S_FALSE;
   }

   // Write the result to the datastore.
   self.apply();
   // Update our cached value.
   name.Attach(bstrNewName.Detach());
   // Tell the service to reload
   parent.getCxn().resetService();

   return S_OK;
}

HRESULT SdoResultItem::onSelect(
                           SnapInView& view,
                           BOOL scopeItem,
                           BOOL selected
                           )
{
   if (!selected) { return S_FALSE; }

   // Get IConsoleVerb ...
   CComPtr<IConsoleVerb> consoleVerb;
   CheckError(view.getConsole()->QueryConsoleVerb(&consoleVerb));

   // ... and turn on our verbs. Don't care if this fails.
   consoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
   consoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
   consoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);
   consoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

   return S_OK;
}

HRESULT SdoResultItem::onViewChange(
                           SnapInView& view,
                           LPARAM data,
                           LPARAM hint
                           )
{
   // Currently, this is only called when a new object is added.
   RESULTDATAITEM rdi;
   memset(&rdi, 0, sizeof(rdi));
   rdi.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
   rdi.str = MMC_CALLBACK;
   rdi.nImage = getImageIndex();
   rdi.lParam = (LPARAM)this;

   CheckError(view.getResultData()->InsertItem(&rdi));

   return S_OK;
}

SdoScopeItem::SdoScopeItem(
                  SdoConnection& connection,
                  int nameId,
                  int errorTitleId,
                  int topMenuItemId,
                  int newMenuItemId,
                  int menuItemStatusBarId
                  ) throw ()
   : SnapInPreNamedItem(nameId),
     cxn(connection),
     loaded(false),
     errorTitle(errorTitleId),
     topMenuItem(topMenuItemId),
     newMenuItem(newMenuItemId),
     menuItemStatusBar(menuItemStatusBarId),
     scopeId(0)

{
   cxn.advise(*this);
}

SdoScopeItem::~SdoScopeItem() throw ()
{
   cxn.unadvise(*this);
}

void SdoScopeItem::addResultItem(SnapInView& view, SdoResultItem& item)
{
   items.push_back(&item);

   if (active)
   {
      // We can't add it directly, since this may be called from a scope item.
      view.updateAllViews(item);
   }
}

void SdoScopeItem::deleteResultItem(SnapInView& view, SdoResultItem& item)
{
   // Remove from the SDO collection,
   getSelf().remove(item.getSelf());
   // the result pane, and
   view.deleteResultItem(item);
   // our cached copy.
   items.erase(&item);
}

HRESULT SdoScopeItem::addMenuItems(
                          SnapInView& view,
                          LPCONTEXTMENUCALLBACK callback,
                          long insertionAllowed
                          )
{
   CONTEXTMENUITEM cmi;
   memset(&cmi, 0, sizeof(cmi));

   if (insertionAllowed & CCM_INSERTIONALLOWED_NEW)
   {
      cmi.strName = newMenuItem;
      cmi.strStatusBarText = menuItemStatusBar;
      cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
      callback->AddItem(&cmi);
   }

   if (insertionAllowed & CCM_INSERTIONALLOWED_TOP)
   {
      cmi.strName = topMenuItem;
      cmi.strStatusBarText = menuItemStatusBar;
      cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
      callback->AddItem(&cmi);
   }

   return S_OK;
}

HRESULT SdoScopeItem::onRefresh(
                          SnapInView& view
                          )
{
   // Refresh the connection.
   cxn.refresh(view);
   return S_OK;
}

HRESULT SdoScopeItem::onSelect(
                          SnapInView& view,
                          BOOL scopeItem,
                          BOOL selected
                          )
{
   if (!selected) { return S_FALSE; }

   // Get IConsoleVerb ...
   CComPtr<IConsoleVerb> consoleVerb;
   CheckError(view.getConsole()->QueryConsoleVerb(&consoleVerb));
   // ... and turn on refresh.
   consoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
   return S_OK;
}

HRESULT SdoScopeItem::onShow(
                          SnapInView& view,
                          HSCOPEITEM itemId,
                          BOOL selected
                          )
{
   if (selected)
   {
      // Set the icon strip.
      view.setImageStrip(IDB_PROXY_SMALL_ICONS, IDB_PROXY_LARGE_ICONS, FALSE);

      // Let the derived class update the column headers.
      insertColumns(view.getHeaderCtrl());

      // Populate the result pane.
      insertResultItems(view);

      // Our node is active.
      active = true;
   }
   else
   {
      active = false;
   }

   return S_OK;
}

HRESULT SdoScopeItem::onViewChange(
                          SnapInView& view,
                          LPARAM data,
                          LPARAM hint
                          )
{
   loaded = false;

   if (active)
   {
      CheckError(view.getConsole()->SelectScopeItem(getScopeId()));
   }

   return S_OK;
}

bool SdoScopeItem::queryRefresh(SnapInView& view)
{
   // Make sure no properties are open.
   for (ResultIterator i = items.begin(); i != items.end(); ++i)
   {
      if (view.isPropertySheetOpen(**i))
      {
         int retval;
         view.formatMessageBox(
                  errorTitle,
                  IDS_PROXY_E_CLOSE_ALL_SHEETS,
                  TRUE,
                  MB_OK | MB_ICONWARNING,
                  &retval
                  );
         return false;
      }
   }
   return true;
}

void SdoScopeItem::refreshComplete(SnapInView& view)
{
   view.updateAllViews(*this);
}

void SdoScopeItem::insertResultItems(SnapInView& view)
{
   // Delete any existing items.
   view.getResultData()->DeleteAllRsltItems();

   // Have we loaded everything from the SDO's yet?
   if (!loaded)
   {
      // Get ourself.
      SdoCollection self = getSelf();

      // Get the source iterator ...
      SdoEnum src(self.getNewEnum());

      // ... and the destination vector.
      ObjectVector<SdoResultItem> dst;
      dst.reserve(self.count());

      // Ask the derived class to get the result items.
      getResultItems(src, dst);

      // Swap them in.
      items.swap(dst);
      loaded = true;
   }

   RESULTDATAITEM rdi;
   memset(&rdi, 0, sizeof(rdi));
   rdi.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
   rdi.str = MMC_CALLBACK;

   for (ResultIterator i = items.begin(); i != items.end();  ++i)
   {
      rdi.nImage = (*i)->getImageIndex();
      rdi.lParam = (LPARAM)*i;
      CheckError(view.getResultData()->InsertItem(&rdi));
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\sdonode.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    sdonode.h
//
// SYNOPSIS
//
//    Declares the classes SdoResultItem and SdoScopeItem.
//
// MODIFICATION HISTORY
//
//    02/10/2000    Original version.
//    04/19/2000    SdoScopeItem::getSelf returns by value, not reference.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef SDONODE_H
#define SDONODE_H
#if _MSC_VER >= 1000
#pragma once
#endif

class ProxyNode;
class SdoScopeItem;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SdoResultItem
//
// DESCRIPTION
//
//    Maps an SDO to MMC result pane data item
//
///////////////////////////////////////////////////////////////////////////////
class SdoResultItem : public SnapInDataItem
{
public:
   SdoResultItem(
       SdoScopeItem& owner,
       ISdo* sdo
       );

   UINT getImageIndex() const throw ()
   { return mapResourceId(IMAGE_INDEX); }

   Sdo& getSelf() throw ()
   { return self; }

   virtual HRESULT queryPagesFor() throw ();
   virtual HRESULT onDelete(
                       SnapInView& view
                       );
   virtual HRESULT onPropertyChange(
                       SnapInView& view,
                       BOOL scopeItem
                       );
   virtual HRESULT onRename(
                       SnapInView& view,
                       LPCOLESTR newName
                       );
   virtual HRESULT onSelect(
                       SnapInView& view,
                       BOOL scopeItem,
                       BOOL selected
                       );
   virtual HRESULT onViewChange(
                       SnapInView& view,
                       LPARAM data,
                       LPARAM hint
                       );
protected:
   // Various resource IDs that the derived class must provide.
   enum ResourceId
   {
      IMAGE_INDEX,
      DELETE_TITLE,
      DELETE_LOCAL,
      DELETE_REMOTE,
      DELETE_LAST_LOCAL,
      DELETE_LAST_REMOTE,
      ERROR_CAPTION,
      ERROR_NOT_UNIQUE,
      ERROR_NAME_EMPTY
   };

   virtual UINT mapResourceId(ResourceId id) const throw () = 0;

   SdoScopeItem& parent;   // Our scope pane node.
   Sdo self;               // The SDO containing our properties.
   CComBSTR name;          // Our name.
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SdoScopeItem
//
// DESCRIPTION
//
//    Map an SDO collection to an MMC scope pane node.
//
///////////////////////////////////////////////////////////////////////////////
class SdoScopeItem : public SnapInPreNamedItem, public SdoConsumer
{
public:
   SdoScopeItem(
       SdoConnection& connection,
       int nameId,
       int errorTitleId,
       int topMenuItemId,
       int newMenuItemId,
       int menuItemStatusBarId
       );
   ~SdoScopeItem() throw ();

   // Returns the connection to the SDOs.
   SdoConnection& getCxn() throw ()
   { return cxn; }

   // Returns the number of result pane items.
   LONG getNumItems() const throw ()
   { return (LONG)items.size(); }

   HSCOPEITEM getScopeId() const throw ()
   { return scopeId; }
   void setScopeId(HSCOPEITEM newScopeId) throw ()
   { scopeId = newScopeId; }

   // Add a new result item to the node.
   void addResultItem(SnapInView& view, SdoResultItem& item);
   // Deletes an item from the result pane.
   void deleteResultItem(SnapInView& view, SdoResultItem& item);

   virtual HRESULT addMenuItems(
                       SnapInView& view,
                       LPCONTEXTMENUCALLBACK callback,
                       long insertionAllowed
                       );
   virtual HRESULT onRefresh(
                       SnapInView& view
                       );
   virtual HRESULT onSelect(
                       SnapInView& view,
                       BOOL scopeItem,
                       BOOL selected
                       );
   virtual HRESULT onShow(
                       SnapInView& view,
                       HSCOPEITEM itemId,
                       BOOL selected
                       );
   virtual HRESULT onViewChange(
                       SnapInView& view,
                       LPARAM data,
                       LPARAM hint
                       );

protected:
   typedef ObjectVector<SdoResultItem> ResultItems;
   typedef ResultItems::iterator ResultIterator;

   // SdoConsumer.
   virtual bool queryRefresh(SnapInView& view);
   virtual void refreshComplete(SnapInView& view);

   // Insert the contents of 'items' into the result pane.
   void insertResultItems(SnapInView& view);

   // Return the collection corresponding to this node.
   virtual SdoCollection getSelf() = 0;
   // Populate dst with the SDOs from src.
   virtual void getResultItems(
                    SdoEnum& src,
                    ResultItems& dst
                    ) = 0;
   // Set the result pane column headers.
   virtual void insertColumns(
                    IHeaderCtrl2* headerCtrl
                    ) = 0;

   SdoConnection& cxn; // Connection to the sdos.
   ResultItems items;  // Our children.
   bool active;        // 'true' if we're currently selected.
   bool loaded;        // 'true' if we've loaded 'items'.

private:
   int errorTitle;             // Resource ID for error dialog titles.
   ResourceString topMenuItem; // Menu items.
   ResourceString newMenuItem;
   ResourceString menuItemStatusBar;
   HSCOPEITEM scopeId;
};

#endif // SDONODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\resolver.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    Declares the class Resolver and its subclasses.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef RESOLVER_H
#define RESOLVER_H
#pragma once

#include "dlgcshlp.h"

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Resolver
//
// DESCRIPTION
//
//    Base class for a simple DNS name resolution dialog. This is specialized
//    for client and server addresses.
//
///////////////////////////////////////////////////////////////////////////////
class Resolver : public CHelpDialog
{
public:
   Resolver(UINT dialog, PCWSTR dnsName, CWnd* pParent = NULL);
   ~Resolver() throw ();

   PCWSTR getChoice() const throw ()
   { return choice; }

protected:
   // Defined in the derived class to display an error dialog if a name
   // couldn't be resolved.
   virtual void OnResolveError() = 0;

   // Overridden in the defined class to determine if a name is already an
   // address. If this function returns true, the name will be presented to the
   // user 'as is'.
   virtual BOOL IsAddress(PCWSTR sz) const throw ();

   virtual BOOL OnInitDialog();
   virtual void DoDataExchange(CDataExchange* pDX);

   afx_msg void OnResolve();

   DECLARE_MESSAGE_MAP()

   // Set (or reset) style flags associated with a button control.
   void setButtonStyle(int controlId, long flags, bool set = true);

   // Set the focus to a control on the page.
   void setFocusControl(int controlId);

private:
   CString name;
   CString choice;
   CListCtrl results;

   // Not implemented.
   Resolver(const Resolver&);
   Resolver& operator=(const Resolver&);
};

class ServerResolver : public Resolver
{
public:
   ServerResolver(PCWSTR dnsName, CWnd* pParent = NULL);

private:
   virtual void OnResolveError();
};

class ClientResolver : public Resolver
{
public:
   ClientResolver(PCWSTR dnsName, CWnd* pParent = NULL);

private:
   virtual void OnResolveError();
   virtual BOOL IsAddress(PCWSTR sz) const throw ();
};

#endif // RESOLVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\sdowrap.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    sdowrap.cpp
//
// SYNOPSIS
//
//    Defines various wrapper classes for manipulating SDOs.
//
// MODIFICATION HISTORY
//
//    02/10/2000    Original version.
//    04/19/2000    Support for using wrappers across apartment boundaries.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <sdowrap.h>
#include <condlist.h>
#include <iaslimits.h>

VOID
WINAPI
SdoTrimBSTR(
    CComBSTR& bstr
    )
{
   // Characters to be trimmed.
   static const WCHAR delim[] = L" \t\n";

   if (bstr.m_str)
   {
      PCWSTR begin, end, first, last;

      // Find the beginning and end of the whole string.
      begin = bstr;
      end   = begin + wcslen(begin);

      // Find the first and last character of the trimmed string.
      first = begin + wcsspn(begin, delim);
      for (last = end; last > first && wcschr(delim, *(last - 1)); --last) { }

      // If they're not the same ...
      if (first != begin || last != end)
      {
         // ... then we have to allocate a new string ...
         BSTR newBstr = SysAllocStringLen(first, last - first);
         if (!newBstr) { AfxThrowOleException(E_OUTOFMEMORY); }

         // ... and replace the original.
         SysFreeString(bstr.m_str);
         bstr.m_str = newBstr;
      }
   }
}

BOOL SdoException::GetErrorMessage(
                       LPWSTR lpszError,
                       UINT nMaxError,
                       PUINT pnHelpContext
                       )
{
   UINT id;

   switch (type)
   {
      case CONNECT_ERROR:
         id = IDS_PROXY_E_SDO_CONNECT;
         break;

      case READ_ERROR:
         id = IDS_PROXY_E_SDO_READ;
         break;

      default:
         id = IDS_PROXY_E_SDO_WRITE;
   }

   return LoadStringW(
              AfxGetResourceHandle(),
              id,
              lpszError,
              nMaxError
              );
}

inline SdoException::SdoException(HRESULT hr, Type errorType) throw ()
   : type(errorType)
{
   m_sc = hr;
}

VOID
WINAPI
SdoThrowException(
    HRESULT hr,
    SdoException::Type errorType
    )
{
   throw new SdoException(hr, errorType);
}

// Extract an interface pointer from a VARIANT.
void ExtractInterface(const VARIANT& v, REFIID iid, PVOID* intfc)
{
   if (V_VT(&v) != VT_UNKNOWN && V_VT(&v) != VT_DISPATCH)
   {
      AfxThrowOleException(DISP_E_TYPEMISMATCH);
   }

   if (!V_UNKNOWN(&v))
   {
      AfxThrowOleException(E_POINTER);
   }

   CheckError(V_UNKNOWN(&v)->QueryInterface(iid, intfc));
}

Sdo::Sdo(IUnknown* unk)
{
   if (unk)
   {
      CheckError(unk->QueryInterface(__uuidof(ISdo), (PVOID*)&self));
   }
}

bool Sdo::setName(BSTR value)
{
   if (!self) { AfxThrowOleException(E_POINTER); }

   bool retval;

   VARIANT v;
   V_VT(&v) = VT_BSTR;
   V_BSTR(&v) = value;

   HRESULT hr = self->PutProperty(PROPERTY_SDO_NAME, &v);
   if (SUCCEEDED(hr))
   {
      retval = true;
   }
   else if (hr == E_INVALIDARG && value && value[0])
   {
      retval = false;
   }
   else
   {
      AfxThrowOleException(hr);
   }

   return retval;
}

void Sdo::clearValue(LONG id)
{
   if (!self) { AfxThrowOleException(E_POINTER); }

   VARIANT v;
   V_VT(&v) = VT_EMPTY;
   HRESULT hr = self->PutProperty(id, &v);
   if (FAILED(hr) && hr != DISP_E_MEMBERNOTFOUND)
   {
      AfxThrowOleException(hr);
   }
}

void Sdo::getValue(LONG id, bool& value) const
{
   VARIANT v;
   getValue(id, VT_BOOL, &v, true);
   value = (V_BOOL(&v) != 0);
}

void Sdo::getValue(LONG id, bool& value, bool defVal) const
{
   VARIANT v;
   if (getValue(id, VT_BOOL, &v, false))
   {
      value = (V_BOOL(&v) != 0);
   }
   else
   {
      value = defVal;
   }
}

void Sdo::getValue(LONG id, LONG& value) const
{
   VARIANT v;
   getValue(id, VT_I4, &v, true);
   value = V_UI4(&v);
}

void Sdo::getValue(LONG id, LONG& value, LONG defVal) const
{
   VARIANT v;
   if (getValue(id, VT_I4, &v, false))
   {
      value = V_UI4(&v);
   }
   else
   {
      value = defVal;
   }
}

void Sdo::getValue(LONG id, CComBSTR& value) const
{
   VARIANT v;
   getValue(id, VT_BSTR, &v, true);
   SysFreeString(value.m_str);
   value.m_str = V_BSTR(&v);
}

void Sdo::getValue(LONG id, CComBSTR& value, PCWSTR defVal) const
{
   VARIANT v;
   if (getValue(id, VT_BSTR, &v, false))
   {
      SysFreeString(value.m_str);
      value.m_str = V_BSTR(&v);
   }
   else
   {
      value = defVal;
      if (defVal && !value) { AfxThrowOleException(E_OUTOFMEMORY); }
   }
}

void Sdo::getValue(LONG id, VARIANT& value) const
{
   if (!self) { AfxThrowOleException(E_POINTER); }

   VariantClear(&value);

   CheckError(self->GetProperty(id, &value));
}

void Sdo::getValue(LONG id, SdoCollection& value) const
{
   if (!self) { AfxThrowOleException(E_POINTER); }

   CComVariant v;
   HRESULT hr = self->GetProperty(id, &v);
   if (FAILED(hr))
   {
      switch (hr)
      {
         case DISP_E_MEMBERNOTFOUND:
         case E_OUTOFMEMORY:
            AfxThrowOleException(hr);

         default:
            SdoThrowException(hr, SdoException::READ_ERROR);
      }
   }

   CComPtr<ISdoCollection> obj;
   ExtractInterface(v, __uuidof(ISdoCollection), (PVOID*)&obj);

   value = obj;
}

void Sdo::setValue(LONG id, bool value)
{
   VARIANT v;
   V_VT(&v) = VT_BOOL;
   V_BOOL(&v) = value ? VARIANT_TRUE : VARIANT_FALSE;
   setValue(id, v);
}

void Sdo::setValue(LONG id, LONG value)
{
   VARIANT v;
   V_VT(&v) = VT_I4;
   V_I4(&v) = value;
   setValue(id, v);
}

void Sdo::setValue(LONG id, BSTR value)
{
   VARIANT v;
   V_VT(&v) = VT_BSTR;
   V_BSTR(&v) = value;
   setValue(id, v);
}

void Sdo::setValue(LONG id, const VARIANT& val)
{
   if (!self) { AfxThrowOleException(E_POINTER); }
   CheckError(self->PutProperty(id, const_cast<VARIANT*>(&val)));
}

void Sdo::apply()
{
   if (!self) { AfxThrowOleException(E_POINTER); }
   HRESULT hr = self->Apply();
   if (FAILED(hr))
   {
      switch (hr)
      {
         case E_OUTOFMEMORY:
            AfxThrowOleException(hr);

         default:
            SdoThrowException(hr, SdoException::WRITE_ERROR);
      }
   }
}

void Sdo::restore()
{
   if (!self) { AfxThrowOleException(E_POINTER); }
   CheckError(self->Restore());
}

bool Sdo::getValue(LONG id, VARTYPE vt, VARIANT* val, bool mandatory) const
{
   if (!self) { AfxThrowOleException(E_POINTER); }

   V_VT(val) = VT_EMPTY;
   HRESULT hr = self->GetProperty(id, val);
   if (SUCCEEDED(hr))
   {
      if (V_VT(val) == VT_EMPTY)
      {
         if (mandatory)
         {
            AfxThrowOleException(DISP_E_MEMBERNOTFOUND);
         }
      }
      else if (V_VT(val) != vt)
      {
         VariantClear(val);
         AfxThrowOleException(DISP_E_TYPEMISMATCH);
      }
      else
      {
         return true;
      }
   }
   else if (hr == DISP_E_MEMBERNOTFOUND)
   {
      if (mandatory)
      {
         AfxThrowOleException(DISP_E_MEMBERNOTFOUND);
      }
   }
   else
   {
      AfxThrowOleException(hr);
   }

   return false;
}

SdoEnum::SdoEnum(IUnknown* unk)
{
   if (unk)
   {
      CheckError(unk->QueryInterface(__uuidof(IEnumVARIANT), (PVOID*)&self));
   }
}

bool SdoEnum::next(Sdo& s)
{
   if (!self) { AfxThrowOleException(E_POINTER); }

   CComVariant element;
   ULONG fetched;
   HRESULT hr = self->Next(1, &element, &fetched);
   if (hr == S_OK && fetched)
   {
      CComPtr<ISdo> obj;
      ExtractInterface(element, __uuidof(ISdo), (PVOID*)&obj);
      s = obj;
      return true;
   }
   CheckError(hr);
   return false;
}

void SdoEnum::reset()
{
   if (!self) { AfxThrowOleException(E_POINTER); }
   CheckError(self->Reset());
}

SdoCollection::SdoCollection(IUnknown* unk)
{
   if (unk)
   {
      CheckError(unk->QueryInterface(__uuidof(ISdoCollection), (PVOID*)&self));
   }
}

void SdoCollection::add(ISdo* sdo)
{
   if (!self) { AfxThrowOleException(E_POINTER); }

   // We must hold a reference across the call to Add since the interface
   // pointer passed to Add is an [in, out] parameter.
   CComPtr<IDispatch> disp(sdo);
   CheckError(self->Add(NULL, &disp));
}

LONG SdoCollection::count() throw ()
{
   if (!self) { AfxThrowOleException(E_POINTER); }
   LONG retval;
   CheckError(self->get_Count(&retval));
   return retval;
}

Sdo SdoCollection::create(BSTR name)
{
   Sdo newObj = tryCreate(name);
   if (!newObj)
   {
      AfxThrowOleException(IAS_E_LICENSE_VIOLATION);
   }

   return newObj;
}

Sdo SdoCollection::tryCreate(BSTR name)
{
   if (!self) { AfxThrowOleException(E_POINTER); }

   CComBSTR tmp;

   // If no name is specified, we'll make use a GUID.
   if (!name)
   {
      // Create the GUID.
      UUID uuid;
      UuidCreate(&uuid);

      // Convert to a string.
      WCHAR buffer[40];
      StringFromGUID2(uuid, buffer, sizeof(buffer)/sizeof(buffer[0]));

      // Convert the string to a BSTR.
      name = tmp = buffer;
      if (!name) { AfxThrowOleException(E_OUTOFMEMORY); }
   }

   CComPtr<IDispatch> disp;
   HRESULT hr = self->Add(name, &disp);
   if (FAILED(hr) && (hr != IAS_E_LICENSE_VIOLATION))
   {
      AfxThrowOleException(hr);
   }

   return Sdo(disp);
}

Sdo SdoCollection::find(BSTR name)
{
   if (!self) { AfxThrowOleException(E_POINTER); }

   VARIANT v;
   V_VT(&v) = VT_BSTR;
   V_BSTR(&v) = name;
   CComPtr<IDispatch> disp;
   HRESULT hr = self->Item(&v, &disp);
   if (FAILED(hr) && hr != DISP_E_MEMBERNOTFOUND)
   {
      AfxThrowOleException(hr);
   }

   return Sdo(disp);
}

SdoEnum SdoCollection::getNewEnum()
{
   if (!self) { AfxThrowOleException(E_POINTER); }

   CComPtr<IUnknown> unk;
   CheckError(self->get__NewEnum(&unk));

   return SdoEnum(unk);
}

bool SdoCollection::isNameUnique(BSTR name)
{
   if (!self) { AfxThrowOleException(E_POINTER); }

   VARIANT_BOOL retval;
   CheckError(self->IsNameUnique(name, &retval));

   return retval != 0;
}

void SdoCollection::reload()
{
   if (self)
   {
      HRESULT hr = self->Reload();
      if (FAILED(hr))
      {
         switch (hr)
         {
            case DISP_E_MEMBERNOTFOUND:
            case E_OUTOFMEMORY:
               AfxThrowOleException(hr);

            default:
               SdoThrowException(hr, SdoException::READ_ERROR);
         }
      }
   }
}

void SdoCollection::remove(ISdo* sdo)
{
   if (!self) { AfxThrowOleException(E_POINTER); }

   HRESULT hr = self->Remove(sdo);
   if (FAILED(hr))
   {
      switch (hr)
      {
         case DISP_E_MEMBERNOTFOUND:
         case E_OUTOFMEMORY:
            AfxThrowOleException(hr);

         default:
            SdoThrowException(hr, SdoException::WRITE_ERROR);
      }
   }
}

void SdoCollection::removeAll()
{
   if (!self) { AfxThrowOleException(E_POINTER); }

   HRESULT hr = self->RemoveAll();
   if (FAILED(hr))
   {
      switch (hr)
      {
         case E_OUTOFMEMORY:
            AfxThrowOleException(hr);

         default:
            SdoThrowException(hr, SdoException::WRITE_ERROR);
      }
   }
}

SdoDictionary::SdoDictionary(IUnknown* unk)
{
   if (unk)
   {
      CheckError(unk->QueryInterface(
                          __uuidof(ISdoDictionaryOld),
                          (PVOID*)&self
                          ));
   }
}

Sdo SdoDictionary::createAttribute(ATTRIBUTEID id) const
{
   if (!self) { AfxThrowOleException(E_POINTER); }

   CComPtr<IDispatch> disp;
   CheckError(self->CreateAttribute(id, &disp));

   return Sdo(disp);
}

ULONG SdoDictionary::enumAttributeValues(ATTRIBUTEID attrId, IdName*& values)
{
   if (!self) { AfxThrowOleException(E_POINTER); }

   // Get the variant arrays.
   CComVariant v1, v2;
   CheckError(self->EnumAttributeValues(attrId, &v1, &v2));

   // Allocate memory for the 'friendly' array.
   ULONG nelem = V_ARRAY(&v1)->rgsabound[0].cElements;
   IdName* vals = new (AfxThrow) IdName[nelem];

   // Get the raw data.
   VARIANT* id   = (VARIANT*)V_ARRAY(&v1)->pvData;
   VARIANT* name = (VARIANT*)V_ARRAY(&v2)->pvData;

   // Copy the variant data into the friendly array.
   for (ULONG i = 0; i < nelem; ++i, ++id, ++name)
   {
      vals[i].id = V_I4(id);
      vals[i].name = V_BSTR(name);
      if (!vals[i].name)
      {
         delete[] vals;
         AfxThrowOleException(E_OUTOFMEMORY);
      }
   }

   values = vals;
   return nelem;
}

SdoMachine::SdoMachine(IUnknown* unk)
{
   if (unk)
   {
      CheckError(unk->QueryInterface(__uuidof(ISdoMachine), (PVOID*)&self));
   }
}

void SdoMachine::attach(BSTR machineName)
{
   if (!self) { create(); }

   if (machineName && !machineName[0]) { machineName = NULL; }

   HRESULT hr = self->Attach(machineName);
   if (FAILED(hr))
   {
      switch (hr)
      {
         case E_OUTOFMEMORY:
            AfxThrowOleException(hr);

         default:
            SdoThrowException(hr, SdoException::CONNECT_ERROR);
      }
   }
}

void SdoMachine::create()
{
   self.Release();
   CheckError(CoCreateInstance(
                  __uuidof(SdoMachine),
                  NULL,
                  CLSCTX_INPROC_SERVER,
                  __uuidof(ISdoMachine),
                  (PVOID*)&self
                  ));
}

Sdo SdoMachine::getIAS()
{
   if (!self) { AfxThrowOleException(E_POINTER); }

   // Get the service SDO.
   CComPtr<IUnknown> unk;
   CComBSTR serviceName(L"IAS");
   if (!serviceName) { AfxThrowOleException(E_OUTOFMEMORY); }
   HRESULT hr = self->GetServiceSDO(
                          DATA_STORE_LOCAL,
                          serviceName,
                          &unk
                          );
   if (FAILED(hr))
   {
      switch (hr)
      {
         case E_OUTOFMEMORY:
            AfxThrowOleException(hr);

         default:
            SdoThrowException(hr, SdoException::CONNECT_ERROR);
      }
   }

   return Sdo(unk);
}

SdoDictionary SdoMachine::getDictionary()
{
   if (!self) { AfxThrowOleException(E_POINTER); }

   // Get the dictionary SDO.
   CComPtr<IUnknown> unk;
   HRESULT hr = self->GetDictionarySDO(&unk);
   if (FAILED(hr))
   {
      switch (hr)
      {
         case E_OUTOFMEMORY:
            AfxThrowOleException(hr);

         default:
            SdoThrowException(hr, SdoException::CONNECT_ERROR);
      }
   }

   return SdoDictionary(unk);
}

void SdoConsumer::propertyChanged(SnapInView& view, IASPROPERTIES id)
{ }

bool SdoConsumer::queryRefresh(SnapInView& view)
{ return true; }

void SdoConsumer::refreshComplete(SnapInView& view)
{ }

SdoConnection::SdoConnection() throw ()
   : dictionary(0),
     service(0),
     control(0),
     attrList(NULL)
{ }

SdoConnection::~SdoConnection() throw ()
{
   executeInMTA(mtaDisconnect);
}

void SdoConnection::advise(SdoConsumer& obj)
{
   consumers.Add(&obj);
}

void SdoConnection::unadvise(SdoConsumer& obj)
{
   for (int i = 0; i < consumers.GetSize(); ++i)
   {
      if (consumers[i] == &obj)
      {
         consumers.RemoveAt(i);
         break;
      }
   }
}

SdoDictionary SdoConnection::getDictionary()
{
   if (!dictionary) { AfxThrowOleException(E_POINTER); }

   CComPtr<ISdoDictionaryOld> obj;
   CheckError(git->GetInterfaceFromGlobal(
                       dictionary,
                       __uuidof(ISdoDictionaryOld),
                       (PVOID*)&obj
                       ));

   return SdoDictionary(obj);
}

SdoCollection SdoConnection::getProxyPolicies()
{
   SdoCollection retval;
   getService().getValue(
                    PROPERTY_IAS_PROXYPOLICIES_COLLECTION,
                    retval
                    );
   return retval;
}

SdoCollection SdoConnection::getProxyProfiles()
{
   SdoCollection retval;
   getService().getValue(
                    PROPERTY_IAS_PROXYPROFILES_COLLECTION,
                    retval
                    );
   return retval;
}

SdoCollection SdoConnection::getServerGroups()
{
   SdoCollection retval;
   getService().getValue(
                    PROPERTY_IAS_RADIUSSERVERGROUPS_COLLECTION,
                    retval
                    );
   return retval;
}

void SdoConnection::connect(PCWSTR computerName)
{
   if (machine) { AfxThrowOleException(E_UNEXPECTED); }

   machineName = computerName;
   if (computerName && !machineName)
   {
      AfxThrowOleException(E_OUTOFMEMORY);
   }

   executeInMTA(mtaConnect);
}

void SdoConnection::propertyChanged(SnapInView& view, IASPROPERTIES id)
{
   for (int i = 0; i < consumers.GetSize(); ++i)
   {
      ((SdoConsumer*)consumers[i])->propertyChanged(view, id);
   }
}

bool SdoConnection::refresh(SnapInView& view)
{
   int i;

   // Make sure the refresh is okay.
   for (i = 0; i < consumers.GetSize(); ++i)
   {
      if (!((SdoConsumer*)consumers[i])->queryRefresh(view))
      {
         return false;
      }
   }

   // Get a new connection.
   executeInMTA(mtaRefresh);

   // Let the consumers know we've refreshed.
   for (i = 0; i < consumers.GetSize(); ++i)
   {
      ((SdoConsumer*)consumers[i])->refreshComplete(view);
   }

   return true;
}

void SdoConnection::resetService()
{
   if (!control) { AfxThrowOleException(E_POINTER); }

   CComPtr<ISdoServiceControl> obj;
   CheckError(git->GetInterfaceFromGlobal(
                       control,
                       __uuidof(ISdoServiceControl),
                       (PVOID*)&obj
                       ));

   // We ignore the error code since the SDOs return an error when the service
   // isn't running.
   obj->ResetService();
}

CIASAttrList* SdoConnection::getCIASAttrList()
{
   if (!attrList)
   {
      attrList = CreateCIASAttrList();
      if (!attrList) { AfxThrowOleException(E_OUTOFMEMORY); }
   }
   return attrList;
}

Sdo SdoConnection::getService()
{
   if (!service) { AfxThrowOleException(E_POINTER); }

   CComPtr<ISdo> obj;
   CheckError(git->GetInterfaceFromGlobal(
                       service,
                       __uuidof(ISdo),
                       (PVOID*)&obj
                       ));
   return Sdo(obj);
}

void SdoConnection::mtaConnect()
{
   // Get the GIT.
   CheckError(CoCreateInstance(
                  CLSID_StdGlobalInterfaceTable,
                  NULL,
                  CLSCTX_INPROC_SERVER,
                  __uuidof(IGlobalInterfaceTable),
                  (PVOID*)&git
                  ));

   // Attach to the machine.
   machine.attach(machineName);

   // Get the dictionary SDO.
   CheckError(git->RegisterInterfaceInGlobal(
                       machine.getDictionary(),
                       __uuidof(ISdoDictionaryOld),
                       &dictionary
                       ));

   // Get the service SDO.
   Sdo serviceSdo = machine.getIAS();
   CheckError(git->RegisterInterfaceInGlobal(
                       serviceSdo,
                       __uuidof(ISdo),
                       &service
                       ));

   // Get the control SDO.
   CComPtr<ISdoServiceControl> controlSdo;
   CheckError(serviceSdo.self->QueryInterface(
                                   __uuidof(ISdoServiceControl),
                                   (PVOID*)&controlSdo
                                   ));
   CheckError(git->RegisterInterfaceInGlobal(
                       controlSdo,
                       __uuidof(ISdoServiceControl),
                       &control
                       ));
}

void SdoConnection::mtaDisconnect()
{
   // Revoke all the GIT cookies.
   if (git)
   {
      if (dictionary) { git->RevokeInterfaceFromGlobal(dictionary); }
      if (service)    { git->RevokeInterfaceFromGlobal(service); }
      if (control)    { git->RevokeInterfaceFromGlobal(control); }

      git.Release();
   }

   DestroyCIASAttrList(attrList);

   // Drop the connection.
   machine.release();
}

void SdoConnection::mtaRefresh()
{
   // Revoke the old connection.
   if (service)
   {
      git->RevokeInterfaceFromGlobal(service);
      service = 0;
   }

   // Get a new connection.
   CheckError(git->RegisterInterfaceInGlobal(
                       machine.getIAS(),
                       __uuidof(ISdo),
                       &service
                       ));
}

namespace
{
   // Struct to store the data for an MTA action.
   struct ActionData
   {
      SdoConnection* cxn;
      SdoConnection::Action action;
   };
};

void SdoConnection::executeInMTA(Action action)
{
   HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
   if (SUCCEEDED(hr))
   {
      // We're already in the MTA, so execute in place.
      (this->*action)();
      CoUninitialize();
   }
   else
   {
      // Save the action data.
      ActionData data = { this, action };

      // Create a thread to perform the action.
      HANDLE thread = CreateThread(
                          NULL,
                          0,
                          actionRoutine,
                          &data,
                          0,
                          NULL
                          );

      // Wait for the thread to exit and retrieve the exit code.
      DWORD exitCode;
      if (!thread ||
          WaitForSingleObject(thread, INFINITE) == WAIT_FAILED ||
          !GetExitCodeThread(thread, &exitCode))
      {
         exitCode = GetLastError();
         hr = HRESULT_FROM_WIN32(exitCode);
      }
      else
      {
         hr = (HRESULT)exitCode;
      }

      CloseHandle(thread);

      CheckError(hr);
   }
}

DWORD WINAPI SdoConnection::actionRoutine(PVOID parameter) throw ()
{
   HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
   if (SUCCEEDED(hr))
   {
      ActionData* data = (ActionData*)parameter;

      try
      {
         ((data->cxn)->*(data->action))();
         hr = S_OK;
      }
      catch (CException* e)
      {
         hr = COleException::Process(e);
         e->Delete();
      }
      CoUninitialize();
   }

   return (DWORD)hr;
}

SdoProfile::SdoProfile(SdoConnection& connection)
   : cxn(connection)
{
}

SdoProfile::SdoProfile(SdoConnection& connection, Sdo& profile)
   : cxn(connection)
{
   operator=(profile);
}

SdoProfile& SdoProfile::operator=(Sdo& profile)
{
   if (!profile) { AfxThrowOleException(E_POINTER); }

   // Get the new attributes collection.
   SdoCollection newSelf;
   profile.getValue(PROPERTY_PROFILE_ATTRIBUTES_COLLECTION, newSelf);

   return operator=(newSelf);
}

SdoProfile& SdoProfile::operator=(ISdoCollection* p)
{
   if (!p) { AfxThrowOleException(E_POINTER); }

   SdoCollection newSelf(p);

   // Create a temporary vector to hold the attributes.
   SdoVector newAttrs;
   newAttrs.reserve(newSelf.count());

   // Get the attributes.
   Sdo attr;
   SdoEnum sdoEnum(newSelf.getNewEnum());
   while (sdoEnum.next(attr))
   {
      newAttrs.push_back(attr);
   }

   // Store the results.
   attrs.swap(newAttrs);
   self = newSelf;

   return *this;
}

void SdoProfile::clear()
{
   self.removeAll();
   attrs.clear();
}

Sdo SdoProfile::find(ATTRIBUTEID id) const
{
   return getExisting(id);
}

void SdoProfile::clearValue(ATTRIBUTEID id)
{
   ISdo* sdo = getExisting(id);
   if (sdo)
   {
      self.remove(sdo);
      attrs.erase(sdo);
   }
}

bool SdoProfile::getValue(ATTRIBUTEID id, bool& value) const
{
   Sdo sdo(getExisting(id));
   return sdo ? sdo.getValue(PROPERTY_ATTRIBUTE_VALUE, value), true : false;
}

bool SdoProfile::getValue(ATTRIBUTEID id, LONG& value) const
{
   Sdo sdo(getExisting(id));
   return sdo ? sdo.getValue(PROPERTY_ATTRIBUTE_VALUE, value), true : false;
}

bool SdoProfile::getValue(ATTRIBUTEID id, CComBSTR& value) const
{
   Sdo sdo(getExisting(id));
   return sdo ? sdo.getValue(PROPERTY_ATTRIBUTE_VALUE, value), true : false;
}

bool SdoProfile::getValue(ATTRIBUTEID id, VARIANT& value) const
{
   Sdo sdo(getExisting(id));
   return sdo ? sdo.getValue(PROPERTY_ATTRIBUTE_VALUE, value), true : false;
}

void SdoProfile::setValue(ATTRIBUTEID id, bool value)
{
   Sdo(getAlways(id)).setValue(PROPERTY_ATTRIBUTE_VALUE, value);
}

void SdoProfile::setValue(ATTRIBUTEID id, LONG value)
{
   Sdo(getAlways(id)).setValue(PROPERTY_ATTRIBUTE_VALUE, value);
}

void SdoProfile::setValue(ATTRIBUTEID id, BSTR value)
{
   Sdo(getAlways(id)).setValue(PROPERTY_ATTRIBUTE_VALUE, value);
}

void SdoProfile::setValue(ATTRIBUTEID id, const VARIANT& val)
{
   Sdo(getAlways(id)).setValue(PROPERTY_ATTRIBUTE_VALUE, val);
}

ISdo* SdoProfile::getAlways(ATTRIBUTEID id)
{
   // Does it already exist ?
   ISdo* sdo = getExisting(id);
   if (sdo) { return sdo; }

   // No, so create a new one
   Sdo attr = cxn.getDictionary().createAttribute(id);
   self.add(attr);
   attrs.push_back(attr);
   return attr;
}

ISdo* SdoProfile::getExisting(ATTRIBUTEID key) const
{
   // Iterate through the attributes.
   for (SdoVector::iterator i = attrs.begin(); i != attrs.end(); ++i)
   {
      // Get the attribute ID.
      LONG id;
      Sdo(*i).getValue(PROPERTY_ATTRIBUTE_ID, id);

      // Does it match the key ?
      if (id == key) { return *i; }
   }

   return NULL;
}

void InterfaceStream::marshal(REFIID riid, LPUNKNOWN pUnk)
{
   // Create the new stream.
   CComPtr<IStream> newStream;
   CheckError(CoMarshalInterThreadInterfaceInStream(
                  riid,
                  pUnk,
                  &newStream
                  ));

   // Release the old one if any.
   if (stream) { stream->Release(); }

   // Save the new one.
   stream = newStream.p;
   newStream.p = NULL;
}

void InterfaceStream::get(REFIID riid, LPVOID* ppv)
{
   // Unmarshall the interface.
   HRESULT hr = CoGetInterfaceAndReleaseStream(
                    stream,
                    riid,
                    ppv
                    );

   // The stream can only be used once even if the above fails.
   stream = NULL;

   // Check the result of CoGetInterfaceAndReleaseStream.
   CheckError(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\sdowrap.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    sdowrap.h
//
// SYNOPSIS
//
//    Declares various wrapper classes for manipulating SDOs.
//
// MODIFICATION HISTORY
//
//    02/10/2000    Original version.
//    04/19/2000    Support for using wrappers across apartment boundaries.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef SDOWRAP_H
#define SDOWRAP_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <sdoias.h>
#include <objvec.h>

class CIASAttrList;
class SdoCollection;
class SdoConnection;
class SnapInView;

//////////
// Helper function to trim the whitespace from the beginning and end of a BSTR.
// Useful when setting the SDO name.
//////////
VOID
WINAPI
SdoTrimBSTR(
    CComBSTR& bstr
    );

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SdoException
//
// DESCRIPTION
//
//    Extends COleException to indicate that this error specifically came from
//    a failure to access the datastore. If you use the wrapper classes, you
//    should never have to throw this exception yourself, but if you need to,
//    use the SdoThrowException function below.
//
///////////////////////////////////////////////////////////////////////////////
class SdoException : public COleException
{
public:
   enum Type
   {
      CONNECT_ERROR,
      READ_ERROR,
      WRITE_ERROR
   };

   Type getType() const throw ()
   { return type; }

   virtual BOOL GetErrorMessage(
                    LPWSTR lpszError,
                    UINT nMaxError,
                    PUINT pnHelpContext = NULL
                    );


protected:
   friend VOID WINAPI SdoThrowException(HRESULT, Type);

   SdoException(HRESULT hr, Type errorType) throw ();

private:
   Type type;
};

VOID
WINAPI
SdoThrowException(
    HRESULT hr,
    SdoException::Type errorType
    );

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Sdo
//
// DESCRIPTION
//
//    Wraps ISdo. Instances of this class may not be accessed from multiple
//    apartments; instead use the SdoStream<T> class to marshal the wrapper
//    across the apartment boundary.
//
///////////////////////////////////////////////////////////////////////////////
class Sdo
{
public:
   Sdo() throw ()
   { }
   Sdo(IUnknown* unk);
   Sdo(ISdo* p) throw ()
      : self(p) { }
   Sdo(const Sdo& s) throw ()
      : self(s.self) { }
   Sdo& operator=(ISdo* p) throw ()
   { self = p; return *this; }
   Sdo& operator=(const Sdo& s) throw ()
   { self = s.self; return *this; }
   operator ISdo*() const throw ()
   { return self; }
   void release() throw ()
   { self.Release(); }

   void getName(CComBSTR& value) const
   { getValue(PROPERTY_SDO_NAME, value); }

   // Sets the name of the SDO. Returns 'false' if the name is not unique.
   bool setName(BSTR value);

   void clearValue(LONG id);

   void getValue(LONG id, bool& value) const;
   void getValue(LONG id, bool& value, bool defVal) const;
   void getValue(LONG id, LONG& value) const;
   void getValue(LONG id, LONG& value, LONG defVal) const;
   void getValue(LONG id, CComBSTR& value) const;
   void getValue(LONG id, CComBSTR& value, PCWSTR defVal) const;
   void getValue(LONG id, VARIANT& value) const;
   void getValue(LONG id, SdoCollection& value) const;

   void setValue(LONG id, bool value);
   void setValue(LONG id, LONG value);
   void setValue(LONG id, BSTR value);
   void setValue(LONG id, const VARIANT& val);

   void apply();
   void restore();

   typedef ISdo Interface;

protected:
   bool getValue(LONG id, VARTYPE vt, VARIANT* val, bool mandatory) const;

   friend class SdoConnection;

private:
   mutable CComPtr<ISdo> self;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SdoEnum
//
// DESCRIPTION
//
//    Wraps an IEnumVARIANT that's being used to iterate through an SDO
//    collection. Instances of this class may not be accessed from multiple
//    apartments; instead use the SdoStream<T> class to marshal the wrapper
//    across the apartment boundary.
//
///////////////////////////////////////////////////////////////////////////////
class SdoEnum
{
public:
   SdoEnum() throw ()
   { }
   SdoEnum(IUnknown* unk);
   SdoEnum(IEnumVARIANT* p) throw ()
      : self(p) { }
   SdoEnum(const SdoEnum& s) throw ()
      : self(s.self) { }
   SdoEnum& operator=(IEnumVARIANT* p) throw ()
   { self = p; return *this; }
   SdoEnum& operator=(const SdoEnum& s) throw ()
   { self = s.self; return *this; }
   operator IEnumVARIANT*() const throw ()
   { return self; }
   void release() throw ()
   { self.Release(); }

   bool next(Sdo& s);
   void reset();

   typedef IEnumVARIANT Interface;

private:
   mutable CComPtr<IEnumVARIANT> self;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SdoCollection
//
// DESCRIPTION
//
//    Wraps ISdoCollection. Instances of this class may not be accessed from
//    multiple apartments; instead use the SdoStream<T> class to marshal the
//    wrapper across the apartment boundary.
//
///////////////////////////////////////////////////////////////////////////////
class SdoCollection
{
public:
   SdoCollection() throw ()
   { }
   SdoCollection(IUnknown* unk);
   SdoCollection(ISdoCollection* p) throw ()
      : self(p) { }
   SdoCollection(const SdoCollection& s) throw ()
      : self(s.self) { }
   SdoCollection& operator=(ISdoCollection* p) throw ()
   { self = p; return *this; }
   SdoCollection& operator=(const SdoCollection& s) throw ()
   { self = s.self; return *this; }
   operator ISdoCollection*() const throw ()
   { return self; }
   void release() throw ()
   { self.Release(); }

   // Add an existing SDO to the collection.
   void add(ISdo* sdo);
   LONG count() throw ();
   // Create a new SDO in the collection with the given name.
   Sdo create(BSTR name = NULL);
   // Tries to create a new SDO in the collection with the given name. Returns
   // null if the SDO can't be created due to licensing restrictions.
   Sdo tryCreate(BSTR name = NULL);
   // Find an SDO in the collection. Returns an empty Sdo if the item doesn't
   // exist.
   Sdo find(BSTR name);
   SdoEnum getNewEnum();
   bool isNameUnique(BSTR name);
   void reload();
   void remove(ISdo* sdo);
   void removeAll();

   typedef ISdoCollection Interface;

private:
   mutable CComPtr<ISdoCollection> self;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SdoDictionary
//
// DESCRIPTION
//
//    Wraps ISdoDictionaryOld. Instances of this class may not be accessed from
//    multiple apartments. You can use the SdoStream<T> class to marshal the
//    wrapper across the apartment boundary, but it's often easier to pass an
//    SdoConnection reference instead and retrieve a new dictionary object in
//    the other apartment.
//
///////////////////////////////////////////////////////////////////////////////
class SdoDictionary
{
public:
   SdoDictionary() throw ()
   { }
   SdoDictionary(IUnknown* unk);
   SdoDictionary(ISdoDictionaryOld* p) throw ()
      : self(p) { }
   SdoDictionary(const SdoDictionary& s) throw ()
      : self(s.self) { }
   SdoDictionary& operator=(ISdoDictionaryOld* p) throw ()
   { self = p; return *this; }
   SdoDictionary& operator=(const SdoDictionary& s) throw ()
   { self = s.self; return *this; }
   operator ISdoDictionaryOld*() const throw ()
   { return self; }
   void release() throw ()
   { self.Release(); }

   // Struct representing an (id, name) pair.
   struct IdName
   {
      LONG id;
      CComBSTR name;
   };

   Sdo createAttribute(ATTRIBUTEID id) const;

   // The caller must delete[] the returned IdName array. The return value is
   // the number of elements in the array.
   ULONG enumAttributeValues(ATTRIBUTEID id, IdName*& values);

   typedef ISdoDictionaryOld Interface;

private:
   mutable CComPtr<ISdoDictionaryOld> self;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SdoMachine
//
// DESCRIPTION
//
//    Wraps ISdoMachine. You should generally not use this class directly since
//    all the necessary machine functionality can be more easily accessed
//    through SdoConnection.
//
//    Instances of this class may not be accessed from multiple apartments;
//    instead use the SdoStream<T> class to marshal the wrapper across the
//    apartment boundary.
//
///////////////////////////////////////////////////////////////////////////////
class SdoMachine
{
public:
   SdoMachine() throw ()
   { }
   SdoMachine(IUnknown* unk);
   SdoMachine(ISdoMachine* p) throw ()
      : self(p) { }
   SdoMachine(const SdoMachine& s) throw ()
      : self(s.self) { }
   SdoMachine& operator=(ISdoMachine* p) throw ()
   { self = p; return *this; }
   SdoMachine& operator=(const SdoMachine& s) throw ()
   { self = s.self; return *this; }
   operator ISdoMachine*() const throw ()
   { return self; }
   void release() throw ()
   { self.Release(); }

   // Attach to the designated machine. This will create the SDO first if
   // necessary.
   void attach(BSTR machineName = NULL);
   // Explicitly create the machine SDO.
   void create();
   // Get the IAS service SDO.
   Sdo getIAS();
   // Get the dictionary SDO.
   SdoDictionary getDictionary();

   typedef ISdoMachine Interface;

private:
   mutable CComPtr<ISdoMachine> self;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SdoConsumer
//
// DESCRIPTION
//
//    Abstract interface implemented by consumers of an SdoConnection if they
//    need to receive refresh notifications.
//
///////////////////////////////////////////////////////////////////////////////
class SdoConsumer
{
public:
   // Called when a property changes.
   virtual void propertyChanged(SnapInView& view, IASPROPERTIES id);

   // Return true to allow the refresh, and false to block it.
   virtual bool queryRefresh(SnapInView& view);

   // Called after the refresh is complete.
   virtual void refreshComplete(SnapInView& view);
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SdoConnection
//
// DESCRIPTION
//
//    Encapsulates the state associated with an SDO connection to a particular
//    machine. Unlike the other wrapper classes an instance of SdoConnection
//    may be freely shared across apartments without marshalling.
//
///////////////////////////////////////////////////////////////////////////////
class SdoConnection
{
public:
   SdoConnection() throw ();
   ~SdoConnection() throw ();

   BSTR getMachineName() const throw ()
   { return machineName; }
   bool isLocal() const throw ()
   { return !machineName || !machineName[0]; }

   // Methods for adding and removing consumers.
   void advise(SdoConsumer& obj);
   void unadvise(SdoConsumer& obj);

   // Retrieve various interesting SDOs.
   SdoDictionary getDictionary();
   SdoCollection getProxyPolicies();
   SdoCollection getProxyProfiles();
   SdoCollection getServerGroups();

   // Connect to a machine. If computerName is NULL, connects locally.
   void connect(PCWSTR computerName = NULL);

   // Dispatch a property changed notification to all consumers.
   void propertyChanged(SnapInView& view, IASPROPERTIES id);

   // Refresh the connection. Returns 'true' if allowed.
   bool refresh(SnapInView& view);

   // Resets the service being managed.
   void resetService();

   CIASAttrList* getCIASAttrList();

   // Prototype of an action to be executed in the MTA.
   typedef void (SdoConnection::*Action)();

protected:
   // Retrieve the service SDO for the current apartment.
   Sdo getService();

   // Various actions that must be performed in the MTA.
   void mtaConnect();
   void mtaDisconnect();
   void mtaRefresh();

   // Schedule the specified action to be executed in the MTA.
   void executeInMTA(Action action);

   // Callback routine for MTA thread.
   static DWORD WINAPI actionRoutine(PVOID parameter) throw ();

private:
   CComPtr<IGlobalInterfaceTable> git;
   CComBSTR machineName;
   SdoMachine machine;         // Only accessed from MTA.
   DWORD dictionary;           // GIT cookie for ISdoDictionaryOld.
   DWORD service;              // GIT cookie for ISdo on the IAS service.
   DWORD control;              // GIT cookie for ISdoServiceControl
   CPtrArray consumers;
   CIASAttrList* attrList;

   // Not implemented.
   SdoConnection(SdoConnection&);
   SdoConnection& operator=(SdoConnection&);
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SdoProfile
//
// DESCRIPTION
//
//    Wraps an collection of profile attributes. This class is *not*
//    multithread safe. Furthermore, instances of this class may not be
//    accessed from multiple apartments; instead use the SdoStream<T> class to
//    marshal the wrapper across the apartment boundary.
//
///////////////////////////////////////////////////////////////////////////////
class SdoProfile
{
public:
   SdoProfile(SdoConnection& connection);
   SdoProfile(SdoConnection& connection, Sdo& profile);

   // Assign a new profile to the object. Note the connection can not be
   // changed after the object is constructed.
   SdoProfile& operator=(Sdo& profile);

   // These allow an SdoProfile to be stored in an SdoStream.
   SdoProfile& operator=(ISdoCollection* p);
   operator ISdoCollection*() const throw ()
   { return self; }

   // Removes all attributes from the profile.
   void clear();

   Sdo find(ATTRIBUTEID id) const;

   void clearValue(ATTRIBUTEID id);

   bool getValue(ATTRIBUTEID id, bool& value) const;
   bool getValue(ATTRIBUTEID id, LONG& value) const;
   bool getValue(ATTRIBUTEID id, CComBSTR& value) const;
   bool getValue(ATTRIBUTEID id, VARIANT& value) const;

   void setValue(ATTRIBUTEID id, bool value);
   void setValue(ATTRIBUTEID id, LONG value);
   void setValue(ATTRIBUTEID id, BSTR value);
   void setValue(ATTRIBUTEID id, const VARIANT& val);

   typedef ISdoCollection Interface;

protected:
   ISdo* getAlways(ATTRIBUTEID id);
   ISdo* getExisting(ATTRIBUTEID id) const;

   typedef ObjectVector<ISdo> SdoVector;

private:
   SdoConnection& cxn;
   SdoCollection self;
   SdoVector attrs;

   // Not implemented.
   SdoProfile(const SdoProfile&);
   SdoProfile& operator=(const SdoProfile&);
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    InterfaceStream
//
// DESCRIPTION
//
//    Helper class for storing an interface in a stream. This class is suitable
//    for standalone use; however, when marshalling the SDO wrapper classes,
//    you should use the type safe SdoStream instead.
//
///////////////////////////////////////////////////////////////////////////////
class InterfaceStream
{
public:
   InterfaceStream() throw ()
      : stream(NULL)
   { }

   ~InterfaceStream() throw ()
   { if (stream) { stream->Release(); } }

   // Marshal an interface into the stream.
   void marshal(REFIID riid, LPUNKNOWN pUnk);

   // Retrieve the marshalled interface.
   void get(REFIID riid, LPVOID* ppv);

private:
   IStream* stream;

   // Not implemented.
   InterfaceStream(const InterfaceStream&);
   InterfaceStream& operator=(const InterfaceStream&);
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SdoStream
//
// DESCRIPTION
//
//    Class for storing an SDO wrapper in a stream.
//
///////////////////////////////////////////////////////////////////////////////
template <class T>
class SdoStream
{
public:
   SdoStream() throw ()
   { }

   SdoStream(T& s)
   { marshal(s); }

   void marshal(T& s)
   { stream.marshal(__uuidof(T::Interface), (T::Interface*)s); }

   void get(T& s)
   {
      CComPtr<T::Interface> p;
      stream.get(__uuidof(T::Interface), (PVOID*)&p);
      s = p;
   }

private:
   InterfaceStream stream;

   // Not implemented.
   SdoStream(const SdoStream&);
   SdoStream& operator=(const SdoStream&);
};

#endif // SDOWRAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\servergroups.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    servergroups.cpp
//
// SYNOPSIS
//
//    Defines the classes ServerGroup and ServerGroups.
//
// MODIFICATION HISTORY
//
//    02/10/2000    Original version.
//    04/19/2000    SdoScopeItem::getSelf returns by value, not reference.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <servergroups.h>
#include <proxynode.h>
#include <grouppage.h>
#include <groupwiz.h>
#include <policywiz.h>
#include <iaslimits.h>

HRESULT ServerGroup::createPropertyPages(
                         SnapInView& view,
                         LPPROPERTYSHEETCALLBACK provider,
                         LONG_PTR handle
                         )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   ServerGroupPage* page = new ServerGroupPage(
                                   handle,
                                   (LPARAM)this,
                                   self
                                   );

   page->addToMMCSheet(provider);

   return S_OK;
}

HRESULT ServerGroup::onContextHelp(SnapInView& view) throw ()
{
   return view.displayHelp(L"ias_ops.chm::/sag_ias_crp_rsg.htm");
}

UINT ServerGroup::mapResourceId(ResourceId id) const throw ()
{
   static UINT resourceIds[] =
   {
      IMAGE_RADIUS_SERVER_GROUP,
      IDS_GROUP_DELETE_CAPTION,
      IDS_GROUP_DELETE_LOCAL,
      IDS_GROUP_DELETE_REMOTE,
      IDS_GROUP_DELETE_LOCAL,
      IDS_GROUP_DELETE_REMOTE,
      IDS_GROUP_E_CAPTION,
      IDS_GROUP_E_RENAME,
      IDS_GROUP_E_NAME_EMPTY
   };

   return resourceIds[id];
}

ServerGroups::ServerGroups(SdoConnection& connection)
   : SdoScopeItem(
         connection,
         IDS_GROUP_NODE,
         IDS_GROUP_E_CAPTION,
         IDS_GROUP_MENU_TOP,
         IDS_GROUP_MENU_NEW,
         IDS_GROUP_MENU_STATUS_BAR
         ),
     nameColumn(IDS_GROUP_COLUMN_NAME)
{ }

HRESULT ServerGroups::onContextHelp(SnapInView& view) throw ()
{
   return view.displayHelp(L"ias_ops.chm::/sag_ias_crp_rsg.htm");
}

SdoCollection ServerGroups::getSelf()
{
   return cxn.getServerGroups();
}

void ServerGroups::getResultItems(SdoEnum& src, ResultItems& dst)
{
   Sdo itemSdo;
   while (src.next(itemSdo))
   {
      CComPtr<ServerGroup> newItem(new (AfxThrow) ServerGroup(
                                                      *this,
                                                      itemSdo
                                                      ));

      dst.push_back(newItem);
   }
}

void ServerGroups::insertColumns(IHeaderCtrl2* headerCtrl)
{
   CheckError(headerCtrl->InsertColumn(0, nameColumn, LVCFMT_LEFT, 310));
}

HRESULT ServerGroups::onMenuCommand(
                          SnapInView& view,
                          long commandId
                          )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   // Fire up the wizard.
   NewGroupWizard wizard(cxn, NULL, true);
   INT_PTR result = wizard.DoModal();
   if (result == IAS_E_LICENSE_VIOLATION)
   {
      int retval;
      view.formatMessageBox(
              IDS_GROUP_E_CAPTION,
              IDS_GROUP_E_LICENSE,
              TRUE,
              MB_OK | MB_ICONWARNING,
              &retval
              );
   }
   else if (result != IDCANCEL)
   {
      // User finished, so create a new DataItem
      CComPtr<ServerGroup> newItem(new (AfxThrow) ServerGroup(
                                                      *this,
                                                      wizard.group
                                                      ));
      // ... and add it to the result pane.
      addResultItem(view, *newItem);

      // Did the user want to create a policy as well ?
      if (wizard.createNewPolicy())
      {
         // Yes, so launch the new policy wizard.
         NewPolicyWizard policyWizard(cxn, &view);
         policyWizard.DoModal();
      }

      // Tell the service to reload.
      cxn.resetService();

   }

   return S_OK;
}

void ServerGroups::propertyChanged(SnapInView& view, IASPROPERTIES id)
{
   if (id == PROPERTY_IAS_RADIUSSERVERGROUPS_COLLECTION)
   {
      view.updateAllViews(*this);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\serverprop.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    serverprop.cpp
//
// SYNOPSIS
//
//    Defines the classes that make up the RADIUS Server property sheet.
//
// MODIFICATION HISTORY
//
//    02/27/2000    Original version.
//    04/19/2000    Marshall SDOs across apartments.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <serverprop.h>
#include <resolver.h>

// Fake secret used for populating the edit control.
const WCHAR FAKE_SECRET[] = L"\b\b\b\b\b\b\b\b";

ServerNamePage::ServerNamePage(Sdo& serverSdo)
   : SnapInPropertyPage(IDD_SERVER_NAME),
     server(serverSdo)
{
   server.getValue(PROPERTY_RADIUSSERVER_ADDRESS, address, L"");
}

void ServerNamePage::onResolve()
{
   // Get the address.
   getValue(IDC_EDIT_NAME, address);

   // Pass it to the resolver.
   ServerResolver resolver(address);
   if (resolver.DoModal() == IDOK)
   {
      // The user clicked OK, so save his choice.
      setValue(IDC_EDIT_NAME, resolver.getChoice());
   }
}

void ServerNamePage::getData()
{
   // Get the address.
   getValue(IDC_EDIT_NAME, address);

   // The address can't be empty.
   if (address.Length() == 0)
   {
      fail(IDC_EDIT_NAME, IDS_SERVER_E_NAME_EMPTY);
   }
}

void ServerNamePage::setData()
{
   setValue(IDC_EDIT_NAME, address);
}

void ServerNamePage::saveChanges()
{
   server.setValue(PROPERTY_RADIUSSERVER_ADDRESS, address);
}

BEGIN_MESSAGE_MAP(ServerNamePage, SnapInPropertyPage)
   ON_EN_CHANGE(IDC_EDIT_NAME, onChange)
   ON_BN_CLICKED(IDC_BUTTON_VERIFY, onResolve)
END_MESSAGE_MAP()

ServerAuthPage::ServerAuthPage(Sdo& serverSdo)
   : SnapInPropertyPage(IDD_SERVER_AUTH),
     server(serverSdo),
     authSecretDirty(false),
     acctSecretDirty(false)
{
   server.getValue(PROPERTY_RADIUSSERVER_AUTH_PORT, authPort, 1812);
   server.getValue(PROPERTY_RADIUSSERVER_AUTH_SECRET, authSecret, L"");
   server.getValue(PROPERTY_RADIUSSERVER_ACCT_PORT, acctPort, 1813);
   server.getValue(PROPERTY_RADIUSSERVER_ACCT_SECRET, acctSecret, NULL);
   useSameSecret = !acctSecret;
   server.getValue(PROPERTY_RADIUSSERVER_FORWARD_ACCT_ONOFF, acctOnOff, true);
}

void ServerAuthPage::onChangeAuthSecret()
{
   authSecretDirty = true;
   SetModified();
}

void ServerAuthPage::onChangeAcctSecret()
{
   acctSecretDirty = true;
   SetModified();
}

void ServerAuthPage::onCheckSameSecret()
{
   // Get the checkbox state.
   getValue(IDC_CHECK_SAME_SECRET, useSameSecret);

   // Update the edit box accordingly.
   enableControl(IDC_EDIT_ACCT_SECRET1, !useSameSecret);
   enableControl(IDC_EDIT_ACCT_SECRET2, !useSameSecret);

   // We've been modified.
   SetModified();
}

void ServerAuthPage::getData()
{
   getValue(IDC_EDIT_AUTH_PORT, authPort, IDS_SERVER_E_PORT_RANGE);
   if (authPort <= 0 || authPort > 65535)
   {
      fail(IDC_EDIT_AUTH_PORT, IDS_SERVER_E_PORT_RANGE);
   }

   if (authSecretDirty)
   {
      // Get the authentication secret ...
      getValue(IDC_EDIT_AUTH_SECRET1, authSecret, false);

      // ... and make sure it matches the confirmation.
      CComBSTR confirm;
      getValue(IDC_EDIT_AUTH_SECRET2, confirm, false);
      if (wcscmp(confirm, authSecret))
      {
         fail(IDC_EDIT_AUTH_SECRET1, IDS_SERVER_E_SECRET_MATCH);
      }

      authSecretDirty = false;
   }

   getValue(IDC_EDIT_ACCT_PORT, acctPort, IDS_SERVER_E_PORT_RANGE);
   if (acctPort <= 0 || acctPort > 65535)
   {
      fail(IDC_EDIT_ACCT_PORT, IDS_SERVER_E_PORT_RANGE);
   }

   getValue(IDC_CHECK_SAME_SECRET, useSameSecret);

   if (!useSameSecret && acctSecretDirty)
   {
      // Get the accounting secret ...
      getValue(IDC_EDIT_ACCT_SECRET1, acctSecret);

      // ... and make sure it matches the confirmation.
      CComBSTR confirm;
      getValue(IDC_EDIT_ACCT_SECRET2, confirm);
      if (wcscmp(confirm, acctSecret))
      {
         fail(IDC_EDIT_ACCT_SECRET1, IDS_SERVER_E_SECRET_MATCH);
      }

      acctSecretDirty = false;
   }

   getValue(IDC_CHECK_ACCT_ONOFF, acctOnOff);
}

void ServerAuthPage::setData()
{
   setValue(IDC_EDIT_AUTH_PORT,    authPort);
   setValue(IDC_EDIT_AUTH_SECRET1, FAKE_SECRET);
   setValue(IDC_EDIT_AUTH_SECRET2, FAKE_SECRET);

   setValue(IDC_EDIT_ACCT_PORT, acctPort);
   setValue(IDC_CHECK_SAME_SECRET, useSameSecret);
   setValue(IDC_EDIT_ACCT_SECRET1, FAKE_SECRET);
   setValue(IDC_EDIT_ACCT_SECRET2, FAKE_SECRET);
   setValue(IDC_CHECK_ACCT_ONOFF, acctOnOff);

   // Update the edit box state.
   enableControl(IDC_EDIT_ACCT_SECRET1, !useSameSecret);
   enableControl(IDC_EDIT_ACCT_SECRET2, !useSameSecret);
}

void ServerAuthPage::saveChanges()
{
   server.setValue(PROPERTY_RADIUSSERVER_AUTH_PORT, authPort);
   server.setValue(PROPERTY_RADIUSSERVER_AUTH_SECRET, authSecret);

   server.setValue(PROPERTY_RADIUSSERVER_ACCT_PORT, acctPort);
   if (useSameSecret)
   {
      server.clearValue(PROPERTY_RADIUSSERVER_ACCT_SECRET);
   }
   else
   {
      server.setValue(PROPERTY_RADIUSSERVER_ACCT_SECRET, acctSecret);
   }
   server.setValue(PROPERTY_RADIUSSERVER_FORWARD_ACCT_ONOFF, acctOnOff);
}

BEGIN_MESSAGE_MAP(ServerAuthPage, SnapInPropertyPage)
   ON_EN_CHANGE(IDC_EDIT_AUTH_PORT,    onChange)
   ON_EN_CHANGE(IDC_EDIT_AUTH_SECRET1, onChangeAuthSecret)
   ON_EN_CHANGE(IDC_EDIT_AUTH_SECRET2, onChangeAuthSecret)
   ON_BN_CLICKED(IDC_CHECK_SAME_SECRET, onCheckSameSecret)
   ON_BN_CLICKED(IDC_CHECK_ACCT_ONOFF, onChange)
   ON_EN_CHANGE(IDC_EDIT_ACCT_PORT, onChange)
   ON_EN_CHANGE(IDC_EDIT_ACCT_SECRET1, onChangeAcctSecret)
   ON_EN_CHANGE(IDC_EDIT_ACCT_SECRET2, onChangeAcctSecret)
END_MESSAGE_MAP()

ServerFTLBPage::ServerFTLBPage(Sdo& serverSdo)
   : SnapInPropertyPage(IDD_SERVER_FTLB),
     server(serverSdo)
{
   server.getValue(PROPERTY_RADIUSSERVER_PRIORITY, priority, 1);
   server.getValue(PROPERTY_RADIUSSERVER_WEIGHT, weight, 50);
   server.getValue(PROPERTY_RADIUSSERVER_TIMEOUT, timeout, 3);
   server.getValue(PROPERTY_RADIUSSERVER_MAX_LOST, maxLost, 5);
   server.getValue(PROPERTY_RADIUSSERVER_BLACKOUT, blackout, 10 * timeout);
}

void ServerFTLBPage::getData()
{
   getValue(IDC_EDIT_PRIORITY, priority, IDS_SERVER_E_PRIORITY_EMPTY);
   if (priority < 1 || priority > 65535)
   {
      fail(IDC_EDIT_PRIORITY, IDS_SERVER_E_PRIORITY_RANGE);
   }

   getValue(IDC_EDIT_WEIGHT, weight, IDS_SERVER_E_WEIGHT_EMPTY);
   if (weight < 1 || weight > 65535)
   {
      fail(IDC_EDIT_WEIGHT, IDS_SERVER_E_WEIGHT_RANGE);
   }

   getValue(IDC_EDIT_TIMEOUT, timeout, IDS_SERVER_E_TIMEOUT_EMPTY);
   if (timeout < 1)
   {
      fail(IDC_EDIT_TIMEOUT, IDS_SERVER_E_TIMEOUT_RANGE);
   }

   getValue(IDC_EDIT_MAX_LOST, maxLost, IDS_SERVER_E_MAXLOST_EMPTY);
   if (maxLost < 1)
   {
      fail(IDC_EDIT_MAX_LOST, IDS_SERVER_E_MAXLOST_RANGE);
   }

   getValue(IDC_EDIT_BLACKOUT, blackout, IDS_SERVER_E_BLACKOUT_EMPTY);
   if (blackout < timeout)
   {
      fail(IDC_EDIT_BLACKOUT, IDS_SERVER_E_BLACKOUT_RANGE);
   }
}

void ServerFTLBPage::setData()
{
   setValue(IDC_EDIT_PRIORITY, priority);
   setValue(IDC_EDIT_WEIGHT, weight);
   setValue(IDC_EDIT_TIMEOUT, timeout);
   setValue(IDC_EDIT_MAX_LOST, maxLost);
   setValue(IDC_EDIT_BLACKOUT, blackout);
}

void ServerFTLBPage::saveChanges()
{
   server.setValue(PROPERTY_RADIUSSERVER_PRIORITY, priority);
   server.setValue(PROPERTY_RADIUSSERVER_WEIGHT, weight);
   server.setValue(PROPERTY_RADIUSSERVER_TIMEOUT, timeout);
   server.setValue(PROPERTY_RADIUSSERVER_MAX_LOST, maxLost);
   server.setValue(PROPERTY_RADIUSSERVER_BLACKOUT, blackout);
}

BEGIN_MESSAGE_MAP(ServerFTLBPage, SnapInPropertyPage)
   ON_EN_CHANGE(IDC_EDIT_PRIORITY, onChange)
   ON_EN_CHANGE(IDC_EDIT_WEIGHT, onChange)
   ON_EN_CHANGE(IDC_EDIT_TIMEOUT, onChange)
   ON_EN_CHANGE(IDC_EDIT_MAX_LOST, onChange)
   ON_EN_CHANGE(IDC_EDIT_BLACKOUT, onChange)
END_MESSAGE_MAP()

ServerProperties::ServerProperties(Sdo& sdo, UINT nIDCaption, CWnd* parent)
   : CPropertySheet(nIDCaption, parent),
     server(sdo),
     serverStream(server),
     name(sdo),
     auth(sdo),
     ftlb(sdo)
{
   // Add the property pages.
   AddPage(&name);
   AddPage(&auth);
   AddPage(&ftlb);
}

INT_PTR ServerProperties::DoModal()
{
   CPropertySheet::DoModal();

   if (name.hasApplied() ||
       auth.hasApplied() ||
       ftlb.hasApplied())
   {
      return IDOK;
   }
   else
   {
      return IDCANCEL;
   }
}

BOOL ServerProperties::OnInitDialog()
{
   // Unmarshal the SDOs.
   serverStream.get(server);
   BOOL bResult = CPropertySheet::OnInitDialog();
   ModifyStyleEx(0, WS_EX_CONTEXTHELP); 
   return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\serverprop.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    serverprop.h
//
// SYNOPSIS
//
//    Declares the classes that make up the RADIUS Server property sheet.
//
// MODIFICATION HISTORY
//
//    02/27/2000    Original version.
//    04/19/2000    Marshall SDOs across apartments.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef SERVERPROP_H
#define SERVERPROP_H
#if _MSC_VER >= 1000
#pragma once
#endif

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ServerNamePage
//
// DESCRIPTION
//
//    The default property page, contains the server address.
//
///////////////////////////////////////////////////////////////////////////////
class ServerNamePage : public SnapInPropertyPage
{
public:
   ServerNamePage(Sdo& serverSdo);

protected:
   afx_msg void onResolve();

   DECLARE_MESSAGE_MAP()

   DEFINE_ERROR_CAPTION(IDS_GROUP_E_CAPTION);

   virtual void getData();
   virtual void setData();
   virtual void saveChanges();

   Sdo& server;
   CComBSTR address;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ServerAuthPage
//
// DESCRIPTION
//
//    The Authentication / Accounting property page.
//
///////////////////////////////////////////////////////////////////////////////
class ServerAuthPage : public SnapInPropertyPage
{
public:
   ServerAuthPage(Sdo& serverSdo);

protected:
   afx_msg void onChangeAuthSecret();
   afx_msg void onChangeAcctSecret();
   afx_msg void onCheckSameSecret();

   DECLARE_MESSAGE_MAP()

   DEFINE_ERROR_CAPTION(IDS_GROUP_E_CAPTION);

   virtual void getData();
   virtual void setData();
   virtual void saveChanges();

   Sdo& server;
   LONG authPort;
   CComBSTR authSecret;
   bool authSecretDirty;
   LONG acctPort;
   bool useSameSecret;
   CComBSTR acctSecret;
   bool acctSecretDirty;
   bool acctOnOff;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ServerFTLBPage
//
// DESCRIPTION
//
//    The Load-balancing property page.
//
///////////////////////////////////////////////////////////////////////////////
class ServerFTLBPage : public SnapInPropertyPage
{
public:
   ServerFTLBPage(Sdo& serverSdo);

protected:
   DECLARE_MESSAGE_MAP()

   DEFINE_ERROR_CAPTION(IDS_GROUP_E_CAPTION);

   virtual void getData();
   virtual void setData();
   virtual void saveChanges();

   Sdo& server;
   LONG priority;
   LONG weight;
   LONG timeout;
   LONG maxLost;
   LONG blackout;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ServerProperties
//
// DESCRIPTION
//
//    The RADIUS Server property sheet.
//
///////////////////////////////////////////////////////////////////////////////
class ServerProperties : public CPropertySheet
{
public:
   ServerProperties(
       Sdo& sdo,
       UINT nIDCaption = IDS_SERVER_CAPTION,
       CWnd* pParentWnd = NULL
       );

   virtual INT_PTR DoModal();

protected:
   virtual BOOL OnInitDialog();

   Sdo server;
   SdoStream<Sdo> serverStream;
   ServerNamePage name;
   ServerAuthPage auth;
   ServerFTLBPage ftlb;
};

#endif // SERVERPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\servergroups.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    servergroups.h
//
// SYNOPSIS
//
//    Declares the classes ServerGroup and ServerGroups.
//
// MODIFICATION HISTORY
//
//    02/10/2000    Original version.
//    04/19/2000    SdoScopeItem::getSelf returns by value, not reference.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef SERVERGROUPS_H
#define SERVERGROUPS_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <sdonode.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ServerGroup
//
// DESCRIPTION
//
//    Implements SnapInDataItem for a server group result pane item.
//
///////////////////////////////////////////////////////////////////////////////
class ServerGroup : public SdoResultItem
{
public:
   ServerGroup(
       SdoScopeItem& owner,
       ISdo* sdo
       )
      : SdoResultItem(owner, sdo)
   { }

   virtual PCWSTR getDisplayName(int column = 0) const throw ()
   { return name; }

   virtual HRESULT createPropertyPages(
                       SnapInView& view,
                       LPPROPERTYSHEETCALLBACK provider,
                       LONG_PTR handle
                       );

   virtual HRESULT onContextHelp(SnapInView& view) throw ();

protected:
   virtual UINT mapResourceId(ResourceId id) const throw ();
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ServerGroups
//
// DESCRIPTION
//
//    Implements SnapInDataItem for the server groups scope pane node.
//
///////////////////////////////////////////////////////////////////////////////
class __declspec(uuid("f156cdba-aca3-4cb2-abb2-fb8921ee8512")) ServerGroups;
class ServerGroups : public SdoScopeItem
{
public:
   ServerGroups(SdoConnection& connection);

   const GUID* getNodeType() const throw ()
   { return &__uuidof(this); }

   virtual HRESULT onContextHelp(SnapInView& view) throw ();

protected:
   virtual SdoCollection getSelf();
   virtual void getResultItems(SdoEnum& src, ResultItems& dst);
   virtual void insertColumns(IHeaderCtrl2* headerCtrl);

   virtual HRESULT onMenuCommand(
                       SnapInView& view,
                       long commandId
                       );

   virtual void propertyChanged(SnapInView& view, IASPROPERTIES id);

private:
   ResourceString nameColumn;
};

#endif // SERVERGROUPS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\snapwork.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    snapwork.cpp
//
// SYNOPSIS
//
//    Defines classes for implementing an MMC Snap-In.
//
// MODIFICATION HISTORY
//
//    02/19/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <snapwork.h>

namespace SnapIn
{
   void AfxThrowLastError()
   {
      DWORD error = GetLastError();
      AfxThrowOleException(HRESULT_FROM_WIN32(error));
   }

   //////////
   // Clipboard formats we support.
   //////////

   const CLIPFORMAT CCF_ID_NODETYPE = (CLIPFORMAT)
      RegisterClipboardFormatW(CCF_NODETYPE);

   const CLIPFORMAT CCF_ID_SZNODETYPE = (CLIPFORMAT)
      RegisterClipboardFormatW(CCF_SZNODETYPE);

   const CLIPFORMAT CCF_ID_DISPLAY_NAME = (CLIPFORMAT)
      RegisterClipboardFormatW(CCF_DISPLAY_NAME);

   const CLIPFORMAT CCF_ID_SNAPIN_CLASSID = (CLIPFORMAT)
      RegisterClipboardFormatW(CCF_SNAPIN_CLASSID);

   //////////
   // Helper function that returns the length of a string in bytes.
   //////////
   inline ULONG wcsbytelen(PCWSTR sz) throw ()
   {
      return (wcslen(sz) + 1) * sizeof(WCHAR);
   }

   //////////
   // Helper functions that writes data to an HGLOBAL
   //////////

   HRESULT WriteDataToHGlobal(
               HGLOBAL& dst,
               const VOID* data,
               ULONG dataLen
               ) throw ()
   {
      if (GlobalSize(dst) < dataLen)
      {
         HGLOBAL newGlobal = GlobalReAlloc(dst, dataLen, 0);
         if (!newGlobal) { return E_OUTOFMEMORY; }
         dst = newGlobal;
      }

      memcpy(dst, data, dataLen);

      return S_OK;
   }

   //////////
   // Helper function that loads a string resource.
   //////////

   ULONG LoadString(
             HMODULE module,
             UINT id,
             PCWSTR* string
             ) throw ()
   {
      HRSRC resInfo = FindResourceW(
                          module,
                          MAKEINTRESOURCEW((id >> 4) + 1),
                          RT_STRING
                          );
      if (resInfo)
      {
         HGLOBAL resData = LoadResource(
                               module,
                               resInfo
                               );
         if (resData)
         {
            PCWSTR sz = (PCWSTR)LockResource(resData);
            if (sz)
            {
               // Skip forward to our string.
               for (id &= 0xf; id > 0; --id)
               {
                  sz += *sz + 1;
               }

               *string = sz + 1;
               return *sz;
            }
         }
      }

      *string = NULL;
      return 0;
   }
}

// Static member of ResourceString
WCHAR ResourceString::empty;

ResourceString::ResourceString(UINT id) throw ()
{
   PCWSTR string;
   ULONG length = LoadString(
                      _Module.GetResourceInstance(),
                      id,
                      &string
                      );
   sz = new (std::nothrow) WCHAR[length + 1];
   if (sz)
   {
      memcpy(sz, string, length * sizeof(WCHAR));
      sz[length] = L'\0';
   }
   else
   {
      sz = &empty;
   }
}

///////////////////////////////////////////////////////////////////////////////
//
// Methods for manipulating a generic IDataObject (i.e., not necessarily one of
// ours).
//
///////////////////////////////////////////////////////////////////////////////

VOID
WINAPI
ExtractData(
    IDataObject* dataObject,
    CLIPFORMAT format,
    PVOID data,
    DWORD dataLen
    )
{
   HGLOBAL global;
   ExtractData(
       dataObject,
       format,
       dataLen,
       &global
       );
   memcpy(data, global, dataLen);
   GlobalFree(global);
}

VOID
WINAPI
ExtractData(
    IDataObject* dataObject,
    CLIPFORMAT format,
    DWORD maxDataLen,
    HGLOBAL* data
    )
{
   if (!dataObject) { AfxThrowOleException(E_POINTER); }

   FORMATETC formatetc =
   {
      format,
      NULL,
      DVASPECT_CONTENT,
      -1,
      TYMED_HGLOBAL
   };

   STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };

   stgmedium.hGlobal = GlobalAlloc(GPTR, maxDataLen);
   if (!stgmedium.hGlobal) { AfxThrowOleException(E_OUTOFMEMORY); }

   HRESULT hr = dataObject->GetDataHere(&formatetc, &stgmedium);
   if (SUCCEEDED(hr))
   {
      *data = stgmedium.hGlobal;
   }
   else
   {
      GlobalFree(stgmedium.hGlobal);
      AfxThrowOleException(hr);
   }
}

VOID
WINAPI
ExtractNodeType(
    IDataObject* dataObject,
    GUID* nodeType
    )
{
   ExtractData(
       dataObject,
       CCF_ID_NODETYPE,
       nodeType,
       sizeof(GUID)
       );
}

// Convert an IDataObject to its corresponding SnapInDataItem.
SnapInDataItem* SnapInDataItem::narrow(IDataObject* dataObject) throw ()
{
   if (!dataObject) { return NULL; }

   SnapInDataItem* object;
   HRESULT hr = dataObject->QueryInterface(
                                __uuidof(SnapInDataItem),
                                (PVOID*)&object
                                );
   if (FAILED(hr)) { return NULL; }

   object->Release();

   return object;
}

// Default implementations of various functions used by GetDataHere. This way
// derived classes don't have to implement these if they're sure MMC will never
// ask for them.
const GUID* SnapInDataItem::getNodeType() const throw ()
{ return &GUID_NULL; }
const GUID* SnapInDataItem::getSnapInCLSID() const throw ()
{ return &GUID_NULL; }
PCWSTR SnapInDataItem::getSZNodeType() const throw ()
{ return L"{00000000-0000-0000-0000-000000000000}"; }

// By default we compare column items as case sensitive strings.
int SnapInDataItem::compare(
                        SnapInDataItem& item,
                        int column
                        ) throw ()
{
   return wcscmp(getDisplayName(column), item.getDisplayName(column));
}

//////////
// Do nothing implementations of all the notifications, etc.
//////////

HRESULT SnapInDataItem::addMenuItems(
                            SnapInView& view,
                            LPCONTEXTMENUCALLBACK callback,
                            long insertionAllowed
                            )
{ return S_FALSE; }

HRESULT SnapInDataItem::createPropertyPages(
                            SnapInView& view,
                            LPPROPERTYSHEETCALLBACK provider,
                            LONG_PTR handle
                            )
{ return S_FALSE; }

HRESULT SnapInDataItem::queryPagesFor() throw ()
{ return S_FALSE; }

HRESULT SnapInDataItem::getResultViewType(
                            LPOLESTR* ppViewType,
                            long* pViewOptions
                            ) throw ()
{ return S_FALSE; }

HRESULT SnapInDataItem::onButtonClick(
                            SnapInView& view,
                            MMC_CONSOLE_VERB verb
                            )
{ return S_FALSE; }

HRESULT SnapInDataItem::onContextHelp(
                            SnapInView& view
                            )
{ return S_FALSE; }

HRESULT SnapInDataItem::onDelete(
                            SnapInView& view
                            )
{ return S_FALSE; }

HRESULT SnapInDataItem::onDoubleClick(
                            SnapInView& view
                            )
{ return S_FALSE; }

HRESULT SnapInDataItem::onExpand(
                           SnapInView& view,
                           HSCOPEITEM itemId,
                           BOOL expanded
                           )
{ return S_FALSE; }

HRESULT SnapInDataItem::onMenuCommand(
                            SnapInView& view,
                            long commandId
                            )
{ return S_FALSE; }

HRESULT SnapInDataItem::onPropertyChange(
                            SnapInView& view,
                            BOOL scopeItem
                            )
{ return S_FALSE; }

HRESULT SnapInDataItem::onRefresh(SnapInView& view)
{ return S_FALSE; }

HRESULT SnapInDataItem::onRename(
                            SnapInView& view,
                            LPCOLESTR newName
                            )
{ return S_FALSE; }

HRESULT SnapInDataItem::onSelect(
                            SnapInView& view,
                            BOOL scopeItem,
                            BOOL selected
                            )
{ return S_FALSE; }

HRESULT SnapInDataItem::onShow(
                            SnapInView& view,
                            HSCOPEITEM itemId,
                            BOOL selected
                            )
{ return S_FALSE; }


HRESULT SnapInDataItem::onToolbarButtonClick(
                            SnapInView& view,
                            int buttonId
                            )
{ return S_FALSE; }

HRESULT SnapInDataItem::onToolbarSelect(
                            SnapInView& view,
                            BOOL scopeItem,
                            BOOL selected
                            )
{ return S_FALSE; }

HRESULT SnapInDataItem::onViewChange(
                            SnapInView& view,
                            LPARAM data,
                            LPARAM hint
                            )
{ return S_FALSE; }

//////////
// IUnknown
//////////

STDMETHODIMP_(ULONG) SnapInDataItem::AddRef()
{
   return InterlockedIncrement(&refCount);
}

STDMETHODIMP_(ULONG) SnapInDataItem::Release()
{
   LONG l = InterlockedDecrement(&refCount);

   if (l == 0) { delete this; }

   return l;
}

STDMETHODIMP SnapInDataItem::QueryInterface(REFIID iid, void ** ppvObject)
{
   if (ppvObject == NULL)
   {
      return E_POINTER;
   }
   else if (iid == __uuidof(SnapInDataItem) ||
            iid == __uuidof(IUnknown)       ||
            iid == __uuidof(IDataObject))
   {
      *ppvObject = this;
   }
   else
   {
      *ppvObject = NULL;
      return E_NOINTERFACE;
   }

   AddRef();
   return S_OK;
}

//////////
// IDataObject
//////////

STDMETHODIMP SnapInDataItem::GetData(
                                 FORMATETC *pformatetcIn,
                                 STGMEDIUM *pmedium
                                 )
{ return E_NOTIMPL; }

STDMETHODIMP SnapInDataItem::GetDataHere(
                                 FORMATETC *pformatetc,
                                 STGMEDIUM *pmedium
                                 )
{

   if (pmedium == NULL) { return E_POINTER; }
   if (pmedium->tymed != TYMED_HGLOBAL) { return DV_E_TYMED; }

   ULONG dataLen;
   const VOID* data;

   if (pformatetc->cfFormat == CCF_ID_NODETYPE)
   {
      dataLen = sizeof(GUID);
      data = getNodeType();
   }
   else if (pformatetc->cfFormat == CCF_ID_DISPLAY_NAME)
   {
      dataLen = wcsbytelen(getDisplayName());
      data = getDisplayName();
   }
   else if (pformatetc->cfFormat == CCF_ID_SZNODETYPE)
   {
      dataLen = wcsbytelen(getSZNodeType());
      data = getSZNodeType();
   }
   else if (pformatetc->cfFormat == CCF_ID_SNAPIN_CLASSID)
   {
      dataLen = sizeof(GUID);
      data = getSnapInCLSID();
   }
   else
   {
      return DV_E_CLIPFORMAT;
   }

   return WriteDataToHGlobal(pmedium->hGlobal, data, dataLen);
}

STDMETHODIMP SnapInDataItem::QueryGetData(
                                 FORMATETC *pformatetc
                                 )
{ return E_NOTIMPL; }

STDMETHODIMP SnapInDataItem::GetCanonicalFormatEtc(
                                 FORMATETC *pformatectIn,
                                 FORMATETC *pformatetcOut
                                 )
{ return E_NOTIMPL; }

STDMETHODIMP SnapInDataItem::SetData(
                                 FORMATETC *pformatetc,
                                 STGMEDIUM *pmedium,
                                 BOOL fRelease
                                 )
{ return E_NOTIMPL; }

STDMETHODIMP SnapInDataItem::EnumFormatEtc(
                                 DWORD dwDirection,
                                 IEnumFORMATETC **ppenumFormatEtc
                                 )
{ return E_NOTIMPL; }

STDMETHODIMP SnapInDataItem::DAdvise(
                                 FORMATETC *pformatetc,
                                 DWORD advf,
                                 IAdviseSink *pAdvSink,
                                 DWORD *pdwConnection
                                 )
{ return E_NOTIMPL; }

STDMETHODIMP SnapInDataItem::DUnadvise(
                                 DWORD dwConnection
                                 )
{ return E_NOTIMPL; }

STDMETHODIMP SnapInDataItem::EnumDAdvise(
                                 IEnumSTATDATA **ppenumAdvise
                                 )
{ return E_NOTIMPL; }

SnapInDataItem::~SnapInDataItem() throw ()
{ }

PCWSTR SnapInPreNamedItem::getDisplayName(int column) const throw ()
{ return name; }

HRESULT SnapInView::displayHelp(PCWSTR  contextHelpPath)
{
   CComPtr<IDisplayHelp>  displayHelp;

   HRESULT hr = console->QueryInterface(
                       __uuidof(IDisplayHelp),
                       (PVOID*)&displayHelp
                       );
   if (FAILED(hr)) { return hr; }

   return displayHelp->ShowTopic(const_cast<LPWSTR>(contextHelpPath));
}

void SnapInView::updateAllViews(
                    SnapInDataItem& item,
                    LPARAM data,
                    INT_PTR hint
                    ) const
{
   CheckError(master->getConsole()->UpdateAllViews(&item, data, hint));
}

void SnapInView::deleteResultItem(const SnapInDataItem& item) const
{
   HRESULTITEM itemId;
   CheckError(resultData->FindItemByLParam((LPARAM)&item, &itemId));
   CheckError(resultData->DeleteItem(itemId, 0));
}

void SnapInView::updateResultItem(const SnapInDataItem& item) const
{
   if (resultData != NULL)
   {
      HRESULTITEM itemId;
      CheckError(resultData->FindItemByLParam((LPARAM)&item, &itemId));
      CheckError(resultData->UpdateItem(itemId));
   }
}

bool SnapInView::isPropertySheetOpen(const SnapInDataItem& item) const
{
   HRESULT hr = sheetProvider->FindPropertySheet(
                                   (MMC_COOKIE)&item,
                                   const_cast<SnapInView*>(this),
                                   const_cast<SnapInDataItem*>(&item)
                                   );
   CheckError(hr);
   return hr == S_OK;
}

IToolbar* SnapInView::attachToolbar(size_t index)
{
   // Make sure we have a controlbar.
   if (!controlbar) { AfxThrowOleException(E_POINTER); }

   // Get the entry for this index.
   ToolbarEntry& entry = toolbars[index];

   // Create the toolbar if necessary.
   if (!entry.toolbar)
   {
      // Create the toolbar.
      CComPtr<IUnknown> unk;
      CheckError(controlbar->Create(TOOLBAR, this, &unk));

      CComPtr<IToolbar> newToolbar;
      CheckError(unk->QueryInterface(__uuidof(IToolbar), (PVOID*)&newToolbar));

      const SnapInToolbarDef& def = *(entry.def);

      // Add the bitmaps.
      CheckError(newToolbar->AddBitmap(
                                 def.nImages,
                                 def.hbmp,
                                 16,
                                 16,
                                 def.crMask
                                 ));

      // Add the buttons.
      CheckError(newToolbar->AddButtons( def.nButtons, def.lpButtons));

      // All went well, so save it away.
      entry.toolbar = newToolbar;
   }

   // Attach the toolbar to the controlbar ...
   CheckError(controlbar->Attach(TOOLBAR, entry.toolbar));

   return entry.toolbar;
}

void SnapInView::detachToolbar(size_t index) throw ()
{
   if (toolbars[index].toolbar)
   {
      // We don't care if this fails, because there's nothing we can do about
      // it anyway.
      controlbar->Detach(toolbars[index].toolbar);
   }
}

void SnapInView::reSort() const
{
   CheckError(resultData->Sort(sortColumn, sortOption, 0));
}

void SnapInView::formatMessageBox(
                     UINT titleId,
                     UINT formatId,
                     BOOL ignoreInserts,
                     UINT style,
                     int* retval,
                     ...
                     )
{
   ResourceString title(titleId);
   ResourceString format(formatId);

   HRESULT hr;

   if (ignoreInserts)
   {
      hr = console->MessageBox(
                        format,
                        title,
                        style,
                        retval
                        );
   }
   else
   {
      va_list marker;
      va_start(marker, retval);
      PWSTR text;
      DWORD nchar = FormatMessageW(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_STRING,
                        format,
                        0,
                        0,
                        (PWSTR)&text,
                        4096,
                        &marker
                        );
      va_end(marker);

      if (!nchar) { AfxThrowLastError(); }

      hr = console->MessageBox(
                        text,
                        title,
                        style,
                        retval
                        );
      LocalFree(text);
   }

   CheckError(hr);
}

void SnapInView::setImageStrip(
                        UINT smallStripId,
                        UINT largeStripId,
                        BOOL scopePane
                        )
{
   //////////
   // Load the bitmaps.
   //////////

   HBITMAP smallStrip, largeStrip;


   smallStrip = LoadBitmap(
                    _Module.GetModuleInstance(),
                    MAKEINTRESOURCE(smallStripId)
                    );
   if (smallStrip)
   {
      largeStrip = LoadBitmap(
                       _Module.GetModuleInstance(),
                       MAKEINTRESOURCE(largeStripId)
                       );
   }

   if (!smallStrip || !largeStrip)
   {
      AfxThrowLastError();
   }

   //////////
   // Set the image strip.
   //////////

   HRESULT hr;
   IImageList* imageList;
   if (scopePane)
   {
      hr = console->QueryScopeImageList(&imageList);
   }
   else
   {
      hr = console->QueryResultImageList(&imageList);
   }

   if (SUCCEEDED(hr))
   {
      hr = imageList->ImageListSetStrip(
                          (LONG_PTR*)smallStrip,
                          (LONG_PTR*)largeStrip,
                          0,
                          RGB(255, 0, 255)
                          );
      imageList->Release();
   }

   DeleteObject(smallStrip);
   DeleteObject(largeStrip);

   CheckError(hr);
}

STDMETHODIMP_(ULONG) SnapInView::AddRef()
{
   return InternalAddRef();
}

STDMETHODIMP_(ULONG) SnapInView::Release()
{
   ULONG l = InternalRelease();
   if (l == 0) { delete this; }
   return l;
}

STDMETHODIMP SnapInView::Initialize(LPCONSOLE lpConsole)
{
   HRESULT hr;

   hr = lpConsole->QueryInterface(
                       __uuidof(IConsole2),
                       (PVOID*)&console
                       );
   if (FAILED(hr)) { return hr; }

   hr = lpConsole->QueryInterface(
                       __uuidof(IHeaderCtrl2),
                       (PVOID*)&headerCtrl
                       );
   if (FAILED(hr)) { return hr; }

   hr = lpConsole->QueryInterface(
                       __uuidof(sheetProvider),
                       (PVOID*)&sheetProvider
                       );
   if (FAILED(hr)) { return hr; }

   hr = lpConsole->QueryInterface(
                       __uuidof(IResultData),
                       (PVOID*)&resultData
                       );
   if (FAILED(hr)) { return hr; }

   return S_OK;
}

STDMETHODIMP SnapInView::Destroy(MMC_COOKIE cookie)
{
   resultData.Release();
   sheetProvider.Release();
   headerCtrl.Release();
   console.Release();
   nameSpace.Release();
   return S_OK;
}

STDMETHODIMP SnapInView::GetResultViewType(
                             MMC_COOKIE cookie,
                             LPOLESTR* ppViewType,
                             long* pViewOptions
                             )
{
   return ((SnapInDataItem*)cookie)->getResultViewType(
                                         ppViewType,
                                         pViewOptions
                                         );
}

STDMETHODIMP SnapInView::GetDisplayInfo(
                             RESULTDATAITEM* pResultDataItem
                             )
{

   if (pResultDataItem->mask & RDI_STR)
   {
      SnapInDataItem* item = (SnapInDataItem*)(pResultDataItem->lParam);
      pResultDataItem->str =
         const_cast<PWSTR>(item->getDisplayName(pResultDataItem->nCol));
   }
   return S_OK;
}

STDMETHODIMP SnapInView::Initialize(LPUNKNOWN pUnknown)
{
   HRESULT hr;

   CComPtr<IConsoleNameSpace2> initNameSpace;
   hr = pUnknown->QueryInterface(
                      __uuidof(IConsoleNameSpace2),
                      (PVOID*)&initNameSpace
                      );
   if (FAILED(hr)) { return hr; }

   CComPtr<IConsole> initConsole;
   hr = pUnknown->QueryInterface(
                      __uuidof(IConsole),
                      (PVOID*)&initConsole
                      );
   if (FAILED(hr)) { return hr; }

   hr = internalInitialize(initNameSpace, this);
   if (FAILED(hr)) { return hr; }

   return Initialize(initConsole);
}

STDMETHODIMP SnapInView::CreateComponent(LPCOMPONENT* ppComponent)
{
   HRESULT hr;

   CComObject<SnapInView>* newComponent;
   hr = CComObject<SnapInView>::CreateInstance(&newComponent);
   if (FAILED(hr)) { return hr; }

   CComPtr<SnapInView> newView(newComponent);

   hr = newView.p->internalInitialize(nameSpace, this);
   if (FAILED(hr)) { return hr; }

   (*ppComponent = newView)->AddRef();

   return S_OK;
}

STDMETHODIMP SnapInView::Destroy()
{
   return Destroy((MMC_COOKIE)0);
}

STDMETHODIMP SnapInView::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
   if (pScopeDataItem->mask & SDI_STR)
   {
      SnapInDataItem* item = (SnapInDataItem*)(pScopeDataItem->lParam);
      pScopeDataItem->displayname = const_cast<PWSTR>(item->getDisplayName());
   }
   return S_OK;
}

STDMETHODIMP SnapInView::QueryDataObject(
                             MMC_COOKIE cookie,
                             DATA_OBJECT_TYPES type,
                             LPDATAOBJECT* ppDataObject
                             )
{
   if (!IS_SPECIAL_COOKIE(cookie))
   {
      (*ppDataObject = (SnapInDataItem*)cookie)->AddRef();
      return S_OK;
   }
   else
   {
      return S_FALSE;
   }
}

STDMETHODIMP SnapInView::Notify(
                             LPDATAOBJECT lpDataObject,
                             MMC_NOTIFY_TYPE event,
                             LPARAM arg,
                             LPARAM param
                             )
{
   // Extract the SnapInDataItem.
   SnapInDataItem* item;
   if (IS_SPECIAL_DATAOBJECT(lpDataObject))
   {
      item = NULL;
   }
   else
   {
      item = SnapInDataItem::narrow(lpDataObject);
   }

   HRESULT hr = S_FALSE;
   try
   {
      if (item)
      {
         // If we have a SnapInDataItem, dispatch the notification ...
         switch (event)
         {
            case MMCN_BTN_CLICK:
               hr = item->onButtonClick(*this, (MMC_CONSOLE_VERB)param);
               break;
            case MMCN_CONTEXTHELP:
               hr = item->onContextHelp(*this);
               break;
            case MMCN_DELETE:
               hr = item->onDelete(*this);
               break;
            case MMCN_DBLCLICK:
               hr = item->onDoubleClick(*this);
               break;
            case MMCN_EXPAND:
               hr = item->onExpand(*this, (HSCOPEITEM)param, (BOOL)arg);
               break;
            case MMCN_REFRESH:
               hr = item->onRefresh(*this);
               break;
            case MMCN_RENAME:
               hr = item->onRename(*this, (LPOLESTR)param);
               break;
            case MMCN_SELECT:
               hr = item->onSelect(*this, LOWORD(arg), HIWORD(arg));
               break;
            case MMCN_SHOW:
               hr = item->onShow(*this, (HSCOPEITEM)param, (BOOL)arg);
               break;
            case MMCN_VIEW_CHANGE:
               hr = item->onViewChange(*this, arg, param);
               break;
         }
      }
      else
      {
         // ... otherwise, handle it ourselves.
         switch (event)
         {
            case MMCN_COLUMN_CLICK:
               sortColumn = (int)arg;
               sortOption = (int)param;
               break;

            case MMCN_PROPERTY_CHANGE:
            {
               hr = ((SnapInDataItem*)param)->onPropertyChange(*this, arg);
               break;
            }
         }
      }
   }
   CATCH_AND_SAVE(hr);

   return hr;
}

STDMETHODIMP SnapInView::CompareObjects(
                             LPDATAOBJECT lpDataObjectA,
                             LPDATAOBJECT lpDataObjectB
                             )
{
   return SnapInDataItem::narrow(lpDataObjectA) ==
          SnapInDataItem::narrow(lpDataObjectB) ? S_OK : S_FALSE;
}

STDMETHODIMP SnapInView::AddMenuItems(
                             LPDATAOBJECT lpDataObject,
                             LPCONTEXTMENUCALLBACK piCallback,
                             long *pInsertionAllowed
                             )
{

   SnapInDataItem* item = SnapInDataItem::narrow(lpDataObject);
   if (!item) { return S_FALSE; }

   HRESULT hr;
   try
   {
      hr = item->addMenuItems(*this, piCallback, *pInsertionAllowed);
   }
   CATCH_AND_SAVE(hr);

   return hr;
}

STDMETHODIMP SnapInView::Command(
                             long lCommandID,
                             LPDATAOBJECT lpDataObject
                             )
{

   SnapInDataItem* item = SnapInDataItem::narrow(lpDataObject);
   if (!item) { return S_FALSE; }

   HRESULT hr;
   try
   {
      hr = item->onMenuCommand(*this, lCommandID);
   }
   CATCH_AND_SAVE(hr);

   return hr;
}

STDMETHODIMP SnapInView::ControlbarNotify(
                             MMC_NOTIFY_TYPE event,
                             LPARAM arg,
                             LPARAM param
                             )
{
   // If we don't have a controlbar, there's nothing we can do.
   if (!controlbar) { return S_FALSE; }

   // Get the IDataObject.
   IDataObject* lpDataObject;
   switch (event)
   {
      case MMCN_BTN_CLICK:
         lpDataObject = (IDataObject*)arg;
         break;
      case MMCN_SELECT:
         lpDataObject = (IDataObject*)param;
         break;
      default:
         lpDataObject = NULL;
   }

   // Convert to a SnapInDataItem.
   if (IS_SPECIAL_DATAOBJECT(lpDataObject)) { return S_FALSE; }
   SnapInDataItem* item = SnapInDataItem::narrow(lpDataObject);
   if (!item) { return S_FALSE; }

   // Dispatch the notification.
   HRESULT hr = S_FALSE;
   try
   {
      switch (event)
      {
         case MMCN_BTN_CLICK:
            hr = item->onToolbarButtonClick(*this, param);
            break;
         case MMCN_SELECT:
            hr = item->onToolbarSelect(*this, LOWORD(arg), HIWORD(arg));
            break;
      }
   }
   CATCH_AND_SAVE(hr);

   return hr;
}

STDMETHODIMP SnapInView::SetControlbar(
                             LPCONTROLBAR pControlbar
                             )
{
   releaseToolbars();
   controlbar = pControlbar;
   return S_OK;
}

STDMETHODIMP SnapInView::CreatePropertyPages(
                             LPPROPERTYSHEETCALLBACK lpProvider,
                             LONG_PTR handle,
                             LPDATAOBJECT lpDataObject
                             )
{

   SnapInDataItem* item = SnapInDataItem::narrow(lpDataObject);
   if (!item) { return S_FALSE; }

   HRESULT hr;
   try
   {
      hr = item->createPropertyPages(*this, lpProvider, handle);
   }
   CATCH_AND_SAVE(hr);

   return hr;
}

STDMETHODIMP SnapInView::QueryPagesFor(
                             LPDATAOBJECT lpDataObject
                             )
{

   SnapInDataItem* item = SnapInDataItem::narrow(lpDataObject);
   return item ? item->queryPagesFor() : S_FALSE;
}

STDMETHODIMP SnapInView::GetWatermarks(
                             LPDATAOBJECT lpIDataObject,
                             HBITMAP *lphWatermark,
                             HBITMAP *lphHeader,
                             HPALETTE *lphPalette,
                             BOOL *bStretch
                             )
{ return E_NOTIMPL; }

HRESULT SnapInView::Compare(
                        LPARAM lUserParam,
                        MMC_COOKIE cookieA,
                        MMC_COOKIE cookieB,
                        int* pnResult
                        )
{
   *pnResult = ((SnapInDataItem*)cookieA)->compare(
                                               *(SnapInDataItem*)cookieB,
                                               *pnResult
                                               );
   return S_OK;
}

const SnapInToolbarDef* SnapInView::getToolbars() const throw ()
{
   static SnapInToolbarDef none;
   return &none;
}

SnapInView::SnapInView() throw ()
   : master(NULL),
     toolbars(NULL),
     numToolbars(0),
     sortColumn(0),
     sortOption(RSI_NOSORTICON)
{ }

SnapInView::~SnapInView() throw ()
{
   releaseToolbars();
   delete[] toolbars;

   if (master && master != this) { master->Release(); }
}

HRESULT SnapInView::internalInitialize(
                        IConsoleNameSpace2* consoleNameSpace,
                        SnapInView* masterView
                        ) throw ()
{
   nameSpace = consoleNameSpace;

   master = masterView;
   if (master != this) { master->AddRef(); }

   const SnapInToolbarDef* defs = master->getToolbars();

   // How many new toolbars are there?
   size_t count = 0;
   while (defs[count].nImages) { ++count; }

   if (count)
   {
      // Allocate memory ...
      toolbars = new (std::nothrow) ToolbarEntry[count];
      if (!toolbars) { return E_OUTOFMEMORY; }

      // ... and save the definitions. We don't actually create the toolbars
      // now. We do this as we need them.
      for (size_t i = 0; i < count; ++i)
      {
         toolbars[i].def = defs + i;
      }
   }

   numToolbars = count;

   return S_OK;
}

void SnapInView::releaseToolbars() throw ()
{
   if (controlbar)
   {
      for (size_t i = 0; i < numToolbars; ++i)
      {
         if (toolbars[i].toolbar)
         {
            controlbar->Detach(toolbars[i].toolbar);
            toolbars[i].toolbar.Release();
         }
      }
   }
}

SnapInPropertyPage::SnapInPropertyPage(
                        UINT nIDTemplate,
                        UINT nIDHeaderTitle,
                        UINT nIDHeaderSubTitle,
                        bool EnableHelp
                        )
  : CHelpPageEx(nIDTemplate, 0, nIDHeaderTitle, nIDHeaderSubTitle, EnableHelp),
    notify(0),
    param(0),
    owner(false),
    applied(false),
    modified(FALSE)
{
   if (!nIDHeaderTitle)
   {
      m_psp.dwFlags |= PSP_HIDEHEADER;
   }
}

SnapInPropertyPage::SnapInPropertyPage(
                        LONG_PTR notifyHandle,
                        LPARAM notifyParam,
                        bool deleteHandle,
                        UINT nIDTemplate,
                        UINT nIDCaption,
                        bool EnableHelp
                        )
  : CHelpPageEx(nIDTemplate, nIDCaption, EnableHelp),
    notify(notifyHandle),
    param(notifyParam),
    owner(deleteHandle),
    applied(false),
    modified(FALSE)
{ 
}

SnapInPropertyPage::~SnapInPropertyPage() throw ()
{
   if (owner && notify) { MMCFreeNotifyHandle(notify); }
}

void SnapInPropertyPage::addToMMCSheet(IPropertySheetCallback* cback)
{
   // Swap our callback for the MFC supplied one.
   mfcCallback = m_psp.pfnCallback;
   m_psp.pfnCallback = propSheetPageProc;
   m_psp.lParam = (LPARAM)this;

   HRESULT hr = MMCPropPageCallback(&m_psp);
   if (SUCCEEDED(hr))
   {
      HPROPSHEETPAGE page = CreatePropertySheetPage(&m_psp);
      if (page)
      {
         hr = cback->AddPage(page);
         if (FAILED(hr))
         {
            DestroyPropertySheetPage(page);
         }
      }
      else
      {
         // GetLastError() doesn't work with CreatePropertySheetPage.
         hr = E_UNEXPECTED;
      }
   }

   if (FAILED(hr)) { delete this; }

   CheckError(hr);
}

void SnapInPropertyPage::DoDataExchange(CDataExchange* pDX)
{
   pDX->m_bSaveAndValidate ? getData() : setData();
}

BOOL SnapInPropertyPage::OnApply()
{
   // If we've been modified, ...
   if (modified)
   {
      try
      {
         // Save the changes.
         saveChanges();
      }
      catch (CException* e)
      {
         // Bring up a message box.
         reportException(e);

         // We're in an indeterminate state, so we can't cancel.
         CancelToClose();

         // Block the apply.
         return FALSE;
      }

      // Notify MMC if necessary.
      if (notify) { MMCPropertyChangeNotify(notify, param); }

      // Set our flags.
      applied = true;
      modified = FALSE;
   }
   return TRUE;
}

BOOL SnapInPropertyPage::OnWizardFinish()
{
   try
   {
      saveChanges();
   }
   catch (CException* e)
   {
      // Bring up a message box.
      reportException(e);

      // Disable all the buttons. Something's wrong, so we'll only let the user
      // cancel.
      ::PostMessageW(
            ::GetParent(m_hWnd),
            PSM_SETWIZBUTTONS,
            0,
            (LPARAM)(DWORD)PSWIZB_DISABLEDFINISH
            );

      return FALSE;
   }

   return TRUE;
}

void SnapInPropertyPage::OnReset()
{
   // If we've been modified, ...
   if (modified)
   {
      // ... discard the changes.
      discardChanges();
      modified = FALSE;
   }
}

void SnapInPropertyPage::SetModified(BOOL bChanged)
{
   modified = bChanged;
   CHelpPageEx::SetModified(bChanged);
}

void SnapInPropertyPage::getData()
{
}

void SnapInPropertyPage::setData()
{
}

void SnapInPropertyPage::saveChanges()
{
}

void SnapInPropertyPage::discardChanges()
{
}

void SnapInPropertyPage::enableControl(int controlId, bool enable)
{
   ::EnableWindow(::GetDlgItem(m_hWnd, controlId), (enable ? TRUE : FALSE));
}

void SnapInPropertyPage::fail(int controlId, UINT errorText, bool isEdit)
{
   failNoThrow(controlId, errorText, isEdit);

   AfxThrowUserException();
}

void SnapInPropertyPage::failNoThrow(int controlId, UINT errorText, bool isEdit)
{
   // Give the offending control the focus.
   HWND ctrl = ::GetDlgItem(m_hWnd, controlId);
   ::SetFocus(ctrl);
   if (isEdit) { ::SendMessage(ctrl, EM_SETSEL, 0, -1); }

   // Bring up a message box.
   reportError(errorText);
}

void SnapInPropertyPage::initControl(int controlId, CWnd& control)
{
   if (control.m_hWnd == NULL)
   {
      if (!control.SubclassWindow(::GetDlgItem(m_hWnd, controlId)))
      {
         AfxThrowNotSupportedException();
      }
   }
}

void SnapInPropertyPage::onChange()
{
   SetModified();
}

void SnapInPropertyPage::reportError(UINT errorText)
{
   // Bring up a message box.
   MessageBox(
       ResourceString(errorText),
       ResourceString(getErrorCaption()),
       MB_ICONWARNING
       );
}

void SnapInPropertyPage::reportException(CException* e)
{
   // Get the error message.
   WCHAR errorText[256];
   e->GetErrorMessage(errorText, sizeof(errorText)/sizeof(errorText[0]));
   e->Delete();

   // Bring up a message box.
   MessageBox(
       errorText,
       ResourceString(getErrorCaption()),
       MB_ICONERROR
       );
}


void SnapInPropertyPage::setLargeFont(int controlId)
{
   static CFont largeFont;

   CWnd* ctrl = GetDlgItem(controlId);
   if (ctrl)
   {
      // If we don't have the large font yet, ...
      if (!(HFONT)largeFont)
      {
         // ... create it.
         largeFont.CreatePointFont(
                       10 * _wtoi(ResourceString(IDS_LARGE_FONT_SIZE)),
                       ResourceString(IDS_LARGE_FONT_NAME)
                       );
      }

      ctrl->SetFont(&largeFont);
   }
}

void SnapInPropertyPage::showControl(int controlId, bool show)
{
   CWnd* ctrl = GetDlgItem(controlId);
   if (ctrl)
   {
      show ? ctrl->ModifyStyle(0, WS_VISIBLE)
           : ctrl->ModifyStyle(WS_VISIBLE, 0);
   }
}

void SnapInPropertyPage::getValue(
                             int controlId,
                             LONG& value,
                             UINT errorText
                             )
{
   WCHAR buffer[32];
   int len = GetDlgItemText(controlId, buffer, 32);

   // We'll fail anything that's longer than 30 characters. This is an
   // arbitrary bound. We just need to make sure that buffer is long enough to
   // hold any valid integer plus a little whitespace.
   if (len == 0 || len > 30)
   {
      fail(controlId, errorText);
   }

   // Skip any leading whitespace.
   PWSTR sz = buffer;
   while (*sz == L' ' || *sz == L'\t') { ++sz; }

   // Save the first non-whitespace character.
   WCHAR first = *sz;

   // Convert the integer.
   value = wcstol(sz, &sz, 10);

   // Skip any trailing whitespace.
   while (*sz == L' ' || *sz == L'\t') { ++sz; }

   // Make sure all went well.
   if ((value == 0 && first != L'0') ||
       *sz != L'\0' ||
       value == LONG_MIN ||
       value == LONG_MAX)
   {
      fail(controlId, errorText);
   }
}

void SnapInPropertyPage::setValue(
                             int controlId,
                             LONG value
                             )
{
   WCHAR buffer[12];
   SetDlgItemText(controlId, _ltow(value, buffer, 10));
}

void SnapInPropertyPage::getValue(
                             int controlId,
                             bool& value
                             )
{
   value = IsDlgButtonChecked(controlId) != 0;
}

void SnapInPropertyPage::setValue(
                             int controlId,
                             bool value
                             )
{
   CheckDlgButton(controlId, (value ? BST_CHECKED : BST_UNCHECKED));
}

void SnapInPropertyPage::getValue(
                             int controlId,
                             CComBSTR& value,
                             bool trim
                             )
{
   HWND hwnd = ::GetDlgItem(m_hWnd, controlId);

   int len = ::GetWindowTextLength(hwnd);
   SysFreeString(value.m_str);
   value.m_str = SysAllocStringLen(NULL, len);
   if (!value) { AfxThrowMemoryException(); }

   ::GetWindowTextW(hwnd, value, len + 1);

   if (trim) { SdoTrimBSTR(value); }
}

void SnapInPropertyPage::setValue(
                             int controlId,
                             PCWSTR value
                             )
{
   SetDlgItemText(controlId, value);
}

void SnapInPropertyPage::getRadio(
                             int firstId,
                             int lastId,
                             LONG& value
                             )
{
   value = GetCheckedRadioButton(firstId, lastId);
   value = value ? value - firstId : -1;
}

void SnapInPropertyPage::setRadio(
                             int firstId,
                             int lastId,
                             LONG value
                             )
{
   CheckRadioButton(firstId, lastId, firstId + value);
}

UINT CALLBACK SnapInPropertyPage::propSheetPageProc(
                                      HWND hwnd,
                                      UINT uMsg,
                                      LPPROPSHEETPAGE ppsp
                                      ) throw ()
{
   SnapInPropertyPage* page = (SnapInPropertyPage*)(ppsp->lParam);

   UINT retval = page->mfcCallback(hwnd, uMsg, ppsp);

   if (uMsg == PSPCB_RELEASE) { delete page; }

   return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\mmc\proxy\snapwork.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    snapwork.h
//
// SYNOPSIS
//
//    Declares classes for implementing an MMC Snap-In.
//
// MODIFICATION HISTORY
//
//    02/19/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef SNAPWORK_H
#define SNAPWORK_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include "dlgcshlp.h"

class SnapInControlbar;
class SnapInView;

///////////////////////////////////////////////////////////////////////////////
//
// NAMESPACE
//
//    SnapIn
//
// DESCRIPTION
//
//    Contains various declarations for exception support.
//
///////////////////////////////////////////////////////////////////////////////
namespace SnapIn
{
   // Check an HRESULT and throw an exception on error.
   inline void CheckError(HRESULT hr)
   {
      if (FAILED(hr)) { AfxThrowOleException(hr); }
   }

   // Throw a COleException containing the result of GetLastError().
   void AfxThrowLastError();

   // Used for overloading the global new operator below.
   struct throw_t { };
   const throw_t AfxThrow;
};

// Throws a CMemoryException on allocation failure.
inline void* __cdecl operator new(size_t size, const SnapIn::throw_t&)
{
   void* p = ::operator new(size);
   if (!p) { AfxThrowMemoryException(); }
   return p;
}
inline void __cdecl operator delete(void* p, const SnapIn::throw_t&)
{
   ::operator delete(p);
}


// Macro to catch any exception and return an appropriate HRESULT.
#define CATCH_AND_RETURN() \
catch (CException* e) { \
   HRESULT hr = COleException::Process(e); \
   e->ReportError(); \
   e->Delete(); \
   return hr; \
} \
catch (...) { \
   return E_FAIL; \
}

// Macro to catch any exception and store an appropriate HRESULT in hr.
#define CATCH_AND_SAVE(hr) \
catch (CException* e) { \
   hr = COleException::Process(e); \
   e->ReportError(); \
   e->Delete(); \
} \
catch (...) { \
   hr = E_FAIL; \
}

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ResourceString
//
// DESCRIPTION
//
//    Simple wrapper around a string resource. Unlike most other wrappers this
//    can support strings of arbitrary length.
//
///////////////////////////////////////////////////////////////////////////////
class ResourceString
{
public:
   ResourceString(UINT id) throw ();
   ~ResourceString() throw ()
   { if (sz != &empty) delete[] sz; }

   operator PCWSTR() const throw ()
   { return sz; }
   operator PWSTR() throw ()
   { return sz; }

private:
   PWSTR sz;             // The string.
   static WCHAR empty;   // Ensures that a ResourceString is never NULL.

   // Not implemented.
   ResourceString(const ResourceString&);
   ResourceString& operator=(const ResourceString&);
};

///////////////////////////////////////////////////////////////////////////////
//
// Methods for manipulating a generic IDataObject (i.e., not necessarily one of
// ours).
//
///////////////////////////////////////////////////////////////////////////////

// Extract a fixed number of bytes from an IDataObject.
VOID
WINAPI
ExtractData(
    IDataObject* dataObject,
    CLIPFORMAT format,
    PVOID data,
    DWORD dataLen
    );

// Extract a variable number of bytes. The caller must use GlobalFree to free
// the returned data.
VOID
WINAPI
ExtractData(
    IDataObject* dataObject,
    CLIPFORMAT format,
    DWORD maxDataLen,
    HGLOBAL* data
    );

// Extract a node type GUID from an IDataObject.
VOID
WINAPI
ExtractNodeType(
    IDataObject* dataObject,
    GUID* nodeType
    );

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SnapInDataItem
//
// DESCRIPTION
//
//    Abstract base class for items that will be displayed in the MMC scope
//    pane or result pane. When overriding functions, pay careful attention to
//    which ones are allowed to throw exceptions.
//
///////////////////////////////////////////////////////////////////////////////
class __declspec(uuid("af0af65a-abe0-4f47-9540-328351c23fab")) SnapInDataItem;
class SnapInDataItem : public IDataObject
{
public:
   SnapInDataItem() throw ()
      : refCount(0)
   { }

   // Convert an IDataObject to its corresponding SnapInDataItem.
   static SnapInDataItem* narrow(IDataObject* dataObject) throw ();

   // Must be defined in the derived class to return the item's display name.
   virtual PCWSTR getDisplayName(int column = 0) const throw () = 0;

   // These should be overridden in the derived class unless you're sure MMC
   // will never ask for them.
   virtual const GUID* getNodeType() const throw ();
   virtual const GUID* getSnapInCLSID() const throw ();
   virtual PCWSTR getSZNodeType() const throw ();

   // Used to determine the sort order of two items.
   virtual int compare(
                   SnapInDataItem& item,
                   int column
                   ) throw ();

   // Allows an item to add commands to the context menu.
   virtual HRESULT addMenuItems(
                       SnapInView& view,
                       LPCONTEXTMENUCALLBACK callback,
                       long insertionAllowed
                       );

   // Methods for exposing properties.
   virtual HRESULT createPropertyPages(
                       SnapInView& view,
                       LPPROPERTYSHEETCALLBACK provider,
                       LONG_PTR handle
                       );
   virtual HRESULT queryPagesFor() throw ();

   // Allows a scope item to customize the result view type.
   virtual HRESULT getResultViewType(
                       LPOLESTR* ppViewType,
                       long* pViewOptions
                       ) throw ();

   //////////
   // Various notifications that your item can handle.
   //////////

   virtual HRESULT onButtonClick(
                       SnapInView& view,
                       MMC_CONSOLE_VERB verb
                       );
   virtual HRESULT onContextHelp(
                       SnapInView& view
                       );
   virtual HRESULT onDelete(
                       SnapInView& view
                       );
   virtual HRESULT onDoubleClick(
                       SnapInView& view
                       );
   virtual HRESULT onExpand(
                       SnapInView& view,
                       HSCOPEITEM itemId,
                       BOOL expanded
                       );
   virtual HRESULT onMenuCommand(
                       SnapInView& view,
                       long commandId
                       );
   virtual HRESULT onPropertyChange(
                      SnapInView& view,
                      BOOL scopeItem
                      );
   virtual HRESULT onRefresh(
                       SnapInView& view
                       );
   virtual HRESULT onRename(
                       SnapInView& view,
                       LPCOLESTR newName
                       );
   virtual HRESULT onSelect(
                       SnapInView& view,
                       BOOL scopeItem,
                       BOOL selected
                       );
   virtual HRESULT onShow(
                       SnapInView& view,
                       HSCOPEITEM itemId,
                       BOOL selected
                       );
   virtual HRESULT onToolbarButtonClick(
                       SnapInView& view,
                       int buttonId
                       );
   virtual HRESULT onToolbarSelect(
                       SnapInView& view,
                       BOOL scopeItem,
                       BOOL selected
                       );
   virtual HRESULT onViewChange(
                       SnapInView& view,
                       LPARAM data,
                       LPARAM hint
                       );

   //////////
   // IUnknown
   //////////

   STDMETHOD_(ULONG, AddRef)();
   STDMETHOD_(ULONG, Release)();
   STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

   //////////
   // IDataObject
   //////////

   STDMETHOD(GetData)(
                 FORMATETC *pformatetcIn,
                 STGMEDIUM *pmedium
                 );
   STDMETHOD(GetDataHere)(
                 FORMATETC *pformatetc,
                 STGMEDIUM *pmedium
                 );
   STDMETHOD(QueryGetData)(FORMATETC *pformatetc);
   STDMETHOD(GetCanonicalFormatEtc)(
                 FORMATETC *pformatectIn,
                 FORMATETC *pformatetcOut
                 );
   STDMETHOD(SetData)(
                 FORMATETC *pformatetc,
                 STGMEDIUM *pmedium,
                 BOOL fRelease
                 );
   STDMETHOD(EnumFormatEtc)(
                 DWORD dwDirection,
                 IEnumFORMATETC **ppenumFormatEtc
                 );
   STDMETHOD(DAdvise)(
                 FORMATETC *pformatetc,
                 DWORD advf,
                 IAdviseSink *pAdvSink,
                 DWORD *pdwConnection
                 );
   STDMETHOD(DUnadvise)(
                 DWORD dwConnection
                 );
   STDMETHOD(EnumDAdvise)(
                 IEnumSTATDATA **ppenumAdvise
                 );

protected:
   virtual ~SnapInDataItem() throw ();

private:
   LONG refCount;

   // Not implemented.
   SnapInDataItem(const SnapInDataItem&);
   SnapInDataItem& operator=(const SnapInDataItem&);
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SnapInPreNamedItem
//
// DESCRIPTION
//
//    Extends SnapInDataItem to implement getDisplayName for items with a fixed
//    name that's stored in a string resource.
//
///////////////////////////////////////////////////////////////////////////////
class SnapInPreNamedItem : public SnapInDataItem
{
public:
   SnapInPreNamedItem(int nameId) throw ()
      : name(nameId)
   { }

   virtual PCWSTR getDisplayName(int column) const throw ();

protected:
   ResourceString name;
};

///////////////////////////////////////////////////////////////////////////////
//
// STRUCT
//
//    SnapInToolbarDef
//
// DESCRIPTION
//
//    Encapsulates the information needed to create and initialize a toolbar.
//    See IToolbar::AddImages and IToolbar::AddButtons for details. An array of
//    SnapInToolbarDef's must be terminated by an entry with nImages set to
//    zero.
//
///////////////////////////////////////////////////////////////////////////////
struct SnapInToolbarDef
{
   int nImages;
   HBITMAP hbmp;
   COLORREF crMask;
   int nButtons;
   LPMMCBUTTON lpButtons;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SnapInView
//
// DESCRIPTION
//
//    Represents a view in the MMC console.
//
///////////////////////////////////////////////////////////////////////////////
class SnapInView
   : public CComObjectRootEx< CComMultiThreadModelNoCS >,
     public IComponent,
     public IComponentData,
     public IExtendContextMenu,
     public IExtendControlbar,
     public IExtendPropertySheet2,
     public IResultDataCompare,
     public ISnapinHelp

{
public:
   // Various interfaces for manipulating the view.
   // These are guaranteed to be non-NULL.
   IConsole2* getConsole() const throw ()
   { return console; }
   IHeaderCtrl2* getHeaderCtrl() const throw ()
   { return headerCtrl; }
   IConsoleNameSpace2* getNameSpace() const throw ()
   { return nameSpace; }
   IPropertySheetProvider* getPropertySheetProvider() const throw ()
   { return sheetProvider; }
   IResultData* getResultData() const throw ()
   { return resultData; }

   HRESULT displayHelp(PCWSTR  contextHelpPath) throw();

   void updateAllViews(
           SnapInDataItem& item,
           LPARAM data = 0,
           INT_PTR hint = 0
           ) const;

   // Delete an item from the result pane.
   void deleteResultItem(const SnapInDataItem& item) const;
   // Update an item in the result pane.
   void updateResultItem(const SnapInDataItem& item) const;

   // Returns true if the item has a property sheet open.
   bool isPropertySheetOpen(const SnapInDataItem& item) const;

   // Attach a toolbar to the controlbar and return a pointer to the newly
   // attached toolbar so the caller can update button state, etc. The returned
   // pointer is only valid for the duration of the current notification method
   // and should not be released.
   IToolbar* attachToolbar(size_t index);
   // Detach a toolbar from the controlbar.
   void detachToolbar(size_t index) throw ();

   // Retrieve the current sort parameters.
   int getSortColumn() const throw ()
   { return sortColumn; }
   int getSortOption() const throw ()
   { return sortOption; }
   // Force a re-sort of the result pane using the current parameters.
   void reSort() const;

   // Format and display a dialog box.
   void formatMessageBox(
            UINT titleId,
            UINT formatId,
            BOOL ignoreInserts,
            UINT style,
            int* retval,
            ...
            );

   // Set the image strip associated with the scope or result pane.
   void setImageStrip(
            UINT smallStripId,
            UINT largeStripId,
            BOOL scopePane
            );

   // IUnknown.
   STDMETHOD_(ULONG, AddRef)();
   STDMETHOD_(ULONG, Release)();

   // IComponent
   STDMETHOD(Initialize)(LPCONSOLE lpConsole);
   STDMETHOD(Destroy)(MMC_COOKIE cookie);
   STDMETHOD(GetResultViewType)(
                 MMC_COOKIE cookie,
                 LPOLESTR* ppViewType,
                 long* pViewOptions
                 );
   STDMETHOD(GetDisplayInfo)(RESULTDATAITEM* pResultDataItem);

   // IComponentData
   STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
   STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
   STDMETHOD(Destroy)();
   STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);

   // Common to both IComponent and IComponentData
   STDMETHOD(QueryDataObject)(
                 MMC_COOKIE cookie,
                 DATA_OBJECT_TYPES type,
                 LPDATAOBJECT* ppDataObject
                 );
   STDMETHOD(Notify)(
                 LPDATAOBJECT lpDataObject,
                 MMC_NOTIFY_TYPE event,
                 LPARAM arg,
                 LPARAM param
                 );
   STDMETHOD(CompareObjects)(
                 LPDATAOBJECT lpDataObjectA,
                 LPDATAOBJECT lpDataObjectB
                 );

   // IExtendContextMenu
   STDMETHOD(AddMenuItems)(
                 LPDATAOBJECT piDataObject,
                 LPCONTEXTMENUCALLBACK piCallback,
                 long *pInsertionAllowed
                 );
   STDMETHOD(Command)(
                 long lCommandID,
                 LPDATAOBJECT piDataObject
                 );

   // IExtendControlbar
   STDMETHOD(ControlbarNotify)(
                 MMC_NOTIFY_TYPE event,
                 LPARAM arg,
                 LPARAM param
                 );
   STDMETHOD(SetControlbar)(
                 LPCONTROLBAR pControlbar
                 );

   // IExtendPropertySheet
   STDMETHOD(CreatePropertyPages)(
                 LPPROPERTYSHEETCALLBACK lpProvider,
                 LONG_PTR handle,
                 LPDATAOBJECT lpIDataObject
                 );
   STDMETHOD(QueryPagesFor)(
                 LPDATAOBJECT lpDataObject
                 );

   // IExtendPropertySheet2
   STDMETHOD(GetWatermarks)(
                 LPDATAOBJECT lpIDataObject,
                 HBITMAP *lphWatermark,
                 HBITMAP *lphHeader,
                 HPALETTE *lphPalette,
                 BOOL *bStretch
                 );

   // IResultDataCompare
   STDMETHOD(Compare)(
                 LPARAM lUserParam,
                 MMC_COOKIE cookieA,
                 MMC_COOKIE cookieB,
                 int* pnResult
                 );

   // ISnapinHelp method(s)
   STDMETHOD(GetHelpTopic)(LPOLESTR * lpCompiledHelpFile){return E_NOTIMPL;};


protected:
   // Should be overridden by the derived class if it supports toolbars.
   virtual const SnapInToolbarDef* getToolbars() const throw ();

   SnapInView() throw ();
   ~SnapInView() throw ();

BEGIN_COM_MAP(SnapInView)
   COM_INTERFACE_ENTRY_IID(__uuidof(IComponent), IComponent)
   COM_INTERFACE_ENTRY_IID(__uuidof(IComponentData), IComponentData)
   COM_INTERFACE_ENTRY_IID(__uuidof(IExtendContextMenu), IExtendContextMenu)
   COM_INTERFACE_ENTRY_IID(__uuidof(IExtendControlbar), IExtendControlbar)
   COM_INTERFACE_ENTRY_IID(__uuidof(IExtendPropertySheet2),
                           IExtendPropertySheet2)
   COM_INTERFACE_ENTRY_IID(__uuidof(IResultDataCompare), IResultDataCompare)
   COM_INTERFACE_ENTRY_IID(__uuidof(ISnapinHelp), ISnapinHelp)
END_COM_MAP()

private:
   HRESULT internalInitialize(
               IConsoleNameSpace2* consoleNameSpace,
               SnapInView* masterView
               ) throw ();
   void releaseToolbars() throw ();

   // Struct that associates a toolbar definition with an instance of that
   // toolbar in the current view.
   struct ToolbarEntry
   {
      const SnapInToolbarDef* def;
      CComPtr<IToolbar> toolbar;
   };

   mutable CComPtr<IConsole2> console;
   mutable CComPtr<IConsoleNameSpace2> nameSpace;
   mutable CComPtr<IHeaderCtrl2> headerCtrl;
   mutable CComPtr<IPropertySheetProvider> sheetProvider;
   mutable CComPtr<IResultData> resultData;
   mutable CComPtr<IControlbar> controlbar;
   SnapInView* master;
   ToolbarEntry* toolbars;
   size_t numToolbars;
   int sortColumn;
   int sortOption;

   // Not implemented.
   SnapInView(const SnapInView&);
   SnapInView& operator=(const SnapInView&);
};


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SnapInPropertyPage
//
// DESCRIPTION
//
//    Extends the MFC class CPropertyPageEx to handle the MMC specific details.
//
///////////////////////////////////////////////////////////////////////////////
class SnapInPropertyPage : public CHelpPageEx
{

public:
   // Constructor for MFC hosted page.
   SnapInPropertyPage(
       UINT nIDTemplate,
       UINT nIDHeaderTitle = 0,
       UINT nIDHeaderSubTitle = 0,
       bool EnableHelp = true
       );

   // Constructor for MMC hosted property page.
   SnapInPropertyPage(
       LONG_PTR notifyHandle,
       LPARAM notifyParam,
       bool deleteHandle,
       UINT nIDTemplate,
       UINT nIDCaption = 0,
       bool EnableHelp = true
       );
   ~SnapInPropertyPage() throw ();

   // Add the property page to a sheet. Regardless of whether or not this
   // succeeds, the SnapInPropertyPage is automatically deleted.
   void addToMMCSheet(IPropertySheetCallback* cback);

   // Returns 'true' if any changes have been applied.
   bool hasApplied() const throw ()
   { return applied; }

   // Returns 'true' if the page has been modified.
   bool isModified() const throw ()
   { return modified != FALSE; }

   // These should generally not be overridden.
   virtual void DoDataExchange(CDataExchange* pDX);
   virtual BOOL OnApply();
   virtual BOOL OnWizardFinish();
   virtual void OnReset();
   void SetModified(BOOL bChanged = TRUE);

protected:
   // These should be overridden in the derived class to do the actual data and
   // UI processing.
   virtual void getData();
   virtual void setData();
   virtual void saveChanges();
   virtual void discardChanges();
   virtual UINT getErrorCaption() const throw () = 0;

   // Enable/disable a control on the page.
   void enableControl(int controlId, bool enable = true);
   // Fail a validation.
   void fail(int controlId, UINT errorText, bool isEdit = true);
   // Fail a validation, but don't throw an exception.
   void failNoThrow(int controlId, UINT errorText, bool isEdit = true);
   // Subclass a control member variable.
   void initControl(int controlId, CWnd& control);
   // Useful as a message handler.
   void onChange();
   // Display an error dialog.
   void reportError(UINT errorText);
   // Display an error dialog based on an exception. The exception is deleted.
   void reportException(CException* e);
   // Set the control to large font.
   void setLargeFont(int controlId);
   // Show/hide a control on the page.
   void showControl(int controlId, bool show = true);

   // Helper functions to get/set values from controls.
   void getValue(
            int controlId,
            LONG& value,
            UINT errorText
            );
   void setValue(
            int controlId,
            LONG value
            );
   void getValue(
            int controlId,
            bool& value
            );
   void setValue(
            int controlId,
            bool value
            );
   void getValue(
            int controlId,
            CComBSTR& value,
            bool trim = true
            );
   void setValue(
            int controlId,
            PCWSTR value
            );
   void getRadio(
            int firstId,
            int lastId,
            LONG& value
            );
   void setRadio(
            int firstId,
            int lastId,
            LONG value
            );

   static UINT CALLBACK propSheetPageProc(
                            HWND hwnd,
                            UINT uMsg,
                            LPPROPSHEETPAGE ppsp
                            ) throw ();

   LPFNPSPCALLBACK mfcCallback;   // The MFC supplied PropSheetPageProc.
   LONG_PTR notify;               // MMC notification handle
   LPARAM param;                  // MMC notification parameter
   bool owner;                    // 'true' if we own the handle
   bool applied;                  // 'true' if any changes have been applied.
   BOOL modified;                 // 'TRUE' if the page has been changed.

};


#define DEFINE_ERROR_CAPTION(id) \
virtual UINT getErrorCaption() const throw () { return id; }

#endif // SNAPWORK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\policy\dll_bld\filter.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    filter.cpp
//
// SYNOPSIS
//
//    Defines the class TypeFilter.
//
///////////////////////////////////////////////////////////////////////////////

#include <polcypch.h>
#include <filter.h>
#include <new>

//////////
// Helper function to read a string value from the registry. If the value
// doesn't exist the function returns NO_ERROR and sets *value to NULL. The
// caller is responsible for deleting the returned string.
//////////
LONG
WINAPI
QueryStringValue(
    IN HKEY key,
    IN PCWSTR name,
    OUT PWCHAR* value
    ) throw ()
{
   // Initialize the out parameter.
   *value = NULL;

   // Find out how long the value is.
   LONG error;
   DWORD type, len;
   error = RegQueryValueExW(
               key,
               name,
               NULL,
               &type,
               NULL,
               &len
               );
   if (error) { return error == ERROR_FILE_NOT_FOUND ? NO_ERROR : error; }

   // Check the data type.
   if (type != REG_SZ) { return ERROR_INVALID_DATA; }

   // Allocate memory to hold the string.
   *value = new (std::nothrow) WCHAR[len / sizeof(WCHAR)];
   if (!*value) { return ERROR_NOT_ENOUGH_MEMORY; }

   // Now read the actual value.
   error = RegQueryValueExW(
               key,
               name,
               NULL,
               &type,
               (LPBYTE)*value,
               &len
               );

   if (type != REG_SZ) { error = ERROR_INVALID_DATA; }

   // Clean-up if there was an error.
   if (error)
   {
      delete[] *value;
      *value = NULL;
   }

   return error;
}

TypeFilter::TypeFilter(BOOL handleByDefault) throw ()
   : begin(NULL), end(NULL), defaultResult(handleByDefault)
{
}

BOOL TypeFilter::shouldHandle(LONG key) const throw ()
{
   // If the filter isn't set, use the default.
   if (begin == end) { return defaultResult; }

   // Iterate through the allowed types ...
   for (PLONG i = begin; i != end; ++i)
   {
      // ... looking for a match.
      if (*i == key) { return TRUE; }
   }

   // No match.
   return FALSE;
}

LONG TypeFilter::readConfiguration(HKEY key, PCWSTR name) throw ()
{
   // Get the filter text.
   PWCHAR text;
   LONG error = QueryStringValue(key, name, &text);
   if (error) { return error; }

   // Count the number of allowed types.
   SIZE_T numTokens = 0;
   PCWSTR sz;
   for (sz = nextToken(text); sz; sz = nextToken(wcschr(sz, L' ')))
   { ++numTokens; }

   // Are there any tokens to process ?
   if (numTokens)
   {
      // Allocate memory to hold the allowed types.
      begin = new (std::nothrow) LONG[numTokens];
      if (begin)
      {
         end = begin;

         // Convert each token to a LONG
         for (sz = nextToken(text); sz; sz = nextToken(wcschr(sz, L' ')))
         {
            *end++ = _wtol(sz);
         }
      }
      else
      {
         error = ERROR_NOT_ENOUGH_MEMORY;
      }
   }

   // We're done with the filter text.
   delete[] text;

   return error;
}

PCWSTR TypeFilter::nextToken(PCWSTR string) throw ()
{
   if (string)
   {
      while (*string == L' ') { ++string; }

      if (*string) { return string; }
   }

   return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\policy\dll_bld\iasattr.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasattr.cpp
//
// SYNOPSIS
//
//    Defines the API for manipulating IASATTRIBUTE structs.
//
// MODIFICATION HISTORY
//
//    02/02/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <polcypch.h>
#include <iaspolcy.h>
#include <iasattr.h>

DWORD
WINAPI
IASAttributeAlloc(
    DWORD dwCount,
    IASATTRIBUTE** ppAttribute
    )
{
   PIASATTRIBUTE* next = ppAttribute;

   for ( ; dwCount; --dwCount, ++next)
   {
      if (!(*next = (PIASATTRIBUTE)CoTaskMemAlloc(sizeof(IASATTRIBUTE))))
      {
         while (next > ppAttribute)
         {
            CoTaskMemFree(*--next);
         }

         return ERROR_NOT_ENOUGH_MEMORY;
      }

      memset(*next, 0, sizeof(IASATTRIBUTE));

      (*next)->dwReserved = 1;
   }

   return NO_ERROR;
}

DWORD
WINAPI
IASAttributeAddRef(
    PIASATTRIBUTE pAttribute
    )
{
   if (pAttribute) { InterlockedIncrement((PLONG)&pAttribute->dwReserved); }

   return NO_ERROR;
}

DWORD
WINAPI
IASAttributeRelease(
    PIASATTRIBUTE pAttribute
    )
{
   if (pAttribute && !InterlockedDecrement((PLONG)&pAttribute->dwReserved))
   {
      switch (pAttribute->Value.itType)
      {
         case IASTYPE_STRING:
         {
            CoTaskMemFree(pAttribute->Value.String.pszAnsi);
            CoTaskMemFree(pAttribute->Value.String.pszWide);
            break;
         }

         case IASTYPE_OCTET_STRING:
         {
            CoTaskMemFree(pAttribute->Value.OctetString.lpValue);
            break;
         }
      }

      CoTaskMemFree(pAttribute);
   }

   return ERROR_SUCCESS;
}

DWORD
WINAPI
IASAttributeUnicodeAlloc(
    PIASATTRIBUTE pAttribute
    )
{
   if (!pAttribute ||
       pAttribute->Value.itType != IASTYPE_STRING  ||
       pAttribute->Value.String.pszWide != NULL ||
       pAttribute->Value.String.pszAnsi == NULL)
   {
      return NO_ERROR;
   }

   // Find out how big a buffer we need.
   int lenW = MultiByteToWideChar(
                  CP_ACP,
                  0,
                  pAttribute->Value.String.pszAnsi,
                  -1,
                  NULL,
                  0);
   if (!lenW) { return GetLastError(); }

   LPWSTR wide = (LPWSTR)CoTaskMemAlloc(lenW * sizeof(WCHAR));
   if (!wide) { return ERROR_NOT_ENOUGH_MEMORY; }

   // Do the conversion.
   MultiByteToWideChar(
       CP_ACP,
       0,
       pAttribute->Value.String.pszAnsi,
       -1,
       wide,
       lenW
       );

   CoTaskMemFree(
      InterlockedExchangePointer(
         (PVOID*)&pAttribute->Value.String.pszWide,
         wide
         )
      );

   return NO_ERROR;
}


DWORD
WINAPI
IASAttributeAnsiAlloc(
    PIASATTRIBUTE pAttribute
    )
{
   if (!pAttribute ||
       pAttribute->Value.itType != IASTYPE_STRING  ||
       pAttribute->Value.String.pszAnsi != NULL ||
       pAttribute->Value.String.pszWide == NULL)
   {
      return NO_ERROR;
   }

   // Find out how big a buffer we need.
   int lenA = WideCharToMultiByte(
                  CP_ACP,
                  0,
                  pAttribute->Value.String.pszWide,
                  -1,
                  NULL,
                  0,
                  NULL,
                  NULL
                  );
   if (!lenA) { return GetLastError(); }

   LPSTR ansi = (LPSTR)CoTaskMemAlloc(lenA * sizeof(CHAR));
   if (!ansi) { return ERROR_NOT_ENOUGH_MEMORY; }

   // Do the conversion.
   WideCharToMultiByte(
       CP_ACP,
       0,
       pAttribute->Value.String.pszWide,
       -1,
       ansi,
       lenA,
       NULL,
       NULL
       );

   CoTaskMemFree(
      InterlockedExchangePointer(
         (PVOID*)&pAttribute->Value.String.pszAnsi,
         ansi
         )
      );

   return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\policy\dll_bld\filter.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    filter.h
//
// SYNOPSIS
//
//    Declares the class TypeFilter.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef FILTER_H
#define FILTER_H
#if _MSC_VER >= 1000
#pragma once
#endif

//////////
// Helper function to read a string value from the registry. If the value
// doesn't exist the function returns NO_ERROR and sets *value to NULL. The
// caller is responsible for deleting the returned string.
//////////
LONG
WINAPI
QueryStringValue(
    IN HKEY key,
    IN PCWSTR name,
    OUT PWCHAR* value
    ) throw ();

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    TypeFilter
//
///////////////////////////////////////////////////////////////////////////////
class TypeFilter
{
public:
   TypeFilter(BOOL handleByDefault = TRUE) throw ();

   ~TypeFilter() throw ()
   { delete[] begin; }

   // Returns true if the key passes the filter.
   BOOL shouldHandle(LONG key) const throw ();

   // Reads the filter configuration from the given registry key & value.
   LONG readConfiguration(HKEY key, PCWSTR name) throw ();

private:
   PLONG begin;        // Beginning of allowed types.
   PLONG end;          // End of allowed types.
   BOOL defaultResult; // Default result if filter not set.

   // Advances to the next filter token in the string.
   static PCWSTR nextToken(PCWSTR string) throw ();

   // Not implemented.
   TypeFilter(const TypeFilter&) throw ();
   TypeFilter& operator=(const TypeFilter&) throw ();
};

#endif // FILTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\policy\dll_bld\pipeline.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    pipeline.cpp
//
// SYNOPSIS
//
//    Defines the class Pipeline.
//
// MODIFICATION HISTORY
//
//    01/28/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <polcypch.h>
#include <iasattr.h>
#include <pipeline.h>
#include <request.h>
#include <sdoias.h>
#include <stage.h>
#include <new>

STDMETHODIMP Pipeline::InitNew()
{ return S_OK; }

STDMETHODIMP Pipeline::Initialize()
{
   // Set up the Provider-Type for NAS-State requests.
   if (IASAttributeAlloc(1, &proxy.pAttribute) != NO_ERROR)
   {
      return E_OUTOFMEMORY;
   }
   proxy.pAttribute->dwId = IAS_ATTRIBUTE_PROVIDER_TYPE;
   proxy.pAttribute->Value.itType = IASTYPE_ENUM;
   proxy.pAttribute->Value.Enumerator = IAS_PROVIDER_RADIUS_PROXY;

   // Allocate the TLS use for storing thread state.
   tlsIndex = TlsAlloc();
   if (tlsIndex == (DWORD)-1)
   {
      HRESULT hr = GetLastError();
      return HRESULT_FROM_WIN32(hr);
   }

   // Read the configuration from the registry.
   HKEY key;
   LONG error = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess"
                    L"\\Policy\\Pipeline",
                    0,
                    KEY_READ,
                    &key
                    );
   if (!error)
   {
      error = readConfiguration(key);
      RegCloseKey(key);
   }

   if (error) { return HRESULT_FROM_WIN32(error); }

   // Initialize the stages.
   for (Stage* s = begin; s != end; ++s)
   {
      HRESULT hr = initializeStage(s);
      if (FAILED(hr)) { return hr; }
   }

   return S_OK;
}

STDMETHODIMP Pipeline::Suspend()
{ return S_OK; }

STDMETHODIMP Pipeline::Resume()
{ return S_OK; }

STDMETHODIMP Pipeline::Shutdown()
{
   delete[] begin;
   begin = end = NULL;

   SafeArrayDestroy(handlers);
   handlers = NULL;

   if (tlsIndex != (DWORD) -1)
   {
      TlsFree(tlsIndex);
      tlsIndex = (DWORD)-1;
   }

   IASAttributeRelease(proxy.pAttribute);
   proxy.pAttribute = NULL;
   return S_OK;
}

STDMETHODIMP Pipeline::GetProperty(LONG Id, VARIANT* pValue)
{
   return DISP_E_MEMBERNOTFOUND;
}

STDMETHODIMP Pipeline::PutProperty(LONG Id, VARIANT* pValue)
{
   if (Id) { return S_OK; }

   if (V_VT(pValue) != (VT_ARRAY | VT_VARIANT)) { return DISP_E_TYPEMISMATCH; }

   SafeArrayDestroy(handlers);
   handlers = NULL;
   return SafeArrayCopy(V_ARRAY(pValue), &handlers);
}

STDMETHODIMP Pipeline::OnRequest(IRequest* pRequest) throw ()
{
   // Extract the Request object.
   Request* request = Request::narrow(pRequest);
   if (!request) { return E_NOINTERFACE; }

   // Classify the request.
   classify(*request);

   // Set this as the new source.
   request->pushSource(this);

   // Set the next stage to execute, i.e., stage zero.
   request->pushState(0);

   // Execute the request.
   execute(*request);

   return S_OK;
}

STDMETHODIMP Pipeline::OnRequestComplete(
                           IRequest* pRequest,
                           IASREQUESTSTATUS eStatus
                           )
{
   // Extract the Request object.
   Request* request = Request::narrow(pRequest);
   if (!request) { return E_NOINTERFACE; }

   // If TLS is set, then we're on the original thread ...
   if (TlsGetValue(tlsIndex))
   {
      // ... so clear the value to let the thread know we finished.
      TlsSetValue(tlsIndex, NULL);
   }
   else
   {
      // Otherwise, we're completing asynchronously so continue execution on
      // the caller's thread.
      execute(*request);
   }

   return S_OK;
}

Pipeline::Pipeline() throw ()
   : tlsIndex((DWORD)-1),
     begin(NULL),
     end(NULL),
     handlers(NULL)
{
   memset(&proxy, 0, sizeof(proxy));
}

Pipeline::~Pipeline() throw ()
{
   Shutdown();
}

void Pipeline::classify(
                   Request& request
                   ) throw ()
{
   IASREQUEST routingType = request.getRequest();

   switch (routingType)
   {
      case IAS_REQUEST_ACCESS_REQUEST:
      {
         PIASATTRIBUTE state = request.findFirst(
                                           RADIUS_ATTRIBUTE_STATE
                                           );
         if (state && state->Value.OctetString.dwLength)
         {
            routingType = IAS_REQUEST_CHALLENGE_RESPONSE;
         }
         break;
      }
      case IAS_REQUEST_ACCOUNTING:
      {
         PIASATTRIBUTE status = request.findFirst(
                                            RADIUS_ATTRIBUTE_ACCT_STATUS_TYPE
                                            );
         if (status)
         {
            switch (status->Value.Integer)
            {
               case 7:  // Accounting-On
               case 8:  // Accounting-Off
               {
                  // NAS state messages always go to RADIUS proxy.
                  request.AddAttributes(1, &proxy);
                  routingType = IAS_REQUEST_NAS_STATE;
               }
            }
         }
         break;
      }
   }

   request.setRoutingType(routingType);
}

BOOL Pipeline::executeNext(
                   Request& request
                   ) throw ()
{
   // Compute the next stage to try.
   Stage* nextStage = begin + request.popState();

   // Find the next stage that wants to handle the request.
   while (nextStage != end && !nextStage->shouldHandle(request))
   {
      ++nextStage;
   }

   // Have we reached the end of the pipeline ?
   if (nextStage == end)
   {
      // Reset the source property.
      request.popSource();

      // We're done.
      request.ReturnToSource(IAS_REQUEST_STATUS_HANDLED);

      return FALSE;
   }

   // Save the next stage to try.
   request.pushState(nextStage - begin + 1);

   // Set TLS, so we'll know we're executing a request.
   TlsSetValue(tlsIndex, (PVOID)-1);

   // Forward to the handler.
   nextStage->onRequest(&request);

   // If TLS is not set, then the request completed synchronously.
   BOOL keepExecuting = !TlsGetValue(tlsIndex);

   // Clear TLS.
   TlsSetValue(tlsIndex, NULL);

   return keepExecuting;
}

LONG Pipeline::readConfiguration(HKEY key) throw ()
{
   // How many stages do we have ?
   LONG error;
   DWORD subKeys;
   error = RegQueryInfoKeyW(
               key,
               NULL,
               NULL,
               NULL,
               &subKeys,
               NULL,
               NULL,
               NULL,
               NULL,
               NULL,
               NULL,
               NULL
               );
   if (error) { return error; }

   // Is the pipeline empty ?
   if (!subKeys) { return NO_ERROR; }

   // Allocate memory to hold the stages.
   begin = new (std::nothrow) Stage[subKeys];
   if (!begin) { return ERROR_NOT_ENOUGH_MEMORY; }

   end = begin;

   // Read the configuration for each stage.
   for (DWORD i = 0; i < subKeys; ++i)
   {
      WCHAR name[32];
      DWORD nameLen = 32;
      error = RegEnumKeyExW(
                  key,
                  i,
                  name,
                  &nameLen,
                  NULL,
                  NULL,
                  NULL,
                  NULL
                  );
      if (error)
      {
         if (error == ERROR_NO_MORE_ITEMS) { error = NO_ERROR; }
         break;
      }

      error = (end++)->readConfiguration(key, name);
      if (error) { break; }
   }

   // Sort the stages according to priority.
   qsort(
      begin,
      end - begin,
      sizeof(Stage),
      (CompFn)Stage::sortByPriority
      );

   return error;
}

HRESULT Pipeline::initializeStage(Stage* stage) throw ()
{
   VARIANT *beginHandlers, *endHandlers;
   if (handlers)
   {
      ULONG nelem = handlers->rgsabound[1].cElements;
      beginHandlers = (VARIANT*)handlers->pvData;
      endHandlers = beginHandlers + nelem * 2;
   }
   else
   {
      beginHandlers = endHandlers = NULL;
   }

   // Did we get this handler from the SDOs ?
   for (VARIANT* v = beginHandlers; v != endHandlers; v+= 2)
   {
      if (!_wcsicmp(stage->getProgID(), V_BSTR(v)))
      {
         // Yes, so just use the one they gave us.
         return stage->setHandler(V_UNKNOWN(++v));
      }
   }

   // No, so create a new one.
   return stage->createHandler();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\policy\dll_bld\pipeline.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    pipeline.h
//
// SYNOPSIS
//
//    Declares the class Pipeline.
//
// MODIFICATION HISTORY
//
//    01/28/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef PIPELINE_H
#define PIPELINE_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <iascomp.h>
#include <iaspolcy.h>
#include <iastlb.h>
#include "resource.h"

class Request;
class Stage;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Pipeline
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE Pipeline :
   public CComObjectRootEx<CComMultiThreadModelNoCS>,
   public CComCoClass<Pipeline, &__uuidof(Pipeline)>,
   public IDispatchImpl< IIasComponent,
                         &__uuidof(IIasComponent),
                         &__uuidof(IASCoreLib) >,
   public IDispatchImpl< IRequestHandler,
                         &__uuidof(IRequestHandler),
                         &__uuidof(IASCoreLib) >,
   public IRequestSource
{
public:

DECLARE_NO_REGISTRY()

DECLARE_NOT_AGGREGATABLE(Pipeline)

BEGIN_COM_MAP(Pipeline)
   COM_INTERFACE_ENTRY_IID(__uuidof(IIasComponent), IIasComponent)
   COM_INTERFACE_ENTRY_IID(__uuidof(IRequestHandler), IRequestHandler)
   COM_INTERFACE_ENTRY_IID(__uuidof(IRequestSource), IRequestSource)
END_COM_MAP()

   // IIasComponent
   STDMETHOD(InitNew)();
   STDMETHOD(Initialize)();
   STDMETHOD(Suspend)();
   STDMETHOD(Resume)();
   STDMETHOD(Shutdown)();
   STDMETHOD(GetProperty)(LONG Id, VARIANT* pValue);
   STDMETHOD(PutProperty)(LONG Id, VARIANT* pValue);

   // IRequestHandler
   STDMETHOD(OnRequest)(IRequest* pRequest);

   // IRequestSource
   STDMETHOD(OnRequestComplete)(
                 IRequest* pRequest,
                 IASREQUESTSTATUS eStatus
                 );

protected:
   Pipeline() throw ();
   ~Pipeline() throw ();

private:
   DWORD tlsIndex;            // Index into TLS for storing thread state.
   Stage* begin;              // Beginning of the pipeline.
   Stage* end;                // End of the pipeline.
   SAFEARRAY* handlers;       // Handlers created and owned by the SDOs.
   ATTRIBUTEPOSITION proxy;   // The provider for NAS-State requests.

   // Function type used with qsort.
   typedef int (__cdecl *CompFn)(const void*, const void*);

   // Determine the routing type of the request.
   void classify(Request& request) throw ();

   // Execute the request as much as possible.
   void execute(
            Request& request
            ) throw ();

   // Execute the next interested stage. Returns TRUE if more stages are ready
   // to execute.
   BOOL executeNext(
            Request& request
            ) throw ();

   // Read the stage configuration from the registry.
   LONG readConfiguration(HKEY key) throw ();

   // Initialize the stage's request handler.
   HRESULT initializeStage(Stage* stage) throw ();

   // Not implemented.
   Pipeline(const Pipeline&) throw ();
   Pipeline& operator=(const Pipeline&) throw ();
};

inline void Pipeline::execute(
                          Request& request
                          ) throw ()
{
   while (executeNext(request)) { }
}

#endif // PIPELINE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\policy\dll_bld\polcypch.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    polcypch.h
//
// SYNOPSIS
//
//    Precompiled header file for iaspolcy.dll
//
// MODIFICATION HISTORY
//
//    03/01/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef POLCYPCH_H
#define POLCYPCH_H
#if _MSC_VER >= 1000
#pragma once
#endif

#define IASPOLCYAPI
#include <ias.h>
#include <iasattr.h>
#include <iaspolcy.h>
#include <sdoias.h>

#endif //POLCYPCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\policy\dll_bld\iaspolcy.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iaspipe.cpp
//
// SYNOPSIS
//
//    Implementation of DLL exports for an ATL in proc server.
//
// MODIFICATION HISTORY
//
//    01/28/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <polcypch.h>
#include <pipeline.h>
#include <request.h>

CComModule _Module;
#include <atlimpl.cpp>

BEGIN_OBJECT_MAP(ObjectMap)
   OBJECT_ENTRY(__uuidof(Request), Request)
   OBJECT_ENTRY(__uuidof(Pipeline), Pipeline)
END_OBJECT_MAP()

//////////
// DLL Entry Point
//////////
BOOL
WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID /*lpReserved*/
    )
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
     _Module.Init(ObjectMap, hInstance);

     DisableThreadLibraryCalls(hInstance);
   }
   else if (dwReason == DLL_PROCESS_DETACH)
   {
     _Module.Term();
   }

   return TRUE;
}


//////////
// Used to determine whether the DLL can be unloaded by OLE
//////////
STDAPI DllCanUnloadNow(void)
{
   return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


//////////
// Returns a class factory to create an object of the requested type.
//////////
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
   return _Module.GetClassObject(rclsid, riid, ppv);
}


//////////
// DllRegisterServer - Adds entries to the system registry
//////////
STDAPI DllRegisterServer(void)
{
   return  _Module.RegisterServer(FALSE);
}


//////////
// DllUnregisterServer - Removes entries from the system registry
//////////
STDAPI DllUnregisterServer(void)
{
   return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\policy\dll_bld\request.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation.
//
// SYNOPSIS
//
//    Defines the class Request.
//
///////////////////////////////////////////////////////////////////////////////

#include <polcypch.h>
#include <iasattr.h>
#include <sdoias.h>
#include <request.h>
#include <new>

PIASATTRIBUTE Request::findFirst(DWORD id) const throw ()
{
   for (PIASATTRIBUTE* a = begin; a != end; ++a)
   {
      if ((*a)->dwId == id) { return *a; }
   }

   return NULL;
}

Request* Request::narrow(IUnknown* pUnk) throw ()
{
   Request* request = NULL;

   if (pUnk)
   {
      HRESULT hr = pUnk->QueryInterface(
                             __uuidof(Request),
                             (PVOID*)&request
                             );
      if (SUCCEEDED(hr))
      {
         request->GetUnknown()->Release();
      }
   }

   return request;
}

STDMETHODIMP Request::get_Source(IRequestSource** pVal)
{
   if (*pVal = source) { source->AddRef(); }
   return S_OK;
}

STDMETHODIMP Request::put_Source(IRequestSource* newVal)
{
   if (source) { source->Release(); }
   if (source = newVal) { source->AddRef(); }
   return S_OK;
}

STDMETHODIMP Request::get_Protocol(IASPROTOCOL *pVal)
{
   *pVal = protocol;
   return S_OK;
}

STDMETHODIMP Request::put_Protocol(IASPROTOCOL newVal)
{
   protocol = newVal;
   return S_OK;
}

STDMETHODIMP Request::get_Request(LONG *pVal)
{
   *pVal = (LONG)request;
   return S_OK;
}

STDMETHODIMP Request::put_Request(LONG newVal)
{
   request = (IASREQUEST)newVal;
   return S_OK;
}

STDMETHODIMP Request::get_Response(LONG *pVal)
{
   *pVal = (LONG)response;
   return S_OK;
}

STDMETHODIMP Request::get_Reason(LONG *pVal)
{
   *pVal = (LONG)reason;
   return S_OK;
}

STDMETHODIMP Request::SetResponse(IASRESPONSE eResponse, LONG lReason)
{
   response = eResponse;
   reason = (IASREASON)lReason;
   return S_OK;
}

STDMETHODIMP Request::ReturnToSource(IASREQUESTSTATUS eStatus)
{
   return source ? source->OnRequestComplete(this, eStatus) : S_OK;
}

HRESULT Request::AddAttributes(
                     DWORD dwPosCount,
                     PATTRIBUTEPOSITION pPositions
                     )
{
   if (!reserve(size() + dwPosCount))
   {
      return E_OUTOFMEMORY;
   }

   for ( ; dwPosCount; --dwPosCount, ++pPositions)
   {
      IASAttributeAddRef(pPositions->pAttribute);
      *end++ = pPositions->pAttribute;
   }

   return S_OK;
}

HRESULT Request::RemoveAttributes(
                     DWORD dwPosCount,
                     PATTRIBUTEPOSITION pPositions
                     )
{
   for ( ; dwPosCount; --dwPosCount, ++pPositions)
   {
      PIASATTRIBUTE* pos = find(pPositions->pAttribute);
      if (pos != 0)
      {
         IASAttributeRelease(*pos);
         --end;
         memmove(pos, pos + 1, (end - pos) * sizeof(PIASATTRIBUTE));
      }
   }

   return S_OK;
}

HRESULT Request::RemoveAttributesByType(
                     DWORD dwAttrIDCount,
                     DWORD *lpdwAttrIDs
                     )
{
   for ( ; dwAttrIDCount; ++lpdwAttrIDs, --dwAttrIDCount)
   {
      for (PIASATTRIBUTE* i = begin; i != end; )
      {
         if ((*i)->dwId == *lpdwAttrIDs)
         {
            IASAttributeRelease(*i);
            --end;
            memmove(i, i + 1, (end - i) * sizeof(PIASATTRIBUTE));
         }
         else
         {
            ++i;
         }
      }
   }

   return S_OK;
}

HRESULT Request::GetAttributeCount(
                     DWORD *lpdwCount
                     )
{
   *lpdwCount = size();

   return S_OK;
}

HRESULT Request::GetAttributes(
                     DWORD *lpdwPosCount,
                     PATTRIBUTEPOSITION pPositions,
                     DWORD dwAttrIDCount,
                     DWORD *lpdwAttrIDs
                     )
{
   HRESULT hr = S_OK;
   DWORD count = 0;

   // End of the caller supplied array.
   PATTRIBUTEPOSITION stop = pPositions + *lpdwPosCount;

   // Next struct to be filled.
   PATTRIBUTEPOSITION next = pPositions;

   // Force at least one iteration of the for loop.
   if (!lpdwAttrIDs) { dwAttrIDCount = 1; }

   // Iterate through the desired attribute IDs.
   for ( ; dwAttrIDCount; ++lpdwAttrIDs, --dwAttrIDCount)
   {
      // Iterate through the request's attribute collection.
      for (PIASATTRIBUTE* i = begin; i != end; ++i)
      {
         // Did the caller ask for all the attributes ?
         // If not, is this a match for one of the requested IDs ?
         if (!lpdwAttrIDs || (*i)->dwId == *lpdwAttrIDs)
         {
            if (next)
            {
               if (next == stop)
               {
                  *lpdwPosCount = count;
                  return HRESULT_FROM_WIN32(ERROR_MORE_DATA);
               }

               IASAttributeAddRef(next->pAttribute = *i);
               ++next;
            }

            ++count;
         }
      }
   }

   *lpdwPosCount = count;

   return hr;
}

STDMETHODIMP Request::InsertBefore(
                         PATTRIBUTEPOSITION newAttr,
                         PATTRIBUTEPOSITION refAttr
                         )
{
   // Reserve space for the new attribute.
   if (!reserve(size() + 1))
   {
      return E_OUTOFMEMORY;
   }

   // Find the position; if it doesn't exist we'll do a simple add.
   PIASATTRIBUTE* pos = find(refAttr->pAttribute);
   if (pos == 0)
   {
      return AddAttributes(1, newAttr);
   }

   // Move the existing attribute out of the way.
   memmove(pos + 1, pos, (end - pos) * sizeof(PIASATTRIBUTE));
   ++end;

   // Store the new attribute.
   *pos = newAttr->pAttribute;
   IASAttributeAddRef(*pos);

   return S_OK;
}

STDMETHODIMP Request::Push(
                          ULONG64 State
                          )
{
   const PULONG64 END_STATE = state + sizeof(state)/sizeof(state[0]);

   if (topOfStack != END_STATE)
   {
      *topOfStack = State;

      ++topOfStack;

      return S_OK;
   }

   return E_OUTOFMEMORY;
}

STDMETHODIMP Request::Pop(
                          ULONG64* pState
                          )
{
   if (topOfStack != state)
   {
      --topOfStack;

      *pState = *topOfStack;

      return S_OK;
   }

   return E_FAIL;
}

STDMETHODIMP Request::Top(
                          ULONG64* pState
                          )
{
   if (topOfStack != state)
   {
      *pState = *(topOfStack - 1);

      return S_OK;
   }

   return E_FAIL;
}

Request::Request() throw ()
   : source(NULL),
     protocol(IAS_PROTOCOL_RADIUS),
     request(IAS_REQUEST_ACCESS_REQUEST),
     response(IAS_RESPONSE_INVALID),
     reason(IAS_SUCCESS),
     begin(NULL),
     end(NULL),
     capacity(NULL),
     topOfStack(&state[0])
{
   topOfStack = state;
}

Request::~Request() throw ()
{
   for (PIASATTRIBUTE* i = begin; i != end; ++i)
   {
      IASAttributeRelease(*i);
   }

   delete[] begin;

   if (source) { source->Release(); }
}

inline size_t Request::size() const throw ()
{
   return end - begin;
}

bool Request::reserve(size_t newCapacity) throw ()
{
   if (newCapacity <= capacity)
   {
      return true;
   }

   // Increase the capacity by at least 50% and never less than 32.
   size_t minCapacity = (capacity > 21) ? (capacity * 3 / 2): 32;

   // Is the requested capacity less than the minimum resize?
   if (newCapacity < minCapacity)
   {
      newCapacity = minCapacity;
   }

   // Allocate the new array.
   PIASATTRIBUTE* newArray = new (std::nothrow) PIASATTRIBUTE[newCapacity];
   if (newArray == 0)
   {
      return false;
   }

   // Save the values in the old array.
   memcpy(newArray, begin, size() * sizeof(PIASATTRIBUTE));

   // Delete the old array.
   delete[] begin;

   // Update our pointers.
   end = newArray + size();
   begin = newArray;
   capacity = newCapacity;

   return true;
}

PIASATTRIBUTE* Request::find(IASATTRIBUTE* key) const throw ()
{
   for (PIASATTRIBUTE* i = begin; i != end; ++i)
   {
      if (*i == key)
      {
         return i;
      }
   }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\policy\dll_bld\resource.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    resource.h
//
// SYNOPSIS
//
//    Resource ID's for the Pipeline module.
//
// MODIFICATION HISTORY
//
//    01/28/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#define IDR_Registry  201

#endif  // _RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\policy\dll_bld\request.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation.
//
// SYNOPSIS
//
//    Declares the class Request.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef REQUEST_H
#define REQUEST_H

#include "resource.h"
#include <iaspolcy.h>
#include <sdoias.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Request
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE Request :
   public CComObjectRootEx<CComMultiThreadModelNoCS>,
   public CComCoClass<Request, &__uuidof(Request)>,
   public IRequest,
   public IAttributesRaw,
   public IRequestState
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_Registry)

DECLARE_NOT_AGGREGATABLE(Request)

BEGIN_COM_MAP(Request)
   COM_INTERFACE_ENTRY_IID(__uuidof(IAttributesRaw), IAttributesRaw)
   COM_INTERFACE_ENTRY_IID(__uuidof(Request), Request)
   COM_INTERFACE_ENTRY_IID(__uuidof(IRequestState), IRequestState)
   COM_INTERFACE_ENTRY_IID(__uuidof(IRequest), IRequest)
END_COM_MAP()

   /////////
   // Methods used by the Pipeline for routing requests.
   /////////

   IASREQUEST getRequest() const throw ()
   { return request; }

   IASPROVIDER getProvider() const throw ()
   {
      PIASATTRIBUTE attr = findFirst(IAS_ATTRIBUTE_PROVIDER_TYPE);
      return attr ? (IASPROVIDER)attr->Value.Enumerator : IAS_PROVIDER_NONE;
   }


   IASRESPONSE getResponse() const throw ()
   { return response; }

   IASREASON getReason() const throw ()
   { return reason; }

   void pushState(ULONG64 state) throw ()
   { *topOfStack++ = state; }

   ULONG64 popState() throw ()
   { return *--topOfStack; }

   void pushSource(IRequestSource* newVal) throw ()
   { pushState((ULONG64)source); source = newVal; }

   void popSource() throw ()
   { source = (IRequestSource*)popState(); }

   IASREQUEST getRoutingType() const throw ()
   { return routing; }
   void setRoutingType(IASREQUEST newVal) throw ()
   { routing = newVal; }

   PIASATTRIBUTE findFirst(DWORD id) const throw ();

   static Request* narrow(IUnknown* pUnk) throw ();

   /////////
   // IRequest
   /////////

   STDMETHOD(get_Source)(IRequestSource** pVal);
   STDMETHOD(put_Source)(IRequestSource* newVal);
   STDMETHOD(get_Protocol)(IASPROTOCOL *pVal);
   STDMETHOD(put_Protocol)(IASPROTOCOL newVal);
   STDMETHOD(get_Request)(LONG *pVal);
   STDMETHOD(put_Request)(LONG newVal);
   STDMETHOD(get_Response)(LONG *pVal);
   STDMETHOD(get_Reason)(LONG *pVal);
   STDMETHOD(SetResponse)(IASRESPONSE eResponse, LONG lReason);
   STDMETHOD(ReturnToSource)(IASREQUESTSTATUS eStatus);

   /////////
   // IAttributesRaw
   /////////

   STDMETHOD(AddAttributes)(
                 DWORD dwPosCount,
                 PATTRIBUTEPOSITION pPositions
                 );
   STDMETHOD(RemoveAttributes)(
                 DWORD dwPosCount,
                 PATTRIBUTEPOSITION pPositions
                 );
   STDMETHOD(RemoveAttributesByType)(
                 DWORD dwAttrIDCount,
                 DWORD *lpdwAttrIDs
                 );
   STDMETHOD(GetAttributeCount)(
                 DWORD *lpdwCount
                 );
   STDMETHOD(GetAttributes)(
                 DWORD *lpdwPosCount,
                 PATTRIBUTEPOSITION pPositions,
                 DWORD dwAttrIDCount,
                 DWORD *lpdwAttrIDs
                 );
   STDMETHOD(InsertBefore)(
                PATTRIBUTEPOSITION newAttr,
                PATTRIBUTEPOSITION refAttr
                );

   /////////
   // IRequestState
   /////////

   STDMETHOD(Push)(
                 ULONG64 state
                 );
   STDMETHOD(Pop)(
                 ULONG64 *pState
                 );
   STDMETHOD(Top)(
                 ULONG64 *pState
                 );

protected:
   Request() throw ();
   ~Request() throw ();

private:
   // Returns the number of attributes in the request.
   size_t size() const throw ();

   // Resizes the attribute array as necessary to ensure it has room for at
   // least newCapacity elements. Returns true if successful, false otherwise.
   bool reserve(size_t newCapacity) throw ();

   // Returns the position of the specified attribute in the array or null if
   // the attribute doesn't exist.
   PIASATTRIBUTE* find(IASATTRIBUTE* key) const throw ();

   // Properties.
   IRequestSource* source;
   IASPROTOCOL protocol;
   IASREQUEST request;
   IASRESPONSE response;
   IASREASON reason;

   // More specific request type used for routing.
   IASREQUEST routing;

   // Attribute collection.
   PIASATTRIBUTE* begin;
   PIASATTRIBUTE* end;
   size_t capacity;

   // State stack.
   ULONG64 state[3];
   PULONG64 topOfStack;

   // Not implemented.
   Request(const Request&) throw ();
   Request& operator=(const Request&) throw ();
};

#endif // REQUEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\attrdnry.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    attrdnry.h
//
// SYNOPSIS
//
//    Declares the class AttributeDictionary.
//
// MODIFICATION HISTORY
//
//    02/04/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef ATTRDNRY_H
#define ATTRDNRY_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <attridx.h>

//////////
// Struct representing an attribute definition.
//////////
struct AttributeDefinition
{
   ULONG id;
   ULONG syntax;
   ULONG vendorID;
   ULONG vendorType;
   BOOL excludeFromLog;
};

class AttributeDictionary
{
public:
   AttributeDictionary() throw ()
      : first(NULL), last(NULL)
   { }
   ~AttributeDictionary() throw ();

   HRESULT FinalConstruct() throw ();

   typedef const AttributeDefinition* const_iterator;

   const_iterator begin() const throw ()
   { return first; }

   const_iterator end() const throw ()
   { return last; }

   const AttributeDefinition* findByID(ULONG id) const throw ();

   const AttributeDefinition* findByVendorInfo(
                                  ULONG vendorID,
                                  ULONG vendorType
                                  ) const throw ();
private:
   void initialize();

   AttributeDefinition* first;
   AttributeDefinition* last;

   AttributeIndex byID;
   AttributeIndex byVendorInfo;

   // Not implemented.
   AttributeDictionary(const AttributeDictionary&) throw ();
   AttributeDictionary& operator=(const AttributeDictionary&) throw ();
};

#endif  // ATTRDNRY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\policy\dll_bld\stage.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    stage.cpp
//
// SYNOPSIS
//
//    Defines the class Stage.
//
///////////////////////////////////////////////////////////////////////////////

#include <polcypch.h>
#include <iascomp.h>
#include <iaspolcy.h>
#include <request.h>
#include <stage.h>
#include <new>

Stage::Stage() throw ()
   : reasons(FALSE), handler(NULL), component(NULL), progId(NULL)
{ }

Stage::~Stage() throw ()
{
   delete[] progId;
   releaseHandler();
}

BOOL Stage::shouldHandle(
                const Request& request
                ) const throw ()
{
   // The request has to pass the 'requests' and 'providers' filters and either
   // the 'responses' filter or the 'reasons' filter.
   return requests.shouldHandle((LONG)request.getRoutingType()) &&
          providers.shouldHandle((LONG)request.getProvider()) &&
          (responses.shouldHandle((LONG)request.getResponse()) ||
           reasons.shouldHandle((LONG)request.getReason()));

}

void Stage::onRequest(IRequest* pRequest) throw ()
{
   HRESULT hr = handler->OnRequest(pRequest);
   if (FAILED(hr))
   {
      // If we couldn't forward it to the handler, we'll discard the packet.
      pRequest->SetResponse(
                    IAS_RESPONSE_DISCARD_PACKET,
                    IAS_INTERNAL_ERROR
                    );
      pRequest->ReturnToSource(IAS_REQUEST_STATUS_ABORT);
   }
}

LONG Stage::readConfiguration(HKEY key, PCWSTR name) throw ()
{
   // The key name is the filter priority.
   priority = _wtol(name);

   LONG error;
   HKEY stage;
   error = RegOpenKeyExW(
               key,
               name,
               0,
               KEY_QUERY_VALUE,
               &stage
               );
   if (error) { return error; }

   do
   {
      // Default value is the prog ID.
      error = QueryStringValue(stage, NULL, &progId);
      if (error) { break; }

      /////////
      // Process each of the filters.
      /////////

      error = requests.readConfiguration(stage, L"Requests");
      if (error) { break; }

      error = responses.readConfiguration(stage, L"Responses");
      if (error) { break; }

      error = providers.readConfiguration(stage, L"Providers");
      if (error) { break; }

      error = reasons.readConfiguration(stage, L"Reasons");

   } while (FALSE);

   RegCloseKey(stage);

   return error;
}

HRESULT Stage::createHandler() throw ()
{
   // Release the existing handler (if any).
   releaseHandler();

   // Convert the ProgID to a CLSID.
   HRESULT hr;
   CLSID clsid;
   hr = CLSIDFromProgID(progId, &clsid);
   if (FAILED(hr)) { return hr; }

   // Create ...
   hr = CoCreateInstance(
            clsid,
            NULL,
            CLSCTX_INPROC_SERVER,
            __uuidof(IIasComponent),
            (PVOID*)&component
            );
   if (FAILED(hr)) { return hr; }

   // ... and initialize the component.
   hr = component->InitNew();
   if (FAILED(hr)) { return hr; }
   hr = component->Initialize();
   if (FAILED(hr)) { return hr; }

   // Get the IRequestHandler interface.
   return component->QueryInterface(
                         __uuidof(IRequestHandler),
                         (PVOID*)&handler
                         );
}

HRESULT Stage::setHandler(IUnknown* newHandler) throw ()
{
   // Release the existing handler (if any).
   releaseHandler();

   // Get the IRequestHandler interface.
   return newHandler->QueryInterface(
                          __uuidof(IRequestHandler),
                          (PVOID*)&handler
                          );
}

void Stage::releaseHandler() throw ()
{
   if (component)
   {
      // If we have an IIasComponent interface, then we're the owner, so we
      // have to shut it down first.
      component->Suspend();
      component->Shutdown();
      component->Release();
      component = NULL;
   }

   if (handler)
   {
      handler->Release();
      handler = NULL;
   }
}

int __cdecl Stage::sortByPriority(
                       const Stage* lhs,
                       const Stage* rhs
                       ) throw ()
{
   return (int)(lhs->priority - rhs->priority);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\policy\dll_bld\stage.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    stage.h
//
// SYNOPSIS
//
//    Declares the class Stage.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef STAGE_H
#define STAGE_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <filter.h>

class Request;
struct IRequest;
struct IRequestHandler;
struct IIasComponent;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Stage
//
///////////////////////////////////////////////////////////////////////////////
class Stage
{
public:
   Stage() throw ();
   ~Stage() throw ();

   // Returns the Prog ID for the handler at this stage.
   PCWSTR getProgID() const throw ()
   { return progId ? progId : L""; }

   // Returns TRUE if the Stage should handle the request.
   BOOL shouldHandle(
           const Request& request
           ) const throw ();

   // Forwards the request to the handler for this stage.
   void onRequest(IRequest* pRequest) throw ();

   // Reads the configuration for the stage from the registry.
   LONG readConfiguration(HKEY key, PCWSTR name) throw ();

   // Create a new handler.
   HRESULT createHandler() throw ();

   // Use an existing handler.
   HRESULT setHandler(IUnknown* newHandler) throw ();

   // Release the handler for this stage.
   void releaseHandler() throw ();

   // Used for sorting stages by priority.
   static int __cdecl sortByPriority(
                          const Stage* lhs,
                          const Stage* rhs
                          ) throw ();
private:
   TypeFilter requests;        // Filter based on request type.
   TypeFilter responses;       // Filter based on response type.
   TypeFilter providers;       // Filter based on provider type.
   TypeFilter reasons;         // Filter based on reason codes.
   IRequestHandler* handler;   // The request handler for this stage.
   IIasComponent* component;   // Non-NULL if we created the handler.
   LONG priority;              // Priority of the stage; lower comes first.
   PWSTR progId;               // ProgID of the handler for this stage.

   // Not implemented.
   Stage(const Stage&) throw ();
   Stage& operator=(const Stage&) throw ();
};

#endif // STAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\attrdnry.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    attrdnry.cpp
//
// SYNOPSIS
//
//    Defines the class AttributeDictionary.
//
// MODIFICATION HISTORY
//
//    02/04/2000    Original version.
//    04/17/2000    Port to new dictionary API.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <iastlutl.h>
#include <iasutil.h>
#include <attrdnry.h>

///////////////////////////////////////////////////////////////////////////////
//
//
// Various functions used for defining the indices.
//
///////////////////////////////////////////////////////////////////////////////

ULONG
WINAPI
HashById(
    const AttributeDefinition& def
    ) throw ()
{
   return def.id;
}

BOOL
WINAPI
EqualById(
    const AttributeDefinition& def1, const AttributeDefinition& def2
    ) throw ()
{
   return def1.id == def2.id;
}

ULONG
WINAPI
HashByVendorInfo(
   const AttributeDefinition& def
   ) throw ()
{
   return def.vendorID | def.vendorType;
}

BOOL
WINAPI
EqualByVendorInfo(
    const AttributeDefinition& def1, const AttributeDefinition& def2
    ) throw ()
{
   return def1.vendorID == def2.vendorID && def1.vendorType == def2.vendorType;
}

BOOL
WINAPI
FilterByVendorInfo(
    const AttributeDefinition& def
    ) throw ()
{
   return def.vendorID != 0;
}

AttributeDictionary::~AttributeDictionary() throw ()
{
   delete[] first;
}

HRESULT AttributeDictionary::FinalConstruct() throw ()
{
   try
   {
      initialize();
   }
   CATCH_AND_RETURN();

   return S_OK;
}

void AttributeDictionary::initialize()
{
   // Names of various columns in the dictionary.
   const PCWSTR COLUMNS[] =
   {
      L"ID",
      L"Syntax",
      L"VendorID",
      L"VendorTypeID",
      NULL
   };

   IASTL::IASDictionary dnary(COLUMNS);

   using _com_util::CheckError;

   // Allocate memory to hold the definitions.
   first = last = new AttributeDefinition[dnary.getNumRows()];

   // Iterate through the dictionary and process each definition.
   while (dnary.next())
   {
      // Process each database column.
      last->id = (ULONG)dnary.getLong(0);
      last->syntax = (ULONG)dnary.getLong(1);
      last->vendorID = (ULONG)dnary.getLong(2);
      last->vendorType = (ULONG)dnary.getLong(3);

      ++last;
   }

   /////////
   // Initialize the indices.
   /////////

   byID.create(
            first,
            last,
            HashById,
            EqualById
            );

   byVendorInfo.create(
                first,
                last,
                HashByVendorInfo,
                EqualByVendorInfo,
                FilterByVendorInfo
                );
}

const AttributeDefinition*
AttributeDictionary::findByID(ULONG id) const throw ()
{
   AttributeDefinition key;
   key.id = id;
   return byID.find(key);
}

const AttributeDefinition*
AttributeDictionary::findByVendorInfo(
                         ULONG vendorID,
                         ULONG vendorType
                         ) const throw ()
{
   AttributeDefinition key;
   key.vendorID = vendorID;
   key.vendorType = vendorType;
   return byVendorInfo.find(key);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\attridx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    attridx.cpp
//
// SYNOPSIS
//
//    Defines the class AttributeIndex
//
// MODIFICATION HISTORY
//
//    02/04/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <attridx.h>
#include <attrdnry.h>

void AttributeIndex::create(
                         const AttributeDefinition* begin,
                         const AttributeDefinition* end,
                         HashFn hash,
                         EqualFn equal,
                         FilterFn filterFn
                         )
{
   const AttributeDefinition* i;

   // Delete any existing index.
   delete[] table;
   table = NULL;

   // Same the funtion pointers.
   hashFn = hash;
   equalFn = equal;

   // Determine how many entries are in the index.
   ULONG count;
   if (filterFn)
   {
      count = 0;
      for (i = begin; i != end; ++i)
      {
         if (filterFn(*i)) { ++count; }
      }
   }
   else
   {
      count = end - begin;
   }

   // Buckets should be a power of two.
   ULONG buckets = 1;
   while (buckets < count) { buckets <<= 1; }

   // Set the hash mask.
   mask = buckets - 1;

   // Allocate the buckets and nodes.
   SIZE_T nbyte = sizeof(Bucket) * buckets + sizeof(Node) * count;
   table = (Bucket*)operator new(nbyte);
   Node* node = (Node*)(table + buckets);

   // Zeroize the hash table.
   memset(table, 0, sizeof(Bucket) * buckets);

   // Iterate through the definitions to be indexed.
   for (i = begin; i != end; ++i)
   {
      // Should we index this one?
      if (!filterFn || filterFn(*i))
      {
         // Yes, so compute the bucket.
         Bucket* bucket = table + (hashFn(*i) & mask);

         // Insert the node at the head of the linked list.
         node->next = *bucket;
         *bucket = node;

         // Store the definition.
         node->def = i;

         // Advance to the next node.
         ++node;
      }
   }
}

const AttributeDefinition* AttributeIndex::find(
                                               const AttributeDefinition& key
                                               ) const throw ()
{
   // Get the appropriate bucket.
   Bucket* bucket = table + (hashFn(key) & mask);

   // Iterate through the linked list ...
   for (const Node* node = *bucket; node; node = node->next)
   {
      // ... and look for a match.
      if (equalFn(*node->def, key)) { return node->def; }
   }

   return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\attridx.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    attridx.h
//
// SYNOPSIS
//
//    Declares the class AttributeIndex
//
// MODIFICATION HISTORY
//
//    02/04/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef ATTRIDX_H
#define ATTRIDX_H
#if _MSC_VER >= 1000
#pragma once
#endif

struct AttributeDefinition;

class AttributeIndex
{
public:
   AttributeIndex() throw ()
      : table(NULL), mask(0), hashFn(NULL), equalFn(NULL)
   { }

   ~AttributeIndex() throw ()
   { delete[] table; }

   // Used for hashing AttributeDefinitions.
   typedef ULONG (WINAPI *HashFn)(
                              const AttributeDefinition& def
                              ) throw ();

   // Used for testing equality of AttributeDefinitions.
   typedef BOOL (WINAPI *EqualFn)(
                             const AttributeDefinition& def1,
                             const AttributeDefinition& def2
                             ) throw ();

   // Used for determining which definitions should be indexed.
   typedef BOOL (WINAPI *FilterFn)(
                             const AttributeDefinition& def
                             ) throw ();

   // Create a new index. Any existing index is destroyed.
   void create(
            const AttributeDefinition* begin,
            const AttributeDefinition* end,
            HashFn hash,
            EqualFn equal,
            FilterFn filterFn = NULL
            );

   // Find an AttributeDefinition according to the key.
   const AttributeDefinition* find(
                                  const AttributeDefinition& key
                                  ) const throw ();

private:
   // Node in a bucket.
   struct Node
   {
      const Node* next;
      const AttributeDefinition* def;
   };

   // Bucket in a hash table.
   typedef Node* Bucket;

   Bucket* table;     // The hash table.
   ULONG mask;        // Mask used for reducing hash values.
   HashFn hashFn;     // Function used for hashing definitions.
   EqualFn equalFn;   // Function used for comparing definitions to key.

   // Not implemented.
   AttributeIndex(const AttributeIndex&) throw ();
   AttributeIndex& operator=(const AttributeIndex&) throw ();
};

#endif // ATTRIDX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\counters.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    counters.cpp
//
// SYNOPSIS
//
//    Defines the classes SharedMemory and ProxyCounters.
//
// MODIFICATION HISTORY
//
//    02/16/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <counters.h>

//////////
// Helper function that creates a named mutex which only admins can access.
//////////
HANDLE CreateAdminMutex(PCWSTR name) throw ()
{
   // Create the SID for local Administrators.
   SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
   PSID adminSid = (PSID)_alloca(GetSidLengthRequired(2));
   InitializeSid(
       adminSid,
       &sia,
       2
       );
   *GetSidSubAuthority(adminSid, 0) = SECURITY_BUILTIN_DOMAIN_RID;
   *GetSidSubAuthority(adminSid, 1) = DOMAIN_ALIAS_RID_ADMINS;

   // Create an ACL giving Administrators all access.
   ULONG cbAcl = sizeof(ACL) +
                 (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                 GetLengthSid(adminSid);
   PACL acl = (PACL)_alloca(cbAcl);
   InitializeAcl(
       acl,
       cbAcl,
       ACL_REVISION
       );
   AddAccessAllowedAce(
       acl,
       ACL_REVISION,
       MUTEX_ALL_ACCESS,
       adminSid
       );

   // Create a security descriptor with the above ACL.
   PSECURITY_DESCRIPTOR pSD;
   BYTE buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
   pSD = (PSECURITY_DESCRIPTOR)buffer;
   InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
   SetSecurityDescriptorDacl(pSD, TRUE, acl, FALSE);

   // Fill in the SECURITY_ATTRIBUTES struct.
   SECURITY_ATTRIBUTES sa;
   sa.nLength = sizeof(sa);
   sa.lpSecurityDescriptor = pSD;
   sa.bInheritHandle = TRUE;

   // Create the mutex.
   return CreateMutex(&sa, FALSE, name);
}

SharedMemory::SharedMemory() throw ()
   : fileMap(NULL),
     view(NULL),
     reserved(0),
     committed(0)
{
   // Determine the page size for this platform.
   SYSTEM_INFO si;
   GetSystemInfo(&si);
   pageSize = si.dwPageSize;
}

bool SharedMemory::open(PCWSTR name, DWORD size) throw ()
{
   close();

   // Determine the number of pages to reserve.
   reserved = (size + pageSize - 1)/pageSize;

   // Create the mapping in the pagefile ...
   fileMap = CreateFileMappingW(
                 INVALID_HANDLE_VALUE,
                 NULL,
                 PAGE_READWRITE | SEC_RESERVE,
                 0,
                 reserved * pageSize,
                 name
                 );
   if (fileMap)
   {
      // ... and map it into our process.
      view = MapViewOfFile(
                 fileMap,
                 FILE_MAP_WRITE,
                 0,
                 0,
                 0
                 );
      if (!view)
      {
         CloseHandle(fileMap);
         fileMap = NULL;
      }
   }

   return view != NULL;
}

void SharedMemory::close() throw ()
{
   if (view)
   {
      UnmapViewOfFile(view);
      view = NULL;
   }
   if (fileMap)
   {
      CloseHandle(fileMap);
      fileMap = NULL;
   }

   reserved = 0;
   committed = 0;
}

bool SharedMemory::commit(DWORD nbyte) throw ()
{
   // How many pages will we need ?
   DWORD pagesNeeded = (nbyte + pageSize - 1)/pageSize;

   // Do we have to commit more memory?
   if (pagesNeeded > committed)
   {
      // If we've hit the max or we can't commit anymore, we're done.
      if (pagesNeeded > reserved ||
          !VirtualAlloc(
               view,
               pageSize * pagesNeeded,
               MEM_COMMIT,
               PAGE_READWRITE
               ))
      {
         return false;
      }

      committed = pagesNeeded;
   }

   return true;
}

HRESULT ProxyCounters::FinalConstruct() throw ()
{
   mutex = CreateAdminMutex(RadiusStatisticsMutex);
   if (mutex)
   {
      lock();

      // Opend the shared memory.
      if (data.open(RadiusProxyStatisticsName, 0x40000))
      {
         // Commit enough space for the Proxy entry.
         nbyte = sizeof(RadiusProxyStatistics) -
                 sizeof(RadiusRemoteServerEntry);

         if (data.commit(nbyte))
         {
            // Zero out the stats.
            stats = (RadiusProxyStatistics*)data.base();
            memset(stats, 0, nbyte);
         }
      }

      unlock();
   }

   if (!stats)
   {
      DWORD error = GetLastError();
      return HRESULT_FROM_WIN32(error);
   }

   return S_OK;
}

RadiusRemoteServerEntry* ProxyCounters::getRemoteServerEntry(
                                            ULONG address
                                            ) throw ()
{
   address = ntohl(address);

   // Try once without the lock.
   RadiusRemoteServerEntry* entry = findRemoteServer(address);
   if (!entry)
   {
      lock();

      // Now try again with the lock just to be sure.
      entry = findRemoteServer(address);
      if (!entry)
      {
         // Make sure we have space.
         if (data.commit(nbyte + sizeof(RadiusRemoteServerEntry)))
         {
            // Zero out the new entry.
            entry = stats->rseRemoteServers + stats->dwNumRemoteServers;
            memset(entry, 0, sizeof(*entry));

            // Set the address.
            entry->dwAddress = address;

            // Update the number of servers ...
            ++(stats->dwNumRemoteServers);
            // ... and the number of bytes.
            nbyte += sizeof(RadiusRemoteServerEntry);
         }
      }

      unlock();
   }

   return entry;
}

//////////
// Array that maps a (RadiusMIB, RadiusEvent) pair to a RemoteServer counter
// offset.
//////////
LONG counterOffset[][2] =
{
   // eventNone
   { -1, -1 },
   // eventInvalidAddress
   { radiusAuthClientInvalidAddresses, radiusAccClientInvalidAddresses },
   // eventAccessRequest
   { radiusAuthClientAccessRequests, -1 },
   // eventAccessAccept
   { radiusAuthClientAccessAccepts, -1 },
   // eventAccessReject
   { radiusAuthClientAccessRejects, -1 },
   // eventAccessChallenge
   { radiusAuthClientAccessChallenges, -1 },
   // eventAccountingRequest
   { -1, radiusAccClientRequests },
   // eventAccountingResponse
   { -1, radiusAccClientResponses },
   // eventMalformedPacket
   { radiusAuthClientMalformedAccessResponses, radiusAccClientResponses },
   // eventBadAuthenticator
   { radiusAuthClientBadAuthenticators, radiusAccClientBadAuthenticators },
   // eventBadSignature
   { radiusAuthClientBadAuthenticators, radiusAccClientBadAuthenticators },
   // eventMissingSignature
   { radiusAuthClientBadAuthenticators, radiusAccClientBadAuthenticators },
   // eventTimeout
   { radiusAuthClientTimeouts, radiusAccClientTimeouts },
   // eventUnknownType
   { radiusAuthClientUnknownTypes, radiusAccClientUnknownTypes },
   // eventUnexpectedResponse
   { radiusAuthClientPacketsDropped, radiusAccClientPacketsDropped },
   // eventLateResponse
   { radiusAuthClientPacketsDropped, radiusAccClientPacketsDropped },
   // eventRoundTrip
   { radiusAuthClientRoundTripTime, radiusAccClientRoundTripTime },
   // eventSendError
   { -1, -1 },
   // eventReceiveError
   { -1, -1 },
   // eventServerAvailable
   { -1, -1 },
   // eventServerUnavailable
   { -1, -1 }
};

void ProxyCounters::updateCounters(
                        RadiusPortType port,
                        RadiusEventType event,
                        RadiusRemoteServerEntry* server,
                        ULONG data
                        ) throw ()
{
   // Get the counter offset. If it's negative, then this event doesn't effect
   // any counters.
   LONG offset = counterOffset[event][port];
   if (offset < 0) { return; }

   if (event == eventInvalidAddress)
   {
      InterlockedIncrement((PLONG)stats->peProxy.dwCounters + offset);
   }
   else if (server)
   {
      if (event == eventRoundTrip)
      {
         server->dwCounters[offset] = data;
      }
      else
      {
         InterlockedIncrement((PLONG)server->dwCounters + offset);
      }
   }
}

RadiusRemoteServerEntry* ProxyCounters::findRemoteServer(
                                            ULONG address
                                            ) throw ()
{
   for (DWORD i = 0; i < stats->dwNumRemoteServers; ++i)
   {
      if (stats->rseRemoteServers[i].dwAddress == address)
      {
         return stats->rseRemoteServers + i;
      }
   }

   return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\counters.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    counters.h
//
// SYNOPSIS
//
//    Declares the classes SharedMemory and ProxyCounters.
//
// MODIFICATION HISTORY
//
//    02/16/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef COUNTERS_H
#define COUNTERS_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <iasinfo.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SharedMemory
//
// DESCRIPTION
//
//    Simple wrapper around a shared memory segment.
//
///////////////////////////////////////////////////////////////////////////////
class SharedMemory
{
public:
   SharedMemory() throw ();
   ~SharedMemory() throw ()
   { close(); }

   // Open a shared memory segment and reserve (but not commit) the specified
   // number of bytes.
   bool open(PCWSTR name, DWORD reserve) throw ();

   // Close the mapping.
   void close() throw ();

   // Ensure that at least 'nbyte' bytes are committed. Returns 'true' if
   // successful.
   bool commit(DWORD nbyte) throw ();

   // Returns the base address of the segment.
   PVOID base() const throw ()
   { return view; }

private:
   HANDLE fileMap;
   PVOID view;
   DWORD pageSize;
   DWORD reserved;   // Number of pages reserved.
   DWORD committed;  // Number of pages committed.

   // Not implemented.
   SharedMemory(SharedMemory&);
   SharedMemory& operator=(SharedMemory&);
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ProxyCounters
//
// DESCRIPTION
//
//    Manages the PerfMon/SNMP counters for the RADIUS proxy.
//
///////////////////////////////////////////////////////////////////////////////
class ProxyCounters
{
public:
   ProxyCounters() throw ()
      : stats(NULL), mutex(NULL), nbyte(0)
   { }

   ~ProxyCounters() throw()
   {if (mutex) CloseHandle(mutex);}

   HRESULT FinalConstruct() throw ();

   // Returns the entry for the RADIUS proxy counters.
   RadiusProxyEntry& getProxyEntry() throw ()
   { return stats->peProxy; }

   // Returns the entry for a give server, creating a new entry if necessary.
   // Returns NULL if no more room is available in the shared memory segment.
   RadiusRemoteServerEntry* getRemoteServerEntry(ULONG address) throw ();

   // Update the counters.
   void updateCounters(
            RadiusPortType port,
            RadiusEventType event,
            RadiusRemoteServerEntry* server,
            ULONG data
            ) throw ();

protected:
   void lock() throw ()
   { WaitForSingleObject(mutex, INFINITE); }
   void unlock() throw ()
   { ReleaseMutex(mutex); }

   // Find an entry without creating a new one.
   RadiusRemoteServerEntry* findRemoteServer(ULONG address) throw ();

private:
   RadiusProxyStatistics* stats;
   HANDLE mutex;
   SharedMemory data;
   DWORD nbyte;         // Current size of the counter data.

   // Not implemented.
   ProxyCounters(ProxyCounters&);
   ProxyCounters& operator=(ProxyCounters&);
};

#endif // COUNTERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\dsobj.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    dsobj.cpp
//
// SYNOPSIS
//
//    Defines the class DataStoreObject.
//
// MODIFICATION HISTORY
//
//    02/12/2000    Original version.
//    04/17/2000    Must pass BSTRs to data store objects.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <dsobj.h>

using _com_util::CheckError;

DataStoreObject::DataStoreObject() throw ()
{
}

DataStoreObject::DataStoreObject(IUnknown* pUnk, PCWSTR path)
   : object(pUnk), container(pUnk)
{
   if (path)
   {
      while (!empty() && *path != L'\0')
      {
         getChild(path, *this);

         path += wcslen(path) + 1;
      }
   }
}

DataStoreObject::~DataStoreObject() throw ()
{
}

void DataStoreObject::getValue(PCWSTR name, BSTR* value)
{
   VARIANT v;
   getValue(name, VT_BSTR, &v, true);
   *value = V_BSTR(&v);
}

void DataStoreObject::getValue(PCWSTR name, BSTR* value, BSTR defaultValue)
{
   VARIANT v;
   if (getValue(name, VT_BSTR, &v, false))
   {
      *value = V_BSTR(&v);
   }
   else
   {
      *value = SysAllocString(defaultValue);
      if (!*value && defaultValue) { _com_issue_error(E_OUTOFMEMORY); }
   }
}

void DataStoreObject::getValue(PCWSTR name, ULONG* value)
{
   VARIANT v;
   getValue(name, VT_I4, &v, true);
   *value = V_UI4(&v);
}

void DataStoreObject::getValue(PCWSTR name, ULONG* value, ULONG defaultValue)
{
   VARIANT v;
   if (getValue(name, VT_I4, &v, false))
   {
      *value = V_UI4(&v);
   }
   else
   {
      *value = defaultValue;
   }
}

void DataStoreObject::getValue(PCWSTR name, bool* value)
{
   VARIANT v;
   getValue(name, VT_BOOL, &v, true);
   *value = V_BOOL(&v) != 0;
}

void DataStoreObject::getValue(PCWSTR name, bool* value, bool defaultValue)
{
   VARIANT v;
   if (getValue(name, VT_BOOL, &v, false))
   {
      *value = V_BOOL(&v) != 0;
   }
   else
   {
      *value = defaultValue;
   }
}

LONG DataStoreObject::numChildren()
{
   LONG value;
   CheckError(container->get_Count(&value));
   return value;
}

bool DataStoreObject::nextChild(DataStoreObject& obj)
{
   if (!hasChildren()) { return false; }

   _variant_t element;
   ULONG fetched;
   HRESULT hr = children->Next(1, &element, &fetched);

   CheckError(hr);

   if (hr != S_OK || !fetched) { return false; }

   obj.attach(IDataStoreObjectPtr(element));

   return true;
}

bool DataStoreObject::empty() const throw ()
{
   return object == NULL;
}

void DataStoreObject::attach(IDataStoreObject* obj)
{
   object = obj;
   container = object;
   children = NULL;
}

bool DataStoreObject::getChild(PCWSTR name, DataStoreObject& obj)
{
   // Convert name to a BSTR.
   CComBSTR bstrName(name);
   if (!bstrName) { _com_issue_error(E_OUTOFMEMORY); }

   IDataStoreObjectPtr child;
   HRESULT hr = container->Item(bstrName, &child);
   if (FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
   {
      _com_issue_error(hr);
   }

   obj.attach(child);

   return !obj.empty();
}

bool DataStoreObject::hasChildren()
{
   if (children == NULL)
   {
      IUnknownPtr unk;
      CheckError(container->get__NewEnum(&unk));
      children = unk;
   }

   return children != NULL;
}

bool DataStoreObject::getValue(
                          PCWSTR name,
                          VARTYPE vt,
                          VARIANT* value,
                          bool mandatory
                          )
{
   bool retval = false;

   if (object == NULL)
   {
      if (mandatory) { _com_issue_error(DISP_E_MEMBERNOTFOUND); }
   }
   else
   {
      // Convert name to a BSTR.
      CComBSTR bstrName(name);
      if (!bstrName) { _com_issue_error(E_OUTOFMEMORY); }

      HRESULT hr = object->GetValue(bstrName, value);
      if (SUCCEEDED(hr))
      {
         if (V_VT(value) != vt)
         {
            VariantClear(value);

            _com_issue_error(DISP_E_TYPEMISMATCH);
         }

         retval = true;
      }
      else if (hr == DISP_E_MEMBERNOTFOUND)
      {
         if (mandatory)
         {
            _com_issue_error(DISP_E_MEMBERNOTFOUND);
         }
      }
      else
      {
         _com_issue_error(hr);
      }
   }

   return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\dsobj.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    dsobj.h
//
// SYNOPSIS
//
//    Declares the class DataStoreObject.
//
// MODIFICATION HISTORY
//
//    02/12/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef DSOBJ_H
#define DSOBJ_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <datastore2.h>

_COM_SMARTPTR_TYPEDEF(IDataStoreObject, __uuidof(IDataStoreObject));
_COM_SMARTPTR_TYPEDEF(IDataStoreContainer, __uuidof(IDataStoreContainer));
_COM_SMARTPTR_TYPEDEF(IDataStoreProperty, __uuidof(IDataStoreProperty));

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    DataStoreObject
//
// DESCRIPTION
//
//    Provides a read-only wrapper around IDataStoreObject and
//    IDataStoreContainer.
//
///////////////////////////////////////////////////////////////////////////////
class DataStoreObject
{
public:
   DataStoreObject() throw ();
   DataStoreObject(IUnknown* pUnk, PCWSTR path = NULL);
   ~DataStoreObject() throw ();

   //////////
   // Methods for reading mandatory and optional properties.
   //////////

   void getValue(PCWSTR name, BSTR* value);
   void getValue(PCWSTR name, BSTR* value, BSTR defaultValue);

   void getValue(PCWSTR name, ULONG* value);
   void getValue(PCWSTR name, ULONG* value, ULONG defaultValue);

   void getValue(PCWSTR name, bool* value);
   void getValue(PCWSTR name, bool* value, bool defaultValue);

   //////////
   // Methods for iterating through the children.
   //////////

   LONG numChildren();
   bool nextChild(DataStoreObject& obj);

   // Returns true if the embedded in IDataStoreObject is NULL.
   bool empty() const throw ();

private:
   void attach(IDataStoreObject* obj) throw ();

   bool getChild(PCWSTR name, DataStoreObject& obj);

   bool hasChildren();

   bool getValue(
            PCWSTR name,
            VARTYPE vt,
            VARIANT* value,
            bool mandatory
            );

   IDataStoreObjectPtr object;
   IDataStoreContainerPtr container;
   IEnumVARIANTPtr children;
};

#endif // DSOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\iascache.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iascache.h
//
// SYNOPSIS
//
//    Declares the classes for creating hash tables and caches.
//
// MODIFICATION HISTORY
//
//    02/07/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef IASCACHE_H
#define IASCACHE_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <iasobj.h>
#include <iaswin32.h>

class HashTableBase;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    HashTableEntry
//
// DESCRIPTION
//
//    Abstract base class for objects that will be stored in a hash table.
//
///////////////////////////////////////////////////////////////////////////////
class HashTableEntry
{
public:
   virtual void AddRef() throw () = 0;
   virtual void Release() throw () = 0;

   virtual const void* getKey() const throw () = 0;

   virtual bool matches(const void* key) const throw () = 0;

   friend class HashTableBase;

protected:
   HashTableEntry* next;

   virtual ~HashTableEntry() throw ();
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    HashTableBase
//
// DESCRIPTION
//
//    Implements a simple hash table.
//
///////////////////////////////////////////////////////////////////////////////
class HashTableBase
{
public:
   // Entry type.
   typedef HashTableEntry Entry;

   typedef ULONG (WINAPI *HashKey)(const void*) throw ();


   HashTableBase(
       HashKey hashFunction,
       ULONG initialSize
       );
   ~HashTableBase() throw ();

   // Erases all entries from the table.
   void clear() throw ();

   // Removes and releases the entry matching key. Returns true if successful.
   bool erase(const void* key) throw ();

   // Returns the entry with the given key or null if no such entry exists. The
   // caller is responsible for releasing the returned entry.
   HashTableEntry* find(const void* key) throw ();

   // Insert a new entry in the cache. Returns 'true' if the entry was
   // successfully inserted. Note: this operation can only fail if
   // checkForDuplicates is true and the entry already exists.
   bool insert(
            HashTableEntry& entry,
            bool checkForDuplicates = true
            ) throw ();

   // Removes and returns the entry with the given key or null if no such entry
   // exists. The caller is responsible for releasing the returned entry.
   HashTableEntry* remove(const void* key) throw ();

   // Resize the hash table to have newSize buckets. Returns true if
   // successful.
   bool resize(ULONG newSize) throw ();

protected:
   void lock() throw ()
   { monitor.lock(); }
   void unlock() throw ()
   { monitor.unlock(); }

   HashTableEntry* bucketAsEntry(size_t bucket) throw ()
   { return (HashTableEntry*)(table + bucket); }

   typedef HashTableEntry* Bucket;

   HashKey hash;             // Hash function for hashing keys.
   Bucket* table;            // Hash table of entries.
   ULONG buckets;            // Number of buckets in the table.
   ULONG entries;            // Number of entries in the table.
   CriticalSection monitor;  // Synchronizes access to the table.

   // Not implemented.
   HashTableBase(const HashTableBase&) throw ();
   HashTableBase& operator=(const HashTableBase&) throw ();
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    HashTable<T>
//
// DESCRIPTION
//
//    Provides a type safe wrapper around HashTableBase.
//
///////////////////////////////////////////////////////////////////////////////
template <class K, class T>
class HashTable : public HashTableBase
{
public:

   HashTable(
       HashKey hashFunction,
       ULONG initialSize
       ) throw ()
      : HashTableBase(hashFunction, initialSize)
   { }

   bool erase(const K& key) throw ()
   { return HashTableBase::erase(&key); }

   bool erase(const T& value) throw ()
   { return HashTableBase::erase(value.getKey()); }

   ObjectPointer<T> find(const K& key) throw ()
   { return ObjectPointer<T>(narrow(HashTableBase::find(&key)), false); }

   bool insert(
            T& entry,
            bool checkForDuplicates = true
            ) throw ()
   { return HashTableBase::insert(entry, checkForDuplicates); }

   ObjectPointer<T> remove(const K& key) throw ()
   { return ObjectPointer<T>(narrow(HashTableBase::remove(&key)), false); }

protected:
   static T* narrow(HashTableBase::Entry* entry) throw ()
   { return entry ? static_cast<T*>(entry) : NULL; }
};
class CacheBase;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    CacheEntry
//
// DESCRIPTION
//
//    Abstract base class for objects that will be stored in a cache.
//
///////////////////////////////////////////////////////////////////////////////
class CacheEntry : public HashTableEntry
{
public:
   // Methods for traversing the doubly-linked list.
   CacheEntry* prevInList() const throw ();
   CacheEntry* nextInList() const throw ();

protected:
   friend class CacheBase;

   // Removes the node from the list.
   void removeFromList() throw ();

   // Methods for manipulating the expiration time.
   bool isExpired(const ULONG64& now) const throw ();
   bool isExpired() const throw ();
   void setExpiry(ULONG64 ttl) throw ();

   CacheEntry* flink;  // Allows this to be an entry in a doubly-linked list.
   CacheEntry* blink;
   ULONG64 expiry;     // Expiration time.
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    CacheBase
//
// DESCRIPTION
//
//    Extends HashTableBase to add support for LRU and TTL based eviction.
//
///////////////////////////////////////////////////////////////////////////////
class CacheBase : protected HashTableBase
{
public:
   // Entry type
   typedef CacheEntry Entry;

   CacheBase(
       HashKey hashFunction,
       ULONG initialSize,
       ULONG maxCapacity,
       ULONG timeToLive,
       bool updateExpiryOnFind
       );
   ~CacheBase() throw ();

   // Erases all entries from the cache.
   void clear() throw ();

   // Removes and releases the entry matching key. Returns true if successful.
   bool erase(const void* key) throw ();

   // Evict any eligible entries. Returns the number of entries evicted.
   ULONG evict() throw ();

   // Returns the entry with the given key or null if no such entry exists. The
   // caller is responsible for releasing the returned entry.
   CacheEntry* find(const void* key) throw ();

   // Insert a new entry in the cache. Returns 'true' if the entry was
   // successfully inserted. Note: this operation can only fail if
   // checkForDuplicates is true and the entry already exists.
   bool insert(
            CacheEntry& entry,
            bool checkForDuplicates = true
            ) throw ();

   // Removes and returns the entry with the given key or null if no such entry
   // exists. The caller is responsible for releasing the returned entry.
   CacheEntry* remove(const void* key) throw ();

   //////////
   // iterator for traversing the cache entries.
   //////////
   class iterator
   {
   public:
      iterator() throw () {}

      iterator(CacheEntry* entry) throw () : p(entry) { }

      CacheEntry& operator*() const throw ()
      { return *p; }

      CacheEntry* operator->() const throw ()
      { return p; }

      iterator& operator++() throw ()
      { p = p->nextInList(); return *this; }

      iterator operator++(int) throw ()
      { iterator tmp = *this; ++*this; return tmp; }

      iterator& operator--() throw ()
      { p = p->prevInList(); return *this; }

      iterator operator--(int) throw ()
      { iterator tmp = *this; --*this; return tmp; }

      bool operator==(const iterator& i) const throw ()
      { return p == i.p; }

      bool operator!=(const iterator& i) const throw ()
      { return p != i.p; }

   protected:
      CacheEntry* p;
   };

   // Iterators for traversing the cache from most to least recently used.
   iterator begin() const throw ()
   { return flink; }
   iterator end() const throw ()
   { return listAsEntry(); }

protected:
   CacheEntry* flink;   // Doubly-linked list of entries.
   CacheEntry* blink;
   ULONG64 ttl;         // Time-to-live of cache entries.
   ULONG maxEntries;    // Max number of entries in the cache.
   bool autoUpdate;     // true if TTL should be updated in find.

   // Evict an eligible entries without grabbing the lock.
   void unsafe_evict() throw ();

   // Remove an entry without grabbing the lock.
   CacheEntry* unsafe_remove(const void* key) throw ();

   // Returns the list as if it were a CacheEntry.
   CacheEntry* listAsEntry() const throw ()
   {
      return (CacheEntry*)
         ((ULONG_PTR)&flink - FIELD_OFFSET(CacheEntry, flink));
   }

   // Add an entry to the front of the LRU list (i.e., it is the most recently
   // used entry.
   void push_front(CacheEntry* entry) throw ();
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Cache<T>
//
// DESCRIPTION
//
//    Provides a type safe wrapper around CacheBase.
//
///////////////////////////////////////////////////////////////////////////////
template <class K, class T>
class Cache : public CacheBase
{
public:

   Cache(
       HashKey hashFunction,
       ULONG initialSize,
       ULONG maxCapacity,
       ULONG timeToLive,
       bool updateExpiryOnFind
       ) throw ()
      : CacheBase(
           hashFunction,
           initialSize,
           maxCapacity,
           timeToLive,
           updateExpiryOnFind
           )
   { }

   bool erase(const K& key) throw ()
   { return CacheBase::erase(&key); }

   bool erase(const T& value) throw ()
   { return CacheBase::erase(value.getKey()); }

   ObjectPointer<T> find(const K& key) throw ()
   { return ObjectPointer<T>(narrow(CacheBase::find(&key)), false); }

   bool insert(
            T& entry,
            bool checkForDuplicates = true
            ) throw ()
   { return CacheBase::insert(entry, checkForDuplicates); }

   ObjectPointer<T> remove(const K& key) throw ()
   { return ObjectPointer<T>(narrow(CacheBase::remove(&key)), false); }

protected:
   static T* narrow(CacheBase::Entry* entry) throw ()
   { return entry ? static_cast<T*>(entry) : NULL; }
};

#endif // IASCACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\iasobj.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasobj.h
//
// SYNOPSIS
//
//    Declares the classes ObjectPointer and ObjectVector for manipulating
//    reference counted objects.
//
// MODIFICATION HISTORY
//
//    02/08/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef IASOBJ_H
#define IASOBJ_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <iaswin32.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ObjectPointer<T>
//
// DESCRIPTION
//
//    Smart pointer to a reference counted object. This is useful because it
//    doesn't require the object to derive from IUnknown like the ATL or VC
//    smart pointers.
//
///////////////////////////////////////////////////////////////////////////////
template <class T>
class ObjectPointer
{
public:
   ObjectPointer() throw ()
      : p(NULL)
   { }

   ObjectPointer(T* lp, bool addRef = true) throw ()
      : p(lp)
   { if (addRef) _addref(); }

   ObjectPointer(const ObjectPointer& lp) throw ()
      : p(lp.p)
   { _addref(); }

   T* operator=(T* lp) throw ()
   {
      attach(lp);
      return p;
   }

   ObjectPointer& operator=(const ObjectPointer& lp) throw ()
   {
      if (this != &lp) attach(lp.p);
      return *this;
   }

   ~ObjectPointer() throw ()
   { _release(); }

   operator T*() const throw ()
   { return p; }

   T* operator->() const throw ()
   { return p; }

   T& operator*() const throw ()
   { return *p; }

   bool operator!() const throw ()
   { return p == NULL; }

   void attach(T* lp) throw ()
   {
      _release();
      p = lp;
      _addref();
   }

   void release() throw ()
   {
      _release();
      p = NULL;
   }

private:
   // Safe versions of AddRef and Release.
   void _addref() throw ()
   { if (p) { p->AddRef(); } }
   void _release() throw ()
   { if (p) { p->Release(); } }

   T* p;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ObjectVector<T>
//
// DESCRIPTION
//
//    Maintains an array of reference counted objects.
//
///////////////////////////////////////////////////////////////////////////////
template <class T>
class ObjectVector
{
public:
   typedef T* const* iterator;

   typedef int (__cdecl *SortFn)(
                             const T* const* t1,
                             const T* const* t2
                             ) throw ();

   typedef int (__cdecl *SearchFn)(
                             const void* key,
                             const T* const* t
                             ) throw ();

   ObjectVector() throw ()
      : first(NULL), last(NULL), cap(NULL)
   { }

   ObjectVector(const ObjectVector& v)
      : first(NULL), last(NULL), cap(NULL)
   { assign(v.begin(), v.end()); }

   ObjectVector(iterator first, iterator last)
      : first(NULL), last(NULL), cap(NULL)
   { assign(first, last); }

   ObjectVector(size_t nelem)
      : first(NULL), last(NULL), cap(NULL)
   { reserve(nelem); }

   ObjectVector& operator=(const ObjectVector& v)
   {
      if (this != &v) { assign(v.begin(), v.end()); }
      return *this;
   }

   ~ObjectVector() throw ()
   {
      clear();
      delete[] first;
   }

   void assign(iterator i1, iterator i2)
   {
      reserve(i2 - i1);
      clear();
      for (iterator i = i1; i != i2; ++i)
      { (*last++ = *i)->AddRef(); }
   }

   // Returns the capacity of the array.
   size_t capacity() const throw ()
   { return cap - first; }

   void clear() throw ()
   { while (last > first) (*--last)->Release(); }

   bool contains(T* elem) throw ()
   { return find(elem) != last; }

   bool empty() const throw ()
   { return last == first; }

   iterator erase(iterator i) throw ()
   {
      memmove((void*)i, (void*)(i + 1), (--last - i) * sizeof(T*));
      return i;
   }

   iterator find(T* elem) throw ()
   {
      for (iterator i = first; i != last && *i != elem; ++i) { }
      return i;
   }

   void push_back(T* elem) throw ()
   {
      if (last == cap) { reserve(empty() ? 1 : capacity() * 2); }
      (*last++ = elem)->AddRef();
   }

   bool remove(T* elem) throw ()
   {
      iterator i = find(elem);
      if (i == last) { return false; }
      (*i)->Release();
      return true;
   }

   void reserve(size_t nelem)
   {
      if (nelem > capacity())
      {
         T** t = new T*[nelem];
         memcpy(t, first, size() * sizeof(T*));
         last = t + size();
         cap = t + nelem;
         delete[] first;
         first = t;
      }
   }

   T* search(const void* key, SearchFn pfn) const throw ()
   {
      T** t = (T**)bsearch(key, begin(), size(), sizeof(T*), (CompFn)pfn);
      return t ? *t : NULL;
   }

   size_t size() const throw ()
   { return last - first; }

   void sort(SortFn pfn) throw ()
   { qsort((void*)begin(), size(), sizeof(T*), (CompFn)pfn); }

   void swap(ObjectVector& v) throw ()
   {
      T** firstTmp = first;
      T** lastTmp = last;
      T** capTmp = cap;
      first = v.first;
      last = v.last;
      cap = v.cap;
      v.first = firstTmp;
      v.last = lastTmp;
      v.cap = capTmp;
   }

   // Methods to iterate the array elements.
   iterator begin() const throw ()
   { return first; }
   iterator end() const throw ()
   { return last; }

   T* operator[](size_t index) const throw ()
   { return first[index]; }

private:
   typedef int (__cdecl *CompFn)(const void*, const void*);

   T** first;
   T** last;
   T** cap;
};

#endif // IASOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\proxy.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    Declares the class RadiusProxy.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef PROXY_H
#define PROXY_H
#pragma once

#define IDS_RadiusProxy 201

#include <radproxy.h>
#include <counters.h>
#include <translate.h>

#include <iastl.h>
#include <iastlutl.h>
using namespace IASTL;

class DataStoreObject;
class Resolver;

class __declspec(uuid("6BC0989F-0CE6-11D1-BAAE-00C04FC2E20D")) RadiusProxy;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    RadiusProxy
//
// DESCRIPTION
//
//    Implements the RadiusProxy request handler.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE RadiusProxy :
   public IASTL::IASRequestHandler,
   public CComCoClass<RadiusProxy, &__uuidof(RadiusProxy)>,
   public RadiusProxyClient
{
public:
IAS_DECLARE_REGISTRY(RadiusProxy, 1, IAS_REGISTRY_AUTO, IASTypeLibrary)

   RadiusProxy();
   ~RadiusProxy() throw ();

   HRESULT FinalConstruct() throw ();

   STDMETHOD(PutProperty)(LONG Id, VARIANT* pValue);

   // RadiusProxyClient methods.
   virtual void onEvent(
                    const RadiusEvent& event
                    ) throw ();
   virtual void onComplete(
                   RadiusProxyEngine::Result result,
                   PVOID context,
                   RemoteServer* server,
                   BYTE code,
                   const RadiusAttribute* begin,
                   const RadiusAttribute* end
                   ) throw ();

protected:

   // Receives requests from the pipeline.
   void onAsyncRequest(IRequest* pRequest) throw ();

   // Update configuration.
   void configure(IUnknown* unk);

   // Read the configuration for a single server in a group.
   void configureServer(
           const Resolver& localAddress,
           const wchar_t* groupName,
           DataStoreObject& inServer,
           RemoteServers& outServers
           );

   // Default vector for retrieving attributes.
   typedef IASAttributeVectorWithBuffer<32> AttributeVector;
   typedef AttributeVector::iterator AttributeIterator;

   Translator translator;    // Converts attributes to RADIUS format.
   RadiusProxyEngine engine; // The actual proxy code.
   ProxyCounters counters;   // Maintains the PerfMon/SNMP counters.
   DWORD maxServerGroups;    // Maximum number of server groups allowed.

   // Not implemented.
   RadiusProxy(const RadiusProxy&);
   RadiusProxy& operator=(const RadiusProxy&);
};

#endif  // PROXY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\proxy.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//    Defines the class RadiusProxy.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <datastore2.h>
#include <proxy.h>
#include <radpack.h>
#include <iasevent.h>
#include <iasinfo.h>
#include <iasutil.h>
#include <dsobj.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Resolver
//
// DESCRIPTION
//
//    Utility class for resolving hostnames and iterating through the results.
//
///////////////////////////////////////////////////////////////////////////////
class Resolver
{
public:
   Resolver() throw ()
      : first(NULL), last(NULL)
   { }

   ~Resolver() throw ()
   { if (first != &addr) delete[] first; }

   // Returns true if the result set contains the specified address.
   bool contains(ULONG address) const throw ()
   {
      for (const ULONG* i = first; i != last; ++i)
      {
         if (*i == address) { return true; }
      }

      return false;
   }

   // Resolves the given name. The return value is the error code.
   ULONG resolve(const PCWSTR name = NULL) throw ()
   {
      // Clear out the existing result set.
      if (first != &addr)
      {
         delete[] first;
         first = last = NULL;
      }

      if (name)
      {
         // First try for a quick score on dotted decimal.
         addr = ias_inet_wtoh(name);
         if (addr != INADDR_NONE)
         {
            addr = htonl(addr);
            first = &addr;
            last = first + 1;
            return NO_ERROR;
         }
      }

      // That didn't work, so look up the name.
      PHOSTENT he = IASGetHostByName(name);
      if (!he) { return GetLastError(); }

      // Count the number of addresses returned.
      ULONG naddr = 0;
      while (he->h_addr_list[naddr]) { ++naddr; }

      // Allocate an array to hold them.
      first = last = new (std::nothrow) ULONG[naddr];
      if (first)
      {
         for (ULONG i = 0; i < naddr; ++i)
         {
            *last++ = *(PULONG)he->h_addr_list[i];
         }
      }

      LocalFree(he);

      return first ? NO_ERROR : WSA_NOT_ENOUGH_MEMORY;
   }

   const ULONG* begin() const throw ()
   { return first; }

   const ULONG* end() const throw ()
   { return last; }

private:
   ULONG addr, *first, *last;

   // Not implemented.
   Resolver(const Resolver&);
   Resolver& operator=(const Resolver&);
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IASRemoteServer
//
// DESCRIPTION
//
//    Extends RemoteServer to add IAS specific server information.
//
///////////////////////////////////////////////////////////////////////////////
class IASRemoteServer : public RemoteServer
{
public:
   IASRemoteServer(
       const RemoteServerConfig& config,
       RadiusRemoteServerEntry* entry
       )
      : RemoteServer(config),
        counters(entry)
   {
      // Create the Remote-Server-Address attribute.
      IASAttribute name(true);
      name->dwId = IAS_ATTRIBUTE_REMOTE_SERVER_ADDRESS;
      name->Value.itType = IASTYPE_INET_ADDR;
      name->Value.InetAddr = ntohl(config.ipAddress);
      attrs.push_back(name);

      // Update our PerfMon entry.
      if (counters)
      {
         counters->dwCounters[radiusAuthClientServerPortNumber] =
            ntohs(config.authPort);
         counters->dwCounters[radiusAccClientServerPortNumber] =
            ntohs(config.acctPort);
      }
   }

   // Attributes to be added to each request.
   IASAttributeVectorWithBuffer<1> attrs;

   // PerfMon counters.
   RadiusRemoteServerEntry* counters;
};

RadiusProxy::RadiusProxy()
   : engine(this)
{
}

RadiusProxy::~RadiusProxy() throw ()
{
}

HRESULT RadiusProxy::FinalConstruct() throw ()
{
   IAS_PRODUCT_LIMITS limits;
   DWORD error = IASGetProductLimits(0, &limits);
   if (error != NO_ERROR)
   {
      return HRESULT_FROM_WIN32(error);
   }
   maxServerGroups = limits.maxServerGroups;

   HRESULT hr = counters.FinalConstruct();
   if (SUCCEEDED(hr))
   {
      hr = translator.FinalConstruct();
      if (SUCCEEDED(hr))
      {
         hr = engine.finalConstruct();
      }
   }

   return hr;
}

STDMETHODIMP RadiusProxy::PutProperty(LONG Id, VARIANT* pValue)
{
   if (pValue == NULL) { return E_INVALIDARG; }

   HRESULT hr;
   switch (Id)
   {
      case PROPERTY_RADIUSPROXY_SERVERGROUPS:
      {
         if (V_VT(pValue) != VT_DISPATCH) { return DISP_E_TYPEMISMATCH; }

         try
         {
            configure(V_UNKNOWN(pValue));
            hr = S_OK;
         }
         catch (const _com_error& ce)
         {
            hr = ce.Error();
         }
         break;
      }
      default:
      {
         hr = DISP_E_MEMBERNOTFOUND;
      }
   }

   return hr;
}

void RadiusProxy::onEvent(
                      const RadiusEvent& event
                      ) throw ()
{
   // Convert the event context to an IASRemoteServer.
   IASRemoteServer* server = static_cast<IASRemoteServer*>(event.context);

   // Update the counters.
   counters.updateCounters(
                event.portType,
                event.eventType,
                (server ? server->counters : NULL),
                event.data
                );

   // We always use the address as an insertion string.
   WCHAR addr[16], misc[16];
   ias_inet_htow(ntohl(event.ipAddress), addr);

   // Set up the default parameters for event reporting.
   DWORD eventID = 0;
   DWORD numStrings = 1;
   DWORD dataSize = 0;
   PCWSTR strings[2] = { addr, misc };
   const void* rawData = NULL;

   // Map the RADIUS event to an IAS event ID.
   switch (event.eventType)
   {
      case eventInvalidAddress:
         eventID = PROXY_E_INVALID_ADDRESS;
         _itow(ntohs(event.ipPort), misc, 10);
         numStrings = 2;
         break;

      case eventMalformedPacket:
         eventID = PROXY_E_MALFORMED_RESPONSE;
         dataSize = event.packetLength;
         rawData = event.packet;
         break;

      case eventBadAuthenticator:
         eventID = PROXY_E_BAD_AUTHENTICATOR;
         break;

      case eventBadSignature:
         eventID = PROXY_E_BAD_SIGNATURE;
         break;

      case eventMissingSignature:
         eventID = PROXY_E_MISSING_SIGNATURE;
         break;

      case eventUnknownType:
         eventID = PROXY_E_UNKNOWN_TYPE;
         _itow(event.packet[0], misc, 10);
         numStrings = 2;
         break;

      case eventUnexpectedResponse:
         eventID = PROXY_E_UNEXPECTED_RESPONSE;
         dataSize = event.packetLength;
         rawData = event.packet;
         break;

      case eventSendError:
         eventID = PROXY_E_SEND_ERROR;
         _itow(event.data, misc, 10);
         numStrings = 2;
         break;

      case eventReceiveError:
         eventID = PROXY_E_RECV_ERROR;
         _itow(event.data, misc, 10);
         numStrings = 2;
         break;

      case eventServerAvailable:
         eventID = PROXY_S_SERVER_AVAILABLE;
         break;

      case eventServerUnavailable:
         eventID = PROXY_E_SERVER_UNAVAILABLE;
         _itow(server->maxEvents, misc, 10);
         numStrings = 2;
         break;
   }

   if (eventID)
   {
      IASReportEvent(
          eventID,
          numStrings,
          dataSize,
          strings,
          (void*)rawData
          );
   }
}

void RadiusProxy::onComplete(
                      RadiusProxyEngine::Result result,
                      PVOID context,
                      RemoteServer* server,
                      BYTE code,
                      const RadiusAttribute* begin,
                      const RadiusAttribute* end
                      ) throw ()
{
   IRequest* comreq = (IRequest*)context;

   IASRESPONSE response = IAS_RESPONSE_DISCARD_PACKET;

   // Map the result to a reason code.
   IASREASON reason;
   switch (result)
   {
      case RadiusProxyEngine::resultSuccess:
         reason = IAS_SUCCESS;
         break;

      case RadiusProxyEngine::resultNotEnoughMemory:
         reason = IAS_INTERNAL_ERROR;
         break;

      case RadiusProxyEngine::resultUnknownServerGroup:
         reason = IAS_PROXY_UNKNOWN_GROUP;
         break;

      case RadiusProxyEngine::resultUnknownServer:
         reason = IAS_PROXY_UNKNOWN_SERVER;
         break;

      case RadiusProxyEngine::resultInvalidRequest:
         reason = IAS_PROXY_PACKET_TOO_LONG;
         break;

      case RadiusProxyEngine::resultSendError:
         reason = IAS_PROXY_SEND_ERROR;
         break;

      case RadiusProxyEngine::resultRequestTimeout:
         reason = IAS_PROXY_TIMEOUT;
         break;

      case RadiusProxyEngine::resultCryptoError:
         reason = IAS_INTERNAL_ERROR;
         break;

      default:
         reason = IAS_INTERNAL_ERROR;
   }

   try
   {
      IASRequest request(comreq);

      // Always store the server attributes if available.
      if (server)
      {
         static_cast<IASRemoteServer*>(server)->attrs.store(request);
      }

      if (reason == IAS_SUCCESS)
      {
         // Set the response code and determine the flags used for returned
         // attributes.
         DWORD flags = 0;
         switch (code)
         {
            case RADIUS_ACCESS_ACCEPT:
            {
               response = IAS_RESPONSE_ACCESS_ACCEPT;
               flags = IAS_INCLUDE_IN_ACCEPT;
               break;
            }

            case RADIUS_ACCESS_REJECT:
            {
               response = IAS_RESPONSE_ACCESS_REJECT;
               reason = IAS_PROXY_REJECT;
               flags = IAS_INCLUDE_IN_REJECT;
               break;
            }

            case RADIUS_ACCESS_CHALLENGE:
            {
               response = IAS_RESPONSE_ACCESS_CHALLENGE;
               flags = IAS_INCLUDE_IN_CHALLENGE;
               break;
            }

            case RADIUS_ACCOUNTING_RESPONSE:
            {
               response = IAS_RESPONSE_ACCOUNTING;
               flags = IAS_INCLUDE_IN_ACCEPT;
               break;
            }

            default:
            {
               // The RadiusProxyEngine should never do this.
               _com_issue_error(E_FAIL);
            }
         }

         // Convert the received attributes to IAS format.
         AttributeVector incoming;
         for (const RadiusAttribute* src = begin; src != end; ++src)
         {
            // Temporary hack to workaround bug in the protocol.
            if (src->type != RADIUS_SIGNATURE)
            {
               translator.fromRadius(*src, flags, incoming);
            }
         }

         if (!incoming.empty())
         {
            // Get the existing attributes.
            AttributeVector existing;
            existing.load(request);

            // Erase any attributes that are already in the request.
            AttributeIterator i, j;
            for (i = existing.begin(); i != existing.end(); ++i)
            {
               // Both the flags ...
               if (i->pAttribute->dwFlags & flags)
               {
                  for (j = incoming.begin(); j != incoming.end(); )
                  {
                     // ... and the ID have to match.
                     if (j->pAttribute->dwId == i->pAttribute->dwId)
                     {
                        j = incoming.erase(j);
                     }
                     else
                     {
                        ++j;
                     }
                  }
               }
            }

            // Store the remaining attributes.
            incoming.store(request);
         }
      }
   }
   catch (const _com_error& ce)
   {
      response = IAS_RESPONSE_DISCARD_PACKET;

      if (ce.Error() == E_INVALIDARG)
      {
         // We must have had an error translating from RADIUS to IAS format.
         reason = IAS_PROXY_MALFORMED_RESPONSE;
      }
      else
      {
         // Probably memory allocation.
         reason = IAS_INTERNAL_ERROR;
      }
   }

   // Give it back to the pipeline.
   comreq->SetResponse(response, reason);
   comreq->ReturnToSource(IAS_REQUEST_STATUS_HANDLED);

   // This balances the AddRef we did before calling forwardRequest.
   comreq->Release();
}

void RadiusProxy::onAsyncRequest(IRequest* pRequest) throw ()
{
   try
   {
      IASRequest request(pRequest);

      // Set the packet code based on the request type.
      BYTE packetCode;
      switch (request.get_Request())
      {
         case IAS_REQUEST_ACCESS_REQUEST:
         {
            packetCode = RADIUS_ACCESS_REQUEST;
            break;
         }

         case IAS_REQUEST_ACCOUNTING:
         {
            packetCode = RADIUS_ACCOUNTING_REQUEST;
            break;
         }

         default:
         {
            // The pipeline should never give us a request of the wrong type.
            _com_issue_error(E_FAIL);
         }
      }

      // Get the attributes from the request.
      AttributeVector all, outgoing;
      all.load(request);

      for (AttributeIterator i = all.begin(); i != all.end(); ++i)
      {
         // Send all the attributes received from the client except Proxy-State.
         if (i->pAttribute->dwFlags & IAS_RECVD_FROM_CLIENT &&
             i->pAttribute->dwId != RADIUS_ATTRIBUTE_PROXY_STATE)
            {
               translator.toRadius(*(i->pAttribute), outgoing);
            }
      }


      // If the request authenticator contains the CHAP challenge:
      // it must be used so get the request authenticator (always to
      // simplify the code)
      PBYTE requestAuthenticator = 0;
      IASAttribute radiusHeader;

      if (radiusHeader.load(
                      request,
                      IAS_ATTRIBUTE_CLIENT_PACKET_HEADER,
                      IASTYPE_OCTET_STRING
                      ))
      {
         requestAuthenticator = radiusHeader->Value.OctetString.lpValue + 4;
      }

      // Allocate an array of RadiusAttributes.
      size_t nbyte = outgoing.size() * sizeof(RadiusAttribute);
      RadiusAttribute* begin = (RadiusAttribute*)_alloca(nbyte);
      RadiusAttribute* end = begin;

      // Load the individual attributes.
      for (AttributeIterator j = outgoing.begin(); j != outgoing.end(); ++j)
      {
         end->type   = (BYTE)(j->pAttribute->dwId);
         end->length = (BYTE)(j->pAttribute->Value.OctetString.dwLength);
         end->value  = j->pAttribute->Value.OctetString.lpValue;

         ++end;
      }

      // Get the RADIUS Server group. This may be NULL since NAS-State bypasses
      // proxy policy.
      PIASATTRIBUTE group = IASPeekAttribute(
                                request,
                                IAS_ATTRIBUTE_PROVIDER_NAME,
                                IASTYPE_STRING
                                );

      // AddRef the request because we're giving it to the engine.
      pRequest->AddRef();

      // Add the request authenticator to the parameters of forwardRequest
      // That can be NULL
      engine.forwardRequest(
                 (PVOID)pRequest,
                 (group ? group->Value.String.pszWide : L""),
                 packetCode,
                 requestAuthenticator,
                 begin,
                 end
                 );
   }
   catch (const _com_error&)
   {
      // We weren't able to forward it to the engine.
      pRequest->SetResponse(IAS_RESPONSE_DISCARD_PACKET, IAS_INTERNAL_ERROR);
      pRequest->ReturnToSource(IAS_REQUEST_STATUS_HANDLED);
   }
}

void RadiusProxy::configure(IUnknown* root)
{
   // Get our IP addresses. We don't care if this fails.
   Resolver localAddress;
   localAddress.resolve();

   // Open the RADIUS Server Groups container. If it's not there, we'll just
   // assume there's nothing to configure.
   DataStoreObject inGroups(
                       root,
                       L"RADIUS Server Groups\0"
                       );
   if (inGroups.empty()) { return; }

   LONG numGroups = inGroups.numChildren();
   if (numGroups > maxServerGroups)
   {
      IASTracePrintf(
         "License Violation: %ld Remote RADIUS Server Groups are "
         "configured, but only %lu are allowed for this product type.",
         numGroups,
         maxServerGroups
         );

      IASReportLicenseViolation();
      _com_issue_error(IAS_E_LICENSE_VIOLATION);
   }

   // Reserve space for each group.
   ServerGroups outGroups(numGroups);

   // Iterate through the groups.
   DataStoreObject inGroup;
   while (inGroups.nextChild(inGroup))
   {
      // Get the group name.
      CComBSTR groupName;
      inGroup.getValue(L"Name", &groupName);

      // Reserve space for each server. This is really a guess since a server
      // may resolve to multiple IP addresses.
      RemoteServers outServers(inGroup.numChildren());

      // Iterate through the servers.
      DataStoreObject inServer;
      while (inGroup.nextChild(inServer))
      {
         configureServer(localAddress, groupName, inServer, outServers);
      }

      // Ignore any empty groups.
      if (outServers.empty()) { continue; }

      // Create the new group.
      ServerGroupPtr outGroup(new ServerGroup(
                                      groupName,
                                      outServers.begin(),
                                      outServers.end()
                                      ));
      outGroups.push_back(outGroup);
   }

   // Wow, we're finally done.
   if (engine.setServerGroups(
              outGroups.begin(),
              outGroups.end()
              ) == false)
   {
      // most likely reason for failure is out of memory error
      _com_issue_error(E_OUTOFMEMORY);
   }
}

void RadiusProxy::configureServer(
                     const Resolver& localAddress,
                     const wchar_t* groupName,
                     DataStoreObject& inServer,
                     RemoteServers& outServers
                     )
{
   USES_CONVERSION;

   // Populate the RemoteServerConfig. It has a lot of fields.
   RemoteServerConfig config;

   CComBSTR name;
   inServer.getValue(L"Name", &name);
   CLSIDFromString(name, &config.guid);

   ULONG port;
   inServer.getValue(L"Server Authentication Port", &port, 1812);
   config.authPort = htons((USHORT)port);

   inServer.getValue(L"Server Accounting Port", &port, 1813);
   config.acctPort = htons((USHORT)port);

   CComBSTR bstrAuth;
   inServer.getValue(L"Authentication Secret", &bstrAuth);
   config.authSecret = W2A(bstrAuth);

   CComBSTR bstrAcct;
   inServer.getValue(L"Accounting Secret", &bstrAcct, bstrAuth);
   config.acctSecret = W2A(bstrAcct);

   inServer.getValue(L"Priority", &config.priority, 1);

   inServer.getValue(L"Weight", &config.weight, 50);
   // Ignore any zero weight servers.
   if (config.weight == 0) { return; }

   // We don't use this feature for now.
   config.sendSignature = false;

   inServer.getValue(
                L"Forward Accounting On/Off",
                &config.sendAcctOnOff,
                true
                );

   inServer.getValue(L"Timeout", &config.timeout, 3);
   // Don't allow zero for timeout
   if (config.timeout == 0) { config.timeout = 1; }

   inServer.getValue(L"Maximum Lost Packets", &config.maxLost, 5);
   // Don't allow zero for maxLost.
   if (config.maxLost == 0) { config.maxLost = 1; }

   inServer.getValue(
                L"Blackout Interval",
                &config.blackout,
                10 * config.timeout
                );
   if (config.blackout < config.timeout)
   {
      // Blackout interval must be >= request timeout.
      config.blackout = config.timeout;
   }

   // These need to be in msec.
   config.timeout *= 1000;
   config.blackout *= 1000;

   // Now we have to resolve the server name to an IP address.
   CComBSTR address;
   inServer.getValue(L"Address", &address);
   Resolver serverAddress;
   ULONG error = serverAddress.resolve(address);
   if (error)
   {
      WCHAR errorCode[16];
      _itow(GetLastError(), errorCode, 10);
      PCWSTR strings[3] = { address, groupName, errorCode };
      IASReportEvent(
         PROXY_E_HOST_NOT_FOUND,
         3,
         0,
         strings,
         NULL
         );
   }

   // Create a server entry for each address.
   for (const ULONG* addr = serverAddress.begin();
        addr != serverAddress.end();
        ++addr)
   {
      // Don't allow them to proxy locally.
      if (localAddress.contains(*addr))
      {
         WCHAR ipAddress[16];
         ias_inet_htow(ntohl(*addr), ipAddress);
         PCWSTR strings[3] = { address, groupName, ipAddress };
         IASReportEvent(
             PROXY_E_LOCAL_SERVER,
             3,
             0,
             strings,
             NULL
             );

         continue;
      }

      // Look up the PerfMon counters.
      RadiusRemoteServerEntry* entry = counters.getRemoteServerEntry(
                                                    *addr
                                                    );

      // Create the new server
      config.ipAddress = *addr;
      RemoteServerPtr outServer(new IASRemoteServer(
                                        config,
                                        entry
                                        ));
      outServers.push_back(outServer);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\iascache.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iascache.cpp
//
// SYNOPSIS
//
//    Defines classes for creating hash tables and caches.
//
// MODIFICATION HISTORY
//
//    02/07/2000    Original version.
//    04/25/2000    Decrement entries when item is removed.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <iascache.h>

///////////////////////////////////////////////////////////////////////////////
//
// HashTableEntry
//
///////////////////////////////////////////////////////////////////////////////

HashTableEntry::~HashTableEntry() throw ()
{ }

///////////////////////////////////////////////////////////////////////////////
//
// HashTableBase
//
///////////////////////////////////////////////////////////////////////////////

HashTableBase::HashTableBase(
                   HashKey hashFunction,
                   ULONG initialSize
                   ) throw ()
   : hash(hashFunction),
     table(NULL),
     buckets(initialSize ? initialSize : 1),
     entries(0)
{
   table = new Bucket[buckets];

   memset(table, 0, buckets * sizeof(Bucket));
}

HashTableBase::~HashTableBase() throw ()
{
   clear();

   delete[] table;
}

void HashTableBase::clear() throw ()
{
   lock();

   Bucket* end = table + buckets;

   // Iterate through the buckets.
   for (Bucket* b = table; b != end; ++b)
   {
      // Iterate through the entries in the bucket.
      for (HashTableEntry* entry = *b; entry; )
      {
         HashTableEntry* next = entry->next;

         entry->Release();

         entry = next;
      }
   }

   // Zero out the table.
   memset(table, 0, buckets * sizeof(Bucket));
   entries = 0;

   unlock();
}

bool HashTableBase::erase(const void* key) throw ()
{
   HashTableEntry* entry = remove(key);

   return entry ? entry->Release(), true : false;
}


HashTableEntry* HashTableBase::find(const void* key) throw ()
{
   HashTableEntry* match = NULL;

   ULONG hashval = hash(key);

   lock();

   for (match = table[hashval % buckets]; match; match = match->next)
   {
      if (match->matches(key))
      {
         match->AddRef();
         break;
      }
   }

   unlock();

   return match;
}

bool HashTableBase::insert(
                    HashTableEntry& entry,
                    bool checkForDuplicates
                    ) throw ()
{
   HashTableEntry* match = NULL;

   // Do what we can before acquiring the lock.
   const void* key = entry.getKey();
   ULONG hashval = hash(key);

   lock();

   // Resize the table to make room.
   if (entries > buckets) { resize(buckets * 2); }

   // Find the bucket.
   Bucket* bucket = table + (hashval % buckets);

   // Do we already have an entry with this key?
   if (checkForDuplicates)
   {
      for (match = *bucket; match; match = match->next)
      {
         if (match->matches(key))
         {
            break;
         }
      }
   }

   if (!match)
   {
      // No, so stick it in the bucket.
      entry.next = *bucket;
      *bucket = &entry;

      entry.AddRef();

      ++entries;
   }

   unlock();

   return match ? false : true;
}

HashTableEntry* HashTableBase::remove(const void* key) throw ()
{
   HashTableEntry* match = NULL;

   ULONG hashval = hash(key);

   lock();

   for (HashTableEntry** entry = table + (hashval % buckets);
        *entry != 0;
        entry = &((*entry)->next))
   {
      if ((*entry)->matches(key))
      {
         match = *entry;
         *entry = match->next;
         --entries;
         break;
      }
   }

   unlock();

   return match;
}

bool HashTableBase::resize(ULONG newSize) throw ()
{
   if (!newSize) { newSize = 1; }

   // Allocate memory for the new table.
   Bucket* newTable = new (std::nothrow) Bucket[newSize];

   // If the allocation failed, there's nothing else we can do.
   if (!newTable) { return false; }

   // Null out the buckets.
   memset(newTable, 0, newSize * sizeof(Bucket));

   lock();

   // Save the old table.
   Bucket* begin = table;
   Bucket* end   = table + buckets;

   // Swap in the new table.
   table   = newTable;
   buckets = newSize;

   // Iterate through the old buckets.
   for (Bucket* oldBucket = begin; oldBucket != end; ++oldBucket)
   {
      // Iterate through the entries in the bucket.
      for (HashTableEntry* entry = *oldBucket; entry; )
      {
         // Save the next entry.
         HashTableEntry* next = entry->next;

         // Get the appropriate bucket.
         Bucket* newBucket = table + (hash(entry->getKey()) % buckets);

         // Add the node to the head of the new bucket.
         entry->next = *newBucket;
         *newBucket = entry;

         // Move on.
         entry = next;
      }
   }

   unlock();

   // Delete the old table.
   delete[] begin;

   return true;
}

///////////////////////////////////////////////////////////////////////////////
//
// CacheEntry
//
///////////////////////////////////////////////////////////////////////////////

inline CacheEntry* CacheEntry::prevInList() const throw ()
{
   return blink;
}

inline CacheEntry* CacheEntry::nextInList() const throw ()
{
   return flink;
}

inline void CacheEntry::removeFromList() throw ()
{
   CacheEntry* oldFlink = flink;
   CacheEntry* oldBlink = blink;

   oldBlink->flink = oldFlink;
   oldFlink->blink = oldBlink;
}

inline bool CacheEntry::isExpired(const ULONG64& now) const throw ()
{
   return now > expiry;
}

inline bool CacheEntry::isExpired() const throw ()
{
   return isExpired(GetSystemTime64());
}

inline void CacheEntry::setExpiry(ULONG64 ttl) throw ()
{
   expiry = GetSystemTime64() + ttl;
}

///////////////////////////////////////////////////////////////////////////////
//
// HashTableBase
//
///////////////////////////////////////////////////////////////////////////////

CacheBase::CacheBase(
               HashKey hashFunction,
               ULONG initialSize,
               ULONG maxCapacity,
               ULONG timeToLive,
               bool updateExpiryOnFind
               ) throw ()
   : HashTableBase(hashFunction, initialSize),
     flink(listAsEntry()), blink(listAsEntry()),
     ttl(timeToLive * 10000i64),
     maxEntries(maxCapacity),
     autoUpdate(updateExpiryOnFind)
{
}

CacheBase::~CacheBase() throw ()
{
   clear();
   buckets = 0;
}

void CacheBase::clear() throw ()
{
   lock();

   // Release all the entries.
   for (iterator i = begin(); i != end(); (i++)->Release()) { }

   // Reset the LRU list.
   flink = blink = listAsEntry();

   // Reset the hash table.
   memset(table, 0, sizeof(Bucket) * buckets);

   // There's nothing left.
   entries = 0;

   unlock();
}

ULONG CacheBase::evict() throw ()
{
   lock();

   ULONG retval = entries;

   unsafe_evict();

   retval = entries - retval;

   unlock();

   return retval;
}

bool CacheBase::erase(const void* key) throw ()
{
   CacheEntry* entry = remove(key);

   return entry ? entry->Release(), true : false;
}

CacheEntry* CacheBase::find(const void* key) throw ()
{
   lock();

   unsafe_evict();

   // Look it up in the hash table.
   CacheEntry* entry = static_cast<CacheEntry*>(HashTableBase::find(key));

   if ((entry != 0) && autoUpdate)
   {
      // Whenever someone reads an entry, we reset the TTL.
      entry->setExpiry(ttl);

      entry->removeFromList();

      push_front(entry);
   }

   unlock();

   return entry;
}

bool CacheBase::insert(
                    CacheEntry& entry,
                    bool checkForDuplicates
                    ) throw ()
{
   lock();

   unsafe_evict();

   bool added = HashTableBase::insert(entry, checkForDuplicates);

   if (added)
   {
      entry.setExpiry(ttl);

      push_front(&entry);
   }

   unlock();

   return added;
}

CacheEntry* CacheBase::remove(const void* key) throw ()
{
   lock();

   CacheEntry* entry = unsafe_remove(key);

   unlock();

   return entry;
}

void CacheBase::unsafe_evict() throw ()
{
   while (entries > maxEntries )
   {
      unsafe_remove(blink->getKey())->Release();
   }

   while (entries && blink->isExpired())
   {
      unsafe_remove(blink->getKey())->Release();
   }
}

CacheEntry* CacheBase::unsafe_remove(const void* key) throw ()
{
   CacheEntry* entry = static_cast<CacheEntry*>(HashTableBase::remove(key));

   if (entry)
   {
      entry->removeFromList();
   }

   return entry;
}

void CacheBase::push_front(CacheEntry* entry) throw ()
{
   CacheEntry* listHead = listAsEntry();
   CacheEntry* oldFlink = listHead->flink;

   entry->flink = oldFlink;
   entry->blink = listHead;

   oldFlink->blink = entry;
   listHead->flink = entry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\proxypch.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//
//
// SYNOPSIS
//
//
//
// MODIFICATION HISTORY
//
//    00/00/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef PROXYPCH_H
#define PROXYPCH_H

#pragma once

#include <ias.h>
#include <new>
#include <radpack.h>
#include <radshare.h>
#include <radproxyp.h>
#include <radproxy.h>

#endif // PROXYPCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\iaswin32.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iaswin32.h
//
// SYNOPSIS
//
//    Declares wrappers around a variety of Win32 objects.
//
// MODIFICATION HISTORY
//
//    02/10/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef IASWIN32_H
#define IASWIN32_H
#if _MSC_VER >= 1000
#pragma once
#endif

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    CriticalSection
//
///////////////////////////////////////////////////////////////////////////////
class CriticalSection
{
public:
   CriticalSection()
   {
      if (!InitializeCriticalSectionAndSpinCount(&cs, 0x80001000))
      { throw std::bad_alloc(); }
   }

   ~CriticalSection()
   { DeleteCriticalSection(&cs); }

   void lock() throw ()
   { EnterCriticalSection(&cs); }

   void unlock() throw ()
   { LeaveCriticalSection(&cs); }

   bool tryLock() throw ()
   { return TryEnterCriticalSection(&cs) != FALSE; }

private:
   CRITICAL_SECTION cs;

   // Not implemented.
   CriticalSection(const CriticalSection&);
   CriticalSection& operator=(const CriticalSection&);
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Event
//
///////////////////////////////////////////////////////////////////////////////
class Event
{
public:
   Event(BOOL manualReset = FALSE, BOOL initialState = FALSE)
      : h(CreateEvent(NULL, manualReset, initialState, NULL))
   { if (!h) { throw std::bad_alloc(); } }

   ~Event() throw ()
   { CloseHandle(h); }

   void reset() throw ()
   { ResetEvent(h); }

   void set() throw ()
   { SetEvent(h); }

   void wait(ULONG msec = INFINITE) throw ()
   { WaitForSingleObject(h, msec); }

   operator HANDLE() throw ()
   { return h; }

private:
   HANDLE h;

   // Not implemented.
   Event(const Event&);
   Event& operator=(const Event&);
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    RWLock
//
// DESCRIPTION
//
//    This class implements a RWLock synchronization object.  Threads
//    may request either exclusive or shared access to the protected area.
//
///////////////////////////////////////////////////////////////////////////////
class RWLock
{
public:
   RWLock();
   ~RWLock() throw ();

   void Lock() const throw ();
   void LockExclusive() throw ();
   void Unlock() const throw ();

protected:
   // Number of threads sharing the perimeter.
   mutable LONG sharing;

   // Number of threads waiting for shared access.
   LONG waiting;

   // Pointer to either sharing or waiting depending on the current state of
   // the perimeter.
   PLONG count;

   // Synchronizes exclusive access.
   mutable CRITICAL_SECTION exclusive;

   // Wakes up threads waiting for shared access.
   HANDLE sharedOK;

   // Wakes up threads waiting for exclusive access.
   HANDLE exclusiveOK;

private:
   // Not implemented.
   RWLock(const RWLock&) throw ();
   RWLock& operator=(const RWLock&) throw ();
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Count
//
///////////////////////////////////////////////////////////////////////////////
class Count
{
public:
   Count() throw ()
      : value(0)
   { }

   Count(const Count& c) throw ()
      : value(c)
   { }

   Count& operator=(const Count& c) throw ()
   {
      value = c.value;
      return *this;
   }

   LONG operator=(LONG l) throw ()
   {
      value = l;
      return value;
   }

   LONG operator++() throw ()
   { return InterlockedIncrement(&value); }

   LONG operator--() throw ()
   { return InterlockedDecrement(&value); }

   operator LONG() const throw ()
   { return value; }

private:
   LONG value;
};

#endif // IASWIN32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\radpack.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    radpack.cpp
//
// SYNOPSIS
//
//    Defines functions for packing and unpacking RADIUS packets.
//
// MODIFICATION HISTORY
//
//    02/01/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>

#include <align.h>
#include <md5.h>
#include <hmac.h>

#include <radpack.h>

// Return the number of bytes required to round 'length' to a multiple of 16.
inline ULONG GetPaddingLength16(ULONG length) throw ()
{
   return ROUND_UP_COUNT(length, 16) - length;
}

// Returns 'true' if attr is a Microsoft VSA. The attribute must be of type 26.
inline bool isMicrosoftVSA(const RadiusAttribute& attr) throw ()
{
   return attr.length >= 6 && !memcmp(attr.value, "\x00\x00\x01\x37", 4);
}

// Returns 'true' if attr is a Cisco AV-Pair VSA containing a LEAP session key.
// The attribute must be of type 26.
inline bool isCiscoLeapSessionKey(const RadiusAttribute& attr) throw ()
{
   return (attr.length == 57) &&
          (memcmp(
              attr.value,
              "\x00\x00\x00\x09\x01\x35leap:session-key=",
              23
              ) == 0);
}

// Pack a 16-bit integer into a buffer.
inline void InsertUInt16(PBYTE p, USHORT value) throw ()
{
   p[0] = (BYTE)(value >> 8);
   p[1] = (BYTE)value;
}

// Unpack a 16-bit integer into a buffer.
inline USHORT ExtractUInt16(const BYTE* p) throw ()
{
   return (USHORT)(p[0] << 8) | (USHORT)p[1];
}


// Returns the number of bytes of padding that should be added when packing the
// attribute.
ULONG
WINAPI
GetPaddingLength(
    const RadiusAttribute& attr
    ) throw ()
{
   switch (attr.type)
   {
      case RADIUS_USER_PASSWORD:
         return GetPaddingLength16(attr.length);

      case RADIUS_TUNNEL_PASSWORD:
         // Subtract 1 byte for the tag and 2 for the salt.
         return GetPaddingLength16(attr.length - 3);

      case RADIUS_VENDOR_SPECIFIC:
      {
         if (isMicrosoftVSA(attr))
         {
            switch (attr.value[4])
            {
               case MS_CHAP_MPPE_SEND_KEYS:
               case MS_CHAP_MPPE_RECV_KEYS:
                  // Vendor-Id     = 4 bytes
                  // Vendor-Type   = 1 byte
                  // Vendor-Length = 1 byte
                  // Salt          = 2 bytes
                  return GetPaddingLength16(attr.length - 8);
            }
         }
         break;
      }
   }

   return 0;
}


// Returns information about how to encrypt/decrypt an attribute.
VOID
WINAPI
GetCryptParameters(
    const RadiusAttribute& attr,
    CryptParameters& parms
    ) throw ()
{
   memset(&parms, 0, sizeof(parms));

   switch (attr.type)
   {
      case RADIUS_USER_PASSWORD:
      {
         parms.encrypted = TRUE;
         break;
      }

      case RADIUS_TUNNEL_PASSWORD:
      {
         parms.encrypted = TRUE;
         parms.salted  = TRUE;
         parms.offset = 1;  // Skip the tag.
         break;
      }

      case RADIUS_VENDOR_SPECIFIC:
      {
         if (isMicrosoftVSA(attr))
         {
            switch (attr.value[4])
            {
               case MS_CHAP_MPPE_KEYS:
               {
                  parms.encrypted = TRUE;
                  parms.offset = 6;  // Skip the VSA header.
                  break;
               }

               case MS_CHAP_MPPE_SEND_KEYS:
               case MS_CHAP_MPPE_RECV_KEYS:
               {
                  parms.encrypted = TRUE;
                  parms.salted = TRUE;
                  parms.offset = 6;  // Skip the VSA header.
                  break;
               }
            }
         }
         else if (isCiscoLeapSessionKey(attr))
         {
            parms.encrypted = TRUE;
            parms.salted = TRUE;
            parms.offset = 23;
         }
         break;
      }
   }
}

ULONG
WINAPI
GetBufferSizeRequired(
    const RadiusPacket& packet,
    const RadiusAttribute* proxyState,
    BOOL alwaysSign
    ) throw ()
{
   // We'll look for the signature as we iterate through the attributes.
   BOOL hasSignature = FALSE;

   // We always need 20 bytes for the header.
   ULONG nbyte = 20;

   // Iterate through the attributes.
   for (const RadiusAttribute* attr = packet.begin; attr != packet.end; ++attr)
   {
      nbyte += 2;  // Two bytes for type & length.
      nbyte += attr->length;
      nbyte += GetPaddingLength(*attr);

      if (attr->type == RADIUS_SIGNATURE)
      {
         hasSignature = TRUE;
      }
      else if (attr->type == RADIUS_EAP_MESSAGE)
      {
         alwaysSign = TRUE;
      }
   }

   // Reserve space for the Proxy-State attribute.
   if (proxyState) { nbyte += proxyState->length + 2; }

   // Reserve space for the signature if necessary.
   if (alwaysSign && !hasSignature && packet.code == RADIUS_ACCESS_REQUEST)
   {
      nbyte += 18;
   }

   return nbyte <= 4096 ? nbyte : 0;
}

VOID
WINAPI
PackBuffer(
    const BYTE* secret,
    ULONG secretLength,
    RadiusPacket& packet,
    const RadiusAttribute* proxyState,
    BOOL alwaysSign,
    BYTE* buffer
    ) throw ()
{
   // Set up a cursor into the buffer.
   BYTE* dst = buffer;

   // Pack the header.
   *dst++ = packet.code;
   *dst++ = packet.identifier;
   InsertUInt16(dst, packet.length);
   dst += 2;

   // Pack the authenticator.
   if (packet.code == RADIUS_ACCESS_REQUEST)
   {
      memcpy(dst, packet.authenticator, 16);
   }
   else
   {
      memset(dst, 0, 16);
   }
   dst += 16;

   // We'll look for the signature as we iterate through the attributes.
   BYTE* signature = NULL;

   for (const RadiusAttribute* attr = packet.begin; attr != packet.end; ++attr)
   {
      // Pack the type.
      *dst++ = attr->type;

      // Pack the length.
      ULONG paddingLength = GetPaddingLength(*attr);
      ULONG valueLength = attr->length + paddingLength;
      *dst++ = (BYTE)(2 + valueLength);

      if (attr->type == RADIUS_SIGNATURE)
      {
         signature = dst;
      }
      else if (attr->type == RADIUS_EAP_MESSAGE)
      {
         alwaysSign = TRUE;
      }

      // Pack the value ...
      memcpy(dst, attr->value, attr->length);
      // ... and add the padding.
      memset(dst + attr->length, 0, paddingLength);

      // Do we need to encrypt this attribute ?
      CryptParameters parms;
      GetCryptParameters(*attr, parms);
      if (parms.encrypted)
      {
         // Yes.
         IASRadiusCrypt(
             TRUE,
             parms.salted,
             secret,
             secretLength,
             buffer + 4,
             dst + parms.offset,
             valueLength - parms.offset
             );
      }

      dst += valueLength;
   }

   // Add the Proxy-State
   if (proxyState)
   {
      *dst++ = proxyState->type;
      *dst++ = proxyState->length + 2;
      memcpy(dst, proxyState->value, proxyState->length);
      dst += proxyState->length;
   }

   if (packet.code == RADIUS_ACCESS_REQUEST)
   {
      if (alwaysSign && (signature == 0))
      {
         *dst++ = RADIUS_SIGNATURE;
         *dst++ = 18;
         signature = dst;
      }

      if (signature != 0)
      {
         // Compute the signature.
         memset(signature, 0, 16);
         HMACMD5_CTX context;
         HMACMD5Init(&context, (BYTE*)secret, secretLength);
         HMACMD5Update(&context, buffer, packet.length);
         HMACMD5Final(&context, signature);
      }
   }
   else
   {
      // For everything but Access-Request, we compute the authenticator.
      MD5_CTX context;
      MD5Init(&context);
      MD5Update(&context, buffer, packet.length);
      MD5Update(&context, secret, secretLength);
      MD5Final(&context);

      memcpy(buffer + 4, context.digest, 16);
   }
}

RadiusAttribute*
WINAPI
FindAttribute(
    const RadiusPacket& packet,
    BYTE type
    )
{
   for (const RadiusAttribute* i = packet.begin; i != packet.end; ++i)
   {
      if (i->type == type) { return const_cast<RadiusAttribute*>(i); }
   }

   return NULL;
}

ULONG
WINAPI
GetAttributeCount(
    const BYTE* buffer,
    ULONG bufferLength
    ) throw ()
{
   if (bufferLength >= 20 && ExtractUInt16(buffer + 2) == bufferLength)
   {
      ULONG count = 0;
      const BYTE* end = buffer + bufferLength;
      for (const BYTE* p = buffer + 20; p < end; p += p[1])
      {
         ++count;
      }

      if (p == end) { return count; }
   }

   return MALFORMED_PACKET;
}

VOID
WINAPI
UnpackBuffer(
    BYTE* buffer,
    ULONG bufferLength,
    RadiusPacket& packet
    ) throw ()
{
   // Set up a cursor into the buffer.
   BYTE* src = buffer;

   packet.code = *src++;
   packet.identifier = *src++;
   packet.length = ExtractUInt16(src);
   src +=2;
   packet.authenticator = src;
   src += 16;

   RadiusAttribute* dst = packet.begin;
   const BYTE* end = buffer + bufferLength;
   while (src < end)
   {
      dst->type = *src++;
      dst->length = *src++ - 2;
      dst->value = src;
      src += dst->length;
      ++dst;
   }
}

BYTE*
WINAPI
FindRawAttribute(
    BYTE type,
    BYTE* buffer,
    ULONG bufferLength
    )
{
   BYTE* end = buffer + bufferLength;

   for (BYTE* p = buffer + 20; p < buffer + bufferLength; p += p[1])
   {
      if (*p == type) { return p; }
   }

   return NULL;
}

AuthResult
WINAPI
AuthenticateAndDecrypt(
    const BYTE* requestAuthenticator,
    const BYTE* secret,
    ULONG secretLength,
    BYTE* buffer,
    ULONG bufferLength,
    RadiusPacket& packet
    ) throw ()
{
   AuthResult result = AUTH_UNKNOWN;

   if (!requestAuthenticator) { requestAuthenticator = buffer + 4; }

   // Check the authenticator for everything but Access-Request.
   if (buffer[0] != RADIUS_ACCESS_REQUEST)
   {
      MD5_CTX context;
      MD5Init(&context);
      MD5Update(&context, buffer, 4);
      MD5Update(&context, requestAuthenticator, 16);
      MD5Update(&context, buffer + 20, bufferLength - 20);
      MD5Update(&context, secret, secretLength);
      MD5Final(&context);

      if (memcmp(context.digest, buffer + 4, 16))
      {
         return AUTH_BAD_AUTHENTICATOR;
      }

      result = AUTH_AUTHENTIC;
   }

   // Look for a signature.
   BYTE* signature = FindRawAttribute(
                         RADIUS_SIGNATURE,
                         buffer,
                         bufferLength
                         );

   if (signature)
   {
      if (signature[1] != 18) { return AUTH_BAD_SIGNATURE; }

      signature += 2;

      BYTE sent[16];
      memcpy(sent, signature, 16);

      memset(signature, 0, 16);

      HMACMD5_CTX context;
      HMACMD5Init(&context, (BYTE*)secret, secretLength);
      HMACMD5Update(&context, buffer, 4);
      HMACMD5Update(&context, (BYTE*)requestAuthenticator, 16);
      HMACMD5Update(&context, buffer + 20, bufferLength - 20);
      HMACMD5Final(&context, signature);

      if (memcmp(signature, sent, 16)) { return AUTH_BAD_SIGNATURE; }

      result = AUTH_AUTHENTIC;
   }
   else if (FindRawAttribute(RADIUS_EAP_MESSAGE, buffer, bufferLength))
   {
      return AUTH_MISSING_SIGNATURE;
   }

   // The buffer is authentic, so decrypt the attributes.
   for (const RadiusAttribute* attr = packet.begin; attr != packet.end; ++attr)
   {
      // Do we need to decrypt this attribute ?
      CryptParameters parms;
      GetCryptParameters(*attr, parms);
      if (parms.encrypted)
      {
         // Yes.
         IASRadiusCrypt(
             FALSE,
             parms.salted,
             secret,
             secretLength,
             requestAuthenticator,
             attr->value + parms.offset,
             attr->length - parms.offset
             );
      }
   }

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\radpack.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    radpack.h
//
// SYNOPSIS
//
//    Declares functions for packing and unpacking RADIUS packets.
//
// MODIFICATION HISTORY
//
//    02/01/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef RADPACK_H
#define RADPACK_H
#if _MSC_VER >= 1000
#pragma once
#endif

#ifndef RADIUS_ATTRIBUTE_DEFINED
#define RADIUS_ATTRIBUTE_DEFINED

struct RadiusAttribute
{
   BYTE type;
   BYTE length;
   BYTE* value;
};

#endif // !RADIUS_ATTRIBUTE_DEFINED

enum RadiusPacketCode
{
   RADIUS_ACCESS_REQUEST       =  1,
   RADIUS_ACCESS_ACCEPT        =  2,
   RADIUS_ACCESS_REJECT        =  3,
   RADIUS_ACCOUNTING_REQUEST   =  4,
   RADIUS_ACCOUNTING_RESPONSE  =  5,
   RADIUS_ACCESS_CHALLENGE     = 11
};

enum RadiusAttributeType
{
   RADIUS_USER_NAME                =  1,
   RADIUS_USER_PASSWORD            =  2,
   RADIUS_CHAP_PASSWORD            =  3,
   RADIUS_NAS_IP_ADDRESS           =  4,
   RADIUS_NAS_PORT                 =  5,
   RADIUS_SERVICE_TYPE             =  6,
   RADIUS_FRAMED_PROTOCOL          =  7,
   RADIUS_FRAMED_IP_ADDRESS        =  8,
   RADIUS_FRAMED_IP_NETMASK        =  9,
   RADIUS_FRAMED_ROUTING           = 10,
   RADIUS_FILTER_ID                = 11,
   RADIUS_FRAMED_MTU               = 12,
   RADIUS_FRAMED_COMPRESSION       = 13,
   RADIUS_LOGIN_IP_HOST            = 14,
   RADIUS_LOGIN_SERVICE            = 15,
   RADIUS_LOGIN_TCP_PORT           = 16,
   RADIUS_UNASSIGNED               = 17,
   RADIUS_REPLY_MESSAGE            = 18,
   RADIUS_CALLBACK_NUMBER          = 19,
   RADIUS_CALLBACK_ID              = 20,
   RADIUS_UNASSIGNED2              = 21,
   RADIUS_FRAMED_ROUTE             = 22,
   RADIUS_FRAMED_IPX_NETWORK       = 23,
   RADIUS_STATE                    = 24,
   RADIUS_CLASS                    = 25,
   RADIUS_VENDOR_SPECIFIC          = 26,
   RADIUS_SESSION_TIMEOUT          = 27,
   RADIUS_IDLE_TIMEOUT             = 28,
   RADIUS_TERMINATION_ACTION       = 29,
   RADIUS_CALLED_STATION_ID        = 30,
   RADIUS_CALLING_STATION_ID       = 31,
   RADIUS_NAS_IDENTIFIER           = 32,
   RADIUS_PROXY_STATE              = 33,
   RADIUS_LOGIN_LAT_SERVICE        = 34,
   RADIUS_LOGIN_LAT_NODE           = 35,
   RADIUS_LOGIN_LAT_GROUP          = 36,
   RADIUS_FRAMED_APPLETALK_LINK    = 37,
   RADIUS_FRAMED_APPLETALK_NETWORK = 38,
   RADIUS_FRAMED_APPLETALK_ZONE    = 39,
   RADIUS_ACCT_STATUS_TYPE         = 40,
   RADIUS_ACCT_DELAY_TIME          = 41,
   RADIUS_ACCT_INPUT_OCTETS        = 42,
   RADIUS_ACCT_OUTPUT_OCTETS       = 43,
   RADIUS_ACCT_SESSION_ID          = 44,
   RADIUS_ACCT_AUTHENTIC           = 45,
   RADIUS_ACCT_SESSION_TIME        = 46,
   RADIUS_ACCT_INPUT_PACKETS       = 47,
   RADIUS_ACCT_OUTPUT_PACKETS      = 48,
   RADIUS_ACCT_TERMINATE_CAUSE     = 49,
   RADIUS_ACCT_MULTI_SESSION_ID    = 50,
   RADIUS_ACCT_LINK_COUNT          = 51,

   RADIUS_CHAP_CHALLENGE           = 60,
   RADIUS_NAS_PORT_TYPE            = 61,
   RADIUS_PORT_LIMIT               = 62,
   RADIUS_LOGIN_LAT_PORT           = 63,

   RADIUS_TUNNEL_PASSWORD          = 69,

   RADIUS_EAP_MESSAGE              = 79,
   RADIUS_SIGNATURE                = 80
};

enum MicrosoftVendorType
{
   MS_CHAP_MPPE_KEYS      = 12,
   MS_CHAP_MPPE_SEND_KEYS = 16,
   MS_CHAP_MPPE_RECV_KEYS = 17
};

struct RadiusPacket
{
   BYTE code;
   BYTE identifier;
   USHORT length;
   const BYTE* authenticator;
   RadiusAttribute* begin;
   RadiusAttribute* end;
};

// Returns the number of bytes required to encode the packet or zero if the
// packet is too large.
ULONG
WINAPI
GetBufferSizeRequired(
    const RadiusPacket& packet,
    const RadiusAttribute* proxyState,  // May be NULL
    BOOL alwaysSign
    ) throw ();

// Encodes the packet into 'buffer'. The buffer must be large enough to hold
// the packet and packet.length must be set to the value returned by
// GetBufferSizeRequired.
VOID
WINAPI
PackBuffer(
    const BYTE* secret,
    ULONG secretLength,
    RadiusPacket& packet,
    const RadiusAttribute* proxyState,
    BOOL alwaysSign,
    BYTE* buffer
    ) throw ();

// Returns the first occurence of a given attribute type in the packet.
RadiusAttribute*
WINAPI
FindAttribute(
    const RadiusPacket& packet,
    BYTE type
    );

const ULONG MALFORMED_PACKET = (ULONG)-1;

// Returns the number of attributes in the buffer or MALFORMED_PACKET if the
// buffer does not contain a valid RADIUS packet.
ULONG
WINAPI
GetAttributeCount(
    const BYTE* buffer,
    ULONG bufferLength
    ) throw ();

// Unpacks the buffer into packet. packet.begin must point to an array with
// enough room to hold the attributes.
VOID
WINAPI
UnpackBuffer(
    BYTE* buffer,
    ULONG bufferLength,
    RadiusPacket& packet
    ) throw ();

// Struct describing how to encrypt an attribute.
struct CryptParameters
{
   BOOL encrypted;
   BOOL salted;
   ULONG offset;
};

// Returns information about how to encrypt/decrypt an attribute.
VOID
WINAPI
GetCryptParameters(
    const RadiusAttribute& attr,
    CryptParameters& parms
    ) throw ();

enum AuthResult
{
   AUTH_BAD_AUTHENTICATOR,
   AUTH_BAD_SIGNATURE,
   AUTH_MISSING_SIGNATURE,
   AUTH_UNKNOWN,
   AUTH_AUTHENTIC
};

// Authenticates the packet and decrypts the attributes.
AuthResult
WINAPI
AuthenticateAndDecrypt(
    const BYTE* requestAuthenticator,
    const BYTE* secret,
    ULONG secretLength,
    BYTE* buffer,
    ULONG bufferLength,
    RadiusPacket& packet
    ) throw ();

// Allocates and initializes a RadiusPacket struct to hold 'nattr' attributes.
#define ALLOC_PACKET(packet, nattr) \
{ size_t nbyte = sizeof(RadiusPacket) + (nattr) * sizeof(RadiusAttribute); \
  (packet) = (RadiusPacket*)_alloca(nbyte); \
  (packet)->begin = (RadiusAttribute*)((packet) + 1); \
  (packet)->end = (RadiusAttribute*)((PBYTE)(packet) + nbyte); \
}

// Allocates and initializes a RadiusPacket struct to hold the attributes in
// 'buf'.
#define ALLOC_PACKET_FOR_BUFFER(packet, buf, buflen) \
{ size_t nattr = GetAttributeCount(buf, buflen); \
  if (nattr != MALFORMED_PACKET) \
     ALLOC_PACKET(packet, nattr) \
  else \
     packet = NULL; \
}

// Allocates a buffer to hold 'packet'.
#define ALLOC_BUFFER_FOR_PACKET(buf, packet, ps, sign) \
{ (packet)->length = (USHORT)GetBufferSizeRequired(*(packet), (ps), (sign)); \
  (buf) = (PBYTE)((packet)->length ? _alloca((packet)->length) : NULL); \
}

#endif // RADPACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\radproxyp.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// FILE
//
//    radproxyp.cpp
//
// SYNOPSIS
//
//    Defines classes that are used in the implementation of RadiusProxy, but
//    need not be visible to clients.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <radproxyp.h>

ProxyContext::~ProxyContext() throw ()
{
   if (context)
   {
      // Our ref count dropped to zero, but we still have a context object.
      // That means no one is going to take ownership.
      RadiusProxyEngine::onRequestAbandoned(context, primary);
   }
}

LONG Request::theNextRequestID;

Request::Request(
             ProxyContext* context,
             RemoteServer* destination,
             BYTE packetCode
             ) throw ()
   : ctxt(context),
     dst(destination),
     id(InterlockedIncrement(&theNextRequestID)),
     code(packetCode)
{
   identifier = port().getIdentifier();
}

void Request::setPacket(const RadiusPacket& packet)
{
   RadiusAttribute* attr = FindAttribute(packet, RADIUS_USER_NAME);
   if (attr != 0)
   {
      userName.assign(attr->value, attr->length);
   }
}

bool Request::onReceive(BYTE code) throw ()
{
   // Compute the round-trip time.
   timeStamp = GetSystemTime64() - timeStamp;

   // Cancel the request timeout timer.
   cancelTimer();

   // Update server state.
   return dst->onReceive(code);
}

void Request::AddRef() throw ()
{
   ++refCount;
}

void Request::Release() throw ()
{
   if (--refCount == 0) { delete this; }
}

void Request::onExpiry() throw ()
{
   RadiusProxyEngine::onRequestTimeout(this);
}

const void* Request::getKey() const throw ()
{
   return &id;
}

bool Request::matches(const void* key) const throw ()
{
   return id == *(PLONG)key;
}

ULONG WINAPI Request::hash(const void* key) throw ()
{
   return *(PLONG)key;
}

void ServerBinding::AddRef() throw ()
{
   ++refCount;
}

void ServerBinding::Release() throw ()
{
   if (--refCount == 0) { delete this; }
}

const void* ServerBinding::getKey() const throw ()
{
   return &state;
}

bool ServerBinding::matches(const void* key) const throw ()
{
   const RadiusRawOctets* p = (const RadiusRawOctets*)key;
   return state.length() == p->len && !memcmp(state, p->value, p->len);
}

ULONG WINAPI ServerBinding::hash(const void* key) throw ()
{
   const RadiusRawOctets* p = (const RadiusRawOctets*)key;
   return IASHashBytes(p->value, p->len);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\radproxy.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    radproxy.h
//
// SYNOPSIS
//
//    Declares the interface into the reusable RadiusProxy engine. This should
//    have no IAS specific dependencies.
//
// MODIFICATION HISTORY
//
//    02/08/2000    Original version.
//    05/30/2000    Eliminate QUESTIONABLE state.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef RADPROXY_H
#define RADPROXY_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <iascache.h>
#include <iasobj.h>
#include <radshare.h>
#include <timerq.h>
#include <udpsock.h>
#include <wincrypt.h>

struct RadiusAttribute;
struct RadiusPacket;
class  Request;
class  ServerBinding;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    RemotePort
//
// DESCRIPTION
//
//    Describes a remote endpoint for a RADIUS conversation.
//
///////////////////////////////////////////////////////////////////////////////
class RemotePort
{
public:
   // Read-only properties.
   const InternetAddress address;
   const RadiusOctets secret;

   RemotePort(
       ULONG ipAddress,
       USHORT port,
       PCSTR sharedSecret
       );
   RemotePort(const RemotePort& port);

   // Returns a packet identifier to use when sending a request to this port.
   BYTE getIdentifier() throw ()
   { return (BYTE)++nextIdentifier; }

   // Synchronizes this with the state of 'port', i.e., use the same next
   // identifier.
   void copyState(const RemotePort& port) throw ()
   { nextIdentifier = port.nextIdentifier; }

   bool operator==(const RemotePort& p) const throw ()
   { return address == p.address && secret == p.secret; }

private:
   Count nextIdentifier;

   // Not implemented.
   RemotePort& operator=(RemotePort&);
};

///////////////////////////////////////////////////////////////////////////////
//
// struct
//
//    RemoteServerConfig
//
// DESCRIPTION
//
//    Plain ol' data holding all the configuration associated with a
//    RemoteServer. This spares clients from having to call a monster
//    contructor when creating a remote server.
//
///////////////////////////////////////////////////////////////////////////////
struct RemoteServerConfig
{
   GUID guid;
   ULONG ipAddress;
   USHORT authPort;
   USHORT acctPort;
   PCSTR authSecret;
   PCSTR acctSecret;
   ULONG priority;
   ULONG weight;
   ULONG timeout;
   ULONG maxLost;
   ULONG blackout;
   bool sendSignature;
   bool sendAcctOnOff;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    RemoteServer
//
// DESCRIPTION
//
//    Describes a remote RADIUS server and maintains the state of that server.
//
///////////////////////////////////////////////////////////////////////////////
class RemoteServer
{
public:
   DECLARE_REFERENCE_COUNT();

   // Unique ID for this server.
   const GUID guid;

   // Authentication and accounting ports.
   RemotePort authPort;
   RemotePort acctPort;

   // Read-only properties for load-balancing and failover.
   const ULONG priority;
   const ULONG weight;

   // Read-only properties for determining server state.
   const ULONG timeout;
   const LONG maxEvents;
   const ULONG blackout;

   // Should we always send a Signature attribute?
   const bool sendSignature;

   // Should we formard Accounting-On/Off requests?
   const bool sendAcctOnOff;

   RemoteServer(const RemoteServerConfig& config);

   // Returns the servers IP address.
   ULONG getAddress() const throw ()
   { return authPort.address.sin_addr.s_addr; }

   // Returns 'true' if the server has a probationary request pending.
   bool isInProgress() const throw ()
   { return onProbation && !usable; }

   // Returns 'true' if the server is available for use.
   bool isUsable() const throw ()
   { return usable; }

   // Returns 'true' if the server should receive a broadcast.
   bool shouldBroadcast() throw ();

   // Notifies the RemoteServer that a valid packet has been received. Returns
   // true if this triggers a state change.
   bool onReceive(BYTE code) throw ();

   // Notifies the RemoteServer that a packet has been sent.
   void onSend() throw ();

   // Notfies the RemoteServer that a request has timed out. Returns true if
   // this triggers a state change.
   bool onTimeout() throw ();

   // Synchronize the state of this server with target.
   void copyState(const RemoteServer& target) throw ();

   bool operator==(const RemoteServer& s) const throw ();

protected:
   // This is virtual so that RemoteServer can server as a base class.
   virtual ~RemoteServer() throw () { }

private:
   CriticalSection lock;

   bool usable;      // true if the server is available.
   bool onProbation; // true if the server is on probation.
   long eventCount;  // Number of packets lost/found
   ULONG64 expiry;   // Time when blackout interval expires.

   // Not implemented.
   RemoteServer& operator=(RemoteServer&);
};

typedef ObjectPointer<RemoteServer> RemoteServerPtr;
typedef ObjectVector<RemoteServer> RemoteServers;

class RequestStack;
class ProxyContext;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ServerGroup
//
// DESCRIPTION
//
//    Load balances requests among a group of RemoteServers.
//
///////////////////////////////////////////////////////////////////////////////
class ServerGroup
{
public:
   DECLARE_REFERENCE_COUNT();

   ServerGroup(
       PCWSTR groupName,
       RemoteServer* const* first,
       RemoteServer* const* last
       );

   // Returns the number of servers in the group.
   ULONG size() const throw ()
   { return servers.size(); }

   bool isEmpty() const throw ()
   { return servers.empty(); }

   // Name used to identify the group.
   PCWSTR getName() const throw ()
   { return name; }

   // Returns a collection of servers that should receive the request.
   void getServersForRequest(
            ProxyContext* context,
            BYTE packetCode,
            const RemoteServer* avoid,
            RequestStack& result
            ) const;

   // Methods for iterating the servers in the group.
   RemoteServers::iterator begin() const throw ()
   { return servers.begin(); }
   RemoteServers::iterator end() const throw ()
   { return servers.end(); }

private:
   ~ServerGroup() throw () { }

   // Pick a server from the list. The list must not be empty, and all the
   // servers must have the same priority. If 'avoid' is not null and there is
   // more than one server in the list, the indicated server won't be picked.
   static RemoteServer* pickServer(
                            RemoteServers::iterator first,
                            RemoteServers::iterator last,
                            const RemoteServer* avoid = 0
                            ) throw ();

   // Array of servers in priority order.
   RemoteServers servers;

   // End of top priority level in array.
   RemoteServers::iterator endTopPriority;

   // Maximum number of bytes required to hold the server candidates.
   ULONG maxCandidatesSize;

   RadiusString name;

   static ULONG theSeed;

   // Not implemented.
   ServerGroup(const ServerGroup&);
   ServerGroup& operator=(const ServerGroup&);
};

typedef ObjectPointer<ServerGroup> ServerGroupPtr;
typedef ObjectVector<ServerGroup> ServerGroups;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ServerGroupManager
//
// DESCRIPTION
//
//    Manages a collection of ServerGroups.
//
///////////////////////////////////////////////////////////////////////////////
class ServerGroupManager
{
public:
   ServerGroupManager() throw () { }

   // Set the server groups to be managed.
   bool setServerGroups(
            ServerGroups::iterator begin,
            ServerGroups::iterator end
            ) throw ();

   // Returns a server with the given IP address.
   RemoteServerPtr findServer(
                       ULONG address
                       ) const throw ();

   void getServersByGroup(
            ProxyContext* context,
            BYTE packetCode,
            PCWSTR name,
            const RemoteServer* avoid,
            RequestStack& result
            ) const;

   void getServersForAcctOnOff(
            ProxyContext* context,
            RequestStack& result
            ) const;

private:
   // Synchronize access.
   mutable RWLock monitor;

   // Server groups being managed sorted by name.
   ServerGroups groups;

   // All servers sorted by guid.
   RemoteServers byAddress;

   // All servers sorted by guid.
   RemoteServers byGuid;

   // Servers to receive Accounting-On/Off requests.
   RemoteServers acctServers;

   // Not implemented.
   ServerGroupManager(const ServerGroupManager&);
   ServerGroupManager& operator=(const ServerGroupManager&);
};

class RadiusProxyClient;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    RadiusProxyEngine
//
// DESCRIPTION
//
//    Implements a RADIUS proxy.
//
///////////////////////////////////////////////////////////////////////////////
class RadiusProxyEngine : PacketReceiver
{
public:

   // Final result of processing a request.
   enum Result
   {
      resultSuccess,
      resultNotEnoughMemory,
      resultUnknownServerGroup,
      resultUnknownServer,
      resultInvalidRequest,
      resultSendError,
      resultRequestTimeout,
      resultCryptoError
   };

   RadiusProxyEngine(RadiusProxyClient* source);
   ~RadiusProxyEngine() throw ();

   HRESULT finalConstruct() throw ();

   // Set the server groups to be used by the proxy.
   bool setServerGroups(
            ServerGroup* const* begin,
            ServerGroup* const* end
            ) throw ();

   // Forward a request to the given server group.
   void forwardRequest(
            PVOID context,
            PCWSTR serverGroup,
            BYTE code,
            const BYTE* requestAuthenticator,
            const RadiusAttribute* begin,
            const RadiusAttribute* end
            ) throw ();

   // Callback when a request context has been abandoned.
   static void onRequestAbandoned(
                   PVOID context,
                   RemoteServer* server
                   ) throw ();

   // Callback when a request has timed out.
   static void onRequestTimeout(
                   Request* request
                   ) throw ();

private:
   // Methods for associating a stateful authentication session with a
   // particular server.
   RemoteServerPtr getServerAffinity(
                       const RadiusPacket& packet
                       ) throw ();
   void setServerAffinity(
            const RadiusPacket& packet,
            RemoteServer& server
            ) throw ();

   // Methods for associating a bad server with a User-Name.
   void clearServerAvoidance(
           const RadiusPacket& packet,
           RemoteServer& server
           ) throw ();
   RemoteServerPtr getServerAvoidance(
                       const RadiusPacket& packet
                       ) throw ();
   void setServerAvoidance(const Request& request) throw ();

   // PacketReceiver callbacks.
   virtual void onReceive(
                    UDPSocket& socket,
                    ULONG_PTR key,
                    const SOCKADDR_IN& remoteAddress,
                    BYTE* buffer,
                    ULONG bufferLength
                    ) throw ();
   virtual void onReceiveError(
                    UDPSocket& socket,
                    ULONG_PTR key,
                    ULONG errorCode
                    ) throw ();

   // Forward a request to an individual RemoteServer.
   Result sendRequest(
              RadiusPacket& packet,
              Request* request
              ) throw ();

   // Report an event to the client.
   void reportEvent(
            const RadiusEvent& event
            ) const throw ();
   void reportEvent(
            RadiusEvent& event,
            RadiusEventType type
            ) const throw ();

   // Callback when a timer has expired.
   static VOID NTAPI onTimerExpiry(PVOID context, BOOLEAN flag) throw ();

   // The object supplying us with requests.
   RadiusProxyClient* client;

   // The local address of the proxy. Used when forming Proxy-State.
   ULONG proxyAddress;

   // UDP sockets used for network I/O.
   UDPSocket authSock;
   UDPSocket acctSock;

   // Server groups used for processing groups.
   ServerGroupManager groups;

   // Table of pending requests.
   HashTable< LONG, Request > pending;

   // Queue of pending requests.
   TimerQueue timers;

   // Table of current authentication sessions.
   Cache< RadiusRawOctets, ServerBinding > sessions;

   // Table of servers to avoid for a given User-Name.
   Cache< RadiusRawOctets, ServerBinding > avoid;

   // Used for generating request authenticators.
   HCRYPTPROV crypto;

   // Global pointer to the RadiusProxyEngine. This is a hack, but it saves me
   // from having to give every Request and Context object a back pointer.
   static RadiusProxyEngine* theProxy;

   // Not implemented.
   RadiusProxyEngine(const RadiusProxyEngine&);
   RadiusProxyEngine& operator=(const RadiusProxyEngine&);
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    RadiusProxyClient
//
// DESCRIPTION
//
//    Abstract base class for clients of the RadiusProxy engine.
//
///////////////////////////////////////////////////////////////////////////////
class __declspec(novtable) RadiusProxyClient
{
public:
   // Invoked to report one of the above events.
   virtual void onEvent(
                    const RadiusEvent& event
                    ) throw () = 0;

   // Invoked exactly once for each call to RadiusProxyEngine::forwardRequest.
   virtual void onComplete(
                     RadiusProxyEngine::Result result,
                     PVOID context,
                     RemoteServer* server,
                     BYTE code,
                     const RadiusAttribute* begin,
                     const RadiusAttribute* end
                     ) throw () = 0;
};

#endif // RADPROXY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\radproxy.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    radprxy.cpp
//
// SYNOPSIS
//
//    Defines the reusable RadiusProxy engine. This should have no IAS specific
//    dependencies.
//
// MODIFICATION HISTORY
//
//    02/08/2000    Original version.
//    05/30/2000    Eliminate QUESTIONABLE state.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <radproxyp.h>
#include <radproxy.h>

// Avoid dependencies on ntrtl.h
extern "C" ULONG __stdcall RtlRandom(PULONG seed);

// Extract a 32-bit integer from a buffer.
ULONG ExtractUInt32(const BYTE* p) throw ()
{
   return (ULONG)(p[0] << 24) | (ULONG)(p[1] << 16) |
          (ULONG)(p[2] <<  8) | (ULONG)(p[3]      );
}

// Insert a 32-bit integer into a buffer.
void InsertUInt32(BYTE* p, ULONG val) throw ()
{
   *p++ = (BYTE)(val >> 24);
   *p++ = (BYTE)(val >> 16);
   *p++ = (BYTE)(val >>  8);
   *p   = (BYTE)(val      );
}

//
//  Layout of a Microsoft State attribute
//
//  struct MicrosoftState
//  {
//      BYTE checksum[4];
//      BYTE vendorID[4];
//      BYTE version[2];
//      BYTE serverAddress[4];
//      BYTE sourceID[4];
//      BYTE sessionID[4];
//  };
//

// Extracts the creators address from a State attribute or INADDR_NONE if this
// isn't a valid Microsoft State attributes.
ULONG ExtractAddressFromState(const RadiusAttribute& state) throw ()
{
   if (state.length == 22 &&
       !memcmp(state.value + 4, "\x00\x00\x01\x37\x00\x01", 6) &&
       IASAdler32(state.value + 4, 18) == ExtractUInt32(state.value))
   {
      return ExtractUInt32(state.value + 10);
   }

   return INADDR_NONE;
}

// Returns true if this is an Accounting-On/Off packet.
bool IsNasStateRequest(const RadiusPacket& packet) throw ()
{
   const RadiusAttribute* status = FindAttribute(
                                       packet,
                                       RADIUS_ACCT_STATUS_TYPE
                                       );
   if (!status) { return false; }

   ULONG value = ExtractUInt32(status->value);

   return value == 7 || value == 8;
}

RemotePort::RemotePort(
                ULONG ipAddress,
                USHORT port,
                PCSTR sharedSecret
                )
   : address(ipAddress, port),
     secret((const BYTE*)sharedSecret, strlen(sharedSecret))
{
}

RemotePort::RemotePort(const RemotePort& port)
   : address(port.address),
     secret(port.secret),
     nextIdentifier(port.nextIdentifier)
{
}

RemoteServer::RemoteServer(
                  const RemoteServerConfig& config
                  )
   : guid(config.guid),
     authPort(config.ipAddress, config.authPort, config.authSecret),
     acctPort(config.ipAddress, config.acctPort, config.acctSecret),
     timeout(config.timeout),
     maxEvents((LONG)config.maxLost),
     blackout(config.blackout),
     priority(config.priority),
     weight(config.weight),
     sendSignature(config.sendSignature),
     sendAcctOnOff(config.sendAcctOnOff),
     usable(true),
     onProbation(false),
     eventCount(0),
     expiry(0)
{
}

bool RemoteServer::shouldBroadcast() throw ()
{
   bool broadcastable = false;

   if (!onProbation && !usable)
   {
      ULONG64 now = GetSystemTime64();

      lock.lock();

      // Has the blackout interval expired ?
      if (now > expiry)
      {
         // Yes, so set a new expiration.
         expiry = now + blackout * 10000i64;

         broadcastable = true;
      }

      lock.unlock();
   }

   return broadcastable;
}

bool RemoteServer::onReceive(BYTE code) throw ()
{
   const bool authoritative = (code != RADIUS_ACCESS_CHALLENGE);

   // Did the server transition from unavailable to available?
   bool downToUp = false;

   lock.lock();

   if (onProbation)
   {
      if (authoritative)
      {
         // Bump the success count.
         if (++eventCount >= maxEvents)
         {
            // We're off probation w/ a lost count of zero.
            onProbation = false;
            eventCount = 0;
            downToUp = true;
         }

         // We successfully finished a request, so we can send another.
         usable = true;
      }
   }
   else if (usable)
   {
      if (authoritative)
      {
         // An authoritative response resets the lost count.
         eventCount = 0;
      }
   }
   else
   {
      // An unavailable server has responded to a broadcast, so put it on
      // probation. Set the success count accordingly.
      usable = true;
      onProbation = true;
      eventCount = authoritative ? 1 : 0;
   }

   lock.unlock();

   return downToUp;
}

void RemoteServer::onSend() throw ()
{
   if (onProbation)
   {
      lock.lock();

      if (onProbation)
      {
         // Probationary servers can only send one request at a time.
         usable = false;
      }

      lock.unlock();
   }
}

bool RemoteServer::onTimeout() throw ()
{
   // Did the server transition from available to unavailable?
   bool upToDown = false;

   lock.lock();

   if (onProbation)
   {
      // Sudden death for probationary servers. Move it straight to
      // unavailable.
      usable = false;
      onProbation = false;
      expiry = GetSystemTime64() + blackout * 10000ui64;
   }
   else if (usable)
   {
      // Bump the lost count.
      if (++eventCount >= maxEvents)
      {
         // Server is now unavailable.
         usable = false;
         expiry = GetSystemTime64() + blackout * 10000ui64;
         upToDown = true;
      }
   }
   else
   {
      // If the server is already unavailable, ignore the timeout.
   }

   lock.unlock();

   return upToDown;
}

void RemoteServer::copyState(const RemoteServer& target) throw ()
{
   // Synchronize the ports.
   authPort.copyState(target.authPort);
   acctPort.copyState(target.acctPort);

   // Synchronize server availability.
   usable = target.usable;
   onProbation = target.onProbation;
   eventCount = target.eventCount;
   expiry = target.expiry;
}

bool RemoteServer::operator==(const RemoteServer& s) const throw ()
{
   return authPort == s.authPort &&
          acctPort == s.acctPort &&
          priority == s.priority &&
          weight == s.weight &&
          timeout == s.timeout &&
          eventCount == s.eventCount &&
          blackout == s.blackout &&
          sendSignature == s.sendSignature &&
          sendAcctOnOff == s.sendAcctOnOff;
}

//////////
// Used for sorting servers by priority.
//////////
int __cdecl sortServersByPriority(
                const RemoteServer* const* server1,
                const RemoteServer* const* server2
                ) throw ()
{
   return (int)(*server1)->priority - (int)(*server2)->priority;
}

ULONG ServerGroup::theSeed;

ServerGroup::ServerGroup(
                 PCWSTR groupName,
                 RemoteServer* const* first,
                 RemoteServer* const* last
                 )
   : servers(first, last),
     name(groupName)
{
   // We don't allow empty groups.
   if (servers.empty()) { _com_issue_error(E_INVALIDARG); }

   if (theSeed == 0)
   {
      FILETIME ft;
      GetSystemTimeAsFileTime(&ft);
      theSeed = ft.dwLowDateTime | ft.dwHighDateTime;
   }

   // Sort by priority.
   servers.sort(sortServersByPriority);

   // Find the end of the top priority servers. This will be useful when doing
   // a forced pick.
   ULONG topPriority = (*servers.begin())->priority;
   for (endTopPriority = servers.begin();
        endTopPriority != servers.end();
        ++endTopPriority)
   {
      if ((*endTopPriority)->priority != topPriority) { break; }
   }

   // Find the max number of servers at any priority level. This will be useful
   // when allocating a buffer to hold the candidates.
   ULONG maxCount = 0, count = 0, priority = (*servers.begin())->priority;
   for (RemoteServer* const* i = begin(); i != end(); ++i)
   {
      if ((*i)->priority != priority)
      {
         priority = (*i)->priority;
         count = 0;
      }
      if (++count > maxCount) { maxCount = count; }
   }

   maxCandidatesSize = maxCount * sizeof(RemoteServer*);
}

RemoteServer* ServerGroup::pickServer(
                               RemoteServers::iterator first,
                               RemoteServers::iterator last,
                               const RemoteServer* avoid
                               ) throw ()
{
   // If the list has exactly one entry, there's nothing to do.
   if (last == first + 1) { return *first; }

   RemoteServer* const* i;

   // Compute the combined weight off all the servers.
   ULONG weight = 0;
   for (i  = first; i != last; ++i)
   {
      if (*i != avoid)
      {
         weight += (*i)->weight;
      }
   }

   // Pick a random number from [0, weight)
   ULONG offset = (ULONG)
      (((ULONG64)RtlRandom(&theSeed) * (ULONG64)weight) >> 31);

   // We don't test the last server since if we make it that far we have to use
   // it anyway.
   --last;

   // Iterate through the candidates until we reach the offset.
   for (i = first; i != last; ++i)
   {
      if (*i != avoid)
      {
         if ((*i)->weight >= offset) { break; }

         offset -= (*i)->weight;
      }
   }

   return *i;
}

void ServerGroup::getServersForRequest(
                      ProxyContext* context,
                      BYTE packetCode,
                      const RemoteServer* avoid,
                      RequestStack& result
                      ) const
{
   // List of candidates.
   RemoteServer** first = (RemoteServer**)_alloca(maxCandidatesSize);
   RemoteServer** last = first;

   // Iterate through the servers.
   ULONG maxPriority = (ULONG)-1;
   for (RemoteServer* const* i = servers.begin(); i != servers.end();  ++i)
   {
      // If this test fails, we must have found a higher priority server that's
      // usable.
      if ((*i)->priority > maxPriority) { break; }

      if ((*i)->isUsable())
      {
         // Don't consider lower priority servers.
         maxPriority = (*i)->priority;

         // Add this to the list of candidates.
         *last++ = *i;
      }
      else if ((*i)->shouldBroadcast())
      {
         // It's not available, but it's ready for a broadcast
         result.push(new Request(context, *i, packetCode));
      }
   }

   if (first == last)
   {
      // No usable servers, so look for in progress servers.
      maxPriority = (ULONG)-1;
      for (RemoteServer* const* i = servers.begin(); i != servers.end();  ++i)
      {
         // If this test fails, we must have found a higher priority server
         // that's in progress.
         if ((*i)->priority > maxPriority) { break; }

         if ((*i)->isInProgress())
         {
            // Don't consider lower priority servers.
            maxPriority = (*i)->priority;

            // Add this to the list of candidates.
            *last++ = *i;
         }
      }
   }

   if (first != last)
   {
      // We have at least one candidate, so pick one and add it to the list.
      result.push(new Request(
                          context,
                          pickServer(first, last, avoid),
                          packetCode
                          ));
   }
   else if (result.empty() && !servers.empty())
   {
      // We have no candidates and no servers available for broadcast, so just
      // force a pick from the top priority servers.
      result.push(new Request(
                          context,
                          pickServer(servers.begin(), endTopPriority, avoid),
                          packetCode
                          ));
   }
}

//////////
// Used for sorting and searching groups by name.
//////////

int __cdecl sortGroupsByName(
                const ServerGroup* const* group1,
                const ServerGroup* const* group2
                ) throw ()
{
   return wcscmp((*group1)->getName(), (*group2)->getName());
}

int __cdecl findGroupByName(
                const void* key,
                const ServerGroup* const* group
                ) throw ()
{
   return wcscmp((PCWSTR)key, (*group)->getName());
}

//////////
// Used for sorting and searching servers by address.
//////////

int __cdecl sortServersByAddress(
                const RemoteServer* const* server1,
                const RemoteServer* const* server2
                )
{
   if ((*server1)->getAddress() < (*server2)->getAddress()) { return -1; }
   if ((*server1)->getAddress() > (*server2)->getAddress()) { return  1; }
   return 0;
}

int __cdecl findServerByAddress(
                const void* key,
                const RemoteServer* const* server
                ) throw ()
{
   if ((ULONG_PTR)key < (*server)->getAddress()) { return -1; }
   if ((ULONG_PTR)key > (*server)->getAddress()) { return  1; }
   return 0;
}

//////////
// Used for sorting and searching servers by guid.
//////////

int __cdecl sortServersByGUID(
                const RemoteServer* const* server1,
                const RemoteServer* const* server2
                ) throw ()
{
   return memcmp(&(*server1)->guid, &(*server2)->guid, sizeof(GUID));
}

int __cdecl findServerByGUID(
                const void* key,
                const RemoteServer* const* server
                ) throw ()
{
   return memcmp(key, &(*server)->guid, sizeof(GUID));
}

//////////
// Used for sorting accounting servers by port.
//////////

int __cdecl sortServersByAcctPort(
                const RemoteServer* const* server1,
                const RemoteServer* const* server2
                )
{
   const sockaddr_in& a1 = (*server1)->acctPort.address;
   const sockaddr_in& a2 = (*server2)->acctPort.address;
   return memcmp(&a1.sin_port, &a2.sin_port, 6);
}

bool ServerGroupManager::setServerGroups(
                             ServerGroup* const* first,
                             ServerGroup* const* last
                             ) throw ()
{
   bool success;

   try
   {
      // Save the new server groups ...
      ServerGroups newGroups(first, last);

      // Sort by name.
      newGroups.sort(sortGroupsByName);

      // Useful iterators.
      ServerGroups::iterator i;
      RemoteServers::iterator j;

      // Count the number of servers and accounting servers.
      ULONG count = 0, acctCount = 0;
      for (i = first; i != last; ++i)
      {
         for (j = (*i)->begin(); j != (*i)->end(); ++j)
         {
            ++count;

            if ((*j)->sendAcctOnOff) { ++acctCount; }
         }
      }

      // Reserve space for the servers.
      RemoteServers newServers(count);
      RemoteServers newAcctServers(acctCount);

      // Populate the servers.
      for (i = first; i != last; ++i)
      {
         for (j = (*i)->begin(); j != (*i)->end(); ++j)
         {
            RemoteServer* newServer = *j;

            // Does this server already exist?
            RemoteServer* existing = byGuid.search(
                                         (const void*)&newServer->guid,
                                         findServerByGUID
                                         );
            if (existing)
            {
               if (*existing == *newServer)
               {
                  // If it's an exact match, use the existing server.
                  newServer = existing;
               }
               else
               {
                  // Otherwise, copy the state of the existing server.
                  newServer->copyState(*existing);
               }
            }

            newServers.push_back(newServer);

            if (newServer->sendAcctOnOff)
            {
               newAcctServers.push_back(newServer);
            }
         }
      }

      // Sort the servers by address ...
      newServers.sort(sortServersByAddress);

      // ... and GUID.
      RemoteServers newServersByGuid(newServers);
      newServersByGuid.sort(sortServersByGUID);

      // Everything is ready so now we grab the write lock ...
      monitor.LockExclusive();

      // ... and swap in the collections.
      groups.swap(newGroups);
      byAddress.swap(newServers);
      byGuid.swap(newServersByGuid);
      acctServers.swap(newAcctServers);

      monitor.Unlock();

      success = true;
   }
   catch (const std::bad_alloc&)
   {
      success = false;
   }

   return success;
}

RemoteServerPtr ServerGroupManager::findServer(
                                        ULONG address
                                        ) const throw ()
{
   monitor.Lock();

   RemoteServer* server = byAddress.search(
                                         (const void*)ULongToPtr(address),
                                         findServerByAddress
                                         );

   monitor.Unlock();

   return server;
}

void ServerGroupManager::getServersByGroup(
                             ProxyContext* context,
                             BYTE packetCode,
                             PCWSTR name,
                             const RemoteServer* avoid,
                             RequestStack& result
                             ) const throw ()
{
   monitor.Lock();

   ServerGroup* group = groups.search(name, findGroupByName);

   if (group)
   {
      group->getServersForRequest(context, packetCode, avoid, result);
   }

   monitor.Unlock();
}

void ServerGroupManager::getServersForAcctOnOff(
                             ProxyContext* context,
                             RequestStack& result
                             ) const
{
   monitor.Lock();

   for (RemoteServer* const* i = acctServers.begin();
        i != acctServers.end();
        ++i)
   {
      result.push(new Request(context, *i, RADIUS_ACCOUNTING_REQUEST));
   }

   monitor.Unlock();
}

RadiusProxyEngine* RadiusProxyEngine::theProxy;

RadiusProxyEngine::RadiusProxyEngine(RadiusProxyClient* source) throw ()
   : client(source),
     proxyAddress(INADDR_NONE),
     pending(Request::hash, 1),
     sessions(ServerBinding::hash, 1, 10000, (2 * 60 * 1000), true),
     avoid(ServerBinding::hash, 1, 10000, (35 * 60 * 1000), false),
     crypto(0)
{
   theProxy = this;

   // We don't care if this fails. The proxy will just use INADDR_NONE in it's
   // proxy-state attribute.
   PHOSTENT he = IASGetHostByName(NULL);
   if (he)
   {
      if (he->h_addr_list[0])
      {
         proxyAddress = *(PULONG)he->h_addr_list[0];
      }

      LocalFree(he);
   }
}


RadiusProxyEngine::~RadiusProxyEngine() throw ()
{
   // Block any new reponses.
   authSock.close();
   acctSock.close();

   // Clear the pending request table.
   pending.clear();

   // Cancel all the timers.
   timers.cancelAllTimers();

   // At this point all our threads should be done, but let's just make sure.
   SwitchToThread();

   if (crypto != 0)
   {
      CryptReleaseContext(crypto, 0);
   }

   theProxy = NULL;
}

HRESULT RadiusProxyEngine::finalConstruct() throw ()
{
   HRESULT hr = S_OK;

   if (!CryptAcquireContext(
           &crypto,
           0,
           0,
           PROV_RSA_FULL,
           CRYPT_VERIFYCONTEXT
           ))
   {
      DWORD error = GetLastError();
      hr = HRESULT_FROM_WIN32(error);
   }

   return hr;
}

bool RadiusProxyEngine::setServerGroups(
                            ServerGroup* const* begin,
                            ServerGroup* const* end
                            ) throw ()
{
   // We don't open the sockets unless we actually have some server groups
   // configured. This is just to be a good corporate citizen.
   if (begin != end)
   {
      if ((!authSock.isOpen() && !authSock.open(this, portAuthentication)) ||
          (!acctSock.isOpen() && !acctSock.open(this, portAccounting)))
      {
         return false;
      }
   }

   return groups.setServerGroups(begin, end);
}

void RadiusProxyEngine::forwardRequest(
                            PVOID context,
                            PCWSTR serverGroup,
                            BYTE code,
                            const BYTE* requestAuthenticator,
                            const RadiusAttribute* begin,
                            const RadiusAttribute* end
                            ) throw ()
{
   // Save the request context. We have to handle this carefully since we rely
   // on the ProxyContext object to ensure that onComplete gets called exactly
   // one. If we can't allocate the object, we have to handle it specially.
   ProxyContextPtr ctxt(new (std::nothrow) ProxyContext(context));
   if (!ctxt)
   {
      client->onComplete(
                  resultNotEnoughMemory,
                  context,
                  NULL,
                  code,
                  NULL,
                  NULL
                  );
      return;
   }

   Result retval = resultUnknownServerGroup;

   try
   {
      // Store the in parameters in a RadiusPacket struct.
      RadiusPacket packet;
      packet.code = code;
      packet.begin = const_cast<RadiusAttribute*>(begin);
      packet.end = const_cast<RadiusAttribute*>(end);

      // Generate the list of RADIUS requests to be sent.
      RequestStack requests;
      switch (code)
      {
         case RADIUS_ACCESS_REQUEST:
         {
            // Is this request associated with a particular server?
            RemoteServerPtr server = getServerAffinity(packet);
            if (server)
            {
               requests.push(new Request(ctxt, server, RADIUS_ACCESS_REQUEST));
            }
            else
            {
               server = getServerAvoidance(packet);

               groups.getServersByGroup(
                          ctxt,
                          code,
                          serverGroup,
                          server,
                          requests
                          );
            }

            // Put request authenticator in the packet. The request
            // authenticator can be NULL. The authenticator will not be
            // changed.
            packet.authenticator = requestAuthenticator;
            break;
         }

         case RADIUS_ACCOUNTING_REQUEST:
         {
            if (!IsNasStateRequest(packet))
            {
               groups.getServersByGroup(
                          ctxt,
                          code,
                          serverGroup,
                          0,
                          requests
                          );
            }
            else
            {
               groups.getServersForAcctOnOff(
                          ctxt,
                          requests
                          );

               // NAS State requests are always reported as a success since we
               // don't care if it gets to all the destinations.
               context = ctxt->takeOwnership();
               if (context)
               {
                  client->onComplete(
                              resultSuccess,
                              context,
                              NULL,
                              RADIUS_ACCOUNTING_RESPONSE,
                              NULL,
                              NULL
                              );
               }
               retval = resultSuccess;
            }
            break;
         }

         default:
         {
            retval = resultInvalidRequest;
         }
      }

      if (!requests.empty())
      {
         // First we handle the primary.
         RequestPtr request = requests.pop();
         ctxt->setPrimaryServer(&request->getServer());
         retval = sendRequest(packet, request);

         // Now we broadcast.
         while (!requests.empty())
         {
            request = requests.pop();
            Result result = sendRequest(packet, request);
            if (result == resultSuccess && retval != resultSuccess)
            {
               // This was the first request to succeed so mark it as primary.
               retval = resultSuccess;
               ctxt->setPrimaryServer(&request->getServer());
            }
         }
      }
   }
   catch (const std::bad_alloc&)
   {
      retval = resultNotEnoughMemory;
   }

   if (retval != resultSuccess)
   {
      // If we made it here, then we didn't successfully send a packet to any
      // server, so we have to report the result ourself.
      context = ctxt->takeOwnership();
      if (context)
      {
         client->onComplete(
                     retval,
                     context,
                     ctxt->getPrimaryServer(),
                     code,
                     NULL,
                     NULL
                     );
      }
   }
}

void RadiusProxyEngine::onRequestAbandoned(
                            PVOID context,
                            RemoteServer* server
                            ) throw ()
{
   // Nobody took responsibility for the request, so we time it out.
   theProxy->client->onComplete(
                         resultRequestTimeout,
                         context,
                         server,
                         0,
                         NULL,
                         NULL
                         );
}

inline void RadiusProxyEngine::reportEvent(
                                   const RadiusEvent& event
                                   ) const throw ()
{
   client->onEvent(event);
}

inline void RadiusProxyEngine::reportEvent(
                                   RadiusEvent& event,
                                   RadiusEventType type
                                   ) const throw ()
{
   event.eventType = type;
   client->onEvent(event);
}

void RadiusProxyEngine::onRequestTimeout(
                            Request* request
                            ) throw ()
{
   // Erase the pending request. If it's not there, that's okay; it means that
   // we received a response, but weren't able to cancel the timer in time.
   if (theProxy->pending.erase(request->getRequestID()))
   {
      // Avoid this server next time.
      theProxy->setServerAvoidance(*request);

      RadiusEvent event =
      {
         request->getPortType(),
         eventTimeout,
         &request->getServer(),
         request->getPort().address.address(),
         request->getPort().address.port()
      };

      // Report the protocol event.
      theProxy->reportEvent(event);

      // Update request state.
      if (request->onTimeout())
      {
         // The server was just marked unavailable, so notify the client.
         theProxy->reportEvent(event, eventServerUnavailable);
      }
   }
}

RemoteServerPtr RadiusProxyEngine::getServerAffinity(
                                       const RadiusPacket& packet
                                       ) throw ()
{
   // Find the State attribute.
   const RadiusAttribute* attr = FindAttribute(packet, RADIUS_STATE);
   if (!attr) { return NULL; }

   // Map it to a session.
   RadiusRawOctets key = { attr->value, attr->length };
   ServerBindingPtr session = sessions.find(key);
   if (!session) { return NULL; }

   return &session->getServer();
}

void RadiusProxyEngine::setServerAffinity(
                            const RadiusPacket& packet,
                            RemoteServer& server
                            ) throw ()
{
   // Is this an Access-Challenge ?
   if (packet.code != RADIUS_ACCESS_CHALLENGE) { return; }

   // Find the State attribute.
   const RadiusAttribute* state = FindAttribute(packet, RADIUS_STATE);
   if (!state) { return; }

   // Do we already have an entry for this State value.
   RadiusRawOctets key = { state->value, state->length };
   ServerBindingPtr session = sessions.find(key);
   if (session)
   {
      // Make sure the server matches.
      session->setServer(server);
      return;
   }

   // Otherwise, we'll have to create a new one.
   try
   {
      session = new ServerBinding(key, server);
      sessions.insert(*session);
   }
   catch (const std::bad_alloc&)
   {
      // We don't care if this fails.
   }
}

void RadiusProxyEngine::clearServerAvoidance(
                           const RadiusPacket& packet,
                           RemoteServer& server
                           ) throw ()
{
   // Is this packet authoritative?
   if ((packet.code == RADIUS_ACCESS_ACCEPT) ||
       (packet.code == RADIUS_ACCESS_REJECT))
   {
      // Find the User-Name attribute.
      const RadiusAttribute* attr = FindAttribute(packet, RADIUS_USER_NAME);
      if (attr != 0)
      {
         // Map it to a server.
         RadiusRawOctets key = { attr->value, attr->length };
         ServerBindingPtr avoidance = avoid.find(key);
         if (avoidance && (avoidance->getServer() == server))
         {
            avoid.erase(key);
         }
      }
   }
}

RemoteServerPtr RadiusProxyEngine::getServerAvoidance(
                                       const RadiusPacket& packet
                                       ) throw ()
{
   // Find the User-Name attribute.
   const RadiusAttribute* attr = FindAttribute(packet, RADIUS_USER_NAME);
   if (!attr) { return NULL; }

   // Map it to a server.
   RadiusRawOctets key = { attr->value, attr->length };
   ServerBindingPtr avoidance = avoid.find(key);
   if (!avoidance) { return NULL; }

   return &avoidance->getServer();
}

void RadiusProxyEngine::setServerAvoidance(const Request& request) throw ()
{
   if ((request.getCode() != RADIUS_ACCESS_REQUEST) ||
       (request.getUserName().len == 0))
   {
      return;
   }

   // Do we already have an entry for this User-Name value.
   ServerBindingPtr avoidance = avoid.find(request.getUserName());
   if (avoidance)
   {
      // Make sure the server matches.
      avoidance->setServer(request.getServer());
      return;
   }

   // Otherwise, we'll have to create a new one.
   try
   {
      avoidance = new ServerBinding(
                         request.getUserName(),
                         request.getServer()
                         );
      avoid.insert(*avoidance);
   }
   catch (const std::bad_alloc&)
   {
      // We don't care if this fails.
   }
}

void RadiusProxyEngine::onReceive(
                            UDPSocket& socket,
                            ULONG_PTR key,
                            const SOCKADDR_IN& remoteAddress,
                            BYTE* buffer,
                            ULONG bufferLength
                            ) throw ()
{
   //////////
   // Set up the event struct. We'll fill in the other fields as we go along.
   //////////

   RadiusEvent event =
   {
      (RadiusPortType)key,
      eventNone,
      NULL,
      remoteAddress.sin_addr.s_addr,
      remoteAddress.sin_port,
      buffer,
      bufferLength,
      0
   };

   //////////
   // Validate the remote address.
   //////////

   RemoteServerPtr server = groups.findServer(
                                       remoteAddress.sin_addr.s_addr
                                       );
   if (!server)
   {
      reportEvent(event, eventInvalidAddress);
      return;
   }

   // Use the server as the event context.
   event.context = server;

   //////////
   // Validate the packet type.
   //////////

   if (bufferLength == 0)
   {
      reportEvent(event, eventUnknownType);
      return;
   }

   switch (MAKELONG(key, buffer[0]))
   {
      case MAKELONG(portAuthentication, RADIUS_ACCESS_ACCEPT):
         reportEvent(event, eventAccessAccept);
         break;

      case MAKELONG(portAuthentication, RADIUS_ACCESS_REJECT):
         reportEvent(event, eventAccessReject);
         break;

      case MAKELONG(portAuthentication, RADIUS_ACCESS_CHALLENGE):
         reportEvent(event, eventAccessChallenge);
         break;

      case MAKELONG(portAccounting, RADIUS_ACCOUNTING_RESPONSE):
         reportEvent(event, eventAccountingResponse);
         break;

      default:
         reportEvent(event, eventUnknownType);
         return;
   }

   //////////
   // Validate that the packet is properly formatted.
   //////////

   RadiusPacket* packet;
   ALLOC_PACKET_FOR_BUFFER(packet, buffer, bufferLength);
   if (!packet)
   {
      reportEvent(event, eventMalformedPacket);
      return;
   }

   // Unpack the attributes.
   UnpackBuffer(buffer, bufferLength, *packet);

   //////////
   // Validate that we were expecting this response.
   //////////

   // Look for our Proxy-State attribute.
   RadiusAttribute* proxyState = FindAttribute(
                                     *packet,
                                     RADIUS_PROXY_STATE
                                     );

   // If we didn't find it OR it's the wrong length OR it doesn't start with
   // our address, then we weren't expecting this packet.
   if (!proxyState ||
       proxyState->length != 8 ||
       memcmp(proxyState->value, &proxyAddress, 4))
   {
      reportEvent(event, eventUnexpectedResponse);
      return;
   }

   // Extract the request ID.
   ULONG requestID = ExtractUInt32(proxyState->value + 4);

   // Don't send the Proxy-State back to our client.
   --packet->end;
   memmove(
       proxyState,
       proxyState + 1,
       (packet->end - proxyState) * sizeof(RadiusAttribute)
       );

   // Look up the request object. We don't remove it yet because we don't know
   // if this is an authentic response.
   RequestPtr request = pending.find(requestID);
   if (!request)
   {
      // If it's not there, we'll assume that this is a packet that's
      // already been reported as a timeout.
      reportEvent(event, eventLateResponse);
      return;
   }

   // Get the actual server we used for the request in case there are multiple
   // servers defined for the same IP address.
   event.context = server = &request->getServer();

   const RemotePort& port = request->getPort();

   // Validate the packet source && identifier.
   if (!(port.address == remoteAddress) ||
       request->getIdentifier() != packet->identifier)
   {
      reportEvent(event, eventUnexpectedResponse);
      return;
   }

   //////////
   // Validate that the packet is authentic.
   //////////

   AuthResult authResult = AuthenticateAndDecrypt(
                               request->getAuthenticator(),
                               port.secret,
                               port.secret.length(),
                               buffer,
                               bufferLength,
                               *packet
                               );
   switch (authResult)
   {
      case AUTH_BAD_AUTHENTICATOR:
         reportEvent(event, eventBadAuthenticator);
         return;

      case AUTH_BAD_SIGNATURE:
         reportEvent(event, eventBadSignature);
         return;

      case AUTH_MISSING_SIGNATURE:
         reportEvent(event, eventMissingSignature);
         return;
   }

   //////////
   // At this point, all the tests have passed -- we have the real thing.
   //////////

   if (!pending.erase(requestID))
   {
      // It must have timed out while we were authenticating it.
      reportEvent(event, eventLateResponse);
      return;
   }

   // Update endpoint state.
   if (request->onReceive(packet->code))
   {
      // The server just came up, so notify the client.
      reportEvent(event, eventServerAvailable);
   }

   // Report the round-trip time.
   event.data = request->getRoundTripTime();
   reportEvent(event, eventRoundTrip);

   // Set the server affinity and clear the server avoidance.
   setServerAffinity(*packet, *server);
   clearServerAvoidance(*packet, *server);

   // Take ownership of the context.
   PVOID context = request->getContext().takeOwnership();
   if (context)
   {
      // The magic moment -- we have successfully processed the response.
      client->onComplete(
                  resultSuccess,
                  context,
                  &request->getServer(),
                  packet->code,
                  packet->begin,
                  packet->end
                  );
   }
}

void RadiusProxyEngine::onReceiveError(
                            UDPSocket& socket,
                            ULONG_PTR key,
                            ULONG errorCode
                            ) throw ()
{
   RadiusEvent event =
   {
      (RadiusPortType)key,
      eventReceiveError,
      NULL,
      socket.getLocalAddress().address(),
      socket.getLocalAddress().port(),
      NULL,
      0,
      errorCode
   };

   client->onEvent(event);
}


RadiusProxyEngine::Result RadiusProxyEngine::sendRequest(
                                                 RadiusPacket& packet,
                                                 Request* request
                                                 ) throw ()
{
   // Fill in the packet identifier.
   packet.identifier = request->getIdentifier();

   // Get the info for the Signature.
   BOOL sign = request->getServer().sendSignature;

   // Format the Proxy-State attributes.
   BYTE proxyStateValue[8];
   RadiusAttribute proxyState = { RADIUS_PROXY_STATE, 8, proxyStateValue };

   // First our IP address ...
   memcpy(proxyStateValue, &proxyAddress, 4);
   // ... and then the unique request ID.
   InsertUInt32(proxyStateValue + 4, request->getRequestID());

   // Allocate a buffer to hold the packet on the wire.
   PBYTE buffer;
   ALLOC_BUFFER_FOR_PACKET(buffer, &packet, &proxyState, sign);
   if (!buffer) { return resultInvalidRequest; }

   // Get the port for this request.
   const RemotePort& port = request->getPort();

   // Generate the request authenticator if necessary.
   BYTE requestAuthenticator[16];
   if ((packet.code == RADIUS_ACCESS_REQUEST) &&
       (packet.authenticator == 0))
   {
      if (!CryptGenRandom(
              crypto,
              sizeof(requestAuthenticator),
              requestAuthenticator
              ))
      {
         return resultCryptoError;
      }

      packet.authenticator = requestAuthenticator;
   }

   // Pack the buffer.  packet.authenticator is used for CHAP when the request
   // authenticator is used for the chap-challenge. It can be null
   PackBuffer(
       port.secret,
       port.secret.length(),
       packet,
       &proxyState,
       sign,
       buffer
       );

   // Save the request authenticator and packet.
   request->setAuthenticator(buffer + 4);
   request->setPacket(packet);

   // Determine the request type.
   bool isAuth = request->isAccReq();

   // Set up the event struct.
   RadiusEvent event =
   {
      (isAuth ? portAuthentication : portAccounting),
      (isAuth ? eventAccessRequest : eventAccountingRequest),
      &request->getServer(),
      port.address.address(),
      port.address.port(),
      buffer,
      packet.length
   };

   // Get the appropriate socket.
   UDPSocket& sock = isAuth ? authSock : acctSock;

   // Insert the pending request before we send it to avoid a race condition.
   pending.insert(*request);

   // The magic moment -- we actually send the request.
   Result result;
   if (sock.send(port.address, buffer, packet.length))
   {
      // Update request state.
      request->onSend();

      // Set a timer to clean up if the server doesn't answer.
      if (timers.setTimer(request, request->getServer().timeout, 0))
      {
         result = resultSuccess;
      }
      else
      {
         // If we can't set at timer we have to remove it from the pending
         // requests table or else it could leak.
         pending.erase(*request);
         result = resultNotEnoughMemory;
      }
   }
   else
   {
      // Update the event with the error data.
      event.eventType = eventSendError;
      event.data = GetLastError();

      // If we received "Port Unreachable" ICMP packet, we'll count this as a
      // timeout since it means the server is unavailable.
      if (event.data == WSAECONNRESET) { request->onTimeout(); }

      // Remove from the pending requests table.
      pending.erase(*request);
   }

   // Report the event ...
   reportEvent(event);

   // ... and the result.
   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\radproxyp.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// FILE
//
//    radproxyp.h
//
// SYNOPSIS
//
//    Declares classes that are used in the implementation of RadiusProxy, but
//    need not be visible to clients.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef RADPROXYP_H
#define RADPROXYP_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <radpack.h>
#include <radproxy.h>
#include <timerq.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ProxyContext
//
// DESCRIPTION
//
//    Allows a request context to be shared by several Requests only one
//    of which will eventually take ownership.
//
///////////////////////////////////////////////////////////////////////////////
class ProxyContext
{
public:
   ProxyContext(PVOID p) throw ()
      : context(p)
   { }

   DECLARE_REFERENCE_COUNT();

   // Each context has an associated 'primary' server. This is the server that
   // will be used for event reporting if no one takes ownership of the
   // context.
   RemoteServer* getPrimaryServer() const throw()
   { return primary; }
   void setPrimaryServer(RemoteServer* server) throw ()
   { primary = server; }

   // Take ownership of the context. This will return NULL if someone has beat
   // you to it. If the caller is successful, he MUST ensure that
   // RadiusProxyClient::onComplete is always invoked exactly once.
   PVOID takeOwnership() throw ()
   { return InterlockedExchangePointer(&context, NULL); }

private:
   PVOID context;
   RemoteServerPtr primary;

   ~ProxyContext() throw ();

   // Not implemented.
   ProxyContext(const ProxyContext&);
   ProxyContext& operator=(const ProxyContext&);
};

typedef ObjectPointer<ProxyContext> ProxyContextPtr;

class RequestStack;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Request
//
// DESCRIPTION
//
//    Stores the state associated with a pending RADIUS request.
//
///////////////////////////////////////////////////////////////////////////////
class Request : public HashTableEntry, public Timer
{
public:
   Request(
       ProxyContext* context,
       RemoteServer* destination,
       BYTE packetCode
       ) throw ();

   //////////
   // Various accessors. There is a lot of state associated with a request.
   //////////

   const BYTE* getAuthenticator() const throw ()
   { return authenticator; }

   BYTE getCode() const throw ()
   { return code; }

   ProxyContext& getContext() const throw ()
   { return *ctxt; }

   // The RADIUS packet identifier for this request.
   BYTE getIdentifier() const throw ()
   { return identifier; }

   void setPacket(const RadiusPacket& packet);

   RadiusPortType getPortType() const throw ()
   { return isAccReq() ? portAuthentication : portAccounting; }

   const RemotePort& getPort() const throw ()
   { return port(); }

   // The unique ID used to identify this request internally. This is not the
   // same as the identifier sent on the wire.
   LONG getRequestID() const throw ()
   { return id; }

   // Returns the round trip time in hundredths of a second.
   ULONG getRoundTripTime() const throw ()
   { return (timeStamp + 50000) / 100000; }

   RemoteServer& getServer() const throw ()
   { return *dst; }

   const RadiusRawOctets& getUserName() const throw ()
   { return userName.get(); }

   // Returns true if the associated RADIUS request is an Access-Request.
   bool isAccReq() const throw ()
   { return code == RADIUS_ACCESS_REQUEST; }

   //////////
   // Set the request authenticator.
   //////////
   void setAuthenticator(const BYTE* p) throw ()
   { memcpy(authenticator, p, sizeof(authenticator)); }

   //////////
   // Methods for updating the request state. These events will be
   // automatically forwarded to the relevant RemoteServer.
   //////////

   // Returns 'true' if the server is now newly available.
   bool onReceive(BYTE code) throw ();

   void onSend() throw ()
   { timeStamp = GetSystemTime64(); dst->onSend(); }

   // Returns 'true' if the server is now newly unavailable.
   bool onTimeout() throw ()
   { return dst->onTimeout(); }

   //////////
   // Methods for storing requests in a HashTable and a TimerQueue.
   //////////

   virtual void AddRef() throw ();
   virtual void Release() throw ();

   virtual void onExpiry() throw ();

   virtual const void* getKey() const throw ();
   virtual bool matches(const void* key) const throw ();

   static ULONG WINAPI hash(const void* key) throw ();

private:
   RemotePort& port() const throw ()
   { return isAccReq() ? dst->authPort : dst->acctPort; }

   ProxyContextPtr ctxt;
   RemoteServerPtr dst;
   ULONG64 timeStamp;
   Count refCount;
   LONG id;                   // Unique ID stored in proxy state attribute.
   BYTE code;                 // Request code.
   BYTE identifier;           // Request identifier.
   BYTE authenticator[16];    // Request authenticator.
   RadiusOctets userName;     // RADIUS User-Name

   static LONG theNextRequestID;

   friend class RequestStack;

   // Not implemented.
   Request(const Request&);
   Request& operator=(const Request&);
};

typedef ObjectPointer<Request> RequestPtr;


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    RequestStack
//
// DESCRIPTION
//
//    Stores a collection of Requests.
//
//    Note: A Request can only be in one RequestStack, and it can not be
//    simultaneously store in a RequestStack and a HashTable.
//
///////////////////////////////////////////////////////////////////////////////
class RequestStack
{
public:
   RequestStack() throw ()
      : head(NULL)
   { }

   ~RequestStack() throw ()
   {
      while (!empty()) { pop(); }
   }

   bool empty() const throw ()
   { return head == NULL; }

   RequestPtr pop() throw ()
   {
      Request* top = head;
      head = static_cast<Request*>(head->next);
      return RequestPtr(top, false);
   }

   void push(Request* request) throw ()
   {
      request->next = head;
      head = request;
      request->AddRef();
   }

private:
   Request* head;

   // Not implemented.
   RequestStack(const RequestStack&);
   RequestStack& operator=(const RequestStack&);
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ServerBinding
//
// DESCRIPTION
//
//    Maps an octet string to a remote IP address. Used for server affinity and
//    avoidance.
//
///////////////////////////////////////////////////////////////////////////////
class ServerBinding : public CacheEntry
{
public:

   // The server that should be used for routing requests in this session.
   RemoteServer& getServer() const throw ()
   { return *server; }
   void setServer(RemoteServer& newVal) throw ()
   { server = &newVal; }

   ServerBinding(
       const RadiusRawOctets& key,
       RemoteServer& value
       )
      : state(key),
        server(&value)
   { }

   // Methods for storing a ServerBinding in a Cache.
   virtual void AddRef() throw ();
   virtual void Release() throw ();
   virtual const void* getKey() const throw ();
   virtual bool matches(const void* key) const throw ();
   static ULONG WINAPI hash(const void* key) throw ();

private:
   Count refCount;
   RadiusOctets state;
   RemoteServerPtr server;

   ~ServerBinding() throw () { }

   // Not implemented.
   ServerBinding(const ServerBinding&);
   ServerBinding& operator=(const ServerBinding&);
};

typedef ObjectPointer<ServerBinding> ServerBindingPtr;

#endif // RADPROXYP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\radshare.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    radutil.h
//
// SYNOPSIS
//
//    Declarations that are shared across the proxy and server components.
//
// MODIFICATION HISTORY
//
//    02/14/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef RADSHARE_H
#define RADSHARE_H
#if _MSC_VER >= 1000
#pragma once
#endif

//////////
// RADIUS port types
//////////
enum RadiusPortType
{
   portAuthentication,
   portAccounting
};

//////////
// RADIUS protocol events
//////////
enum RadiusEventType
{
   eventNone,
   eventInvalidAddress,
   eventAccessRequest,
   eventAccessAccept,
   eventAccessReject,
   eventAccessChallenge,
   eventAccountingRequest,
   eventAccountingResponse,
   eventMalformedPacket,
   eventBadAuthenticator,
   eventBadSignature,
   eventMissingSignature,
   eventTimeout,
   eventUnknownType,
   eventUnexpectedResponse,
   eventLateResponse,
   eventRoundTrip,
   eventSendError,
   eventReceiveError,
   eventServerAvailable,
   eventServerUnavailable
};

///////////////////////////////////////////////////////////////////////////////
//
// STRUCT
//
//    RadiusEvent
//
// DESCRIPTION
//
//    Used for reporting events from the RADIUS protocol layer.
//
///////////////////////////////////////////////////////////////////////////////
struct RadiusEvent
{
   RadiusPortType portType;
   RadiusEventType eventType;
   PVOID context;
   ULONG ipAddress;
   USHORT ipPort;
   const BYTE* packet;
   ULONG packetLength;
   ULONG data;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    RadiusString
//
// DESCRIPTION
//
//    Simple wrapper around a read-only string.
//
///////////////////////////////////////////////////////////////////////////////
class RadiusString
{
public:
   RadiusString(PCWSTR p)
   { alloc(p); }

   RadiusString(const RadiusString& x)
   { alloc(x.value); }

   RadiusString& operator=(const RadiusString& x)
   {
      if (this != &x)
      {
         delete[] value;
         value = NULL;
         alloc(x.value);
      }
      return *this;
   }

   ~RadiusString() throw ()
   { delete[] value; }

   operator PCWSTR() const throw ()
   { return value; }

   bool operator==(const RadiusString& s) const throw ()
   { return !wcscmp(value, s.value); }

private:
   PWSTR value;

   void alloc(PCWSTR p)
   { value = wcscpy(new WCHAR[wcslen(p) + 1], p); }
};


///////////////////////////////////////////////////////////////////////////////
//
// STRUCT
//
//    RadiusRawOctets
//
// DESCRIPTION
//
//    Plain ol' data.
//
///////////////////////////////////////////////////////////////////////////////
struct RadiusRawOctets
{
   BYTE* value;
   ULONG len;
};


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    RadiusOctets
//
// DESCRIPTION
//
//    Simple wrapper around a read-only octet string.
//
///////////////////////////////////////////////////////////////////////////////
class RadiusOctets : private RadiusRawOctets
{
public:
   RadiusOctets() throw ()
   { value = 0; len = 0; }

   RadiusOctets(const BYTE* buf, ULONG buflen)
   { alloc(buf, buflen); }

   RadiusOctets(const RadiusRawOctets& x)
   { alloc(x.value, x.len); }

   RadiusOctets(const RadiusOctets& x)
   { alloc(x.value, x.len); }

   RadiusOctets& operator=(const RadiusOctets& x)
   {
      assign(x.value, x.len);
      return *this;
   }

   ~RadiusOctets() throw ()
   { delete[] value; }

   void assign(const BYTE* buf, ULONG buflen)
   {
      if (value != buf)
      {
         delete[] value;
         value = 0;
         alloc(buf, buflen);
      }
   }

   const RadiusRawOctets& get() const throw ()
   { return *this; }

   ULONG length() const throw ()
   { return len; }

   operator const BYTE*() const throw ()
   { return value; }

   bool operator==(const RadiusOctets& o) const throw ()
   { return len == o.len && !memcmp(value, o.value, len); }

private:
   void alloc(const BYTE* buf, ULONG buflen)
   {
      value = (PBYTE)memcpy(new BYTE[buflen], buf, buflen);
      len = buflen;
   }
};

//////////
// Macro to add reference counting to a class definition.
//////////
#define DECLARE_REFERENCE_COUNT() \
private: \
   Count refCount; \
public: \
   void AddRef() throw () \
   {  ++refCount; } \
   void Release() throw () \
   { if (--refCount == 0) delete this; }

//////////
// Helper function to get system time as 64-bit integer.
//////////
inline ULONG64 GetSystemTime64() throw ()
{
   ULONG64 val;
   GetSystemTimeAsFileTime((FILETIME*)&val);
   return val;
}

#endif // RADSHARE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\rwlock.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    RWLock.cpp
//
// SYNOPSIS
//
//    This file implements the class RWLock.
//
// MODIFICATION HISTORY
//
//    09/04/1997    Original version.
//    09/30/1998    Fix bug with recursive LockExclusive calls.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <climits>
#include <iaswin32.h>

//////////
//  Large negative value used to block shared entry into the perimeter.
//////////
const LONG BLOCK_VALUE = (-LONG_MAX)/2;

RWLock::RWLock()
   : sharing(0),
     waiting(0),
     count(&sharing),
     sharedOK(NULL),
     exclusiveOK(NULL)
{
   bool success = false;

   do
   {
      sharedOK =    CreateSemaphore(NULL, 0, LONG_MAX, NULL);
      if (!sharedOK) { break; }

      exclusiveOK = CreateSemaphore(NULL, 0, 1, NULL);
      if (!exclusiveOK) { break; }

      if (!InitializeCriticalSectionAndSpinCount(&exclusive, 0x80001000))
      { break; }

      success = true;

   } while (FALSE);

   if (!success)
   {
      if (exclusiveOK) { CloseHandle(exclusiveOK); }
      if (sharedOK) { CloseHandle(sharedOK); }
      throw std::bad_alloc();
   }
}

RWLock::~RWLock() throw ()
{
   CloseHandle(exclusiveOK);
   CloseHandle(sharedOK);

   DeleteCriticalSection(&exclusive);
}

void RWLock::Lock() const throw ()
{
   // If this is less than zero, then an exlusive thread must have inserted
   // the BLOCK_VALUE, so ...
   if (InterlockedIncrement(count) <= 0)
   {
      // ... we have to wait until he's done.
      WaitForSingleObject(sharedOK, INFINITE);
   }
}

void RWLock::LockExclusive() throw ()
{
   // This limits exclusive access to a single thread.
   EnterCriticalSection(&exclusive);

   // The first time through we have to wait for the sharers to finish.
   if (exclusive.RecursionCount == 1)
   {
      // Block any new shared threads.
      waiting = BLOCK_VALUE;
      InterlockedExchangePointer((PVOID *)&count, &waiting);

      // Find out how many shared threads are already in the perimeter ...
      LONG sharingNow = InterlockedExchangeAdd(&sharing, BLOCK_VALUE);

      if (sharingNow > 0)
      {
         // ... and wait until they're done.
         WaitForSingleObject(exclusiveOK, INFINITE);
      }

      // At this point there is no one left inside the perimeter.
      sharing = 0;
   }
}

void RWLock::Unlock() const throw ()
{
   // If sharing is zero, we must be an exclusive thread.
   if (!sharing)
   {
      // Are we about to release our last lock ?
      if (exclusive.RecursionCount == 1)
      {
         // Allow any new shared access attempts.
         InterlockedExchangePointer((PVOID *)&count, &sharing);

         // Find out how many threads are waiting on the semaphore ...
         LONG waitingNow = waiting - BLOCK_VALUE;

         if (waitingNow > 0)
         {
            // ... and let them go.
            InterlockedExchangeAdd(count, waitingNow);
            ReleaseSemaphore(sharedOK, waitingNow, NULL);
         }
      }

      // Release the exclusive lock.
      LeaveCriticalSection(&exclusive);
   }
   else if (InterlockedDecrement(&sharing) == BLOCK_VALUE)
   {
      // If we end up here, we must have been the last shared thread out of
      // the perimeter while an exlusive thread is waiting, so wake him up.
      ReleaseSemaphore(exclusiveOK, 1, NULL) ;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\timerq.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    timerq.h
//
// SYNOPSIS
//
//    Declares the classes Timer and TimerQueue.
//
// MODIFICATION HISTORY
//
//    02/10/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef TIMERQ_H
#define TIMERQ_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <iaswin32.h>
#include <map>

class Timer;
class TimerQueue;

typedef std::multimap< ULONG64, Timer* > Timers;
typedef Timers::iterator TimerIterator;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Timer
//
// DESCRIPTION
//
//    Abstract base class for Timers that will be executed by a TimerQueue.
//
///////////////////////////////////////////////////////////////////////////////
class Timer
{
public:
   Timer() throw ()
      : queue(NULL)
   { }

   virtual void AddRef() throw() = 0;
   virtual void Release() throw () = 0;
   virtual void onExpiry() throw () = 0;

   void cancelTimer() throw ();

private:
   friend class TimerQueue;

   TimerQueue* queue;   // The current queue or NULL if the timer's not set.
   TimerIterator self;  // Location of this in the timer queue.
   ULONG period;        // Period of the timer or zero for one-shots.

   // Not implemented.
   Timer(const Timer&);
   Timer& operator=(const Timer&);
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    TimerQueue
//
// DESCRIPTION
//
//    Implements a queue of timers.
//
///////////////////////////////////////////////////////////////////////////////
class TimerQueue : IAS_CALLBACK
{
public:
   TimerQueue();
   ~TimerQueue() throw ();

   // Set a timer in this queue.
   bool setTimer(
            Timer* timer,
            ULONG dueTime,
            ULONG period
            ) throw ();

   // Cancels all timers. This will block until any executing callbacks have
   // completed.
   void cancelAllTimers() throw ();

private:

   friend class Timer;

   void cancelTimer(Timer* timer) throw ();

   // Create a new thread to watch the queue.
   void createWatcher() throw ();

   // Wait for the next timer to expire and execute it.
   void executeOneTimer() throw ();

   // Add a timer to the queue.
   bool queueTimer(Timer* timer, ULONG dueTime) throw ();

   // Callback routine for watchers.
   static void startRoutine(PIAS_CALLBACK This) throw ();

   CriticalSection monitor;  // Serialize access.
   Event nudge;              // Nudge the watcher to recheck the queue.
   Event idle;               // Have all watchers exited?
   Timers queue;             // Set of timers orderd by expiry.
   Count useCount;           // Zero when the queue is idle.
   bool hasWatcher;          // true if the pool has a watcher thread.

   // Not implemented.
   TimerQueue(const TimerQueue&);
   TimerQueue& operator=(const TimerQueue&);
};

#endif // TIMERQ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\timerq.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    timerq.cpp
//
// SYNOPSIS
//
//    Defines the class TimerQueue.
//
// MODIFICATION HISTORY
//
//    02/10/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <timerq.h>

void Timer::cancelTimer() throw ()
{
   TimerQueue* ourQueue = queue;
   if (ourQueue)
   {
      ourQueue->cancelTimer(this);
   }
}

TimerQueue::TimerQueue()
   : idle(TRUE), hasWatcher(false)
{
   CallbackRoutine = startRoutine;

   // We bump up the use count to prevent the idle event from being
   // continuously set and reset.
   ++useCount;
}

TimerQueue::~TimerQueue() throw ()
{
   cancelAllTimers();
}

inline void TimerQueue::createWatcher() throw ()
{
   if (IASRequestThread(this)) { hasWatcher = TRUE; }
}

bool TimerQueue::setTimer(
                     Timer* timer,
                     ULONG dueTime,
                     ULONG period
                     ) throw ()
{
   // Make sure it's not already set.
   timer->cancelTimer();

   // Set the timer's period.
   timer->period = period;

   monitor.lock();

   // Add it to the queue ...
   bool success = queueTimer(timer, dueTime);

   // .. and ensure we have someone to watch it.
   if (success && !hasWatcher) { createWatcher(); }

   monitor.unlock();

   return success;
}

void TimerQueue::cancelAllTimers() throw ()
{
   monitor.lock();

   // Release the references.
   for (TimerIterator i = queue.begin(); i != queue.end(); ++i)
   {
      i->second->queue = NULL;
      i->second->Release();
   }

   // Clear the queue.
   queue.clear();

   // Allow the use count to go to zero, so the idle event will be set.
   if (--useCount == 0) { idle.set(); }

   monitor.unlock();

   // Wake up the watcher, so he'll see the queue is empty.
   nudge.set();

   // Wait until we're idle, ...
   idle.wait();

   // ... then put the useCount back up.
   ++useCount;
}

void TimerQueue::cancelTimer(Timer* timer) throw ()
{
   monitor.lock();

   // Make sure this is from the right queue. We checked this is
   // Timer::cancelTimer, but we need to do it again now that we hold the lock.
   if (timer->queue == this)
   {
      // Remove it from the queue.
      queue.erase(timer->self);
      timer->queue = NULL;

      // Release the reference we added in queueTimer.
      timer->Release();

      // Normally, we won't bother to wake the watcher, but if this was the last
      // timer, we'll let him exit.
      if (queue.empty()) { nudge.set(); }
   }

   monitor.unlock();
}

void TimerQueue::executeOneTimer() throw ()
{
   // The timer to be executed.
   Timer* timer = NULL;

   monitor.lock();

   // Loop until either we get a timer or the queue is empty.
   while (!queue.empty())
   {
      ULONG64 now = GetSystemTime64();

      // Has the next timer expired ?
      if (now >= queue.begin()->first)
      {
         // Yes, so save it for later.
         timer = queue.begin()->second;

         // Remove it from the queue.
         queue.erase(queue.begin());
         timer->queue = NULL;

         // If it's recurrent, set it again.
         if (timer->period) { queueTimer(timer, timer->period); }

         break;
      }

      // Calculate the time until the next timer expires ...
      ULONG timeout = (queue.begin()->first - now) / 10000;

      monitor.unlock();

      // ... and wait.
      nudge.wait(timeout);

      monitor.lock();
   }

   // We're not watching the queue anymore.
   hasWatcher = false;

   // Do we need a replacement?
   if (!queue.empty()) { createWatcher(); }

   monitor.unlock();

   if (timer)
   {
      // Invoke the callback.
      timer->onExpiry();

      // Release the reference we added in queueTimer.
      timer->Release();
   }

   // We're exiting, so drop the useCount.
   if (--useCount == 0) { idle.set(); }
}

bool TimerQueue::queueTimer(Timer* timer, ULONG dueTime) throw ()
{
   // NOTE: You must hold the lock when calling this method.

   ULONG64 expiry = GetSystemTime64() + dueTime * 10000i64;

   bool success;

   try
   {
      // Insert the timer into the queue.
      timer->self = queue.insert(Timers::value_type(expiry, timer));

      // If this is the next timer to expire, we need to nudge the watcher.
      if (timer->self == queue.begin()) { nudge.set(); }

      timer->queue = this;

      timer->AddRef();

      success = true;
   }
   catch (const std::bad_alloc&)
   {
      success = false;
   }

   return success;
}

void TimerQueue::startRoutine(PIAS_CALLBACK This) throw ()
{
   static_cast<TimerQueue*>(This)->executeOneTimer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\translate.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    translate.cpp
//
// SYNOPSIS
//
//    Defines the class Translator.
//
// MODIFICATION HISTORY
//
//    02/04/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef TRANSLATE_H
#define TRANSLATE_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <attrdnry.h>
#include <iastlutl.h>
using namespace IASTL;

struct RadiusAttribute;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Translator
//
///////////////////////////////////////////////////////////////////////////////
class Translator
{
public:
   HRESULT FinalConstruct() throw ();

   // Converts an IAS attribute to RADIUS format and stores it in dst.
   void toRadius(
            IASATTRIBUTE& src,
            IASAttributeVector& dst
            ) const;

   // Convert a RADIUS attribute to IAS format and stores it in dst.
   void fromRadius(
            const RadiusAttribute& src,
            DWORD flags,
            IASAttributeVector& dst
            );

protected:
   // Decodes an RADIUS attribute value into dst.
   static void decode(
                   IASTYPE dstType,
                   const BYTE* src,
                   ULONG srclen,
                   IASAttribute& dst
                   );

   // Returns the number of bytes required to encode src.
   static ULONG getEncodedSize(
                    const IASATTRIBUTE& src
                    );

   // Encodes src into dst. dst must be long enough to hold the result.
   static void encode(
                   PBYTE dst,
                   const IASATTRIBUTE& src
                   ) throw ();

   // Encodes src into dst. Returns the length of the encode data (not counting
   // the header).
   static ULONG encode(
                    ULONG headerLength,
                    const IASATTRIBUTE& src,
                    IASAttribute& dst
                    );

   // Breaks src into multiple attributes if necessary and stores the result in
   // dst.
   static void scatter(
                   ULONG headerLength,
                   IASATTRIBUTE& src,
                   IASAttributeVector& dst
                   );

private:
   AttributeDictionary dnary;
};

#endif // TRANSLATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\translate.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    translate.cpp
//
// SYNOPSIS
//
//    Defines the class Translator.
//
// MODIFICATION HISTORY
//
//    02/04/2000    Original version.
//    04/17/2000    Add support for UTCTime.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <iasutil.h>
#include <attrdnry.h>
#include <radpack.h>
#include <translate.h>

//////////
// The offset between the UNIX and NT epochs.
//////////
const ULONG64 UNIX_EPOCH = 116444736000000000ui64;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ByteSource
//
// DESCRIPTION
//
//    Simple class for extracting bytes from an octet string.
//
///////////////////////////////////////////////////////////////////////////////
class ByteSource
{
public:
   ByteSource(const BYTE* buf, ULONG buflen) throw ()
      : next(buf), last(buf + buflen) { }

   // Returns true if there are any bytes remaining.
   bool more() const throw ()
   {
      return next != last;
   }

   // Extracts 'nbyte' bytes.
   const BYTE* extract(ULONG nbyte)
   {
      const BYTE* retval = next;

      // Update the cursor.
      next += nbyte;

      // Did we overflow ?
      if (next > last) { _com_issue_error(E_INVALIDARG); }

      return retval;
   }

   ULONG remaining() const throw ()
   {
      return (ULONG)(last - next);
   }

protected:
   const BYTE* next;  // The next byte in the stream.
   const BYTE* last;  // The end of the stream.

private:
   // Not implemented.
   ByteSource(const ByteSource&);
   ByteSource& operator=(const ByteSource&);
};


HRESULT Translator::FinalConstruct() throw ()
{
   return dnary.FinalConstruct();
}

void Translator::toRadius(
                     IASATTRIBUTE& src,
                     IASAttributeVector& dst
                     ) const
{

   if (src.dwId > 0 && src.dwId < 256)
   {
      // This is already a RADIUS attribute, so all we have to do is convert
      // the value to an octet string.
      if (src.Value.itType == IASTYPE_OCTET_STRING)
      {
         // It's already an octet string, so just scatter into dst.
         scatter(0, src, dst);
      }
      else
      {
         // Convert to an octet string ...
         IASAttribute attr(true);
         encode(0, src, attr);

         // ... and scatter into dst.
         scatter(0, *attr, dst);
      }
   }
   else
   {
      // Look up the attribute definition.
      const AttributeDefinition* def = dnary.findByID(src.dwId);

      // We only process VSAs. At this point, anything else is an internal
      // attribute that has no RADIUS representation.
      if (def && def->vendorID)
      {
         // Allocate an attribute for the VSA.
         IASAttribute attr(true);

         // USR uses a different header than everybody else.
         ULONG headerLength = (def->vendorID != 429) ? 6 : 8;

         // Encode the data.
         ULONG dataLength = encode(headerLength, src, attr);

         // Pack the Vendor-Id.
         PBYTE buf = attr->Value.OctetString.lpValue;
         IASInsertDWORD(buf, def->vendorID);
         buf += 4;

         // Pack the Vendor-Type and Vendor-Length;
         if (def->vendorID != 429)
         {
            *buf++ = (BYTE)def->vendorType;
            *buf++ = (BYTE)(dataLength + 2);
         }
         else
         {
            IASInsertDWORD(buf, def->vendorType);
            buf += 4;
         }

         // Mark it as a VSA.
         attr->dwId = RADIUS_ATTRIBUTE_VENDOR_SPECIFIC;

         // Scatter into multiple attributes if necessary.
         scatter(headerLength, *attr, dst);
      }
   }
}


void Translator::fromRadius(
            const RadiusAttribute& src,
            DWORD flags,
            IASAttributeVector& dst
            )
{
   if (src.type != RADIUS_ATTRIBUTE_VENDOR_SPECIFIC)
   {
      // Look this up in the dictionary.
      const AttributeDefinition* def = dnary.findByID(src.type);

      // If we don't recognize the attribute, treat it as an octet string.
      IASTYPE syntax = def ? (IASTYPE)def->syntax : IASTYPE_OCTET_STRING;

      // Create the new attribute.
      IASAttribute attr(true);
      attr->dwId = src.type;
      attr->dwFlags = flags;
      decode(syntax, src.value, src.length, attr);

      // Add to the destination vector.
      dst.push_back(attr);
   }
   else
   {
      // Create a byte source from the attribute value.
      ByteSource bytes(src.value, src.length);

      // Extract the vendor ID.
      ULONG vendorID = IASExtractDWORD(bytes.extract(4));

      // Loop through the value and convert each sub-VSA.
      do
      {
         // Extract the Vendor-Type and the data length.
         ULONG type, length;
         if (vendorID != 429)
         {
            type = *bytes.extract(1);
            length = *bytes.extract(1) - 2;
         }
         else
         {
            type = IASExtractDWORD(bytes.extract(4));
            length = bytes.remaining();
         }

         // Do we have this VSA in our dictionary ?
         const AttributeDefinition* def = dnary.findByVendorInfo(
                                                     vendorID,
                                                     type
                                                     );
         if (!def)
         {
            // No, so we'll just leave it 'as is'.
            IASAttribute attr(true);
            attr->dwId = RADIUS_ATTRIBUTE_VENDOR_SPECIFIC;
            attr->dwFlags = flags;
            attr.setOctetString(src.length, src.value);

            dst.push_back(attr);
            break;
         }

         // Yes, so we can decode this properly.
         IASAttribute attr(true);
         attr->dwId = def->id;
         attr->dwFlags = flags;
         decode((IASTYPE)def->syntax, bytes.extract(length), length, attr);

         dst.push_back(attr);

      } while (bytes.more());
   }
}


void Translator::decode(
                     IASTYPE dstType,
                     const BYTE* src,
                     ULONG srclen,
                     IASAttribute& dst
                     )
{
   // Switch based on the destination type.
   switch (dstType)
   {
      case IASTYPE_BOOLEAN:
      {
         if (srclen != 4) { _com_issue_error(E_INVALIDARG); }
         dst->Value.Boolean = IASExtractDWORD(src) ? TRUE : FALSE;
         break;
      }

      case IASTYPE_INTEGER:
      case IASTYPE_ENUM:
      case IASTYPE_INET_ADDR:
      {
         if (srclen != 4) { _com_issue_error(E_INVALIDARG); }
         dst->Value.Integer = IASExtractDWORD(src);
         break;
      }

      case IASTYPE_UTC_TIME:
      {
         if (srclen != 4) { _com_issue_error(E_INVALIDARG); }

         // Extract the UNIX time.
         ULONG64 val = IASExtractDWORD(src);

         // Convert from seconds to 100 nsec intervals.
         val *= 10000000;

         // Shift to the NT epoch.
         val += 116444736000000000ui64;

         // Split into the high and low DWORDs.
         dst->Value.UTCTime.dwLowDateTime = (DWORD)val;
         dst->Value.UTCTime.dwHighDateTime = (DWORD)(val >> 32);

         break;
      }

      case IASTYPE_STRING:
      {
         dst.setString(srclen, src);
         break;
      }

      default:
      {
         dst.setOctetString(srclen, src);
         break;
      }
   }

   // All went well, so set type attribute type.
   dst->Value.itType = dstType;
}


ULONG Translator::getEncodedSize(
                      const IASATTRIBUTE& src
                      ) 
{
   // Note: this is the same as RadiusUtil::getEncodedSize
   // only one version should be kept
   ULONG size;
   switch (src.Value.itType)
   {
      case IASTYPE_BOOLEAN:
      case IASTYPE_INTEGER:
      case IASTYPE_ENUM:
      case IASTYPE_INET_ADDR:
      case IASTYPE_UTC_TIME:
      {
         size = 4;
         break;
      }

      case IASTYPE_STRING:
      {
         // Convert the string to ANSI so we can count octets.
         DWORD dwErr = IASAttributeAnsiAlloc(const_cast<PIASATTRIBUTE>(&src));
         if (dwErr != NO_ERROR)
         {
            _com_issue_error(HRESULT_FROM_WIN32(dwErr));
         }

         // Allow for NULL strings and don't count the terminator.
         if (src.Value.String.pszAnsi)
         {
            size = strlen(src.Value.String.pszAnsi);
         }
         else
         {
            size = 0;
         }
         break;
      }

      case IASTYPE_OCTET_STRING:
      {
         size = src.Value.OctetString.dwLength;
         break;
      }

      default:
         // All other types have no wire representation.
         size = 0;
   }

   return size;
}


void Translator::encode(
                     PBYTE dst,
                     const IASATTRIBUTE& src
                     ) throw ()
{
   // Switch based on the source's type.
   switch (src.Value.itType)
   {
      case IASTYPE_BOOLEAN:
      {
         IASInsertDWORD(dst, (src.Value.Boolean ? 1 : 0));
         break;
      }

      case IASTYPE_INTEGER:
      case IASTYPE_ENUM:
      case IASTYPE_INET_ADDR:
      {
         IASInsertDWORD(dst, src.Value.Integer);
         break;
      }

      case IASTYPE_STRING:
      {
         const BYTE* p = (const BYTE*)src.Value.String.pszAnsi;

         // Don't use strcpy since we don't want the null terminator.
         if (p)
         {
            while (*p) { *dst++ = *p++; }
         }

         break;
      }

      case IASTYPE_UTC_TIME:
      {
         ULONG64 val;

         // Move in the high DWORD.
         val   = src.Value.UTCTime.dwHighDateTime;
         val <<= 32;

         // Move in the low DWORD.
         val  |= src.Value.UTCTime.dwLowDateTime;

         // Convert to the UNIX epoch.
         val  -= UNIX_EPOCH;

         // Convert to seconds.
         val  /= 10000000;

         IASInsertDWORD(dst, (DWORD)val);

         break;
      }

      case IASTYPE_OCTET_STRING:
      {
         memcpy(dst,
                src.Value.OctetString.lpValue,
                src.Value.OctetString.dwLength);
      }
   }
}


ULONG Translator::encode(
                      ULONG headerLength,
                      const IASATTRIBUTE& src,
                      IASAttribute& dst
                      )
{
   // Compute the encoded size.
   ULONG dataLength = getEncodedSize(src);
   ULONG attrLength = dataLength + headerLength;

   // Allocate a buffer for the value.
   PBYTE buf = (PBYTE)CoTaskMemAlloc(attrLength);
   if (!buf) { _com_issue_error(E_OUTOFMEMORY); }

   // Encode the data.
   encode(buf + headerLength, src);

   // Store the buffer in the attribute.
   dst->dwId = src.dwId;
   dst->dwFlags = src.dwFlags;
   dst->Value.itType = IASTYPE_OCTET_STRING;
   dst->Value.OctetString.dwLength = attrLength;
   dst->Value.OctetString.lpValue = buf;

   return dataLength;
}


void Translator::scatter(
                     ULONG headerLength,
                     IASATTRIBUTE& src,
                     IASAttributeVector& dst
                     )
{
   if (src.Value.OctetString.dwLength <= 253)
   {
      // If the attribute is already small enough, then there's nothing to do.
      dst.push_back(&src);
   }
   else
   {
      // Maximum length of data that can be store in each attribute.
      ULONG maxDataLength = 253 - headerLength;

      // Number of bytes remaining to be scattered.
      ULONG remaining = src.Value.OctetString.dwLength - headerLength;

      // Next byte to be scattered.
      PBYTE next = src.Value.OctetString.lpValue + headerLength;

      do
      {
         // Allocate an attribute for the next chunk.
         IASAttribute chunk(true);

         // Compute the data length and attribute length for this chunk.
         ULONG dataLength = min(remaining, maxDataLength);
         ULONG attrLength = dataLength + headerLength;

         // Allocate a buffer for the value.
         PBYTE buf = (PBYTE)CoTaskMemAlloc(attrLength);
         if (!buf) { _com_issue_error(E_OUTOFMEMORY); }

         // Copy in the header ...
         memcpy(buf, src.Value.OctetString.lpValue, headerLength);
         // ... and the next chunk of data.
         memcpy(buf + headerLength, next, dataLength);

         // Store the buffer in the attribute.
         chunk->dwId = src.dwId;
         chunk->dwFlags = src.dwFlags;
         chunk->Value.itType = IASTYPE_OCTET_STRING;
         chunk->Value.OctetString.dwLength = attrLength;
         chunk->Value.OctetString.lpValue = buf;

         // Append to the destination vector.
         dst.push_back(chunk);

         // Advance to the next chunk.
         remaining -= dataLength;
         next += dataLength;

      } while (remaining);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\client.h ===
//#--------------------------------------------------------------
//
//  File:       client.h
//
//  Synopsis:   This file holds the declarations of the
//            CClient class
//
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _CLIENT_H_
#define _CLIENT_H_

#include "radcommon.h"
#include "iasradius.h"
#include "resource.h"

#define MAX_SECRET_SIZE         255
#define MAX_CLIENT_SIZE         255
#define MAX_CLIENTNAME_SIZE     255

class CClient :
    public IIasClient,
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CClient, &__uuidof (CClient)>
{

public:

//
//  registry declaration for the Client Object
//
IAS_DECLARE_REGISTRY (CClient, 1, 0, IASRadiusLib)

//
//  this component is non-aggregatable
//
DECLARE_NOT_AGGREGATABLE (CClient)

//
// macros for ATL required methods
//
BEGIN_COM_MAP (CClient)
    COM_INTERFACE_ENTRY_IID (__uuidof(CClient), CClient)
    COM_INTERFACE_ENTRY (IIasClient)
END_COM_MAP ()

public:
   STDMETHOD_(DWORD, GetAddress)();

   STDMETHOD_(BOOL, NeedSignatureCheck)();

   STDMETHOD_(LONG, GetVendorType)();

   STDMETHOD_(LPCWSTR, GetClientNameW)();

   STDMETHOD_(LPCWSTR, GetClientAddressW)();

   STDMETHOD_(const BYTE*, GetSecret)(DWORD* pdwSecretSize);

   STDMETHOD(Init)(ISdo* pISdo);

   STDMETHOD(ResolveAddress)();

   CClient();

   virtual ~CClient();

    struct Address
    {
       ULONG ipAddress;
       ULONG width;
    };

   const Address* GetAddressList() throw ()
   { return m_adwAddrList; }

protected:
   void ClearAddress() throw ();

private:
    HRESULT SetAddress (const VARIANT& varAddress) throw ();

    BOOL SetSecret (
            /*[in]*/    VARIANT varSecret
            );

    HRESULT SetClientName(const VARIANT& varClientName) throw ();


    BOOL SetSignatureFlag (
            /*[in]*/    VARIANT varSigFlag
            );

    BOOL SetVendorType (
            /*[in]*/    VARIANT varAddress
            );

   Address   m_adwAddressBuffer[2];
   Address*  m_adwAddrList;

   CHAR    m_szSecret[MAX_SECRET_SIZE + 1];

   WCHAR   m_wszClientName[MAX_CLIENTNAME_SIZE + 1];

    WCHAR   m_wszClientAddress[MAX_CLIENT_SIZE +1];

    DWORD   m_dwSecretSize;

    BOOL    m_bSignatureCheck;

    INT     m_lVendorType;

};

#endif // ifndef _CLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\udpsock.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    udpsock.h
//
// SYNOPSIS
//
//    Declares the classes PacketReceiver and UDPSocket.
//
// MODIFICATION HISTORY
//
//    02/05/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef UDPSOCK_H
#define UDPSOCK_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <winsock2.h>

class UDPSocket;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    InternetAddress
//
// DESCRIPTION
//
//    Simple wrapper around a SOCKADDR_IN
//
///////////////////////////////////////////////////////////////////////////////
struct InternetAddress : public SOCKADDR_IN
{
   InternetAddress(ULONG address = INADDR_ANY, USHORT port = 0)
   {
      sin_family = AF_INET;
      sin_port = port;
      sin_addr.s_addr = address;
      memset(sin_zero, 0, sizeof(sin_zero));
   }

   InternetAddress(const SOCKADDR_IN& sin) throw ()
   { *this = sin; }

   const SOCKADDR_IN& operator=(const SOCKADDR_IN& sin) throw ()
   {
      sin_port = sin.sin_port;
      sin_addr.s_addr = sin.sin_addr.s_addr;
      return *this;
   }

   USHORT port() const throw ()
   { return sin_port; }
   void port(USHORT newPort) throw ()
   { sin_port = newPort; }

   ULONG address() const throw ()
   { return sin_addr.s_addr; }
   void address(ULONG newAddress) throw ()
   { sin_addr.s_addr = newAddress; }

   bool operator==(const SOCKADDR_IN& sin) const throw ()
   {
      return sin_port == sin.sin_port &&
             sin_addr.s_addr == sin.sin_addr.s_addr;
   }

   operator const SOCKADDR*() const throw ()
   { return (const SOCKADDR*)this; }
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    PacketReceiver
//
// DESCRIPTION
//
//    Implemented by classes that receive packets from a UDPSocket.
//
///////////////////////////////////////////////////////////////////////////////
class PacketReceiver
{
public:
   virtual void onReceive(
                    UDPSocket& socket,
                    ULONG_PTR key,
                    const SOCKADDR_IN& remoteAddress,
                    BYTE* buffer,
                    ULONG bufferLength
                    ) throw () = 0;

   virtual void onReceiveError(
                    UDPSocket& socket,
                    ULONG_PTR key,
                    ULONG errorCode
                    ) throw () = 0;
};


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    UDPSocket
//
// DESCRIPTION
//
//    Listens and sends on a UDP socket.
//
///////////////////////////////////////////////////////////////////////////////
class UDPSocket : public IAS_CALLBACK
{
public:
   UDPSocket() throw ();
   ~UDPSocket() throw ();

   const InternetAddress& getLocalAddress() const throw ()
   { return localAddress; }

   bool isOpen() const throw ()
   { return idle != NULL; }

   BOOL open(
            PacketReceiver* sink,
            ULONG_PTR recvKey = 0,
            const SOCKADDR_IN* address = NULL
            ) throw ();
   void close() throw ();

   BOOL send(
            const SOCKADDR_IN& to,
            const BYTE* buffer,
            ULONG bufferLength
            ) throw ();

   bool operator==(const UDPSocket& socket) const throw ()
   { return localAddress == socket.localAddress; }

protected:
   // Create a new thread to listen on the port.
   BOOL createReceiveThread() throw ();

   // Receive data from the port.
   bool receive() throw ();

   // Receive thread start routine.
   static void startRoutine(PIAS_CALLBACK This) throw ();

private:
   PacketReceiver* receiver;       // Our client.
   ULONG_PTR key;                  // Our client's key.
   SOCKET sock;                    // The UDP socket.
   InternetAddress localAddress;   // The address the socket is bound to.
   BOOL closing;                   // Signals the receiver that we're closing.
   HANDLE idle;                    // Signals that the receiver has exited.
   BYTE buffer[4096];              // Receive buffer.

   // Not implemented.
   UDPSocket(const UDPSocket&);
   UDPSocket& operator=(const UDPSocket&);
};

#endif  // UDPSOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\client.cpp ===
//#--------------------------------------------------------------
//
//  File:      client.cpp
//
//  Synopsis:   Implementation of CClient class methods
//
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "client.h"
#include "iasevent.h"
#include <iasutil.h>
#include <memory>
#include "strsafe.h"

inline BOOL IsDottedDecimal(PCWSTR sz) throw ()
{
   return wcsspn(sz, L"0123456789./") == wcslen(sz);
}


STDMETHODIMP_(DWORD) CClient::GetAddress()
{
   return m_adwAddrList[0].ipAddress;
}


STDMETHODIMP_(BOOL) CClient::NeedSignatureCheck()
{
   return m_bSignatureCheck;
}


STDMETHODIMP_(LONG) CClient::GetVendorType()
{
   return m_lVendorType;
}


STDMETHODIMP_(LPCWSTR) CClient::GetClientNameW()
{
   return m_wszClientName;
}


STDMETHODIMP_(LPCWSTR) CClient::GetClientAddressW()
{
   return m_wszClientAddress;
}


STDMETHODIMP_(const BYTE*) CClient::GetSecret(DWORD* pdwSecretSize)
{
   if (pdwSecretSize != 0)
   {
      *pdwSecretSize = m_dwSecretSize;
   }

   return reinterpret_cast<const BYTE*>(m_szSecret);
}


//++--------------------------------------------------------------
//
//  Function:   CClient
//
//  Synopsis:   This is the constructor of the Client class
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//  History:    MKarki      Created     9/26/97
//
//----------------------------------------------------------------
CClient::CClient (
            VOID
            )
            : m_adwAddrList (m_adwAddressBuffer),
              m_lVendorType (0),
              m_bSignatureCheck (FALSE)
{
   m_adwAddressBuffer[0].ipAddress = INADDR_NONE;
   ZeroMemory (m_szSecret, MAX_SECRET_SIZE + 1);

}   //  end of CClient constructor

//++--------------------------------------------------------------
//
//  Function:   ~CClient
//
//  Synopsis:   This is the destructor of the Client class
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//  History:    MKarki      Created     9/26/97
//
//----------------------------------------------------------------
CClient::~CClient(
            VOID
            )
{
   ClearAddress();
}   //  end of CClient constructor


//++--------------------------------------------------------------
//
//  Function:   Init
//
//  Synopsis:   This is the CClient public method used
//              to initialize the object with the
//              ISdo interface
//
//  Arguments:
//              [in]    ISdo*
//
//  Returns:    NONE
//
//  History:    MKarki      Created     9/26/97
//
//  Called By:  CClients::SetClients public method
//
//----------------------------------------------------------------
STDMETHODIMP
CClient::Init (
            ISdo *pISdo
            )
{
    BOOL        bStatus = FALSE;
    HRESULT     hr = S_OK;
    CComVariant varClient;

    _ASSERT (pISdo);

    //
    //  get the client address first
    //
    hr = pISdo->GetProperty (PROPERTY_CLIENT_ADDRESS, &varClient);
    if  (FAILED (hr))
    {
        IASTracePrintf (
            "Unable to obtain Client Address Property "
            "during Client object initialization"
            );
        hr = E_FAIL;
        return (hr);
    }

    //
    // store the address
    //
    hr = SetAddress (varClient);
    if (FAILED(hr))
    {
        return hr;
    }

    varClient.Clear ();

    //
    //  get the client address first
    //
    hr = pISdo->GetProperty (PROPERTY_CLIENT_SHARED_SECRET, &varClient);
    if  (FAILED (hr))
    {
        IASTracePrintf (
            "Unable to obtain Client shared secret Property "
            "during Client object initialization"
            );
       return (hr);
    }

    //
    // now store away the shared secret
    //
    bStatus = SetSecret (varClient);
    if (FALSE == bStatus)
    {
        hr = E_FAIL;
        return (hr);
    }

    varClient.Clear ();

    //
    //  get signature information
    //
    hr = pISdo->GetProperty (PROPERTY_CLIENT_REQUIRE_SIGNATURE, &varClient);
    if  (FAILED (hr))
    {
        IASTracePrintf (
            "Unable to obtain Client Signature Property "
            "during Client object initialization"
            );
        return (hr);
    }

    //
    //  store away the signature information
    //
    bStatus = SetSignatureFlag (varClient);
    if (FALSE == bStatus)
    {
        hr = E_FAIL;
        return (hr);
    }

    varClient.Clear ();

    //
    //  get the client NAS Manufacturer information
    //
    hr = pISdo->GetProperty (PROPERTY_CLIENT_NAS_MANUFACTURER, &varClient);
    if  (FAILED (hr))
    {
        IASTracePrintf (
            "Unable to obtain Client NAS Manufacturer Property "
            "during Client object initialization"
            );
        return (hr);
    }

    //
    //  store away the Nas Manufacturer information
    //
    bStatus = SetVendorType (varClient);
    if (FALSE == bStatus)
    {
        hr = E_FAIL;
        return (hr);
    }

    varClient.Clear ();

    //
    //  get the client name
    //
    hr = pISdo->GetProperty (PROPERTY_SDO_NAME, &varClient);
    if  (FAILED (hr))
    {
        IASTracePrintf (
            "Unable to obtain SDO Name Property "
            "during Client object initialization"
            );
        return (hr);
    }

    //
    //  store away the client name information
    //
    hr = SetClientName (varClient);
    if (FAILED(hr))
    {
        return hr;
    }

    varClient.Clear ();

    return (hr);

}   //  end of CClient::Init method

void CClient::ClearAddress() throw ()
{
   if (m_adwAddrList != m_adwAddressBuffer)
   {
      delete[] m_adwAddrList;
   }

   m_adwAddressBuffer[0].ipAddress = INADDR_NONE;
   m_adwAddrList = m_adwAddressBuffer;
}

HRESULT CClient::SetAddress(const VARIANT& varAddress) throw ()
{
   if (V_VT(&varAddress) != VT_BSTR)
   {
      return E_INVALIDARG;
   }

   return StringCchCopyW(
             m_wszClientAddress,
             RTL_NUMBER_OF(m_wszClientAddress),
             V_BSTR(&varAddress)
             );
}

//++--------------------------------------------------------------
//
//  Function:   ResolveAddress
//
//  Synopsis:   This is the CClient public method used
//              to resolve the Client IP address obtained previously
//              which could be a DNS name or dotted octed
//
//  Arguments:  VOID
//
//  Returns:    HRESULT
//
//  History:    MKarki      Created     2/3/98
//
//  Called By: CClient::Init method
//
//----------------------------------------------------------------
STDMETHODIMP
CClient::ResolveAddress (
    VOID
    )
{
    INT             iRetVal = 0;
    PHOSTENT        pHostent = NULL;
    BOOL            bDNSName = FALSE;
    BOOL            bRetVal = TRUE;
    CHAR            szClient[MAX_CLIENT_SIZE +1];
    HRESULT         hr = S_OK;

    // Clear any existing addresses.
    ClearAddress();

    __try
    {
        //
        //  check if this address is dotted octet or DNS name
        //
        if (!IsDottedDecimal(m_wszClientAddress))
        {
            //
            //  we probably have a DNS name so
            //  get the address information
            //
            pHostent = IASGetHostByName (m_wszClientAddress);
            if (NULL == pHostent)
            {
                IASTracePrintf (
                    "Unable to get client IP Address through IASGetHostByName () "
                    "during client address resolution"
                    );

                //
                //  log an event here
                //
                PCWSTR strings[] = { m_wszClientAddress, m_wszClientName };
                int data = WSAGetLastError();
                IASReportEvent(
                    RADIUS_E_CANT_RESOLVE_CLIENT_NAME,
                    2,
                    sizeof(data),
                    strings,
                    &data
                    );
                hr = E_FAIL;
                __leave;
            }

            //
            //  store addresses in host byte order
            //
            size_t count;
            for (count = 0; pHostent->h_addr_list[count]; ++count) { }

            if (count > 1)
            {
               m_adwAddrList = new (std::nothrow) Address[count + 1];
               if (!m_adwAddrList)
               {
                  m_adwAddrList = m_adwAddressBuffer;
                  hr = E_OUTOFMEMORY;
                  __leave;
               }
            }

            for (count = 0; pHostent->h_addr_list[count]; ++count)
            {
               m_adwAddrList[count].ipAddress =
                  ntohl(*(PDWORD)pHostent->h_addr_list[count]);
               m_adwAddrList[count].width = 32;
            }

            m_adwAddrList[count].ipAddress = INADDR_NONE;
        }
        else
        {
            //
            //  this could be a dotted-octet address
            //
            ULONG width;
            m_adwAddressBuffer[0].ipAddress = IASStringToSubNetW(
                                                 m_wszClientAddress,
                                                 &m_adwAddressBuffer[0].width
                                                 );
            if (INADDR_NONE == m_adwAddressBuffer[0].ipAddress)
            {
                IASTracePrintf (
                    "Unable to get client IP Address through inet_addr () "
                    "during client address resolution"
                    );

                //
                //  log an event here
                //
                PCWSTR strings[] = { m_wszClientAddress, m_wszClientName };
                IASReportEvent(
                    RADIUS_E_INVALID_CLIENT_ADDRESS,
                    2,
                    0,
                    strings,
                    NULL
                    );
                hr = E_FAIL;
                __leave;
            }

            // Terminate the array.
            m_adwAddressBuffer[1].ipAddress = INADDR_NONE;
       }
    }
    __finally
    {
        if (bRetVal)
        {
            IASTracePrintf (
                "Resolved Client:%S, to IP address:%ul", m_wszClientAddress, m_adwAddrList[0].ipAddress
                );
        }

        if (pHostent) { LocalFree(pHostent); }
    }

    return (hr);

}   //  end of CClient::ResolveAddress method

//++--------------------------------------------------------------
//
//  Function:   SetSecret
//
//  Synopsis:   This is the CClient private method used
//              to set the shared secret
//
//  Arguments:  VARIANT - holds the secret as a BSTR
//
//  Returns:    status
//
//  History:    MKarki      Created     2/3/98
//
//  Called By: CClient::Init method
//
//----------------------------------------------------------------
BOOL
CClient::SetSecret (
            VARIANT varSecret
             )
{
    INT     iRetVal = 0;

    _ASSERT (VT_BSTR == varSecret.vt);

    iRetVal = ::WideCharToMultiByte (
                            CP_ACP,
                            0,
                            reinterpret_cast <LPCWSTR> (varSecret.pbstrVal),
                            -1,
                            m_szSecret,
                            MAX_SECRET_SIZE,
                            NULL,
                            NULL
                            );
    if (0 == iRetVal)
    {
        IASTracePrintf (
            "Unable to convert client shared secret to multi-byte string "
            "during Client processing"
            );
        return (FALSE);
    }

    //
    //  set secret size
    //
    m_dwSecretSize = strlen (m_szSecret);

    return (TRUE);

}   //  end of CClient::SetSecret method


HRESULT CClient::SetClientName(const VARIANT& varClientName) throw ()
{
   if (V_VT(&varClientName) != VT_BSTR)
   {
      return E_INVALIDARG;
   }

   return StringCchCopyW(
             m_wszClientName,
             RTL_NUMBER_OF(m_wszClientName),
             V_BSTR(&varClientName)
             );
}


//++--------------------------------------------------------------
//
//  Function:   SetSignatureFlag
//
//  Synopsis:   This is the CClient private method used
//              to set the Client Signature flag
//
//  Arguments:  VARIANT - holds the signature as a boolean
//
//  Returns:    status
//
//  History:    MKarki      Created     2/3/98
//
//  Called By: CClient::Init method
//
//----------------------------------------------------------------
BOOL
CClient::SetSignatureFlag (
            VARIANT varSigFlag
            )
{
    _ASSERT (VT_BOOL == varSigFlag.vt);

    if (0 == varSigFlag.boolVal)
    {
        m_bSignatureCheck = FALSE;
    }
    else
    {
        m_bSignatureCheck = TRUE;
    }

    return (TRUE);

}   //  end of CClient::SetSignatureFlag method

//++--------------------------------------------------------------
//
//  Function:   SetVendorType
//
//  Synopsis:   This is the CClient private method used
//              to set the Client Vendor Type
//
//  Arguments:  VARIANT - holds the Vendor Type
//
//  Returns:    status
//
//  History:    MKarki      Created     3/16/98
//
//  Called By: CClient::Init method
//
//----------------------------------------------------------------
BOOL
CClient::SetVendorType (
            VARIANT varVendorType
            )
{
    _ASSERT (VT_I4 == varVendorType.vt);

    m_lVendorType = varVendorType.lVal;

    return (TRUE);

}   //  end of CClient::SetVendorType method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\proxy\udpsock.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    udpsock.cpp
//
// SYNOPSIS
//
//    Defines the class UDPSocket.
//
// MODIFICATION HISTORY
//
//    02/06/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <proxypch.h>
#include <malloc.h>
#include <udpsock.h>

inline BOOL UDPSocket::createReceiveThread()
{
   // check if the processing is still going on
   if (!closing)
   {
      return IASRequestThread(this) ? TRUE : FALSE;
   }
   else
   {
      SetEvent(idle);
      return TRUE;
   }
}

UDPSocket::UDPSocket() throw ()
   : receiver(NULL),
     sock(INVALID_SOCKET),
     closing(FALSE),
     idle(NULL)
{
   CallbackRoutine = startRoutine;
}

UDPSocket::~UDPSocket() throw ()
{
   if (idle) { CloseHandle(idle); }
   if (sock != INVALID_SOCKET) { closesocket(sock); }
}

BOOL UDPSocket::open(
                    PacketReceiver* sink,
                    ULONG_PTR recvKey,
                    const SOCKADDR_IN* address
                    ) throw ()
{
   receiver = sink;
   key = recvKey;

   if (address)
   {
      localAddress = *address;
   }

   sock = WSASocket(
              AF_INET,
              SOCK_DGRAM,
              0,
              NULL,
              0,
              WSA_FLAG_OVERLAPPED
              );
   if (sock == INVALID_SOCKET) { return FALSE; }

   int error = bind(
                   sock,
                   localAddress,
                   sizeof(localAddress)
                   );
   if (error) { return FALSE; }

   idle = CreateEventW(
              NULL,
              TRUE,
              FALSE,
              NULL
              );
   if (!idle) { return FALSE; }

   BOOL threadCreated = createReceiveThread();
   if (!threadCreated)
   {
      SetEvent(idle);
   }
   return threadCreated;
}

void UDPSocket::close() throw ()
{
   if (sock != INVALID_SOCKET)
   {
      closing = TRUE;

      closesocket(sock);
      sock = INVALID_SOCKET;

      WaitForSingleObject(idle, INFINITE);
   }

   if (idle)
   {
      CloseHandle(idle);
      idle = NULL;
   }
}

BOOL UDPSocket::send(
                    const SOCKADDR_IN& to,
                    const BYTE* buf,
                    ULONG buflen
                    ) throw ()
{
   WSABUF wsabuf = { buflen, (CHAR*)buf };
   ULONG bytesSent;
   return !WSASendTo(
               sock,
               &wsabuf,
               1,
               &bytesSent,
               0,
               (const SOCKADDR*)&to,
               sizeof(to),
               NULL,
               NULL
               );
}

bool UDPSocket::receive() throw ()
{
   // Return value from the function. Indicates whether or not the caller
   // should call UDPSocket::receive() again 
   bool shouldCallAgain = false;
   WSABUF wsabuf = { sizeof(buffer), (CHAR*)buffer };
   ULONG bytesReceived;
   ULONG flags = 0;
   SOCKADDR_IN remoteAddress;
   int remoteAddressLength;
   remoteAddressLength = sizeof(remoteAddress);

   int error = WSARecvFrom(
                  sock,
                  &wsabuf,
                  1,
                  &bytesReceived,
                  &flags,
                  (SOCKADDR*)&remoteAddress,
                  &remoteAddressLength,
                  NULL,
                  NULL
                  );
   if (error)
   {
      error = WSAGetLastError();
      switch (error)
      {
      case WSAECONNRESET:
         {
            shouldCallAgain = true;
            break;
         }
      case WSAENOBUFS:
         {
            shouldCallAgain = true;
            Sleep(5);
            break;
         }
      default:
         {
            // Don't report errors while closing.
            if (!closing)
            {
               receiver->onReceiveError(*this, key, error);
            }

            // There's no point getting another thread if the socket's no good, so
            // we'll just exit.
            SetEvent(idle);
         }
      }
   }
   else
   {
      // Save the buffer locally.
      PBYTE packet = (PBYTE)_alloca(bytesReceived);
      memcpy(packet, buffer, bytesReceived);

      // Get a replacement. Reuse the current thread if the allocation 
      // of the new one failed
      shouldCallAgain = (createReceiveThread()? false : true);

      // Invoke the callback.
      receiver->onReceive(*this, key, remoteAddress, packet, bytesReceived);
   }

   return shouldCallAgain;
}

void UDPSocket::startRoutine(PIAS_CALLBACK This) throw ()
{
   UDPSocket* receiveSocket = static_cast<UDPSocket*>(This);
   while (receiveSocket->receive())
   {
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\clients.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class CClients
//
///////////////////////////////////////////////////////////////////////////////

#ifndef CLIENTS_H
#define CLIENTS_H
#pragma once

#include "clientstrie.h"

class CClients
{
public:
   CClients() throw ();
   ~CClients() throw ();

   HRESULT Init() throw ();
   void Shutdown() throw ();

   HRESULT SetClients(VARIANT* pVarClients) throw ();

   BOOL FindObject(
           DWORD dwKey,
           IIasClient** ppIIasClient = 0
           ) throw ();

   void DeleteObjects() throw ();

private:
   // Frees the client objects in m_pCClientArray.
   void FreeClientArray(DWORD dwCount) throw ();

   // Resolve the clients in the m_pCClientArray member.
   void Resolve(DWORD dwCount) throw ();

   // Wait for the resolver thread to exit.
   HRESULT StopResolvingClients() throw ();

   // State passed to the resolver thread.
   struct ConfigureCallback : IAS_CALLBACK
   {
      CClients* self;
      DWORD numClients;
   };

   // Thread start routine for the resolver thread.
   static void WINAPI CallbackRoutine(IAS_CALLBACK* context) throw ();

   // Critical section used to serialize access to the ClientTrie.
   bool m_CritSectInitialized;
   CRITICAL_SECTION m_CritSect;

   // Class factory for creating new client objects.
   CComPtr<IClassFactory> m_pIClassFactory;

   // Scratch pad for storing clients that need to be resolved.
   CClient** m_pCClientArray;

   // The map of clients
   ClientTrie m_mapClients;

   // Used to signal that the resolver thread has finished.
   HANDLE m_hResolverEvent;

   // Max number of clients allowed.
   LONG m_dwMaxClients;

   // True if subnet syntax and multiple addresses per hostname are allowed.
   bool m_fAllowSubnetSyntax;
};

#endif // CLIENTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\clients.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the class CClients.
//
///////////////////////////////////////////////////////////////////////////////

#include "radcommon.h"
#include "clients.h"
#include "client.h"


CClients::CClients() throw ()
   : m_CritSectInitialized(false),
     m_pCClientArray(0),
     m_hResolverEvent(0),
     m_dwMaxClients(0),
     m_fAllowSubnetSyntax(false)
{
}

CClients::~CClients() throw ()
{
   if (m_hResolverEvent != 0)
   {
      CloseHandle(m_hResolverEvent);
   }

   DeleteObjects();

   CoTaskMemFree(m_pCClientArray);

   if (m_CritSectInitialized)
   {
      DeleteCriticalSection(&m_CritSect);
   }
}


HRESULT CClients::Init() throw ()
{
   IAS_PRODUCT_LIMITS limits;
   DWORD error = IASGetProductLimits(0, &limits);
   if (error != NO_ERROR)
   {
      return HRESULT_FROM_WIN32(error);
   }
   m_dwMaxClients = limits.maxClients;
   m_fAllowSubnetSyntax = (limits.allowSubnetSyntax != FALSE);

   if (!InitializeCriticalSectionAndSpinCount(&m_CritSect, 0))
   {
      error = GetLastError();
      return HRESULT_FROM_WIN32(error);
   }
   m_CritSectInitialized = true;

   // Get the IClassFactory interface to be used to create the Client COM
   // objects
   HRESULT hr = CoGetClassObject(
                   __uuidof(CClient),
                   CLSCTX_INPROC_SERVER,
                   0,
                   __uuidof(IClassFactory),
                   reinterpret_cast<void**>(&m_pIClassFactory)
                   );
   if (FAILED(hr))
   {
      return hr;
   }

   m_hResolverEvent = CreateEventW(
                         0,    //  security attribs
                         TRUE, //  manual reset
                         TRUE, //  initial state
                         0     //  event name
                         );
   if (m_hResolverEvent == 0)
   {
      error = GetLastError();
      return HRESULT_FROM_WIN32(error);
   }

   return S_OK;
}


void CClients::Shutdown() throw ()
{
   StopResolvingClients();
}


HRESULT CClients::SetClients(VARIANT* pVarClients) throw ()
{
   //  check the input arguments
   if ((pVarClients == 0) ||
       (V_VT(pVarClients) != VT_DISPATCH) ||
       (V_DISPATCH(pVarClients) == 0))
   {
      return E_INVALIDARG;
   }

   HRESULT hr;

    // stop any previous client configuration in progress
   hr = StopResolvingClients();
   if (FAILED(hr))
   {
      return hr;
   }

   //  get the ISdoCollection interface now
   CComPtr<ISdoCollection> pISdoCollection;
   hr = V_DISPATCH(pVarClients)->QueryInterface(
                                    __uuidof(ISdoCollection),
                                    reinterpret_cast<void**>(&pISdoCollection)
                                    );
   if (FAILED(hr))
   {
      return hr;
   }

   // get the number of objects in the collection
   LONG lCount;
   hr = pISdoCollection->get_Count(&lCount);
   if (FAILED (hr))
   {
      return hr;
   }
   else if (lCount == 0)
   {
      DeleteObjects();
      return S_OK;
   }
   else if (lCount > m_dwMaxClients)
   {
      IASTracePrintf(
         "License Violation: %ld RADIUS Clients are configured, but only "
         "%lu are allowed for this product type.",
         lCount,
         m_dwMaxClients
         );
      IASReportLicenseViolation();
      return IAS_E_LICENSE_VIOLATION;
   }

   // allocate array of CClient* to temporarily store the CClient objects until
   // the addresses are resolved
   m_pCClientArray = static_cast<CClient**>(
                        CoTaskMemAlloc(sizeof(CClient*) * lCount)
                        );
   if (m_pCClientArray == 0)
   {
      return E_OUTOFMEMORY;
   }

   // get the enumerator for the clients collection
   CComPtr<IUnknown> pIUnknown;
   hr = pISdoCollection->get__NewEnum(&pIUnknown);
   if (FAILED (hr))
   {
      return hr;
   }

   // get the enum variant
   CComPtr<IEnumVARIANT> pIEnumVariant;
   hr = pIUnknown->QueryInterface(
                      __uuidof(IEnumVARIANT),
                      reinterpret_cast<void**>(&pIEnumVariant)
                      );
   if (FAILED (hr))
   {
      return hr;
   }

   //  get clients out of the collection and initialize
   CComVariant varPerClient;
   DWORD dwClientsLeft;
   hr = pIEnumVariant->Next(1, &varPerClient, &dwClientsLeft);
   if (FAILED(hr))
   {
      return hr;
   }

   DWORD dwCurrentIndex = 0;
   while ((dwClientsLeft > 0) && (dwCurrentIndex < lCount))
   {
      // get an Sdo pointer from the variant we received
      CComPtr<ISdo> pISdo;
      hr = V_DISPATCH(&varPerClient)->QueryInterface(
                                         __uuidof(ISdo),
                                         reinterpret_cast<void**>(&pISdo)
                                      );
      if (FAILED(hr))
      {
         break;
      }

      // create a new Client object now
      CClient* pIIasClient;
      hr = m_pIClassFactory->CreateInstance(
                                0,
                                __uuidof(CClient),
                                reinterpret_cast<void**>(&pIIasClient)
                                );
      if (FAILED(hr))
      {
         break;
      }


      // store this CClient class object in the object array temporarily
      m_pCClientArray[dwCurrentIndex] = pIIasClient;
      ++dwCurrentIndex;

      // initalize the client
      hr = pIIasClient->Init(pISdo);
      if (FAILED(hr))
      {
         break;
      }

      if (!m_fAllowSubnetSyntax &&
          IASIsStringSubNetW(pIIasClient->GetClientAddressW()))
      {
         IASTracePrintf(
            "License Violation: RADIUS Client '%S' uses sub-net syntax, "
            "which is not allowed for this product type.",
            pIIasClient->GetClientNameW()
            );
         IASReportLicenseViolation();
         hr = IAS_E_LICENSE_VIOLATION;
         break;
      }

      // clear the perClient value from this variant
      varPerClient.Clear();

      //  get next client out of the collection
      hr = pIEnumVariant->Next(1, &varPerClient, &dwClientsLeft);
      if (FAILED(hr))
      {
         break;
      }
   }

   if (FAILED(hr))
   {
      FreeClientArray(dwCurrentIndex);
      return hr;
   }

   ConfigureCallback* cback = static_cast<ConfigureCallback*>(
                                 CoTaskMemAlloc(sizeof(ConfigureCallback))
                                 );
   if (cback == 0)
   {
      return E_OUTOFMEMORY;
   }

   cback->CallbackRoutine = CallbackRoutine;
   cback->self = this;
   cback->numClients = dwCurrentIndex;

   // We reset the event which will be set by the resolver thread when its done
   // and start the resolver thread
   ResetEvent(m_hResolverEvent);
   if (!IASRequestThread(cback))
   {
      CallbackRoutine(cback);
   }

   return S_OK;
}


BOOL CClients::FindObject(DWORD dwKey, IIasClient** ppIIasClient) throw ()
{
   EnterCriticalSection(&m_CritSect);

   IIasClient* client = m_mapClients.Find(dwKey);

   if (ppIIasClient != 0)
   {
      *ppIIasClient = client;

      if (client != 0)
      {
         client->AddRef();
      }
   }

   LeaveCriticalSection(&m_CritSect);

   return client != 0;
}


void CClients::DeleteObjects() throw ()
{
   m_mapClients.Clear();
}


void CClients::FreeClientArray(DWORD dwCount) throw ()
{
   for (DWORD i = 0; i < dwCount; ++i)
   {
      m_pCClientArray[i]->Release();
   }

   CoTaskMemFree(m_pCClientArray);
   m_pCClientArray = 0;
}


void CClients::Resolve(DWORD dwArraySize) throw ()
{
   // Set up iterators for the clients array.
   CClient** begin = m_pCClientArray;
   CClient** end = begin + dwArraySize;
   CClient** i;

   // Resolve the client addresses.
   for (i = begin; i != end; ++i)
   {
      (*i)->ResolveAddress();
   }

   //////////
   // Update the client map.
   //////////

   EnterCriticalSection(&m_CritSect);

   DeleteObjects();

   try
   {
      for (i = begin; i != end; ++i)
      {
         const CClient::Address* beginAddrs = (*i)->GetAddressList();

         for (const CClient::Address* paddr = beginAddrs;
              paddr->ipAddress != INADDR_NONE;
              ++paddr)
         {
            if ((paddr == beginAddrs) || m_fAllowSubnetSyntax)
            {
               m_mapClients.Insert(SubNet(paddr->ipAddress, paddr->width), *i);
            }
            else
            {
               IASTracePrintf(
                  "License Restriction: RADIUS Client '%S' resolves to more "
                  "than one IP address; on this product type only the first "
                  "address will be used.",
                  (*i)->GetClientNameW()
                  );
               break;
            }
         }
      }
   }
   catch (const std::bad_alloc&)
   {
   }

   LeaveCriticalSection(&m_CritSect);

   // Clean up the array of client objects.
   FreeClientArray(dwArraySize);

   // Set the event indicating that the Resolver thread is done
   SetEvent(m_hResolverEvent);
}


HRESULT CClients::StopResolvingClients() throw ()
{
   DWORD result = WaitForSingleObject(m_hResolverEvent, INFINITE);
   if (result == WAIT_FAILED)
   {
      DWORD error = GetLastError();
      return HRESULT_FROM_WIN32(error);
   }

   return S_OK;

}


void WINAPI CClients::CallbackRoutine(IAS_CALLBACK* context) throw ()
{
   ConfigureCallback* cback = static_cast<ConfigureCallback*>(context);
   cback->self->Resolve(cback->numClients);
   CoTaskMemFree(cback);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\clientstrie.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines
//
///////////////////////////////////////////////////////////////////////////////

#include "radcommon.h"
#include "clientstrie.h"
#include <iomanip>


SubNet::SubNet(uint32_t ipAddress, uint32_t width) throw ()
   : address(ipAddress)
{
   if (width == 0)
   {
      subNetMask = 0;
      firstUniqueBitMask = 0x80000000;
   }
   else if (width == 32)
   {
      subNetMask = 0xffffffff;
      firstUniqueBitMask = 0;
   }
   else
   {
      subNetMask = 0xffffffff;
      subNetMask >>= (32 - width);
      subNetMask <<= (32 - width);

      firstUniqueBitMask = 0x80000000;
      firstUniqueBitMask >>= width;
   }

   address &= subNetMask;
}


SubNet SubNet::SmallestContainingSubNet(const SubNet& subnet) const throw ()
{
   // Find the most significant bit where the addresses differ.
   uint32_t width = 0;
   for (uint32_t mask = 0x80000000;
        (mask != 0) && (subnet.address & mask) == (address & mask);
        (mask >>= 1), (++width))
   {
   }

   return SubNet(address, width);
}


ClientNodePtr& ClientNodePtr::operator=(ClientNodePtr& rhs) throw ()
{
   if (p != rhs.p)
   {
      delete p;
      p = rhs.p;
      rhs.p = 0;
   }

   return *this;
}


ClientNode::Relationship ClientNode::RelationshipTo(
                                        const ClientNode& node
                                        ) const throw ()
{
   if (key == node.key)
   {
      return self;
   }
   else if (key.Contains(node.key))
   {
      return parent;
   }
   else if (node.key.Contains(key))
   {
      return child;
   }
   else
   {
      return brother;
   }
}


void ClientNode::SetChild(ClientNodePtr& node) throw ()
{
   // assert(node.get() != 0);
   WhichBranch(*node) = node;
}


inline ClientNode::ClientNode(
                      const SubNet& subnet,
                      IIasClient* client
                      ) throw ()
   : key(subnet), value(client)
{
}


ClientNodePtr ClientNode::CreateInstance(
                             const SubNet& subnet,
                             IIasClient* client
                             ) throw ()
{
   return ClientNodePtr(new ClientNode(subnet, client));
}


void ClientNode::Write(
                    const ClientNodePtr& branch,
                    std::ostream& output,
                    size_t startingIndent
                    )
{
   for (size_t i = 0; i < startingIndent; ++i)
   {
      output.put(' ');
   }

   if (branch.get() != 0)
   {
      output << branch->Key()
             << ((branch->Value() != 0) ? " <value>\n" : " <null>\n");

      Write(branch->zero, output, startingIndent + 2);
      Write(branch->one, output, startingIndent + 2);
   }
   else
   {
      output << "<null>\n";
   }
}


ClientNode::~ClientNode() throw ()
{
}


IIasClient* ClientTrie::Find(uint32_t ipAddress) const throw ()
{
   IIasClient* bestMatch = 0;

   for (const ClientNode* n = root.get();
        n != 0 && n->Key().HasMember(ipAddress);
        n = n->WhichChild(ipAddress))
   {
      if (n->Value() != 0)
      {
         // As we walk down the tree, we are finding longer and longer matches,
         // so the last one we find is the best.
         bestMatch = n->Value();
      }
   }

   return bestMatch;
}


void ClientTrie::Insert(const SubNet& subnet, IIasClient* client)
{
   Insert(root, ClientNode::CreateInstance(subnet, client));
}


void ClientTrie::Write(std::ostream& output) const
{
   ClientNode::Write(root, output);
}


void ClientTrie::Insert(ClientNodePtr& node, ClientNodePtr& newEntry)
{
   if (node.get() == 0)
   {
      // We made it to the end of the branch, so we're a leaf.
      node = newEntry;
   }
   else
   {
      switch (node->RelationshipTo(*newEntry))
      {
         case ClientNode::parent:
         {
            // This is an ancestor of ours, so keep walking.
            Insert(node->WhichBranch(*newEntry), newEntry);
            break;
         }

         case ClientNode::child:
         {
            // This is our child, ...
            newEntry->SetChild(node);
            // ... so we take its place in the tree.
            node = newEntry;
            break;
         }

         case ClientNode::brother:
         {
            // We found a brother, so our parent is missing.
            ClientNodePtr parent(node->CreateParent(*newEntry));
            parent->SetChild(node);
            parent->SetChild(newEntry);
            node = parent;
            break;
         }

         case ClientNode::self:
         {
            if (node->Value() == 0)
            {
               node->SetValue(newEntry->Value());
            }
            // Otherwise, this is a duplicate entry. We do nothing so that the
            // first entry in the UI will take precedence.
            break;
         }

         default:
            // assert(false);
            break;
      }
   }
}


std::ostream& operator<<(std::ostream& output, const SubNet& subnet)
{
   output << std::hex
          << std::setfill('0')
          << std::setiosflags(std::ios_base::right)
          << std::setw(8)
          << subnet.IpAddress()
          << ':'
          << std::setw(8)
          << subnet.SubNetMask();

   return output;
}


std::ostream& operator<<(std::ostream& output, const ClientTrie& tree)
{
   tree.Write(output);

   return output;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\clientstrie.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares
//
///////////////////////////////////////////////////////////////////////////////

#ifndef CLIENTSTRIE_H
#define CLIENTSTRIE_H
#pragma once

#include "atlbase.h"
#include "iasradius.h"
#include <iostream>

typedef ULONG32 uint32_t;

// Represents an IPv4 subnet. Note that we can model an individual IP host as a
// subnet with a mask 32-bits wide.
class SubNet
{
public:
   SubNet() throw ();

   // 'width' is the width in bits of the subnet mask. If 'width' is greater
   // than 32, it is treated as if it were exactly 32.
   explicit SubNet(uint32_t ipAddress, uint32_t width = 32) throw ();

   // Use compiler generated versions.
   // ~SubNet() throw ();
   // SubNet(const SubNet&);
   // SubNet& operator=(const SubNet&);

   uint32_t IpAddress() const throw ();
   uint32_t SubNetMask() const throw ();

   // Returns the first bit after the subnet mask.
   uint32_t FirstUniqueBit(uint32_t ipAddress) const throw ();
   uint32_t FirstUniqueBit(const SubNet& subnet) const throw ();

   // Returns true if the argument is a member of the subnet.
   bool HasMember(uint32_t ipAddress) const throw ();
   // Returns true if 'this' contains 'subnet'.
   bool Contains(const SubNet& subnet) const throw ();

   // Returns the smallest subnet that contains both 'this' and 'subnet'.
   SubNet SmallestContainingSubNet(const SubNet& subnet) const throw ();

   bool operator==(const SubNet& rhs) const throw ();

private:
   uint32_t address;
   uint32_t subNetMask;
   uint32_t firstUniqueBitMask;
};


class ClientNode;


// This class is an auto_ptr for ClientNode. I had to implement this because
// the std::auto_ptr used in Whistler doesn't comply to the standard. Once we
// have a compliant std::auto_ptr, this class can be replaced with a typedef.
class ClientNodePtr
{
public:
   ClientNodePtr(ClientNode* node = 0) throw ();
   ~ClientNodePtr() throw ();

   ClientNodePtr(ClientNodePtr& original) throw ();
   ClientNodePtr& operator=(ClientNodePtr& rhs) throw ();

   ClientNode& operator*() const throw ();
   ClientNode* operator->() const throw ();
   ClientNode* get() const throw ();
   void reset(ClientNode* node = 0) throw ();

private:
   ClientNode* p;
};


// A node in the binary trie used to store clients.
class ClientNode
{
public:
   // Used to express the relationship between two nodes.
   enum Relationship
   {
      child,
      parent,
      brother,
      self
   };

   const SubNet& Key() const throw ();
   IIasClient* Value() const throw ();
   void SetValue(IIasClient* newValue) throw ();

   // Returns the child node (if any) that contains 'ipAddress' assuming that
   // this node contains 'ipAddress'.
   const ClientNode* WhichChild(uint32_t ipAddress) const throw ();

   // Returns the branch from this node to follow when looking for 'node'.
   ClientNodePtr& WhichBranch(const ClientNode& node) throw ();

   // Returns the relationship between 'this' and 'node'.
   Relationship RelationshipTo(const ClientNode& node) const throw ();

   // Sets 'node' as a child of 'this'. This function takes ownership of 'node'
   // and silently overwrites any existing child on the branch.
   void SetChild(ClientNodePtr& node) throw ();

   // Create a new ClientNode.
   static ClientNodePtr CreateInstance(
                           const SubNet& subnet,
                           IIasClient* client = 0
                           ) throw ();

   // Create new ClientNode that is a parent to both 'this' and 'node'.
   ClientNodePtr CreateParent(const ClientNode& node) const;

   // Dump a branch of the trie to an ostream. Useful for debugging.
   static void Write(
                  const ClientNodePtr& branch,
                  std::ostream& output,
                  size_t startingIndent = 0
                  );

private:
   // The constructor and destructor are private since other classes should
   // only use ClientNodePtr.
   ClientNode(const SubNet& subnet, IIasClient* client) throw ();
   ~ClientNode() throw ();

   friend class ClientNodePtr;

   SubNet key;
   // 'value' is mutable because it can change without affecting the structure
   // of the trie.
   mutable CComPtr<IIasClient> value;
   ClientNodePtr zero;
   ClientNodePtr one;

   // Not implemented.
   ClientNode(const ClientNode&);
   ClientNode& operator=(const ClientNode&);
};


// A binary trie storing ClientNodes and supporting efficient longest-prefix
// matching.
class ClientTrie
{
public:
   ClientTrie() throw ();

   // Use compiler-generated version.
   // ~ClientTrie() throw ();

   // Clear all entries from the trie.
   void Clear() throw ();

   // Find the client (if any) with the longest prefix match. The returned
   // pointer has not been AddRef'ed.
   IIasClient* Find(uint32_t ipAddress) const throw ();

   // Insert a new client into the trie.
   void Insert(const SubNet& subnet, IIasClient* client);

   // Dump the trie to an ostream. Useful for debugging.
   void Write(std::ostream& output) const;

private:
   void Insert(ClientNodePtr& node, ClientNodePtr& newEntry);

   ClientNodePtr root;

   // Not implemented
   ClientTrie(const ClientTrie&);
   ClientTrie& operator=(const ClientTrie&);
};


// Useful debugging functions.
std::ostream& operator<<(std::ostream& output, const SubNet& subnet);
std::ostream& operator<<(std::ostream& output, const ClientTrie& tree);


inline SubNet::SubNet() throw ()
   : address(0), subNetMask(0), firstUniqueBitMask(0)
{
}


inline uint32_t SubNet::IpAddress() const throw ()
{
   return address;
}


inline uint32_t SubNet::SubNetMask() const throw ()
{
   return subNetMask;
}


inline uint32_t SubNet::FirstUniqueBit(uint32_t ipAddress) const throw ()
{
   return ipAddress & firstUniqueBitMask;
}


inline uint32_t SubNet::FirstUniqueBit(const SubNet& subnet) const throw ()
{
   return FirstUniqueBit(subnet.address);
}


inline bool SubNet::HasMember(uint32_t ipAddress) const throw ()
{
   return (ipAddress & subNetMask) == address;
}


inline bool SubNet::Contains(const SubNet& subnet) const throw ()
{
   return (subNetMask <= subnet.subNetMask) && HasMember(subnet.address);
}


inline bool SubNet::operator==(const SubNet& rhs) const throw ()
{
   return (address == rhs.address) && (subNetMask == rhs.subNetMask);
}


inline ClientNodePtr::ClientNodePtr(ClientNode* node) throw ()
   : p(node)
{
}


inline ClientNodePtr::~ClientNodePtr() throw ()
{
   delete p;
}


inline ClientNodePtr::ClientNodePtr(ClientNodePtr& original) throw ()
   : p(original.p)
{
   original.p = 0;
}


inline ClientNode& ClientNodePtr::operator*() const throw ()
{
   return *p;
}


inline ClientNode* ClientNodePtr::operator->() const throw ()
{
   return p;
}


inline ClientNode* ClientNodePtr::get() const throw ()
{
   return p;
}


inline void ClientNodePtr::reset(ClientNode* node) throw ()
{
   if (node != p)
   {
      delete p;
      p = node;
   }
}


inline const SubNet& ClientNode::Key() const throw ()
{
   return key;
}


inline IIasClient* ClientNode::Value() const throw ()
{
   return value;
}


inline void ClientNode::SetValue(IIasClient* newValue) throw ()
{
   value = newValue;
}


inline const ClientNode* ClientNode::WhichChild(
                                        uint32_t ipAddress
                                        ) const throw ()
{
   return (key.FirstUniqueBit(ipAddress) ? one : zero).get();
}


inline ClientNodePtr& ClientNode::WhichBranch(const ClientNode& node) throw ()
{
   return key.FirstUniqueBit(node.key) ? one : zero;
}


inline ClientNodePtr ClientNode::CreateParent(const ClientNode& node) const
{
   return CreateInstance(key.SmallestContainingSubNet(node.key), 0);
}


inline ClientTrie::ClientTrie() throw ()
{
}


inline void ClientTrie::Clear() throw ()
{
   root.reset();
}

#endif  // CLIENTSTRIE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\dictionary.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    dictionary.cpp
//
// SYNOPSIS
//
//    Defines the class CDictionary.
//
// MODIFICATION HISTORY
//
//    04/19/1999    Complete rewrite.
//    02/16/2000    User ID instead of RADIUS_ID.
//    04/17/2000    Port to new dictionary API.
//
///////////////////////////////////////////////////////////////////////////////

#include <radcommon.h>
#include <dictionary.h>
#include <iastlb.h>
#include <iastlutl.h>

BOOL CDictionary::Init() throw ()
{
   HRESULT hr;

   // When in doubt, assume OctetString.
   for (ULONG i = 0; i < 256; ++i)
   {
      type[i] = IASTYPE_OCTET_STRING;
   }

   try
   {
      // Names of various columns in the dictionary.
      const PCWSTR COLUMNS[] =
      {
         L"ID",
         L"Syntax",
         NULL
      };

      // Open the attributes table.
      IASTL::IASDictionary dnary(COLUMNS);

      // Store the RADIUS attributes in the type array.
      while (dnary.next())
      {
         LONG id = dnary.getLong(0);

         if (id >= 0 && id < 256)
         {
            type[id] = (IASTYPE)dnary.getLong(1);
         }
      }
   }
   catch (const _com_error& ce)
   {
      return FALSE;
   }

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\dictionary.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    dictionary.h
//
// SYNOPSIS
//
//    Declares the class CDictionary.
//
// MODIFICATION HISTORY
//
//    04/19/1999    Complete rewrite.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef DICTIONARY_H
#define DICTIONARY_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <radpkt.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    CDictionary
//
// DESCRIPTION
//
//    Maps RADIUS attributes to there IAS syntax.
//
///////////////////////////////////////////////////////////////////////////////
class CDictionary
{
public:
   CDictionary() throw () { }

   BOOL Init() throw ();

   IASTYPE getAttributeType(BYTE radiusId) const throw ()
   { return type[radiusId]; }

private:
   IASTYPE type[256];

   // Not implemented.
   CDictionary(const CDictionary&);
   CDictionary& operator=(const CDictionary&);
};

#endif  // DICTIONARY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\hash.cpp ===
// hash.cpp: implementation of the CHash class.
//
//////////////////////////////////////////////////////////////////////
#include "radcommon.h"
#include "hash.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHash::CHash()
{

}

CHash::~CHash()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\hash.h ===
//#--------------------------------------------------------------
//        
//  File:      hash.h
//        
//  Synopsis:   This file holds the declarations of the 
//				CHash class
//              
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _HASH_H_
#define _HASH_H_

class CHash  
{

public:

	virtual BOOL HashIt (
					/*[out]*/   PBYTE   pbyAuthenticator,
                    /*[in]*/    PBYTE   pKey,
                    /*[in]*/    DWORD   dwKeySize,
					/*[in]*/    PBYTE   pBuffer1,
					/*[in]*/    DWORD   dwSize1,
					/*[in]*/    PBYTE   pBuffer2,
					/*[in]*/    DWORD   dwSize2,
					/*[in]*/    PBYTE   pBuffer3,
					/*[in]*/    DWORD   dwSize3, 
					/*[in]*/    PBYTE   pBuffer4,
					/*[in]*/    DWORD   dwSize4,
					/*[in]*/    PBYTE   pBuffer5,
					/*[in]*/    DWORD   dwSize5
					)=0;

	virtual BOOL Init (VOID)=0;

	CHash();

	virtual ~CHash();

};

#endif // ifndef _HASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\dbgtrace.h ===
/*----------------------------------------------------------------------
    dbgtrace.h
        Definitions for async tracing routines

    Copyright (C) 1997-98  Microsoft Corporation
    All rights reserved.

    Authors:
        gordm          Gord Mangione

    History:
        01/30/95 gordm      Created.
----------------------------------------------------------------------*/

#if !defined(_DBGTRACE_H_)
#define _DBGTRACE_H_


#ifdef __cplusplus
extern "C" {
#endif


//
// setup DLL Export macros
//
#if !defined(DllExport)
    #define DllExport __declspec( dllexport )
#endif
#if !defined(DllImport)
    #define DllImport __declspec( dllimport )
#endif
#if !defined(_DBGTRACE_DLL_DEFINED)
    #define _DBGTRACE_DLL_DEFINED
    #if defined(WIN32)
        #if defined(_DBGTRACE_DLL_IMPLEMENTATION)
            #define DbgTraceDLL DllExport
        #else
            #define DbgTraceDLL DllImport
        #endif
    #else
        #define DbgTraceDLL
    #endif
#endif

#ifndef THIS_FILE
#define THIS_FILE   __FILE__
#endif

#if defined( NOTRACE )

#define FLUSHASYNCTRACE                         // for _ASSERT below

#define FatalTrace  1 ? (void)0 : PreAsyncTrace
#define ErrorTrace  1 ? (void)0 : PreAsyncTrace
#define DebugTrace  1 ? (void)0 : PreAsyncTrace
#define StateTrace  1 ? (void)0 : PreAsyncTrace
#define FunctTrace  1 ? (void)0 : PreAsyncTrace
#define ErrorTraceX 1 ? (void)0 : PreAsyncTrace
#define DebugTraceX 1 ? (void)0 : PreAsyncTrace

#define MessageTrace( lParam, pbData, cbData )
#define BinaryTrace( lParam, pbData, cbData )
#define UserTrace( lParam, dwUserType, pbData, cbData )

#define TraceFunctEnter( sz )
#define TraceFunctEnterEx( lparam, sz )
#define TraceFunctLeave()

//
// import functions from DBGTRACE.DLL
//
#define	InitAsyncTrace()
#define	TermAsyncTrace()
#define	FlushAsyncTrace()

__inline int PreAsyncTrace( LPARAM lParam, LPCSTR szFormat, ... )
{
        return( 1);
}


#define MessageTrace( lParam, pbData, cbData )
#define BinaryTrace( lParam, pbData, cbData )
#define UserTrace( lParam, dwUserType, pbData, cbData )



#else // NOTRACE

#define FLUSHASYNCTRACE     FlushAsyncTrace(),  // for _ASSERT below

#define FatalTrace  !(__dwEnabledTraces & FATAL_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, FATAL_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define ErrorTrace  !(__dwEnabledTraces & ERROR_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, ERROR_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define DebugTrace  !(__dwEnabledTraces & DEBUG_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, DEBUG_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define StateTrace  !(__dwEnabledTraces & STATE_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, STATE_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define FunctTrace  !(__dwEnabledTraces & FUNCT_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, FUNCT_TRACE_MASK ) &&     \
                    PreAsyncTrace

//
// Support for unspecified function names
//

#define ErrorTraceX  !(__dwEnabledTraces & ERROR_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, "Fn", ERROR_TRACE_MASK ) &&     \
                    PreAsyncTrace

#define DebugTraceX  !(__dwEnabledTraces & DEBUG_TRACE_MASK) ?   \
                    (void)0 :                                   \
                    SetAsyncTraceParams( THIS_FILE, __LINE__, "Fn", DEBUG_TRACE_MASK ) &&     \
                    PreAsyncTrace


//
// use to explicitly remove function tracing even for debug builds
//
#define TraceQuietEnter( sz )                   \
        char    *___pszFunctionName = sz

//
// disable function tracing for retail builds
// reduces code size increase and only should
// only be used sparingly
//
#ifdef  DEBUG

#define TraceFunctEnter( sz )                   \
        TraceQuietEnter( sz );                  \
        FunctTrace( 0, "Entering %s", sz )

#define TraceFunctLeave()                       \
        FunctTrace( 0, "Leaving %s", ___pszFunctionName )

#define TraceFunctEnterEx( lParam, sz )         \
        TraceQuietEnter( sz );                  \
        FunctTrace( lParam, "Entering %s", sz )

#define TraceFunctLeaveEx( lParam )             \
        FunctTrace( lParam, "Leaving %s", ___pszFunctionName )

#else

#define TraceFunctEnter( sz )           TraceQuietEnter( sz )
#define TraceFunctEnterEx( lParam, sz ) TraceQuietEnter( sz )

#define TraceFunctLeave()
#define TraceFunctLeaveEx( lParam )

#endif

//
// import functions from DBGTRACE.DLL
//
extern DbgTraceDLL BOOL WINAPI InitAsyncTrace( void );
extern DbgTraceDLL BOOL WINAPI TermAsyncTrace( void );
extern DbgTraceDLL BOOL WINAPI FlushAsyncTrace( void );




//
// fixed number of parameters for Binary trace macros
//
#define MessageTrace( lParam, pbData, cbData )                  \
        !(__dwEnabledTraces & MESSAGE_TRACE_MASK) ?             \
        (void)0 :                                               \
        SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, MESSAGE_TRACE_MASK ) &&       \
        AsyncBinaryTrace( lParam, TRACE_MESSAGE, pbData, cbData )

#define BinaryTrace( lParam, pbData, cbData )                   \
        !(__dwEnabledTraces & MESSAGE_TRACE_MASK) ?             \
        (void)0 :                                               \
        SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, MESSAGE_TRACE_MASK ) &&       \
        AsyncBinaryTrace( lParam, TRACE_BINARY, pbData, cbData )

#define UserTrace( lParam, dwUserType, pbData, cbData )         \
        !(__dwEnabledTraces & MESSAGE_TRACE_MASK) ?             \
        (void)0 :                                               \
        SetAsyncTraceParams( THIS_FILE, __LINE__, ___pszFunctionName, MESSAGE_TRACE_MASK ) &&       \
        AsyncBinaryTrace( lParam, dwUserType, pbData, cbData )

//
// imported trace flag used by trace macros to determine if the trace
// statement should be executed
//
extern DWORD DbgTraceDLL    __dwEnabledTraces;



extern DbgTraceDLL int WINAPI AsyncStringTrace( LPARAM  lParam,
                                                LPCSTR  szFormat,
                                                va_list marker );

extern DbgTraceDLL int WINAPI AsyncBinaryTrace( LPARAM  lParam,
                                                DWORD   dwBinaryType,
                                                LPBYTE  pbData,
                                                DWORD   cbData );

extern DbgTraceDLL int WINAPI SetAsyncTraceParams(  LPSTR   pszFile,
                                                    int     iLine,
                                                    LPSTR   szFunction,
                                                    DWORD   dwTraceMask );

//
// Trace flag constants
//
#define FATAL_TRACE_MASK    0x00000001
#define ERROR_TRACE_MASK    0x00000002
#define DEBUG_TRACE_MASK    0x00000004
#define STATE_TRACE_MASK    0x00000008
#define FUNCT_TRACE_MASK    0x00000010
#define MESSAGE_TRACE_MASK  0x00000020
#define ALL_TRACE_MASK      0xFFFFFFFF

#define NUM_TRACE_TYPES     6

//
// Output trace types. used by tools to modify the
// registry to change the output target
//
enum tagTraceOutputTypes {
    TRACE_OUTPUT_DISABLED = 0,
    TRACE_OUTPUT_FILE = 1,
    TRACE_OUTPUT_DEBUG = 2,
    TRACE_OUTPUT_DISCARD = 4        // used to find race windows
};

#define TRACE_OUTPUT_INVALID    \
        ~(TRACE_OUTPUT_FILE|TRACE_OUTPUT_DEBUG|TRACE_OUTPUT_DISCARD)


#define IsTraceFile(x)      ((x) & TRACE_OUTPUT_FILE)
#define IsTraceDebug(x)     ((x) & TRACE_OUTPUT_DEBUG)
#define IsTraceDiscard(x)   ((x) & TRACE_OUTPUT_DISCARD)


//
// predefined types of binary trace types.  User defined
// types must be greater than 0x8000
//
enum tagBinaryTypes {
    TRACE_STRING = 0,
    TRACE_BINARY,
    TRACE_MESSAGE,
    TRACE_USER = 0x8000
};

#include <stdarg.h>

//
// use __inline to ensure grab __LINE__ and __FILE__
//
__inline int WINAPIV PreAsyncTrace( LPARAM lParam, LPCSTR szFormat, ... )
{
    va_list marker;
    int     iLength;

    va_start( marker, szFormat );
    iLength = AsyncStringTrace( lParam, szFormat, marker );
    va_end( marker );

    return  iLength;
}

// !defined(NOTRACE) from way at the top of this include file
#endif // !defined(NOTRACE)

// Asserts are independent of tracing
// (with the exception of flushing the trace buffer).

//
// For now enable ASSERT defines only if debugging is enabled
//
#ifdef  DEBUG
#define _ENABLE_ASSERTS

#ifndef NOTRACE
#define _ENABLE_VERBOSE_ASSERTS
#endif	// NO_TRACE

#endif	// DEBUG

//
// Macros added for doing asserts and verifies.  basic clones
// of the MFC macros with a prepended _ symbol
//
#ifdef  _ENABLE_ASSERTS

extern DllExport void WINAPI DebugAssert(	DWORD dwLine,
											LPSTR lpszFunction,
											LPSTR lpszExpression );

#ifndef _ASSERT
#ifdef  _ENABLE_VERBOSE_ASSERTS
#define _ASSERT(f)	!(f) ? DebugAssert( __LINE__,  THIS_FILE, #f ) : ((void)0)
#else
#define _ASSERT(f)	!(f) ? DebugBreak() : ((void)0)
#endif	//_ENABLE_VERBOSE_ASSERTS
#endif

#define _VERIFY(f)	_ASSERT(f)

#else

#define _ASSERT(f)	((void)0)
#define _VERIFY(f)	((void)(f))

#endif	// _ENABLE_ASSERTS


#ifdef __cplusplus
} // extern "C"

#ifdef NOTRACE

#define TraceFunctEntry(sz)

#else

class CTraceEntry
{
public:
    CTraceEntry(char * psz)
    {
        this->___pszFunctionName = psz;
        FunctTrace( 0, "Entering %s", psz);
    }
    ~CTraceEntry()
    {
        FunctTrace( 0, "Leaving %s", this->___pszFunctionName);
    }
    char * ___pszFunctionName;
};

#define TraceFunctEntry(sz) CTraceEntry __cte(sz)

#endif // NOTRACE


#endif


#endif // !defined(_DBGTRACE_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\controller.h ===
//#--------------------------------------------------------------
//
//  File:       controller.h
//
//  Synopsis:   This file holds the declarations of the
//            CCollection class
//
//
//  History:     9/23/97  MKarki Created
//               6/04/98  SBens  Added the InfoBase class.
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------
#ifndef _CONTROLLER_H_
#define _CONTROLLER_H_

#include "radcommon.h"
#include "iasradius.h"
#include "resource.h"
#include "dictionary.h"
#include "prevalidator.h"
#include "preprocessor.h"
#include "packetreceiver.h"
#include "hashmd5.h"
#include "hashhmac.h"
#include "packetsender.h"
#include "reportevent.h"
#include "sendtopipe.h"
#include "tunnelpassword.h"
#include "ports.h"

class CController:
   public IDispatchImpl<IIasComponent,
                        &__uuidof (IIasComponent),
                        &__uuidof (IASRadiusLib)
                        >,
    public IPersistPropertyBag2,
   public CComObjectRoot,
   public CComCoClass<RadiusProtocol,&__uuidof (RadiusProtocol)>,
   private IASTraceInitializer
{
public:

//
// registry declaration for the Radius Protocol
//
IAS_DECLARE_REGISTRY (RadiusProtocol, 1, 0, IASRadiusLib)

//
// this COM Component is not aggregatable
//
DECLARE_NOT_AGGREGATABLE(CController)

//
// MACROS for ATL required methods
//
BEGIN_COM_MAP(CController)
   COM_INTERFACE_ENTRY2(IDispatch, IIasComponent)
   COM_INTERFACE_ENTRY(IIasComponent)
   COM_INTERFACE_ENTRY(IPersistPropertyBag2)
    COM_INTERFACE_ENTRY_FUNC(__uuidof (IRequestSource), 0, &CController::QueryInterfaceReqSrc)
END_COM_MAP()

//
// MACRO to declare Controlling IUnknown method
//
DECLARE_GET_CONTROLLING_UNKNOWN()

    CController (VOID);

    ~CController (VOID);

public:

    //
    //  methods of IPersistPropertyBag2 interface
    //

    STDMETHOD(Load) (
                /*[in]*/    IPropertyBag2   *pIPropertyBag,
                /*[in]*/    IErrorLog       *pIErrLog
                );
    STDMETHOD(Save) (
                /*[in]*/    IPropertyBag2   *pIPropertyBag,
                /*[in]*/    BOOL            bClearDirty,
                /*[in]*/    BOOL            bSaveAllProperties
                );
    STDMETHOD(IsDirty)();

    //
    // IPersist Method
    //
    STDMETHOD (GetClassID) (
               /*[out]*/     CLSID *pClsid
               )
    {
        if (NULL ==  pClsid)
            return (E_FAIL);

        *pClsid = __uuidof (RadiusProtocol);

        return (S_OK);
    }


    //
    //  IIasPropertyNotify method
    //
    STDMETHOD (OnPropertyChange)(
                /*[in]*/    ULONG           ulProperties,
                /*[in]*/    ULONG           *pulProperties,
                /*[in]*/    IPropertyBag2   *pIPropertyBag
                );
    //
    //  methods of IIasComponent interface
    //
    STDMETHOD(Initialize)();

    STDMETHOD(Shutdown)();

    STDMETHOD(GetProperty)(
                /*[in]*/    LONG        id,
                /*[out]*/   VARIANT     *pValue
                );

    STDMETHOD(PutProperty)(
                /*[in]*/    LONG        id,
                /*[in]*/    VARIANT     *pValue
                );

   STDMETHOD(InitNew)();

    STDMETHOD (Suspend) ();

    STDMETHOD (Resume) ();

private:

   CPacketReceiver      *m_pCPacketReceiver;
    CRecvFromPipe       *m_pCRecvFromPipe;
   CPreProcessor      *m_pCPreProcessor;
   CPreValidator      *m_pCPreValidator;
   CDictionary         *m_pCDictionary;
    CClients            *m_pCClients;
    CHashMD5            *m_pCHashMD5;
    CHashHmacMD5        *m_pCHashHmacMD5;
   CSendToPipe         *m_pCSendToPipe;
    CPacketSender       *m_pCPacketSender;
    CReportEvent        *m_pCReportEvent;
    CTunnelPassword     *m_pCTunnelPassword;
    VSAFilter           *m_pCVSAFilter;
    IIasComponent       *m_pInfoBase;   // Auditor that tracks RADIUS events.

    CPorts              m_objAuthPort;

    CPorts              m_objAcctPort;

    //
    //  here the Request servers
    //
    IRequestHandler     *m_pIRequestHandler;

    //
    //  here is the definition of the CRequestSource
    //  which implements the method of the IRequestSource
    //  interface
    //
   class CRequestSource : public IRequestSource
    {

   public:

      CRequestSource (CController *pCController);
      ~CRequestSource ();


        //
      // IUnknown methods - delegate to outer IUnknown
        //
      STDMETHOD(QueryInterface)(
            /*[in]*/    REFIID    riid,
            /*[out]*/   void      **ppv
            )
         {
                IUnknown *pUnknown = m_pCController->GetControllingUnknown();
                return (pUnknown->QueryInterface(riid,ppv));
            }

      STDMETHOD_(ULONG,AddRef)(void)
         {
                IUnknown *pUnknown = m_pCController->GetControllingUnknown();
                return (pUnknown->AddRef());
            }

      STDMETHOD_(ULONG,Release)(void)
         {
                IUnknown *pUnknown = m_pCController->GetControllingUnknown();
                return (pUnknown->Release());
            }

        //
      // IDispatch methods - delegate to outer class object
        //
        STDMETHOD(GetTypeInfoCount)(
            /*[out]*/    UINT    *pctinfo
            )
        {
            return (m_pCController->GetTypeInfoCount (pctinfo));
        }

        STDMETHOD(GetTypeInfo)(
            /*[in]*/    UINT        iTInfo,
            /*[in]*/    LCID        lcid,
            /*[out]*/   ITypeInfo   **ppTInfo
            )
        {
            return (m_pCController->GetTypeInfo (iTInfo, lcid, ppTInfo));
        }

        STDMETHOD(GetIDsOfNames)(
            /*[in]*/    const IID&  riid,
            /*[in]*/    LPOLESTR    *rgszNames,
            /*[in]*/    UINT        cNames,
            /*[in]*/    LCID        lcid,
            /*[out]*/   DISPID      *rgDispId)
        {
            return (m_pCController->GetIDsOfNames (
                        riid, rgszNames, cNames, lcid, rgDispId
                        )
                    );
        }

        STDMETHOD(Invoke)(
            /*[in]*/    DISPID          dispIdMember,
            /*[in]*/    const IID&      riid,
            /*[in]*/    LCID            lcid,
            /*[in]*/    WORD            wFlags,
            /*[in/out]*/DISPPARAMS      *pDispParams,
            /*[out]*/   VARIANT         *pVarResult,
            /*[out]*/   EXCEPINFO      *pExcepInfo,
            /*[out]*/   UINT            *puArgErr
            )
        {
            return (m_pCController->Invoke (
                                dispIdMember,
                                riid,
                                lcid,
                                wFlags,
                                pDispParams,
                                pVarResult,
                                pExcepInfo,
                                puArgErr
                                )
                );
        }

        //
      // IRequestSource Interface method
        //
      STDMETHOD(OnRequestComplete)(
                /*[in]*/ IRequest           *pIRequest,
                /*[in]*/ IASREQUESTSTATUS   eStatus
                );

        private:

      CController*            m_pCController;


   };   // End of nested class CRequestSource


    //
    //  this method is called when somone whants the
    //  IRequestHandlercallback interface
    //
    static HRESULT WINAPI QueryInterfaceReqSrc (
                        VOID        *pThis,
                        REFIID      riid,
                        LPVOID      *ppv,
                        ULONG_PTR   ulpValue
                        );

    //
    //  instantiate this nested class
    //
    CRequestSource m_objCRequestSource;

    //
    // now we can call into private methods of CController
    //
    friend class CRequestSource;

    typedef enum _component_state_
    {
        COMP_SHUTDOWN,
        COMP_UNINITIALIZED,
        COMP_INITIALIZED,
        COMP_SUSPENDED

    }   COMPONENTSTATE, *PCOMPONENTSTATE;

    COMPONENTSTATE m_eRadCompState;

    //
    //  this is the internal initialization method of CController class
    //  object
    //
    HRESULT InternalInit (VOID);

    //
    //  does the internal cleanup of resources
    //
    VOID InternalCleanup (VOID);

};

#endif // !define  _CONTROLLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\hashhmac.cpp ===
//#--------------------------------------------------------------
//        
//  File:		hashhmac.cpp
//        
//  Synopsis:   Implementation of CHashHmacMD5 class methods
//              
//
//  History:     1/28/98  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "hashhmac.h"
#include <md5.h>
#include <hmac.h>

//++--------------------------------------------------------------
//
//  Function:   CHashHmacMD5
//
//  Synopsis:   This is CHashHmacMD5 class constructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     1/28/98
//
//----------------------------------------------------------------
CHashHmacMD5::CHashHmacMD5()
{

}   //  end of CHashHmacMD5 constructor

//++--------------------------------------------------------------
//
//  Function:   ~CHashHmacMD5
//
//  Synopsis:   This is ~CHashHmacMD5 class constructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
CHashHmacMD5::~CHashHmacMD5()
{
}   //  end of CHashHmacMD5 destructor

//++--------------------------------------------------------------
//
//  Function:   HashIt
//
//  Synopsis:   This is HashIt CHashHmacMD5 class public method used
//              carry out hashing of the buffers provided
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     1/28/97
//
//----------------------------------------------------------------
BOOL 
CHashHmacMD5::HashIt (
            PBYTE   pbyAuthenticator,
            PBYTE   pSharedSecret = NULL,
            DWORD   dwSharedSecretSize = 0,
            PBYTE   pBuffer1 = NULL,
            DWORD   dwSize1 = 0,
            PBYTE   pBuffer2 = NULL,
            DWORD   dwSize2 = 0,
            PBYTE   pBuffer3 = NULL,
            DWORD   dwSize3 = 0,
            PBYTE   pBuffer4 = NULL,
            DWORD   dwSize4 = 0,
            PBYTE   pBuffer5 = NULL,
            DWORD   dwSize5 = 0
            )
{
    BOOL    bRetVal = FALSE;
    HMACMD5_CTX Context;

    __try 
    {
        if (NULL == pbyAuthenticator)
            __leave;

        HMACMD5Init (&Context, pSharedSecret, dwSharedSecretSize);
    
        if ((NULL != pBuffer1) && (0  != dwSize1))
        {   
            HMACMD5Update (&Context, pBuffer1, dwSize1);
        }

        if ((NULL != pBuffer2) && (0  != dwSize2))
        {   
            HMACMD5Update (&Context, pBuffer2, dwSize2);
        }

        if ((NULL != pBuffer3) && (0  != dwSize3))
        {   
            HMACMD5Update (&Context, pBuffer3, dwSize3);
        }

        if ((NULL != pBuffer4) && (0  != dwSize4))
        {   
           HMACMD5Update ( &Context, pBuffer4, dwSize4);
        }

        if ((NULL != pBuffer5) && (0  != dwSize5))
        {   
           HMACMD5Update ( &Context, pBuffer5, dwSize5);
        }

        HMACMD5Final (&Context, pbyAuthenticator);
               
        //
        // done the hashing
        //      
        bRetVal = TRUE;

    }
    __finally
    {
        //
        //  nothing here for now 
        // 
    }

    return (bRetVal);

}   //  end of CHmacHashMD5::HashIt method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\controller.cpp ===
//#--------------------------------------------------------------
//
//  File:      controller.cpp
//
//  Synopsis:   Implementation of CController class methods
//
//
//  History:    10/02/97  MKarki Created
//               6/04/98  SBens  Added the InfoBase class.
//               9/09/98  SBens  Let the InfoBase know when we're reset.
//               1/25/00  SBens  Clear the ports in InternalCleanup.
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "controller.h"
#include <new>

LONG g_lPacketCount = 0;
LONG g_lThreadCount = 0;
const DWORD MAX_SLEEP_TIME = 50;  //milliseconds

//++--------------------------------------------------------------
//
//  Function:   CController
//
//  Synopsis:   This is CController class constructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
CController::CController (
            VOID
            )
           :m_objCRequestSource (this),
            m_pCSendToPipe (NULL),
           m_pCDictionary (NULL),
           m_pCPacketReceiver (NULL),
           m_pCPreValidator (NULL),
            m_pCPreProcessor (NULL),
            m_pCClients (NULL),
            m_pCHashMD5 (NULL),
            m_pCHashHmacMD5 (NULL),
            m_pCRecvFromPipe (NULL),
            m_pCPacketSender (NULL),
            m_pCReportEvent (NULL),
            m_pCVSAFilter (NULL),
            m_pInfoBase (NULL),
            m_pCTunnelPassword (NULL),
            m_pIRequestHandler (NULL),
            m_eRadCompState (COMP_SHUTDOWN)
{
}   //   end of CController constructor

//++--------------------------------------------------------------
//
//  Function:   ~CController
//
//  Synopsis:   This is CController class destructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
CController::~CController(
               VOID
               )
{
}   //   end of CController destructor

//++--------------------------------------------------------------
//
//  Function:   InitNew
//
//  Synopsis:   This is the InitNew method exposed through the
//            IIasComponent COM Interface. It is used to
//              initialize the RADIUS protocol component
//
//  Arguments:  NONE
//
//  Returns:    HRESULT   -   status
//
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
STDMETHODIMP
CController::InitNew (
                VOID
                )
{
   HRESULT hr = S_OK;
   BOOL   bStatus = FALSE;

    //
    //  InitNew can only be called from the shutdown state
    //
    if (COMP_SHUTDOWN != m_eRadCompState)
    {
        IASTracePrintf ("Incorrect state for calling InitNew");
        hr = E_UNEXPECTED;
      goto Cleanup;
   }

    //
    //  create the CReportEvent class object
   //
    m_pCReportEvent = new (std::nothrow) CReportEvent ();
   if (NULL == m_pCReportEvent)
   {
        IASTracePrintf (
            "Unable to create ReportEvent object in Controller initialization"
            );
      hr = E_OUTOFMEMORY;
      goto Cleanup;
   }

    //
    //  create the CTunnelPassword class object
    //
    m_pCTunnelPassword = new (std::nothrow) CTunnelPassword;
    if (NULL == m_pCTunnelPassword)
    {
        IASTracePrintf (
          "Unable to create Tunnel-Password object in Controller initialization"
            );
      hr = E_FAIL;
      goto Cleanup;
    }

    //
    //  create the VSAFilter class object
    //
    m_pCVSAFilter = new (std::nothrow) VSAFilter;
    if (NULL == m_pCVSAFilter)
    {
        IASTracePrintf (
          "Unable to create VSA-Filter object in Controller initialization"
            );
      hr = E_FAIL;
      goto Cleanup;
    }

    //
    //  initialize the VSA filter class object
    //
    hr = m_pCVSAFilter->initialize ();
    if (FAILED (hr))
    {
        IASTracePrintf (
          "Unable to initalize VSA-Filter object in Controller initialization"
            );
        delete m_pCVSAFilter;
        m_pCVSAFilter = NULL;
        goto Cleanup;
    }

    //
    //  create the CPacketSender class object
   //
    m_pCPacketSender = new (std::nothrow) CPacketSender ();
   if (NULL == m_pCPacketSender)
   {
        IASTracePrintf (
          "Unable to create Packet-Sender object in Controller initialization"
            );
      hr = E_OUTOFMEMORY;
      goto Cleanup;
   }
    hr = m_pCPacketSender->FinalConstruct();
    if (FAILED(hr))
    {
       goto Cleanup;
    }

    //
    //  create the CHashHmacMD5 class object
   //
    m_pCHashHmacMD5 = new (std::nothrow) CHashHmacMD5 ();
   if (NULL == m_pCHashHmacMD5)
   {
        IASTracePrintf (
          "Unable to create HMAC-MD5 object in Controller initialization"
            );
      hr = E_OUTOFMEMORY;
      goto Cleanup;
   }

    //
    //  create the CHashMD5 class object
   //
    m_pCHashMD5 = new (std::nothrow) CHashMD5 ();
   if (NULL == m_pCHashMD5)
   {
        IASTracePrintf (
          "Unable to create MD5 object in Controller initialization"
            );
      hr = E_OUTOFMEMORY;
      goto Cleanup;
   }


   //
   // create the CDictionary class object
   //
   m_pCDictionary = new (std::nothrow) CDictionary ();
   if (NULL == m_pCDictionary)
   {
        IASTracePrintf (
          "Unable to create Dictionary object in Controller initialization"
            );
      hr = E_OUTOFMEMORY;
      goto Cleanup;
   }

    //
    // initialize the CDictionary class object
    //
    bStatus = m_pCDictionary->Init ();
    if (FALSE == bStatus)
    {
        IASTracePrintf (
          "Unable to initialize Dictionary object in Controller initialization"
            );
      hr = E_FAIL;
      goto Cleanup;
   }

   //
   // create the CClients class object
   //
   m_pCClients = new (std::nothrow) CClients ();
   if (NULL == m_pCClients)
   {
          IASTracePrintf (
            "Unable to create clients object in Controller initialization"
            );
      hr = E_OUTOFMEMORY;
      goto Cleanup;
   }

    //
    //  initialize the CClients call object now
    //
   hr = m_pCClients->Init ();
   if (FAILED (hr))
   {
        IASTracePrintf (
          "Unable to initialize clients object in Controller initialization"
            );
        delete m_pCClients;
        m_pCClients = NULL;
      goto Cleanup;
   }

    //
    //  create the CSendToPipe class object
   //
    m_pCSendToPipe = new (std::nothrow) CSendToPipe();
   if (NULL == m_pCSendToPipe)
   {
          IASTracePrintf (
            "Unable to create Send-To-Pipe object in Controller initialization"
            );
      hr = E_OUTOFMEMORY;
      goto Cleanup;
   }

   //
   // create the CPreProcessor class object
   //
   //
   m_pCPreProcessor = new (std::nothrow) CPreProcessor();
   if (NULL == m_pCPreProcessor)
   {
          IASTracePrintf (
            "Unable to create Pre-Processor object in Controller initialization"
            );
      hr = E_OUTOFMEMORY;
      goto Cleanup;
   }

   //
   // create the CPreValidator class object
   //
   //
   m_pCPreValidator = new (std::nothrow) CPreValidator ();
   if (NULL == m_pCPreValidator)
   {
        IASTracePrintf (
          "Unable to create Pre-Validator object in Controller initialization"
            );
      hr = E_OUTOFMEMORY;
      goto Cleanup;
   }

   //
   // initialize the CPreProcessor class object
   //
   bStatus = m_pCPreProcessor->Init (
                        m_pCPreValidator,
                        m_pCHashMD5,
                        m_pCSendToPipe,
                        m_pCPacketSender,
                        m_pCReportEvent
                        );
   if (FALSE == bStatus)
   {
        IASTracePrintf (
        "Unable to initialize Pre-Processor object in Controller initialization"
         );
      hr = E_FAIL;
      goto Cleanup;
   }

   //
   // initialize the CPreValidator class object
   //
   bStatus = m_pCPreValidator->Init (
                  m_pCDictionary,
                        m_pCPreProcessor,
                        m_pCClients,
                        m_pCHashMD5,
                        m_pCSendToPipe,
                        m_pCReportEvent
                  );
   if (FALSE == bStatus)
   {
        IASTracePrintf (
        "Unable to initialize Pre-Validator object in Controller initialization"
         );
      hr = E_FAIL;
      goto Cleanup;
   }

   //
   // create the CRecvFromPipe class object
   //
   m_pCRecvFromPipe = new (std::nothrow) CRecvFromPipe (
                                                m_pCPreProcessor,
                                                m_pCHashMD5,
                                                m_pCHashHmacMD5,
                                                m_pCClients,
                                                m_pCVSAFilter,
                                                m_pCTunnelPassword,
                                                m_pCReportEvent
                                          );
   if (NULL == m_pCRecvFromPipe)
   {
        IASTracePrintf (
            "Unable to create RecvFromPipe object in Controller initialization"
             );
      hr = E_FAIL;
      goto Cleanup;
   }

   // create the CPacketReceiver class object
   //
   m_pCPacketReceiver = new (std::nothrow) CPacketReceiver ();
   if (NULL == m_pCPacketReceiver)
   {
        IASTracePrintf (
          "Unable to create Packet-Receiver object in Controller initialization"
          );
      hr = E_OUTOFMEMORY;
      goto Cleanup;
   }

   //
   // initialize the CPacketReceiver class object
   //
   bStatus = m_pCPacketReceiver->Init (
                        m_pCDictionary,
                  m_pCPreValidator,
                        m_pCHashMD5,
                        m_pCHashHmacMD5,
                        m_pCClients,
                        m_pCReportEvent
                  );
   if (FALSE == bStatus)
   {
        IASTracePrintf (
            "Unable to initialize Packet-Receiver object "
            "in Controller initialization"
            );
      hr = E_FAIL;
      goto Cleanup;
   }


    //
    //  initialize the CSendToPipe class object
    //
    bStatus = m_pCSendToPipe->Init (
                        reinterpret_cast <IRequestSource*>
                                    (&m_objCRequestSource),
                                    m_pCVSAFilter,
                                    m_pCReportEvent
                        );
    if (FALSE == bStatus)
    {
        IASTracePrintf (
         "Unable to initialize Send-to-pipe object in Controller initialization"
          );
      hr = E_FAIL;
      goto Cleanup;
    }

    //
    //  Create and InitNew the InfoBase object
    //
    CLSID clsid;
    hr = CLSIDFromProgID(IAS_PROGID(InfoBase), &clsid);
    if (SUCCEEDED(hr))
    {
       hr = CoCreateInstance(clsid,
                             NULL,
                             CLSCTX_INPROC_SERVER,
                             __uuidof(IIasComponent),
                             (PVOID*)&m_pInfoBase);

       if (SUCCEEDED(hr))
       {
          hr = m_pInfoBase->InitNew();
       }
    }
    if (FAILED(hr))
    {
        IASTracePrintf (
         "Unable to create InfoBase auditor in Controller initialization"
          );
      goto Cleanup;
    }

    //
    //  reset make the global counts as a precaution
    //
    g_lPacketCount  = 0;
    g_lThreadCount  = 0;

    //
    //  if we have reached here than InitNew succeeded and we
    //  are in Uninitialized state
    //
    m_eRadCompState = COMP_UNINITIALIZED;

Cleanup:


   //
   // if we failed its time to cleanup
   //
    if (FAILED (hr)) { InternalCleanup (); }

   return (hr);

}   // end of CController::OnInit method

//++--------------------------------------------------------------
//
//  Function:   Load
//
//  Synopsis:   This is the  IPersistPropertyBag2 COM Interface
//              method which is called in to indicate that its
//              time to load configuration information from the
//              property bag.
//
//  Arguments:
//              [in]    IPropertyBag2
//              [in]    IErrorLog
//
//  Returns:    HRESULT   -   status
//
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
STDMETHODIMP
CController::Load (
                IPropertyBag2   *pIPropertyBag,
                IErrorLog       *pIErrorLog
                )
{

    if ((NULL == pIPropertyBag) || (NULL == pIErrorLog)){return (E_POINTER);}

    return (S_OK);

}   //  end of CController::Load method

//++--------------------------------------------------------------
//
//  Function:   Save
//
//  Synopsis:   This is the  IPersistPropertyBag2 COM Interface
//              method which is called in to indicate that its
//              time to save configuration information from the
//              property bag.
//
//  Arguments:
//              [in]    IPropertyBag2
//              [in]    BOOL    -   Dirty Bit flag
//              [in]    BOOL    -   save all properties
//
//  Returns:    HRESULT   -   status
//
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
STDMETHODIMP
CController::Save (
                IPropertyBag2   *pIPropertyBag,
                BOOL            bClearDirty,
                BOOL            bSaveAllProperties
                )
{
    if  (NULL == pIPropertyBag) {return (E_POINTER);}

    return (S_OK);

}   //  end of CController::Save method

//++--------------------------------------------------------------
//
//  Function:   IsDirty
//
//  Synopsis:   This is the  IPersistPropertyBag2 COM Interface
//              method which is called to check if any of the
//              properties data have become dirty
//
//  Arguments:
//
//  Returns:    HRESULT   -   status
//
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
STDMETHODIMP
CController::IsDirty (
                VOID
                )
{
    return (S_FALSE);

}   //  end of CController::Save method

//++--------------------------------------------------------------
//
//  Function:   Initialize
//
//  Synopsis:   This is the OnStart method exposed through the
//            IIasComponent COM Interface. It is used to start
//            processing data
//
//  Arguments:  NONE
//
//  Returns:    HRESULT   -   status
//
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
STDMETHODIMP
CController::Initialize (
                VOID
                )
{
    IASTracePrintf ("Initializing Radius component....");

    //
    // Initialize call can only be made from Uninitialized state
    //
    if (COMP_INITIALIZED == m_eRadCompState)
    {
        return (S_OK);
    }
    else if (COMP_UNINITIALIZED != m_eRadCompState)
    {
        IASTracePrintf (
            "Unable to initialize Radius Component in this state"
            );
        return (E_UNEXPECTED);
    }

    //
    //  We forward all state transitions to the InfoBase auditor.
    //
    HRESULT hr = m_pInfoBase->Initialize();
    if (FAILED (hr))
    {
        IASTracePrintf ( "InfoBase initialization failed" );
        return (hr);
    }

    //
    //  call the internal initializer now
    //
    hr = InternalInit ();
   if (FAILED (hr)) { return (hr); }

    //
    //  we have finished initialization here
    //
    m_eRadCompState = COMP_INITIALIZED;

    IASTracePrintf ("Radius component initialized.");

    return (S_OK);

}   //  end of CController::Start method

//++--------------------------------------------------------------
//
//  Function:   Shutdown
//
//  Synopsis:   This is the OnShutDown method exposed through the
//            IComponent COM Interface. It is used to stop
//            processing data
//
//  Arguments:  NONE
//
//  Returns:    HRESULT   -   status
//
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
STDMETHODIMP
CController::Shutdown (
                VOID
                )
{
    BOOL    bStatus = FALSE;
    HRESULT hr = S_OK;

    IASTracePrintf ("Shutting down Radius Component...");

    //
    //  shutdown can only be called from the suspend state
    //
    if (COMP_SHUTDOWN == m_eRadCompState)
    {
        return (S_OK);
    }
    else if (
            (COMP_SUSPENDED != m_eRadCompState)   &&
            (COMP_UNINITIALIZED != m_eRadCompState)
            )
    {
        IASTracePrintf (
            "Radius component can not be shutdown in this state"
            );
        return (E_UNEXPECTED);
    }

    //
    //  We forward all state transitions to the InfoBase auditor.
    //
    hr = m_pInfoBase->Shutdown();
    if (FAILED (hr))
    {
        IASTracePrintf ("InfoBase shutdown failed");
    }


    //
    //  do the internal cleanup now
    //
    InternalCleanup ();

    //
    //  we have cleanly shutdown
    //
    m_eRadCompState = COMP_SHUTDOWN;


    IASTracePrintf ("Radius component shutdown completed");

    return (hr);

}   //  end of CController::Shutdown method

//++--------------------------------------------------------------
//
//  Function:   Suspend
//
//  Synopsis:   This is the Suspend method exposed through the
//            IComponent COM Interface. It is used to suspend
//              packet processing operations
//
//  Arguments:  NONE
//
//  Returns:    HRESULT   -   status
//
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
STDMETHODIMP
CController::Suspend (
                VOID
                )
{
    BOOL    bStatus = FALSE;
    HRESULT hr = S_OK;

    IASTracePrintf ("Suspending Radius component...");

    //
    //  suspend can only be called from the initialized state
    //
    if (COMP_SUSPENDED == m_eRadCompState)
    {
        return (S_OK);
    }
    else if (COMP_INITIALIZED != m_eRadCompState)
    {
        IASTracePrintf (
            "Radius component can not be suspended in current state"
            );
        return (E_UNEXPECTED);
    }

    //
    //  We forward all state transitions to the InfoBase auditor.
    //
    hr = m_pInfoBase->Suspend();
    if (FAILED (hr))
    {
        IASTracePrintf ("Infobase suspend failed");
    }

    //
    //  stop receiving packets now
    //
    bStatus = m_pCPacketReceiver->StopProcessing ();
    if (FALSE == bStatus) { hr =  E_FAIL; }

    //
    //  now wait till all requests are completed
    //
    while ( g_lPacketCount )
    {
        IASTracePrintf (
            "Packet Left to process:%d",
            g_lPacketCount
            );
        Sleep (MAX_SLEEP_TIME);
    }

   //
    //  stop sending out packets
    //
    bStatus = m_pCPacketSender->StopProcessing ();
    if (FALSE == bStatus) { hr =  E_FAIL; }

    //
    //  stop sending packets to the pipeline
    //
    bStatus = m_pCSendToPipe->StopProcessing ();
    if (FALSE == bStatus) { hr =  E_FAIL; }

    //
    //  now wait till allour earlier threads are back
    //  and requests are completed
    //
    while ( g_lThreadCount )
    {
        IASTracePrintf (
            "Worker thread active:%d",
            g_lThreadCount
            );
        Sleep (MAX_SLEEP_TIME);
    }

    m_objAuthPort.CloseSockets();
    m_objAcctPort.CloseSockets();

    //
    //  we have successfully suspended RADIUS component's packet
    //  processing operations
    //
    m_eRadCompState = COMP_SUSPENDED;

    IASTracePrintf ("Radius component suspended.");

    return (hr);

}   //  end of CController::Suspend method

//++--------------------------------------------------------------
//
//  Function:   Resume
//
//  Synopsis:   This is the Resume method exposed through the
//            IComponent COM Interface. It is used to resume
//              packet processing operations which had been
//              stopped by a previous call to Suspend API
//
//
//  Arguments:  NONE
//
//  Returns:    HRESULT   -   status
//
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
STDMETHODIMP
CController::Resume (
                VOID
                )
{
    IASTracePrintf ("Resuming Radius component...");

    if (COMP_SUSPENDED != m_eRadCompState)
    {
        IASTracePrintf ("Can not resume Radius component in current state");
        return (E_UNEXPECTED);
    }

    //
    //  We forward all state transitions to the InfoBase auditor.
    //
    HRESULT hr = m_pInfoBase->Resume();
    if (FAILED (hr))
    {
        IASTracePrintf ("Unable to resume Infobase");
        return (hr);
    }

   hr = m_objAuthPort.OpenSockets();
   if (SUCCEEDED(hr))
   {
      hr = m_objAcctPort.OpenSockets();
      if (SUCCEEDED(hr))
      {
         hr = InternalInit();
         if (SUCCEEDED(hr))
         {
            m_eRadCompState = COMP_INITIALIZED;
            IASTraceString("Radius componend resumed.");
         }
      }
   }
   if (FAILED(hr))
   {
      m_objAuthPort.CloseSockets();
      m_objAcctPort.CloseSockets();
   }

   return hr;
}   //  end of CController::Resume method


//++--------------------------------------------------------------
//
//  Function:   GetProperty
//
//  Synopsis:   This is the IIasComponent Interface method used
//              to get property information from the RADIUS protocol
//              component
//
//  Arguments:
//              [in]    LONG    -   id
//              [out]   VARIANT -   *pValue
//
//  Returns:    HRESULT   -   status
//
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
STDMETHODIMP
CController::GetProperty (
                LONG        id,
                VARIANT     *pValue
                )
{
    return (S_OK);

}   //  end of CController::GetProperty method

//++--------------------------------------------------------------
//
//  Function:   PutProperty
//
//  Synopsis:   This is the IIasComponent Interface method used
//              to put property information int the RADIUS protocol
//              component
//
//  Arguments:
//              [in]    LONG    -   id
//              [out]   VARIANT -   *pValue
//
//  Returns:    HRESULT   -   status
//
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
STDMETHODIMP
CController::PutProperty (
                LONG        id,
                VARIANT     *pValue
                )
{
    HRESULT hr = S_OK;

    //
    //  PutProperty method can only be called from
    //  Uninitialized, Initialized or Suspended state
    //
    if (
        (COMP_UNINITIALIZED != m_eRadCompState) &&
        (COMP_INITIALIZED != m_eRadCompState)   &&
        (COMP_SUSPENDED != m_eRadCompState)
        )
    {
        IASTracePrintf ("Unable to PutProperty in current state");
        return (E_UNEXPECTED);
    }

    //
    //  check if valid arguments where passed in
    //
    if (NULL == pValue) { return (E_POINTER); }

    //
    // carry out the property intialization now
    //
    switch (id)
    {

    case PROPERTY_RADIUS_ACCOUNTING_PORT:

        if (VT_BSTR != V_VT (pValue))
        {
            hr = DISP_E_TYPEMISMATCH;
        }
        else if (COMP_INITIALIZED != m_eRadCompState)
        {
            //
            //  initialize Accounting Port
            //
            m_objAcctPort.SetConfig(V_BSTR(pValue));
        }
        break;

    case PROPERTY_RADIUS_AUTHENTICATION_PORT:

        if (VT_BSTR != V_VT (pValue))
        {
            hr = DISP_E_TYPEMISMATCH;
        }
        else if (COMP_INITIALIZED != m_eRadCompState)
        {
            //
            //  initialize Authentication Port
            //
            m_objAuthPort.SetConfig(V_BSTR(pValue));
        }
        break;

    case PROPERTY_RADIUS_CLIENTS_COLLECTION:

        hr = m_pCClients->SetClients (pValue);
        break;

    case PROPERTY_PROTOCOL_REQUEST_HANDLER:

        if (VT_DISPATCH != pValue->vt)
        {
            hr = DISP_E_TYPEMISMATCH;
        }
        else if (NULL == pValue->punkVal)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            //
            //  initialize the provider
            //
            m_pIRequestHandler = reinterpret_cast <IRequestHandler*>
                                                        (pValue->punkVal);
            m_pIRequestHandler->AddRef ();

            //
            //  now that we have the request handler set,
            //  we are ready to start processing requests
            //
            if (COMP_INITIALIZED == m_eRadCompState)
            {
                hr = InternalInit ();
            }
        }
        break;

    default:
        hr = DISP_E_MEMBERNOTFOUND;
        break;
    }

    //
    // Tickle the InfoBase to let it know we've been reset.
    //
    m_pInfoBase->PutProperty(0, NULL);

    return (hr);

}   //  end of CController::PutProperty method

//++--------------------------------------------------------------
//
//  Function:   InternalInit
//
//  Synopsis:   This is the InternalInit private method
//            of the CController class object which is used
//              to the initialization when the Initialize or
//              Resume methods of the IIasComponent interface
//              are called
//
//  Arguments:  NONE
//
//  Returns:    HRESULT   -   status
//
//  History:    MKarki      Created     4/28/98
//
//----------------------------------------------------------------
HRESULT
CController::InternalInit (
                VOID
                )
{
    BOOL    bStatus = FALSE;
    HRESULT hr = S_OK;

    __try
    {
        //
        //
        //  check if we have the RequestHandler in place
        //
        if (NULL == m_pIRequestHandler) { __leave; }

        //
        // get the authentication socket set
        //
        fd_set AuthSet;
        m_objAuthPort.GetSocketSet(AuthSet);

        //
        // get the accounting socket set
        //
        fd_set AcctSet;
        m_objAcctPort.GetSocketSet(AcctSet);

        //
        //  start sending data to pipe
        //
        bStatus = m_pCSendToPipe->StartProcessing (m_pIRequestHandler);
        if (FALSE == bStatus)
        {
            hr =  E_FAIL;
            __leave;
        }

        //
        //  start sending out packets
        //
        bStatus = m_pCPacketSender->StartProcessing ();
        if (FALSE == bStatus)
        {
            hr =  E_FAIL;
            __leave;
        }

        //
        //  start receiving packets now
        //
        bStatus = m_pCPacketReceiver->StartProcessing (AuthSet, AcctSet);
        if (FALSE == bStatus)
        {
            hr =  E_FAIL;
            __leave;
        }

        //
        //  we have finished internal initialization here
        //
    }
    __finally
    {
        if (FAILED (hr))
        {
            //
            //  if failed, disconnect from backend
            //
            m_pCPacketReceiver->StopProcessing ();
            m_pCPacketSender->StopProcessing ();
            m_pCSendToPipe->StopProcessing ();
         }
    }

    return (hr);

}   //  end of CController::InternalInit method

//++--------------------------------------------------------------
//
//  Function:   InternalCleanup
//
//  Synopsis:   This is the InternalInit private method
//            of the CController class object which is used
//              to shutdown the internal resources when then
//              InitNew call failed or Shutdown is called
//
//  Arguments:  NONE
//
//  Returns:    HRESULT   -   status
//
//  History:    MKarki      Created     4/28/98
//
//----------------------------------------------------------------
VOID
CController::InternalCleanup (
                VOID
                )
{
    //
    //  release the IRequestHandler interfaces
    //
    if (m_pIRequestHandler)
    {
        m_pIRequestHandler->Release ();
        m_pIRequestHandler = NULL;
    }

    //
    //  shutdown the VSA filter object
    //
    if (m_pCVSAFilter) { m_pCVSAFilter->shutdown (); }

    //
    //  stop the CClients object from resolving DNS names
    //
    if (m_pCClients) { m_pCClients->Shutdown (); }

    // Close all the ports.
    m_objAuthPort.Clear();
    m_objAcctPort.Clear();

    //
    //  delete all the internal objects
    //
    if (m_pInfoBase)
    {
       m_pInfoBase->Release();
       m_pInfoBase = NULL;
    }

    if (m_pCTunnelPassword)
    {
        delete m_pCTunnelPassword;
        m_pCTunnelPassword = NULL;
    }

    if (m_pCVSAFilter)
    {
        delete m_pCVSAFilter;
        m_pCVSAFilter = NULL;
    }

    if (m_pCPacketSender)
    {
        delete m_pCPacketSender;
        m_pCPacketSender = NULL;
    }

    if (m_pCSendToPipe)
    {
        delete m_pCSendToPipe;
        m_pCSendToPipe = NULL;
    }

   if (m_pCRecvFromPipe)
    {
      delete m_pCRecvFromPipe;
        m_pCRecvFromPipe = NULL;
    }

   if (m_pCPacketReceiver)
    {
      delete m_pCPacketReceiver;
        m_pCPacketReceiver = NULL;
    }

    if (m_pCPreProcessor)
    {
        delete m_pCPreProcessor;
        m_pCPreProcessor = NULL;
    }

   if (m_pCPreValidator)
    {
      delete m_pCPreValidator;
        m_pCPreValidator = NULL;
    }

   if (m_pCDictionary)
    {
      delete m_pCDictionary;
        m_pCDictionary = NULL;
    }

   if (m_pCClients)
    {
      delete m_pCClients;
        m_pCClients = NULL;
    }

    if (m_pCHashMD5)
    {
        delete m_pCHashMD5;
        m_pCHashMD5 = NULL;
    }

    if (m_pCHashHmacMD5)
    {
        delete m_pCHashHmacMD5;
        m_pCHashHmacMD5 = NULL;
    }

    if (m_pCReportEvent)
    {
        delete m_pCReportEvent;
        m_pCReportEvent = NULL;
    }

    return;

}   //  end of CController::InternalCleanup method


//++--------------------------------------------------------------
//
//  Function:   OnPropertyChange
//
//  Synopsis:   This is the OnPropertyChange method exposed through the
//            IComponentNotify COM Interface. It is called to notify
//              the component of any change in its properties
//
//  Arguments:
//
//  Returns:    HRESULT   -   status
//
//
//  History:    MKarki      Created     12/3/97
//
//----------------------------------------------------------------
STDMETHODIMP
CController::OnPropertyChange (
                ULONG           ulProperties,
                ULONG           *pulProperties,
                IPropertyBag2   *pIPropertyBag
                )
{

    if ((NULL == pulProperties) || (NULL == pIPropertyBag))
        return (E_POINTER);

    return (S_OK);

}   //  end of CController::OnPropertyChange method

//++--------------------------------------------------------------
//
//  Function:   QueryInterfaceReqSrc
//
//  Synopsis:   This is the function called when this Component
//              is called and queried for its IRequestSource
//              interface
//
//  Arguments:  NONE
//
//  Returns:    HRESULT   -   status
//
//
//  History:    MKarki      Created     11/21/97
//
//----------------------------------------------------------------
HRESULT WINAPI
CController::QueryInterfaceReqSrc (
                PVOID       pThis,
                REFIID      riid,
                LPVOID      *ppv,
                ULONG_PTR   ulpValue
                )
{
     *ppv = &(static_cast<CController*>(pThis))->m_objCRequestSource;

    //
    // increment count
    //
    ((LPUNKNOWN)*ppv)->AddRef();

    return (S_OK);

}   //  end of CController::QueryInterfaceReqSrc method

//++--------------------------------------------------------------
//
//  Function:   CRequestSource
//
//  Synopsis:   This is the constructor of the CRequestSource
//              nested  class
//
//  Arguments:
//              CController*
//
//  Returns:
//
//
//  History:    MKarki      Created     11/21/97
//
//----------------------------------------------------------------
CController::CRequestSource::CRequestSource (
                    CController *pCController
                    )
            :m_pCController (pCController)
{
    _ASSERT (pCController);

}   //  end of CRequestSource constructor

//++--------------------------------------------------------------
//
//  Function:   ~CRequestSource
//
//  Synopsis:   This is the destructor of the CRequestSource
//              nested  class
//
//  Arguments:
//
//
//  Returns:    HRESULT   -   status
//
//
//  History:    MKarki      Created     11/21/97
//
//----------------------------------------------------------------
CController::CRequestSource::~CRequestSource()
{
}   //  end of CRequestSource destructor

//++--------------------------------------------------------------
//
//  Function:   OnRequestComplete
//
//  Synopsis:   This is the function called when a request is
//              is being pushed back after backend processing
//
//  Arguments:
//              [in]    IRequest*
//              [in]    IASREQUESTSTATUS
//
//  Returns:    HRESULT   -   status
//
//
//  History:    MKarki      Created     1/20/98
//
//----------------------------------------------------------------
STDMETHODIMP CController::CRequestSource::OnRequestComplete (
                        IRequest            *pIRequest,
                        IASREQUESTSTATUS    eStatus
                        )
{
    HRESULT     hr = S_OK;
    BOOL        bStatus = FALSE;

    __try
    {
        if (NULL == pIRequest)
        {
            IASTracePrintf (
                "Invalid argument passed to OnRequestComplete method"
                );
           hr =  E_POINTER;
           __leave;
        }

        //
        //  start using this interface in processing outbound
        //  requests now
        //
        hr = m_pCController->m_pCRecvFromPipe->Process (pIRequest);
        if  (FAILED (hr)) { __leave; }

        //
        //  success
        //

    }
    __finally
    {
    }

    return (hr);

}   //  end of CController::CRequestSource::OnRequestComplete method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\hashhmac.h ===
//#--------------------------------------------------------------
//        
//  File:       hmachhash.h
//        
//  Synopsis:   This file holds the declarations of the 
//				CHmacMD5 class 
//              
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------

#ifndef _HMACHASH_H_
#define _HMACHASH_H_
 
#include "hash.h"

class CHashHmacMD5 : public CHash
{
public:

	CHashHmacMD5();

	virtual ~CHashHmacMD5();

    BOOL HashIt (
        /*[out]*/   PBYTE   pbyAuthenticator,
        /*[in]*/    PBYTE   pSharedSecret,
        /*[in]*/    DWORD   dwSharedSecretSize,
        /*[in]*/    PBYTE   pBuffer1,
        /*[in]*/    DWORD   dwSize1,
        /*[in]*/    PBYTE   pBuffer2,
        /*[in]*/    DWORD   dwSize2,
        /*[in]*/    PBYTE   pBuffer3,
        /*[in]*/    DWORD   dwSize3, 
        /*[in]*/    PBYTE   pBuffer4,
        /*[in]*/    DWORD   dwSize4,
        /*[in]*/    PBYTE   pBuffer5,
        /*[in]*/    DWORD   dwSize5
            );

	BOOL Init (VOID) {return (TRUE);};
};

#endif // ifndef _HMACHASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\hashmd5.h ===
//#--------------------------------------------------------------
//        
//  File:      hashmd5.h
//        
//  Synopsis:   This file holds the declarations of the 
//				CHashMD5 class
//              
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------

#ifndef _HASHMD5_H_
#define _HASHMD5_H_
 
#include "hash.h"

class CHashMD5 : public CHash  
{
public:

	CHashMD5();

	virtual ~CHashMD5();

    BOOL HashIt (
        /*[out]*/   PBYTE   pbyAuthenticator,
        /*[in]*/    PBYTE   pSecret,
        /*[in]*/    DWORD   dwSecretSize,
        /*[in]*/    PBYTE   pBuffer1,
        /*[in]*/    DWORD   dwSize1,
        /*[in]*/    PBYTE   pBuffer2,
        /*[in]*/    DWORD   dwSize2,
        /*[in]*/    PBYTE   pBuffer3,
        /*[in]*/    DWORD   dwSize3, 
        /*[in]*/    PBYTE   pBuffer4,
        /*[in]*/    DWORD   dwSize4,
        /*[in]*/    PBYTE   pBuffer5,
        /*[in]*/    DWORD   dwSize5
            );

	BOOL Init (VOID) {return (TRUE);};
};

#endif // ifndef _HASHMD5_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\hashmd5.cpp ===
//#--------------------------------------------------------------
//        
//  File:		hashmd5.cpp
//        
//  Synopsis:   Implementation of CHashMD5 class methods
//              
//
//  History:     10/2/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "hashmd5.h"
#include <md5.h>

//++--------------------------------------------------------------
//
//  Function:   CHashMD5
//
//  Synopsis:   This is CHashMD5 class constructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
CHashMD5::CHashMD5()
{

}

//++--------------------------------------------------------------
//
//  Function:   ~CHashMD5
//
//  Synopsis:   This is ~CHashMD5 class constructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
CHashMD5::~CHashMD5()
{

}

//++--------------------------------------------------------------
//
//  Function:   HashIt
//
//  Synopsis:   This is HashIt CHashMD5 class public method used
//              carry out hashing of the buffers provided
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
BOOL 
CHashMD5::HashIt (
            PBYTE   pbyAuthenticator,
            PBYTE   pKey = NULL,
            DWORD   dwKeySize = 0,
            PBYTE   pBuffer1 = NULL,
            DWORD   dwSize1 = 0,
            PBYTE   pBuffer2 = NULL,
            DWORD   dwSize2 = 0,
            PBYTE   pBuffer3 = NULL,
            DWORD   dwSize3 = 0,
            PBYTE   pBuffer4 = NULL,
            DWORD   dwSize4 = 0,
            PBYTE   pBuffer5 = NULL,
            DWORD   dwSize5 = 0
            )
{
    BOOL    bRetVal = FALSE;
    MD5_CTX md5Context;

    __try 
    {
        if (NULL == pbyAuthenticator)
            __leave;

        MD5Init (&md5Context);
    
        if ((NULL != pBuffer1) && (0  != dwSize1))
        {   
            MD5Update (
                &md5Context, 
                reinterpret_cast <const unsigned char * > (pBuffer1), 
                dwSize1
                );
         }

        if ((NULL != pBuffer2) && (0  != dwSize2))
        {   
            MD5Update (
                &md5Context, 
                reinterpret_cast <const unsigned char * > (pBuffer2), 
                dwSize2
                );
         }

        if ((NULL != pBuffer3) && (0  != dwSize3))
        {   
            MD5Update (
                &md5Context, 
                reinterpret_cast <const unsigned char * > (pBuffer3), 
                dwSize3
                );
         }

        if ((NULL != pBuffer4) && (0  != dwSize4))
        {   
            MD5Update (
                &md5Context, 
                reinterpret_cast <const unsigned char * > (pBuffer4), 
                dwSize4
                );
         }

        if ((NULL != pBuffer5) && (0  != dwSize5))
        {   
            MD5Update (
                &md5Context, 
                reinterpret_cast <const unsigned char * > (pBuffer5), 
                dwSize5
                );
         }

        MD5Final (&md5Context);

        ::memcpy (pbyAuthenticator, md5Context.digest, MD5DIGESTLEN);
               
        //
        // done the hashing
        //      
        bRetVal = TRUE;

    }
    __finally
    {
        //
        //  nothing here for now 
        // 
    }

    return (bRetVal);

}   //  end of CHashMD5::HashIt method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\packetio.h ===
//#--------------------------------------------------------------
//        
//  File:       packetio.h
//        
//  Synopsis:   This file holds the declarations of the 
//				CPacketIo class
//              
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _PACKETIO_H_
#define _PACKETIO_H_

#include "radcommon.h"
#include "perimeter.h"

class CPacketIo  : public Perimeter
{
public:

    //
    //  start processing the packet I/O
    //
    virtual BOOL StartProcessing ();
    //
    //  stop processing packet I/O
    //
    virtual BOOL StopProcessing ();

    //
    //  constructor
    //
	CPacketIo();

    //
    //  destructor
    //
	virtual ~CPacketIo();

protected:

    //
    //  enable the processing 
    //
    BOOL    EnableProcessing (VOID);

    //
    //  disable processing
    //
    BOOL    DisableProcessing (VOID);

    //
    //  check if processing is enabled
    //  
    BOOL    IsProcessingEnabled (VOID);

private:
    
    BOOL    m_bProcessData;
};

#endif //	infndef _PACKETRECEIVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\logresult.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    logresult.h
//
// SYNOPSIS
//
//    Declares the function IASRadiusLogResult.
//
// MODIFICATION HISTORY
//
//    04/23/1999    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef LOGRESULT_H
#define LOGRESULT_H
#if _MSC_VER >= 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

VOID
WINAPI
IASRadiusLogResult(
    IRequest* request,
    IAttributesRaw* raw
    );

#ifdef __cplusplus
}
#endif
#endif  // LOGRESULT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\iasradius.cpp ===
//#--------------------------------------------------------------
//        
//  File:       iasradius.cpp
//        
//  Synopsis:   this is the main Source File for the UDP
//              Protocol DLL
//              
//
//  History:     8/18/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------


//
// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f radprotops.mk in the project directory.

#include "radcommon.h"
#include "controller.h"
#include "proxy.h"
#include <newop.cpp>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(__uuidof(RadiusProtocol), CController)
	OBJECT_ENTRY(__uuidof(RadiusProxy),
                IASRequestHandlerObject< RadiusProxy >)
	OBJECT_ENTRY(__uuidof(CClient), CClient)
END_OBJECT_MAP()

//++--------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Disabling thread calls
//
//  Arguments:  [in]    HINSTANCE - module handle
//              [in]    DWORD     - reason for call
//              reserved 
//
//  Returns:    BOOL    -   sucess/failure
//
//
//  History:    MKarki      Created     8/20/97
//
//----------------------------------------------------------------
extern "C" BOOL WINAPI 
DllMain(
    HINSTANCE   hInstance, 
    DWORD       dwReason, 
    LPVOID      lpReserved
    )
{

	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
		_Module.Term();
    }

	return (TRUE);

}   //  end of DllMain method

//++--------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Used to determine if the DLL can be unloaded
//
//  Arguments:  NONE
//
//  Returns:    HRESULT
//
//
//  History:    MKarki      Created     8/20/97
//
//----------------------------------------------------------------
STDAPI 
DllCanUnloadNow(
            VOID
            )
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;

}   //  end of DllCanUnloadNow method

//++--------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Returns a class factory to create an object 
//              of the requested type
//
//  Arguments: [in]  REFCLSID  
//             [in]  REFIID    
//             [out] LPVOID -   class factory
//              
//
//  Returns:    HRESULT
//
//
//  History:    MKarki      Created     8/20/97
//
//----------------------------------------------------------------
STDAPI 
DllGetClassObject(
            REFCLSID rclsid, 
            REFIID riid, 
            LPVOID* ppv
            )
{
	return (_Module.GetClassObject(rclsid, riid, ppv));

}   //  end of DllGetClassObject method

//++--------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Add entries to the system registry
//
//  Arguments:  NONE
//
//  Returns:    HRESULT
//
//
//  History:    MKarki      Created     8/20/97
//
//----------------------------------------------------------------
STDAPI DllRegisterServer(
            VOID
            )
{
    //
	// registers object, typelib and all interfaces in typelib
    //
	return (_Module.RegisterServer(TRUE));

}   //  end of DllRegisterServer method

//++--------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Removes entries from the system registry
//
//  Arguments:  NONE
//
//  Returns:    HRESULT
//
//
//  History:    MKarki      Created     8/20/97
//
//----------------------------------------------------------------
STDAPI DllUnregisterServer(
        VOID
        )
{
	_Module.UnregisterServer();
	return (S_OK);

}   //  end of DllUnregisterServer method

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\packetradius.h ===
//#--------------------------------------------------------------
//
//  File:       packetradius.h
//
//  Synopsis:   This file holds the declarations of the
//				CPacketRadius class
//
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-2001 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------

#ifndef _PACKETRADIUS_H_
#define _PACKETRADIUS_H_


#include "mempool.h"
#include "client.h"
#include "proxyinfo.h"
#include "hashmd5.h"
#include "hashhmac.h"
#include "dictionary.h"
#include "reportevent.h"
#include <new>


class CPacketRadius
{
public:

    inline SOCKET GetSocket () {return (m_socket);}

    inline DWORD GetInRadiusAttributeCount (VOID)
        {return (m_dwInAttributeCount);}

    inline DWORD GetInAttributeCount (VOID)
        {return (m_dwInAttributeCount + COMPONENT_SPECIFIC_ATTRIBUTE_COUNT);}


	inline PATTRIBUTEPOSITION GetInAttributes (VOID)
        {return (m_pIasAttribPos);}

    inline WORD GetInPort (VOID)
        {return (m_wInPort);}

    inline WORD GetOutPort (VOID)
        {return (m_wOutPort);}

	inline DWORD GetInAddress (VOID)
        {return (m_dwInIPaddress);}

	inline DWORD GetOutAddress (VOID)
        {return (m_dwOutIPaddress);}

   PATTRIBUTE GetUserName() const throw ()
   { return m_pUserName; }

   PIASATTRIBUTE GetUserPassword() const throw ()
   { return m_pPasswordAttrib; }

   HRESULT cryptBuffer(
               BOOL encrypt,
               BOOL salted,
               PBYTE buf,
               ULONG buflen
               ) const throw ();

	HRESULT GetClient (
            /*[out]*/   IIasClient **ppIIasClient
            );

   LPCWSTR GetClientName() const throw ()
   { return m_pIIasClient->GetClientNameW(); }

	HRESULT PrelimVerification (
                /*[in]*/    CDictionary *pDictionary,
			    /*[in]*/	DWORD       dwBufferSize
			    );
	HRESULT SetPassword (
			    /*[in]*/	PBYTE pPassword,
			    /*[in]*/	DWORD dwBufferSize
			    );
    BOOL GetUserName (
		    /*[out]*/       PBYTE   pbyUserName,
		    /*[in/out]*/    PDWORD  pdwBufferSize
		);
	BOOL IsProxyStatePresent (VOID);

	PACKETTYPE GetInCode (VOID);

	PACKETTYPE GetOutCode (VOID);

	WORD GetOutLength (VOID);

	WORD GetInLength (VOID) const
   { return m_dwInLength; }

	HRESULT GetInAuthenticator (
			/*[out]*/	    PBYTE   pAuthenticator,
            /*[in/out]*/    PDWORD  pdwBufSize
			);
	BOOL SetOutAuthenticator (
			/*[in]*/	PBYTE pAuthenticator
			);
	HRESULT SetOutSignature (
			    /*[in]*/	PBYTE pSignature
		    	);
	inline PBYTE GetInPacket (VOID) const
        {return (m_pInPacket);}

	inline PBYTE GetOutPacket (VOID)
        {return (m_pOutPacket);}

    BOOL SetProxyInfo (
            /*[in]*/    CProxyInfo  *pCProxyInfo
            );
    HRESULT BuildOutPacket (
                /*[in]*/    PACKETTYPE         ePacketType,
                /*[in]*/    PATTRIBUTEPOSITION pAttribPos,
                /*[in]*/    DWORD              dwAttribCount
                );

    VOID SetProxyState (VOID);

    BOOL GetInSignature (
                /*[out]*/    PBYTE   pSignatureValue
                );

    BOOL GenerateInAuthenticator (
                /*[in]*/    PBYTE    pInAuthenticator,
                /*[out]*/   PBYTE    pOutAuthenticator
                );
    BOOL    GenerateOutAuthenticator();

    BOOL    IsUserPasswordPresent (VOID)
            {return (NULL != m_pPasswordAttrib); }

    BOOL    IsOutSignaturePresent (VOID)
            {return (NULL != m_pOutSignature); }

    BOOL    ValidateSignature (VOID);

    HRESULT GenerateInSignature (
                /*[out]*/       PBYTE           pSignatureValue,
                /*[in/out]*/    PDWORD          pdwSigSize
                );

    HRESULT GenerateOutSignature (
                /*[out]*/       PBYTE           pSignatureValue,
                /*[in/out]*/    PDWORD          pdwSigSize
                );

    BOOL IsOutBoundAttribute (
                /*[in]*/    PACKETTYPE      ePacketType,
                /*[in]*/    PIASATTRIBUTE   pIasAttribute
                );

	CPacketRadius(
            /*[in]*/    CHashMD5         *pCHashMD5,
            /*[in]*/    CHashHmacMD5     *pCHashHmacMD5,
            /*[in]*/    IIasClient       *pIIasClient,
            /*[in]*/    CReportEvent     *pCReportEvent,
            /*[in]*/    PBYTE            pInBuffer,
            /*[in]*/    DWORD            dwInLength,
            /*[in]*/    DWORD            dwIPAddress,
            /*[in]*/    WORD             wInPort,
            /*[in]*/    SOCKET           sock,
            /*[in]*/    PORTTYPE         portType
            );

	virtual ~CPacketRadius();

   void reportMalformed() const throw ();

private:

    BOOL    XorBuffers (
                /*[in/out]*/    PBYTE pbData1,
                /*[in]*/        DWORD dwDataLength1,
                /*[in]*/        PBYTE pbData2,
                /*[in]*/        DWORD dwDataLength2
                );

    HRESULT FillSharedSecretInfo (
                /*[in]*/    PIASATTRIBUTE   pIasAttrib
                );
    HRESULT FillClientIPInfo (
                /*[in]*/    PIASATTRIBUTE   pIasAttrib
                );
    HRESULT FillClientPortInfo (
                /*[in]*/    PIASATTRIBUTE   pIasAttrib
                );
    HRESULT FillPacketHeaderInfo (
                /*[in]*/    PIASATTRIBUTE   pIasAttrib
                );
    HRESULT FillClientVendorType (
                /*[in]*/    PIASATTRIBUTE   pIasAttrib
                );
    HRESULT FillClientName (
                /*[in]*/    PIASATTRIBUTE   pIasAttrib
                );
    HRESULT FillInAttributeInfo (
                /*[in]*/    CDictionary     *pCDictionary,
                /*[in]*/    PACKETTYPE      ePacketType,
                /*[in]*/    PIASATTRIBUTE   pIasAttrib,
                /*[in]*/    PATTRIBUTE      pRadiusAttrib
                );
    HRESULT FillOutAttributeInfo (
                /*[in]*/    PATTRIBUTE      pRadiusAttrib,
                /*[in]*/    PIASATTRIBUTE   pIasAttrib,
                /*[out]*/   PWORD           pwActualAttributeLength,
                /*[in]*/    DWORD           dwMaxPossibleAttribLength
                );
    BOOL    InternalGenerator (
                /*[in]*/    PBYTE           pInAuthenticator,
                /*[out]*/   PBYTE           pOutAuthenticator,
                /*[in]*/    PRADIUSPACKET   pPacket
                );
	HRESULT ValidatePacketFields (
			    /*[in]*/	DWORD dwBufferSize
			    );
	HRESULT CreateAttribCollection(
                /*[in]*/    CDictionary     *pCDictionary
                );

    HRESULT InternalSignatureGenerator (
                /*[in]*/    PBYTE           pSignatureValue,
                /*[in/out]*/PDWORD          pdwSigSize,
                /*[in]*/    PRADIUSPACKET   pPacket,
                /*[in]*/    PATTRIBUTE      pSignatureAttr
                );

    PORTTYPE GetPortType (){return (m_porttype);}

    PIASATTRIBUTE              m_pPasswordAttrib;

    PATTRIBUTEPOSITION         m_pIasAttribPos;

    enum
    {
        RADIUS_CREATOR_STATE = 1
    };

    PBYTE    m_pInPacket;
    DWORD    m_dwInLength;

    PBYTE    m_pOutPacket;

    PATTRIBUTE  m_pInSignature;

    PATTRIBUTE  m_pOutSignature;

    PATTRIBUTE  m_pUserName;

	WORD m_wInPort;

	WORD m_wOutPort;

    WORD m_wInPacketLength;

	DWORD m_dwInIPaddress;

	DWORD m_dwOutIPaddress;

    DWORD m_dwInAttributeCount;

    SOCKET m_socket;

    PORTTYPE m_porttype;

	HRESULT VerifyAttributes (
                /*[in]*/    CDictionary     *pCDictionary
                );

    CHashMD5        *m_pCHashMD5;

    CHashHmacMD5    *m_pCHashHmacMD5;

    IIasClient      *m_pIIasClient;

    CReportEvent    *m_pCReportEvent;

    //
    //  here is the private data for proxy
    //
	CProxyInfo   *m_pCProxyInfo;

    //
    //  here are the COM interfaces
    //
    IRequest        *m_pIRequest;

    IAttributesRaw  *m_pIAttributesRaw;

    //
    //  the memory pool for outbound UDP buffer
    //
    static memory_pool <MAX_PACKET_SIZE, task_allocator> m_OutBufferPool;
};

#endif // !defined(PACKET_RADIUS_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\packetradius.cpp ===
//#--------------------------------------------------------------
//
//  File:       packetradius.cpp
//
//  Synopsis:   Implementation of CPacketRadius class methods
//
//    Copyright (C)  Microsoft Corporation All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "iasutil.h"
#include "packetradius.h"

const CHAR      NUL =  '\0';
const DWORD     DEFAULT_ATTRIB_ARRAY_SIZE = 64;

memory_pool<MAX_PACKET_SIZE, task_allocator> CPacketRadius::m_OutBufferPool;

namespace
{
   const DWORDLONG UNIX_EPOCH = 116444736000000000ui64;
}

void CPacketRadius::reportMalformed() const throw ()
{
   PCWSTR strings[] = { GetClientName() };
   IASReportEvent(
       RADIUS_E_MALFORMED_PACKET,
       1,
       GetInLength(),
       strings,
       GetInPacket()
       );
}

//++--------------------------------------------------------------
//
//  Function:   CPacketRadius
//
//  Synopsis:   This is the constructor of the CPacketRadius class
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     9/23/97
//
//----------------------------------------------------------------
CPacketRadius::CPacketRadius(
         CHashMD5       *pCHashMD5,
         CHashHmacMD5   *pCHashHmacMD5,
         IIasClient     *pIIasClient,
         CReportEvent   *pCReportEvent,
         PBYTE          pInBuffer,
         DWORD          dwInLength,
         DWORD          dwIPAddress,
         WORD           wInPort,
         SOCKET         sock,
         PORTTYPE       portType
         )
              : m_wInPort (wInPort),
                m_dwInIPaddress (dwIPAddress),
                m_socket (sock),
                m_porttype (portType),
                m_pCProxyInfo (NULL),
                m_pCHashMD5 (pCHashMD5),
                m_pCHashHmacMD5 (pCHashHmacMD5),
                m_pIIasClient (pIIasClient),
                m_pCReportEvent (pCReportEvent),
                m_pIasAttribPos (NULL),
                m_pInPacket (pInBuffer),
                m_dwInLength(dwInLength),
                m_pOutPacket (NULL),
                m_pInSignature (NULL),
                m_pOutSignature(NULL),
                m_pUserName (NULL),
                m_pPasswordAttrib (NULL)
{
    _ASSERT (
            (NULL != pInBuffer) &&
            (NULL != pCHashMD5) &&
            (NULL != pCHashHmacMD5) &&
            (NULL != pIIasClient)
            );
    m_pIIasClient->AddRef ();

}   //  end of CPacketRadius constructor

//++--------------------------------------------------------------
//
//  Function:   ~CPacketRadius
//
//  Synopsis:   This is the destructor of the CPacketRadius class
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//  History:    MKarki      Created     9/23/97
//
//----------------------------------------------------------------
CPacketRadius::~CPacketRadius()
{
    if (NULL != m_pIasAttribPos)
    {
        //
        //  release the attribute
        //
        for (
          DWORD dwCount = 0;
          dwCount < (m_dwInAttributeCount + COMPONENT_SPECIFIC_ATTRIBUTE_COUNT);
          dwCount++
         )
        {
            ::IASAttributeRelease (m_pIasAttribPos[dwCount].pAttribute);
        }

        //
        //  delete the attribute position array now
        //
        CoTaskMemFree (m_pIasAttribPos);
    }

    //
    //  release the reference to Client object
    //
    if (m_pIIasClient) { m_pIIasClient->Release ();}

    //
    //  delete the out-packet buffer
    //
    if (m_pOutPacket) { m_OutBufferPool.deallocate (m_pOutPacket); }

    //
    //  delete the in packet buffer
    //
    if (m_pInPacket) { CoTaskMemFree (m_pInPacket); }

}   //  end of CPacketRadius destructor

//+++-------------------------------------------------------------
//
//  Function:   PrelimVerification
//
//  Synopsis:   The method  starts the verification of the
//              buffer passed in this is done only when
//              the class objec is created for an inbound
//              packet
//
//  Arguments:
//              [in] CDictionary*
//          [in] DWORD  - size of the buffer provided
//
//  Returns:    HRESULT - status
//
// Called By:  CPacketReceiver::ReceivePacket class method
//
//  History:    MKarki      Created     9/23/97
//
//----------------------------------------------------------------
HRESULT
CPacketRadius::PrelimVerification (
                CDictionary *pCDictionary,
            DWORD     dwBufferSize
            )
{
    PRADIUSPACKET       pPacket = NULL;
    DWORD               dwAttribCount = 0;
    TCHAR               szErrorString [IAS_ERROR_STRING_LENGTH];
    HRESULT             hr = S_OK;

   __try
   {
      //
      // check that the buffer received is atleast big enough to
      // accomdate out RADIUSPACKET struct
      //
      if (dwBufferSize < MIN_PACKET_SIZE)
      {

            IASTracePrintf (
                "Packet received is smaller than minimum Radius packet"
                );

            reportMalformed();

            m_pCReportEvent->Process (
                RADIUS_MALFORMED_PACKET,
                (AUTH_PORTTYPE == GetPortType ())?
                ACCESS_REQUEST:ACCOUNTING_REQUEST,
                dwBufferSize,
                m_dwInIPaddress,
                NULL,
                static_cast <LPVOID> (m_pInPacket)
                );
            hr = RADIUS_E_ERRORS_OCCURRED;
            __leave;
        }

      pPacket = reinterpret_cast <PRADIUSPACKET> (m_pInPacket);

      //
      // now save values in host byte order
      //
        m_wInPacketLength  = ntohs (pPacket->wLength);

      //
      // validate the fields of the packet, except the attributes
      //
      hr = ValidatePacketFields (dwBufferSize);
      if (FAILED (hr)) { __leave; }

      //
      // verify that the attributes are completely formed
        //
      hr = VerifyAttributes (pCDictionary);
      if (FAILED (hr)) { __leave; }

      //
      // now we have to create the attributes collection
      //
      hr = CreateAttribCollection (pCDictionary);
      if (FAILED (hr)) { __leave; }

        //
        // success
        //
   }
   __finally
   {
   }

   return (hr);

}  // end of CPacketRadius::PrelimVerification method

//+++-------------------------------------------------------------
//
//  Function:   VerifyAttributes
//
//  Synopsis:   This is a CPacketRadius class private method used
//          verify that the attributes received are well formed
//
//  Arguments:  none
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     10/3/97
//
//  Called By:  CPacketRadius::PrelimVerification method
//
//----------------------------------------------------------------
HRESULT
CPacketRadius::VerifyAttributes (
               CDictionary *pCDictionary
               )
{  PRADIUSPACKET  pPacketEnd = NULL;
    PRADIUSPACKET   pPacketStart = NULL;
   PATTRIBUTE     pAttrib = NULL;
    DWORD           dwAttribCount = 0;
    TCHAR           szErrorString [IAS_ERROR_STRING_LENGTH];
    HRESULT         hr = S_OK;
    BOOL            bStatus = FALSE;


    _ASSERT (pCDictionary);

   __try
   {
      pPacketStart = reinterpret_cast <PRADIUSPACKET> (m_pInPacket);

      //
      // get a pointer to the packet end
      //
      pPacketEnd = reinterpret_cast <PRADIUSPACKET> (
                      reinterpret_cast <PBYTE>  (pPacketStart)
                            +  m_wInPacketLength
                            );
      //
      // go through the attributes once, to verify they are of correct
      // length
      //
      pAttrib = reinterpret_cast <PATTRIBUTE> (pPacketStart->AttributeStart);

        const DWORD dwMinAttribOffset = sizeof (ATTRIBUTE) - sizeof (BYTE);

      while (static_cast <PVOID> (
                  reinterpret_cast <PBYTE> (pAttrib) +
                  dwMinAttribOffset
                  ) <=
            static_cast <PVOID> (pPacketEnd)
            )
      {
            //
            //  verify that the attributes is of correct length
            //  and in any case not  of length 0
            //  MKarki Fix #147284
            //  Fix summary - forgot the "__leave"
            //
            if (pAttrib->byLength < ATTRIBUTE_HEADER_SIZE)

            {
               reportMalformed();

                m_pCReportEvent->Process (
                    RADIUS_MALFORMED_PACKET,
                    GetInCode (),
                    m_wInPacketLength,
                    m_dwInIPaddress,
                    NULL,
                    static_cast <LPVOID> (m_pInPacket)
                    );
                hr = RADIUS_E_ERRORS_OCCURRED;
                __leave;
            }

            //
            //  move to the next attribute
            //
         pAttrib = reinterpret_cast <PATTRIBUTE> (
                           reinterpret_cast <PBYTE> (pAttrib) +
                            pAttrib->byLength
                            );
            //
            //  count the attributes
            //
            dwAttribCount++;
      }

        //
        //  if the attributes don't addup to end of packet
        //
      if (static_cast <PVOID> (pAttrib) != static_cast <PVOID> (pPacketEnd))
      {

         IASTracePrintf (
               "Attributes do not add up to end of Radius packet"
               );

         reportMalformed();

             m_pCReportEvent->Process (
                RADIUS_MALFORMED_PACKET,
                GetInCode (),
                m_wInPacketLength,
                m_dwInIPaddress,
                NULL,
                static_cast <LPVOID> (m_pInPacket)
                );
            hr = RADIUS_E_ERRORS_OCCURRED;
         __leave;
      }

      //
      // verified
      //
        m_dwInAttributeCount = dwAttribCount;
   }
   __finally
   {
   }

   return (hr);

}  // end of CPacketRadius::VerifyAttributes method

//+++-------------------------------------------------------------
//
//  Function:   CreateAttribCollection
//
//  Synopsis:   This is a CPacketRadius class private method used
//          to put the RADIUS attributes into the CAttributes
//          collection
//
//  Arguments:  none
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     9/23/97
//
//  Called By:  CPacketRadius::Init method
//
//----------------------------------------------------------------
HRESULT
CPacketRadius::CreateAttribCollection(
                    CDictionary *pCDictionary
               )
{
    HRESULT         hr = S_OK;
    PATTRIBUTE      pAttrib = NULL;
    DWORD           dwAttribType  = 0;
    DWORD           dwCount = 0;
    DWORD           dwRetVal = ERROR_NOT_ENOUGH_MEMORY;
    PIASATTRIBUTE   AttributePtrArray[DEFAULT_ATTRIB_ARRAY_SIZE];
    PIASATTRIBUTE   *ppAttribArray = NULL;
    PRADIUSPACKET   pPacketStart = reinterpret_cast <PRADIUSPACKET>
                                                    (m_pInPacket);

    const DWORD     dwTotalAttribCount = m_dwInAttributeCount +
                                         COMPONENT_SPECIFIC_ATTRIBUTE_COUNT;


    _ASSERT (pCDictionary);

    //
    //  allocate an ATTRIBUTEPOSITION array to carry the attribute
    //  around
    //
    m_pIasAttribPos =  reinterpret_cast <PATTRIBUTEPOSITION> (
        CoTaskMemAlloc (
            sizeof (ATTRIBUTEPOSITION)*dwTotalAttribCount
            ));
    if (NULL == m_pIasAttribPos)
    {
        IASTracePrintf (
            "Unable to allocate memory for Attribute position array "
            "while creating attribute collection"
            );
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }


    if  (dwTotalAttribCount > DEFAULT_ATTRIB_ARRAY_SIZE)
    {
        //
        // allocate array to store the attributes in
        //
        ppAttribArray =  reinterpret_cast <PIASATTRIBUTE*> (
            CoTaskMemAlloc (
                sizeof (PIASATTRIBUTE)*dwTotalAttribCount
                ));
        if (NULL == ppAttribArray)
        {
            IASTracePrintf (
                "Unable to allocate memory for Attribute array "
                "while creating attribute collection"
                );
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    else
    {
        //
        //  the default array is big enough
        //
        ppAttribArray = AttributePtrArray;
    }

    //
    //  create a bunch of new blank attributes to fill up the positions
    //
    dwRetVal = ::IASAttributeAlloc (dwTotalAttribCount, ppAttribArray);
    if (0 != dwRetVal)
    {
        IASTracePrintf (
            "Unable to allocate IAS attribute while creating attribute "
            "collection"
            );
        hr = HRESULT_FROM_WIN32 (dwRetVal);
        goto Cleanup;
    }

   //
   // go through the attributes storing them in the collection
   //
   pAttrib = reinterpret_cast <PATTRIBUTE> (pPacketStart->AttributeStart);

    //
    // now initialize the IASATTRIBUTE value structs with the values
    // in the packet
    //
    for (dwCount = 0; dwCount < m_dwInAttributeCount; dwCount++)
   {
        hr = FillInAttributeInfo (
                    pCDictionary,
                    static_cast <PACKETTYPE> (pPacketStart->byCode),
                    ppAttribArray[dwCount],
                    pAttrib
                    );
        if (FAILED (hr)) { goto Cleanup; }

        //
        // now put this in the attribute position structure
        //
        m_pIasAttribPos[dwCount].pAttribute = ppAttribArray[dwCount];

        //
        //   now store a reference to the attribute here if its
        //   a User-Password attribute, because we know we will
        //   access it later and don't want to have to search for
        //   it
        //   TODO - do the same kind of stuff for ProxyState
        //   as we would need the proxystate too.
        //
        if (USER_PASSWORD_ATTRIB == pAttrib->byType)
        {
           m_pPasswordAttrib = ppAttribArray[dwCount];
        }
        else if (SIGNATURE_ATTRIB == pAttrib->byType)
        {
            //
            // for Signature we want its position in the
            // raw input buffer
            //
            m_pInSignature = pAttrib;
        }
        else if (USER_NAME_ATTRIB == pAttrib->byType)
        {
            //
            // for UserName we want its position in the
            // raw input buffer
            //
            m_pUserName = pAttrib;
        }

        //
        // move to the next attribute now
        //
      pAttrib = reinterpret_cast <PATTRIBUTE> (
                     reinterpret_cast <PBYTE> (pAttrib) +
                      pAttrib->byLength
                     );

   }  // end of for loop


    //
    //  put in Client IP address in an attribute
    //
    hr = FillClientIPInfo (ppAttribArray[m_dwInAttributeCount]);
    if (FAILED (hr)) { goto Cleanup; }

    m_pIasAttribPos[m_dwInAttributeCount].pAttribute =
                                    ppAttribArray[m_dwInAttributeCount];

    //
    //  put in Client Port number in the attribute
    //
    hr = FillClientPortInfo (ppAttribArray[m_dwInAttributeCount +1]);
    if (FAILED (hr)) { goto Cleanup; }

    m_pIasAttribPos[m_dwInAttributeCount +1].pAttribute =
                                    ppAttribArray[m_dwInAttributeCount +1];

    //
    //  put in the packet header information
    //
    hr = FillPacketHeaderInfo (ppAttribArray[m_dwInAttributeCount +2]);
    if (FAILED (hr)) { goto Cleanup; }

    m_pIasAttribPos[m_dwInAttributeCount +2].pAttribute =
                                    ppAttribArray[m_dwInAttributeCount +2];

    //
    //  put in the Shared Secret
    //
    hr = FillSharedSecretInfo (ppAttribArray[m_dwInAttributeCount +3]);
    if (FAILED (hr)) { goto Cleanup; }

    m_pIasAttribPos[m_dwInAttributeCount +3].pAttribute =
                                    ppAttribArray[m_dwInAttributeCount +3];
    //
    //  put in the Client Vendor Type
    //
    hr = FillClientVendorType (ppAttribArray[m_dwInAttributeCount +4]);
    if (FAILED (hr)) { goto Cleanup; }

    m_pIasAttribPos[m_dwInAttributeCount +4].pAttribute =
                                    ppAttribArray[m_dwInAttributeCount +4];

    //
    //  put in the Client Name
    //
    hr = FillClientName (ppAttribArray[m_dwInAttributeCount +5]);
    if (FAILED (hr)) { goto Cleanup; }

    m_pIasAttribPos[m_dwInAttributeCount +5].pAttribute =
                                    ppAttribArray[m_dwInAttributeCount +5];


   //
   // successfully collected attributes
   //

Cleanup:

    if  (FAILED (hr))
    {

        if (0 == dwRetVal)
        {
            //
            //  release the attribute
            //
            for (dwCount = 0; dwCount < dwTotalAttribCount ; dwCount++)
            {
                ::IASAttributeRelease (ppAttribArray[dwCount]);
            }
        }

        if (NULL != m_pIasAttribPos)
        {
            CoTaskMemFree (m_pIasAttribPos);
            m_pIasAttribPos = NULL;
        }
    }

    //
    // the attribute array is always freed
    //
    if (
        (NULL != ppAttribArray) &&
        (dwTotalAttribCount > DEFAULT_ATTRIB_ARRAY_SIZE)
       )
    {
        CoTaskMemFree (ppAttribArray);
    }

   return (hr);

}  // end of CPacketRadius::CreateAttribCollection method

//+++-------------------------------------------------------------
//
//  Function:   ValidatePacketFields
//
//  Synopsis:   This is a CPacketRadius class private method used
//          to validate the fields of the RADIUS packet, execpt
//          the attributes
//
//  Arguments:  [in] DWORD -  buffer size
//
//
//  Returns:    HRESULT - status
//
//
//  History:    MKarki      Created     9/23/97
//
//  Called By:  CPacketRadius::PrelimVerification method
//
//----------------------------------------------------------------
HRESULT
CPacketRadius::ValidatePacketFields(
      DWORD dwBufferSize
      )
{
   HRESULT         hr = S_OK;
    TCHAR           szErrorString [IAS_ERROR_STRING_LENGTH];
    PRADIUSPACKET   pPacket =
                    reinterpret_cast <PRADIUSPACKET> (m_pInPacket);

   __try
   {
      //
      // check that we have received the complete packet
      //
      if (m_wInPacketLength > dwBufferSize)
      {
            //
            //  log error and generate audit event
            //
         IASTracePrintf (
            "Packet length:%d is greater than received buffer:%d",
                m_wInPacketLength,
                dwBufferSize
            );

         reportMalformed();

            m_pCReportEvent->Process (
                RADIUS_MALFORMED_PACKET,
                (AUTH_PORTTYPE== GetPortType ())?
                ACCESS_REQUEST:ACCOUNTING_REQUEST,
                dwBufferSize,
                m_dwInIPaddress,
                NULL,
                static_cast <LPVOID> (m_pInPacket)
                );
            hr = RADIUS_E_ERRORS_OCCURRED;
         __leave;
      }

      //
      //  verify that the packet is of correct lenth;
        //  i.e between 20 to 4096 octets
      //
      if (
            (m_wInPacketLength < MIN_PACKET_SIZE) ||
         (m_wInPacketLength > MAX_PACKET_SIZE)
            )
      {
         //
            // Log Error and Audit Event
            //
          IASTracePrintf (
                "Incorrect received packet size:%d",
             m_wInPacketLength
             );

          reportMalformed();

            m_pCReportEvent->Process (
                RADIUS_MALFORMED_PACKET,
                (AUTH_PORTTYPE == GetPortType ())?
                ACCESS_REQUEST:ACCOUNTING_REQUEST,
                dwBufferSize,
                m_dwInIPaddress,
                NULL,
                static_cast <LPVOID> (m_pInPacket)
                );
            hr = RADIUS_E_ERRORS_OCCURRED;
         __leave;
      }

        //
        //  verify that the PACKET code is correct
        //
        if  (
            ((ACCESS_REQUEST == static_cast <PACKETTYPE> (pPacket->byCode)) &&
            (AUTH_PORTTYPE != GetPortType ()))
            ||
            ((ACCOUNTING_REQUEST == static_cast<PACKETTYPE>(pPacket->byCode)) &&
            (ACCT_PORTTYPE != GetPortType ()))
            ||
            (((ACCESS_REQUEST != static_cast<PACKETTYPE>(pPacket->byCode))) &&
            ((ACCOUNTING_REQUEST != static_cast<PACKETTYPE>(pPacket->byCode))))
            )
        {

            //
            //  log error and generate audit event
            //
         IASTracePrintf (
             "UnSupported Packet type:%d on this port",
             static_cast <INT> (pPacket->byCode)
             );

         WCHAR packetCode[11];
         _ultow(pPacket->byCode, packetCode, 10);

         sockaddr_in sin;
         int namelen = sizeof(sin);
         getsockname(GetSocket(), (sockaddr*)&sin, &namelen);
         WCHAR dstPort[11];
         _ultow(ntohs(sin.sin_port), dstPort, 10);

         PCWSTR strings[] = { packetCode, dstPort, GetClientName() };

         IASReportEvent(
             RADIUS_E_INVALID_PACKET_TYPE,
             3,
             0,
             strings,
             NULL
             );

            m_pCReportEvent->Process (
                RADIUS_UNKNOWN_TYPE,
                (AUTH_PORTTYPE == GetPortType ())?
                ACCESS_REQUEST:ACCOUNTING_REQUEST,
                dwBufferSize,
                m_dwInIPaddress,
                NULL,
                static_cast <LPVOID> (m_pInPacket)
                );
            hr = RADIUS_E_ERRORS_OCCURRED;
         __leave;
      }

   }
   __finally
   {
   }

   return (hr);

}  // end of CPacketRadius::ValidatePacketFields method

//+++-------------------------------------------------------------
//
//  Function:   SetPassword
//
//  Synopsis:   Thie is a CPacketRadius class public method used to
//          store the user password.
//
//  Arguments:  [in] PBYTE  -  buffer to return password
//          [in]  PDWORD -  holds the buffer size
//
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     9/23/97
//
//----------------------------------------------------------------
HRESULT
CPacketRadius::SetPassword (
      PBYTE pPassword,
      DWORD dwSize
      )
{

   if (dwSize  > MAX_ATTRIBUTE_LENGTH)
    {
        IASTracePrintf (
                "Password length is greater than max attribute value size"
                );
        return (E_INVALIDARG);
    }

    //
    //  delete the dynamically allocated memory if its not big enough
    //
    if (dwSize >  m_pPasswordAttrib->Value.OctetString.dwLength)
    {
        if (NULL != m_pPasswordAttrib->Value.OctetString.lpValue)
        {
            CoTaskMemFree (m_pPasswordAttrib->Value.OctetString.lpValue);
        }

        //
        //  allocate memory for OctetString
        //
        m_pPasswordAttrib->Value.OctetString.lpValue =
            reinterpret_cast <PBYTE> (CoTaskMemAlloc (dwSize));
        if (NULL == m_pPasswordAttrib->Value.OctetString.lpValue)
        {
            IASTracePrintf (
                "Unable to allocate memory for password attribute "
                "during packet processing"
                );
            return (E_OUTOFMEMORY);
        }
    }

    //
    //  copy the value now
    //
    CopyMemory (
        m_pPasswordAttrib->Value.OctetString.lpValue,
        pPassword,
        dwSize
        );

    m_pPasswordAttrib->Value.OctetString.dwLength = dwSize;

   return (S_OK);

}  // end of CPacketRadius::SetPassword method


//++--------------------------------------------------------------
//
//  Function:   GetUserName
//
//  Synopsis:   Thie is a CPacketRadius class public method used to
//          return the RADIUS UserName
//
//  Arguments:  [in]  PBYTE  - buffer to return the password in
//          [in/out] PDWORD -  holds the buffer size
//
//  Returns:    BOOL    - status
//
//  History:    MKarki      Created     9/23/97
//
//----------------------------------------------------------------
BOOL
CPacketRadius :: GetUserName (
      PBYTE   pbyUserName,
      PDWORD  pdwBufferSize
      )
{
    _ASSERT ((pbyUserName) && (pdwBufferSize));

    if (NULL == m_pUserName)
    {
        IASTracePrintf (
            "No User-Name attribute found during packet processing"
            );
        return (FALSE);
    }

    DWORD dwNameLength = m_pUserName->byLength - ATTRIBUTE_HEADER_SIZE;
    if (*pdwBufferSize < dwNameLength)
    {
        IASTracePrintf (
            "User-Name Buffer Size is less than length of attribute value"
            );
        return (FALSE);
    }

   //
   // copy the password into the out buffer
   //
   CopyMemory (pbyUserName, m_pUserName->ValueStart, dwNameLength);
   *pdwBufferSize = dwNameLength;

   return (TRUE);

}  // end of CPacketRadius::GetPassword method


//++--------------------------------------------------------------
//
//  Function:   IsProxyStatePresent
//
//  Synopsis:   Thie is a CPacketRadius class public method used to
//          check if the RADIUS packet has a proxy state present.
//
//
//  Arguments:  none
//
//
//  Returns:    BOOL    - status
//
//
//  History:    MKarki      Created     9/23/97
//
//----------------------------------------------------------------
BOOL
CPacketRadius::IsProxyStatePresent (
      VOID
      )
{
   return (NULL != m_pCProxyInfo);

}  // end of CPacketRadius::IsProxyStatePresent method

//++--------------------------------------------------------------
//
//  Function:  GetInAuthenticator
//
//  Synopsis:   Thie is a CPacketRadius class public method used
//          to get the inbound RADIUS packet authenticator
//              field.
//
//
//  Arguments:  [out]    PBYTE   -  buffer to hold authenticator
//
//
//  Returns:    BOOL    - status
//
//  History:    MKarki      Created     9/23/97
//
//----------------------------------------------------------------
HRESULT
CPacketRadius::GetInAuthenticator (
      PBYTE    pbyAuthenticator,
        PDWORD   pdwBufSize
         )
{
    HRESULT hr = S_OK;
    PRADIUSPACKET  pPacket = reinterpret_cast <PRADIUSPACKET>(m_pInPacket);


    _ASSERT ((pbyAuthenticator) && (pdwBufSize) && (pPacket));

    if (*pdwBufSize < AUTHENTICATOR_SIZE)
    {
        hr = E_INVALIDARG;
    }
    else
    {
       CopyMemory (
          pbyAuthenticator,
          pPacket->Authenticator,
          AUTHENTICATOR_SIZE
         );
    }

    *pdwBufSize = AUTHENTICATOR_SIZE;
    return hr;
}  // end of CPacketRadius::GetInAuthenticator method

//++--------------------------------------------------------------
//
//  Function:  SetOutAuthenticator
//
//  Synopsis:   Thie is a CPacketRadius class public method used
//          to set the RADIUS authenticator field in the outbound
//              packet
//
//
//  Arguments:  [in]  PBYTE   -  buffer  hold authenticator
//
//
//  Returns:    BOOL    - status
//
//
//  History:    MKarki      Created    11/11/97
//
//----------------------------------------------------------------
BOOL
CPacketRadius::SetOutAuthenticator (
      PBYTE pbyAuthenticator
        )
{
    PRADIUSPACKET pPacket = reinterpret_cast <PRADIUSPACKET> (m_pOutPacket);

    _ASSERT ((pbyAuthenticator) && (pPacket));

   CopyMemory (
      pPacket->Authenticator,
      pbyAuthenticator,
      AUTHENTICATOR_SIZE
      );

   return (TRUE);

}  // end of CPacketRadius::SetOutAuthenticator method

//++--------------------------------------------------------------
//
//  Function:  SetOutSignature
//
//  Synopsis:   Thie is a CPacketRadius class public method used
//          to set the RADIUS Signature attribute value in the
//              outbound packet
//
//
//  Arguments:  [in]  PBYTE   -  buffer  holds signature
//
//
//  Returns:    BOOL    - status
//
//
//  History:    MKarki      Created    11/18/98
//
//----------------------------------------------------------------
HRESULT
CPacketRadius::SetOutSignature (
      PBYTE pbySignature
        )
{
    _ASSERT (pbySignature && m_pOutPacket && m_pOutSignature);

   CopyMemory (
      m_pOutSignature->ValueStart,
      pbySignature,
      SIGNATURE_SIZE
        );

   return (S_OK);

}  // end of CPacketRadius::SetOutSignature method

//+++-------------------------------------------------------------
//
//  Function:  GetInCode
//
//  Synopsis:   Thie is a CPacketRadius class public method used
//          to get the inbound RADIUS packet code field.
//
//
//  Arguments:  none
//
//
//  Returns:    PACKETTYPE
//
//
//  History:    MKarki      Created     9/23/97
//
//----------------------------------------------------------------
PACKETTYPE
CPacketRadius::GetInCode (
                VOID
                )
{
    PRADIUSPACKET pPacket = reinterpret_cast <PRADIUSPACKET>
                                                (m_pInPacket);

   return (static_cast <PACKETTYPE> (pPacket->byCode));

}  // end of CPacketRadius::GetInCode method

//++--------------------------------------------------------------
//
//  Function:  GetOutCode
//
//  Synopsis:   Thie is a CPacketRadius class public method used
//          to get the outbound RADIUS packet code field.
//
//
//  Arguments:  NONE
//
//
//  Returns:    PACKETTYPE
//
//
//  History:    MKarki      Created     9/23/97
//
//----------------------------------------------------------------
PACKETTYPE
CPacketRadius::GetOutCode (
      VOID
      )
{
    PRADIUSPACKET pPacket = reinterpret_cast <PRADIUSPACKET> (m_pOutPacket);

   return (static_cast <PACKETTYPE> (pPacket->byCode));

}  // end of CPacketRadius::GetOutCode method

//++--------------------------------------------------------------
//
//  Function:  GetOutLength
//
//  Synopsis:   Thie is a CPacketRadius class public method used
//          to get the outbound RADIUS packet length.
//
//
//  Arguments:  none
//
//
//  Returns:    WORD    - RADIUS in packet length
//
//
//  History:    MKarki      Created     9/23/97
//
//----------------------------------------------------------------
WORD
CPacketRadius::GetOutLength (
               VOID
               )
{
    PRADIUSPACKET   pPacket = reinterpret_cast <PRADIUSPACKET>
                                                (m_pOutPacket);

   return (ntohs (pPacket->wLength));

}  // end of CPacketRadius::GetOutLength method


//++--------------------------------------------------------------
//
//  Function:   SetProxyState
//
//  Synopsis:   Thie is a CPacketRadius class public method used
//          to set the proxy state to TRUE
//
//  Arguments:  none
//
//  Returns:    BOOL -  status
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
VOID
CPacketRadius::SetProxyState (
                    VOID
                    )
{
    return;

}   //  end of CPacketRadius::SetProxyState method

//++--------------------------------------------------------------
//
//  Function:   SetProxyInfo
//
//  Synopsis:   Thie is a CPacketRadius class public method used
//          to set the proxy state information for the packet
//
//  Arguments:  [in]  CProxyInfo*
//
//  Returns:    BOOL -  status
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------
BOOL
CPacketRadius::SetProxyInfo (
                    CProxyInfo  *pCProxyInfo
                    )
{
    BOOL    bRetVal = FALSE;

    _ASSERT (pCProxyInfo);

    m_pCProxyInfo = pCProxyInfo;

    return (TRUE);

}   //  end of CPacketRadius::SetProxyInfo method

//++--------------------------------------------------------------
//
//  Function:   BuildOutPacket
//
//  Synopsis:   This is a CPacketRadius class public method used
//          to build the outbound packet
//
//  Arguments:
//              [in]    PACKETTYPE        -  out packet type
//              [in]    PATTRIBUTEPOSITION - out attributes array
//              [in]    DWORD   -            Attributes Count
//
//  Returns:    HRESULT -  status
//
//  History:    MKarki      Created     10/22/97
//
//----------------------------------------------------------------
HRESULT
CPacketRadius::BuildOutPacket (
                    PACKETTYPE         ePacketType,
                    PATTRIBUTEPOSITION pAttribPos,
                    DWORD              dwTotalAttributes
                    )
{
    BOOL            bRetVal = FALSE;
    PRADIUSPACKET   pOutPacket = NULL;
    PRADIUSPACKET   pInPacket = reinterpret_cast <PRADIUSPACKET> (m_pInPacket);
    PATTRIBUTE      pCurrent = NULL;
    PATTRIBUTE      pAttribStart = NULL;
    PBYTE           pPacketEnd = NULL;
    WORD            wAttributeLength = 0;
    DWORD           dwPacketLength = 0;
    DWORD           dwMaxPossibleAttribLength = 0;
    HRESULT         hr = S_OK;

    __try
    {
        dwPacketLength =
            PACKET_HEADER_SIZE +
            dwTotalAttributes*(MAX_ATTRIBUTE_LENGTH + ATTRIBUTE_HEADER_SIZE);

        //
        //  limit the packet size to max UDP  packet size
        //
        dwPacketLength =  (dwPacketLength > MAX_PACKET_SIZE)
                           ? MAX_PACKET_SIZE
                           : dwPacketLength;

        m_pOutPacket = reinterpret_cast <PBYTE> (m_OutBufferPool.allocate ());
        if (NULL == m_pOutPacket)
        {
            IASTracePrintf (
                "Unable to allocate memory for pool for out-bound packet"
                );
            hr = E_OUTOFMEMORY;
            __leave;
        }

        pOutPacket = reinterpret_cast <PRADIUSPACKET> (m_pOutPacket);

        //
        //  put the packet type
        //
        pOutPacket->byCode = ePacketType;

        //
        //  put the packet ID
        //
        pOutPacket->byIdentifier = pInPacket->byIdentifier;

        //
        //  now fill in the current packet length
        //
        pOutPacket->wLength = htons (PACKET_HEADER_SIZE);

        //
        //  get the end of buffer
        //
        pPacketEnd = (reinterpret_cast <PBYTE> (pOutPacket)) + dwPacketLength;

        //
        // goto start of attributes
        //
        pAttribStart = reinterpret_cast <PATTRIBUTE>
                                (pOutPacket->AttributeStart);

        //
        //  Fix for Bug #190523 - 06/26/98 - MKarki
        //  we shouldn't be taking diff of PUNINTs
        //
        dwMaxPossibleAttribLength = static_cast <DWORD> (
                                    reinterpret_cast<PBYTE> (pPacketEnd) -
                                    reinterpret_cast<PBYTE> (pAttribStart)
                                   );

        //
        //  filled the attributes now
        //
        for (
            DWORD dwAttribCount = 0;
            dwAttribCount < dwTotalAttributes;
            dwAttribCount++
            )
        {
            if (IsOutBoundAttribute (
                            ePacketType,
                            pAttribPos[dwAttribCount].pAttribute
                            ))
            {
                //
                //  fill the attribute in the  packet buffer
                //
                hr = FillOutAttributeInfo (
                                    pAttribStart,
                                    pAttribPos[dwAttribCount].pAttribute,
                                    &wAttributeLength,
                                    dwMaxPossibleAttribLength
                                    );
                if (FAILED (hr)) { __leave; }

                dwMaxPossibleAttribLength -= wAttributeLength;

                //
                //  go to the next attribute start
                //
                PBYTE pTemp = reinterpret_cast <PBYTE> (pAttribStart) +
                               wAttributeLength;
                pAttribStart = reinterpret_cast <PATTRIBUTE> (pTemp);

                if ((reinterpret_cast <PBYTE> (pAttribStart)) >  pPacketEnd)
                {
                    //
                    //  log error
                    //
                    IASTracePrintf (
                        "Attributes can not fit in out-bound packet"
                        );
                    hr = RADIUS_E_PACKET_OVERFLOW;
                     __leave;
                }
            }   //  end of if

        }   //  end of for loop

        m_wOutPort = m_wInPort;
        m_dwOutIPaddress = m_dwInIPaddress;

        //
        //  now update the length of the packet
        //
        pOutPacket->wLength = htons (
                              (reinterpret_cast <PBYTE> (pAttribStart)) -
                              (reinterpret_cast <PBYTE>  (pOutPacket))
                              );
        //
        //  success
        //
    }
    __finally
    {
    }

    if (hr == RADIUS_E_PACKET_OVERFLOW)
    {
       PCWSTR strings[] = { GetClientName() };
       IASReportEvent(
           RADIUS_E_PACKET_OVERFLOW,
           1,
           0,
           strings,
           0
           );
       hr = RADIUS_E_ERRORS_OCCURRED;
    }

    return (hr);

}   //  end of CPacketRadius::BuildOutPacket method

//++--------------------------------------------------------------
//
//  Function:   GetInSignature
//
//  Synopsis:   This is CPacketARadius class public method
//          that returns the Signature attribute present
//              in the in bound request
//
//  Arguments:
//              [out]    PBYTE - signature
//
//  Returns:    BOOL -  status
//
//  History:    MKarki      Created     1/6/98
//
//----------------------------------------------------------------
BOOL
CPacketRadius::GetInSignature (
                PBYTE   pSignatureValue
                )
{
    BOOL        bRetVal = TRUE;

    _ASSERT (pSignatureValue);

    //
    //  assuming that the caller provides a buffer of 16 bytes
    //  as this the signature size ALWAYS
    //
    if (NULL == m_pInSignature)
    {
        //
        //  no signature attribute received
        //
        bRetVal = FALSE;
    }
    else
    {
        CopyMemory (
                pSignatureValue,
                m_pInSignature->ValueStart,
                SIGNATURE_SIZE
                );
    }

    return (bRetVal);

}   //  end of CPacketRadius::GetInSignature method

//++--------------------------------------------------------------
//
//  Function:   GenerateInAuthenticator
//
//  Synopsis:   This is CPacketARadius class public method
//          that generates the authenticator from the
//              input packet
//
//  Arguments:
//              [in]    PBYTE   -  Inbound Authenticator
//              [out]   PBYTE   -  Outbound Authenticator
//
//  Returns:    BOOL -  status
//
//  History:    MKarki      Created     12/8/97
//
//
//----------------------------------------------------------------
BOOL
CPacketRadius::GenerateInAuthenticator (
                       PBYTE    pInAuthenticator,
                       PBYTE    pOutAuthenticator
                        )
{

    PRADIUSPACKET pPacket = reinterpret_cast <PRADIUSPACKET> (m_pInPacket);

    _ASSERT ((pOutAuthenticator) && (pInAuthenticator)  && (pPacket));

    return (InternalGenerator (
                        pInAuthenticator,
                        pOutAuthenticator,
                        pPacket
                        ));

}   //  end of CPacketRadius::GenerateInAuthenticator

//++--------------------------------------------------------------
//
//  Function:   GenerateOutAuthenticator
//
//  Synopsis:   This is CPacketARadius class public method
//          that generates the authenticator from the
//              outbound packet
//
//  Arguments:
//              [in]    PBYTE   -  Inbound authenticator
//              [out]   PBYTE   -  Outbound authenticator
//
//  Returns:    BOOL -  status
//
//  History:    MKarki      Created     12/8/97
//
//
//----------------------------------------------------------------
BOOL
CPacketRadius::GenerateOutAuthenticator()
{
    PRADIUSPACKET pPacket = reinterpret_cast <PRADIUSPACKET> (m_pOutPacket);

    _ASSERT ((pOutAuthenticator) && (pInAuthenticator) && (pPacket));

    return (InternalGenerator (
                        m_pInPacket + 4,
                        pPacket->Authenticator,
                        pPacket
                        ));

}   //  end of CPacketRadius::GenerateOutAuthenticator method

//++--------------------------------------------------------------
//
//  Function:   InternalGenerator
//
//  Synopsis:   This is CPacketARadius class private method
//          that generates the response authenticator for the
//              packet provided
//
//  Arguments:
//              [in]    PBYTE   -  InAuthenticator
//              [out]   PBYTE   -  OutAuthenticator
//              [in]    PPACKETRADIUS
//
//  Returns:    BOOL -  status
//
//  History:    MKarki      Created     12/8/97
//
//
//----------------------------------------------------------------
BOOL
CPacketRadius::InternalGenerator(
                       PBYTE            pInAuthenticator,
                       PBYTE            pOutAuthenticator,
                       PRADIUSPACKET    pPacket
                        )
{
    BOOL            bStatus = TRUE;
    DWORD           dwPacketHeaderSize = 0;
    DWORD           dwAttributesLength = 0;

    _ASSERT ((pInAuthenticator) && (pOutAuthenticator) && (pPacket));

    __try
    {

        //
        //  get the size of the packet without the attributes and
        //  request authenticator
        //
        dwPacketHeaderSize = sizeof (RADIUSPACKET)
                             - sizeof (BYTE)
                             - AUTHENTICATOR_SIZE;

        //
        //  get the total attributes length now
        //
        dwAttributesLength = ntohs (pPacket->wLength)
                             - (dwPacketHeaderSize +  AUTHENTICATOR_SIZE);


        //
        //  get the shared secret
        //
        DWORD dwSecretSize;
        const BYTE* bySecret = m_pIIasClient->GetSecret(&dwSecretSize);

        //
        // do the hashing here
        //
        m_pCHashMD5->HashIt (
                            pOutAuthenticator,
                            NULL,
                            0,
                            reinterpret_cast <PBYTE> (pPacket),
                            dwPacketHeaderSize,
                            pInAuthenticator,
                            AUTHENTICATOR_SIZE,
                            pPacket->AttributeStart,
                            dwAttributesLength,
                            const_cast<BYTE*>(bySecret),
                            dwSecretSize,
                            0,
                            0
                            );

        //
        //   we have successfully got the outbound authenticator
        //

    }
    __finally
    {
    }

    return (bStatus);

}   //  end of CPacketRadius::InternalGenerator method

//++--------------------------------------------------------------
//
//  Function:   FillInAttributeInfo
//
//  Synopsis:   This is CPacketARadius class private method
//          that fills up the attribute information into
//              the IASATTRIBUTE struct from the raw RADIUS
//              packet
//
//  Arguments:
//              [in]    PACKETTYPE
//              [in]    PIASATTRIBUTE
//              [in]    PATTRIBUTE
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     12/31/97
//
//---------------------------------------------------------------
HRESULT
CPacketRadius::FillInAttributeInfo (
        CDictionary     *pCDictionary,
        PACKETTYPE      ePacketType,
        PIASATTRIBUTE   pIasAttrib,
        PATTRIBUTE      pRadiusAttrib
        )
{
    HRESULT hr = S_OK;

    _ASSERT ((pCDictionary) && (pIasAttrib) && (pRadiusAttrib));

    __try
    {
       // IAS IDs always match the RADIUS ID.
       pIasAttrib->dwId = pRadiusAttrib->byType;

       // Get the IAS syntax from the dictionary.
       pIasAttrib->Value.itType =
          pCDictionary->getAttributeType(pRadiusAttrib->byType);

        //
        //  get the length of the value
        //
        DWORD dwValueLength = static_cast <DWORD>
                (pRadiusAttrib->byLength - ATTRIBUTE_HEADER_SIZE);

        //
        // Set Value now
        //
        switch (pIasAttrib->Value.itType)
        {
        case IASTYPE_BOOLEAN:

            if (sizeof (DWORD) != dwValueLength)
            {
                hr = RADIUS_E_MALFORMED_PACKET;
                __leave;
            }
            pIasAttrib->Value.Boolean = IASExtractDWORD(
                                            pRadiusAttrib->ValueStart
                                            );

            break;

        case IASTYPE_INTEGER:
            if (sizeof (DWORD) != dwValueLength)
            {
                hr = RADIUS_E_MALFORMED_PACKET;
                __leave;
            }
            pIasAttrib->Value.Integer = IASExtractDWORD(
                                            pRadiusAttrib->ValueStart
                                            );
            break;

        case IASTYPE_ENUM:
            if (sizeof (DWORD) != dwValueLength)
            {
                hr = RADIUS_E_MALFORMED_PACKET;
                __leave;
            }
            pIasAttrib->Value.Enumerator = IASExtractDWORD(
                                               pRadiusAttrib->ValueStart
                                               );
            break;

        case IASTYPE_INET_ADDR:
            if (sizeof (DWORD) != dwValueLength)
            {
                hr = RADIUS_E_MALFORMED_PACKET;
                __leave;
            }
            pIasAttrib->Value.InetAddr = IASExtractDWORD(
                                             pRadiusAttrib->ValueStart
                                             );
            break;

        case IASTYPE_STRING:
            //
            //  allocate memory for string + ending NUL
            //
            if(0 == dwValueLength)
            {
                pIasAttrib->Value.String.pszAnsi = NULL;
            }
            else
            {
                pIasAttrib->Value.String.pszAnsi =
                                reinterpret_cast <PCHAR>
                                (CoTaskMemAlloc (dwValueLength + 1));
                if (NULL == pIasAttrib->Value.String.pszAnsi)
                {
                    hr = E_OUTOFMEMORY;
                    __leave;
                }
                CopyMemory (
                    pIasAttrib->Value.String.pszAnsi,
                    pRadiusAttrib->ValueStart,
                    dwValueLength
                    );
                pIasAttrib->Value.String.pszAnsi[dwValueLength] = NUL;
            }
            pIasAttrib->Value.String.pszWide = NUL;
            break;

        case IASTYPE_OCTET_STRING:

            pIasAttrib->Value.OctetString.dwLength = dwValueLength;
            //
            //  here dwValueLength == 0
            //
            if(0 == dwValueLength)
            {
                pIasAttrib->Value.OctetString.lpValue = NULL;
            }
            else
            {

                pIasAttrib->Value.OctetString.lpValue =
                    reinterpret_cast <PBYTE> (CoTaskMemAlloc (dwValueLength));
                if (NULL == pIasAttrib->Value.OctetString.lpValue)
                {
                    hr = E_OUTOFMEMORY;
                    __leave;
                }
                CopyMemory (
                    pIasAttrib->Value.OctetString.lpValue,
                    pRadiusAttrib->ValueStart,
                    dwValueLength
                    );
            }
            break;

        case IASTYPE_UTC_TIME:
            {
               if (dwValueLength != 4)
               {
                  hr = RADIUS_E_MALFORMED_PACKET;
                  __leave;
               }

               DWORDLONG val;

               // Extract the UNIX time.
               val = IASExtractDWORD(pRadiusAttrib->ValueStart);

               // Convert from seconds to 100 nsec intervals.
               val *= 10000000;

               // Shift to the NT epoch.
               val += UNIX_EPOCH;

               // Split into the high and low DWORDs.
               pIasAttrib->Value.UTCTime.dwLowDateTime = (DWORD)val;
               pIasAttrib->Value.UTCTime.dwHighDateTime = (DWORD)(val >> 32);
            }

            break;

        case IASTYPE_INVALID:
        case IASTYPE_PROV_SPECIFIC:
        default:
            hr = E_FAIL;
            __leave;
        }

        //
        // sign the attribute that the Protocol component created it
        //
        pIasAttrib->dwFlags |= (IAS_RECVD_FROM_CLIENT | IAS_RECVD_FROM_PROTOCOL);

        //
        //  also if this is a proxy state attribute also send
        //  it out on the wire
        //
        if (PROXY_STATE_ATTRIB == pIasAttrib->dwId)
        {
            pIasAttrib->dwFlags |= IAS_INCLUDE_IN_RESPONSE;
        }

        //
        //  success
        //
    }
    __finally
    {
        if (hr == RADIUS_E_MALFORMED_PACKET)
        {
            IASTracePrintf (
                   "Incorrect attribute:%d in packet",
                    static_cast <DWORD> (pRadiusAttrib->byType)
                    );

            reportMalformed();

            m_pCReportEvent->Process (
                    RADIUS_MALFORMED_PACKET,
                    GetInCode (),
                    m_wInPacketLength,
                    m_dwInIPaddress,
                    NULL,
                    static_cast <LPVOID> (m_pInPacket)
                    );

            hr = RADIUS_E_ERRORS_OCCURRED;
        }
    }

    return (hr);

}   //  end of CPacketRadius::FillInAttributeInfo method


//++--------------------------------------------------------------
//
//  Function:   FillOutAttributeInfo
//
//  Synopsis:   This is CPacketARadius class private method
//          that fills up the attribute information into
//              the outbound RADIUS packet from the IASATTRIBUTE
//              struct
//
//  Arguments:
//              [in]    PATTRIBUTE
//              [in]    PIASATTRIBUTE
//              [out]   PWORD   - return attribute length
//              [in]    DWORD   - Max possible attribute length
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     1/3/97
//
//----------------------------------------------------------------
HRESULT
CPacketRadius::FillOutAttributeInfo (
        PATTRIBUTE      pRadiusAttrib,
        PIASATTRIBUTE   pIasAttrib,
        PWORD           pwAttributeLength,
        DWORD           dwMaxPossibleAttribSize
        )
{
    DWORD           dwAttributeLength = 0;
    IAS_BOOLEAN     iasBoolean = 0;
    IAS_INTEGER     iasInteger = 0;
    IAS_ENUM        iasEnum = 0;
    IAS_INET_ADDR   iasAddr = 0;
    HRESULT         hr = S_OK;

    _ASSERT ((pRadiusAttrib) && (pIasAttrib) && (pwAttributeLength));

    __try
    {
        //
        //  now put the value into the buffer
        //
        switch (pIasAttrib->Value.itType)
        {
        case IASTYPE_BOOLEAN:

            iasBoolean = htonl (pIasAttrib->Value.Boolean);
            dwAttributeLength =
                    ATTRIBUTE_HEADER_SIZE + sizeof (IAS_BOOLEAN);

            if (dwMaxPossibleAttribSize >= dwAttributeLength)
            {
                CopyMemory (
                    pRadiusAttrib->ValueStart,
                    &iasBoolean,
                    sizeof (IAS_BOOLEAN)
                    );
            }
            else
            {
                hr = RADIUS_E_PACKET_OVERFLOW;
                __leave;
            }
            break;

        case IASTYPE_INTEGER:

            iasInteger = htonl (pIasAttrib->Value.Integer);
            dwAttributeLength =
                    ATTRIBUTE_HEADER_SIZE + sizeof (IAS_INTEGER);

            if (dwMaxPossibleAttribSize >= dwAttributeLength)
            {
                CopyMemory (
                    pRadiusAttrib->ValueStart,
                    &iasInteger,
                    sizeof (IAS_INTEGER)
                    );
            }
            else
            {
                hr = RADIUS_E_PACKET_OVERFLOW;
                __leave;
            }
            break;

        case IASTYPE_ENUM:

            iasEnum = htonl (pIasAttrib->Value.Enumerator);
            dwAttributeLength =
                    ATTRIBUTE_HEADER_SIZE + sizeof (IAS_ENUM);

            if (dwMaxPossibleAttribSize >= dwAttributeLength)
            {
                CopyMemory (
                    pRadiusAttrib->ValueStart,
                    &iasEnum,
                    sizeof (IAS_ENUM)
                    );
            }
            else
            {
                hr = RADIUS_E_PACKET_OVERFLOW;
                __leave;
            }
            break;

        case IASTYPE_INET_ADDR:

            iasAddr = htonl (pIasAttrib->Value.InetAddr);
            dwAttributeLength =  ATTRIBUTE_HEADER_SIZE +
                                 sizeof (IAS_INET_ADDR);

            if (dwMaxPossibleAttribSize >= dwAttributeLength)
            {
                CopyMemory (
                    pRadiusAttrib->ValueStart,
                    &iasAddr,
                    sizeof (IAS_INET_ADDR)
                    );
            }
            else
            {
                hr = RADIUS_E_PACKET_OVERFLOW;
                __leave;
            }
            break;

        case IASTYPE_STRING:
        {
            //
            //  for RADIUS protocol always ANSI
            //
            DWORD dwErr = IASAttributeAnsiAlloc (pIasAttrib);
            if (dwErr != NO_ERROR)
            {
               hr = HRESULT_FROM_WIN32(dwErr);
               __leave;
            }

            dwAttributeLength = ATTRIBUTE_HEADER_SIZE +
                                strlen (pIasAttrib->Value.String.pszAnsi);

            if (dwMaxPossibleAttribSize >= dwAttributeLength)
            {
                CopyMemory (
                    pRadiusAttrib->ValueStart,
                    reinterpret_cast <PBYTE>
                    (pIasAttrib->Value.String.pszAnsi),
                    strlen (pIasAttrib->Value.String.pszAnsi)
                    );
            }
            else
            {
                hr = RADIUS_E_PACKET_OVERFLOW;
                __leave;
            }
            break;
        }

        case IASTYPE_OCTET_STRING:

            dwAttributeLength =
                    ATTRIBUTE_HEADER_SIZE +
                    pIasAttrib->Value.OctetString.dwLength;

            if (dwMaxPossibleAttribSize >= dwAttributeLength)
            {
                CopyMemory (
                    pRadiusAttrib->ValueStart,
                    static_cast <PBYTE>
                    (pIasAttrib->Value.OctetString.lpValue),
                    pIasAttrib->Value.OctetString.dwLength
                    );
            }
            else
            {
                hr = RADIUS_E_PACKET_OVERFLOW;
                __leave;
            }
            break;

        case IASTYPE_UTC_TIME:
            {
               dwAttributeLength = ATTRIBUTE_HEADER_SIZE + 4;
               if (dwAttributeLength <= dwMaxPossibleAttribSize)
               {
                  DWORDLONG val;

                  // Move in the high DWORD.
                  val   = pIasAttrib->Value.UTCTime.dwHighDateTime;
                  val <<= 32;

                  // Move in the low DWORD.
                  val  |= pIasAttrib->Value.UTCTime.dwLowDateTime;

                  // Convert to the UNIX epoch.
                  val  -= UNIX_EPOCH;

                  // Convert to seconds.
                  val  /= 10000000;

                  IASInsertDWORD(pRadiusAttrib->ValueStart, (DWORD)val);
               }
               else
               {
                  hr = RADIUS_E_PACKET_OVERFLOW;
                  __leave;
               }
            }
            break;

        case IASTYPE_PROV_SPECIFIC:
        case IASTYPE_INVALID:
        default:
            _ASSERT (0);
            //
            //  should never reach here
            //
            IASTracePrintf (
                "Unknown IAS Value type :%d encountered "
                "while building out-bound packet",
                static_cast <DWORD> (pIasAttrib->Value.itType)
                );
            __leave;
            hr = E_FAIL;
            break;

        }   //  end of switch


        //
        //  check the size against spec
        //
        if (dwAttributeLength > (MAX_ATTRIBUTE_LENGTH + ATTRIBUTE_HEADER_SIZE))
        {
            PCWSTR strings[] = { GetClientName() };
            IASReportEvent(
                RADIUS_E_ATTRIBUTE_OVERFLOW,
                1,
                sizeof(pIasAttrib->dwId),
                strings,
                &(pIasAttrib->dwId)
                );

            hr = RADIUS_E_ERRORS_OCCURRED;
            __leave;
        }

        //
        //  IAS attribute type matches RADIUS attribute type
        //
        pRadiusAttrib->byType = static_cast <BYTE> (pIasAttrib->dwId);

        //
        // hold a reference to the signature attribute for future use
        //
        if (RADIUS_ATTRIBUTE_SIGNATURE == pIasAttrib->dwId)
        {
            m_pOutSignature = pRadiusAttrib;
        }

        //
        //  set the length in the packet
        //
        *pwAttributeLength = pRadiusAttrib->byLength =  dwAttributeLength;

        //
        //  success
        //
    }
    __finally
    {
    }

    return (hr);

}   //  end of CPacketRadius::FillOutAttributeInfo method

//++--------------------------------------------------------------
//
//  Function:   FillClientIPInfo
//
//  Synopsis:   This is CPacketARadius class private method
//          that fills the attribute information for Client
//              IP address
//
//  Arguments:
//              [in]    PIASATTRIBUTE
//
//  Returns:    HRESULT -  status
//
//  History:    MKarki      Created     1/6/98
//
//  Called By:  CPacketRadius::CreateAttribCollection private method
//
//----------------------------------------------------------------
HRESULT
CPacketRadius::FillClientIPInfo (
        PIASATTRIBUTE   pIasAttrib
        )
{
    _ASSERT (pIasAttrib);

    //
    //  put in the values now
    //
    pIasAttrib->dwId = IAS_ATTRIBUTE_CLIENT_IP_ADDRESS;
    pIasAttrib->Value.itType = IASTYPE_INET_ADDR;
    pIasAttrib->Value.InetAddr = m_dwInIPaddress;
    pIasAttrib->dwFlags = IAS_RECVD_FROM_PROTOCOL;

    return (S_OK);

}   //  end of CPacketRadius::FillClientIPInfo method

//++--------------------------------------------------------------
//
//  Function:   FillClientPortInfo
//
//  Synopsis:   This is CPacketARadius class private method
//          that fills the attribute information for Client
//              UDP port
//
//  Arguments:
//              [in]    PIASATTRIBUTE
//
//  Returns:    HRESULT -  status
//
//  History:    MKarki      Created     1/6/98
//
//  Called By:  CPacketRadius::CreateAttribCollection private method
//
//----------------------------------------------------------------
HRESULT
CPacketRadius::FillClientPortInfo (
        PIASATTRIBUTE   pIasAttrib
        )
{
    _ASSERT (pIasAttrib);

    //
    //  put in the values now
    //
    pIasAttrib->dwId = IAS_ATTRIBUTE_CLIENT_UDP_PORT;
    pIasAttrib->Value.itType = IASTYPE_INTEGER;
    pIasAttrib->Value.Integer = m_wInPort;
    pIasAttrib->dwFlags = IAS_RECVD_FROM_PROTOCOL;

    return (S_OK);

}   //  end of CPacketRadius::FillClientPortInfo method

//++--------------------------------------------------------------
//
//  Function:   FillPacketHeaderInfo
//
//  Synopsis:   This is CPacketARadius class private method
//          that fills the attribute information for
//              RADIUS packet header
//
//  Arguments:
//              [in]    PIASATTRIBUTE
//
//  Returns:    HRESULT -  status
//
//  History:    MKarki      Created     1/6/98
//
//  Called By:  CPacketRadius::CreateAttribCollection private method
//
//----------------------------------------------------------------
HRESULT
CPacketRadius::FillPacketHeaderInfo (
        PIASATTRIBUTE   pIasAttrib
        )
{
    HRESULT hr = S_OK;

    _ASSERT (pIasAttrib);

    //
    //  allocate dynamic memory for the packet header
    //
    pIasAttrib->Value.OctetString.lpValue =
         reinterpret_cast <PBYTE>  (CoTaskMemAlloc (PACKET_HEADER_SIZE));
    if (NULL == pIasAttrib->Value.OctetString.lpValue)
    {
        IASTracePrintf (
            "Unable to allocate dynamic memory for packet header info "
            "during in-packet processing"
            );
        hr = E_OUTOFMEMORY;
    }
    else
    {
        //
        //  put in the values now
        //
        pIasAttrib->dwId = IAS_ATTRIBUTE_CLIENT_PACKET_HEADER;
        pIasAttrib->Value.itType = IASTYPE_OCTET_STRING;

        CopyMemory (
            pIasAttrib->Value.OctetString.lpValue,
            m_pInPacket,
            PACKET_HEADER_SIZE
            );

        pIasAttrib->Value.OctetString.dwLength = PACKET_HEADER_SIZE;
        pIasAttrib->dwFlags = IAS_RECVD_FROM_PROTOCOL;
    }

    return (hr);

}   //  end of CPacketRadius::FillPacketHeaderInfo method

//++--------------------------------------------------------------
//
//  Function:   FillSharedSecretInfo
//
//  Synopsis:   This is CPacketARadius class private method
//          that fills the shared secret that the server
//              shares with the client from which this request
//              has been received
//
//  Arguments:
//              [in]    PIASATTRIBUTE
//
//  Returns:    HRESULT -  status
//
//  History:    MKarki      Created     1/6/98
//
//  Called By:  CPacketRadius::CreateAttribCollection private method
//
//----------------------------------------------------------------
HRESULT
CPacketRadius::FillSharedSecretInfo (
        PIASATTRIBUTE   pIasAttrib
        )
{
    BOOL    bStatus = FALSE;
    HRESULT hr = S_OK;

    _ASSERT ((pIasAttrib) && (m_pIIasClient));

    __try
    {

        //
        //  get the client secret
        //
        DWORD dwSecretSize;
        const BYTE* SharedSecret = m_pIIasClient->GetSecret(&dwSecretSize);

        //
        //  allocate dynamic memory for the client secret
        //
        pIasAttrib->Value.OctetString.lpValue =
             reinterpret_cast <PBYTE>  (CoTaskMemAlloc (dwSecretSize));
        if (NULL == pIasAttrib->Value.OctetString.lpValue)
        {
            IASTracePrintf (
                "Unable to allocate memory for client secret "
                "during in-packet processing"
                );
            hr = E_OUTOFMEMORY;
            __leave;
        }

        //
        //  put in the values now
        //
        pIasAttrib->dwId = IAS_ATTRIBUTE_SHARED_SECRET;
        pIasAttrib->Value.itType = IASTYPE_OCTET_STRING;

        CopyMemory (
            pIasAttrib->Value.OctetString.lpValue,
            SharedSecret,
            dwSecretSize
            );

        pIasAttrib->Value.OctetString.dwLength = dwSecretSize;
        pIasAttrib->dwFlags = IAS_RECVD_FROM_PROTOCOL;

        //
        //  success
        //
    }
    __finally
    {
    }

    return (hr);

}   //  end of CPacketRadius::FillSharedSecretInfo method

//++--------------------------------------------------------------
//
//  Function:   FillClientVendorType
//
//  Synopsis:   This is CPacketARadius class private method
//          that fills the Client-Vendor-Type information
//
//  Arguments:
//              [in]    PIASATTRIBUTE
//
//  Returns:    HRESULT -  status
//
//  History:    MKarki      Created     3/16/98
//
//  Called By:  CPacketRadius::CreateAttribCollection private method
//
//----------------------------------------------------------------
HRESULT
CPacketRadius::FillClientVendorType (
        PIASATTRIBUTE   pIasAttrib
        )
{
    _ASSERT ((pIasAttrib) && (m_pIIasClient));

    //
    //  put in the values now
    //
    pIasAttrib->dwId = IAS_ATTRIBUTE_CLIENT_VENDOR_TYPE;

    pIasAttrib->Value.itType = IASTYPE_INTEGER;

    pIasAttrib->dwFlags = IAS_RECVD_FROM_PROTOCOL;
    //
    //  get the client vendor type
    //
    LONG lVendorType = m_pIIasClient->GetVendorType();

    _ASSERT (SUCCEEDED (hr));

    pIasAttrib->Value.Integer = static_cast <IAS_INTEGER> (lVendorType);

    return (S_OK);

}   //  end of CPacketRadius::ClientVendorType method

//++--------------------------------------------------------------
//
//  Function:   FillClientName
//
//  Synopsis:   This is CPacketARadius class private method
//          that fills the Client-Name information
//
//  Arguments:
//              [in]    PIASATTRIBUTE
//
//  Returns:    HRESULT -  status
//
//  History:    MKarki      Created     3/30/98
//
//  Called By:  CPacketRadius::CreateAttribCollection private method
//
//----------------------------------------------------------------
HRESULT
CPacketRadius::FillClientName (
        PIASATTRIBUTE   pIasAttrib
        )
{
    _ASSERT ((pIasAttrib) && (m_pIIasClient));

    // Fill in the attribute fields.
    pIasAttrib->dwId = IAS_ATTRIBUTE_CLIENT_NAME;
    pIasAttrib->Value.itType = IASTYPE_STRING;
    pIasAttrib->dwFlags = IAS_RECVD_FROM_PROTOCOL;
    pIasAttrib->Value.String.pszAnsi = NULL;

    // Get the client name and length.
    PCWSTR name = m_pIIasClient->GetClientNameW();
    SIZE_T nbyte = (wcslen(name) + 1) * sizeof(WCHAR);

    // Make a copy.
    pIasAttrib->Value.String.pszWide = (PWSTR)CoTaskMemAlloc(nbyte);
    if (!pIasAttrib->Value.String.pszWide) { return E_OUTOFMEMORY; }
    memcpy(pIasAttrib->Value.String.pszWide, name, nbyte);

    return S_OK;
}


//+++-------------------------------------------------------------
//
//  Function:   GenerateInSignature
//
//  Synopsis:   This is CPacketARadius class public method
//          that carries out generation of Signature
//              over the in-bound RADIUS packet
//
//  Arguments:
//              [out]    PBYTE  - signature
//              [in/out] PDWORD - signature size
//
//  Returns:    BOOL -  status
//
//  History:    MKarki      Created     1/6/98
//
//----------------------------------------------------------------
HRESULT
CPacketRadius::GenerateInSignature (
                PBYTE           pSignatureValue,
                PDWORD          pdwSigSize
                )
{
    HRESULT         hr = S_OK;
    PRADIUSPACKET   pPacket = reinterpret_cast <PRADIUSPACKET> (m_pInPacket);
    PATTRIBUTE      pSignature = m_pInSignature;

    _ASSERT (pSignatureValue && pdwSigSize && pSignature);

    if (*pdwSigSize >= SIGNATURE_SIZE)
    {
        //
        //  generate the signature now
        //
        hr = InternalSignatureGenerator (
                            pSignatureValue,
                            pdwSigSize,
                            pPacket,
                            pSignature
                            );
    }
    else
    {
        IASTracePrintf (
            "Buffer not large enough to hold generated Message Authenticator"
            );
        *pdwSigSize = SIGNATURE_SIZE;
        hr = E_INVALIDARG;
    }

    return (hr);

}   //  end of CPacketRadius::GenerateInSignature method

//+++-------------------------------------------------------------
//
//  Function:   GenerateOutSignature
//
//  Synopsis:   This is CPacketARadius class public method
//          that carries out generation of Signature
//              for the outbound RADIUS packet
//
//  Arguments:
//              [out]    PBYTE  - signature
//              [in/out] PDWORD - signature size
//
//  Returns:    BOOL -  status
//
//  History:    MKarki      Created     11/18/98
//
//----------------------------------------------------------------
HRESULT
CPacketRadius::GenerateOutSignature (
                PBYTE           pSignatureValue,
                PDWORD          pdwSigSize
                )
{
    HRESULT         hr = S_OK;
    PRADIUSPACKET   pPacket = reinterpret_cast <PRADIUSPACKET> (m_pOutPacket);
    PATTRIBUTE      pSignature = m_pOutSignature;

    _ASSERT (pSignatureValue && pdwSigSize && pSignature);

    if (*pdwSigSize >= SIGNATURE_SIZE)
    {
        //
        //  generate the signature now
        //
        hr = InternalSignatureGenerator (
                            pSignatureValue,
                            pdwSigSize,
                            pPacket,
                            pSignature
                            );
    }
    else
    {
        IASTracePrintf (
            "Buffer not large enough to hold generated Message Authenticator"
            );
        *pdwSigSize = SIGNATURE_SIZE;
        hr = E_INVALIDARG;
    }

    return (hr);

}   //  end of CPacketRadius::GenerateOutSignature method

//+++-------------------------------------------------------------
//
//  Function:   InternalSignatureGenerator
//
//  Synopsis:   This is CPacketARadius class public method
//          that carries out the HMAC-MD5 hash to give the
//              signature value
//
//  Arguments:
//              [out]    PBYTE  - signature
//              [in/out] PDWORD - signature size
//              [in]     PRADIUSPACKET
//
//  Returns:    BOOL -  status
//
//  History:    MKarki      Created     1/6/98
//
//----------------------------------------------------------------
HRESULT
CPacketRadius::InternalSignatureGenerator (
                PBYTE           pSignatureValue,
                PDWORD          pdwSigSize,
                PRADIUSPACKET   pPacket,
                PATTRIBUTE      pSignatureAttr
                )
{
    BYTE            byAuthenticator[AUTHENTICATOR_SIZE];
    DWORD           dwAuthenticatorSize = AUTHENTICATOR_SIZE;
    HRESULT         hr = S_OK;

    _ASSERT (
             (NULL != pSignatureValue)  &&
             (NULL != pdwSigSize)       &&
             (NULL != pPacket)          &&
             (NULL != pSignatureAttr)   &&
             (NULL != m_pIIasClient)
            );

    //
    //   get the In authenticator
    //
    hr = GetInAuthenticator (byAuthenticator, &dwAuthenticatorSize);
    if (FAILED (hr)) { return (hr); }


    //
    //  get the shared secret
    //
    DWORD dwSecretSize;
    const BYTE* bySecret = m_pIIasClient->GetSecret(&dwSecretSize);

    //
    //  we will have all zero's in packet for signature generation
    //
    ZeroMemory (pSignatureValue, SIGNATURE_SIZE);

    //
    // Fixing bug #181029 - MKarki
    //  Don't prepend secret in case of  HMAC-MD5 hash
    //

    //
    //  carry out the HmacMD5 hashing now
    //
    m_pCHashHmacMD5->HashIt (
        pSignatureValue,
        const_cast<BYTE*>(bySecret),
        dwSecretSize,
        reinterpret_cast <PBYTE> (pPacket),
        PACKET_HEADER_SIZE - AUTHENTICATOR_SIZE,
        byAuthenticator,
        AUTHENTICATOR_SIZE,
        reinterpret_cast <PBYTE> (pPacket) + PACKET_HEADER_SIZE,
        (reinterpret_cast <PBYTE> (pSignatureAttr) + ATTRIBUTE_HEADER_SIZE) -
        (reinterpret_cast <PBYTE> (pPacket) + PACKET_HEADER_SIZE),
        pSignatureValue,
        SIGNATURE_SIZE,
        reinterpret_cast <PBYTE> (pSignatureAttr) + pSignatureAttr->byLength,
        reinterpret_cast <PBYTE> (reinterpret_cast <PBYTE> (pPacket) +
        ntohs (pPacket->wLength)) -
        reinterpret_cast <PBYTE> (reinterpret_cast <PBYTE>(pSignatureAttr) +
        pSignatureAttr->byLength)
        );

    *pdwSigSize = SIGNATURE_SIZE;
    return (hr);

}   //  end of CPacketRadius::GenerateInSignature method

//++--------------------------------------------------------------
//
//  Function:   IsOutBoundAttribute
//
//  Synopsis:   This is CPacketARadius class private method
//          that checks if this attribute has to be put
//              in the outbound RADIUS packet
//
//  Arguments:
//              [in]    PACKETTYPE
//              [in]    PIASATTRIBUTE
//
//  Returns:    BOOL -  status
//
//  History:    MKarki      Created     1/6/98
//
//  Called By:  CPacketRadius::BuildOutPacket private method
//
//----------------------------------------------------------------
BOOL
CPacketRadius::IsOutBoundAttribute (
        PACKETTYPE      ePacketType,
        PIASATTRIBUTE   pIasAttribute
        )
{
    _ASSERT (pIasAttribute);

    //  Ensure this is a RADIUS attribute ...
    if (pIasAttribute->dwId < 1 || pIasAttribute->dwId > 255) { return FALSE; }

    // ... and it's flagged to be sent over the wire.
    switch (ePacketType)
    {
       case ACCESS_ACCEPT:
       case ACCOUNTING_RESPONSE:
          return pIasAttribute->dwFlags & IAS_INCLUDE_IN_ACCEPT;

       case ACCESS_REJECT:
          return pIasAttribute->dwFlags & IAS_INCLUDE_IN_REJECT;

       case ACCESS_CHALLENGE:
          return pIasAttribute->dwFlags & IAS_INCLUDE_IN_CHALLENGE;
    }

    // Always return the Proxy-State.
    return pIasAttribute->dwId == PROXY_STATE_ATTRIB;
}


HRESULT CPacketRadius::cryptBuffer(
                           BOOL encrypt,
                           BOOL salted,
                           PBYTE buf,
                           ULONG buflen
                           ) const throw ()
{
   // Get the shared secret.
   DWORD secretLen;
   const BYTE* secret = m_pIIasClient->GetSecret(&secretLen);

   // Crypt the buffer.
   IASRadiusCrypt(
       encrypt,
       salted,
       secret,
       secretLen,
       m_pInPacket + 4,
       buf,
       buflen
       );

   return S_OK;
}

//++--------------------------------------------------------------
//
//  Function:   GetClient
//
//  Synopsis:   This is CPacketARadius class public method
//          that returns the the Client object
//
//
//  Arguments:
//              [out]    IIASClient**
//
//  Returns:    HRESULT -  status
//
//  History:    MKarki      Created     3/30/98
//
//  Called By:
//
//----------------------------------------------------------------
HRESULT
CPacketRadius::GetClient (
            /*[out]*/   IIasClient **ppIasClient
            )
{
    _ASSERT (ppIasClient);

    m_pIIasClient->AddRef ();

    *ppIasClient = m_pIIasClient;

    return (S_OK);

}   //  end of CPacketRadius::GetClient method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\packetio.cpp ===
//#--------------------------------------------------------------
//        
//  File:		packetio.cpp
//        
//  Synopsis:   Implementation of CPacketIo class methods
//              
//
//  History:     9/23/97  MKarki Created
//               8/28/98  MKarki Update to use Perimeter class
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "packetio.h"


//++--------------------------------------------------------------
//
//  Function:   CPacketIo
//
//  Synopsis:   This is the constructor of the CPacketIo class
//
//  Arguments:  NONE
//
//  Returns:    NONE 
//
//
//  History:    MKarki      Created     11/25/97
//
//----------------------------------------------------------------
CPacketIo::CPacketIo(
		        VOID
			    )
{
}	//	end of CPacketIo constructor

//++--------------------------------------------------------------
//
//  Function:   ~CPacketIo
//
//  Synopsis:   This is the destructor of the CPacketIo class
//
//  Arguments:  NONE
//
//  Returns:    NONE 
//
//  History:    MKarki      Created     11/25/97
//
//----------------------------------------------------------------
CPacketIo::~CPacketIo(
		VOID
		)
{
}   //  end of CPacketIo destructor

//++--------------------------------------------------------------
//
//  Function:   StartProcessing
//
//  Synopsis:   This is the CPacketIo public method enables
//              sending packets out to the net
//
//  Arguments:  
//              [in]    DWORD   -   authentication handle
//              [in]    DWORD   -   accounting  handle
//              
//
//  Returns:    BOOL    -   bStatus
//
//  History:    MKarki      Created     11/25/97
//
//----------------------------------------------------------------
BOOL CPacketIo::StartProcessing ( )
{
    //
    // enable
    //
    EnableProcessing ();

    return (TRUE);

}	//	end of CPacketIo::StartProcessing method

//++--------------------------------------------------------------
//
//  Function:   StopProcessing
//
//  Synopsis:   This is the CPacketIo public method disables
//              sending packets out to the net
//
//  Arguments:  NONE
//
//  Returns:    BOOL    -   bStatus
//
//  History:    MKarki      Created     11/25/97
//
//----------------------------------------------------------------
BOOL
CPacketIo::StopProcessing (
                        VOID
						)
{
    //
    // disable
    //
    DisableProcessing ();

    return (TRUE);

}	//	end of CPacketIo::StopProcessing method 

//++--------------------------------------------------------------
//
//  Function:   EnableProcessing
//
//  Synopsis:   This is the CPacketIo class private method 
//              that enables the processing  flag
//
//  Arguments:  
//
//  Returns:    BOOL	-	status
//
//
//  History:    MKarki      Created     11/19/97
//
//----------------------------------------------------------------
BOOL 
CPacketIo::EnableProcessing (
                VOID
                )
{
    LockExclusive ();
    m_bProcessData = TRUE;
    Unlock ();

    return (TRUE);
}
        
//++--------------------------------------------------------------
//
//  Function:   DisableProcessing
//
//  Synopsis:   This is the CPacketIo class private method 
//              that disables the processing  flag
//
//  Arguments:  
//
//  Returns:    BOOL	-	status
//
//
//  History:    MKarki      Created     11/19/97
//
//----------------------------------------------------------------
BOOL 
CPacketIo::DisableProcessing (
                VOID
                )
{
    LockExclusive ();
    m_bProcessData = FALSE;
    Unlock ();

    return (TRUE);

}   //  end of CPacketIo::DisableProcessing method
        
//++--------------------------------------------------------------
//
//  Function:   IsProcessingEnabled
//
//  Synopsis:   This is the CPacketIo class private method 
//              that checks if the processing is enabled
//
//  Arguments:  
//
//  Returns:    BOOL	-	status
//
//
//  History:    MKarki      Created     11/19/97
//
//----------------------------------------------------------------
BOOL 
CPacketIo::IsProcessingEnabled(
                VOID
                )
{
    BOOL bRetVal = FALSE;

    Lock ();
    bRetVal = m_bProcessData;
    Unlock ();

    return (bRetVal);

}   //  end of CPacketIo::IsProcessingEnabled method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\logresult.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    logresult.cpp
//
// SYNOPSIS
//
//    Defines the function IASRadiusLogResult.
//
///////////////////////////////////////////////////////////////////////////////

#include <radcommon.h>
#include <iastlutl.h>
#include <iasutil.h>
#include <logresult.h>

// Dummy attribute ID for the stringized reason code.
const DWORD IAS_ATTRIBUTE_REASON_STRING = 0xBADF00D;

// An empty string.
WCHAR emptyString[1];

// Create a newly-allocated copy of a string.
PWSTR copyString(PCWSTR sz) throw ()
{
   if (sz)
   {
      // Calculate the number of bytes.
      size_t nbyte = (wcslen(sz) + 1) * sizeof(WCHAR);

      // Allocate the memory.
      PVOID p = LocalAlloc(LMEM_FIXED, nbyte);
      if (p)
      {
         // Copy the string and return.
         return (PWSTR)memcpy(p, sz, nbyte);
      }
   }

   // If anything went wrong, return an empty string.
   return emptyString;
}

// Frees a string returned by copyString.
void freeString(PWSTR sz) throw ()
{
   if (sz != emptyString) { LocalFree(sz); }
}

// Format an integer value.
PWSTR formatInteger(DWORD value) throw ()
{
   WCHAR buffer[11], *p = buffer + 10;
   *p = L'\0';
   do { *--p = L'0' + (WCHAR)(value % 10); } while (value /= 10);
   return copyString(p);
}

// Format a parameter value.
PWSTR formatParameter(DWORD value) throw ()
{
   WCHAR buffer[13], *p = buffer + 12;
   *p = L'\0';
   do { *--p = L'0' + (WCHAR)(value % 10); } while (value /= 10);
   *--p = L'%';
   *--p = L'%';
   return copyString(p);
}

// Format the IAS_ATTRIBUTE_PROVIDER_TYPE value.
PWSTR formatProviderType(DWORD type) throw ()
{
   switch (type)
   {
      case IAS_PROVIDER_WINDOWS:
         return formatParameter(IASP_PROVIDER_WINDOWS);
      case IAS_PROVIDER_RADIUS_PROXY:
         return formatParameter(IASP_PROVIDER_RADIUS_PROXY);
      case IAS_PROVIDER_EXTERNAL_AUTH:
         return formatParameter(IASP_PROVIDER_EXTERNAL_AUTH);
      default:
         return formatParameter(IASP_NONE);
   }
}

// Format the IAS_ATTRIBUTE_AUTHENTICATION_TYPE value.
PWSTR formatAuthType(DWORD type) throw ()
{
   switch (type)
   {
      case IAS_AUTH_PAP:
         return copyString(L"PAP");
      case IAS_AUTH_MD5CHAP:
         return copyString(L"MD5-CHAP");
      case IAS_AUTH_MSCHAP:
         return copyString(L"MS-CHAPv1");
      case IAS_AUTH_MSCHAP2:
         return copyString(L"MS-CHAPv2");
      case IAS_AUTH_EAP:
         return copyString(L"EAP");
      case IAS_AUTH_ARAP:
         return copyString(L"ARAP");
      case IAS_AUTH_NONE:
         return copyString(L"Unauthenticated");
      case IAS_AUTH_CUSTOM:
         return copyString(L"Extension");
      case IAS_AUTH_MSCHAP_CPW:
         return copyString(L"MS-CHAPv1 CPW");
      case IAS_AUTH_MSCHAP2_CPW:
         return copyString(L"MS-CHAPv2 CPW");
      case IAS_AUTH_PEAP:
         return copyString(L"PEAP");
      default:
         return formatInteger(type);
   }
}

// Format the NAS-Port-Type value.
PWSTR formatPortType(DWORD type) throw ()
{
   switch (type)
   {
      case 0:
         return copyString(L"Async");
      case 1:
         return copyString(L"Sync");
      case 2:
         return copyString(L"ISDN Sync");
      case 3:
         return copyString(L"ISDN Async V.120");
      case 4:
         return copyString(L"ISDN Async V.110");
      case 5:
        return copyString(L"Virtual");
      case 6:
        return copyString(L"PIAFS");
      case 7:
        return copyString(L"HDLC Clear Channel");
      case 8:
        return copyString(L"X.25");
      case 9:
        return copyString(L"X.75");
      case 10:
        return copyString(L"G.3 Fax");
      case 11:
        return copyString(L"SDSL");
      case 12:
        return copyString(L"ADSL-CAP");
      case 13:
        return copyString(L"ADSL-DMT");
      case 14:
        return copyString(L"IDSL");
      case 15:
        return copyString(L"Ethernet");
      case 16:
        return copyString(L"xDSL");
      case 17:
        return copyString(L"Cable");
      case 18:
        return copyString(L"Wireless - Other");
      case 19:
        return copyString(L"Wireless - IEEE 802.11");
      default:
        return formatInteger(type);
   }
}

PWSTR formatAttribute(
          IRequest* request,
          IAttributesRaw* raw,
          DWORD dwId,
          DWORD defaultValue
          ) throw ()
{
   // Is this one of the 'special' attributes ?
   switch (dwId)
   {
      case IAS_ATTRIBUTE_REASON_CODE:
      {
         LONG reason = 0;
         request->get_Reason(&reason);
         if (reason >= IAS_MAX_REASON_CODE)
         {
            reason = IAS_INTERNAL_ERROR;
         }
         return formatInteger(reason);
      }

      case IAS_ATTRIBUTE_REASON_STRING:
      {
         LONG reason;
         request->get_Reason(&reason);
         if (reason >= IAS_MAX_REASON_CODE)
         {
            reason = IAS_INTERNAL_ERROR;
         }
         return formatParameter(reason + 0x1000);
      }
   }

   // Get a single attribute with the give ID.
   DWORD posCount = 1;
   ATTRIBUTEPOSITION pos;
   raw->GetAttributes(&posCount, &pos, 1, &dwId);

   // If it's not present, use the defaultValue parameter.
   if (!posCount) { return formatParameter(defaultValue); }

   // Otherwise, save and release.
   const IASVALUE& val = pos.pAttribute->Value;
   IASAttributeRelease(pos.pAttribute);

   // Format the value.
   switch (val.itType)
   {
      case IASTYPE_ENUM:
      case IASTYPE_INTEGER:
      {
         switch (dwId)
         {
            case RADIUS_ATTRIBUTE_NAS_PORT_TYPE:
               return formatPortType(val.Enumerator);

            case IAS_ATTRIBUTE_PROVIDER_TYPE:
               return formatProviderType(val.Enumerator);

            case IAS_ATTRIBUTE_AUTHENTICATION_TYPE:
               return formatAuthType(val.Enumerator);

            // Fall through.
         }

         return formatInteger(val.Integer);
      }

      case IASTYPE_INET_ADDR:
      {
         WCHAR buffer[16];
         return copyString(ias_inet_htow(val.InetAddr, buffer));
      }

      case IASTYPE_STRING:
      {
         if (val.String.pszWide)
         {
            return copyString(val.String.pszWide);
         }
         else
         {
            USES_CONVERSION;
            return copyString(A2W(val.String.pszAnsi));
         }
      }

      case IASTYPE_OCTET_STRING:
      {
         return copyString(IAS_OCT2WIDE(val.OctetString));
      }
   }

   return emptyString;
}

///////
// An InsertionString definition consists of the attribute ID and a
// defaultValue to be used if the attribute isn't present.
///////
struct InsertionString
{
   DWORD attrID;
   DWORD defaultValue;
};

// Insertion strings for an Access-Accept.
const InsertionString ACCEPT_ATTRS[] =
{
   { RADIUS_ATTRIBUTE_USER_NAME,              IASP_NOT_PRESENT  },
   { IAS_ATTRIBUTE_FULLY_QUALIFIED_USER_NAME, IASP_UNDETERMINED },
   { RADIUS_ATTRIBUTE_NAS_IP_ADDRESS,         IASP_NOT_PRESENT  },
   { RADIUS_ATTRIBUTE_NAS_IDENTIFIER,         IASP_NOT_PRESENT  },
   { IAS_ATTRIBUTE_CLIENT_NAME,               IASP_NOT_PRESENT  },
   { IAS_ATTRIBUTE_CLIENT_IP_ADDRESS,         IASP_NOT_PRESENT  },
   { RADIUS_ATTRIBUTE_CALLING_STATION_ID,     IASP_NOT_PRESENT  },
   { RADIUS_ATTRIBUTE_NAS_PORT_TYPE,          IASP_NOT_PRESENT  },
   { RADIUS_ATTRIBUTE_NAS_PORT,               IASP_NOT_PRESENT  },
   { IAS_ATTRIBUTE_PROXY_POLICY_NAME,         IASP_NONE         },
   { IAS_ATTRIBUTE_PROVIDER_TYPE,             IASP_UNDETERMINED },
   { IAS_ATTRIBUTE_REMOTE_SERVER_ADDRESS,     IASP_UNDETERMINED },
   { IAS_ATTRIBUTE_NP_NAME,                   IASP_UNDETERMINED },
   { IAS_ATTRIBUTE_AUTHENTICATION_TYPE,       IASP_UNDETERMINED },
   { IAS_ATTRIBUTE_EAP_FRIENDLY_NAME,         IASP_UNDETERMINED },
   { ATTRIBUTE_UNDEFINED,                     IASP_UNDETERMINED }
};

// Insertion strings for an Access-Reject.
const InsertionString REJECT_ATTRS[] =
{
   { RADIUS_ATTRIBUTE_USER_NAME,              IASP_NOT_PRESENT  },
   { IAS_ATTRIBUTE_FULLY_QUALIFIED_USER_NAME, IASP_UNDETERMINED },
   { RADIUS_ATTRIBUTE_NAS_IP_ADDRESS,         IASP_NOT_PRESENT  },
   { RADIUS_ATTRIBUTE_NAS_IDENTIFIER,         IASP_NOT_PRESENT  },
   { RADIUS_ATTRIBUTE_CALLED_STATION_ID,      IASP_NOT_PRESENT  },
   { RADIUS_ATTRIBUTE_CALLING_STATION_ID,     IASP_NOT_PRESENT  },
   { IAS_ATTRIBUTE_CLIENT_NAME,               IASP_NOT_PRESENT  },
   { IAS_ATTRIBUTE_CLIENT_IP_ADDRESS,         IASP_NOT_PRESENT  },
   { RADIUS_ATTRIBUTE_NAS_PORT_TYPE,          IASP_NOT_PRESENT  },
   { RADIUS_ATTRIBUTE_NAS_PORT,               IASP_NOT_PRESENT  },
   { IAS_ATTRIBUTE_PROXY_POLICY_NAME,         IASP_NONE         },
   { IAS_ATTRIBUTE_PROVIDER_TYPE,             IASP_UNDETERMINED },
   { IAS_ATTRIBUTE_REMOTE_SERVER_ADDRESS,     IASP_UNDETERMINED },
   { IAS_ATTRIBUTE_NP_NAME,                   IASP_UNDETERMINED },
   { IAS_ATTRIBUTE_AUTHENTICATION_TYPE,       IASP_UNDETERMINED },
   { IAS_ATTRIBUTE_EAP_FRIENDLY_NAME,         IASP_UNDETERMINED },
   { IAS_ATTRIBUTE_REASON_CODE,               IASP_UNDETERMINED },
   { IAS_ATTRIBUTE_REASON_STRING,             IASP_UNDETERMINED },
   { ATTRIBUTE_UNDEFINED,                     IASP_UNDETERMINED }
};

// Insertion strings for a discarded request.
const InsertionString DISCARD_ATTRS[] =
{
   { RADIUS_ATTRIBUTE_USER_NAME,              IASP_NOT_PRESENT  },
   { IAS_ATTRIBUTE_FULLY_QUALIFIED_USER_NAME, IASP_UNDETERMINED },
   { RADIUS_ATTRIBUTE_NAS_IP_ADDRESS,         IASP_NOT_PRESENT  },
   { RADIUS_ATTRIBUTE_NAS_IDENTIFIER,         IASP_NOT_PRESENT  },
   { RADIUS_ATTRIBUTE_CALLED_STATION_ID,      IASP_NOT_PRESENT  },
   { RADIUS_ATTRIBUTE_CALLING_STATION_ID,     IASP_NOT_PRESENT  },
   { IAS_ATTRIBUTE_CLIENT_NAME,               IASP_NOT_PRESENT  },
   { IAS_ATTRIBUTE_CLIENT_IP_ADDRESS,         IASP_NOT_PRESENT  },
   { RADIUS_ATTRIBUTE_NAS_PORT_TYPE,          IASP_NOT_PRESENT  },
   { RADIUS_ATTRIBUTE_NAS_PORT,               IASP_NOT_PRESENT  },
   { IAS_ATTRIBUTE_PROXY_POLICY_NAME,         IASP_NONE         },
   { IAS_ATTRIBUTE_PROVIDER_TYPE,             IASP_UNDETERMINED },
   { IAS_ATTRIBUTE_REMOTE_SERVER_ADDRESS,     IASP_UNDETERMINED },
   { IAS_ATTRIBUTE_REASON_CODE,               IASP_UNDETERMINED },
   { IAS_ATTRIBUTE_REASON_STRING,             IASP_UNDETERMINED },
   { ATTRIBUTE_UNDEFINED,                     IASP_UNDETERMINED }
};

// Insertion strings for a discarded accounting request.
const InsertionString ACCT_DISCARD_ATTRS[] =
{
   { RADIUS_ATTRIBUTE_USER_NAME,              IASP_NOT_PRESENT  },
   { IAS_ATTRIBUTE_FULLY_QUALIFIED_USER_NAME, IASP_UNDETERMINED },
   { RADIUS_ATTRIBUTE_NAS_IP_ADDRESS,         IASP_NOT_PRESENT  },
   { RADIUS_ATTRIBUTE_NAS_IDENTIFIER,         IASP_NOT_PRESENT  },
   { RADIUS_ATTRIBUTE_CALLED_STATION_ID,      IASP_NOT_PRESENT  },
   { RADIUS_ATTRIBUTE_CALLING_STATION_ID,     IASP_NOT_PRESENT  },
   { IAS_ATTRIBUTE_CLIENT_NAME,               IASP_NOT_PRESENT  },
   { IAS_ATTRIBUTE_CLIENT_IP_ADDRESS,         IASP_NOT_PRESENT  },
   { RADIUS_ATTRIBUTE_NAS_PORT_TYPE,          IASP_NOT_PRESENT  },
   { RADIUS_ATTRIBUTE_NAS_PORT,               IASP_NOT_PRESENT  },
   { IAS_ATTRIBUTE_PROXY_POLICY_NAME,         IASP_NONE         },
   { IAS_ATTRIBUTE_PROVIDER_TYPE,             IASP_UNDETERMINED },
   { IAS_ATTRIBUTE_REMOTE_SERVER_ADDRESS,     IASP_UNDETERMINED },
   { IAS_ATTRIBUTE_REASON_CODE,               IASP_UNDETERMINED },
   { IAS_ATTRIBUTE_REASON_STRING,             IASP_UNDETERMINED },
   { ATTRIBUTE_UNDEFINED,                     IASP_UNDETERMINED }
};

VOID
WINAPI
IASRadiusLogResult(
    IRequest* request,
    IAttributesRaw* raw
    )
{
   // Determine which response type this is.
   LONG type;
   HRESULT hr = request->get_Response(&type);
   if (FAILED(hr))
   {
      return;
   }

   DWORD eventID;
   const InsertionString* attrs;
   switch (type)
   {
      case IAS_RESPONSE_ACCESS_ACCEPT:
      {
         eventID = IAS_RESPONSE_ACCEPT;
         attrs = ACCEPT_ATTRS;
         break;
      }

      case IAS_RESPONSE_ACCESS_REJECT:
      {
         eventID = IAS_RESPONSE_REJECT;
         attrs = REJECT_ATTRS;
         break;
      }

      case IAS_RESPONSE_DISCARD_PACKET:
      {
         hr = request->get_Request(&type);
         if (FAILED(hr))
         {
            return;
         }

         switch (type)
         {
            case IAS_REQUEST_ACCESS_REQUEST:
            {
               eventID = IAS_RESPONSE_DISCARD;
               attrs = DISCARD_ATTRS;
               break;
            }

            case IAS_REQUEST_ACCOUNTING:
            {
               eventID = IAS_ACCT_RESPONSE_DISCARD;
               attrs = ACCT_DISCARD_ATTRS;
               break;
            }

            default:
            {
               return;
            }
         }
         break;
      }

      default:
      {
         return;
      }
   }

   // Format the insertion strings.
   PWSTR strings[24];
   DWORD numStrings = 0;
   for ( ; attrs->attrID != ATTRIBUTE_UNDEFINED; ++attrs, ++numStrings)
   {
      strings[numStrings] = formatAttribute(
                                request,
                                raw,
                                attrs->attrID,
                                attrs->defaultValue
                                );
   }

   // Report the event.
   IASReportEvent(
       eventID,
       numStrings,
       0,
       (PCWSTR*)strings,
       NULL
       );

   // Free the insertion strings.
   while (numStrings--)
   {
      freeString(strings[numStrings]);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\packetsender.cpp ===
//#--------------------------------------------------------------
//
//  File:		packetsender.cpp
//
//  Synopsis:   Implementation of CPacketSender class methods
//              The Class is responsible for sending RADIUS
//              packet data out to the client
//
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "packetsender.h"

//++--------------------------------------------------------------
//
//  Function:   CPacketSender
//
//  Synopsis:   This is the constructor of the CPacketSender class
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     11/25/97
//
//----------------------------------------------------------------
CPacketSender::CPacketSender(
						VOID
						)
{
}	//	end of CPacketSender class constructor

//++--------------------------------------------------------------
//
//  Function:   ~CPacketSender
//
//  Synopsis:   This is the destructor of the CPacketSender class
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//  History:    MKarki      Created     11/25/97
//
//----------------------------------------------------------------
CPacketSender::~CPacketSender(
		VOID
		)
{
}   //  end of CPacketSender class destructor

//++--------------------------------------------------------------
//
//  Function:   SendPacket
//
//  Synopsis:   This is the CPacketSender public method that sends
//              packets out to the net
//
//  Arguments:
//              [in]    CPacketRadius*
//
//  Returns:    BOOL    -   bStatus
//
//
//  History:    MKarki      Created     11/25/97
//
//  CalledBy:   classes derived from CProcessor and CValidator
//
//----------------------------------------------------------------
HRESULT
CPacketSender::SendPacket (
                    CPacketRadius   *pCPacketRadius
                    )
{
    BOOL    bStatus = FALSE;
    PBYTE   pOutBuffer = NULL;
    DWORD   dwSize = 0;
    DWORD   dwPeerAddress = 0;
    WORD    wPeerPort = 0;
    SOCKET  sock;
    HRESULT hr = S_OK;

    _ASSERT (pCPacketRadius);

    __try
    {

        if (FALSE == IsProcessingEnabled ())
        {
            hr = E_FAIL;
            __leave;
        }

        //
        //  get the out packet buffer from the packet object
        //
        pOutBuffer = pCPacketRadius->GetOutPacket ();

        //
        // get the data size
        //
        dwSize = pCPacketRadius->GetOutLength ();

        //
        //  get the Peer address
        //
        dwPeerAddress = pCPacketRadius->GetOutAddress ();

        //
        //  get the Peer port number
        //
        wPeerPort = pCPacketRadius->GetOutPort ();

        //
        // get the socket
        //
        sock = pCPacketRadius->GetSocket ();


        //
        //  send the data out now
        //
        SOCKADDR_IN sin;
        sin.sin_family = AF_INET;
        sin.sin_port = htons (wPeerPort);
        sin.sin_addr.s_addr = htonl (dwPeerAddress);
        INT iBytesSent = ::sendto (
                                sock,
                                (PCHAR)pOutBuffer,
                                (INT)dwSize,
                                0,
                                (PSOCKADDR)&sin,
                                (INT)sizeof (SOCKADDR)
                                );
        if ((iBytesSent > 0)  && (iBytesSent < dwSize))
        {
            IASTracePrintf (
                "Unable to send out complete Radius packet"
                );
        }
        else if (SOCKET_ERROR == iBytesSent)
        {
           int data = WSAGetLastError();

            IASTracePrintf (
                "Unable to send Radius packet due to error:%d", data
                );

            IASReportEvent(
                RADIUS_E_CANT_SEND_RESPONSE,
                0,
                sizeof(data),
                NULL,
                &data
                );

            hr = RADIUS_E_ERRORS_OCCURRED;
            __leave;
        }

        //
        //  success
        //
    }
    __finally
    {
    }

    return (hr);

}   //  end of CPacketSender::SendPacket method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\packetsender.h ===
//#--------------------------------------------------------------
//        
//  File:       packetsender.h
//        
//  Synopsis:   This file holds the declarations of the 
//				CPacketSender class
//              
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _PACKETSENDER_H_
#define _PACKETSENDER_H_

#include "packetio.h"
#include "packetradius.h"
#include "radcommon.h"

class CPacketSender : public CPacketIo  
{
public:

    //
    //  send packet to the Transport component
    //
    HRESULT SendPacket (
                /*[in]*/    CPacketRadius   *pCPacketRadius
                );
    //
    //  constructor
    //
	CPacketSender(VOID);

    //
    //  destructor
    //
	virtual ~CPacketSender(VOID);
};

#endif //	infndef _PACKETRECEIVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\packetreceiver.cpp ===
//#--------------------------------------------------------------
//
//  File:      packetreceiver.cpp
//
//  Synopsis:   Implementation of CPacketReceiver class methods
//
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "packetreceiver.h"
#include <new>
#include <iastlutl.h>
#include <iasutil.h>

//
// this is the time we allow the worker thread to sleep
//
const DWORD MAX_SLEEP_TIME = 1000; //1000 milli-seconds

extern LONG g_lPacketCount;
extern LONG g_lThreadCount;

///////////////////////////////////////////////////////////////////////////////
//
// Retrieve the Auto-Reject User-Name pattern from the registry.
//
///////////////////////////////////////////////////////////////////////////////
BSTR
WINAPI
IASRadiusGetPingUserName( VOID )
{
   LONG status;
   HKEY hKey;
   status = RegOpenKeyW(
                HKEY_LOCAL_MACHINE,
                L"SYSTEM\\CurrentControlSet\\Services\\IAS\\Parameters",
                &hKey
                );
   if (status != NO_ERROR) { return NULL; }

   BSTR val = NULL;

   DWORD cbData, type;
   status = RegQueryValueExW(
                hKey,
                L"Ping User-Name",
                NULL,
                &type,
                NULL,
                &cbData
                );
   if (status == NO_ERROR && type == REG_SZ)
   {
      PWSTR buf = (PWSTR)_alloca(cbData);
      status = RegQueryValueExW(
                   hKey,
                   L"Ping User-Name",
                   NULL,
                   &type,
                   (PBYTE)buf,
                   &cbData
                   );
      if (status == NO_ERROR && type == REG_SZ)
      {
         val = SysAllocString(buf);
      }
   }

   RegCloseKey(hKey);

   return val;
}

///////////////////////////////////////////////////////////////////////////////
//
// Handle ping packets.
//
///////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
IASRadiusIsPing(
    CPacketRadius& pkt,
    const RegularExpression& regexp
    ) throw ()
{
   // Determine the ping response.
   PACKETTYPE outCode;
   switch (pkt.GetInCode())
   {
      case ACCESS_REQUEST:
         outCode = ACCESS_REJECT;
         break;

      case ACCOUNTING_REQUEST:
         outCode = ACCOUNTING_RESPONSE;
         break;

      default:
         return FALSE;
   }

   // Get the User-Name.
   PATTRIBUTE username = pkt.GetUserName();
   if (!username) { return FALSE; }

   // Convert to UNICODE and test against the pattern.
   IAS_OCTET_STRING oct = { username->byLength - 2, username->ValueStart };
   if (!regexp.testString(IAS_OCT2WIDE(oct))) { return FALSE; }

   // Build the empty out packet.
   HRESULT hr = pkt.BuildOutPacket(outCode, NULL, 0);
   if (SUCCEEDED(hr))
   {
      // Compute the Response-Authenticator.
      pkt.GenerateOutAuthenticator();

      // Get the packet ...
      PBYTE buf = pkt.GetOutPacket();
      WORD buflen = pkt.GetOutLength();

      // ... and address.
      SOCKADDR_IN sin;
      sin.sin_family = AF_INET;
      sin.sin_port = htons(pkt.GetOutPort());
      sin.sin_addr.s_addr = htonl(pkt.GetOutAddress());

      // Send the ping response.
      sendto(
          pkt.GetSocket(),
          (const char*)buf,
          buflen,
          0,
          (PSOCKADDR)&sin,
          sizeof(sin)
          );
   }

   // This packet has been processed.
   InterlockedDecrement(&g_lPacketCount);

   return TRUE;
}

//+++-------------------------------------------------------------
//
//  Function:   CPacketReceiver
//
//  Synopsis:   This is the constructor of the CPacketReceiver class
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     9/26/97
//
//----------------------------------------------------------------
CPacketReceiver::CPacketReceiver(
                  VOID
                  )
                  : pingPattern(NULL),
                    m_pCDictionary (NULL),
                    m_pCPreValidator (NULL),
                    m_pCHashMD5 (NULL),
                    m_pCHashHmacMD5 (NULL),
                    m_pCClients (NULL),
                    m_pCReportEvent (NULL)
{
}  // end of CPacketReceiver constructor

//+++-------------------------------------------------------------
//
//  Function:   ~CPacketReceiver
//
//  Synopsis:   This is the destructor of the CPacketReceiver class
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//  History:    MKarki      Created     9/23/97
//
//----------------------------------------------------------------
CPacketReceiver::~CPacketReceiver(
      VOID
      )
{
   SysFreeString(pingPattern);

}  // end of CPacketReceiver destructor

//+++-------------------------------------------------------------
//
//  Function:   Init
//
//  Synopsis:   This is the method which initializes the
//          CPacketReceiver class object
//
//  Arguments:
//               [in]  CDictionary*
//               [in]  CPreValidator*
//               [in]  CHashMD5*
//               [in]  CHashHmacMD5*
//               [in]  CReportEvent*
//
//  Returns:    BOOL -  status
//
//
//  History:    MKarki      Created     9/29/97
//
// Called By:  CContoller class method
//
//----------------------------------------------------------------
BOOL CPacketReceiver::Init(
                        CDictionary   *pCDictionary,
                        CPreValidator *pCPreValidator,
                        CHashMD5      *pCHashMD5,
                        CHashHmacMD5  *pCHashHmacMD5,
                        CClients      *pCClients,
                        CReportEvent  *pCReportEvent
                  )
{
    _ASSERT (
             (NULL != pCDictionary)   &&
             (NULL != pCPreValidator) &&
             (NULL != pCHashMD5)      &&
             (NULL != pCHashHmacMD5)  &&
             (NULL != pCClients)      &&
             (NULL != pCReportEvent)
            );

    HRESULT hr = FinalConstruct();
    if (FAILED(hr))
    {
       return FALSE;
    }

    // Initialize the Auto-Reject pattern.
    if (pingPattern = IASRadiusGetPingUserName())
    {
       regexp.setGlobal(TRUE);
       regexp.setIgnoreCase(TRUE);
       regexp.setPattern(pingPattern);
    }

    m_pCDictionary  =  pCDictionary;

    m_pCPreValidator = pCPreValidator;

    m_pCHashMD5 = pCHashMD5;

    m_pCHashHmacMD5 = pCHashHmacMD5;

    m_pCClients = pCClients;

    m_pCReportEvent = pCReportEvent;

    if (m_AuthEvent.initialize() || m_AcctEvent.initialize())
    {
       return FALSE;
    }

    return (TRUE);

}  // end of CPacketReceiver::Init method

//+++-------------------------------------------------------------
//
//  Function:   StartProcessing
//
//  Synopsis:   This is the method to start receiving inbound
//              data
//
//  Arguments:
//              [in]    fd_set -   Authentication socket set
//              [in]    fd_set -   Accounting socket set
//
//  Returns:    BOOL -  status
//
//  History:    MKarki      Created     11/19/97
//
// Called By:  CContoller::InternalInit method
//
//----------------------------------------------------------------
BOOL
CPacketReceiver::StartProcessing (
                    /*[in]*/    fd_set&  AuthSet,
                    /*[in]*/    fd_set&  AcctSet
                    )
{

    BOOL  bStatus = FALSE;

    __try
    {
        //
        // enable
        //
        EnableProcessing ();

        m_AuthSet = AuthSet;
        m_AcctSet = AcctSet;

        // Make sure the events are clear ...
        m_AuthEvent.reset();
        m_AcctEvent.reset();

        // ... and add the to the fd_set.
        FD_SET (m_AuthEvent, &m_AuthSet);
        FD_SET (m_AcctEvent, &m_AcctSet);

        //
        // start a new thread to process authentication requests
        //
        bStatus = StartThreadIfNeeded (AUTH_PORTTYPE);
        if (FALSE == bStatus)  { __leave; }

        //
        // start a new thread to process accounting requests
        //
        bStatus =  StartThreadIfNeeded (ACCT_PORTTYPE);
        if (FALSE == bStatus) { __leave; }

        //
        //  success
        //

    }
    __finally
    {
        if (FALSE == bStatus) { DisableProcessing (); }
    }

    return (bStatus);

}   //  end of CPacketReceiver::StartProcessing method

//+++-------------------------------------------------------------
//
//  Function:   StopProcessing
//
//  Synopsis:   This is the method to stop receiving inbound
//              data
//
//  Arguments:  none
//
//  Returns:    BOOL -  status
//
//
//  History:    MKarki      Created     11/19/97
//
// Called By:  CContoller::Suspend method
//
//----------------------------------------------------------------
BOOL
CPacketReceiver::StopProcessing (
                    VOID
                    )
{

    DisableProcessing ();

    // Signal the SocketEvents to wake up the worker threads.
    m_AuthEvent.set();
    m_AcctEvent.set();

    return (TRUE);

}   //  end of CPacketReceiver::StopProcessing method
//+++-------------------------------------------------------------
//
//  Function:   ReceivePacket
//
//  Synopsis:   This is the method which receives the UDP packet
//          buffer and starts processing it.
//
//  Arguments:
//          [in]  PBYTE -   in packet buffer
//          [in]  DWORD -  size of the packet
//          [in]  DWORD -  Client's IP address
//          [in]  WORD  -  Client's UDP port
//
//  Returns:    HRESULT - status
//
// Called By:  CPacketReceiver::WorkerRoutine  private method
//
//  History:    MKarki      Created     9/23/97
//
//----------------------------------------------------------------
HRESULT
CPacketReceiver::ReceivePacket(
               PBYTE           pInBuffer,
               DWORD           dwSize,
               DWORD           dwIPaddress,
               WORD            wPort,
               SOCKET          sock,
               PORTTYPE        portType
               )
{
    BOOL                    bStatus = FALSE;
    HRESULT                 hr = S_OK;
    CPacketRadius           *pCPacketRadius = NULL;
    CComPtr <IIasClient>    pIIasClient;


    _ASSERT (pInBuffer);

    //
    // get client information for this RADIUS packet
    //
    bStatus = m_pCClients->FindObject (
                           dwIPaddress,
                           &pIIasClient
                           );
    if (!bStatus)
    {
        //
        //  free the allocated in buffer
        //
        CoTaskMemFree (pInBuffer);

        //
        //  log error and generate audit event
        //
        WCHAR srcAddr[16];
        ias_inet_htow(dwIPaddress, srcAddr);
        PCWSTR strings[] = { srcAddr };
        IASReportEvent(
            RADIUS_E_INVALID_CLIENT,
            1,
            0,
            strings,
            NULL
            );

        //
        //  generate an Audit Log
        //
        m_pCReportEvent->Process (
            RADIUS_INVALID_CLIENT,
            (AUTH_PORTTYPE == portType) ? ACCESS_REQUEST : ACCOUNTING_REQUEST,
            dwSize,
            dwIPaddress,
            0,
            pInBuffer
            );
        return RADIUS_E_ERRORS_OCCURRED;
    }

    //
    // create packet radius object
    //
    pCPacketRadius = new (std::nothrow) CPacketRadius (
                                                    m_pCHashMD5,
                                                    m_pCHashHmacMD5,
                                                    pIIasClient,
                                                    m_pCReportEvent,
                                                    pInBuffer,
                                                    dwSize,
                                                    dwIPaddress,
                                                    wPort,
                                                    sock,
                                                    portType
                                                    );
    if (NULL == pCPacketRadius)
    {
        //
        //  free the allocated in buffer
        //
        CoTaskMemFree (pInBuffer);
        IASTracePrintf (
            "Unable to create Packet-Radius object during packet processing"
            );
        hr = E_OUTOFMEMORY;
       goto Cleanup;
    }

    //
    // now do the preliminary verification of the packet received
    //
    hr = pCPacketRadius->PrelimVerification (
                        m_pCDictionary,
                        dwSize
                        );
    if (FAILED (hr)) { goto Cleanup; }

    // If the Ping User-Name pattern has been set, then we must test
    // this packet.
    if (pingPattern && IASRadiusIsPing(*pCPacketRadius, regexp))
    {
       // It was a ping packet, so we're done.
       delete pCPacketRadius;
       return S_OK;
    }

    //
    // now pass on this packet to the PreValidator
    //
    hr = m_pCPreValidator->StartInValidation (pCPacketRadius);
    if (FAILED (hr)) { goto Cleanup; }

Cleanup:

    //
    //  cleanup on error
    //
    if (FAILED (hr))
    {

        if (hr != RADIUS_E_ERRORS_OCCURRED)
        {
           IASReportEvent(
               RADIUS_E_INTERNAL_ERROR,
               0,
               sizeof(hr),
               NULL,
               &hr
               );
        }

        //
        //  also inform that the packet is being discarded
        //
        in_addr sin;
        sin.s_addr = htonl (dwIPaddress);
        IASTracePrintf (
                "Silently  discarding packet received from:%s",
                 inet_ntoa (sin)
             );


        //
        //  inform that packet is being discarded
        //
        m_pCReportEvent->Process (
                RADIUS_DROPPED_PACKET,
                (AUTH_PORTTYPE == portType)?ACCESS_REQUEST:ACCOUNTING_REQUEST,
                dwSize,
                dwIPaddress,
                NULL,
                static_cast <LPVOID> (pInBuffer)
                );

        //
        // free the memory
        //
        if (pCPacketRadius) { delete pCPacketRadius; }
    }

   return (hr);

}  // end of CPacketReceiver::ReceivePacket method


bool CPacketReceiver::WorkerRoutine(DWORD dwInfo) throw ()
{
    // Return value from the function. Indicates whether or not the caller
    // should call WorkerRoutine again because we were unable to schedule a
    // replacement thread.
    bool shouldCallAgain = false;

    BOOL            bSuccess = FALSE;
    DWORD           dwPeerAddress = 0;
    WORD            wPeerPort = 0;
    CPacketRadius   *pCPacketRadius = NULL;
    PBYTE           pBuffer = NULL;
    PBYTE           pReAllocatedBuffer = NULL;
    DWORD           dwSize = MAX_PACKET_SIZE;
    fd_set          socketSet;
    SOCKET          sock = INVALID_SOCKET;

    __try
    {
        if (AUTH_PORTTYPE == (PORTTYPE)dwInfo)
        {
            socketSet = m_AuthSet;
        }
        else
        {
            socketSet = m_AcctSet;
        }

StartAgain:

        //
        //  check if the processing is still going on
        //
        if (FALSE == IsProcessingEnabled ())
        {
            IASTracePrintf (
                "Worker Thread exiting as packet processing is not enabled"
                );
            __leave;
        }

        //
        //  allocate a new inbound packet buffer
        //
        pBuffer = reinterpret_cast <PBYTE> (m_InBufferPool.allocate ());
        if (NULL == pBuffer)
        {
            IASTracePrintf (
            "unable to allocate memory from buffer pool for in-bound packet"
               );

            //
            //  Sleep for a second, and try again
            //  Fix for Bug #159140 - MKarki - 4/29/98
            //
            Sleep (MAX_SLEEP_TIME);

            //
            //  we will have to check whether processing is still
            //  enabled
            //
            goto StartAgain;
        }

        //
        // wait now on select
        //
        INT iRetVal = select (0, &socketSet, NULL, NULL, NULL);
        if (SOCKET_ERROR == iRetVal)
        {
           int iWsaError = ::WSAGetLastError();
           IASTracePrintf (
              "Worker Thread failed on select call with error:%d",
              iWsaError
              );
           if (WSAENOBUFS == iWsaError)
           {
              IASTraceString("WARNING: out of memory condition on select in CPacketReceiver::WorkerRoutine");
              // out of memory condition. Keep using this thread.
              shouldCallAgain = true;
              // to give a chance to the system to recover from a transient 
              // condition
              Sleep(5);
           }
           __leave;
        }

        //
        //  check if the processing is still going on
        //
        if (FALSE == IsProcessingEnabled ())
        {
            IASTracePrintf(
                "Worker Thread exiting as packet processing is not enabled"
                );
            __leave;
        }

        //
        // get a socket to recv data on
        //
        static size_t nextSocket;
        sock = socketSet.fd_array[++nextSocket % iRetVal];

        //
        // recv data now
        //
        SOCKADDR_IN sin;
        DWORD dwAddrSize = sizeof (SOCKADDR);
        dwSize = ::recvfrom (
                       sock,
                       (PCHAR)pBuffer,
                       (INT)dwSize,
                       (INT)0,
                       (PSOCKADDR)&sin,
                       (INT*)&dwAddrSize
                       );

        // Request a new thread now
        if (!StartThreadIfNeeded(dwInfo))
        {
           // We were unable to create a replacement thread, so this thread
           // will have to keep receiving packets for now.
           IASTraceString("WARNING StartThreadIfNeeded failed in CPacketReceiver::WorkerRoutine");
           shouldCallAgain = true;
        }

        //
        //  if failed to receive data, quit processing
        //  MKarki 3/13/98 - Fix for Bug #147266
        //  Fix Summary: check for dwSize == 0 too
        //
        if ( 0 == dwSize )
        {
           IASTraceString("WARNING failed to receive data, quit processing in CPacketReceiver::WorkerRoutine");
            __leave;
        }

        wPeerPort = ntohs (sin.sin_port);
        dwPeerAddress = ntohl (sin.sin_addr.s_addr);

        if ( dwSize == SOCKET_ERROR )
        {
           int error = WSAGetLastError();
           IASTracePrintf (
              "WARNING Worker Thread failed on recvfrom with error:%d",
              error
              );

           switch (error)
           {
           case WSAEMSGSIZE:
              {
                  ProcessInvalidPacketSize(dwInfo, pBuffer, dwPeerAddress);
                 __leave;
              }

           default:
               __leave;
           }
        }

        //
        //  reallocate buffer to size
        //
        pReAllocatedBuffer =  reinterpret_cast <PBYTE>
                              (CoTaskMemAlloc (dwSize));
        if (NULL == pReAllocatedBuffer)
        {
            IASTracePrintf (
                "Unable to allocate memory for received Radius packet "
                "from Process Heap"
                );
           __leave;
        }

        //
        //  copy the information into this buffer
        //
        CopyMemory (pReAllocatedBuffer, pBuffer, dwSize);

        //
        //  free the memory from the pool
        //
        m_InBufferPool.deallocate (pBuffer);
        pBuffer = NULL;

        //
        //  success
        //
        bSuccess = TRUE;
    }
    __finally
    {
        if (FALSE == bSuccess)
        {
            //
            // do Cleanup
            //
            if (pBuffer) { m_InBufferPool.deallocate (pBuffer); }
        }
        else
        {
            //
            //  Increment the packet count here
            //
            InterlockedIncrement (&g_lPacketCount);

            //
            // start processing data
            //
            HRESULT hr = ReceivePacket (
                            pReAllocatedBuffer,
                            dwSize,
                            dwPeerAddress,
                            wPeerPort,
                            sock,
                            (PORTTYPE)dwInfo
                            );
            if (FAILED (hr))
            {
                //
                //  Decrement the packet count here
                //
                InterlockedDecrement (&g_lPacketCount);
            }
        }
    }

    return shouldCallAgain;
}


void WINAPI CPacketReceiver::CallbackRoutine(IAS_CALLBACK* context) throw ()
{
   ReceiverCallback* cback = static_cast<ReceiverCallback*>(context);
   while (cback->self->WorkerRoutine(cback->dwInfo))
   {
      IASTraceString("WARNING: reusing WorkerRoutine");
   }
   CoTaskMemFree(cback);

   //  decrement the global worker thread count
   InterlockedDecrement(&g_lThreadCount);
}


BOOL CPacketReceiver::StartThreadIfNeeded(DWORD dwInfo)
{
   // check if the processing is still going on
   if (!IsProcessingEnabled())
   {
      return TRUE;
   }

   ReceiverCallback* cback = static_cast<ReceiverCallback*>(
                                CoTaskMemAlloc(sizeof(ReceiverCallback))
                                );
   if (cback == 0)
   {
      IASTraceString(
         "CoTaskMemAlloc failed in CPacketReceiver::StartThreadIfNeeded."
         );
      return FALSE;
   }

   cback->CallbackRoutine = CallbackRoutine;
   cback->self = this;
   cback->dwInfo = dwInfo;

   InterlockedIncrement(&g_lThreadCount);

   // Request a new thread now
   if (!IASRequestThread(cback))
   {
      InterlockedDecrement(&g_lThreadCount);
      CoTaskMemFree(cback);

      IASTraceString(
         "IASRequestThread failed in CPacketReceiver::StartThreadIfNeeded."
         );

      return FALSE;
  }

  return TRUE;
}


//+++-------------------------------------------------------------
//
//  Function:   ProcessInvalidPacketSize
//
//  Synopsis:   Process the UDP packets received when the size of the packet
//              is bigger than MAX_PACKET_SIZE (4096)
//              Log the error.
//
//  Arguments:  [in]  DWORD  - info to give to thread
//                    (comes from WorkerRoutine)
//
//              [in] const void* pBuffer - contains the 4096 first bytes
//                   of the packet received
//              [in] DWORD address - source address (host order)
//
//
// Called By: CPacketReceiver::WorkerRoutine
//
//----------------------------------------------------------------
void CPacketReceiver::ProcessInvalidPacketSize(
                        /*in*/ DWORD dwInfo,
                        /*in*/ const void* pBuffer,
                        /*in*/ DWORD address
                        )
{
   //
   // packet received bigger than max size.
   // log error and generate audit event
   //

   // extract the IP address
   WCHAR srcAddr[16];
   ias_inet_htow(address, srcAddr);

   IASTracePrintf(
      "Incorrect received packet from %S, size: greater than %d",
      srcAddr, MAX_PACKET_SIZE
      );

   //
   // get client information for this RADIUS packet
   //

   BOOL bStatus = m_pCClients->FindObject(address);
   if ( bStatus == FALSE )
   {
      //
      // Invalid Client
      // log error and generate audit event
      //

      IASTracePrintf(
         "No client with IP-Address:%S registered with server",
         srcAddr
         );

      PCWSTR strings[] = { srcAddr };
      IASReportEvent(
         RADIUS_E_INVALID_CLIENT,
         1,
         0,
         strings,
         NULL
         );

      //
      //  generate an Audit Log
      //
      m_pCReportEvent->Process(
         RADIUS_INVALID_CLIENT,
         (AUTH_PORTTYPE == (PORTTYPE)dwInfo)?ACCESS_REQUEST:ACCOUNTING_REQUEST,
         MAX_PACKET_SIZE,
         address,
         NULL,
         const_cast<void*> (pBuffer)
         );
   }
   else
   {
      //
      // Valid client but packet received bigger than max size.
      // log error and generate audit event
      //

      PCWSTR strings[] = {srcAddr};
      IASReportEvent(
         RADIUS_E_MALFORMED_PACKET,
         1,
         MAX_PACKET_SIZE,
         strings,
         const_cast<void*> (pBuffer)
      );

      //
      //  generate an Audit Log
      //

      m_pCReportEvent->Process(
         RADIUS_MALFORMED_PACKET,
         (AUTH_PORTTYPE == (PORTTYPE)dwInfo)?ACCESS_REQUEST:ACCOUNTING_REQUEST,
         MAX_PACKET_SIZE,
         address,
         NULL,
         const_cast<void*> (pBuffer)
         );
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\packetreceiver.h ===
//#--------------------------------------------------------------
//
//  File:       packetreceiver.h
//
//  Synopsis:   This file holds the declarations of the
//            CPacketReceiver class
//
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _PACKETRECEIVER_H_
#define _PACKETRECEIVER_H_

#include "mempool.h"
#include "packetio.h"
#include "packetradius.h"
#include "prevalidator.h"
#include "reportevent.h"
#include "clients.h"
#include "sockevt.h"
#include "radcommon.h"
#include "regex.h"

class CHashMD5;

class CHashHmacMD5;

class CDictionary;

class CPacketReceiver : public CPacketIo
{
public:

    //
    //  initializes the CPacketReceiver class object
    //
   BOOL Init (
         /*[in]*/   CDictionary   *pCDictionary,
         /*[in]*/   CPreValidator *pCPreValidator,
           /*[in]*/ CHashMD5      *pCHashMD5,
           /*[in]*/ CHashHmacMD5  *pCHashHmacMD5,
           /*[in]*/ CClients      *pCClients,
           /*[in]*/ CReportEvent  *pCReportEvent
      );

    //
    //  start processing of the new packet received
    //
   HRESULT ReceivePacket (
             /*[in]*/   PBYTE           pInBuffer,
             /*[in]*/   DWORD           dwSize,
             /*[in]*/   DWORD           dwIPaddress,
             /*[in]*/   WORD            wPort,
             /*[in]*/   SOCKET          sock,
             /*[in]*/   PORTTYPE        portType
             );

   // The receiver thread worker routine. Returns 'true' if the function should
   // be called again because the worker was unable to schedule a replacement.
   // The caller should continue to call WorkerRoutine until it returns false.
   bool WorkerRoutine(DWORD dwInfo) throw ();

    //
    //  initate the processing of inbound data
    //
    BOOL StartProcessing (
                    fd_set&  AuthSet,
                    fd_set&  AcctSet
                    );

    //
    //  stop processing of inbound data
    //
    BOOL StopProcessing (
                    VOID
                    );

    //
    //  constructor
    //
   CPacketReceiver(VOID);

    //
    //  destructor
    //
   virtual ~CPacketReceiver(VOID);

private:
   // State passed to the receiver thread.
   struct ReceiverCallback : IAS_CALLBACK
   {
      CPacketReceiver* self;
      DWORD dwInfo;
   };

   // Thread start routine for the receiver thread.
   static void WINAPI CallbackRoutine(IAS_CALLBACK* context) throw ();

    BOOL  StartThreadIfNeeded (
                /*[in]*/    DWORD dwHandle
                );

    void ProcessInvalidPacketSize(
                                    /*in*/ DWORD dwInfo,
                                    /*in*/ const void* pBuffer,
                                    /*in*/ DWORD address
                                 );


    BSTR pingPattern;
    RegularExpression regexp;

    CPreValidator   *m_pCPreValidator;

    CHashMD5        *m_pCHashMD5;

    CHashHmacMD5    *m_pCHashHmacMD5;

    CDictionary     *m_pCDictionary;

    CClients        *m_pCClients;

    CReportEvent    *m_pCReportEvent;

    //
    //   memory pool for UDP in request
    //
    memory_pool <MAX_PACKET_SIZE, task_allocator> m_InBufferPool;

    //
    // socket sets
    //
    fd_set          m_AuthSet;
    fd_set          m_AcctSet;

    // Used for knocking threads out of select.
    SocketEvent m_AuthEvent;
    SocketEvent m_AcctEvent;
};

#endif //   infndef _PACKETRECEIVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\ports.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class CPorts.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef PORTS_H
#define PORTS_H
#pragma once


// Manages the ports that the RADIUS server accepts requests on.
class CPorts
{
public:
   CPorts() throw ();
   ~CPorts() throw ();

   // Sets the ports configuration.
   HRESULT SetConfig(const wchar_t* config) throw ();

   // Open/close sockets for the configured ports.
   HRESULT OpenSockets() throw ();
   void CloseSockets() throw ();

   void GetSocketSet(fd_set& sockets) const throw ();

   // Close all sockets and reset the configuration.
   void Clear() throw ();

private:
   void InsertPort(DWORD ipAddress, WORD ipPort) throw ();

   struct Port
   {
      DWORD ipAddress;
      WORD ipPort;
      SOCKET socket;
   };

   Port* ports;
   size_t numPorts;
   fd_set  fdSet;

   // Not implemented.
   CPorts(const CPorts&);
   CPorts& operator=(const CPorts&);
};


inline void CPorts::GetSocketSet(fd_set& sockets) const throw ()
{
    sockets = fdSet;
}

#endif //PORTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\ports.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the class CPorts.
//
///////////////////////////////////////////////////////////////////////////////

#include "radcommon.h"
#include "ports.h"
#include "portparser.h"
#include <new>
#include <ws2tcpip.h>

CPorts::CPorts() throw ()
   : ports(0),
     numPorts(0)
{
   FD_ZERO(&fdSet);
}


CPorts::~CPorts() throw ()
{
   Clear();
}


HRESULT CPorts::SetConfig(const wchar_t* config) throw ()
{
   // We can only be configured once.
   if (ports != 0)
   {
      return E_UNEXPECTED;
   }

   size_t maxPorts = CPortParser::CountPorts(config);
   if (maxPorts == 0)
   {
      return E_INVALIDARG;
   }

   ports = new (std::nothrow) Port[maxPorts];
   if (ports == 0)
   {
      return E_OUTOFMEMORY;
   }

   CPortParser parser(config);

   DWORD ipAddress;
   while (parser.GetIPAddress(&ipAddress) == S_OK)
   {
      WORD ipPort;
      while (parser.GetNextPort(&ipPort) == S_OK)
      {
         InsertPort(ipAddress, ipPort);
      }
   }

   return S_OK;
}


HRESULT CPorts::OpenSockets() throw ()
{
   HRESULT result = S_OK;

   for (size_t i = 0; i < numPorts; ++i)
   {
      if (ports[i].socket != INVALID_SOCKET)
      {
         continue;
      }

      SOCKADDR_IN sin;
      sin.sin_family = AF_INET;
      sin.sin_port = htons(ports[i].ipPort);
      sin.sin_addr.s_addr = ports[i].ipAddress;

      SOCKET sock = socket(AF_INET, SOCK_DGRAM, 0);
      if (sock == INVALID_SOCKET)
      {
         int error = WSAGetLastError();
         IASTracePrintf(
            "Create socket failed for %s:%hu; error = %lu",
            inet_ntoa(sin.sin_addr),
            ports[i].ipPort,
            error
            );
         result = HRESULT_FROM_WIN32(error);
         break;
      }
      else
      {
         // Bind the socket for exclusive access to keep other apps from
         // snooping.  
         int optval = 1;
         if (setsockopt(
            sock,
            SOL_SOCKET,
            SO_EXCLUSIVEADDRUSE,
            reinterpret_cast<const char*>(&optval),
            sizeof(optval)
            ) == SOCKET_ERROR)
         {
            int error = WSAGetLastError();
            IASTracePrintf(
            "Set socket option SO_EXCLUSIVEADDRUSE failed for %s:%hu; error = %lu",
            inet_ntoa(sin.sin_addr),
            ports[i].ipPort,
            error
            );
            result = HRESULT_FROM_WIN32(error);
            closesocket(sock);
            break;
         }

         // Block receiving broadcast traffic (for security)
         optval = 0; // FALSE
         if (setsockopt(
            sock,
            IPPROTO_IP,
            IP_RECEIVE_BROADCAST,
            reinterpret_cast<const char*>(&optval),
            sizeof(optval)
            ) == SOCKET_ERROR)
         {
            int error = WSAGetLastError();
            IASTracePrintf(
            "Set IP option IP_RECEIVE_BROADCAST failed for %s:%hu; error = %lu",
            inet_ntoa(sin.sin_addr),
            ports[i].ipPort,
            error
            );
            result = HRESULT_FROM_WIN32(error);
            closesocket(sock);
            break;
         }

         int bindResult = bind(
                         sock,
                         reinterpret_cast<const SOCKADDR*>(&sin),
                         sizeof(SOCKADDR_IN)
                         );
         if (bindResult == SOCKET_ERROR)
         {
            int error = WSAGetLastError();
            IASTracePrintf(
               "Bind failed for %s:%hu; error = %lu",
               inet_ntoa(sin.sin_addr),
               ports[i].ipPort,
               error
               );

            result = HRESULT_FROM_WIN32(error);
            closesocket (sock);
         }
         else
         {
            IASTracePrintf(
               "RADIUS Server starting to listen on %s:%hu",
               inet_ntoa(sin.sin_addr),
               ports[i].ipPort
               );

            ports[i].socket = sock;
            FD_SET(sock, &fdSet);
         }
      }
   }

   return result;
}


void CPorts::CloseSockets() throw ()
{
   for (size_t i = 0; i < numPorts; ++i)
   {
      if (ports[i].socket != INVALID_SOCKET)
      {
         closesocket(ports[i].socket);
         ports[i].socket = INVALID_SOCKET;
      }
   }

   FD_ZERO(&fdSet);
}


void CPorts::Clear() throw ()
{
   CloseSockets();

   delete[] ports;
   ports = 0;

   numPorts = 0;
}


void CPorts::InsertPort(DWORD ipAddress, WORD ipPort) throw ()
{
   for (size_t i = 0; i < numPorts; )
   {
      if (ipPort == ports[i].ipPort)
      {
         if (ipAddress == INADDR_ANY)
         {
            // Remove the existing entry.
            --numPorts;
            ports[i] = ports[numPorts];

            // Don't increment the loop variable because we just put a new port
            // into this array element.
            continue;
         }
         else if ((ipAddress == ports[i].ipAddress) ||
                  (ports[i].ipAddress == INADDR_ANY))
         {
            // The new port is already covered by an existing entry.
            return;
         }
      }

      ++i;
   }

   // Add the port to the array.
   ports[numPorts].ipAddress = ipAddress;
   ports[numPorts].ipPort = ipPort;
   ports[numPorts].socket = INVALID_SOCKET;

   ++numPorts;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\preprocessor.h ===
//#--------------------------------------------------------------
//        
//  File:       preprocessor.h
//        
//  Synopsis:   This file holds the declarations of the 
//				CPreProcessor class
//              
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _PREPROC_H_ 
#define _PREPROC_H_

#include "packetradius.h"
#include "procaccess.h"
#include "procacct.h"
#include "procresponse.h"
#include "hashmd5.h"

class CSendToPipe;

class CPreValidator;

class CPacketSender;

class CReportEvent;

class CPreProcessor  
{
public:

    //
    //  initialize the CPreProcessor class object
    //
    BOOL Init (
            /*[in]*/    CPreValidator *pCPreValidator,
            /*[in]*/    CHashMD5      *pCHashMD5,
            /*[in]*/    CSendToPipe   *pCSendToPipe,
            /*[in]*/    CPacketSender *pCPacketSender,
            /*[in]*/    CReportEvent  *pCReportEvent
            );

    //
    //  start pre-processing of outbound RADIUS packet
    //
	HRESULT StartOutProcessing (
                /*[in]*/    CPacketRadius *pCPacketRadius
                );

    //
    //  start pre-processing of inbound RADIUS packet
    //
	HRESULT StartInProcessing (
                /*[in]*/    CPacketRadius *pCPacketRadius
                );

    //
    // constructor
    //
	CPreProcessor(VOID);

    //
    // destructor
    //
	virtual ~CPreProcessor(VOID);

private:

	CProcAccess         *m_pCProcAccess;

    CProcAccounting     *m_pCProcAccounting; 

    CProcResponse       *m_pCProcResponse;

    CSendToPipe         *m_pCSendToPipe;
};

#endif // ifndef _PREPROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\preprocessor.cpp ===
//#--------------------------------------------------------------
//        
//  File:		preprocessor.cpp
//        
//  Synopsis:   Implementation of CPreProcessor class methods
//              
//
//  History:     9/30/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "preprocessor.h"
#include <new>

//+++-------------------------------------------------------------
//
//  Function:   CPreProcessor
//
//  Synopsis:   This is the constructor of the CPreProcessor class
//
//  Arguments:  NONE
//
//  Returns:    NONE 
//
//
//  History:    MKarki      Created     9/30/97
//
//----------------------------------------------------------------
CPreProcessor::CPreProcessor(
                    VOID
                    )
      : m_pCSendToPipe (NULL),
        m_pCProcResponse (NULL),
        m_pCProcAccounting (NULL),
        m_pCProcAccess (NULL)
{
}	//	end of CPreProcessor constructor

//+++-------------------------------------------------------------
//
//  Function:  ~CPreProcessor
//
//  Synopsis:   This is the destructor of the CPreProcessor class
//
//  Arguments:  NONE
//
//  Returns:    NONE 
//
//
//  History:    MKarki      Created     9/30/97
//
//----------------------------------------------------------------
CPreProcessor::~CPreProcessor(VOID)
{
    if (m_pCProcResponse) {delete (m_pCProcResponse);}
    if (m_pCProcAccounting) {delete (m_pCProcAccounting);}
    if (m_pCProcAccess) { delete (m_pCProcAccess);}

}	//	end of CPreProcessor destructor

//+++-------------------------------------------------------------
//
//  Function:   Init
//
//  Synopsis:   This is the CPreProcessor class initialization method
//
//  Arguments:  
//              [in]    CPreValidator*
//              [in]    CHashMD5*
//              [in]    CSendToPipe*
//              [in]    CPacketSender*
//				none
//
//  Returns:    BOOL	-	status
//
//	Called By:	CCollector class method
//
//  History:    MKarki      Created     9/26/97
//
//----------------------------------------------------------------
BOOL CPreProcessor::Init(
                        CPreValidator   *pCPreValidator,
                        CHashMD5        *pCHashMD5,
                        CSendToPipe     *pCSendToPipe,
                        CPacketSender   *pCPacketSender,
                        CReportEvent    *pCReportEvent
				        )
{
    BOOL    bRetVal = FALSE;
    BOOL    bStatus = FALSE;

    _ASSERT (
            (NULL != pCPreValidator) &&
            (NULL != pCHashMD5)      &&
            (NULL != pCSendToPipe)   &&
            (NULL != pCPacketSender) &&
            (NULL != pCReportEvent) 
            );


    m_pCSendToPipe = pCSendToPipe;

	//
	// Access Request processor
	//
    m_pCProcAccess = new (std::nothrow) CProcAccess ();         
	if (NULL == m_pCProcAccess)
	{
		IASTracePrintf (
			"Unable to crate Access-Processing object in "
            "Pre-Processor initialization"
			);
		goto Cleanup;
	}

    //
    //  initialize the access request processor
    //
	bStatus = m_pCProcAccess->Init (
                                pCPreValidator, 
                                pCHashMD5,
                                pCSendToPipe
                                ); 
    if (FALSE == bStatus) { goto Cleanup; }

	//
	// Accounting Request processor
	//
    m_pCProcAccounting = new (std::nothrow) CProcAccounting ();         
	if (NULL == m_pCProcAccounting)
	{
		IASTracePrintf (
			"Unable to crate Accounting-Processing object in "
            "Pre-Processor initialization"
			);
		goto Cleanup;
	}

    //
    //  initialize the accounting request processor
    //
	bStatus = m_pCProcAccounting->Init (
                                    pCPreValidator, 
                                    pCPacketSender,
                                    pCSendToPipe
                                    ); 
    if (FALSE == bStatus) { goto Cleanup; }

	//
	// Response packet processor
	//
    m_pCProcResponse = new (std::nothrow) CProcResponse ();         
	if (NULL == m_pCProcResponse)
	{
		IASTracePrintf (
			"Unable to crate Response-Processing object in "
            "Pre-Processor initialization"
			);
		goto Cleanup;
	}

    //
    //  initialize the response processor
    //
	bStatus = m_pCProcResponse->Init (
                                    pCPreValidator, 
                                    pCPacketSender
                                    ); 
    if (FALSE == bStatus) { goto Cleanup; }

    //
    //  success
    //
    bRetVal = TRUE;

Cleanup:
   
    if (FALSE == bRetVal)
    {
          if (m_pCProcResponse) {delete (m_pCProcResponse);}
          if (m_pCProcAccounting){delete (m_pCProcAccounting);}
          if (m_pCProcAccess) {delete (m_pCProcAccess);}
    }

    return (bRetVal);

}   //  end of CPreProcessor::Init method

//+++-------------------------------------------------------------
//
//  Function:   StartInProcessing
//
//  Synopsis:   This is the CPreProcessor class method used to 
//				initiate the processing of an inbound RADIUS packet
//
//  Arguments:  [in]	-	CPacketRadius*
//
//  Returns:    HRESULT -	status
//
//  History:    MKarki      Created     9/30/97
//
//	Called By:	CValidator derived class method
//
//----------------------------------------------------------------
HRESULT
CPreProcessor::StartInProcessing (
                CPacketRadius *pCPacketRadius
			    )
{
    HRESULT     hr = S_OK;

    _ASSERT (pCPacketRadius);

    //
	// get the packet type for this RADIUS packet
    //
	PACKETTYPE ePacketType = pCPacketRadius->GetInCode ();
    if (ACCESS_REQUEST == ePacketType)
    {
        //
        //  we still have to get the password out of the packet
        //
	    hr = m_pCProcAccess->ProcessInPacket (pCPacketRadius);
    }
    else
    {
	    //
		//	in all other cases, there is no disassembly to be done
	    //	so call the Service Request Generator
	    //
        hr = m_pCSendToPipe->Process (pCPacketRadius);
	}		

	return (hr);

}	//	end of CPreProcessor::StartInProcessing method

//++--------------------------------------------------------------
//
//  Function:   StartOutProcessing
//
//  Synopsis:   This is the CPreProcessor class method used to 
//				initiate the processing of an outbound RADIUS packet
//
//  Arguments:  [IN]	-	CPacketRadius*
//
//  Returns:    HRESULT -	status
//
//  History:    MKarki      Created     9/26/97
//
//	Called By:	CPacketReceiver class method
//
//----------------------------------------------------------------
HRESULT
CPreProcessor::StartOutProcessing(
						CPacketRadius * pCPacketRadius
						)
{
	PACKETTYPE	ePacketType;	
    HRESULT     hr = S_OK;

	__try
	{
		//
		// get the packet type for this RADIUS packet
		//
	    ePacketType = pCPacketRadius->GetOutCode ();
		switch (ePacketType)
		{
		case ACCESS_REQUEST:
			hr = m_pCProcAccess->ProcessOutPacket (pCPacketRadius);
			break;

        case ACCOUNTING_REQUEST:
			hr = m_pCProcAccounting->ProcessOutPacket (pCPacketRadius);
			break;

        case ACCESS_CHALLENGE:
        case ACCESS_REJECT:
        case ACCESS_ACCEPT:
        case ACCOUNTING_RESPONSE:
            hr = m_pCProcResponse->ProcessOutPacket (pCPacketRadius);
            break;

		default:
			//
			//	in all other cases, there is no disassembly to be done
			//	so call the Service Request Generator
			//
            _ASSERT (0);
            IASTracePrintf (
                "Packet of unknown type:%d found in the pre-processing stage ",
                static_cast <DWORD> (ePacketType)
                );
            hr = E_FAIL;
			break;
		}

		//
		// we have completed the pre-validation successfully
		//
	}		
	__finally
	{
	}

	return (hr);

}	//	end of CPreProcessor::StartOutProcessing method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\procaccess.h ===
//#--------------------------------------------------------------
//        
//  File:       procaccess.h
//        
//  Synopsis:   This file holds the declarations of the 
//				CProcAccess class
//              
//
//  History:     10/20/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _PROCACCESS_H_ 
#define _PROCACCESS_H_

#include "packetradius.h"
#include "hashmd5.h"
#include "sendtopipe.h"

class CPreValidator;

class CProcAccess  
{

public:

    //
    //  initialize the CProcAccess class object
    //
    BOOL Init (
            /*[in]*/ CPreValidator  *pCPreValidator,
            /*[in]*/ CHashMD5       *pCHashMD5,
            /*[in]*/ CSendToPipe       *pCSendToPipe
            );
    //
    //  process out bound RADUS packet
    //
	HRESULT ProcessOutPacket (
                /*[in]*/    CPacketRadius *pCPacketRadius
                );

    //
    //  process in bound RADUS packet
    //
	HRESULT ProcessInPacket (
                /*[in]*/    CPacketRadius *pCPacketRadius
                );

    //
    //  constructor
    //
	CProcAccess();

    //
    //  destructor
    //
	virtual ~CProcAccess();

private:

    CPreValidator   *m_pCPreValidator;

    CHashMD5        *m_pCHashMD5;

    CSendToPipe     *m_pCSendToPipe;

};

#endif // ifndef _PROCACCESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\processor.cpp ===
// processor.cpp: implementation of the CProcessor class.
//
//////////////////////////////////////////////////////////////////////

#include "radcommon.h"
#include "processor.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProcessor::CProcessor()
{

}

CProcessor::~CProcessor()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\procacct.h ===
//#--------------------------------------------------------------
//        
//  File:       procacct.h
//        
//  Synopsis:   This file holds the declarations of the 
//				CProcAcctReq class
//              
//
//  History:     10/20/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _PROCACCT_H_ 
#define _PROCACCT_H_

#include "packetradius.h"
#include "hashmd5.h"
#include "packetsender.h"
#include "sendtopipe.h"

class  CPreValidator;

class CProcAccounting 
{

public:

    //
    //  initialize the CProcAccounting class object
    //
    BOOL Init (
            /*[in]*/    CPreValidator  *pCreValidator,
            /*[in]*/    CPacketSender  *pCPacketSender,
            /*[in]*/    CSendToPipe    *pCSendToPipe
            );
    //
    //  process out bound accounting packet
    //
	HRESULT ProcessOutPacket (
                /*[in]*/    CPacketRadius *pCPacketRadius
                );
    //
    //  constructor
    //
	CProcAccounting();

    //
    //  destructor
    //
	virtual ~CProcAccounting();

private:

    CPreValidator   *m_pCPreValidator;

    CPacketSender   *m_pCPacketSender;

    CSendToPipe     *m_pCSendToPipe;
};

#endif // ifndef _PROCACCT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\processor.h ===
//#--------------------------------------------------------------
//        
//  File:       processor.h
//        
//  Synopsis:   This file holds the declarations of the 
//				CProcessor class
//              
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------

#ifndef _PROCESSOR_H_
#define _PROCESSOR_H_

#include "packetradius.h"

class CProcessor  
{
public:
	virtual BOOL ProcessOutPacket (
                        /*[in]*/    CPacketRadius *pCPacketRadius
                        )=0;
	virtual BOOL ProcessInPacket (
                        /*[in]*/    CPacketRadius *pCPacketRadius
                        )=0;
	CProcessor();

	virtual ~CProcessor();

};

#endif // ifndef _PROCESSOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\prevalidator.cpp ===
//#--------------------------------------------------------------
//        
//  File:		prevalidator.cpp
//        
//  Synopsis:   Implementation of CPreValidator class methods
//              
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "radpkt.h"
#include "prevalidator.h"
#include <new>
//+++-------------------------------------------------------------
//
//  Function:   CPreValidator
//
//  Synopsis:   This is the constructor of the CPreValidator class
//
//  Arguments:  NONE
//
//  Returns:    NONE 
//
//
//  History:    MKarki      Created     9/26/97
//
//----------------------------------------------------------------
CPreValidator::CPreValidator(
					VOID
					)
              : m_pCValAccess (NULL),
                m_pCValAttributes (NULL),
                m_pCValAccounting (NULL),
                m_pCValProxy (NULL) 
{
}	//	end of CPreValidator constructor

//+++-------------------------------------------------------------
//
//  Function:   ~CPreValidator
//
//  Synopsis:   This is the destructor of the CPreValidator class
//
//  Arguments:  NONE
//
//  Returns:    NONE 
//
//
//  History:    MKarki      Created     9/26/97
//
//----------------------------------------------------------------
CPreValidator::~CPreValidator(
						VOID
						)
{
    if (m_pCValProxy) {delete m_pCValProxy;}

	if (m_pCValAttributes) {delete m_pCValAttributes;}

	if (m_pCValAccess) {delete m_pCValAccess;}

	if (m_pCValAccounting) {delete m_pCValAccounting;}

}	//	end of CPreValidator::~CPreValidator

//+++-------------------------------------------------------------
//
//  Function:   Init
//
//  Synopsis:   This is the CPreValidator class initialization method
//
//  Arguments: 
//				[in]	-	CDictionary*
//              [in]    -   CPreProcsssor*
//              [in]    -   CClients*
//              [in]    -   CHashMD5*
//              [in]    -   CSendToPipe*
//                [in]    -   CReportEvent*
//
//  Returns:    BOOL	-	status
//
//	Called By:	CController::OnInit class public method
//
//  History:    MKarki      Created     9/26/97
//
//----------------------------------------------------------------
BOOL CPreValidator::Init(
						CDictionary	    *pCDictionary,
                        CPreProcessor   *pCPreProcessor,
                        CClients        *pCClients,
                        CHashMD5        *pCHashMD5,
                        CSendToPipe     *pCSendToPipe,
                        CReportEvent    *pCReportEvent
						)
{
	BOOL bRetVal = FALSE;
	BOOL bStatus = FALSE;
	
	_ASSERT    (
                (NULL != pCDictionary)  &&
                (NULL != pCPreProcessor)&&
                (NULL != pCClients)     &&
                (NULL != pCHashMD5)     &&
                (NULL != pCSendToPipe)  &&
                (NULL != pCReportEvent)
                );

	//
	// attribute validator
	//
	m_pCValAttributes = new (std::nothrow) CValAttributes();
	if (NULL == m_pCValAttributes)
	{
        IASTracePrintf (
            "Memory allocation for Attribute Validator failed during "
            "Pre-Validation"
            );
		goto Cleanup;
	}

	//
	// initalize the attribute validator class object
	//
	bStatus = m_pCValAttributes->Init (pCDictionary, pCReportEvent);
	if (FALSE == bStatus)
	{
        IASTracePrintf ("Attribute Validator Initialization failed");
		goto Cleanup;
	}

	//
	// Accounting Request validator 
	//
	m_pCValAccounting = new (std::nothrow) CValAccounting ();
	if (NULL == m_pCValAccounting)
	{
        IASTracePrintf (
            "Memory allocation for accounting validator failed "
            "during pre-validation"
            );
		goto Cleanup;
	}

	bStatus = m_pCValAccounting->Init (
						m_pCValAttributes,
						pCPreProcessor,
                        pCClients,
                        pCHashMD5,
                        pCReportEvent
						);
	if (FALSE == bStatus)
	{
        IASTracePrintf ("Accounting Validator Initialization failed");
		goto Cleanup;
	}

	//
	// Access Request validator 
	//
	m_pCValAccess = new (std::nothrow) CValAccess();
	if (NULL == m_pCValAccess)
	{
        IASTracePrintf (
            "Memory allocation for access validator failed "
            "during pre-validation"
            );
		goto Cleanup;
	}

	bStatus = m_pCValAccess->Init (
					m_pCValAttributes,
				    pCPreProcessor,
                    pCClients,
					pCHashMD5,
                    pCReportEvent
					);
	if (FALSE == bStatus)
	{
        IASTracePrintf ("Accounting Validator Initialization failed");
		goto Cleanup;
	}

	//
	// Proxy Packet validator 
	//
	m_pCValProxy = new (std::nothrow) CValProxy ();
	if (NULL == m_pCValAttributes)
	{
        IASTracePrintf (
            "Memory allocation for proxy alidator failed "
            "during pre-validation"
            );
		goto Cleanup;
	}

    //
    //  initialize the CValProxy class object    
    //
	bStatus = m_pCValProxy->Init (
				m_pCValAttributes,
				pCPreProcessor,
                pCClients,
                pCHashMD5,
                pCSendToPipe,
                pCReportEvent
				);
	if (FALSE == bStatus)
	{
        IASTracePrintf ("Proxy Validator Initialization failed");
		goto Cleanup;
	}

    //
    //  success
    //
    bRetVal = TRUE;

Cleanup:

    if (FALSE == bRetVal)
    {
        if (m_pCValProxy) {delete m_pCValProxy;}

	    if (m_pCValAttributes) {delete m_pCValAttributes;}

	    if (m_pCValAccess) {delete m_pCValAccess;}

	    if (m_pCValAccounting) {delete m_pCValAccounting;}
    }

	return (bRetVal);

}	//	end of CPreValidator::Init method

//+++-------------------------------------------------------------
//
//  Function:   StartInValidation
//
//  Synopsis:   This is the CPreValidator class method used to 
//				initiate the validation of an inbound RADIUS packet
//
//  Arguments:  [in]	-	CPacketRadius*
//
//  Returns:    HRESULT -	status
//
//  History:    MKarki      Created     9/26/97
//
//	Called By:	CPacketReceiver::ReceivePacket class private method
//
//----------------------------------------------------------------
HRESULT  
CPreValidator::StartInValidation(
					CPacketRadius * pCPacketRadius
					)
{
    HRESULT     hr = S_OK;
	PACKETTYPE	ePacketType;	

    _ASSERT (NULL != pCPacketRadius);

	__try
	{
		//
		// get the packet type for this RADIUS packet
		//
		ePacketType = pCPacketRadius->GetInCode ();

        //
        //  call the appropriate validator depending upon the packet
        //  type
        //
		switch (ePacketType)
		{
		case ACCESS_REQUEST:
            
			hr = m_pCValAccess->ValidateInPacket (pCPacketRadius);
            break;
		
		case ACCOUNTING_REQUEST:
			hr = m_pCValAccounting->ValidateInPacket (pCPacketRadius);
            break;

        case ACCESS_REJECT:
        case ACCESS_CHALLENGE:
        case ACCESS_ACCEPT:
        case ACCOUNTING_RESPONSE:
			hr = m_pCValProxy->ValidateInPacket (pCPacketRadius);
			break;

		default:
            //
            //  should never reach here
            //
            _ASSERT (0);
            IASTracePrintf (
                "Packet of Unknown Type:%d, in pre-validator",
                static_cast <DWORD> (ePacketType)
                );
            hr = E_FAIL;
			break;
		}

	}		
	__finally
	{
	}

	return (hr);

}	//	end of CPreValidator::StartInValidation method

//+++-------------------------------------------------------------
//
//  Function:   StartOutValidation
//
//  Synopsis:   This is the CPreValidator class method used to 
//				initiate the validation of an outbound RADIUS packet
//
//  Arguments:  
//              [in]    CPacketRadius*
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     9/26/97
//
//	Called By:	
//
//----------------------------------------------------------------
HRESULT
CPreValidator::StartOutValidation(
	    CPacketRadius * pCPacketRadius
	)
{
	HRESULT  hr = S_OK;

	__try
	{
		
        /*
		bStatus = pCValidator->ValidateOutPacket (pCPacketRadius);
		if (FALSE == bStatus) { __leave; }
        */

		//
		// we have completeted the pre-validation successfully
		//
	}		
	__finally
	{
		//
		//	nothing here for now
		//
	}

	return (hr);

}	//	end of CPreValidator::StartOutValidation method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\procaccess.cpp ===
//#--------------------------------------------------------------
//
//  File:      procaccess.cpp
//
//  Synopsis:   Implementation of CProcAccess class methods
//
//
//  History:     10/20/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "procaccess.h"

//+++-------------------------------------------------------------
//
//  Function:   CProcAccess
//
//  Synopsis:   This is CProcAccess class constructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     10/20/97
//
//----------------------------------------------------------------
CProcAccess::CProcAccess()
      : m_pCPreValidator (NULL),
        m_pCHashMD5 (NULL),
        m_pCSendToPipe (NULL)
{
}   //  end of CProcAccess class constructor

//+++-------------------------------------------------------------
//
//  Function:   CProcAccess
//
//  Synopsis:   This is CProcAccess class destructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     10/20/97
//
//----------------------------------------------------------------
CProcAccess::~CProcAccess()
{
}   //  end of CProcAccess class destructor


//+++-------------------------------------------------------------
//
//  Function:   Init
//
//  Synopsis:   This is CProcAccess class public initialization
//              method
//
//  Arguments:  NONE
//
//  Returns:    status
//
//
//  History:    MKarki      Created     10/20/97
//
//----------------------------------------------------------------
BOOL
CProcAccess::Init(
                    CPreValidator   *pCPreValidator,
                    CHashMD5        *pCHashMD5,
                    CSendToPipe     *pCSendToPipe
                  )
{
     _ASSERT  ((NULL != pCPreValidator) &&
               (NULL != pCHashMD5)      &&
               (NULL != pCSendToPipe)
               );


     m_pCPreValidator = pCPreValidator;

     m_pCHashMD5 = pCHashMD5;

     m_pCSendToPipe = pCSendToPipe;

     return (TRUE);

}   //   end of CProcAccess::Init method

//+++-------------------------------------------------------------
//
//  Function:   ProcessInPacket
//
//  Synopsis:   This is CProcAccess class public method
//              which carries out the processing of an inbound
//              RADIUS packet - for now it just decrypts the
//              password
//
//  Arguments:
//              [in]        CPacketRadius*
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     10/20/97
//
//  Called By:  CPreProcessor::StartProcessing public method
//
//----------------------------------------------------------------
HRESULT
CProcAccess::ProcessInPacket (
                  CPacketRadius *pCPacketRadius
                  )
{
   // If the User-Password is present, ...
   PIASATTRIBUTE pwd = pCPacketRadius->GetUserPassword();
   if (pwd)
   {
      // ... then decrypt it.
      pCPacketRadius->cryptBuffer(
                          FALSE,
                          FALSE,
                          pwd->Value.OctetString.lpValue,
                          pwd->Value.OctetString.dwLength
                          );
   }

   return m_pCSendToPipe->Process (pCPacketRadius);
}

//++--------------------------------------------------------------
//
//  Function:   ProcessOutPacket
//
//  Synopsis:   This is CProcAccess class public method
//              which carries out the processing of an outbound
//              RADIUS packet - for now it just encrypts the
//              password
//
//
//  Arguments:
//              [in]        CPacketRadius*
//
//  Returns:    HRESULT - status
//
//
//  History:    MKarki      Created     10/20/97
//
//  Called By:
//
//----------------------------------------------------------------
HRESULT
CProcAccess::ProcessOutPacket (
                  CPacketRadius *pCPacketRadius
                  )
{
   return (S_OK);
}   //   end of CProcAccess::ProcessOutPacket method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\prevalidator.h ===
//#--------------------------------------------------------------
//        
//  File:       prevalidator.h
//        
//  Synopsis:   This file holds the declarations of the 
//				CPreValidator class
//              
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _PREVALIDATOR_H_
#define	_PREVALIDATOR_H_

#include "packetradius.h"
#include "dictionary.h"
#include "valattrib.h"
#include "hashmd5.h"
#include "preprocessor.h"
#include "reportevent.h"
#include "clients.h"
#include "valaccess.h"
#include "valacct.h"
#include "valproxy.h"
#include "sendtopipe.h"


class CPreValidator  
{

public:

    //
    //  initialize the CPreValidator class object
    //
	BOOL Init (
            /*[in]*/    CDictionary     *pCDictionary, 
            /*[in]*/    CPreProcessor   *pCPreProcessor,
            /*[in]*/    CClients        *pCClients,
            /*[in]*/    CHashMD5        *pCHashMD5,
            /*[in]*/    CSendToPipe     *pCSendToPipe,
            /*[in]*/    CReportEvent    *pCReportEvent
            );
    //
    //  start the validation of the outbound packet
    //
	HRESULT StartOutValidation (
            /*[in]*/    CPacketRadius *pCPacketRadius
            );
    
    //
    //  start the validation of the inbound packet
    //
	HRESULT StartInValidation (
            /*[in]*/    CPacketRadius *pCPacketRadius
            );

    //
    //  constructor
    //
	CPreValidator(VOID);

    //
    //  destructor
    //
	virtual ~CPreValidator(VOID);

private:

	CValAccounting			*m_pCValAccounting;

    CValProxy		        *m_pCValProxy;

	CValAccess				*m_pCValAccess;

	CValAttributes			*m_pCValAttributes;
};

#endif // ifndef _PREVALIDATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\procacct.cpp ===
//#--------------------------------------------------------------
//
//  File:      procacct.cpp
//
//  Synopsis:   Implementation of CProcAccounting class methods
//
//
//  History:     10/20/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "procacct.h"

//++--------------------------------------------------------------
//
//  Function:   CProcAccounting
//
//  Synopsis:   This is CProcAccounting class constructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     10/20/97
//
//----------------------------------------------------------------
CProcAccounting::CProcAccounting()
      : m_pCPreValidator (NULL),
        m_pCPacketSender (NULL),
        m_pCSendToPipe (NULL)
{
}   //  end of CProcAccounting class constructor

//++--------------------------------------------------------------
//
//  Function:   CProcAccounting
//
//  Synopsis:   This is CProcAccounting class destructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     10/20/97
//
//----------------------------------------------------------------
CProcAccounting::~CProcAccounting()
{
}   //  end of CProcAccounting class destructor

//++--------------------------------------------------------------
//
//  Function:   Init
//
//  Synopsis:   This is CProcAccounting class public
//              initialization method
//
//  Arguments:  NONE
//
//  Returns:    status
//
//
//  History:    MKarki      Created     10/20/97
//
//----------------------------------------------------------------
BOOL
CProcAccounting::Init(
                    CPreValidator   *pCPreValidator,
                    CPacketSender   *pCPacketSender,
                    CSendToPipe     *pCSendToPipe
                  )
{
    _ASSERT ((NULL != pCPreValidator) ||
             (NULL != pCPacketSender) ||
             (NULL != pCSendToPipe)
            );

    m_pCPreValidator = pCPreValidator;

    m_pCPacketSender = pCPacketSender;

    m_pCSendToPipe = pCSendToPipe;

   return (TRUE);

}   //   end of CProcAccounting::Init method

//++--------------------------------------------------------------
//
//  Function:   ProcessOutPacket
//
//  Synopsis:   This is CProcAccounting class public method
//              which carries out the processing of an outbound
//              RADIUS accounting packet
//
//
//  Arguments:
//              [in]        CPacketRadius*
//
//  Returns:    HRESULT - status
//
//
//  History:    MKarki      Created     10/20/97
//
//  Called By:
//
//----------------------------------------------------------------
HRESULT
CProcAccounting::ProcessOutPacket (
                  CPacketRadius *pCPacketRadius
                  )
{
    return (S_OK);
}   //   end of CProcAccounting::ProcessOutPacket method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\radcommon.cpp ===
#include "radcommon.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\proxyinfo.h ===
//#--------------------------------------------------------------
//        
//  File:       proxyinfo.h
//        
//  Synopsis:   This file holds the declarations of the 
//				proxyinfo class
//              
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------

#ifndef _PROXYINFO_H_
#define _PROXYINFO_H_

#include "radpkt.h"


class CProxyInfo  
{
public:

	CProxyInfo();

	virtual ~CProxyInfo();

	BOOL Init (
        PBYTE   pbyClientAuthenticator,
        PBYTE   pbyProxyAuthentciator,
        DWORD   dwClientIPAddress,
        WORD    wClientPort
        );
	BOOL GetProxyReqAuthenticator (
                PBYTE   pbyProxyReqAuthenticator
				);

private:

    BYTE    m_ProxyReqAuthenticator[AUTHENTICATOR_SIZE];

    BYTE    m_ClientReqAuthenticator[AUTHENTICATOR_SIZE];

    DWORD   m_dwClientIPAddress;

    WORD    m_wClientPort;


};

#endif // ifndef _PROXYINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\procresponse.h ===
//#--------------------------------------------------------------
//        
//  File:       procresponse.h
//        
//  Synopsis:   This file holds the declarations of the 
//				CProcAcctReq class
//              
//
//  History:     10/20/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _PROCRESPONSE_H_
#define _PROCRESPONSE_H_

#include "packetradius.h"
#include "packetsender.h"
#include "hashmd5.h"

class CPreValidator;

class CProcResponse  
{

public:

    //
    //  initializes the CProcResponse class object
    //
    BOOL Init (
            /*[in]*/    CPreValidator   *pPreValidator,
            /*[in]*/    CPacketSender   *pCPacketSender
            );
    //
    //  process out bound RADIUS response packet
    //
	HRESULT ProcessOutPacket (
            /*[in]*/    CPacketRadius *pCPacketRadius
            );
    //
    //  constructor
    //
	CProcResponse();

    //
    //  destructor
    //
	virtual ~CProcResponse();

private:

    CPreValidator   *m_pCPreValidator;

    CPacketSender   *m_pCPacketSender;
};

#endif // ifndef _PROCREPSONSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\radcommon.h ===
//#--------------------------------------------------------------
//        
//  File:       radcommon.h
//        
//  Synopsis:   This file holds the global declarations for the
//              EAS RADIUS protocol component
//              
//
//  History:     11/13/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _RADCOMMON_H_
#define _RADCOMMON_H_

#include <ias.h>
#include <iasevent.h>
#include <iaspolcy.h>
#include <iastransport.h>
#include <iasattr.h>
#include <iasdefs.h>
#include <sdoias.h>
#include "winsock2.h"

//
//default UDP Ports to be used
//
#define IAS_DEFAULT_AUTH_PORT   1812
#define IAS_DEFAULT_ACCT_PORT   1813

//
// these are the port types
//
typedef enum _porttype_
{
    AUTH_PORTTYPE = 1,
    ACCT_PORTTYPE
}
PORTTYPE, *PPORTTYPE;

//
// this is the length of the eror string
//
#define IAS_ERROR_STRING_LENGTH 255

#define IASRADAPI __declspec(dllexport)

#endif // ifndef _RADCOMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\procresponse.cpp ===
//#--------------------------------------------------------------
//
//  File:      procresponse.cpp
//
//  Synopsis:   Implementation of CProcResponse class methods
//
//
//  History:     10/20/97  MKarki Created
//
//    Copyright (C)  Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "procresponse.h"

//++--------------------------------------------------------------
//
//  Function:   CProcResponse
//
//  Synopsis:   This is CProcResponse class constructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//  History:    MKarki      Created     10/20/97
//
//----------------------------------------------------------------
CProcResponse::CProcResponse()
              : m_pCPreValidator (NULL),
                m_pCPacketSender (NULL)
{
}   //  end of CProcResponse class constructor

//++--------------------------------------------------------------
//
//  Function:   CProcResponse
//
//  Synopsis:   This is CProcResponse class destructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     10/20/97
//
//----------------------------------------------------------------
CProcResponse::~CProcResponse()
{
}   //  end of CProcResponse class destructor


//++--------------------------------------------------------------
//
//  Function:   Init
//
//  Synopsis:   This is CProcResponse class public
//              initialization method
//
//  Arguments:  NONE
//
//  Returns:    status
//
//  History:    MKarki      Created     10/20/97
//
//----------------------------------------------------------------
BOOL
CProcResponse::Init(
                    CPreValidator   *pCPreValidator,
                    CPacketSender   *pCPacketSender
                  )
{

    _ASSERT (pCPreValidator && pCPacketSender);

    m_pCPreValidator = pCPreValidator;

    m_pCPacketSender = pCPacketSender;

   return (TRUE);

}  // end of CProcResponse::Init method

//++--------------------------------------------------------------
//
//  Function:   ProcessOutPacket
//
//  Synopsis:   This is CProcResponse class public method
//              which carries out the following RADIUS outbound
//              packet types:
//
//              ACCESS REJECT
//              ACCESS CHALLENGE
//              ACCESS ACCEPT
//              ACCOUNTING RESPONSE
//
//
//  Arguments:
//              [in]        CPacketRadius*
//
//  Returns:    HRESULT - status
//
//
//  History:    MKarki      Created     10/20/97
//
//  Called By:  CPreProcessor::StartOutProcessing method
//
//----------------------------------------------------------------
HRESULT
CProcResponse::ProcessOutPacket (
                  CPacketRadius *pCPacketRadius
                  )
{
    BOOL    bStatus = FALSE;
    HRESULT hr = S_OK;
    BYTE    RequestAuthenticator[AUTHENTICATOR_SIZE];
    BYTE    ResponseAuthenticator[AUTHENTICATOR_SIZE];

    __try
    {
        if (pCPacketRadius->IsOutSignaturePresent ())
        {
            //
            // generate the signature value
            //
            BYTE    SignatureValue[SIGNATURE_SIZE];
            DWORD   dwSigSize = SIGNATURE_SIZE;
            hr = pCPacketRadius->GenerateOutSignature  (
                                        SignatureValue,
                                        &dwSigSize
                                        );
            if (FAILED (hr)) { __leave; }

            //
            // set the signature value in attribute already set up
            // in the out-bound RADIUS packet
            //
            hr = pCPacketRadius->SetOutSignature (SignatureValue);
            if (FAILED (hr)) {__leave; }

            IASTracePrintf ("Message Authenticator Attribute set in out UDP buffer");
        }

        //  generate the response authenticator here
        //  not specifying an argument means
        //  use the value from the request authenticatior
        //
        bStatus = pCPacketRadius->GenerateOutAuthenticator ();
        if (FALSE == bStatus)
        {
            hr = E_FAIL;
            __leave;
        }

        //
        //  TODO - if validation is required call the validator
        //  else  send the packet on its way
        //
        hr = m_pCPacketSender->SendPacket (pCPacketRadius);
        if (FALSE == bStatus) { __leave; }

    }
    __finally
    {
    }

    return (hr);

}  // end of CProcResponse::ProcessOutPacket method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\proxyinfo.cpp ===
//#--------------------------------------------------------------
//        
//  File:		proxyinfo.cpp
//        
//  Synopsis:   Implementation of CProxyInfo class methods
//              
//
//  History:     10/2/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "proxyinfo.h"

//++--------------------------------------------------------------
//
//  Function:   CProxyInfo
//
//  Synopsis:   This is CProxyInfo class constructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     10/2/97
//
//----------------------------------------------------------------

CProxyInfo::CProxyInfo()
{
    ZeroMemory (m_ProxyReqAuthenticator, AUTHENTICATOR_SIZE);
    ZeroMemory (m_ClientReqAuthenticator, AUTHENTICATOR_SIZE);
    m_dwClientIPAddress = 0;
    m_wClientPort = 0;

}   //  end of CProxyInfo constructor

CProxyInfo::~CProxyInfo()
{

}

BOOL 
CProxyInfo::Init (
        PBYTE   pbyClientAuthenticator,
        PBYTE   pbyProxyAuthenticator,
        DWORD   dwClientIPAddress,
        WORD    wClientPort
        )
{
    BOOL    bRetVal = FALSE;

    __try
    {
        if ((NULL == pbyClientAuthenticator) ||
            (NULL == pbyProxyAuthenticator)
            )
            __leave;

        CopyMemory (
                m_ClientReqAuthenticator, 
                pbyClientAuthenticator, 
                AUTHENTICATOR_SIZE
                );
        CopyMemory (
                m_ProxyReqAuthenticator, 
                pbyProxyAuthenticator,
                AUTHENTICATOR_SIZE
                );

        m_dwClientIPAddress = dwClientIPAddress;

        m_wClientPort = wClientPort;

        bRetVal = TRUE;
    }
    __finally
    {
        //
        //  nothing here for now
        //
    }

    return (bRetVal);

}   //  end of SetProxyReqAuthenticator::method

//++--------------------------------------------------------------
//
//  Function:    GetProxyReqAuthenticator
//
//  Synopsis:   This is the CProxyInfo class public method
//              used to 
//
//  Arguments:  
//
//  Returns:    BOOL    status
//
//
//  History:    MKarki      Created     10/22/97
//
//  Called By:  
//
//----------------------------------------------------------------
BOOL
CProxyInfo::GetProxyReqAuthenticator (
                PBYTE   pbyProxyReqAuthenticator
				)
{
    BOOL    bRetVal = FALSE;

    __try
    {
        if (NULL == pbyProxyReqAuthenticator)
            __leave;

        CopyMemory (
                pbyProxyReqAuthenticator,
                m_ProxyReqAuthenticator, 
                AUTHENTICATOR_SIZE
                );
        
        //
        //  success
        //
        bRetVal = TRUE;
    }
    __finally
    {
        //
        //  nothing here for now
        //
    }

    return (bRetVal);

}   //  end of CProxyInfo::GetProxyReqAuthenticator method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\radpkt.h ===
//#--------------------------------------------------------------
//        
//  File:       radpkt.h
//        
//  Synopsis:   This file holds the declarations for the
//              RADIUS protocol specific structs and macros
//              
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _RADPKT_H_
#define _RADPKT_H_


//
// here are the values for the RADIUS packet codes
//
typedef enum _packettype_
{
	ACCESS_REQUEST = 1,
	ACCESS_ACCEPT = 2,
	ACCESS_REJECT = 3,
	ACCOUNTING_REQUEST = 4,
	ACCOUNTING_RESPONSE = 5,
	ACCESS_CHALLENGE = 11

}	PACKETTYPE, *PPACKETTYPE;

//
//  RADIUS attribute types
//
#define PROXY_STATE_ATTRIB          33
#define USER_NAME_ATTRIB             1 
#define USER_PASSWORD_ATTRIB         2 
#define CHAP_PASSWORD_ATTRIB         3
#define NAS_IP_ADDRESS_ATTRIB        4
#define CLASS_ATTRIB                25 
#define NAS_IDENTIFIER_ATTRIB       32
#define ACCT_STATUS_TYPE_ATTRIB     40
#define ACCT_SESSION_ID_ATTRIB      44
#define TUNNEL_PASSWORD_ATTRIB      69 
#define EAP_MESSAGE_ATTRIB          79
#define SIGNATURE_ATTRIB            80


//
// these are the largest values that the attribute type 
// packet type have  
//

#define MAX_ATTRIBUTE_TYPE   255
#define MAX_PACKET_TYPE       11


//
// number of IAS attribute created by the 
// RADIUS protocol component 
// 1) IAS_ATTRIBUTE_CLIENT_IP_ADDRESS
// 2) IAS_ATTRIBUTE_CLIENT_UDP_PORT
// 3) IAS_ATTRIBUTE_CLIENT_PACKET_HEADER
// 4) IAS_ATTRIBUTE_SHARED_SECRET
// 5) IAS_ATTRIBUTE_CLIENT_VENDOR_TYPE
// 6) IAS_ATTRIBUTE_CLIENT_NAME
//
#define COMPONENT_SPECIFIC_ATTRIBUTE_COUNT 6

//
// these are the related constants
//
#define MIN_PACKET_SIZE         20
#define MAX_PACKET_SIZE         4096
#define AUTHENTICATOR_SIZE      16
#define SIGNATURE_SIZE          16
#define MAX_PASSWORD_SIZE       253
#define MAX_ATTRIBUTE_LENGTH    253
#define MAX_VSA_ATTRIBUTE_LENGTH 247

//
// using BYTE alignment here
//
#pragma pack(push,1)
	//
	// here we define an ATTRIBUTE type
	// used to access the attribute fields of the RAIDUS packet
	//
typedef	struct _attribute_
{
	BYTE	byType;
	BYTE	byLength;
	BYTE	ValueStart[1];

} ATTRIBUTE, *PATTRIBUTE; 

//
// we define the RADIUSPACKET struct
// for simpler access to the RADIUS packet
//
typedef struct _radiuspacket_
{
	BYTE		byCode;
	BYTE		byIdentifier;
	WORD		wLength;
	BYTE		Authenticator[AUTHENTICATOR_SIZE];
	BYTE		AttributeStart[1];

} RADIUSPACKET, *PRADIUSPACKET;


#pragma pack (pop)

#define ATTRIBUTE_HEADER_SIZE 2     //byType + byLength

#define PACKET_HEADER_SIZE  20 // byCode+byIdentifier+wLength+Authenticator

#endif //  ifndef _RADPKT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\radutil.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    radutil.cpp
//
// SYNOPSIS
//
//    This file defines methods for converting attributes to and from
//    RADIUS wire format.
//
///////////////////////////////////////////////////////////////////////////////

#include <radcommon.h>
#include <iasutil.h>
#include <iastlutl.h>

#include <radutil.h>

//////////
// The offset between the UNIX and NT epochs.
//////////
const DWORDLONG UNIX_EPOCH = 116444736000000000ui64;

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    RadiusUtil::decode
//
// DESCRIPTION
//
//    Decodes an octet string into a newly-allocated IAS Attribute of the
//    specified type.
//
///////////////////////////////////////////////////////////////////////////////
PIASATTRIBUTE RadiusUtil::decode(
                              IASTYPE dstType,
                              PBYTE src,
                              ULONG srclen
                              )
{
   // Allocate an attribute to hold the decoded value.
   IASTL::IASAttribute dst(true);

   // Switch based on the destination type.
   switch (dstType)
   {
      case IASTYPE_BOOLEAN:
      {
         if (srclen != 4) { _com_issue_error(E_INVALIDARG); }
         dst->Value.Boolean = IASExtractDWORD(src) ? TRUE : FALSE;
         break;
      }

      case IASTYPE_INTEGER:
      case IASTYPE_ENUM:
      case IASTYPE_INET_ADDR:
      {
         if (srclen != 4) { _com_issue_error(E_INVALIDARG); }
         dst->Value.Integer = IASExtractDWORD(src);
         break;
      }

      case IASTYPE_UTC_TIME:
      {
         if (srclen != 4) { _com_issue_error(E_INVALIDARG); }

         DWORDLONG val;

         // Extract the UNIX time.
         val = IASExtractDWORD(src);

         // Convert from seconds to 100 nsec intervals.
         val *= 10000000;

         // Shift to the NT epoch.
         val += 116444736000000000ui64;

         // Split into the high and low DWORDs.
         dst->Value.UTCTime.dwLowDateTime = (DWORD)val;
         dst->Value.UTCTime.dwHighDateTime = (DWORD)(val >> 32);

         break;
      }

      case IASTYPE_STRING:
      {
         dst.setString(srclen, src);
         break;
      }

      case IASTYPE_OCTET_STRING:
      case IASTYPE_PROV_SPECIFIC:
      {
         dst.setOctetString(srclen, src);
         break;
      }
   }

   // All went well, so set type attribute type  ...
   dst->Value.itType = dstType;

   // ... and return.
   return dst.detach();
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    RadiusUtil::getEncodedSize
//
// DESCRIPTION
//
//    Returns the size in bytes of the IASATTRIBUTE when converted to RADIUS
//    wire format.  This does NOT include the attribute header.
//
///////////////////////////////////////////////////////////////////////////////
ULONG RadiusUtil::getEncodedSize(
                      const IASATTRIBUTE& src
                      )
{
   switch (src.Value.itType)
   {
      case IASTYPE_BOOLEAN:
      case IASTYPE_INTEGER:
      case IASTYPE_ENUM:
      case IASTYPE_INET_ADDR:
      case IASTYPE_UTC_TIME:
      {
         return 4;
      }

      case IASTYPE_STRING:
      {
         // Convert the string to ANSI so we can count octets.
         DWORD dwErr = IASAttributeAnsiAlloc(const_cast<PIASATTRIBUTE>(&src));
         if (dwErr != NO_ERROR)
         {
            // functions calling this are exception based
            _com_issue_error(HRESULT_FROM_WIN32(dwErr));
         }

         // Allow for NULL strings and don't count the terminator.
         return src.Value.String.pszAnsi ? strlen(src.Value.String.pszAnsi)
                                         : 0;
      }

      case IASTYPE_OCTET_STRING:
      case IASTYPE_PROV_SPECIFIC:
      {
         return src.Value.OctetString.dwLength;
      }
   }

   // All other types have no wire representation.
   return 0;
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    RadiusUtil::encode
//
// DESCRIPTION
//
//    Encodes the IASATTRIBUTE into RADIUS wire format and copies the value
//    to the buffer pointed to by 'dst'. The caller should ensure that the
//    destination buffer is large enough by first calling getEncodedSize.
//    This method only encodes the attribute value, not the header.
//
///////////////////////////////////////////////////////////////////////////////
void RadiusUtil::encode(
                     PBYTE dst,
                     const IASATTRIBUTE& src
                     ) throw ()
{
   // Switch based on the source's type.
   switch (src.Value.itType)
   {
      case IASTYPE_BOOLEAN:
      {
         IASInsertDWORD(dst, (src.Value.Boolean ? 1 : 0));
         break;
      }

      case IASTYPE_INTEGER:
      case IASTYPE_ENUM:
      case IASTYPE_INET_ADDR:
      {
         IASInsertDWORD(dst, src.Value.Integer);
         break;
      }

      case IASTYPE_UTC_TIME:
      {
         DWORDLONG val;

         // Move in the high DWORD.
         val   = src.Value.UTCTime.dwHighDateTime;
         val <<= 32;

         // Move in the low DWORD.
         val  |= src.Value.UTCTime.dwLowDateTime;

         // Convert to the UNIX epoch.
         val  -= UNIX_EPOCH;

         // Convert to seconds.
         val  /= 10000000;

         IASInsertDWORD(dst, (DWORD)val);

         break;
      }

      case IASTYPE_STRING:
      {
         const BYTE* p = (const BYTE*)src.Value.String.pszAnsi;

         // Don't use strcpy since we don't want the null terminator.
         if (p) while (*p) *dst++ = *p++;

         break;
      }

      case IASTYPE_OCTET_STRING:
      case IASTYPE_PROV_SPECIFIC:
      {
         memcpy(dst,
                src.Value.OctetString.lpValue,
                src.Value.OctetString.dwLength);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\radutil.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    radutil.h
//
// SYNOPSIS
//
//    This file declares methods for converting attributes to and from
//    RADIUS wire format.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _RADUTIL_H_
#define _RADUTIL_H_
#if _MSC_VER >= 1000
#pragma once
#endif

namespace RadiusUtil
{
   ////////// 
   // Decodes an octet string into a newly-allocated IAS Attribute of the
   // specified type.
   ////////// 
   PIASATTRIBUTE decode(
                     IASTYPE dstType,
                     PBYTE src,
                     ULONG srclen
                     );

   ////////// 
   // Returns the size in bytes of the IASATTRIBUTE when converted to RADIUS
   // wire format.  This does NOT include the attribute header.
   ////////// 
   ULONG getEncodedSize(
             const IASATTRIBUTE& src
             ); 

   ////////// 
   // Encodes the IASATTRIBUTE into RADIUS wire format and copies the value
   // to the buffer pointed to by 'dst'. The caller should ensure that the
   // destination buffer is large enough by first calling getEncodedSize.
   // This method only encodes the attribute value, not the header.
   ////////// 
   void encode(
            PBYTE dst,
            const IASATTRIBUTE& src
            ) throw ();
};

#endif  // _RADUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\resource.h ===
#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#define IDS_RadiusProtocol                      101
#define IDR_RadiusProtocol                      102
#define IDS_CClient                             103
#define IDR_CClient                             104

#endif // ifndef _RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\recvfrompipe.h ===
//#--------------------------------------------------------------
//        
//  File:       recvfrompipe
//        
//  Synopsis:   This file holds the declarations of the 
//				CRecvFromPipe class
//              
//
//  History:     10/22/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _RECVFROMPIPE_H_
#define _RECVFROMPIPE_H_
 
#include "vsafilter.h"
#include "packetradius.h"
#include "clients.h"
#include "tunnelpassword.h"
#include "reportevent.h"


class CPreProcessor;

class CRecvFromPipe  
{

public:
	
    //
    //  processess the outbound RADIUS packet received from the
    //  pipeline
    //
    HRESULT Process (
                /*[in]*/     IRequest    *pIRequest
                );
    //
    //  constructor
    //
	CRecvFromPipe(
			/*[in]*/	CPreProcessor	*pCPreProcessor,
			/*[in]*/	CHashMD5        *pCHashMD5,
			/*[in]*/	CHashHmacMD5    *pCHashHmacMD5,
            /*[in]*/    CClients        *pCClients,
            /*[in]*/    VSAFilter       *pCVSAFilter,
            /*[in]*/    CTunnelPassword *pCTunnelPassword,
            /*[in]*/    CReportEvent    *pCReportEvent
            );

    //
    //  destructor
    //
	virtual ~CRecvFromPipe();

private:

    HRESULT GeneratePacketRadius (
            /*[out]*/   CPacketRadius   **ppCPacketRadius,
            /*[in]*/    IAttributesRaw  *pIAttributesRaw
            );

    HRESULT GetOutPacketInfo (
                /*[out]*/   PDWORD          pdwIPAddress,
                /*[out]*/   PWORD           pwPort,
                /*[out]*/   IIasClient      **ppClient,
                /*[out]*/   PBYTE           pPacketHeader,
                /*[in]*/    IAttributesRaw  *pIAttributesRaw
                );

    HRESULT InjectSignatureIfNeeded (
                    /*[in]*/    PACKETTYPE      ePacketType,
                    /*[in]*/    IAttributesRaw  *pIAttributesRaw,
                    /*[in]*/    CPacketRadius   *pCPacketRadius
                    );

    //
    //  converts the IAS response code to RADIUS packet type
    //
    HRESULT ConvertResponseToRadiusCode (
                LONG     	iasResponse,
                PPACKETTYPE     pPacketType,
                CPacketRadius   *pCPacketRadius
                );
    //
    // split the specific attribute into multiple ones that
    // can fit in a packet
    //
    HRESULT SplitAndAdd (
                /*[in]*/    IAttributesRaw  *pIAttributesRaw,
                /*[in]*/    PIASATTRIBUTE   pIasAttribute,
                /*[in]*/    IASTYPE         iasType,
                /*[in]*/    DWORD           dwAttributeLength,
                /*[in]*/    DWORD           dwMaxLength
                );

    //
    // carries out splitting of attributes if required
    //
    HRESULT SplitAttributes (
                /*[in]*/    IAttributesRaw  *pIAttributesRaw
                );

    //
    // converts IAS reason code to RADIUS error codes
    //
    HRESULT  CRecvFromPipe::ConvertReasonToRadiusError (
                /*[in]*/    LONG            iasReason,
                /*[out]*/   PRADIUSLOGTYPE  pRadError
                );
    
    CPreProcessor *m_pCPreProcessor;

    CHashMD5      *m_pCHashMD5;

    CHashHmacMD5   *m_pCHashHmacMD5;

    CClients       *m_pCClients;

    VSAFilter      *m_pCVSAFilter;

    CTunnelPassword *m_pCTunnelPassword;

    CReportEvent   *m_pCReportEvent;
    

};

#endif // ifndef _RECVFROMPIPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\reportevent.h ===
//#--------------------------------------------------------------
//        
//  File:       reportevent.h
//        
//  Synopsis:   This file holds the declarations of the 
//				CReportEvent class
//                  
//
//  History:     1/29/98  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------
#ifndef _REPORTEVENT_H_
#define _REPORTEVENT_H_


//
//  here the audit log types generated by the RADIUS
//  protocol component
//
typedef enum _radiuslogtype_
{
    RADIUS_DROPPED_PACKET = 0,
    RADIUS_MALFORMED_PACKET = RADIUS_DROPPED_PACKET +1,
    RADIUS_INVALID_CLIENT = RADIUS_MALFORMED_PACKET +1,
    RADIUS_LOG_PACKET = RADIUS_INVALID_CLIENT +1,
    RADIUS_BAD_AUTHENTICATOR = RADIUS_LOG_PACKET +1,
    RADIUS_UNKNOWN_TYPE = RADIUS_BAD_AUTHENTICATOR +1,
    RADIUS_NO_RECORD = RADIUS_UNKNOWN_TYPE +1

}   RADIUSLOGTYPE, *PRADIUSLOGTYPE;

//
// this the maximum value the the log types have 
//
#define MAX_RADIUSLOGTYPE  RADIUS_NO_RECORD

class CReportEvent
{

public:

    VOID SetLogType  (
            /*[in]*/    DWORD   dwLogType,
            /*[in]*/    BOOL    bLogValue
            );

    VOID Process (
            /*[in]*/    RADIUSLOGTYPE   radLogType,
            /*[in]*/    PACKETTYPE      radPacketType,
            /*[in]*/    DWORD           dwDataSize,
            /*[in]*/    DWORD           dwIPAddress,
            /*[in]*/    LPCWSTR         szString,
            /*[in]*/    LPVOID          pRawData
            );
        
    CReportEvent ();
    
    ~CReportEvent ();

private:
    
    BOOL        m_bLogMalformed;
    BOOL        m_bLogAcct;
    BOOL        m_bLogAuth;
    BOOL        m_bLogAll;

};

#endif //   _REPORTEVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\reportevent.cpp ===
//#--------------------------------------------------------------
//
//  File:		reportevent.cpp
//
//  Synopsis:   Implementation of CReportEvent class methods
//              The class is responsible for logging the
//              appropriate events
//
//
//  History:     1/29/98  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "radpkt.h"
#include "reportevent.h"
#include "iasradius.h"
#include "iasutil.h"

#define  NUMBER_OF_EVENT_STRINGS 2
//
// this array holds the  information to map RADIUSLOGTYPEs to
// IAS logs
//
static DWORD   g_ReportEvent [MAX_RADIUSLOGTYPE +1][MAX_PACKET_TYPE +1];

//++--------------------------------------------------------------
//
//  Function:   CReportEvent
//
//  Synopsis:   This is CReportEvent class constructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     1/29/98
//
//----------------------------------------------------------------
CReportEvent::CReportEvent (
                VOID
                )
            :m_bLogMalformed (FALSE),
             m_bLogAcct (FALSE),
             m_bLogAuth (FALSE),
             m_bLogAll (FALSE)
{

    //
    //  initalize the global array
    //
    g_ReportEvent[RADIUS_DROPPED_PACKET][ACCESS_REQUEST] =
                            IAS_EVENT_RADIUS_AUTH_DROPPED_PACKET;

    g_ReportEvent[RADIUS_DROPPED_PACKET][ACCOUNTING_REQUEST] =
                            IAS_EVENT_RADIUS_ACCT_DROPPED_PACKET;


    g_ReportEvent[RADIUS_MALFORMED_PACKET][ACCESS_REQUEST] =
                            IAS_EVENT_RADIUS_AUTH_MALFORMED_PACKET;

    g_ReportEvent[RADIUS_MALFORMED_PACKET][ACCOUNTING_REQUEST] =
                            IAS_EVENT_RADIUS_ACCT_MALFORMED_PACKET;


    g_ReportEvent[RADIUS_INVALID_CLIENT][ACCESS_REQUEST] =
                            IAS_EVENT_RADIUS_AUTH_INVALID_CLIENT;

    g_ReportEvent[RADIUS_INVALID_CLIENT][ACCOUNTING_REQUEST] =
                            IAS_EVENT_RADIUS_ACCT_INVALID_CLIENT;

    g_ReportEvent[RADIUS_LOG_PACKET][ACCESS_REQUEST] =
                            IAS_EVENT_RADIUS_AUTH_ACCESS_REQUEST;

    g_ReportEvent[RADIUS_LOG_PACKET][ACCESS_ACCEPT] =
                            IAS_EVENT_RADIUS_AUTH_ACCESS_ACCEPT;

    g_ReportEvent[RADIUS_LOG_PACKET][ACCESS_REJECT] =
                            IAS_EVENT_RADIUS_AUTH_ACCESS_REJECT;

    g_ReportEvent[RADIUS_LOG_PACKET][ACCOUNTING_REQUEST] =
                            IAS_EVENT_RADIUS_ACCT_REQUEST;

    g_ReportEvent[RADIUS_LOG_PACKET][ACCOUNTING_RESPONSE] =
                            IAS_EVENT_RADIUS_ACCT_RESPONSE;

    g_ReportEvent[RADIUS_LOG_PACKET][ACCESS_CHALLENGE] =
                            IAS_EVENT_RADIUS_AUTH_ACCESS_CHALLENGE;

    g_ReportEvent[RADIUS_BAD_AUTHENTICATOR][ACCESS_REQUEST] =
                            IAS_EVENT_RADIUS_AUTH_BAD_AUTHENTICATOR;

    g_ReportEvent[RADIUS_BAD_AUTHENTICATOR][ACCOUNTING_REQUEST] =
                            IAS_EVENT_RADIUS_ACCT_BAD_AUTHENTICATOR;

    g_ReportEvent[RADIUS_UNKNOWN_TYPE][ACCESS_REQUEST] =
                            IAS_EVENT_RADIUS_AUTH_UNKNOWN_TYPE;

    g_ReportEvent[RADIUS_UNKNOWN_TYPE][ACCOUNTING_REQUEST] =
                            IAS_EVENT_RADIUS_ACCT_UNKNOWN_TYPE;

    g_ReportEvent[RADIUS_NO_RECORD][ACCESS_REQUEST] =
                            IAS_EVENT_RADIUS_AUTH_DROPPED_PACKET;

    g_ReportEvent[RADIUS_NO_RECORD][ACCOUNTING_REQUEST] =
                            IAS_EVENT_RADIUS_ACCT_NO_RECORD;

}   //  end of CReportEvent class constructor

//++--------------------------------------------------------------
//
//  Function:   ~CReportEvent
//
//  Synopsis:   This is CReportEvent class destructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     1/29/98
//
//----------------------------------------------------------------
CReportEvent::~CReportEvent (
                VOID
                )
{

}   //  end of CReportEvent class constructor

//++--------------------------------------------------------------
//
//  Function:   SetLogType
//
//  Synopsis:   This is CReportEvent class responsible
//              for setting the logging type
//
//  Arguments:
//              [in]     DWORD - log id
//              [in]     BOOL  - log value
//
//  Returns:    VOID
//
//  History:    MKarki      Created     1/29/98
//
//----------------------------------------------------------------
VOID
CReportEvent::SetLogType (
        DWORD   dwLogSwitches,
        BOOL    bLogValue
        )
{
    return;

}   //  end of CReportEvent::SetLogType method

//++--------------------------------------------------------------
//
//  Function:   Process
//
//  Synopsis:   This is CReportEvent class responsible for
//              actually logging the event to the Audit channel
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     1/29/98
//
//----------------------------------------------------------------
VOID
CReportEvent::Process (
        RADIUSLOGTYPE radLogType,
        PACKETTYPE    radPacketType,
        DWORD         dwDataSize,
        DWORD         dwIPAddress,
        LPCWSTR       szInString,
        LPVOID        pRawData
)
{
    HRESULT  hr = S_OK;
    LPCWSTR  pStrArray[NUMBER_OF_EVENT_STRINGS];
    WCHAR    wszIPAddress[16];
    BOOL     bLogPacket = FALSE;

    //
    // the values should be in array range
    //
    _ASSERT (MAX_RADIUSLOGTYPE >= radLogType);

    //
    //  as we might get incorrect values for packettype,
    //  we need to correct this
    //
    if (MAX_PACKET_TYPE < radPacketType) { return;}


    //
    //  get the IP address in dotted octed format
    //  and put in as a string
    //
    ias_inet_htow(dwIPAddress, wszIPAddress);

    //
    //  put the strings in the array
    //
    pStrArray[0] = wszIPAddress;
    pStrArray[1] = szInString;


    //
    //  log the event now
    //
    hr = ::IASReportEvent (
                g_ReportEvent [radLogType][radPacketType],
                (DWORD) NUMBER_OF_EVENT_STRINGS,
                dwDataSize,
                pStrArray,
                pRawData
                );
    if (FAILED (hr))
    {
        IASTracePrintf (
            "Unable to report event from Radius Component"
            );
    }
}   //  end of CReportEvent::Process method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\recvfrompipe.cpp ===
//#--------------------------------------------------------------
//
//  File:       recvfrompipe.cpp
//
//  Synopsis:   Implementation of CRecvFromPip class methods
//
//    Copyright (C) Microsoft Corporation All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "preprocessor.h"
#include "recvfrompipe.h"
#include "logresult.h"

#include <new>
#include <iastlutl.h>

const CHAR      NUL =  '\0';

extern LONG g_lPacketCount;
//++--------------------------------------------------------------
//
//  Function:   CRecvFromPipe
//
//  Synopsis:   This is the constructor of the CRecvFromPipe
//          class
//
//  Arguments:  none
//
//  Returns:    none
//
//
//  History:    MKarki      Created     10/22/97
//
//----------------------------------------------------------------
CRecvFromPipe::CRecvFromPipe(
         CPreProcessor     *pCPreProcessor,
         CHashMD5          *pCHashMD5,
         CHashHmacMD5      *pCHashHmacMD5,
         CClients          *pCClients,
         VSAFilter         *pCVSAFilter,
         CTunnelPassword   *pCTunnelPassword,
         CReportEvent      *pCReportEvent
         )
         :m_pCPreProcessor (pCPreProcessor),
          m_pCHashMD5 (pCHashMD5),
          m_pCHashHmacMD5 (pCHashHmacMD5),
          m_pCClients (pCClients),
          m_pCVSAFilter (pCVSAFilter),
          m_pCTunnelPassword (pCTunnelPassword),
          m_pCReportEvent (pCReportEvent)
{
    _ASSERT  (
               (NULL != pCPreProcessor)      &&
               (NULL != pCHashMD5)           &&
               (NULL != pCHashHmacMD5)       &&
               (NULL != pCClients)           &&
               (NULL != pCVSAFilter)         &&
               (NULL != pCTunnelPassword)    &&
               (NULL != pCReportEvent)
             );

}   //  end of CRecvFromPipe constructor

//++--------------------------------------------------------------
//
//  Function:   ~CRecvFromPipe
//
//  Synopsis:   This is the destructor of the CRecvFromPipe
//          class
//
//  Arguments:  none
//
//  Returns:    none
//
//
//  History:    MKarki      Created     10/22/97
//
//----------------------------------------------------------------
CRecvFromPipe::~CRecvFromPipe()
{
}   //  end of CRecvFromPipe destructor

//++--------------------------------------------------------------
//
//  Function:   Process
//
//  Synopsis:   This is the CRecvFromPipe class public method
//              to start processing the packet on its way out
//
//  Arguments:
//              [in]    CPacketRadius*
//
//  Returns:    HRESULT
//
//
//  History:    MKarki      Created     10/22/97
//
//  Called By:
//              1) CController::CRequestSource::OnRequest Method
//
//----------------------------------------------------------------
HRESULT
CRecvFromPipe::Process (
                IRequest    *pIRequest
                )
{
    BOOL                    bStatus = FALSE;
    HRESULT                 hr = S_OK;
    DWORD                   dwCode = 0;
    DWORD                   dwCount = 0;
    DWORD                   dwAttribCount = 0;
    IAttributesRaw          *pIAttributesRaw = NULL;
    IRequestState           *pIRequestState = NULL;
    CPacketRadius           *pCPacketRadius =  NULL;
    LONG                    iasResponse, iasReason = 0;
    PACKETTYPE              ePacketType;
    PATTRIBUTEPOSITION      pAttribPosition = NULL;
    unsigned   hyper        uhyPacketAddress = 0;
    RADIUSLOGTYPE           RadiusError = RADIUS_DROPPED_PACKET;

    _ASSERT (pIRequest);

    __try
    {
        // We have to retrieve the CPacketRadius object first, so we can clean
       // it up even in the error cases.
        hr = pIRequest->QueryInterface (
                                __uuidof(IRequestState),
                                reinterpret_cast <PVOID*> (&pIRequestState)
                                );
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to obtain request state in request received from "
                "backend"
               );
            __leave;
        }

        //
        //  get the CPacketRadius class object
        //
        hr = pIRequestState->Pop (
                reinterpret_cast <unsigned hyper*> (&uhyPacketAddress)
                );
        if (FAILED (hr))
        {
            IASTracePrintf (
               "Unable to obtain information from request state received "
                "from backend"
                );
            __leave;
        }

        pCPacketRadius = reinterpret_cast <CPacketRadius*> (uhyPacketAddress);

        //
        //  if this Request object has been generated by the backend then we
        //  don't have a CPacketRadius class object
        //
        if (NULL == pCPacketRadius)
        {
            //
            //  we most probably are sending out an EAP-Challenge
            //
            hr= GeneratePacketRadius (
                            &pCPacketRadius,
                            pIAttributesRaw
                            );
            if (FAILED (hr)) { __leave; }
        }

        //
        //  get the IAttributesRaw interface now
        //
        hr = pIRequest->QueryInterface (
                                __uuidof(IAttributesRaw),
                                reinterpret_cast <PVOID*> (&pIAttributesRaw)
                                );
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to obtain Attributes interface in request "
                "received from backend"
                );
            __leave;
        }

        //
        // split the attributes which can not fit in a radius packet
        //
        hr = SplitAttributes (pIAttributesRaw);
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to split IAS attribute received from backend"
               );
            __leave;
        }

        //
        //  convert the IAS VSA attributes to RADIUS format
        //
        hr = m_pCVSAFilter->radiusFromIAS (pIAttributesRaw);
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to convert IAS attribute to Radius VSAs in request "
                "received from backend"
               );
            __leave;
        }

        //
        //  get the outbound packet code
        //
        hr = pIRequest->get_Response (&iasResponse);
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to obtain response code in request recieved from "
                "backend"
                );
            __leave;
        }

        //
        //  get the outbound reason code
        //
        hr = pIRequest->get_Reason (&iasReason);
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to obtain reason code in request recieved from "
                "backend"
                );
            __leave;
        }

        // Log the result of the request.
        IASRadiusLogResult(pIRequest, pIAttributesRaw);

        // If it failed convert the reason code.
        if (iasReason != S_OK)
        {
           ConvertReasonToRadiusError (iasReason, &RadiusError);
        }

        //
        //  convert the IASRESPONSE type to RADIUS type
        //
        hr = ConvertResponseToRadiusCode (
                        iasResponse,
                        &ePacketType,
                        pCPacketRadius
                        );
        if (FAILED (hr)) { __leave; }

        //
        //  check if we have Tunnel-Password attribute, if yes
        //  then encrypt it
        //
        hr = m_pCTunnelPassword->Process (
                        ePacketType,
                        pIAttributesRaw,
                        pCPacketRadius
                        );
        if (FAILED (hr)) { __leave; }

        //
        // inject Signature Attribute if needed
        //
        hr = InjectSignatureIfNeeded (
                                ePacketType,
                                pIAttributesRaw,
                                pCPacketRadius
                                );
        if (FAILED (hr)) { __leave; }

        //
        //  get the count of number of request
        //
        hr = pIAttributesRaw->GetAttributeCount (&dwAttribCount);
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to obtain attribute count in request received from "
                "backend"
                );
            __leave;
        }

        //
        //  allocate the attribposition structures
        //
        pAttribPosition = reinterpret_cast <PATTRIBUTEPOSITION>  (
                      CoTaskMemAlloc (
                            sizeof (ATTRIBUTEPOSITION)*dwAttribCount
                            ));
        if (NULL == pAttribPosition)
        {
            IASTracePrintf (
                "Unable to allocate memory for attribute postion array "
                "while processing request recieved from backend"
                );
            hr = E_OUTOFMEMORY;
            __leave;
        }

        //
        //  get the attributes from the collection
        //
        hr = pIAttributesRaw->GetAttributes (
                                    &dwAttribCount,
                                    pAttribPosition,
                                    0,
                                    NULL
                                    );
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to get attribute in request received from backend"
                );
            __leave;
        }

        //
        //  remove the attributes from the collection now
        //
        hr = pIAttributesRaw->RemoveAttributes (
                                dwAttribCount,
                                pAttribPosition
                                );
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to remove attribute in request received from backend"
                );
            __leave;
        }

        //
        //  carry out the generic packet building here
        //
        hr = pCPacketRadius->BuildOutPacket (
                                        ePacketType,
                                        pAttribPosition,
                                        dwAttribCount
                                        );
        if (FAILED (hr)) { __leave; }

        //
        //  sending out packet now
        //
        hr = m_pCPreProcessor->StartOutProcessing (pCPacketRadius);
        if (FAILED (hr)) { __leave; }

   }
   __finally
   {

      //
      //  log event in case of both success and failure
      //
      if (SUCCEEDED (hr))
      {
         //
         //  log an event that inbound packet has been processed
         //  successfully
         //
         m_pCReportEvent->Process (
               RADIUS_LOG_PACKET,
               pCPacketRadius->GetInCode (),
               pCPacketRadius->GetInLength (),
               pCPacketRadius->GetInAddress (),
               NULL,
               static_cast <LPVOID> (pCPacketRadius->GetInPacket())
               );

         //
         //  log an event for the outbound packet successfully send
         //  out
         //
         m_pCReportEvent->Process (
               RADIUS_LOG_PACKET,
               pCPacketRadius->GetOutCode (),
               pCPacketRadius->GetOutLength (),
               pCPacketRadius->GetOutAddress (),
               NULL,
               static_cast <LPVOID> (pCPacketRadius->GetOutPacket())
               );
      }
      else
      {
         if (hr != RADIUS_E_ERRORS_OCCURRED)
         {
            IASReportEvent(
               RADIUS_E_INTERNAL_ERROR,
               0,
               sizeof(hr),
               NULL,
               &hr
               );
         }
         else if (pCPacketRadius != 0)
         {
            //
            //  generate event that inbound packet has been dropped
            //
            m_pCReportEvent->Process (
               RadiusError,
               pCPacketRadius->GetInCode (),
               pCPacketRadius->GetInLength (),
               pCPacketRadius->GetInAddress (),
               NULL,
               static_cast <LPVOID> (pCPacketRadius->GetInPacket())
               );
         }
         else
         {
            IASReportEvent(
               RADIUS_E_INTERNAL_ERROR,
               0,
               sizeof(hr),
               NULL,
               &hr
               );
         }
      }

      //
      //  now delete the dynamically allocated memory
      //
      if (NULL != pAttribPosition)
      {
         //
         //  release the attributes first
         //
         for (dwCount = 0; dwCount < dwAttribCount; dwCount++)
         {
            ::IASAttributeRelease  (pAttribPosition[dwCount].pAttribute);
         }

         CoTaskMemFree (pAttribPosition);
      }

      if (pIRequestState) { pIRequestState->Release (); }

      if (pIAttributesRaw) { pIAttributesRaw->Release (); }

      //
      //  delete the packet
      //
      if (pCPacketRadius) { delete pCPacketRadius; }

      //
      //  now decrement the global packet reference count
      //
      InterlockedDecrement (&g_lPacketCount);
   }

   return (hr);

}   //  end of CRecvFromPipe::Process method

//++--------------------------------------------------------------
//
//  Function:   ConvertResponseToRadiusCode
//
//  Synopsis:   This is the CRecvFromPipe class private method
//              that converts the IASRESPONSE code to RADIUS
//              packet type
//
//  Arguments:
//              [in]    IASRESPONSE
//              [out]   PPACKETTYPE
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     12/12/97
//
//  Called By:  CRecvFromPipe::Process method
//
//----------------------------------------------------------------
HRESULT
CRecvFromPipe::ConvertResponseToRadiusCode (
                        LONG            iasResponse,
                        PPACKETTYPE     pPacketType,
                        CPacketRadius   *pCPacketRadius
                        )
{
    HRESULT hr = S_OK;

    _ASSERT (pPacketType && pCPacketRadius);

    switch (iasResponse)
    {
    case  IAS_RESPONSE_ACCESS_ACCEPT:
        *pPacketType = ACCESS_ACCEPT;
        break;
    case  IAS_RESPONSE_ACCESS_REJECT:
        *pPacketType = ACCESS_REJECT;
        break;
    case  IAS_RESPONSE_ACCESS_CHALLENGE:
        *pPacketType = ACCESS_CHALLENGE;
        break;
    case  IAS_RESPONSE_ACCOUNTING:
        *pPacketType = ACCOUNTING_RESPONSE;
        break;
    case  IAS_RESPONSE_FORWARD_PACKET:
        //
        // if we are forwarding this packet
        // the the packet type remains the same
        //
        *pPacketType = pCPacketRadius->GetInCode ();
        break;
    case  IAS_RESPONSE_DISCARD_PACKET:
        hr = RADIUS_E_ERRORS_OCCURRED;
        break;

    case  IAS_RESPONSE_INVALID:
    default:
        hr = E_FAIL;
        break;
    }

    return (hr);

}   //  end of CRecvFromPipe::ConvertResponseToRadiusCode method

//++--------------------------------------------------------------
//
//  Function:   GetOutPacketInfo
//
//  Synopsis:   This is the CRecvFromPipe class private method
//              that is used to used to get out bound packet
//              information from the IAS attribute collection
//
//  Arguments:
//              [out]    PDWORD   -  IP address
//              [out]    PWORD    -  UDP port
//              [out]    Client** -  reference to CClient object
//              [out]    PBYTE    -  packet header
//              [in]     IAttributesRaw*
//
//  Returns:    BOOL    status
//
//  History:    MKarki      Created     1/9/97
//
//  Called By:  CRecvFromPipe::Process method
//
//----------------------------------------------------------------
HRESULT
CRecvFromPipe::GetOutPacketInfo (
    PDWORD          pdwIPAddress,
    PWORD           pwPort,
    IIasClient      **ppIIasClient,
    PBYTE           pPacketHeader,
    IAttributesRaw  *pIAttributesRaw
    )
{
    BOOL            bStatus = TRUE;
    HRESULT         hr = S_OK;
    DWORD           dwCount = 0;
    PIASATTRIBUTE   pIasAttribute = NULL;
    DWORD           dwAttribPosCount = COMPONENT_SPECIFIC_ATTRIBUTE_COUNT;
    DWORD           dwAttribIDCount =  COMPONENT_SPECIFIC_ATTRIBUTE_COUNT;
    ATTRIBUTEPOSITION   AttribPos[COMPONENT_SPECIFIC_ATTRIBUTE_COUNT];
    static DWORD AttribIDs [] =
                           {
                                IAS_ATTRIBUTE_CLIENT_IP_ADDRESS,
                                IAS_ATTRIBUTE_CLIENT_UDP_PORT,
                                IAS_ATTRIBUTE_CLIENT_PACKET_HEADER
                           };

    _ASSERT (
            (NULL != pdwIPAddress)  &&
            (NULL != pwPort)        &&
            (NULL != pPacketHeader) &&
            (NULL != ppIIasClient)  &&
            (NULL != pIAttributesRaw)
            );

    __try
    {

        //
        //  get client info
        //
        //  get the attributes from the collection
        //
        hr = pIAttributesRaw->GetAttributes (
                                    &dwAttribPosCount,
                                    AttribPos,
                                    dwAttribIDCount,
                                    reinterpret_cast <LPDWORD> (AttribIDs)
                                    );
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to get attributes while obtaining out-bound packet "
                "information"
                );
           __leave;
        }
        else if (COMPONENT_SPECIFIC_ATTRIBUTE_COUNT !=  dwAttribPosCount)
        {
            IASTracePrintf (
                "Request received from backend does not have all the "
                "all the required attributes"
                );
            hr = E_FAIL;
           __leave;
        }


        //
        //  go through the attributes and get values out
        //
        for (dwCount = 0; dwCount < dwAttribPosCount; dwCount++)
        {
            pIasAttribute =  AttribPos[dwCount].pAttribute;
            switch (pIasAttribute->dwId)
            {
            case IAS_ATTRIBUTE_CLIENT_IP_ADDRESS:
                _ASSERT (IASTYPE_INET_ADDR == pIasAttribute->Value.itType),
                *pdwIPAddress = pIasAttribute->Value.InetAddr;
                break;

            case IAS_ATTRIBUTE_CLIENT_UDP_PORT:
                _ASSERT (IASTYPE_INTEGER == pIasAttribute->Value.itType);
                *pwPort = pIasAttribute->Value.Integer;
                break;

            case  IAS_ATTRIBUTE_CLIENT_PACKET_HEADER:
               _ASSERT (
               (IASTYPE_OCTET_STRING == pIasAttribute->Value.itType)  &&
               (PACKET_HEADER_SIZE == pIasAttribute->Value.OctetString.dwLength)
                );
                //
                //  copy the value into the buffer provided
                //
                CopyMemory (
                    pPacketHeader,
                    pIasAttribute->Value.OctetString.lpValue,
                    PACKET_HEADER_SIZE
                    );
                break;
            default:
                _ASSERT (0);
                IASTracePrintf (
                    "Attribute:%d, not requested, is present "
                    "in request received from backend",
                    pIasAttribute->dwId
                    );
                hr = E_FAIL;
                __leave;
                break;
            }

        }   //  end of for loop

        //
       //   get client information for this RADIUS packet
        //
        bStatus = m_pCClients->FindObject (
                           *pdwIPAddress,
                            ppIIasClient
                           );
        if (FALSE == bStatus)
        {
           in_addr sin;
           sin.s_addr = *pdwIPAddress;
            IASTracePrintf (
                "Unable to get information for client:%s "
                "while processing request received from backend",
                inet_ntoa (sin)
                );
            hr = E_FAIL;
            __leave;
        }

    }
    __finally
    {
        if  (SUCCEEDED (hr))
        {
            for (dwCount = 0; dwCount < dwAttribPosCount; dwCount++)
            {
                //
                //  now release the reference to the attributes
                //
                ::IASAttributeRelease  (AttribPos[dwCount].pAttribute);
            }
        }
    }

    return (hr);

}   //  end of CPacketRadius::GetOutPacketInfo method

//++--------------------------------------------------------------
//
//  Function:   GeneratePacketRadius
//
//  Synopsis:   This is the CRecvFromPipe class private method
//              that is used generate a new CPacketRadius
//              class object and initialize it
//
//  Arguments:
//              [out]    CPacketRadius**
//              [in]     IAttributesRaw*
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     2/6/98
//
//  Called By:  CRecvFromPipe::Process method
//
//----------------------------------------------------------------
HRESULT
CRecvFromPipe:: GeneratePacketRadius (
        CPacketRadius   **ppCPacketRadius,
        IAttributesRaw  *pIAttributesRaw
        )
{
    PBYTE                   pPacketHeader = NULL;
    DWORD                   dwAddress = 0;
    WORD                    wPort = 0;
    IIasClient              *pIIasClient = NULL;
    HRESULT                 hr = S_OK;
    PATTRIBUTEPOSITION      pAttribPosition = NULL;


    _ASSERT (ppCPacketRadius && pIAttributesRaw);

    //
    // allocate memory for packet header
    //
    pPacketHeader =
        reinterpret_cast <PBYTE> (CoTaskMemAlloc (PACKET_HEADER_SIZE));
    if (NULL == pPacketHeader)
    {
        IASTracePrintf (
                "Unable to allocate memory for packet header information "
                "while generating out-bound packet"
                );
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    //  we need to gather information from the attribute collection
    //  needed to get create and initialize a CPacketRadius class
    //  object
    //
    hr = GetOutPacketInfo (
                    &dwAddress,
                    &wPort,
                    &pIIasClient,
                    pPacketHeader,
                    pIAttributesRaw
                    );
    if (FAILED (hr)) { goto Cleanup; }


    //
    //  create a new CPacketRadius class object
    //
    *ppCPacketRadius = new (std::nothrow) CPacketRadius (
                                            m_pCHashMD5,
                                            m_pCHashHmacMD5,
                                            pIIasClient,
                                            m_pCReportEvent,
                                            pPacketHeader,
                                            PACKET_HEADER_SIZE,
                                            dwAddress,
                                            wPort,
                                            INVALID_SOCKET,
                                            AUTH_PORTTYPE
                                            );
    if (NULL == *ppCPacketRadius)
    {
        IASTracePrintf (
            "Unable to create a Packet-Radius object "
            "while generating an out-bound packet"
             );
        pIIasClient->Release ();
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:

    if ((FAILED (hr)) && (pPacketHeader))
    {
        CoTaskMemFree (pPacketHeader);
    }

    return (hr);

}   //  end of CRecvFromPipe::GeneratePacketRadius method

//++--------------------------------------------------------------
//
//  Function:   InjectSignatureIfNeeded
//
//  Synopsis:   This method is used to add a blank Signature attribute
//              into the response if we see an EAP-Message attribute
//              present
//
//  Arguments:
//              [in]     PACKETTYPE
//              [in]     IAttributesRaw*
//              [in]     CPacketRadius*
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     11/17/98
//
//  Called By:  CRecvFromPipe::Process method
//
//----------------------------------------------------------------
HRESULT CRecvFromPipe::InjectSignatureIfNeeded (
                    /*[in]*/    PACKETTYPE      ePacketType,
                    /*[in]*/    IAttributesRaw  *pIAttributesRaw,
                    /*[in]*/    CPacketRadius   *pCPacketRadius
                    )
{
    HRESULT hr = S_OK;
    PATTRIBUTEPOSITION pAttribPos = NULL;
    PIASATTRIBUTE pIasAttrib = NULL;

    _ASSERT (pIAttributesRaw && pCPacketRadius);

    __try
    {
        if (
            (ACCESS_ACCEPT != ePacketType) &&
            (ACCESS_REJECT != ePacketType) &&
            (ACCESS_CHALLENGE != ePacketType)
            )
            {__leave;}

        //
        //  get the count of the total attributes in the collection
        //
        DWORD dwAttributeCount = 0;
        hr = pIAttributesRaw->GetAttributeCount (&dwAttributeCount);
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to obtain attribute count in request while "
                "processing message authenticator attribute in out-bound packet "
                );
            __leave;
        }
        else if (0 == dwAttributeCount)
        {
            __leave;
        }

        //
        //  allocate memory for the ATTRIBUTEPOSITION array
        //
        pAttribPos = reinterpret_cast <PATTRIBUTEPOSITION> (
                        CoTaskMemAlloc (
                             sizeof (ATTRIBUTEPOSITION)*dwAttributeCount));
        if (NULL == pAttribPos)
        {
            IASTracePrintf (
                "Unable to allocate memory for attribute position array "
                "while processing message authenticator attribute in out-bound packet"
                );
            hr = E_OUTOFMEMORY;
            __leave;
        }

        //
        // get the EAP-Message attribute from the interface
        //
        DWORD  dwAttrId = RADIUS_ATTRIBUTE_EAP_MESSAGE;
        hr = pIAttributesRaw->GetAttributes (
                                    &dwAttributeCount,
                                    pAttribPos,
                                    1,
                                    &dwAttrId
                                    );
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to obtain information about EAP-Message attribute "
                "while processing out-bound RADIUS packet"
                );
        }
        else if (0 == dwAttributeCount)
        {
            __leave;
        }

        bool bFound = false;
        for (DWORD dwCount = 0; dwCount < dwAttributeCount; dwCount++)
        {
            if (
                (!bFound) &&
                (pCPacketRadius->IsOutBoundAttribute (
                                                ePacketType,
                                                pAttribPos[dwCount].pAttribute
                                                ))
                )
            {
                bFound = true;
            }

            ::IASAttributeRelease (pAttribPos[dwCount].pAttribute);
        }

        if (bFound)
        {
            //
            // if we have an out-bound EAP-Message attribute then
            // we need to insert a Signature attribute too
            //

            //
            //  create a new blank attribute
            //
            DWORD dwRetVal = ::IASAttributeAlloc ( 1, &pIasAttrib);
            if (0 != dwRetVal)
            {
                IASTracePrintf (
                    "Unable to allocate IAS attribute for message authenticator "
                    "while processing out-bound RADIUS packet"
                    );
                hr = HRESULT_FROM_WIN32 (dwRetVal);
                __leave;
            }

            //
            //  allocate dynamic memory for the Signature
            //
            pIasAttrib->Value.OctetString.lpValue =
                                reinterpret_cast <PBYTE>
                                (CoTaskMemAlloc (SIGNATURE_SIZE));
            if (NULL == pIasAttrib->Value.OctetString.lpValue)
            {
                IASTracePrintf (
                    "Unable to allocate dynamic memory for message authenticator "
                    "attribute value while processing out-bound RADIUS packet"
                    );
                hr = E_OUTOFMEMORY;
                __leave;
            }
            else
            {
                //
                //  put the signature attribute with no value
                //  but correct size
                //
                pIasAttrib->dwId = RADIUS_ATTRIBUTE_SIGNATURE;
                pIasAttrib->Value.itType = IASTYPE_OCTET_STRING;
                pIasAttrib->Value.OctetString.dwLength = SIGNATURE_SIZE;
                pIasAttrib->dwFlags = IAS_INCLUDE_IN_RESPONSE;

                //
                // add the attribute to the collection now
                //
                ATTRIBUTEPOSITION attrPos;
                attrPos.pAttribute = pIasAttrib;
                hr = pIAttributesRaw->AddAttributes (1, &attrPos);
                if (FAILED (hr))
                {
                    IASTracePrintf (
                        "Unable to add message authenticator attribute to request while "
                        "processing out-bound RADIUS packet"
                        );
                    __leave;
                }

                IASTracePrintf (
                    "message authenticator Attribute added to out-bound RADIUS packet"
                    );
            }
        }
    }
    __finally
    {
        if (pAttribPos) { CoTaskMemFree (pAttribPos); }
        if (pIasAttrib) { ::IASAttributeRelease(pIasAttrib);}
    }

    return (hr);

}   //  end of CRecvFromPipe::InjectSignatureIfNeeded method

//++--------------------------------------------------------------
//
//  Function:   SplitAttributes
//
//  Synopsis:   This method is used to split up the following
//              out-bound attributes:
//                  1) Reply-Message attribute
//                  2) MS-Filter-VSA attribute
//                  3) MS QuarantineIpFilter attribute (VSA)
//
//  Arguments:
//              [in]     IAttributesRaw*
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     1/19/99
//
//  Called By:  CRecvFromPipe::Process method
//
//----------------------------------------------------------------
HRESULT CRecvFromPipe::SplitAttributes (
                    /*[in]*/    IAttributesRaw  *pIAttributesRaw
                    )
{
    const DWORD SPLIT_ATTRIBUTE_COUNT = 3;
    static DWORD  AttribIds [] = {
                                    RADIUS_ATTRIBUTE_REPLY_MESSAGE,
                                    MS_ATTRIBUTE_FILTER,
                                    MS_ATTRIBUTE_QUARANTINE_IPFILTER
                                };

    HRESULT hr = S_OK;
    DWORD dwAttributesFound = 0;
    PATTRIBUTEPOSITION pAttribPos = NULL;

    _ASSERT (pIAttributesRaw);

    __try
    {
        //
        //  get the count of the total attributes in the collection
        //
        DWORD dwAttributeCount = 0;
        hr = pIAttributesRaw->GetAttributeCount (&dwAttributeCount);
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to obtain attribute count in request while "
                "splitting attributes in out-bound packet "
                );
            __leave;
        }
        else if (0 == dwAttributeCount)
        {
            __leave;
        }

        //
        //  allocate memory for the ATTRIBUTEPOSITION array
        //
        pAttribPos = reinterpret_cast <PATTRIBUTEPOSITION> (
                        CoTaskMemAlloc (
                        sizeof (ATTRIBUTEPOSITION)*dwAttributeCount)
                        );
        if (NULL == pAttribPos)
        {
            IASTracePrintf (
                "Unable to allocate memory for attribute position array "
                "while splitting attributes in out-bound packet"
                );
            hr = E_OUTOFMEMORY;
            __leave;
        }

        //
        // get the attributes we are interested in from the interface
        //
        hr = pIAttributesRaw->GetAttributes (
                                    &dwAttributeCount,
                                    pAttribPos,
                                    SPLIT_ATTRIBUTE_COUNT,
                                    static_cast <PDWORD> (AttribIds)
                                    );
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to obtain information about attributes"
                "while splitting attributes in out-bound RADIUS packet"
                );
            __leave;
        }
        else if (0 == dwAttributeCount)
        {
            __leave;
        }

        //
        // save the count of attributes returned
        //
        dwAttributesFound = dwAttributeCount;

        DWORD dwAttribLength = 0;
        DWORD dwMaxPossibleLength = 0;
        IASTYPE iasType = IASTYPE_INVALID;
        //
        // evaluate each attribute now
        //
        for (DWORD dwCount = 0; dwCount < dwAttributeCount; dwCount++)
        {
            if ((pAttribPos[dwCount].pAttribute)->dwFlags &
                                            IAS_INCLUDE_IN_RESPONSE)
            {
                //
                // get attribute type and length
                //
                if (
                (iasType = (pAttribPos[dwCount].pAttribute)->Value.itType) ==
                            IASTYPE_STRING
                    )
                {
                    DWORD dwErr = ::IASAttributeAnsiAlloc(pAttribPos[dwCount].pAttribute);
                    if (dwErr != NO_ERROR)
                    {
                        hr = HRESULT_FROM_WIN32(dwErr);
                        IASTracePrintf (
                           "Unable to allocate memory for string attribute "
                           "while splitting attributes in out-bound packet"
                           );
                        __leave;
                    }

                    dwAttribLength =
                        strlen (
                        (pAttribPos[dwCount].pAttribute)->Value.String.pszAnsi);

                }
                else if (
                (iasType = (pAttribPos[dwCount].pAttribute)->Value.itType) ==
                            IASTYPE_OCTET_STRING
                )
                {
                  dwAttribLength =
                  (pAttribPos[dwCount].pAttribute)->Value.OctetString.dwLength;
                }
                else
                {
                    //
                    // only string values need to be split
                    //
                    continue;
                }

                //
                // get max possible attribute length
                //
                if ((pAttribPos[dwCount].pAttribute)->dwId > MAX_ATTRIBUTE_TYPE)
                {
                    dwMaxPossibleLength = MAX_VSA_ATTRIBUTE_LENGTH;
                }
                else
                {
                    dwMaxPossibleLength = MAX_ATTRIBUTE_LENGTH;
                }

                //
                // check if we need to split this attribute
                //
                if (dwAttribLength <= dwMaxPossibleLength)  {continue;}


                //
                // split the attribute now
                //
                hr = SplitAndAdd (
                            pIAttributesRaw,
                            pAttribPos[dwCount].pAttribute,
                            iasType,
                            dwAttribLength,
                            dwMaxPossibleLength
                            );
                if (SUCCEEDED (hr))
                {
                    //
                    //  remove this attribute from the collection now
                    //
                    hr = pIAttributesRaw->RemoveAttributes (
                                1,
                                &(pAttribPos[dwCount])
                                );
                    if (FAILED (hr))
                    {
                        IASTracePrintf (
                            "Unable to remove attribute from collection"
                            "while splitting out-bound attributes"
                            );
                    }
                }
            }
        }
    }
    __finally
    {
        if (pAttribPos)
        {
            for (DWORD dwCount = 0; dwCount < dwAttributesFound; dwCount++)
            {
                ::IASAttributeRelease (pAttribPos[dwCount].pAttribute);
            }

            CoTaskMemFree (pAttribPos);
        }
    }

    return (hr);

}   //  end of CRecvFromPipe::SplitAttributes method

//++--------------------------------------------------------------
//
//  Function:   SplitAndAdd
//
//  Synopsis:   This method is used to remove the original attribute
//              and add new ones
//  Arguments:
//              [in]     IAttributesRaw*
//              [in]     PIASATTRIBUTE
//              [in]     IASTYPE
//              [in]     DWORD  -   attribute length
//              [in]     DWORD  -   max attribute length
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     1/19/99
//
//  Called By:  CRecvFromPipe::SplitAttributes method
//
//----------------------------------------------------------------
HRESULT CRecvFromPipe::SplitAndAdd (
                    /*[in]*/    IAttributesRaw  *pIAttributesRaw,
                    /*[in]*/    PIASATTRIBUTE   pIasAttribute,
                    /*[in]*/    IASTYPE         iasType,
                    /*[in]*/    DWORD           dwAttributeLength,
                    /*[in]*/    DWORD           dwMaxLength
                    )
{
    HRESULT             hr = S_OK;
    DWORD               dwPacketsNeeded = 0;
    DWORD               dwFailed = 0;
    PIASATTRIBUTE       *ppAttribArray = NULL;
    PATTRIBUTEPOSITION  pAttribPos = NULL;

    _ASSERT (pIAttributesRaw && pIasAttribute);

    __try
    {
        dwPacketsNeeded = dwAttributeLength / dwMaxLength;
        if (dwAttributeLength % dwMaxLength) {++dwPacketsNeeded;}

        //
        //  allocate memory for the ATTRIBUTEPOSITION array
        //
        pAttribPos = reinterpret_cast <PATTRIBUTEPOSITION> (
                        CoTaskMemAlloc (
                             sizeof (ATTRIBUTEPOSITION)*dwPacketsNeeded));
        if (NULL == pAttribPos)
        {
            IASTracePrintf (
                "Unable to allocate memory for attribute position array "
                "while split and add of attributese in out-bound packet"
                );
            hr = E_OUTOFMEMORY;
            __leave;
        }

        //
        // allocate array to store the attributes in
        //
        ppAttribArray =
            reinterpret_cast <PIASATTRIBUTE*> (
            CoTaskMemAlloc (sizeof (PIASATTRIBUTE)*dwPacketsNeeded));
        if (NULL == ppAttribArray)
        {
            IASTracePrintf (
                "Unable to allocate memory"
                "while split and add of out-bound attribues"
                );
            hr = E_OUTOFMEMORY;
            __leave;
        }

        DWORD dwFailed =
                ::IASAttributeAlloc (dwPacketsNeeded, ppAttribArray);
        if (0 != dwFailed)
        {
            IASTracePrintf (
                "Unable to allocate attributes while splitting out-bound"
                "attributes"
                );
            hr = HRESULT_FROM_WIN32 (dwFailed);
            __leave;
        }

        if (IASTYPE_STRING == iasType)
        {
            PCHAR pStart =  (pIasAttribute->Value).String.pszAnsi;
            DWORD dwCopySize = dwMaxLength;

            //
            // set value in each of the new attributes
            //
            for (DWORD dwCount1 = 0; dwCount1 < dwPacketsNeeded; dwCount1++)
            {
                (ppAttribArray[dwCount1])->Value.String.pszWide = NULL;
                (ppAttribArray[dwCount1])->Value.String.pszAnsi =
                            reinterpret_cast <PCHAR>
                            (CoTaskMemAlloc ((dwCopySize + 1)*sizeof (CHAR)));
                if (NULL == (ppAttribArray[dwCount1])->Value.String.pszAnsi)
                {
                    IASTracePrintf (
                        "Unable to allocate memory for new attribute values"
                        "while split and add of out-bound attribues"
                        );
                    hr = E_OUTOFMEMORY;
                    __leave;
                }

                //
                // set the value now
                //
                ::CopyMemory (
                        (ppAttribArray[dwCount1])->Value.String.pszAnsi,
                        pStart,
                        dwCopySize
                        );
                //
                // nul terminate the values
                //
                ((ppAttribArray[dwCount1])->Value.String.pszAnsi)[dwCopySize]=NUL;
                (ppAttribArray[dwCount1])->Value.itType =  iasType;
                (ppAttribArray[dwCount1])->dwId = pIasAttribute->dwId;
                (ppAttribArray[dwCount1])->dwFlags = pIasAttribute->dwFlags;

                //
                // calculate for next attribute
                //
                pStart = pStart + dwCopySize;
                dwAttributeLength -= dwCopySize;
                dwCopySize =  (dwAttributeLength > dwMaxLength) ?
                              dwMaxLength : dwAttributeLength;

                //
                // add attribute to position array
                //
                pAttribPos[dwCount1].pAttribute = ppAttribArray[dwCount1];
            }
        }
        else
        {
            PBYTE pStart = (pIasAttribute->Value).OctetString.lpValue;
            DWORD dwCopySize = dwMaxLength;

            //
            // fill the new attributes now
            //
            for (DWORD dwCount1 = 0; dwCount1 < dwPacketsNeeded; dwCount1++)
            {
                (ppAttribArray[dwCount1])->Value.OctetString.lpValue =
                    reinterpret_cast <PBYTE> (CoTaskMemAlloc (dwCopySize));
                if (NULL ==(ppAttribArray[dwCount1])->Value.OctetString.lpValue)
                {
                    IASTracePrintf (
                        "Unable to allocate memory for new attribute values"
                        "while split and add of out-bound attribues"
                        );
                    hr = E_OUTOFMEMORY;
                    __leave;
                }

                //
                // set the value now
                //
                ::CopyMemory (
                        (ppAttribArray[dwCount1])->Value.OctetString.lpValue,
                        pStart,
                        dwCopySize
                        );

                (ppAttribArray[dwCount1])->Value.OctetString.dwLength = dwCopySize;
                (ppAttribArray[dwCount1])->Value.itType = iasType;
                (ppAttribArray[dwCount1])->dwId = pIasAttribute->dwId;
                (ppAttribArray[dwCount1])->dwFlags = pIasAttribute->dwFlags;

                //
                // calculate for next attribute
                //
                pStart = pStart + dwCopySize;
                dwAttributeLength -= dwCopySize;
                dwCopySize = (dwAttributeLength > dwMaxLength) ?
                                 dwMaxLength :
                                 dwAttributeLength;

                //
                // add attribute to position array
                //
                pAttribPos[dwCount1].pAttribute = ppAttribArray[dwCount1];
            }
        }

        //
        //   add the attribute to the collection
        //
        hr = pIAttributesRaw->AddAttributes (dwPacketsNeeded, pAttribPos);
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Failed to add attributes to the collection"
                "on split and add out-bound attributes"
                );
            __leave;
        }
    }
    __finally
    {
        if (ppAttribArray && !dwFailed)
        {
            for (DWORD dwCount = 0; dwCount < dwPacketsNeeded; dwCount++)
            {
                ::IASAttributeRelease (ppAttribArray[dwCount]);
            }
        }

        if (ppAttribArray) {CoTaskMemFree (ppAttribArray);}

        if (pAttribPos) {CoTaskMemFree (pAttribPos);}
    }

    return (hr);

}   //  end of CRecvFromPipe::SplitAndAdd method

//++--------------------------------------------------------------
//
//  Function:   ConvertReasonToRadiusError
//
//  Synopsis:
//
//  Arguments:
//              [in]     iasReason
//              [out]    Radius Error
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     12/31/98
//
//  Called By:  CRecvFromPipe::Process method
//
//----------------------------------------------------------------
HRESULT
CRecvFromPipe::ConvertReasonToRadiusError (
        /*[in]*/    LONG            iasReason,
        /*[out]*/   PRADIUSLOGTYPE  pRadError
        )
{
    HRESULT hr = S_OK;

    _ASSERT (pRadError);

    switch (iasReason)
    {
    case IAS_NO_RECORD:
        *pRadError =  RADIUS_NO_RECORD;
         break;

    case IAS_MALFORMED_REQUEST:
        *pRadError =  RADIUS_MALFORMED_PACKET;
         break;

    default:
       hr = E_FAIL;
       break;
    }

    return (hr);

}   //  end of CRecvFromPipe::ConvertReasonToRadiusError method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\rwlock.h ===
/*--------------------------------------------------------

  rwlock.h
      CReadWriteLock class provides functions that allow 
      threads to lock any resource in two different
	  modes (read-mode and write-mode).
      The class will allow multiple reader threads to access
      the resource simultaneously, but will make sure that
      a writer thread doesn't access the resource when 
      reader threads or a writer thread is currently accessing
      the resource. The class also assures fairness in access
      i.e. the access will be regulated by a first-come-first-in
	  policy.

	  Note:- ALL the functions in the class are INLINE functions.
	  So, this header can be directly used in the source.


  Copyright (C) 1997-98 Microsoft Corporation
  All rights reserved.

  Authors:
      rsraghav    R.S. Raghavan 

  History:
      04-20-95    rsraghav    Created.

  -------------------------------------------------------*/

#ifdef __cplusplus		// this file should be include only if this is
						// is included in a c++ source file.

#ifndef _RWLOCK_H_
#define _RWLOCK_H_

#if defined(DEBUG) && defined(INLINE)
#undef THIS_FILE
static char BASED_CODE RWLOCK_H[] = "rwlock.h";
#define THIS_FILE RWLOCK_H
#endif

#include <windows.h>

#define INLINE_EXPORT_SPEC __declspec( dllexport)

typedef enum {RWLOCK_READ_MODE, RWLOCK_WRITE_MODE} RWLOCK_MODE;

//////////////////////////////////////////////////////////////////////
// CReadWriteLock - Class that can be used to regulate read-write
//					access to resource, where multiple readers are
//					allowed simultaneously, but writers are excluded
//					from each other and from the readers. 

class CReadWriteLock
{
	HANDLE 			hResource;			 
	CRITICAL_SECTION 	csReader;			
	CRITICAL_SECTION	csWriter;			
	DWORD			cReaders;
	DWORD			cWriteRecursion;

	public:
		
		CReadWriteLock()			// object constructor
		{
			cReaders =0;
			cWriteRecursion = 0;
			hResource = CreateEvent(NULL, FALSE, TRUE, NULL);	// no manual reset & initial state is signalled
			InitializeCriticalSection(&csReader);
			InitializeCriticalSection(&csWriter);
		}

		~CReadWriteLock()			// object destructor
		{
			if (hResource)
				CloseHandle(hResource);
			DeleteCriticalSection(&csReader);
			DeleteCriticalSection(&csWriter);
		}

		CReadWriteLock *PrwLock() 
		{
			return this;			
		}

		BOOL FInit()
		{
			return (BOOL)hResource;
		}

		void LockReadMode()			// Get read access to the resource
		{
			EnterCriticalSection(&csWriter);	
			LeaveCriticalSection(&csWriter);
			EnterCriticalSection(&csReader);
			if (!cReaders)
			{
				if (hResource)
					WaitForSingleObject(hResource, INFINITE);
			}
			cReaders++;
			LeaveCriticalSection(&csReader);
		}

		int LockReadModeEx(int iTimeOut)			// Get read access to the resource w/ Timeout
		{
			int status = 0;

			EnterCriticalSection(&csWriter);	
			LeaveCriticalSection(&csWriter);
			EnterCriticalSection(&csReader);
			if (!cReaders)
			{
				if (hResource) {
					status = WaitForSingleObject(hResource, iTimeOut);
					if (status == WAIT_TIMEOUT) 
					{ 
						status = -1;
					} else {
						status = 0;
					}
				}
			}
			cReaders++;
			LeaveCriticalSection(&csReader);

			return status;
		}


		void UnlockReadMode()		// Relinquish read access to the resource
		{
			EnterCriticalSection(&csReader);
			if (!(--cReaders))
			{
				if (hResource)
					SetEvent(hResource);				
			}
			LeaveCriticalSection(&csReader);
		}

		void LockCSUnderRead()
		{
			EnterCriticalSection(&csReader);
		}
		void UnlockCSUnderRead()
		{
			LeaveCriticalSection(&csReader);
		}

		void LockWriteMode()		// Get write access to the resource
		{
			EnterCriticalSection(&csWriter);
			if (!cWriteRecursion)
			{
				if (hResource)
					WaitForSingleObject(hResource, INFINITE);
			}
			cWriteRecursion++;
			
		}
		
		int LockWriteModeEx(int iTimeOut)		// Get write access to the resource
		{
			int status = 0;

			EnterCriticalSection(&csWriter);
			if (!cWriteRecursion)
			{
				if (hResource) 
				{
					status = WaitForSingleObject(hResource, iTimeOut);
					if (status == WAIT_TIMEOUT) 
					{ 
						status = -1;
					} else {
						status = 0;
					}
				}				
			}
			if (status == 0)
				cWriteRecursion++;			

			return status;
		}


		void UnlockWriteMode()		// Relinquish write access to the resource
		{
			if (!(--cWriteRecursion))
			{
				if (hResource)
					SetEvent(hResource);
			}
			LeaveCriticalSection(&csWriter);
		}
};



//////////////////////////////////////////////////////////////////////
// Following class is just a utility class - users don't need to 
// necessarily use this class for obtaining read-write lock functionalities.

//////////////////////////////////////////////////////////////////////
// CScopeRWLock - This can be used to lock the given CReadWriteLock
//						object for the rest of the scope. The user just
//						needs to define this object in the scope by passing
//						a pointer to the CReadWriteLock object in the constructor. 
//						When this CScopeRWLock object goes out of scope the
//						CReadWriteLock object will automatically be unlocked.
//						This is provided just for user convenience so that the
//						user can choose to avoid remembering to unlock the object 
//						before every possible return/break path of the scope.
//						Use the RWLOCK_READ_MODE or RWLOCK_WRITE_MODE in the constructor
//						to indicate which type of access is requested.
//						Assumption:- CReadWriteLock object used here is expected to 
//								be valid at lease until the end of the scope.

class CScopeRWLock
{
	CReadWriteLock *m_prwLock;
	LPCRITICAL_SECTION m_pcs;
	RWLOCK_MODE m_rwMode;

	public:
		CScopeRWLock(CReadWriteLock * prwLock, RWLOCK_MODE rwMode)
		{
			m_prwLock = prwLock;
			m_pcs = NULL;
			m_rwMode = rwMode;
			if (m_prwLock)
			{
				if (m_rwMode == RWLOCK_READ_MODE)
					m_prwLock->LockReadMode();	
				else if (m_rwMode == RWLOCK_WRITE_MODE)
					m_prwLock->LockWriteMode();
			}
		}

		CScopeRWLock(LPCRITICAL_SECTION pcsLock)
		{  	
			m_pcs = pcsLock;
			m_prwLock = NULL;
			if (m_pcs)
				EnterCriticalSection(m_pcs);
		}

		~CScopeRWLock()
		{
			if (m_prwLock)
			{
				if (m_rwMode == RWLOCK_READ_MODE)
					m_prwLock->UnlockReadMode();
				else if (m_rwMode == RWLOCK_WRITE_MODE)
					m_prwLock->UnlockWriteMode();
			}
			
			if (m_pcs)
			{
				LeaveCriticalSection(m_pcs);
			}
		}
};

#endif // _RWLOCK_H_

#endif // #if __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\sockevt.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    sockevt.h
//
// SYNOPSIS
//
//    Declares the class SocketEvent.
//
// MODIFICATION HISTORY
//
//    02/12/1999    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _SOCKEVT_H_
#define _SOCKEVT_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <winsock2.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SocketEvent
//
// DESCRIPTION
//
//    Creates a socket that acts like a Win32 event. Useful for knocking a
//    thread out of select.
//
///////////////////////////////////////////////////////////////////////////////
class SocketEvent
{
public:
   SocketEvent() throw ()
      : s(INVALID_SOCKET)
   { }

   ~SocketEvent() throw ()
   { finalize(); }

   DWORD initialize() throw ();
   void finalize() throw ();

   DWORD set() throw ();
   void reset() throw ();

   operator SOCKET() throw ()
   { return s; }

private:
   SOCKET s;
   sockaddr_in sin;
};

#endif  // _SOCKEVT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\sockevt.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    sockevt.cpp
//
// SYNOPSIS
//
//    Defines the class SocketEvent.
//
// MODIFICATION HISTORY
//
//    02/12/1999    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <radcommon.h>
#include <sockevt.h>

DWORD SocketEvent::initialize() throw ()
{
   // Create a socket.
   s = socket(AF_INET, SOCK_DGRAM, 0);
   if (s == INVALID_SOCKET)
   {
      return WSAGetLastError();
   }

   int error;

   // Bind to an arbitrary port on the loopback interface.
   sin.sin_family      = AF_INET;
   sin.sin_port        = 0;
   sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
   error = bind(s, (sockaddr*)&sin, sizeof(sin));

   if (!error)
   {
      // Find out which port we bound to.
      int namelen = sizeof(sin);
      error = getsockname(s, (sockaddr*)&sin, &namelen);

      if (!error)
      {
         // Set the socket to non-blocking.
         u_long argp = 1;
         error = ioctlsocket(s, FIONBIO, &argp);
      }
   }

   // Clean-up if anything went wrong.
   if (error)
   {
      closesocket(s);
      s = INVALID_SOCKET;
      return WSAGetLastError();
   }

   return NO_ERROR;
}

void SocketEvent::finalize() throw ()
{
   if (s != INVALID_SOCKET)
   {
      closesocket(s);
      s = INVALID_SOCKET;
   }
}

DWORD SocketEvent::set() throw ()
{
   if (sendto(s, NULL, 0, 0, (sockaddr*)&sin, sizeof(sin)))
   {
      return WSAGetLastError();
   }

   return NO_ERROR;
}

void SocketEvent::reset() throw ()
{
   // Loop until we've read all the zero-byte sends.
   char buf[1];
   while (!recv(s, buf, 1, 0)) {}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\sendtopipe.h ===
//#--------------------------------------------------------------
//        
//  File:       sendtopipe.h
//        
//  Synopsis:   This file holds the declarations of the 
//				CSendToPipe class
//              
//
//  History:     10/22/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _SENDTOPIPE_H_
#define _SENDTOPIPE_H_

#include "vsafilter.h"
#include "recvfrompipe.h"	
#include "packetradius.h"
#include "reportevent.h"
#include "radcommon.h"


class CSendToPipe  
{

public:

    //
    //  initialize the CSendToPipe class object
    //
	BOOL Init (
            /*[in]*/    IRequestSource *pIRequestSource,
            /*[in]*/    VSAFilter      *pCVSAFilter,
            /*[in]*/    CReportEvent    *pCReportEvent
            );
    //
    //  start processing the inbound RADIUS requests
    //
    BOOL StartProcessing (
            /*[in]*/    IRequestHandler  *pIRequestHandler
            );

    //
    //  stop processing inbound RADIUS packet
    //
    BOOL   StopProcessing (VOID);

    //
    //  process inbound RADIUS packet
    //
	HRESULT Process (
                /*[in]*/    CPacketRadius *pCPacketRadius
                );

    //
    //  constructor
    //
	CSendToPipe();

    //
    //  destructor
    //
	virtual ~CSendToPipe();

private:

    //
    //  set the properties in Request class object
    //
    HRESULT SetRequestProperties (
                /*[in]*/    IRequest       *pIRequest,
                /*[in]*/    CPacketRadius  *pCPacketRadius,
                /*[in]*/    PACKETTYPE     epPacketType
                );

	IRequestSource      *m_pIRequestSource;

    IRequestHandler      *m_pIRequestHandler;

    IClassFactory       *m_pIClassFactory;

    VSAFilter           *m_pCVSAFilter;

    CReportEvent        *m_pCReportEvent;
};

#endif // ifndef _SENDTOPIPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\tunnelpassword.h ===
//#--------------------------------------------------------------
//
//  File:       tunnelpassword.h
//
//  Synopsis:   This file holds the declarations of the
//				CTunnelPassword class
//
//
//  History:     4/19/98  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radpkt.h"
#include "packetradius.h"

#ifndef _TUNNELPASSWORD_H_
#define _TUNNELPASSWORD_H_

//
//  declaration of the CTunnelPassword class
//
class CTunnelPassword
{
public:

    //
    //  process Tunnel-Password in out-bound packet
    //
    HRESULT Process (
                /*[in]*/    PACKETTYPE          ePacketType,
                /*[in]*/    IAttributesRaw      *pIAttributesRaw,
                /*[in]*/    CPacketRadius       *pCPacketRadius
                );

private:

    //
    //  Encrypts the Tunnel-Password value
    //
    static HRESULT EncryptTunnelPassword (
                /*[in]*/    CPacketRadius*  pCPacketRadius,
                /*[in]*/    IAttributesRaw      *pIAttributesRaw,
                /*[in]*/    PIASATTRIBUTE   pAttribute
                );
};

#endif //_TUNNELPASSWORD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\sendtopipe.cpp ===
//#--------------------------------------------------------------
//        
//  File:       sendtopipe.cpp
//        
//  Synopsis:   Implementation of CSendToPipe class methods
//              
//
//  History:     11/22/97  MKarki Created
//               06/12/98  SBens  Changed put_Response to SetResponse.
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "sendtopipe.h"

//+++-------------------------------------------------------------
//
//  Function:   CSendToPipe
//
//  Synopsis:   This is the constructor of the CSendToPipe 
//				class method
//
//  Arguments:  NONE
//
//  Returns:    NONE 
//
//  History:    MKarki      Created     11/22/97
//
//----------------------------------------------------------------
CSendToPipe::CSendToPipe()
          : m_pIRequestHandler (NULL),
            m_pIRequestSource (NULL),
            m_pIClassFactory (NULL),
            m_pCVSAFilter (NULL),
            m_pCReportEvent (NULL)
{
}   //  end of CSendToPipe constructor

//++--------------------------------------------------------------
//
//  Function:   ~CSendToPipe
//
//  Synopsis:   This is the destructor of the CSendToPipe 
//				class method
//
//  Arguments:  NONE
//
//  Returns:    NONE 
//
//  History:    MKarki      Created     11/22/97
//
//----------------------------------------------------------------
CSendToPipe::~CSendToPipe()
{
   if (m_pIClassFactory)  { m_pIClassFactory->Release(); }

}   //  end of CSendToPipe destructor

//+++-------------------------------------------------------------
//
//  Function:   Process
//
//  Synopsis:   This is the public method of the CSendToPipe class
//              that gets hold of a IRequestRaw interface, puts the
//              data in it and sends it on its way.
//
//  Arguments:  
//              [in]    CPacketRadius*
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     11/22/97
//
//----------------------------------------------------------------
HRESULT
CSendToPipe::Process(
			CPacketRadius *pCPacketRadius
			)
{
    BOOL                    bRetVal = FALSE;
    BOOL                    bStatus = FALSE;
    HRESULT                 hr = S_OK;
    IRequest                *pIRequest = NULL;
    IAttributesRaw          *pIAttributesRaw = NULL;
    PATTRIBUTEPOSITION      pIasAttribPos = NULL;
    DWORD                   dwCount = 0;
    DWORD                   dwRetVal = 0;
    PACKETTYPE              ePacketType;
    IRequestHandler          *pIRequestHandler = m_pIRequestHandler;
     

    _ASSERT (pCPacketRadius);

    __try
    {
        //
        //  check if the pipeline is present to process our 
        //  request
        //
        if (NULL != pIRequestHandler)
        {
            pIRequestHandler->AddRef ();
        }
        else
        {
            //
            //  should never reach here
            //
            _ASSERT (0);
            IASTracePrintf (
                "Unable to send request to backend as request handler "
                "unavailable"
                );
            hr = E_FAIL;
            __leave;
        }
            
        //
        //  create the Request COM object here
        //
        hr = m_pIClassFactory->CreateInstance (
                                NULL,
                                __uuidof (IRequest),
                                reinterpret_cast <PVOID*> (&pIRequest)
                                );
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to create a Request object from class factory "
                "before sending request to backend"
                );
            __leave;
        }

        //
        //  get the packettype
        //
        ePacketType = pCPacketRadius->GetInCode ();
    
        //
        //  get the attributes collection
        //  get the total attributes in the collection
        //  get as many IASATTRIBUTE structs
        //  fill in the IAS attribute structs with the appropriate
        //  values
        //
        dwCount = pCPacketRadius->GetInAttributeCount();
        if (dwCount > 0)
        {
            //
            //  get the attributes collection now
            //
            pIasAttribPos = pCPacketRadius->GetInAttributes ();

            //
            //  if the attribute count is greater than 0 there
            //  should always be attributes around
            //
            _ASSERT (pIasAttribPos);

            //
            // get IAttributesRaw interface
            //
            hr = pIRequest->QueryInterface (
                                __uuidof (IAttributesRaw),
                                reinterpret_cast <PVOID*> (&pIAttributesRaw)
                                );
            if (FAILED (hr))
            {
                IASTracePrintf (
                    "Unable to obtain Attributes interface in request object "
                    "before sending request to backend"
                    );
                __leave;
            }

            //
            //  put the attributes collection into the request
            //
            hr = pIAttributesRaw->AddAttributes (dwCount, pIasAttribPos);
            if (FAILED (hr))
            {
                IASTracePrintf (
                    "Unable to add Attributes to request object "
                    "before sending request to backend"
                    );
                __leave;
            }
        }

        //
        //  set IRequestRaw interface properties
        //
        hr = SetRequestProperties (
                                pIRequest, 
                                pCPacketRadius, 
                                ePacketType
                                );
        if (FAILED (hr)) { __leave; }


        //
        //  convert the VSA attributes into IAS format
        //  
        hr = m_pCVSAFilter->radiusToIAS (pIAttributesRaw);
        if (FAILED (hr))
        {
           if (hr == E_INVALIDARG)
           {
              pCPacketRadius->reportMalformed();
              hr = RADIUS_E_ERRORS_OCCURRED;
           }
             
            IASTracePrintf (
                    "Unable to convert Radius VSAs to IAS attributes in "
                    "request object before sending it to backend"
                    );
           __leave;
        }
        
         
        //
        //  now the packet is ready for sending out
        //
        hr = pIRequestHandler->OnRequest (pIRequest);
        if (FAILED (hr))
        {
            IASTracePrintf ("Unable to send request object to backend");
           __leave;
        }

        //
        //  success
        //
    }
    __finally
    {
        if (pIRequestHandler) {pIRequestHandler->Release ();}
        if (pIAttributesRaw) {pIAttributesRaw->Release();}
        if (pIRequest) {pIRequest->Release();}
    }

    return (hr);

}   //  end of CSendToPipe::Process method

//+++-------------------------------------------------------------
//
//  Function:   Init
//
//  Synopsis:   This is the CSendToPipe class public method which
//              initializes the class object
//
//  Arguments:  
//              [in]   IRequestSource* 
//
//  Returns:    BOOL - status
//
//  History:    MKarki      Created     11/22/97
//
//----------------------------------------------------------------
BOOL CSendToPipe::Init (
        IRequestSource *pIRequestSource,
        VSAFilter      *pCVSAFilter,
        CReportEvent   *pCReportEvent
        )
{
    BOOL    bStatus = TRUE;
    HRESULT hr = S_OK;

    _ASSERT (pIRequestSource && pCReportEvent && pCVSAFilter);

    m_pCReportEvent = pCReportEvent;
    
    m_pCVSAFilter   = pCVSAFilter;

    //
    //  get the IClassFactory interface to be used to create 
    //  the Request COM object
    //  TODO - replace CLSID with __uuidof
    //
    hr = ::CoGetClassObject (
                CLSID_Request,
                CLSCTX_INPROC_SERVER,
                NULL,
                IID_IClassFactory,
                reinterpret_cast  <PVOID*> (&m_pIClassFactory)
                );
    if (FAILED (hr))
    {
        IASTracePrintf (
            "Unable to obtain Request object class factory"
            );
        bStatus = FALSE;
    }
    else
    {
	    m_pIRequestSource = pIRequestSource;  
    }

	return (bStatus);

}   //  end of CSendToPipe::Init method

//+++-------------------------------------------------------------
//
//  Function:   StartProcessing
//
//  Synopsis:   This is the CSendToPipe class public method which
//              gets object ready to send data to the PipeLine
//
//  Arguments:  
//              [in]    IRequestHandler*
//
//  Returns:    BOOL - status
//
//  History:    MKarki      Created     11/22/97
//
//----------------------------------------------------------------
BOOL
CSendToPipe::StartProcessing (
                IRequestHandler *pIRequestHandler
                )
{
    _ASSERT (pIRequestHandler);

    //
    //  set the value of the handler
    //
    m_pIRequestHandler = pIRequestHandler;

    return (TRUE);

}   //  end of CSendToPipe::StartProcessing method

//+++-------------------------------------------------------------
//
//  Function:   StopProcessing
//
//  Synopsis:   This is the CSendToPipe class public method which
//              gets object to stop sending data to the PipeLine
//
//  Arguments:  none
//
//  Returns:    BOOL - status
//
//  History:    MKarki      Created     11/22/97
//
//----------------------------------------------------------------
BOOL
CSendToPipe::StopProcessing (
                VOID
                )
{
    //
    //  set the value of the handlers
    //
    m_pIRequestHandler = NULL;

    return (TRUE);

}   //  end of CSendToPipe::StartProcessing method

//+++-------------------------------------------------------------
//
//  Function:   SetRequestProperties
//
//  Synopsis:   This is the CSendToPipe class public method which
//              set the properties in the IRequestRaw object
//
//  Arguments:  
//              [in]    IRequesetRaw*
//              [in]    CPacketRadius*
//              [in]    PACKETTYPE
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     11/22/97
//
//----------------------------------------------------------------
HRESULT
CSendToPipe::SetRequestProperties (
                IRequest        *pIRequest,
                CPacketRadius   *pCPacketRadius,
                PACKETTYPE      ePacketType
                )
{
    IRequestState   *pIRequestState = NULL;
    IASREQUEST      eRequest;
    IASRESPONSE     eResponse;
    HRESULT         hr = S_OK;

   _ASSERT (pIRequest && pCPacketRadius);

    __try
    {
        //
        //  decide the Request and Response Type
        //
        switch (ePacketType)
        {
        case ACCESS_REQUEST:
            eRequest = IAS_REQUEST_ACCESS_REQUEST;
            eResponse = IAS_RESPONSE_ACCESS_ACCEPT;
            break;
        case ACCOUNTING_REQUEST:
            eRequest = IAS_REQUEST_ACCOUNTING;
            eResponse = IAS_RESPONSE_ACCOUNTING;
             break;
        case ACCESS_ACCEPT:
            eRequest = IAS_REQUEST_PROXY_PACKET;
            eResponse = IAS_RESPONSE_ACCESS_ACCEPT;
            break;
        case ACCOUNTING_RESPONSE:
            eRequest = IAS_REQUEST_PROXY_PACKET;
            eResponse = IAS_RESPONSE_ACCOUNTING;
            break;
        case ACCESS_CHALLENGE:
            eRequest = IAS_REQUEST_PROXY_PACKET;
            eResponse = IAS_RESPONSE_ACCESS_CHALLENGE;
            break;
        default:
            //
            //  should never reach here
            //
            _ASSERT (0);
            IASTracePrintf (
                "Packet of unsupported type:%d, before sending request to "
                "backend",
                static_cast <DWORD> (ePacketType)
                );
                
            hr = E_FAIL;
            __leave;
            break;
        }
            
        //
        //  set the request type now
        // 
        hr = pIRequest->put_Request (eRequest);
        if (FAILED (hr))
        {   
            IASTracePrintf (
                "Unable to set request type in request before sending "
                "it to the backend"
                );
            __leave;    
        }

        //
        //  set the protocol now
        //
        hr = pIRequest->put_Protocol (IAS_PROTOCOL_RADIUS);
        if (FAILED (hr))
        {   
            IASTracePrintf (
                "Unable to set protocol type in request before sending "
                "it to the backend"
                );
            __leave;    
        }

        //
        //  Set source callback
        //
        hr = pIRequest->put_Source (m_pIRequestSource);
        if (FAILED (hr))
        {   
            IASTracePrintf (
                "Unable to set request source type in request before sending "
                "it to the backend"
                );
            __leave;    
        }

        //
        //  get the request state interface to put in our state now
        //  
        //
        hr = pIRequest->QueryInterface (
                                __uuidof (IRequestState),
                                reinterpret_cast <PVOID*> (&pIRequestState)
                                );
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to get RequestState interface from request object "
                "before sending it to the backend"
                );
            __leave;    
        }

        //
        //  put in the request state now
        //
        hr = pIRequestState->Push  (
                    reinterpret_cast <unsigned hyper> (pCPacketRadius)
                    );
        if (FAILED (hr))
        {   
            IASTracePrintf (
                "Unable to set information in request state "
                "before sending request to backend"
                );
            __leave;    
        }

        //
        //  success
        //
    }
    __finally
    {
        if (pIRequestState) { pIRequestState->Release (); }
    }
     
    return (hr);

}   //  end of CSendToPipe::SetRequestProperties method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\valaccess.cpp ===
//#--------------------------------------------------------------
//
//  File:       valaccess.cpp
//
//  Synopsis:   Implementation of CValAccess class methods
//
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "valaccess.h"

//+++--------------------------------------------------------------
//
//  Function:   CValAccess
//
//  Synopsis:   This is the constructor of the CValAccess
//          class
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     9/28/97
//
//----------------------------------------------------------------
CValAccess::CValAccess(
      VOID
       )
{
}  // end of CValAccess constructor

//+++--------------------------------------------------------------
//
//  Function:   ~CValAccess
//
//  Synopsis:   This is the destructor of the CValAccess
//          class
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     9/28/97
//
//----------------------------------------------------------------
CValAccess::~CValAccess(
      VOID
      )
{
}  // end of CValAccess destructor


//+++--------------------------------------------------------------
//
//  Function:   ValidateInPacket
//
//  Synopsis:   This is CValAccess class public method
//          that validates inbound Access Request packet
//
//  Arguments:
//              [in] -  CPacketRadius*
//
//  Returns:    HRESULT -  status
//
//
//  History:    MKarki      Created     9/28/97
//
// Calleed By: CPreValidator::StartInValidation class method
//
//----------------------------------------------------------------
HRESULT
CValAccess::ValidateInPacket(
              CPacketRadius * pCPacketRadius
                )
{
    HRESULT hr = S_OK;
   DWORD dwClientAddress = 0;
   CClient *pCClient = NULL;

    _ASSERT (pCPacketRadius);

   __try
   {
      //
      // validate the attributes
      //
      hr = m_pCValAttributes->Validate (pCPacketRadius);
      if (FAILED (hr)) { __leave; }

        //
        //  validate the Signature present in the packet
        //  if no signature is present this call will return
        //  success
        //
        hr = ValidateSignature (pCPacketRadius);
      if (FAILED (hr)) { __leave; }

      //
      // now give the packet for processing
      //
      hr = m_pCPreProcessor->StartInProcessing (pCPacketRadius);
      if (FAILED (hr)) { __leave; }
   }
   __finally
   {
   }

   return (hr);

}  // end of CValAccess::ValidateInPacket method

//+++-------------------------------------------------------------
//
//  Function:   ValidateSignature
//
//  Synopsis:   This is CValAccesss class private method
//          that carries out validation provided in an
//              inbound RADIUS access request which has a
//              signature attribute
//
//  Arguments:
//              [in]    CPacketRadius*
//
//  Returns:    HRESULT -  status
//
//  History:    MKarki      Created     1/6/98
//
//----------------------------------------------------------------
HRESULT
CValAccess::ValidateSignature (
                    CPacketRadius   *pCPacketRadius
                    )
{
    HRESULT     hr = S_OK;
    BOOL        bStatus = FALSE;
    PBYTE       InPacketSignature[SIGNATURE_SIZE];
    PBYTE       GeneratedSignature [SIGNATURE_SIZE];
    TCHAR       szErrorString [IAS_ERROR_STRING_LENGTH];
    IIasClient  *pIIasClient = NULL;

    __try
    {

        //
        //  get the CClient class object
        //
        hr = pCPacketRadius->GetClient (&pIIasClient);
        if (FAILED (hr)) { __leave; }

        //
        //  get the signature attribute value from the inbound
        //  packet
        //
        if (FALSE ==  pCPacketRadius->GetInSignature (
                            reinterpret_cast <PBYTE> (InPacketSignature)
                            ))
        {
            //
            // check if signature check is required
            //
            BOOL bCheckRequired = pIIasClient->NeedSignatureCheck ();
            if (!bCheckRequired)
            {
                __leave;
            }
            else
            {
                IASTracePrintf (
                    "In-Bound request does not have does not have "
                    "Message Authenticator attribute which is required for this client"
                    );

                //
                //  this is an error, need to silenty discard the
                //  packet
                //

                PCWSTR strings[] = { pCPacketRadius->GetClientName() };
                IASReportEvent (
                    RADIUS_E_SIGNATURE_REQUIRED,
                    1,
                    0,
                    strings,
                    NULL
                    );

                m_pCReportEvent->Process (
                    RADIUS_BAD_AUTHENTICATOR,
                    pCPacketRadius->GetInCode (),
                    pCPacketRadius->GetInLength(),
                    pCPacketRadius->GetInAddress(),
                    NULL,
                    static_cast <LPVOID> (pCPacketRadius->GetInPacket())
                    );
                hr = RADIUS_E_ERRORS_OCCURRED;
                __leave;
            }
        }

        //
        //  generate the signature
        //
        DWORD dwBufSize = SIGNATURE_SIZE;
        hr = pCPacketRadius->GenerateInSignature (
                    reinterpret_cast <PBYTE> (GeneratedSignature),
                    &dwBufSize
                    );
        if (FAILED (hr)) { __leave; }

        //
        //  compare the signature attribute value in packet with
        //  the one present
        //
        if (memcmp(InPacketSignature,GeneratedSignature,SIGNATURE_SIZE))
        {
            //
            //  log error and generate audit event
            //
            IASTracePrintf (
                "Message Authenticator in request packet does not match the "
                "Message Authenticator generated by the server"
                );

            PCWSTR strings[] = { pCPacketRadius->GetClientName() };
            IASReportEvent (
                RADIUS_E_INVALID_SIGNATURE,
                1,
                0,
                strings,
                NULL
                );

            m_pCReportEvent->Process (
                RADIUS_BAD_AUTHENTICATOR,
                pCPacketRadius->GetInCode (),
                pCPacketRadius->GetInLength(),
                pCPacketRadius->GetInAddress(),
                NULL,
                static_cast <LPVOID> (pCPacketRadius->GetInPacket())
                );
            hr = RADIUS_E_ERRORS_OCCURRED;
            __leave;
        }

        //
        //  success
        //
    }
    __finally
    {
        if (pIIasClient) { pIIasClient->Release (); }
    }

    return (hr);

}   //  end of CValAccess::ValidateSignature method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\tunnelpassword.cpp ===
//#--------------------------------------------------------------
//
//  File:       tunnelpassword.cpp
//
//  Synopsis:   Implementation of CTunnelPassword class methods
//
//
//  History:     04/16/98  MKarki Created
//
//    Copyright (C) Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "tunnelpassword.h"
#include "align.h"
#include "iastlutl.h"
#include "radpack.h"
using namespace IASTL;

const DWORD MAX_TUNNELPASSWORD_LENGTH =
    (MAX_ATTRIBUTE_LENGTH/AUTHENTICATOR_SIZE)*AUTHENTICATOR_SIZE;


//////////
// Extracts the Vendor-Type field from a Microsoft VSA. Returns zero if the
// attribute is not a valid Microsoft VSA.
//////////
BYTE
WINAPI
ExtractMicrosoftVendorType(
    const IASATTRIBUTE& attr
    ) throw ()
{
   if (attr.Value.itType == IASTYPE_OCTET_STRING &&
       attr.Value.OctetString.dwLength > 6 &&
       !memcmp(attr.Value.OctetString.lpValue, "\x00\x00\x01\x37", 4))
   {
      return *(attr.Value.OctetString.lpValue + 4);
   }

   return (BYTE)0;
}

//////////
// Encrypts the vendor specific attributes in a request.
//////////
HRESULT EncryptVSAs(
            const CPacketRadius& packet,
            IAttributesRaw* request
            ) throw ()
{
   try
   {
      IASAttributeVectorWithBuffer<16> attrs;
      attrs.load(request, RADIUS_ATTRIBUTE_VENDOR_SPECIFIC);

      for (IASAttributeVector::iterator i = attrs.begin();
           i != attrs.end();
           ++i)
      {
         if (i->pAttribute->Value.OctetString.dwLength <= 253)
         {
            RadiusAttribute attr =
            {
               RADIUS_VENDOR_SPECIFIC,
               static_cast<BYTE>(i->pAttribute->Value.OctetString.dwLength),
               i->pAttribute->Value.OctetString.lpValue
            };

            CryptParameters parms;
            GetCryptParameters(attr, parms);

            if (parms.encrypted)
            {
               packet.cryptBuffer(
                         TRUE,
                         parms.salted,
                         attr.value + parms.offset,
                         attr.length - parms.offset
                         );
            }
         }
      }
   }
   catch (const _com_error& ce)
   {
      return ce.Error();
   }

   return S_OK;
}


//++--------------------------------------------------------------
//
//  Function:   Process
//
//  Synopsis:   This is the CTunnelPassword class public method
//              responsible for encrypting the Tunnel Passwords
//              present in an out-bound RADIUS packet
//
//  Arguments:
//              PACKETTYPE      - Radius packet type
//              IAttributesRaw*
//              CPacketRadius*
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     04/16/98
//
//----------------------------------------------------------------
HRESULT
CTunnelPassword::Process (
    PACKETTYPE          ePacketType,
    IAttributesRaw      *pIAttributesRaw,
    CPacketRadius       *pCPacketRadius
    )
{
    HRESULT             hr = S_OK;
    DWORD               dwCount = 0;
    DWORD               dwAttributeCount = 0;
    DWORD               dwTunnelAttributeCount = 0;
    static DWORD        dwTunnelPasswordType =  TUNNEL_PASSWORD_ATTRIB;
    PATTRIBUTE          pAttribute = NULL;
    PATTRIBUTEPOSITION  pAttribPos = NULL;

    _ASSERT (pIAttributesRaw && pCPacketRadius);

    __try
    {
        //
        //  the tunnel-password attribute only goes
        //  into an access-accept packet
        //
        if (ACCESS_ACCEPT != ePacketType) { __leave; }

        // Encrypt the MPPE keys.
        hr = EncryptVSAs(*pCPacketRadius, pIAttributesRaw);
        if (FAILED(hr)) { __leave; }

        //
        //  get the count of the total attributes in the collection
        //
        hr = pIAttributesRaw->GetAttributeCount (&dwAttributeCount);
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to obtain attribute count in request "
                "while processing tunnel-password"
                );
            __leave;
        }
        else if (0 == dwAttributeCount)
        {
            __leave;
        }

        //
        //  allocate memory for the ATTRIBUTEPOSITION array
        //
        pAttribPos = reinterpret_cast <PATTRIBUTEPOSITION> (
                        CoTaskMemAlloc (
                             sizeof (ATTRIBUTEPOSITION)*dwAttributeCount));
        if (NULL == pAttribPos)
        {
            IASTracePrintf (
                "Unable to allocate memory for attribute position array "
                "while processing tunnel-password"
                );
            hr = E_OUTOFMEMORY;
            __leave;
        }

        //
        //  get the Tunnel-Password attributes from
        //  the collection
        //
        dwTunnelAttributeCount = dwAttributeCount;
       hr = pIAttributesRaw->GetAttributes (
                        &dwTunnelAttributeCount,
                        pAttribPos,
                        1,
                        &dwTunnelPasswordType
                        );
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to get attributes from request "
                "while processing tunnel-password"
                );
            __leave;
        }
        else if (0 == dwTunnelAttributeCount)
        {
            __leave;
        }


        //
        //  remove the Tunnel-Password attributes from the collection
        //
        hr = pIAttributesRaw->RemoveAttributes (
                                    dwTunnelAttributeCount,
                                    pAttribPos
                                       );
        if (FAILED (hr))
        {
            IASTracePrintf (
                "Unable to remove attributes from request "
                "while processing tunnel-password"
                );
            __leave;
        }

        //
        //  now process the Tunnel-Password attributes

        for (DWORD i = 0; i < dwTunnelAttributeCount; ++i)
        {
           hr =  EncryptTunnelPassword (
                                   pCPacketRadius,
                                   pIAttributesRaw,
                                   pAttribPos[i].pAttribute
                                   );
           if (FAILED (hr)) { __leave; }
        }

    }
    __finally
    {
        //
        // release all the Tunnel Attributes now
        //
        for (dwCount = 0; dwCount < dwTunnelAttributeCount; dwCount++)
        {
            ::IASAttributeRelease (pAttribPos[dwCount].pAttribute);
        }

        //
        //  free the dynamically allocated memory
        //
        if (pAttribPos) { CoTaskMemFree (pAttribPos); }
    }

    return (hr);

}   //  end of CRecvFromPipe::TunnelPasswordSupport method

//++--------------------------------------------------------------
//
//  Function:   EncryptPassword
//
//  Synopsis:   This is the CTunnelPassword class private method
//              responsible for encrypting the Tunnel Password
//              present in an out-bound RADIUS packet. The Encrypted
//              password is put in an IAS attribute which is added
//              to the attribute collection of the outbound request.
//
//  Arguments:
//              CPacketRadius*
//              IAttributesRaw*
//              PIASATTRIBUTE
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     04/16/98
//
//----------------------------------------------------------------
HRESULT
CTunnelPassword::EncryptTunnelPassword (
            CPacketRadius   *pCPacketRadius,
            IAttributesRaw  *pIAttributesRaw,
            PIASATTRIBUTE   plaintext
            )
{
   // Extract the password.
   const IAS_OCTET_STRING& pwd = plaintext->Value.OctetString;

   // We must have at least 4 bytes.
   if (pwd.dwLength < 4) { return E_INVALIDARG; }

   // How many bytes do we need including padding.
   ULONG nbyte = ROUND_UP_COUNT(pwd.dwLength - 3, 16) + 3;
   if (nbyte > 253) { return E_INVALIDARG; }

   // Create a new IASATTRIBUTE for the encrypted value.
   PIASATTRIBUTE encrypted;
   if (IASAttributeAlloc(1, &encrypted)) { return E_OUTOFMEMORY; }
   encrypted->dwId = RADIUS_ATTRIBUTE_TUNNEL_PASSWORD;
   encrypted->dwFlags = plaintext->dwFlags;
   encrypted->Value.itType = IASTYPE_OCTET_STRING;
   encrypted->Value.OctetString.dwLength = nbyte;
   encrypted->Value.OctetString.lpValue = (PBYTE)CoTaskMemAlloc(nbyte);

   HRESULT hr;
   PBYTE val = encrypted->Value.OctetString.lpValue;
   if (val)
   {
      // Copy in the value.
      memcpy(val, pwd.lpValue, pwd.dwLength);

      // Zero out the padding.
      memset(val + pwd.dwLength, 0, nbyte - pwd.dwLength);

      // Encrypt the password.
      pCPacketRadius->cryptBuffer(
                          TRUE,
                          TRUE,
                          val + 1,
                          nbyte - 1
                          );

      // Add the encrypted attribute to the request.
      ATTRIBUTEPOSITION pos;
      pos.pAttribute = encrypted;
      hr = pIAttributesRaw->AddAttributes(1, &pos);
   }
   else
   {
      hr = E_OUTOFMEMORY;
   }

   // Release the encrypted password.
   IASAttributeRelease(encrypted);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\valaccess.h ===
//#--------------------------------------------------------------
//        
//  File:       valaccess.h
//        
//  Synopsis:   This file holds the declarations of the 
//				CValAccess class
//              
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _VALACCESS_H_
#define _VALACCESS_H_

#include "packetradius.h"
#include "validator.h"
#include "valattrib.h"
#include "clients.h"
	
//#include "preprocessor.h"	

class CValAccess : public CValidator  
{
public:

    //
    //  this method validates the inbound RADIUS packet
    //
	virtual HRESULT ValidateInPacket (
			/*[in]*/	CPacketRadius *pCPacketRadius
			);

    //
    //  constructor
    //
	CValAccess(VOID);
	
    //
    //  destructor
    //
	virtual ~CValAccess(VOID);

private:

    //
    //  this method validates  the signature attribute received
    //  in an access request
    //
    HRESULT ValidateSignature (
                /*[in]*/    CPacketRadius   *pCPacketRadius
                );

};


#endif //	#ifndef _VALACCESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\valacct.h ===
//#--------------------------------------------------------------
//        
//  File:       valacct.h
//        
//  Synopsis:   This file holds the declarations of the 
//				CValAccounting class
//              
//
//  History:     10/20/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _VALACCT_H_ 
#define _VALACCT_H_

#include "packetradius.h"
#include "validator.h"
#include "hashmd5.h"
#include "sendtopipe.h"

class CValidator;

class CValAccounting : public CValidator
{

public:

    //
    //  validates the inbound RADIUS packet
    //
	HRESULT ValidateInPacket(
                /*[in]*/    CPacketRadius *pCPacketRadius
                );

    //
    //  constructor
    //
	CValAccounting();

    //
    //  destructor
    //
	virtual ~CValAccounting();

private:

    //
    //  authenticates the inbound RADIUS packet
    //
    HRESULT AuthenticatePacket (
                /*[in]*/        CPacketRadius   *pCPacketRadius
                );
};

#endif // ifndef _VALACCT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\valattrib.h ===
//#--------------------------------------------------------------
//        
//  File:       valattrib.h
//        
//  Synopsis:   This file holds the declarations of the 
//				valattrib class
//              
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------

#ifndef _VALATTRIB_H_
#define _VALATTRIB_H_

#include "dictionary.h"	
#include "reportevent.h"
#include "packetradius.h"

class CValAttributes  
{

public:

	HRESULT Validate(
                /*[in]*/    CPacketRadius *pCPacketRadius
                );
	BOOL Init (
            /*[in]*/    CDictionary     *pCDictionary,
            /*[in]*/    CReportEvent    *pCReportEvent
            );
	CValAttributes(VOID);

	virtual ~CValAttributes(VOID);

private:

	CDictionary     *m_pCDictionary;

    CReportEvent    *m_pCReportEvent;
};

#endif // ifndef _VALATTRIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\valattrib.cpp ===
//#--------------------------------------------------------------
//
//  File:       valattrib.cpp
//
//  Synopsis:   Implementation of CValAttributes class methods
//              The class is responsible for taking the attributes
//              in a RADIUS packet and validating their type and
//              value
//
//  History:     11/22/97  MKarki Created
//
//    Copyright (C) Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "valattrib.h"

//+++-------------------------------------------------------------
//
//  Function:   CValAttributes
//
//  Synopsis:   This is the constructor of the CValAttributes
//            class
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//  History:    MKarki      Created     11/22/97
//
//----------------------------------------------------------------
CValAttributes::CValAttributes(
                     VOID
                     )
            :m_pCDictionary (NULL)
{
}   //   end of CValAttributes constructor

//+++-------------------------------------------------------------
//
//  Function:   ~CValAttributes
//
//  Synopsis:   This is the destructor of the CValAttributes
//              class
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//  History:    MKarki      Created     11/22/97
//
//----------------------------------------------------------------
CValAttributes::~CValAttributes(
                     VOID
                     )
{
}   //   end of CValAttributes destructor


//+++-------------------------------------------------------------
//
//  Function:   Init
//
//  Synopsis:   This is the CValAttributes public method used
//              to intialize the class object
//
//  Arguments:
//              [in]     CDictionary*
//
//  Returns:    BOOL - status
//
//  History:    MKarki      Created     11/22/97
//
//----------------------------------------------------------------
BOOL CValAttributes::Init(
            CDictionary     *pCDictionary,
            CReportEvent    *pCReportEvent
            )
{
   BOOL   bRetVal = FALSE;

    _ASSERT (pCDictionary && pCReportEvent);

    m_pCDictionary = pCDictionary;

    m_pCReportEvent = pCReportEvent;

   return (TRUE);

}   //   end of CValAttributes::Init method

//+++-------------------------------------------------------------
//
//  Function:   Validate
//
//  Synopsis:   This is the CValAttributes public method used
//              to validate the packet attributes
//
//  Arguments:
//              [in]     CPacketRadius*
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     11/22/97
//
//----------------------------------------------------------------
HRESULT
CValAttributes::Validate (
        CPacketRadius *pCPacketRadius
        )
{
   // We only care about Access-Requests.
   if (pCPacketRadius->GetInCode() == ACCESS_REQUEST)
   {
      // We're looking for the Signature and EAP-Message attributes.
      BOOL hasSignature = FALSE, hasEapMessage = FALSE;

      // Loop through the attributes.
      PATTRIBUTEPOSITION p, end;
      p   = pCPacketRadius->GetInAttributes();
      end = p + pCPacketRadius->GetInRadiusAttributeCount();
      for ( ; p != end; ++p)
      {
         if (p->pAttribute->dwId == RADIUS_ATTRIBUTE_SIGNATURE)
         {
            hasSignature = TRUE;
         }
         else if (p->pAttribute->dwId == RADIUS_ATTRIBUTE_EAP_MESSAGE)
         {
            hasEapMessage = TRUE;
         }
      }

      // If EAP-Message is present, then Signature must be as well.
      if (hasEapMessage && !hasSignature)
      {
         IASTraceString("Message Authenticator must accompany EAP-Message.");

         // Generate audit event.
         PCWSTR strings[] = { pCPacketRadius->GetClientName() };
         IASReportEvent(
             RADIUS_E_NO_SIGNATURE_WITH_EAP_MESSAGE,
             1,
             0,
             strings,
             NULL
             );

         m_pCReportEvent->Process (
                              RADIUS_MALFORMED_PACKET,
                              pCPacketRadius->GetInCode(),
                              pCPacketRadius->GetInLength(),
                              pCPacketRadius->GetInAddress(),
                              NULL,
                              pCPacketRadius->GetInPacket()
                              );

         return RADIUS_E_ERRORS_OCCURRED;
      }
   }

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\valacct.cpp ===
//#--------------------------------------------------------------
//
//  File:        valacct.cpp
//
//  Synopsis:   Implementation of CValAccounting class methods
//
//
//  History:     10/20/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "valacct.h"

namespace {
   BYTE NULL_AUTHENTICATOR[AUTHENTICATOR_SIZE];
}

//++--------------------------------------------------------------
//
//  Function:   CValAccounting
//
//  Synopsis:   This is CValAccounting class constructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     10/20/97
//
//----------------------------------------------------------------
CValAccounting::CValAccounting()
{
}   //  end of CValAccounting class constructor

//++--------------------------------------------------------------
//
//  Function:   CValAccounting
//
//  Synopsis:   This is CValAccounting class destructor
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     10/20/97
//
//----------------------------------------------------------------
CValAccounting::~CValAccounting()
{
}   //  end of CValAccounting class destructor

//++--------------------------------------------------------------
//
//  Function:   ValidateInPacket
//
//  Synopsis:   This is CValAccounting class public method
//              which carries out the validation of an inbound
//              RADIUS accounting packet
//
//  Arguments:
//              [in]        CPacketRadius*
//
//  Returns:    HRESULT - status
//
//  History:    MKarki      Created     10/20/97
//
//  Called By:  CPreValidator::StartInValidation class method
//
//++--------------------------------------------------------------
HRESULT
CValAccounting::ValidateInPacket (
                        CPacketRadius *pCPacketRadius
                        )
{
    HRESULT  hr = S_OK;
    DWORD    dwClientAddress = 0;
    CClient *pCClient = NULL;

    _ASSERT (pCPacketRadius);

    __try
    {
        //
        //  get the packet authenticated
        //
        hr = AuthenticatePacket (pCPacketRadius);
        if (FAILED (hr)) {__leave; }


        //
        // validate the attributes
        //
        hr = m_pCValAttributes->Validate (pCPacketRadius);
        if (FAILED (hr)) { __leave; }

        //
        // now give the packet for processing
        //
        hr = m_pCPreProcessor->StartInProcessing (pCPacketRadius);
        if (FAILED (hr)) { __leave; }

        //
        //    we have successfully done the processing here
        //
    }
    __finally
    {
    }

    return (hr);

}    //    end of CValAccounting::ValidateInPacket method

//++--------------------------------------------------------------
//
//  Function:   AuthenticatePacket
//
//  Synopsis:   This is CValAccounting class private method
//                that authenticates the packet, by generating a
//              request authenticator with the packet and then
//              comparing it with the authenticator in the packet
//
//  Arguments:  [in]    -    CPacketRadius*
//
//  Returns:    HRESULT -    status
//
//  History:    MKarki      Created     10/21/97
//
//    Called By: CValAccounting::ProcessInPacket method
//
//----------------------------------------------------------------
HRESULT
CValAccounting::AuthenticatePacket (
                        CPacketRadius   *pCPacketRadius
                        )
{
    BYTE    InAuthenticator [AUTHENTICATOR_SIZE];
    BYTE    OutAuthenticator[AUTHENTICATOR_SIZE];
    BOOL    bStatus = FALSE;
    HRESULT hr = S_OK;

    _ASSERT (pCPacketRadius);

    __try
    {
        //
        //  the request authenticator is all zero's for calculating
        //  the actual authenticator
        //
        ZeroMemory (InAuthenticator, AUTHENTICATOR_SIZE);

        //
        //  now calculate the request authenticator
        //
        bStatus = pCPacketRadius->GenerateInAuthenticator (
                        reinterpret_cast <PBYTE>  (&InAuthenticator),
                        reinterpret_cast <PBYTE>  (&OutAuthenticator)
                        );
        if (FALSE == bStatus)
        {
            hr = E_FAIL;
            __leave;
        }

        //
        //  get the request authenticator from the  packet
        //
        DWORD   dwBufSize = AUTHENTICATOR_SIZE;
        hr = pCPacketRadius->GetInAuthenticator (
                        reinterpret_cast <PBYTE> (InAuthenticator),
                        &dwBufSize
                        );
        if (FAILED (hr)) { __leave; }

        //
        //  now compare the authenticator we just generated with the
        //  the one sent in the packet
        //
        if (memcmp (InAuthenticator,OutAuthenticator,AUTHENTICATOR_SIZE) != 0)
        {
           // Is the authenticator all zeros?
           if (!memcmp(
                    InAuthenticator,
                    NULL_AUTHENTICATOR,
                    AUTHENTICATOR_SIZE
                    ))
           {
              // Yes, so check for a zero length shared secret.
              IIasClient* client;
              hr = pCPacketRadius->GetClient(&client);
              if (SUCCEEDED(hr))
              {
                 DWORD secretSize;
                 client->GetSecret(&secretSize);

                 client->Release();

                 if (secretSize == 0)
                 {
                    // Zero-length shared secret AND all zero authenticator.
                    __leave;
                 }
              }
           }

            IASTracePrintf (
                "In correct authenticator in the accounting packet..."
                );
            //
            //  generate an Audit event
            //
            PCWSTR strings[] = { pCPacketRadius->GetClientName() };
            IASReportEvent(
                RADIUS_E_BAD_AUTHENTICATOR,
                1,
                0,
                strings,
                NULL
                );

            m_pCReportEvent->Process (
                RADIUS_BAD_AUTHENTICATOR,
                pCPacketRadius->GetInCode (),
                pCPacketRadius->GetInLength (),
                pCPacketRadius->GetInAddress (),
                NULL,
                static_cast <LPVOID> (pCPacketRadius->GetInPacket())
                );
            hr = RADIUS_E_ERRORS_OCCURRED;
            __leave;
        }

        //
        //  success
        //
    }
    __finally
    {
    }

    return (hr);

}   //  end of CValAccounting::AuthenticatePacket method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\validator.cpp ===
//#--------------------------------------------------------------
//        
//  File:		validator.cpp
//        
//  Synopsis:   Implementation of CValidator class methods
//              
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "validator.h"

//++--------------------------------------------------------------
//
//  Function:   CValidator
//
//  Synopsis:   This is the constructor of the CValidator class
//
//  Arguments:  NONE
//
//  Returns:    NONE 
//
//
//  History:    MKarki      Created     9/26/97
//
//----------------------------------------------------------------
CValidator::CValidator()
{
}   //  end of CValidator class constructor

//++--------------------------------------------------------------
//
//  Function:   ~CValidator
//
//  Synopsis:   This is the destructor of the CValidator class
//
//  Arguments:  NONE
//
//  Returns:    NONE 
//
//
//  History:    MKarki      Created     9/26/97
//
//----------------------------------------------------------------
CValidator::~CValidator()
{
    return;
}

//++--------------------------------------------------------------
//
//  Function:   ValidateInPacket
//
//  Synopsis:   This is the CValidator class public method which
//              validates the inbound RADIUS packet
//
//  Arguments:  NONE
//
//  Returns:    NONE 
//
//
//  History:    MKarki      Created     9/26/97
//
//----------------------------------------------------------------
HRESULT CValidator::ValidateInPacket(
                    CPacketRadius * pCPacketRadius
                    )
{
	return (S_OK);
}

//++--------------------------------------------------------------
//
//  Function:   ValidateInPacket
//
//  Synopsis:   This is the CValidator class public method which
//              validates the outbound RADIUS packet
//
//  Arguments:  NONE
//
//  Returns:    NONE 
//
//
//  History:    MKarki      Created     9/26/97
//
//----------------------------------------------------------------
HRESULT
CValidator::ValidateOutPacket(
                    CPacketRadius * pCPacketRadius
                    )
{
    HRESULT hr = S_OK;
	DWORD	dwClientAddress = 0;
	CClient *pCClient = NULL;

    _ASSERT (pCPacketRadius);
	
	__try
	{
			
		//
		// validate the attributes
		//
	    hr  = m_pCValAttributes->Validate (pCPacketRadius);
		if (FAILED (hr)) { __leave; }

		//
		// now give the packet for processing
		//
		hr = m_pCPreProcessor->StartOutProcessing (pCPacketRadius);
		if (FAILED (hr)) { __leave; }
	}
	__finally
	{
		//
		//	nothing here for now
		//
	}

	return (hr);
}

//++--------------------------------------------------------------
//
//  Function:   Init
//
//  Synopsis:   This is the intialization code
//
//  Arguments:  NONE
//
//  Returns:    NONE 
//
//
//  History:    MKarki      Created     9/28/97
//
//	Calleed By:	CPreValidator class method
//
//----------------------------------------------------------------
BOOL 
CValidator::Init(
        CValAttributes		 *pCValAttributes,
        CPreProcessor        *pCPreProcessor,
        CClients             *pCClients,
        CHashMD5             *pCHashMD5,
        CReportEvent         *pCReportEvent
        )
{
    _ASSERT (
            (NULL != pCValAttributes)  &&
            (NULL != pCPreProcessor)   &&
            (NULL != pCClients)        &&
            (NULL != pCHashMD5)        &&
            (NULL != pCReportEvent)
            );

    //
    // assign values now
    //
    m_pCValAttributes = pCValAttributes;
    m_pCPreProcessor = pCPreProcessor;
    m_pCClients = pCClients;
    m_pCHashMD5 = pCHashMD5;
    m_pCReportEvent = pCReportEvent;

	return (TRUE);

}   //  end of CValidator::Init method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\validator.h ===
//#--------------------------------------------------------------
//        
//  File:       validator.h
//        
//  Synopsis:   This file holds the declarations of the 
//				validator class
//              
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-98 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _VALIDATOR_H_
#define _VALIDATOR_H_
 
#include "packetradius.h"
#include "valattrib.h"
#include "clients.h"
#include "hashmd5.h"
#include "reportevent.h"
#include "preprocessor.h"

class CValidator  
{
public:
    
    virtual BOOL Init (
                    /*[in]*/    CValAttributes		  *pCValAttributes,
                    /*[in]*/    CPreProcessor         *pCPreProcessor,
                    /*[in]*/    CClients              *pCClients,
					/*[in]*/	CHashMD5			  *pCHashMD5,
                    /*[in]*/    CReportEvent          *pCReportEvent
                    );
	virtual HRESULT ValidateOutPacket (
                    /*[in]*/    CPacketRadius *pCPacketRadius
                    );
	virtual HRESULT ValidateInPacket (
                    /*[in]*/    CPacketRadius *pCPacketRadius
                    );
	CValidator();

	virtual ~CValidator();

    CPreProcessor			 *m_pCPreProcessor;

    CValAttributes			 *m_pCValAttributes;

    CClients				 *m_pCClients;

    CHashMD5		         *m_pCHashMD5;
    
    CReportEvent             *m_pCReportEvent; 
};

#endif // ifndef _VALIDATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\valproxy.h ===
//#--------------------------------------------------------------
//        
//  File:       valproxy.h
//        
//  Synopsis:   This file holds the declarations of the 
//				CValProxy class
//              
//
//  History:     10/14/97  MKarki Created
//
//    Copyright (C) 1997-2001 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _VALPRXYPKT_H_
#define _VALPRXYPKT_H_

#include "packetradius.h"
#include "validator.h"
#include "valattrib.h"
#include "clients.h"	
#include "hashmd5.h"
#include "preprocessor.h"
#include "valproxy.h"
#include "sendtopipe.h"

class CReportEvent;

class CValProxy : public CValidator  
{

public:

    BOOL Init (
			/*[in]*/		CValAttributes		 *pCValAttributes,
			/*[in]*/		CPreProcessor		 *pCPreProcessor,
            /*[in]*/		CClients			 *pCClients,
            /*[in]*/        CHashMD5             *pCHashMD5,
            /*[in]*/        CSendToPipe          *pCSendToPipe,
            /*[in]*/        CReportEvent         *pCReportEvent
			);
	virtual HRESULT ValidateOutPacket (
			/*[in]*/	CPacketRadius *pCPacketRadius
			);
	virtual HRESULT ValidateInPacket (
			/*[in]*/     	CPacketRadius *pCPacketRadius
			);

	CValProxy(VOID);
	
	virtual ~CValProxy(VOID);

private:

	HRESULT AuthenticatePacket (
                /*[in]*/    CPacketRadius   *pCPacketRadius,
                /*[in]*/    PBYTE           pbyAuthenticator
                );

    CSendToPipe *m_pCSendToPipe;
};


#endif //	#ifndef _VALPRXYPKT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\valproxy.cpp ===
//#--------------------------------------------------------------
//
//  File:       valproxy.cpp
//
//  Synopsis:   Implementation of CValProxy class methods
//
//
//  History:     9/23/97  MKarki Created
//
//    Copyright (C) 1997-2001 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "radcommon.h"
#include "valproxy.h"
#include "radpkt.h"

//++--------------------------------------------------------------
//
//  Function:   CValProxy
//
//  Synopsis:   This is the constructor of the CValProxy
//            class
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     9/28/97
//
//----------------------------------------------------------------
CValProxy::CValProxy(
             VOID
            )
         :  m_pCSendToPipe (NULL)
{
}   //   end of CValProxy constructor

//++--------------------------------------------------------------
//
//  Function:   ~CValProxy
//
//  Synopsis:   This is the destructor of the CValProxy
//            class
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//
//  History:    MKarki      Created     9/28/97
//
//----------------------------------------------------------------
CValProxy::~CValProxy(
             VOID
            )
{
}   //   end of CValProxy destructor

//++--------------------------------------------------------------
//
//  Function:   Init
//
//  Synopsis:   This is the CValProxy public method used
//              in initialization of the class object
//
//  Arguments:  NONE
//
//  Returns:    status
//
//
//  History:    MKarki      Created     9/28/97
//
//----------------------------------------------------------------
BOOL
CValProxy::Init (
                  CValAttributes       *pCValAttributes,
                  CPreProcessor       *pCPreProcessor,
                  CClients          *pCClients,
                        CHashMD5             *pCHashMD5,
                        CSendToPipe          *pCSendToPipe,
                        CReportEvent         *pCReportEvent
                  )
{
    BOOL    bRetVal = FALSE;
   BOOL   bStatus = FALSE;

    __try
    {

        //
        //  call the base classes init method
        //
       bStatus = CValidator::Init (
                     pCValAttributes,
                     pCPreProcessor,
                            pCClients,
                            pCHashMD5,
                            pCReportEvent
                     );
       if (FALSE == bStatus) { __leave; }


        //
        //  set the proxy state
        //
        m_pCSendToPipe = pCSendToPipe;

        //
        // initalization complete
        //
        bRetVal = TRUE;
    }
    __finally
    {
        //
        //  nothing here for now
        //
    }

    return (bRetVal);

}   //  end of CValProxy::Init method

//++--------------------------------------------------------------
//
//  Function:   ValidateInPacket
//
//  Synopsis:   This is CValProxy class public method
//            that validates inbound Access Request packet
//
//  Arguments:  [IN]   -   CPacketRadius*
//
//  Returns:    HRESULT -   status
//
//
//  History:    MKarki      Created     9/28/97
//
//   Calleed By:   CPreValidator class method
//
//----------------------------------------------------------------
HRESULT
CValProxy::ValidateInPacket(
                CPacketRadius * pCPacketRadius
              )
{
   BOOL bRetVal = FALSE;
   HRESULT hr = S_OK;
   __try
   {
      //
      // validate the attributes
      //
      hr = m_pCValAttributes->Validate (pCPacketRadius);
      if (FAILED(hr)) { __leave; }

      //
      //  authenticate packet now
      //

      BYTE ReqAuthenticator[AUTHENTICATOR_SIZE];
      hr = AuthenticatePacket (
                            pCPacketRadius,
                            ReqAuthenticator
                            );
      if (FAILED(hr)) { __leave; }


      //
      // now give the packet for processing
      //
      hr = m_pCPreProcessor->StartInProcessing (pCPacketRadius);
      if (FAILED(hr)) { __leave; }

      //
      // successfully processed packet
      //
      bRetVal = TRUE;
   }
   __finally
   {
      //
      // nothing here for now
      //
   }

   if (bRetVal)
   {
      return S_OK;
   }
   else
   {
      if (FAILED(hr))
      {
         return hr;
      }
      else
      {
         return E_FAIL;
      }
   }
}  // end of CValProxy::ValidateInPacket method


//++--------------------------------------------------------------
//
//  Function:   ValidateOutPacket
//
//  Synopsis:   This is CValProxy class public method
//            that validates outbound Access Request packet
//
//  Arguments:  NONE
//
//  Returns:    HRESULT - status
//
//
//  History:    MKarki      Created     9/28/97
//
//   Calleed By:   CPreValidator class method
//
//----------------------------------------------------------------
HRESULT
CValProxy::ValidateOutPacket(
                     CPacketRadius * pCPacketRadius
                     )
{
   return S_OK;
}   //   end of CValProxy::ValidateOutPacket method


//++--------------------------------------------------------------
//
//  Function:   AuthenticatePacket
//
//  Synopsis:   This is CValProxy class private method
//            that authenticates the packet, by generating a
//              response authenticator with the packet and then
//              comparing it with the request authenticator
//
//  Arguments:  [in]   -   CPacketRadius*
//
//  Returns:    BOOL   -   status
//
//
//  History:    MKarki      Created     9/28/97
//
//   Called By: CValProxy::ValidateInPacket method
//
//----------------------------------------------------------------
HRESULT
CValProxy::AuthenticatePacket (
                        CPacketRadius   *pCPacketRadius,
                        PBYTE           pbyAuthenticator
                        )
{
    BOOL            bRetVal = FALSE;
    BOOL            bStatus = FALSE;
    PRADIUSPACKET   pPacketRadius = NULL;
    DWORD           dwPacketHeaderSize = 0;
    DWORD           dwAttributesLength = 0;
    BYTE            HashResult[AUTHENTICATOR_SIZE];
    IIasClient      *pIIasClient = NULL;
    HRESULT         hr = S_OK;

    __try
    {
        //
        //  check that the arguments passed in are correct
        //
        if ((NULL == pCPacketRadius) || (NULL == pbyAuthenticator))
            __leave;

        //
        //  get a pointer to the raw packet
        //
      pPacketRadius = reinterpret_cast <PRADIUSPACKET>
                            (pCPacketRadius->GetInPacket ());

        //
        //  get the size of the packet without the attributes and
        //  request authenticator
        //
        dwPacketHeaderSize = sizeof (RADIUSPACKET)
                             - sizeof (BYTE)
                             - AUTHENTICATOR_SIZE;

        //
        //  get the total attributes length now
        //
        dwAttributesLength = ntohs (pPacketRadius->wLength)
                            - (dwPacketHeaderSize +  AUTHENTICATOR_SIZE);


        //
        //  get the CClients object
        //
        hr = pCPacketRadius->GetClient (&pIIasClient);
        if (FAILED (hr)) { __leave; }

        //
        //  get the shared secret from the client object
        //
        DWORD dwSecretSize;
        const BYTE* bySecret = pIIasClient->GetSecret(&dwSecretSize);

        //
        // do the hashing here
        //
        m_pCHashMD5->HashIt (
                            reinterpret_cast <PBYTE> (&HashResult),
                            NULL,
                            0,
                            reinterpret_cast <PBYTE> (pPacketRadius),
                            dwPacketHeaderSize,
                            pbyAuthenticator,
                            AUTHENTICATOR_SIZE,
                            pPacketRadius->AttributeStart,
                            dwAttributesLength,
                            const_cast<BYTE*>(bySecret),
                            dwSecretSize,
                            0,
                            0
                            );

        if (memcmp (
                HashResult,
                pPacketRadius->Authenticator,
                AUTHENTICATOR_SIZE
                )
            != 0
            )
            __leave;


        //
        //   we have successfully authenticated this packet
        //
        bRetVal = TRUE;


    }
    __finally
    {
        if (NULL != pIIasClient)
        {
            pIIasClient->Release ();
        }
    }


    return S_OK;
}   //  end of CValProxy::AuthenticatePacket method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\vsadnary.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    vsadnary.h
//
// SYNOPSIS
//
//    This file declares the class VSADictionary.
//
// MODIFICATION HISTORY
//
//    03/07/1998    Original version.
//    09/16/1998    Add additional fields to VSA definition.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _VSADNARY_H_
#define _VSADNARY_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <hashmap.h>
#include <iaspolcy.h>
#include <nocopy.h>

//////////
// Struct representing an entry in the dictionary.
//////////
struct VSADef
{
   DWORD vendorID;           // RADIUS Vendor-Id.
   DWORD vendorType;         // RADIUS Vendor-Type.
   DWORD vendorTypeWidth;    // Width in bytes of the Vendor-Type field.
   DWORD vendorLengthWidth;  // Width in bytes of the Vendor-Length field.
   DWORD iasID;              // IAS protocol-independent attribute ID.
   IASTYPE iasType;          // The IAS attribute syntax.

   /////////
   // Functors used for indexing VSADef objects.
   /////////

   struct HashByIAS {
      DWORD operator()(const VSADef& v) const throw ()
      { return v.iasID; }
   };

   struct EqualByIAS {
      bool operator()(const VSADef& lhs, const VSADef& rhs) const throw ()
      { return lhs.iasID == rhs.iasID; }
   };

   struct HashByRADIUS {
      DWORD operator()(const VSADef& v) const throw ()
      { return v.vendorID ^ v.vendorType; }
   };

   struct EqualByRADIUS {
      bool operator()( const VSADef& lhs, const VSADef& rhs) const throw ()
      { return memcmp(&lhs, &rhs, 3 * sizeof(DWORD)) == 0; }
   };
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    VSADictionary
//
// DESCRIPTION
//
//    This class indexes all the information necessary for converting
//    vendor specific attributes between RADIUS format and IAS protocol-
//    independent format.
//
///////////////////////////////////////////////////////////////////////////////
class VSADictionary
   : NonCopyable
{
public:

   VSADictionary()
      : refCount(0)
   { }

   // Retrieve a definition based on the IAS attribute ID.
   const VSADef* find(DWORD iasID) const throw ()
   {
      VSADef key;
      key.iasID = iasID;
      return byIAS.find(key);
   }

   // Retrieve a definition based on the RADIUS vendor ID, type, and width.
   const VSADef* find(const VSADef& key) const throw ()
   {
      return byRADIUS.find(key);
   }

   // Initialize the dictionary for use.
   HRESULT initialize() throw ();

   // Shutdown the dictionary after use.
   void shutdown() throw ();

protected:

   // Clear the indices.
   void clear() throw ()
   {
      byIAS.clear();
      byRADIUS.clear();
   }

   // Insert a new definition into the dictionary.
   void insert(const VSADef& newDef)
   {
      byIAS.multi_insert(newDef);
      byRADIUS.multi_insert(newDef);
   }

   typedef hash_table< VSADef,
                       VSADef::HashByIAS,
                       VSADef,
                       identity< VSADef >,
                       VSADef::EqualByIAS
                     > IASMap;

   typedef hash_table< VSADef,
                       VSADef::HashByRADIUS,
                       VSADef,
                       identity< VSADef >,
                       VSADef::EqualByRADIUS
                     > RADIUSMap;

   IASMap byIAS;       // Indexed by IAS attribute ID.
   RADIUSMap byRADIUS; // Indexed by RADIUS Vendor-Id, Vendor-Type, and width.
   DWORD  refCount;    // Initialization reference count.
};

#endif  // _VSADNARY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\vsafilter.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    vsafilter.cpp
//
// SYNOPSIS
//
//    This file defines the class VSAFilter.
//
// MODIFICATION HISTORY
//
//     3/08/1998    Original version.
//     4/30/1998    Remove incoming VSA's if they can be completely converted.
//     5/15/1998    Allow clients to control whether VSAs are consolidated.
//     8/13/1998    IASTL integration.
//     9/16/1998    Overhaul for more flexible VSA support.
//     7/09/1999    Process all attributes -- not just outgoing.
//
///////////////////////////////////////////////////////////////////////////////

#include <radcommon.h>
#include <iasutil.h>
#include <iastlutl.h>
#include <sdoias.h>

#include <radutil.h>
#include <vsadnary.h>
#include <vsafilter.h>

using namespace IASTL;

//////////
// Dictionary shared by all VSAFilter's.
//////////
VSADictionary VSAFilter::theDictionary;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ByteSource
//
// DESCRIPTION
//
//    Simple class for extracting bytes from an octet string.
//
///////////////////////////////////////////////////////////////////////////////
class ByteSource
{
public:
   ByteSource(PBYTE buf, size_t buflen) throw ()
      : next(buf), last(buf + buflen) { }

   // Returns true if there are any bytes remaining.
   bool more() const throw ()
   {
      return next != last;
   }

   // Extracts 'nbyte' bytes.
   PBYTE extract(size_t nbyte)
   {
      PBYTE retval = next;

      // Update the cursor.
      next += nbyte;

      // Did we overflow ?
      if (next > last) { _com_issue_error(E_INVALIDARG); }

      return retval;
   }

   DWORD remaining() const throw ()
   {
      return static_cast<DWORD>(last - next);
   }

protected:
   PBYTE next;  // The next byte in the stream.
   PBYTE last;  // The end of the stream.
};


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    IASInsertField
//
// DESCRIPTION
//
//    Inserts a variable width integer field.
//
///////////////////////////////////////////////////////////////////////////////
PBYTE
WINAPI
IASInsertField(
    PBYTE dst,
    DWORD fieldWidth,
    DWORD fieldValue
    ) throw ()
{
   switch (fieldWidth)
   {
      case 0:
         break;

      case 1:
         *dst++ = (BYTE)fieldValue;
         break;

      case 2:
         IASInsertWORD(dst, (WORD)fieldValue);
         dst += 2;
         break;

      case 4:
         IASInsertDWORD(dst, fieldValue);
         dst += 4;
         break;
   }

   return dst;
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    VSAFilter::initialize
//
// DESCRIPTION
//
//    Prepares the filter for use by initializing the dictionary.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT VSAFilter::initialize() throw ()
{
   return theDictionary.initialize();
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    VSAFilter::shutdown
//
// DESCRIPTION
//
//    Cleans up the filter by clearing the dictionary.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT VSAFilter::shutdown() throw ()
{
   theDictionary.shutdown();
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    VSAFilter::radiusToIAS
//
// DESCRIPTION
//
//    This method retrieves all the VSA's from the request and attempts to
//    convert them to a protocol-independent format.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT VSAFilter::radiusToIAS(IAttributesRaw* raw) const throw ()
{
   _ASSERT(raw != NULL);

   try
   {
      // Retrieve all the VSA's.
      IASAttributeVectorWithBuffer<16> vsas;
      vsas.load(raw, RADIUS_ATTRIBUTE_VENDOR_SPECIFIC);

      // Convert each VSA.
      IASAttributeVector::iterator i;
      for (i = vsas.begin(); i != vsas.end(); ++i)
      {
         radiusToIAS(raw, *i);
      }
   }
   CATCH_AND_RETURN();

   return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    VSAFilter::radiusFromIAS
//
// DESCRIPTION
//
//    This method retrieves all the outgoing, non-RADIUS attributes from a
//    request and tries to represent them as RADIUS VSA's.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT VSAFilter::radiusFromIAS(IAttributesRaw* raw) const throw ()
{
   _ASSERT(raw != NULL);
   USES_IAS_STACK_VECTOR();

   try
   {
      // Get all the attributes from the request.
      IASAttributeVectorOnStack(attrs, raw, 0);
      attrs.load(raw);

      // Iterator through the attributes looking for conversion candidates.
      IASAttributeVector::iterator i;
      for (i = attrs.begin(); i != attrs.end(); ++i)
      {
         // We're only concerned with non-RADIUS attributes.
         if (i->pAttribute->dwId > 0xFF)
         {
            radiusFromIAS(raw, *i);
         }
      }
   }
   CATCH_AND_RETURN()

   return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    VSAFilter::extractVendorType
//
// DESCRIPTION
//
//    This method extracts the Vendor-Type from a byte source and returns
//    the corresponding VSA definition. If the VSA is not found in the
//    dictionary, the return value is NULL.
//
///////////////////////////////////////////////////////////////////////////////
const VSADef* VSAFilter::extractVendorType(
                             DWORD vendorID,
                             ByteSource& bytes
                             ) const
{
   // Set up the return value.
   const VSADef* def = NULL;

   // Set up the key for dictionary lookups.
   VSADef key;
   key.vendorID = vendorID;

   // Try for a one byte Vendor-Type.
   key.vendorType = *bytes.extract(1);
   key.vendorTypeWidth = 1;
   def = theDictionary.find(key);
   if (def || !bytes.more()) { return def; }

   // Try for a two byte Vendor-Type.
   key.vendorType <<= 8;
   key.vendorType |= *bytes.extract(1);
   key.vendorTypeWidth = 2;
   def = theDictionary.find(key);
   if (def || !bytes.more()) { return def; }

   // Try for a four byte Vendor-Type.
   key.vendorType <<= 8;
   key.vendorType |= *bytes.extract(1);
   if (!bytes.more()) { return NULL; }
   key.vendorType <<= 8;
   key.vendorType |= *bytes.extract(1);
   key.vendorTypeWidth = 4;
   return theDictionary.find(key);
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    VSAFilter::radiusToIAS
//
// DESCRIPTION
//
//    If the passed in attribute doesn't comply with the 'SHOULD' format
//    defined in RFC 2138 (q.v.), then this method does nothing. Otherwise,
//    it parses the VSA into sub-VSA's and converts each of these into a
//    protocol-independent IAS format.
//
///////////////////////////////////////////////////////////////////////////////
void VSAFilter::radiusToIAS(
                    IAttributesRaw* raw,
                    ATTRIBUTEPOSITION& pos
                    ) const
{
   // The ATTRIBUTEPOSITION position struct should have a valid RADIUS VSA.
   _ASSERT(pos.pAttribute != NULL);
   _ASSERT(pos.pAttribute->dwId == RADIUS_ATTRIBUTE_VENDOR_SPECIFIC);
   _ASSERT(pos.pAttribute->Value.itType == IASTYPE_OCTET_STRING);

   // Convert the Octet String into a ByteSource.
   ByteSource bytes(pos.pAttribute->Value.OctetString.lpValue,
                    pos.pAttribute->Value.OctetString.dwLength);

   // Get the vendor ID for this VSA.
   DWORD vendorID = IASExtractDWORD(bytes.extract(4));

   do
   {
      // Do we have this VSA in our dictionary?
      const VSADef* def = extractVendorType(vendorID, bytes);

      // If not, we can't convert it to a protocol-independent format,
      // so there's nothing to do.
      if (!def) { return; }

      // Extract the length.
      BYTE vendorLength;

      if (def->vendorLengthWidth)
      {
         switch (def->vendorLengthWidth)
         {
            case 1:
               vendorLength = *bytes.extract(1);
               break;

            case 2:
               vendorLength = (BYTE)IASExtractWORD(bytes.extract(2));
               break;

            case 4:
               vendorLength = (BYTE)IASExtractDWORD(bytes.extract(4));
               break;
         }

         // Subtract off the header fields.
         vendorLength -= (BYTE)def->vendorTypeWidth;
         vendorLength -= (BYTE)def->vendorLengthWidth;
      }
      else
      {
         // No length field, so we just use whatever's left.
         vendorLength = bytes.remaining();
      }

      // Convert this sub-VSA into an IASAttribute.
      IASAttribute attr(RadiusUtil::decode(def->iasType,
                                           bytes.extract(vendorLength),
                                           vendorLength), false);

      // Set the IAS attribute ID.
      attr->dwId = def->iasID;

      // The flags should match the original attribute.
      attr->dwFlags = pos.pAttribute->dwFlags;

      // Insert into the request.
      attr.store(raw);

      // Loop until the bytes are exhausted.
   } while (bytes.more());

   // If we made it here, then every sub-VSA was compliant, so we can remove
   // the original.
   _com_util::CheckError(raw->RemoveAttributes(1, &pos));
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    VSAFilter::radiusFromIAS
//
// DESCRIPTION
//
//    Attempts to convert a non-RADIUS standard IAS attribute to a RADIUS
//    VSA. If the attribute has no RADIUS representation, then this method
//    does nothing.
//
///////////////////////////////////////////////////////////////////////////////
void VSAFilter::radiusFromIAS(
                    IAttributesRaw* raw,
                    ATTRIBUTEPOSITION& pos
                    ) const
{
   // Is this attribute a RADIUS VSA ?
   const VSADef* def = theDictionary.find(pos.pAttribute->dwId);

   // If not, there's nothing to do.
   if (!def) { return; }

   // Compute the length of the VSA data.
   ULONG dataLength = RadiusUtil::getEncodedSize(*pos.pAttribute);

   // The attribute length is 4 bytes for the Vendor-Id plus the width of the
   // Vendor-Type plus the width of the Vendor-Length plus the length of the
   // data.
   ULONG attrLength = 4 +
                      def->vendorTypeWidth +
                      def->vendorLengthWidth +
                      dataLength;

   // RADIUS attributes can be at most 253 bytes in length.
   if (attrLength > 253) { _com_issue_error(E_INVALIDARG); }

   // Allocate an attribute for the VSA.
   IASAttribute vsa(true);

   // Allocate a buffer for the value.
   PBYTE buf = (PBYTE)CoTaskMemAlloc(attrLength);
   if (!buf) { _com_issue_error(E_OUTOFMEMORY); }

   // Initialize the attribute.
   vsa->dwFlags = pos.pAttribute->dwFlags;
   vsa->dwId = RADIUS_ATTRIBUTE_VENDOR_SPECIFIC;
   vsa->Value.itType = IASTYPE_OCTET_STRING;
   vsa->Value.OctetString.dwLength = attrLength;
   vsa->Value.OctetString.lpValue = buf;

   // Pack the Vendor-Id.
   IASInsertDWORD(buf, def->vendorID);
   buf += 4;

   // Pack the Vendor-Type.
   buf = IASInsertField(
             buf,
             def->vendorTypeWidth,
             def->vendorType
             );

   // Pack the Vendor-Length;
   buf = IASInsertField(
             buf,
             def->vendorLengthWidth,
             def->vendorTypeWidth + def->vendorLengthWidth + dataLength
             );

   // Encode the data.
   RadiusUtil::encode(buf, *pos.pAttribute);

   // Remove the original attribute.
   _com_util::CheckError(raw->RemoveAttributes(1, &pos));

   // Store the new attribute.
   vsa.store(raw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\vsafilter.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    vsafilter.h
//
// SYNOPSIS
//
//    This file declares the class VSAFilter.
//
// MODIFICATION HISTORY
//
//     3/08/1998    Original version.
//     5/15/1998    Allow clients to control whether VSAs are consolidated.
//     9/16/1998    Overhaul for more flexible VSA support.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _VSAFILTER_H_
#define _VSAFILTER_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <nocopy.h>

class ByteSource;
struct VSADef;
class VSADictionary;

#ifndef IASRADAPI
#define IASRADAPI __declspec(dllimport)
#endif

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    VSAFilter
//
// DESCRIPTION
//
//    This class is responsible for converting vendor specific attributes
//    between RADIUS format and the IAS protocol-independent format.
//
///////////////////////////////////////////////////////////////////////////////
class VSAFilter
   : public NonCopyable
{
public:
   // Prepare the filter for use.
   HRESULT IASRADAPI initialize() throw ();

   // Clean-up the filter prior to termination.
   HRESULT IASRADAPI shutdown() throw ();

   // Converts any RADIUS VSA's contained in 'raw' to IAS format.
   HRESULT IASRADAPI radiusToIAS(IAttributesRaw* raw) const throw ();

   // Converts any VSA's contained in 'raw' to RADIUS format.
   HRESULT IASRADAPI radiusFromIAS(IAttributesRaw* raw) const throw ();

protected:
   // Dictionary mapping IAS attributes to their Vendor-ID and Vendor-Type.
   static VSADictionary theDictionary;

   // Extracts the Vendor-Type from a byte source and returns the
   // corresponding VSA definition.
   const VSADef* extractVendorType(
                     DWORD vendorID,
                     ByteSource& bytes
                     ) const;

   // Explodes the RADIUS VSA contained in 'pos' into sub-VSA's and converts
   // each of these to an IAS attribute.
   void radiusToIAS(
            IAttributesRaw* raw,
            ATTRIBUTEPOSITION& pos
            ) const;

   // Converts the IAS attribute contained in 'pos' to a RADIUS VSA.
   void radiusFromIAS(
            IAttributesRaw* raw,
            ATTRIBUTEPOSITION& pos
            ) const;
};

#endif  // _VSAFILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\vsasink.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    VSASink.cpp
//
// SYNOPSIS
//
//    This file defines the class VSASink.
//
// MODIFICATION HISTORY
//
//    01/24/1998    Original version.
//    08/11/1998    Packing functions moved to iasutil.
//    08/13/1998    IASTL integration.
//
///////////////////////////////////////////////////////////////////////////////

#include <radcommon.h>
#include <iasutil.h>
#include <iastlutl.h>
#include <sdoias.h>

#include <radutil.h>
#include <vsasink.h>

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    VSASink::VSASink
//
// DESCRIPTION
//
//    Constructor.
//
///////////////////////////////////////////////////////////////////////////////
VSASink::VSASink(IAttributesRaw* request) throw ()
   : raw(request),
     bufferLength(0),
     currentVendor(NO_VENDOR)
{ }


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    VSASink::operator<<
//
// DESCRIPTION
//
//    Inserts a SubVSA into the sink.
//
///////////////////////////////////////////////////////////////////////////////
VSASink& VSASink::operator<<(const SubVSA& vsa)
{
   _ASSERT(vsa.vendorID != NO_VENDOR);

   // Get the size of the sub VSA on the wire.
   ULONG vsaLength = RadiusUtil::getEncodedSize(*vsa.attr) + 2;

   if (vsaLength > MAX_SUBVSA_LENGTH) { _com_issue_error(E_INVALIDARG); }

   // If we're out of room or the vendors and flags don't match, then ...
   if (bufferLength + vsaLength > sizeof(buffer) ||
       currentVendor != vsa.vendorID ||
       currentFlags  != vsa.attr->dwFlags)
   {
      // ... we have to flush the buffer and start a new attribute.

      flush();

      // Write the vendor ID at the head of the attribute.
      IASInsertDWORD(buffer, vsa.vendorID);
      bufferLength = 4;

      // Save the new vendor and flags.
      currentVendor = vsa.vendorID;
      currentFlags  = vsa.attr->dwFlags;
   }

   // Find the next available byte.
   PBYTE next = buffer + bufferLength;

   // Pack the vendor type.
   *next++ = vsa.vendorType;

   // Pack the vendor length.
   *next++ = (BYTE)vsaLength;

   // Encode the value.
   RadiusUtil::encode(next, *vsa.attr);

   // Update the buffer length.
   bufferLength += vsaLength;

   return *this;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    VSASink::flush
//
// DESCRIPTION
//
//    Flush the sink. This should be called after all SubVSA's have been
//    inserted to ensure that everything has been inserted into the request.
//
///////////////////////////////////////////////////////////////////////////////
void VSASink::flush() throw (_com_error)
{
   // Is there anything in the buffer?
   if (bufferLength > 0)
   {
      //////////
      // Allocate an attribute for the VSA.
      //////////

      IASTL::IASAttribute attr(true);

      //////////
      // Initialize the fields.
      //////////

      attr->dwId = RADIUS_ATTRIBUTE_VENDOR_SPECIFIC;
      attr->dwFlags = currentFlags;
      attr.setOctetString(bufferLength, buffer);

      //////////
      // Load the attribute into the request and reset the buffer.
      //////////

      attr.store(raw);

      currentVendor = NO_VENDOR;
      bufferLength = 0;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\vsadnary.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    vsadnary.cpp
//
// SYNOPSIS
//
//    This file defines the class VSADictionary.
//
// MODIFICATION HISTORY
//
//    03/07/1998    Original version.
//    08/13/1998    Use SQL query to retrieve attributes.
//    09/16/1998    Add additional fields to VSA definition.
//    04/17/2000    Port to new dictionary API.
//
///////////////////////////////////////////////////////////////////////////////

#include <radcommon.h>
#include <iastlb.h>
#include <iastlutl.h>
#include <iasutil.h>

#include <sdoias.h>
#include <vsadnary.h>

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    getFieldWidth
//
// DESCRIPTION
//
//    Reads a byte width value from the dictionary.
//
///////////////////////////////////////////////////////////////////////////////
DWORD getFieldWidth(
          IASTL::IASDictionary& table,
          ULONG ordinal
          ) throw ()
{
   // If the width isn't set, assume 1 byte.
   if (table.isEmpty(ordinal)) { return 1; }

   DWORD width = (DWORD)table.getLong(ordinal);

   // Make sure the value is valid.
   switch (width)
   {
      case 0:
      case 1:
      case 2:
      case 4:
         break;

      default:
         width = 1;
   }

   return width;
}

///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    VSADictionary::initialize
//
// DESCRIPTION
//
//    Prepares the dictionary for use.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT VSADictionary::initialize() throw ()
{
   IASGlobalLockSentry sentry;

   // Have we already been initialized ?
   if (refCount != 0)
   {
      ++refCount;
      return S_OK;
   }

   try
   {
      // Names of various columns in the dictionary.
      const PCWSTR COLUMNS[] =
      {
         L"ID",
         L"Syntax",
         L"VendorID",
         L"VendorTypeID",
         L"VendorTypeWidth",
         L"VendorLengthWidth",
         NULL
      };

      // Open the attributes table.
      IASTL::IASDictionary dnary(COLUMNS);

      VSADef def;

      // Iterate through the attributes and populate our dictionary.
      while (dnary.next())
      {
         if (dnary.isEmpty(2) || dnary.isEmpty(3)) { continue; }

         def.iasID      = (DWORD)  dnary.getLong(0);
         def.iasType    = (IASTYPE)dnary.getLong(1);
         def.vendorID   = (DWORD)  dnary.getLong(2);
         def.vendorType = (DWORD)  dnary.getLong(3);

         def.vendorTypeWidth   = getFieldWidth(dnary, 4);
         def.vendorLengthWidth = getFieldWidth(dnary, 5);

         insert(def);
      }
   }
   catch (std::bad_alloc)
   {
      clear();
      return E_OUTOFMEMORY;
   }
   catch (const _com_error& ce)
   {
      clear();
      return ce.Error();
   }

   // We were successful so add ref.
   refCount = 1;

   return S_OK;
}

void VSADictionary::shutdown() throw ()
{
   IASGlobalLockSentry sentry;

   _ASSERT(refCount != 0);

   if (--refCount == 0) { clear(); }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\protocol\radius\vsasink.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    VSASink.h
//
// SYNOPSIS
//
//    This file declares the class VSASink.
//
// MODIFICATION HISTORY
//
//    03/07/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _VSASINK_H_
#define _VSASINK_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <iaspolcy.h>
#include <nocopy.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SubVSA
//
// DESCRIPTION
//
//    Encapsulates the information for converting an IAS Attribute into a
//    RADIUS vendor specific attribute.
//
///////////////////////////////////////////////////////////////////////////////
class SubVSA
{
public:
   DWORD vendorID;       // The Vendor-ID in host order.
   BYTE vendorType;      // The Vendor-Type code.
   PIASATTRIBUTE attr;   // Protocol-independent representation.

   // When sorting, we want to group by vendor ID and flags. We don't care
   // about type.
   bool operator<(const SubVSA& s) const throw ()
   {
      return vendorID == s.vendorID ? attr->dwFlags < s.attr->dwFlags
                                    : vendorID < s.vendorID;
   }
};


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    VSASink
//
// DESCRIPTION
//
//    This class converts a Request object into a sink for SubVSA's. Sub-VSA's
//    inserted into the sink are converted into IASAttributes's and inserted
//    into the request object.
//
///////////////////////////////////////////////////////////////////////////////
class VSASink
   : NonCopyable
{
public:
   // Construct a sink from a request.
   explicit VSASink(IAttributesRaw* request) throw ();

   // Insert a SubVSA into the sink.
   VSASink& operator<<(const SubVSA& vsa);

   // Flush the sink. This should be called after all SubVSA's have been
   // inserted to ensure that everything has been inserted into the request.
   void flush();

protected:
   enum
   {
      NO_VENDOR         =   0,   // Indicates a 'blank' vendor ID.
      MAX_SUBVSA_LENGTH = 249,   // Maximum length of a sub-VSA.
      MAX_VSA_LENGTH    = 253    // Maximum length of a consolidated VSA.
   };

   CComPtr<IAttributesRaw> raw;  // The request object being wrapped.
   BYTE buffer[MAX_VSA_LENGTH];  // Buffer used for building VSA's.
   size_t bufferLength;          // Number of bytes in the buffer.
   DWORD currentVendor;          // Vendor being processed.
   DWORD currentFlags;           // Flags for current VSA.
};

#endif  // _VSASINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\account.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// SYNOPSIS
//
//    Defines the class Accountant.
//
///////////////////////////////////////////////////////////////////////////////

#include "ias.h"
#include "account.h"
#include <algorithm>
#include "sdoias.h"


#define STACK_ALLOC(type, num) (type*)_alloca(sizeof(type) * (num))


Accountant::Accountant() throw ()
   : logAuth(false),
     logAcct(false),
     logInterim(false),
     logAuthInterim(false)
{
}


Accountant::~Accountant() throw ()
{
}


STDMETHODIMP Accountant::Initialize()
{
   return schema.initialize();
}


STDMETHODIMP Accountant::Shutdown()
{
   schema.shutdown();
   return S_OK;
}


HRESULT Accountant::PutProperty(LONG id, VARIANT* value) throw ()
{
   if (value == 0)
   {
      return E_INVALIDARG;
   }

   HRESULT hr = S_OK;

   switch (id)
   {
      case PROPERTY_ACCOUNTING_LOG_ACCOUNTING:
      {
         if (V_VT(value) == VT_BOOL)
         {
            logAcct = (V_BOOL(value) != 0);
         }
         else
         {
            hr = DISP_E_TYPEMISMATCH;
         }
         break;
      }

      case PROPERTY_ACCOUNTING_LOG_ACCOUNTING_INTERIM:
      {
         if (V_VT(value) == VT_BOOL)
         {
            logInterim = (V_BOOL(value) != 0);
         }
         else
         {
            hr = DISP_E_TYPEMISMATCH;
         }
         break;
      }

      case PROPERTY_ACCOUNTING_LOG_AUTHENTICATION:
      {
         if (V_VT(value) == VT_BOOL)
         {
            logAuth = (V_BOOL(value) != 0);
         }
         else
         {
            hr = DISP_E_TYPEMISMATCH;
         }
         break;
      }

      case PROPERTY_ACCOUNTING_LOG_AUTHENTICATION_INTERIM:
      {
         if (V_VT(value) == VT_BOOL)
         {
            logAuthInterim = (V_BOOL(value) != 0);
         }
         else
         {
            hr = DISP_E_TYPEMISMATCH;
         }
         break;
      }
      default:
      {
         // We just ignore properties that we don't understand.
         break;
      }
   }

   return hr;
}


void Accountant::RecordEvent(void* context, IASTL::IASRequest& request)
{
   // Array of PacketTypes to be inserted. PKT_UNKNOWN indicates no record.
   PacketType types[3] =
   {
      PKT_UNKNOWN,
      PKT_UNKNOWN,
      PKT_UNKNOWN
   };

   // Determine packet types based on request type and the configuration.
   switch (request.get_Request())
   {
      case IAS_REQUEST_ACCOUNTING:
      {
         if (IsInterimRecord(request) ? logInterim : logAcct)
         {
            types[0] = PKT_ACCOUNTING_REQUEST;
         }
         break;
      }

      case IAS_REQUEST_ACCESS_REQUEST:
      {
         switch (request.get_Response())
         {
            case IAS_RESPONSE_ACCESS_ACCEPT:
            {
               if (logAuth)
               {
                  types[0] = PKT_ACCESS_REQUEST;
                  types[1] = PKT_ACCESS_ACCEPT;
               }
               break;
            }

            case IAS_RESPONSE_ACCESS_REJECT:
            {
               if (logAuth)
               {
                  types[0] = PKT_ACCESS_REQUEST;
                  types[1] = PKT_ACCESS_REJECT;
               }
               break;
            }

            case IAS_RESPONSE_ACCESS_CHALLENGE:
            {
               if (logAuthInterim)
               {
                  types[0] = PKT_ACCESS_REQUEST;
                  types[1] = PKT_ACCESS_CHALLENGE;
               }
               break;
            }

            default:
            {
               break;
            }
         }
         break;
      }

      default:
      {
         break;
      }
   }

   // Get the local SYSTEMTIME.
   SYSTEMTIME localTime;
   GetLocalTime(&localTime);

   // Insert the appropriate records.
   for (const PacketType* type = types; *type != PKT_UNKNOWN; ++type)
   {
      InsertRecord(context, request, localTime, *type);
   }

   // Flush the accounting stream.
   Flush(context, request, localTime);
}


void Accountant::InsertRecord(
                    void* context,
                    IASTL::IASRequest& request,
                    const SYSTEMTIME& localTime,
                    PacketType packetType
                    )
{
   //////////
   // Retrieve all the attributes from the request. Save room for three extra
   // attributes: Packet-Type, Reason-Code, and a null-terminator.
   //////////

   PATTRIBUTEPOSITION firstPos, curPos, lastPos;
   DWORD nattr = request.GetAttributeCount();
   firstPos = STACK_ALLOC(ATTRIBUTEPOSITION, nattr + 3);
   nattr = request.GetAttributes(nattr, firstPos, 0, NULL);
   lastPos = firstPos + nattr;

   //////////
   // Compute the attribute filter and reason code.
   //////////

   DWORD always, never, reason = 0;
   switch (packetType)
   {
      case PKT_ACCESS_REQUEST:
         always = IAS_RECVD_FROM_CLIENT | IAS_RECVD_FROM_PROTOCOL;
         never  = IAS_INCLUDE_IN_RESPONSE;
         break;

      case PKT_ACCESS_ACCEPT:
         always = IAS_INCLUDE_IN_ACCEPT;
         never  = IAS_RECVD_FROM_CLIENT |
                  IAS_INCLUDE_IN_REJECT | IAS_INCLUDE_IN_CHALLENGE;
         break;

      case PKT_ACCESS_REJECT:
         always = IAS_INCLUDE_IN_REJECT;
         never  = IAS_RECVD_FROM_CLIENT |
                  IAS_INCLUDE_IN_ACCEPT | IAS_INCLUDE_IN_CHALLENGE;
         reason = request.get_Reason();
         break;

      case PKT_ACCESS_CHALLENGE:
         always = IAS_INCLUDE_IN_CHALLENGE;
         never =  IAS_RECVD_FROM_CLIENT |
                  IAS_INCLUDE_IN_ACCEPT | IAS_INCLUDE_IN_REJECT;
         break;

      case PKT_ACCOUNTING_REQUEST:
         always = IAS_INCLUDE_IN_ACCEPT | IAS_RECVD_FROM_CLIENT |
                  IAS_RECVD_FROM_PROTOCOL;
         never  = IAS_INCLUDE_IN_RESPONSE;
         reason = request.get_Reason();
         break;
   }

   //////////
   // Filter the attributes based on flags.
   //////////

   for (curPos = firstPos;  curPos != lastPos; )
   {
      // We can release here since the request still holds a reference.
      IASAttributeRelease(curPos->pAttribute);

      if (!(curPos->pAttribute->dwFlags & always) &&
           (curPos->pAttribute->dwFlags & never ) &&
           (curPos->pAttribute->dwId != RADIUS_ATTRIBUTE_CLASS))
      {
         --lastPos;

         std::swap(lastPos->pAttribute, curPos->pAttribute);
      }
      else
      {
         ++curPos;
      }
   }

   //////////
   // Add the Packet-Type pseudo-attribute.
   //////////

   IASATTRIBUTE packetTypeAttr;
   packetTypeAttr.dwId             = IAS_ATTRIBUTE_PACKET_TYPE;
   packetTypeAttr.dwFlags          = (DWORD)-1;
   packetTypeAttr.Value.itType     = IASTYPE_ENUM;
   packetTypeAttr.Value.Enumerator = packetType;

   lastPos->pAttribute = &packetTypeAttr;
   ++lastPos;

   //////////
   // Add the Reason-Code pseudo-attribute.
   //////////

   IASATTRIBUTE reasonCodeAttr;
   reasonCodeAttr.dwId             = IAS_ATTRIBUTE_REASON_CODE;
   reasonCodeAttr.dwFlags          = (DWORD)-1;
   reasonCodeAttr.Value.itType     = IASTYPE_INTEGER;
   reasonCodeAttr.Value.Integer    = reason;

   lastPos->pAttribute = &reasonCodeAttr;
   ++lastPos;

   //////////
   // Invoke the derived class.
   //////////

   InsertRecord(context, request, localTime, firstPos, lastPos);
}


IASREQUESTSTATUS Accountant::onSyncRequest(IRequest* pRequest) throw ()
{
   try
   {
      Process(IASTL::IASRequest(pRequest));
   }
   catch (...)
   {
      pRequest->SetResponse(IAS_RESPONSE_DISCARD_PACKET, IAS_NO_RECORD);
      return IAS_REQUEST_STATUS_ABORT;
   }

   return IAS_REQUEST_STATUS_CONTINUE;
}


bool Accountant::IsInterimRecord(IAttributesRaw* attrs) throw ()
{
   const DWORD accountingInterim = 3;

   IASATTRIBUTE* attr = IASPeekAttribute(
                           attrs,
                           RADIUS_ATTRIBUTE_ACCT_STATUS_TYPE,
                           IASTYPE_ENUM
                           );

   return (attr != 0) && (attr->Value.Enumerator == accountingInterim);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\account.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class Accountant.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef ACCOUNT_H
#define ACCOUNT_H
#pragma once

#include "iastl.h"
#include "iastlutl.h"
#include "logschema.h"

// Abstract base class for the accounting handlers.
class __declspec(novtable) Accountant
   : public IASTL::IASRequestHandlerSync
{
public:
   Accountant() throw ();
   virtual ~Accountant() throw ();

protected:
   // IIasComponent. If the derived class overrides these, it must also invoke
   // the base class methods.
   STDMETHOD(Initialize)();
   STDMETHOD(Shutdown)();
   STDMETHOD(PutProperty)(LONG id, VARIANT* value);

   // Called by the derived class to begin the accounting process.
   void RecordEvent(void* context, IASTL::IASRequest& request);

   // This is the main entry point for the derived class. In this function, it
   // should do any preprocessing, create a context, and invoke OnEvent.
   virtual void Process(IASTL::IASRequest& request) = 0;

   // Called to append a record to the accounting stream.
   virtual void InsertRecord(
                   void* context,
                   IASTL::IASRequest& request,
                   const SYSTEMTIME& localTime,
                   PATTRIBUTEPOSITION first,
                   PATTRIBUTEPOSITION last
                   ) = 0;

   // Called to flush the accounting stream.
   virtual void Flush(
                   void* context,
                   IASTL::IASRequest& request,
                   const SYSTEMTIME& localTime
                   ) = 0;

   // Packet types.
   enum PacketType
   {
      PKT_UNKNOWN            = 0,
      PKT_ACCESS_REQUEST     = 1,
      PKT_ACCESS_ACCEPT      = 2,
      PKT_ACCESS_REJECT      = 3,
      PKT_ACCOUNTING_REQUEST = 4,
      PKT_ACCESS_CHALLENGE   = 11
   };

   // The accounting schema.
   LogSchema schema;

private:
   // Wraps the virtual overload to perform pre/post processing.
   void InsertRecord(
           void* context,
           IASTL::IASRequest& request,
           const SYSTEMTIME& localTime,
           PacketType type
           );

   virtual IASREQUESTSTATUS onSyncRequest(IRequest* pRequest) throw ();

   // Returns true if the request is an interim accounting record.
   static bool IsInterimRecord(IAttributesRaw* attrs) throw ();

   bool logAuth;        // Log authentication requests ?
   bool logAcct;        // Log accounting requests ?
   bool logInterim;     // Log interim accounting requests ?
   bool logAuthInterim; // Log interim authentication requests ?

   // Not implemented.
   Accountant(const Accountant&);
   Accountant& operator=(const Accountant&);
};

#endif  // ACCOUNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\classattr.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    classattr.cpp
//
// SYNOPSIS
//
//    Defines the class IASClass.
//
// MODIFICATION HISTORY
//
//    08/06/1998    Original version.
//    01/25/2000    Use IASGetHostByName.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasattr.h>
#include <sdoias.h>

#include <lmcons.h>
#include <winsock2.h>

#include <classattr.h>

const DWORD IAS_CLASS_VERSION = 1;

//////////
// Global variables computed during initialization.
//////////
IASClass invariant;    // Stores invariant fields of the class attribute.
LONG nextSerialNumber; // Next serial number to be assigned.

// Returns TRUE if the class attribute is in Microsoft format.
BOOL IASClass::isMicrosoft(DWORD actualLength) const throw ()
{
   return actualLength  >= sizeof(IASClass) &&
          getVendorID() == IAS_VENDOR_MICROSOFT &&
          getVersion()  == IAS_CLASS_VERSION &&
          getChecksum() == IASAdler32(
                               vendorID,
                               actualLength - offsetof(IASClass, vendorID)
                               );
}

void IASClass::initialize() throw ()
{
   // Null everything out.
   memset(&invariant, 0, sizeof(invariant));

   // Set the vendor ID and version.
   IASInsertDWORD(invariant.vendorID, IAS_VENDOR_MICROSOFT);
   IASInsertWORD (invariant.version,  IAS_CLASS_VERSION);

   // Try to set the server IP address. We don't care if this fails since
   // we may be running on a computer without IP installed.
   WCHAR computerName[CNLEN + 1];
   DWORD nchar = CNLEN + 1;
   if (GetComputerNameW(computerName, &nchar))
   {
      PHOSTENT hostEnt = IASGetHostByName(computerName);
      if (hostEnt)
      {
         memcpy(invariant.serverAddress, hostEnt->h_addr, 4);
         LocalFree(hostEnt);
      }
   }

   // Set the boot time.
   FILETIME ft;
   GetSystemTimeAsFileTime(&ft);
   IASInsertDWORD(invariant.lastReboot,     ft.dwHighDateTime);
   IASInsertDWORD(invariant.lastReboot + 4, ft.dwLowDateTime);

   // Reset the serial number.
   nextSerialNumber = 0;
}

PIASATTRIBUTE IASClass::createAttribute(const IAS_OCTET_STRING* tag) throw ()
{
   //////////
   // Allocate an attribute.
   //////////

   PIASATTRIBUTE attr;
   if (IASAttributeAlloc(1, &attr) != NO_ERROR)
   {
      return NULL;
   }

   //////////
   // Allocate memory for the value.
   //////////

   DWORD len = sizeof(IASClass) + (tag ? tag->dwLength : 0);
   IASClass* cl = (IASClass*)CoTaskMemAlloc(len);
   if (cl == NULL)
   {
      IASAttributeRelease(attr);
      return NULL;
   }

   //////////
   // Copy in the parts that never change.
   //////////

   memcpy(cl->vendorID, invariant.vendorID, 22);

   //////////
   // Set the unique serial number.
   //////////

   IASInsertDWORD(cl->serialNumber + 4,
                  InterlockedIncrement(&nextSerialNumber));

   //////////
   // Add the profile string (if any).
   //////////

   if (tag)
   {
      memcpy(cl->serialNumber + 8, tag->lpValue, tag->dwLength);
   }

   //////////
   // Compute and insert the checksum.
   //////////

   IASInsertDWORD(
       cl->checksum,
       IASAdler32(
           cl->vendorID,
           len - offsetof(IASClass, vendorID)
           )
       );

   //////////
   // Fill in the attribute fields.
   //////////

   attr->dwId = RADIUS_ATTRIBUTE_CLASS;
   attr->dwFlags = IAS_INCLUDE_IN_ACCEPT;
   attr->Value.itType = IASTYPE_OCTET_STRING;
   attr->Value.OctetString.lpValue = (PBYTE)cl;
   attr->Value.OctetString.dwLength = len;

   return attr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\commandpool.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the class CommandPool.
//
///////////////////////////////////////////////////////////////////////////////

#include "ias.h"
#include "commandpool.h"
#include <climits>
#include <new>


CommandPool::CommandPool() throw ()
   : version(0),
     pool(0),
     maxCommands(1),
     numCommands(0),
     owners(0),
     waiters(0),
     semaphore(0)
{
}


CommandPool::~CommandPool() throw ()
{
   while (pool != 0)
   {
      delete Pop();
   }

   if (semaphore != 0)
   {
      DeleteCriticalSection(&lock);

      CloseHandle(semaphore);
   }
}


HRESULT CommandPool::FinalConstruct() throw ()
{
   if (!InitializeCriticalSectionAndSpinCount(
           &lock,
           0x80000000
           ))
   {
      DWORD error = GetLastError();
      return HRESULT_FROM_WIN32(error);
   }

   semaphore = CreateSemaphoreW(0, 0, LONG_MAX, 0);
   if (semaphore == 0)
   {
      DeleteCriticalSection(&lock);

      DWORD error = GetLastError();
      return HRESULT_FROM_WIN32(error);
   }

   return S_OK;
}


void CommandPool::SetMaxCommands(size_t newValue) throw ()
{
   // Don't allow empty pools; otherwise, Alloc will block forever.
   if (newValue < 1)
   {
      newValue = 1;
   }

   // Number of waiters to release as a result of the change.
   long releaseCount = 0;

   Lock();

   maxCommands = newValue;

   // Are there any slots open? If so, we may need to release some waiters.
   if (owners < maxCommands)
   {
      // newOwners = min(open slots, waiters)
      size_t newOwners = maxCommands - owners;
      if (newOwners > waiters)
      {
         newOwners = waiters;
      }

      // Convert the threads from waiters to owners.
      waiters -= newOwners;
      owners += newOwners;

      releaseCount = static_cast<long>(newOwners);
   }

   // Delete any excess commands.
   while ((numCommands > maxCommands) && (pool != 0))
   {
      delete Pop();
   }

   Unlock();

   if (releaseCount > 0)
   {
      // Unlock before we release the semaphore because the other threads will
      // immediately try to acquire the lock.
      ReleaseSemaphore(semaphore, releaseCount, 0);
   }
}


ReportEventCommand* CommandPool::Alloc() throw ()
{
   LockAndWait();

   ReportEventCommand* cmd;

   // If the pool isn't empty, ...
   if (pool != 0)
   {
      // ... then reuse one from the pool ...
      cmd = Pop();
   }
   else
   {
      // ... otherwise create a new object.
      cmd = new (std::nothrow) ReportEventCommand();
      if (cmd == 0)
      {
         // The resource acquired by the call to LockAndWait above is normally
         // released in Free, but since we're not returning a command to the
         // caller, we have to do it here.
         UnlockAndRelease();
         return 0;
      }

      ++numCommands;
   }

   cmd->SetVersion(version);

   Unlock();

   return cmd;
}


void CommandPool::Free(ReportEventCommand* cmd) throw ()
{
   if (cmd != 0)
   {
      Lock();

      if (numCommands > maxCommands)
      {
         // There's too many commands, so delete.
         delete cmd;
         --numCommands;
      }
      else
      {
         // If the command is stale, reset it.
         if (cmd->Version() != version)
         {
            cmd->Unprepare();
         }

         // Return the command to the pool.
         Push(cmd);
      }

      UnlockAndRelease();
   }
}


void CommandPool::UnprepareAll() throw ()
{
   Lock();

   ++version;

   for (ReportEventCommand* i = pool; i != 0; i = i->Next())
   {
      i->Unprepare();
   }

   Unlock();
}


inline void CommandPool::Lock() throw ()
{
   EnterCriticalSection(&lock);
}


inline void CommandPool::Unlock() throw ()
{
   LeaveCriticalSection(&lock);
}


inline void CommandPool::LockAndWait() throw ()
{
   Lock();

   if (owners >= maxCommands)
   {
      // No available resources, so we wait.
      ++waiters;

      // Don't hold the lock while we're waiting.
      Unlock();
      WaitForSingleObject(semaphore, INFINITE);
      Lock();
   }
   else
   {
      ++owners;
   }
}


void CommandPool::UnlockAndRelease() throw ()
{
   // Should we wake someone up?
   if ((waiters > 0) && (owners <= maxCommands))
   {
      // Convert one waiter to an owner. The owners count is unchanged since
      // the other thread is taking our place.
      --waiters;
      Unlock();

      // Unlock before we release the semaphore because the other thread will
      // immediately try to acquire the lock.
      ReleaseSemaphore(semaphore, 1, 0);
   }
   else
   {
      --owners;
      Unlock();
   }
}


inline void CommandPool::Push(ReportEventCommand* cmd) throw ()
{
   cmd->SetNext(pool);
   pool = cmd;
}


inline ReportEventCommand* CommandPool::Pop() throw ()
{
   ReportEventCommand* retval = pool;
   pool = retval->Next();
   return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\commandpool.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class CommandPool.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef COMMANDPOOL_H
#define COMMANDPOOL_H
#pragma once

#include "reporteventcmd.h"

// Maintains a blocking pool of command objects.
class CommandPool
{
public:
   CommandPool() throw ();
   ~CommandPool() throw ();

   HRESULT FinalConstruct() throw ();

   // Set the maximum number of pooled commands.
   void SetMaxCommands(size_t newValue) throw ();

   // Current version of the pool.
   unsigned int Version() throw ();

   // Allocate a command object, blocking until one is available.
   ReportEventCommand* Alloc() throw ();

   // Free a command object.
   void Free(ReportEventCommand* cmd) throw ();

   // Unprepare all commands in the pool. Commands that are currently in use
   // will be unprepared when they are freed.
   void UnprepareAll() throw ();

private:
   void Lock() throw ();
   void Unlock() throw ();

   // Acquire both the lock and a resource.
   void LockAndWait() throw ();
   // Release both the lock and a resource.
   void UnlockAndRelease() throw ();

   void Push(ReportEventCommand* cmd) throw ();
   ReportEventCommand* Pop() throw ();

   // Version of the pool; used to detect stale command objects.
   unsigned int version;

   // Singly-linked list of commands available for use.
   ReportEventCommand* pool;

   // Maximum number of command objects allowed in existence. This limit may be
   // temporarily exceeded if maxCommands is reduced while commands are in use.
   size_t maxCommands;

   // Number of command objects in existence.
   size_t numCommands;

   // Number of threads that own a command.
   size_t owners;

   // Number of threads waiting for a command.
   size_t waiters;

   // Semaphore used to signal threads waiting for a command.
   HANDLE semaphore;

   // Serialize access.
   CRITICAL_SECTION lock;

   // Not implemented.
   CommandPool(const CommandPool&);
   CommandPool& operator=(const CommandPool&);
};


inline unsigned int CommandPool::Version() throw ()
{
   return version;
}

#endif // COMMANDPOOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\classattr.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    classattr.h
//
// SYNOPSIS
//
//    Declares the class IASClass.
//
// MODIFICATION HISTORY
//
//    08/06/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _CLASSATTR_H_
#define _CLASSATTR_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <iaspolcy.h>
#include <iasutil.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    IASClass
//
// DESCRIPTION
//
//    Wrapper around the IAS-specific format for the RADIUS class attribute.
//
///////////////////////////////////////////////////////////////////////////////
struct IASClass
{
   BYTE checksum[4];
   BYTE vendorID[4];
   BYTE version[2];
   BYTE serverAddress[4];
   BYTE lastReboot[8];
   BYTE serialNumber[8];

   //////////
   // Miscellaneous accessors.
   //////////

   DWORD getChecksum() const throw ()
   { return IASExtractDWORD(checksum); }

   DWORD getVendorID() const throw ()
   { return IASExtractDWORD(vendorID); }

   WORD getVersion() const throw ()
   { return IASExtractWORD(version); }

   DWORD getServerAddress() const throw ()
   { return IASExtractDWORD(serverAddress); }

   FILETIME getLastReboot() const throw ()
   {
      FILETIME ft;
      ft.dwHighDateTime = IASExtractDWORD(lastReboot);
      ft.dwLowDateTime  = IASExtractDWORD(lastReboot + 4);
      return ft;
   }

   DWORDLONG getSerialNumber() const throw ()
   { 
      ULARGE_INTEGER ul;
      ul.HighPart = IASExtractDWORD(serialNumber);
      ul.LowPart  = IASExtractDWORD(serialNumber + 4);
      return ul.QuadPart;
   }

   const BYTE* getString() const throw ()
   { return serialNumber + 8; }

   // Returns TRUE if the class attribute is in Microsoft format.
   BOOL isMicrosoft(DWORD actualLength) const throw ();

   // Must be called before any calls to createAttribute.
   static void initialize() throw ();

   // Create a new class attribute. The caller is responsible for releasing
   // the returned attribute. The tag is optional and may be null.
   static PIASATTRIBUTE createAttribute(const IAS_OCTET_STRING* tag) throw ();
};

#endif  // _CLASSATTRIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\database.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class Database
//
///////////////////////////////////////////////////////////////////////////////

#ifndef DATABASE_H
#define DATABASE_H
#pragma once

#include "lmcons.h"
#include "account.h"
#include "commandpool.h"
#include "resource.h"

class ATL_NO_VTABLE Database
   : public Accountant,
     public CComCoClass<Database, &__uuidof(DatabaseAccounting)>
{
public:

IAS_DECLARE_REGISTRY(DatabaseAccounting, 1, IAS_REGISTRY_AUTO, IASTypeLibrary)
IAS_DECLARE_OBJECT_ID(IAS_PROVIDER_MICROSOFT_DB_ACCT)

   Database() throw ();
   ~Database() throw ();

   HRESULT FinalConstruct() throw ();

protected:
   // IIasComponent
   STDMETHOD(Initialize)();
   STDMETHOD(Shutdown)();
   STDMETHOD(PutProperty)(LONG Id, VARIANT* pValue);

private:
   virtual void Process(IASTL::IASRequest& request);

   virtual void InsertRecord(
                   void* context,
                   IASTL::IASRequest& request,
                   const SYSTEMTIME& localTime,
                   PATTRIBUTEPOSITION first,
                   PATTRIBUTEPOSITION last
                   );

   virtual void Flush(
                   void* context,
                   IASTL::IASRequest& request,
                   const SYSTEMTIME& localTime
                   );

   // Execute a command. It need not be prepared.
   HRESULT ExecuteCommand(
              ReportEventCommand& command,
              const wchar_t* doc,
              bool retry
              ) throw ();

   // Prepare a command for execution.
   HRESULT PrepareCommand(ReportEventCommand& command) throw ();

   // Reset the connection to the database.
   void ResetConnection() throw ();

   // Events that trigger state changes.
   void OnConfigChange() throw ();
   void OnConnectError() throw ();
   void OnExecuteSuccess(ReportEventCommand& command) throw ();
   void OnExecuteError(ReportEventCommand& command) throw ();
   bool IsBlackedOut() throw ();
   void SetBlackOut() throw ();

   // States of the database connection.
   enum State
   {
      AVAILABLE,
      QUESTIONABLE,
      BLACKED_OUT
   };

   // Local computer name; included in each event we report.
   wchar_t computerName[MAX_COMPUTERNAME_LENGTH + 1];

   // Database initialization string. null if not configured.
   CComBSTR initString;

   // Connection to the database.
   CComPtr<IDBCreateSession> dataSource;

   // Pool of reusable commands.
   CommandPool pool;

   // Current state of the connection.
   State state;

   // Expiration time of the blackout state; ignored if state != BLACKED_OUT.
   ULONGLONG blackoutExpiry;

   // Blackout interval in units of DCE time.
   static const ULONGLONG blackoutInterval;

   // Not implemented.
   Database(const Database&);
   Database& operator=(const Database&);
};


#endif // DATABASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\formbuf.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    formbuf.h
//
// SYNOPSIS
//
//    Declares the class FormattedBuffer.
//
// MODIFICATION HISTORY
//
//    08/04/1998    Original version.
//    12/17/1998    Add append overload for IASATTRIBUTE&.
//    01/25/1999    Date and time are separate fields.
//    03/23/1999    Add support for text qualifiers.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _FORMBUF_H_
#define _FORMBUF_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <iaspolcy.h>
#include <outbuf.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    FormattedBuffer
//
// DESCRIPTION
//
//    Extends the OutputBuffer class to provide IAS specific formatting.
//
///////////////////////////////////////////////////////////////////////////////
class FormattedBuffer
   : public OutputBuffer
{
public:
   using OutputBuffer::append;

   FormattedBuffer(CHAR qualifier) throw ()
      : textQualifier(qualifier) { }

   void append(DWORD value);
   void append(DWORDLONG value);
   void append(const IASVALUE& value);
   void append(const IASATTRIBUTE& attr);
   void append(const ATTRIBUTEPOSITION* pos);
   void append(const IAS_OCTET_STRING& value);

   void appendClassAttribute(const IAS_OCTET_STRING& value);
   void appendFormattedOctets(const BYTE* buf, DWORD buflen);
   void appendDate(const SYSTEMTIME& value);
   void appendQualifier() { append(textQualifier); }
   void appendText(PCSTR sz, DWORD szlen);
   void appendTime(const SYSTEMTIME& value);

   void beginColumn() { append(','); }
   void endRecord()   { append((PBYTE)"\r\n", 2); }

private:
   const CHAR textQualifier;
};

#endif  // _FORMBUF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\formbuf.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    formbuf.cpp
//
// SYNOPSIS
//
//    Defines the class FormattedBuffer.
//
// MODIFICATION HISTORY
//
//    08/04/1998    Original version.
//    12/17/1998    Add append overload for IASATTRIBUTE&.
//    01/22/1999    UTF-8 support.
//    01/25/1999    Date and time are separate fields.
//    03/23/1999    Add support for text qualifiers.
//    04/19/1999    Strip null-terminators from OctetStrings.
//    05/17/1999    Handle ANSI strings correctly.
//    06/01/1999    Make sure Class 'string' is printable.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasattr.h>
#include <iasutil.h>
#include <iasutf8.h>
#include <sdoias.h>

#include <classattr.h>
#include <formbuf.h>

//////////
// Helper function that returns the number of printable characters if an
// OctetString consists solely of printable UTF-8 characters.
//////////
DWORD
WINAPI
IsOctetStringPrintable(
    PBYTE buf,
    DWORD buflen
    ) throw ()
{
   // Is the last character just a null terminator?
   if (buflen && !buf[buflen - 1]) { --buflen; }

   PBYTE p   = buf;
   PBYTE end = buf + buflen;

   // Scan for control characters and delimiters.
   while (p < end)
   {
      if (!(*p & 0x60)) { return 0; }

      ++p;
   }

   // Ensure it's a valid UTF-8 string.
   return (IASUtf8ToUnicodeLength((PCSTR)buf, buflen) >= 0) ? buflen : 0;
}

void FormattedBuffer::append(DWORD value)
{
   CHAR buffer[11], *p = buffer + 11;

   do
   {
      *--p = '0' + (CHAR)(value % 10);

   } while (value /= 10);

   append((const BYTE*)p, (DWORD)(buffer + 11 - p));
}

void FormattedBuffer::append(DWORDLONG value)
{
   CHAR buffer[21], *p = buffer + 21;

   do
   {
      *--p = '0' + (CHAR)(value % 10);

   } while (value /= 10);

   append((const BYTE*)p, (DWORD)(buffer + 21 - p));
}

void FormattedBuffer::append(const IASVALUE& value)
{
   switch (value.itType)
   {
      case IASTYPE_BOOLEAN:
      case IASTYPE_INTEGER:
      case IASTYPE_ENUM:
      {
         append(value.Integer);
         break;
      }

      case IASTYPE_OCTET_STRING:
      case IASTYPE_PROV_SPECIFIC:
      {
         append(value.OctetString);
         break;
      }

      case IASTYPE_INET_ADDR:
      {
         CHAR buffer[16];
         append(ias_inet_htoa(value.InetAddr, buffer));
         break;
      }

      case IASTYPE_STRING:
      {
         // Make sure we have a Unicode string available.
         if (!value.String.pszWide)
         {
            // If there's no ANSI string either, then there's nothing to log.
            if (!value.String.pszAnsi) { break; }

            // Convert the value into an attribute ...
            PIASATTRIBUTE p = (PIASATTRIBUTE)
               ((ULONG_PTR)&value - FIELD_OFFSET(IASATTRIBUTE, Value));

            // ... and allocate a Unicode string.
            if (IASAttributeUnicodeAlloc(p) != NO_ERROR)
            {
               throw std::bad_alloc();
            }
         }

         // Compute the length of the source Unicode string.
         DWORD srclen = wcslen(value.String.pszWide);

         // Compute the length of the converted UTF-8 string.
         LONG dstlen = IASUnicodeToUtf8Length(value.String.pszWide, srclen);

         // Allocate space for the converted string.
         PSTR dst = (PSTR)_alloca(dstlen);

         // Convert the string.
         IASUnicodeToUtf8(value.String.pszWide, srclen, dst);

         // Write the buffer.
         appendText(dst, dstlen);
         break;
      }

      case IASTYPE_UTC_TIME:
      {
         SYSTEMTIME st;
         FileTimeToSystemTime(&value.UTCTime, &st);
         appendDate(st);
         append(' ');
         appendTime(st);
         break;
      }
   }
}

//////////
// Appends a single attribute value.
//////////
void FormattedBuffer::append(const IASATTRIBUTE& attr)
{
   // Class attributes are special-cased.
   if (attr.dwId == RADIUS_ATTRIBUTE_CLASS)
   {
      appendClassAttribute(attr.Value.OctetString);
   }
   else
   {
      append(attr.Value);
   }
}

//////////
// Appends an array of attributes. The array is terminated either by a null
// attribute pointer or an attribute with a different ID.
//////////
void FormattedBuffer::append(const ATTRIBUTEPOSITION* pos)
{
   DWORD id = pos->pAttribute->dwId;

   // Will this attribute be written as text?
   BOOL isText = FALSE;
   switch (pos->pAttribute->Value.itType)
   {
      case IASTYPE_INET_ADDR:
      case IASTYPE_STRING:
      case IASTYPE_OCTET_STRING:
      case IASTYPE_PROV_SPECIFIC:
         isText = TRUE;
   }

   // If so, then we surround it with the text qualifier.
   if (isText) { appendQualifier(); }

   // Write the first value.
   append(*(pos->pAttribute));
   ++pos;

   // Then add any additional values delimited by a pipe.
   while (pos->pAttribute && pos->pAttribute->dwId == id)
   {
      append('|');
      append(*(pos->pAttribute));
      ++pos;
   }

   // Write the closing text qualifier if necessary.
   if (isText) { appendQualifier(); }
}

//////////
// Appends an octet string attribute value.
//////////
void FormattedBuffer::append(const IAS_OCTET_STRING& value)
{
   DWORD len = IsOctetStringPrintable(value.lpValue, value.dwLength);

   if (len)
   {
      appendText((PCSTR)value.lpValue, len);
   }
   else
   {
      appendFormattedOctets(value.lpValue, value.dwLength);
   }
}

//////////
// Appends a class attribute
//////////
void FormattedBuffer::appendClassAttribute(const IAS_OCTET_STRING& value)
{
   // Extract a class attribute from the blob.
   IASClass* cl = (IASClass*)value.lpValue;

   if (!cl->isMicrosoft(value.dwLength))
   {
      // If it's not one of ours try to write is as a string
      append(value);
   }
   else
   {
      // Vendor ID.
      append(cl->getVendorID());

      // Version.
      append(' ');
      append((DWORD)cl->getVersion());

      // Server IP address.
      CHAR buffer[16];
      append(' ');
      append(ias_inet_htoa(cl->getServerAddress(), buffer));

      // Server reboot time.
      FILETIME ft = cl->getLastReboot();
      SYSTEMTIME st;
      FileTimeToSystemTime(&ft, &st);
      append(' ');
      appendDate(st);
      append(' ');
      appendTime(st);

      // Session serial number.
      DWORDLONG serialNumber = cl->getSerialNumber();
      append(' ');
      append(serialNumber);

      // Class string.
      if (value.dwLength > sizeof(IASClass))
      {
         append(' ');

         // Convert the remainder to an OctetString ...
         IASVALUE tmp;
         tmp.itType = IASTYPE_OCTET_STRING;
         tmp.OctetString.lpValue = const_cast<PBYTE>(cl->getString());
         tmp.OctetString.dwLength = value.dwLength - sizeof(IASClass);

         // ... and append.
         append(tmp);
      }
   }
}

// Convert a hex number to an ascii digit. Does not check for overflow.
#define HEX_TO_ASCII(h) ((h) < 10 ? '0' + (CHAR)(h) : ('A' - 10) + (CHAR)(h))

//////////
// Appends an octet string as stringized hex.
//////////
void FormattedBuffer::appendFormattedOctets(
                          const BYTE* buf,
                          DWORD buflen
                          )
{
   PCHAR dst = (PCHAR)reserve(buflen * 2 + 2);

   //////////
   // Add a leading 0x.
   //////////

   *dst = '0';
   ++dst;
   *dst = 'x';
   ++dst;

   //////////
   // Add each octet.
   //////////

   while (buflen)
   {
      CHAR digit;

      // High-order digit.
      digit = (CHAR)(*buf >> 4);
      *dst = HEX_TO_ASCII(digit);
      ++dst;

      // Low-order digit.
      digit = (CHAR)(*buf & 0xf);
      *dst = HEX_TO_ASCII(digit);
      ++dst;

      // Advance to the next octet.
      ++buf;
      --buflen;
   }
}

// insert a 4 character integer.
#define INSERT_4u(p, v) \
{ *p = '0' + (v) / 1000;    ++p; *p = '0' + (v) / 100 % 10; ++p; \
  *p = '0' + (v) / 10 % 10; ++p; *p = '0' + (v) % 10;       ++p; }

// insert a 2 character integer.
#define INSERT_2u(p, v) \
{ *p = '0' + (v) / 10; ++p; *p = '0' + (v) % 10; ++p; }

// insert a single character.
#define INSERT_1c(p, v) \
{ *p = v; ++p; }

void FormattedBuffer::appendDate(const SYSTEMTIME& value)
{
   PCHAR p = (PCHAR)reserve(10);

   INSERT_2u(p, value.wMonth);
   INSERT_1c(p, '/');
   INSERT_2u(p, value.wDay);
   INSERT_1c(p, '/');
   INSERT_4u(p, value.wYear);
}

void FormattedBuffer::appendText(PCSTR sz, DWORD szlen)
{
   if (textQualifier)
   {
      /////////
      // We have a text qualifier, so we don't have to worry about embedded
      // delimiters, but we do have to worry about embedded qualifiers. We
      // replace each embedded qualifier with a double qualifier.
      /////////

      PCSTR p;
      while ((p = (PCSTR)memchr(sz, textQualifier, szlen)) != NULL)
      {
         // Skip past the qualifier.
         ++p;

         // How many bytes do we have ?
         DWORD nbyte = p - sz;

         // Write the bytes.
         append((const BYTE*)sz, nbyte);

         // Add an extra qualifer.
         append(textQualifier);

         // Update our state to point to the remainder of the text.
         sz = p;
         szlen -= nbyte;
      }

      // Write the piece after the last embedded qualifer.
      append((PBYTE)sz, szlen);
   }
   else
   {
      ////////
      // No text qualifer, so we can't handle embedded delimiter.
      ////////

      if (!memchr(sz, ',', szlen))
      {
         // No delimiters, so write 'as is'.
         append((PBYTE)sz, szlen);
      }
      else
      {
         // It contains a delimiter so write as formatted octets.
         appendFormattedOctets((PBYTE)sz, szlen);
      }
   }
}

void FormattedBuffer::appendTime(const SYSTEMTIME& value)
{
   PCHAR p = (PCHAR)reserve(8);

   INSERT_2u(p, value.wHour);
   INSERT_1c(p, ':');
   INSERT_2u(p, value.wMinute);
   INSERT_1c(p, ':');
   INSERT_2u(p, value.wSecond);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\database.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the class Database.
//
///////////////////////////////////////////////////////////////////////////////

#include "ias.h"
#include "database.h"
#include "dbconfig.h"
#include "xmlwriter.h"


const ULONGLONG Database::blackoutInterval = 2 * 10000000ui64;


Database::Database() throw ()
   : state(AVAILABLE),
     blackoutExpiry(0)
{
}


Database::~Database() throw ()
{
}


HRESULT Database::FinalConstruct() throw ()
{
   return pool.FinalConstruct();
}


STDMETHODIMP Database::Initialize()
{
   DWORD len = sizeof(computerName) / sizeof(wchar_t);
   if (!GetComputerNameW(computerName, &len))
   {
      computerName[0] = L'\0';
   }

   return Accountant::Initialize();
}


STDMETHODIMP Database::Shutdown()
{
   ResetConnection();
   return Accountant::Shutdown();
}


STDMETHODIMP Database::PutProperty(LONG Id, VARIANT *pValue)
{
   // We only process one property. Everything else is proxied to our base
   // class.
   if (Id != PROPERTY_ACCOUNTING_SQL_MAX_SESSIONS)
   {
      return Accountant::PutProperty(Id, pValue);
   }

   // Check the arguments.
   if (pValue == 0)
   {
      return E_POINTER;
   }
   if (V_VT(pValue) != VT_I4)
   {
      return E_INVALIDARG;
   }

   // This is a good time to reread the LSA config as well.
   CComBSTR newInitString;
   CComBSTR dataSourceName;
   HRESULT hr = IASLoadDatabaseConfig(
                   0,
                   &newInitString,
                   &dataSourceName
                   );
   if (FAILED(hr))
   {
      return hr;
   }

   // Did the config change?
   if (!initString ||
       !newInitString ||
       (wcscmp(initString, newInitString) != 0))
   {
      OnConfigChange();
      initString.Attach(newInitString.Detach());
   }

   pool.SetMaxCommands(V_I4(pValue));

   return S_OK;
}


void Database::Process(IASTL::IASRequest& request)
{
   // Quick precheck so we don't waste time if the database isn't configured.
   if (initString)
   {
      RecordEvent(0, request);
   }
}


void Database::InsertRecord(
                   void* context,
                   IASTL::IASRequest& request,
                   const SYSTEMTIME& localTime,
                   PATTRIBUTEPOSITION first,
                   PATTRIBUTEPOSITION last
                   )
{
   XmlWriter doc;
   doc.StartDocument();

   doc.InsertElement(L"Computer-Name", computerName, XmlWriter::DataType::string);

   static const wchar_t eventSourceName[] = L"Event-Source";
   switch (request.get_Protocol())
   {
      case IAS_PROTOCOL_RADIUS:
      {
         doc.InsertElement(eventSourceName, L"IAS", XmlWriter::DataType::string);
         break;
      }

      case IAS_PROTOCOL_RAS:
      {
         doc.InsertElement(eventSourceName, L"RAS", XmlWriter::DataType::string);
         break;
      }

      default:
      {
         break;
      }
   }

   for (PATTRIBUTEPOSITION i = first; i != last; ++i)
   {
      const LogField* field = schema.find(i->pAttribute->dwId);
      if ((field != 0) && !field->excludeFromDatabase)
      {
         doc.InsertAttribute(field->name, *(i->pAttribute));
      }
   }

   doc.EndDocument();

   HRESULT hr;

   ReportEventCommand* command = pool.Alloc();
   if (command != 0)
   {
      hr = ExecuteCommand(*command, doc.GetDocument(), true);

      pool.Free(command);
   }
   else
   {
      hr = E_OUTOFMEMORY;
   }

   if (FAILED(hr))
   {
      IASTL::issue_error(hr);
   }
}


void Database::Flush(
                  void* context,
                  IASTL::IASRequest& request,
                  const SYSTEMTIME& localTime
                  )
{
}


HRESULT Database::ExecuteCommand(
                     ReportEventCommand& command,
                     const wchar_t* doc,
                     bool retry
                     ) throw ()
{
   HRESULT hr = PrepareCommand(command);
   if (hr == S_OK)
   {
      hr = command.Execute(doc);
      if (SUCCEEDED(hr))
      {
         OnExecuteSuccess(command);
      }
      else
      {
         OnExecuteError(command);

         if (retry)
         {
            ExecuteCommand(command, doc, false);
         }
      }
   }

   return hr;
}


HRESULT Database::PrepareCommand(ReportEventCommand& command) throw ()
{
   HRESULT hr = S_OK;

   Lock();

   if (!initString)
   {
      // If we don't have an initialization string, it's not an error. It just
      // means the admin never configured it.
      hr = S_FALSE;
   }
   else if (IsBlackedOut())
   {
      // Don't even try to prepare if we're blacked out.
      hr = E_FAIL;
   }
   else
   {
      // Create the connection if necessary.
      if (!dataSource)
      {
         hr = ReportEventCommand::CreateDataSource(
                                     initString,
                                     &dataSource
                                     );
         if (FAILED(hr))
         {
            OnConnectError();
         }
      }

      // If we have a good connection, prepare the command if necessary.
      if (SUCCEEDED(hr) && !command.IsPrepared())
      {
         hr = command.Prepare(dataSource);
         if (FAILED(hr))
         {
            OnConnectError();
         }
      }
   }

   Unlock();

   return hr;
}


void Database::ResetConnection() throw ()
{
   dataSource.Release();
   pool.UnprepareAll();
}


inline void Database::OnConfigChange() throw ()
{
   ResetConnection();
   state = AVAILABLE;
}


void Database::OnConnectError() throw ()
{
   ResetConnection();
   SetBlackOut();
}


inline void Database::OnExecuteSuccess(ReportEventCommand& command) throw ()
{
   // Suppress events from old connections.
   if (command.Version() == pool.Version())
   {
      state = AVAILABLE;
   }
}


inline void Database::OnExecuteError(ReportEventCommand& command) throw ()
{
   Lock();

   // Suppress events from old connections.
   if (command.Version() == pool.Version())
   {
      ResetConnection();

      if (state == AVAILABLE)
      {
         state = QUESTIONABLE;
      }
      else if (state == QUESTIONABLE)
      {
         SetBlackOut();
      }
   }

   command.Unprepare();

   Unlock();
}


inline bool Database::IsBlackedOut() throw ()
{
   if (state == BLACKED_OUT)
   {
      ULONGLONG now;
      GetSystemTimeAsFileTime(reinterpret_cast<FILETIME*>(&now));
      if (now >= blackoutExpiry)
      {
         state = AVAILABLE;
      }
   }

   return state == BLACKED_OUT;
}


void Database::SetBlackOut() throw ()
{
   state = BLACKED_OUT;
   GetSystemTimeAsFileTime(reinterpret_cast<FILETIME*>(&blackoutExpiry));
   blackoutExpiry += blackoutInterval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\iasacct.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasacct.cpp
//
// SYNOPSIS
//
//    Implementation of DLL exports for an ATL in proc server.
//
// MODIFICATION HISTORY
//
//    08/04/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasutil.h>
#include <newop.cpp>

#include <database.h>
#include <localfile.h>

CComModule _Module;
#include <atlimpl.cpp>

BEGIN_OBJECT_MAP(ObjectMap)
   OBJECT_ENTRY(__uuidof(Accounting),
                IASTL::IASRequestHandlerObject<LocalFile> )
   OBJECT_ENTRY(__uuidof(DatabaseAccounting),
                IASTL::IASRequestHandlerObject<Database> )
END_OBJECT_MAP()


//////////
// DLL Entry Point
//////////
BOOL
WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID /*lpReserved*/
    )
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
     _Module.Init(ObjectMap, hInstance);

     DisableThreadLibraryCalls(hInstance);
   }
   else if (dwReason == DLL_PROCESS_DETACH)
   {
     _Module.Term();
   }

   return TRUE;
}


//////////
// Used to determine whether the DLL can be unloaded by OLE
//////////
STDAPI DllCanUnloadNow(void)
{
   return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


//////////
// Returns a class factory to create an object of the requested type.
//////////
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
   return _Module.GetClassObject(rclsid, riid, ppv);
}


//////////
// DllRegisterServer - Adds entries to the system registry
//////////
STDAPI DllRegisterServer(void)
{
   return  _Module.RegisterServer(FALSE);
}


//////////
// DllUnregisterServer - Removes entries from the system registry
//////////
STDAPI DllUnregisterServer(void)
{
   return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\localfile.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    localfile.cpp
//
// SYNOPSIS
//
//    Defines the class LocalFile.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasutf8.h>
#include <sdoias.h>

#include <algorithm>

#include <localfile.h>
#include <classattr.h>
#include <formbuf.h>

#define STACK_ALLOC(type, num) (type*)_alloca(sizeof(type) * (num))

//////////
// Misc. enumerator constants.
//////////
const LONG  INET_LOG_FORMAT_INTERNET_STD  = 0;
const LONG  INET_LOG_FORMAT_NCSA          = 3;
const LONG  INET_LOG_FORMAT_ODBC_RADIUS   = 0xFFFF;


//////////
// Inserts a class attribute into the request.
//////////
extern "C"
HRESULT
WINAPI
InsertClassAttribute(
    IAttributesRaw* pRaw
    )
{
   //////////
   // Check if this was proxied.
   //////////
   PIASATTRIBUTE attr = IASPeekAttribute(
                            pRaw,
                            IAS_ATTRIBUTE_PROVIDER_TYPE,
                            IASTYPE_ENUM
                            );
   if (attr && attr->Value.Enumerator == IAS_PROVIDER_RADIUS_PROXY)
   {
      return S_OK;
   }


   //////////
   // Check if Generate Class Attribute is disabled
   //////////
   PIASATTRIBUTE generateClassAttr = IASPeekAttribute(
                            pRaw,
                            IAS_ATTRIBUTE_GENERATE_CLASS_ATTRIBUTE,
                            IASTYPE_BOOLEAN
                            );

   if (generateClassAttr && generateClassAttr->Value.Boolean == FALSE)
   {
      return S_OK;
   }

   //////////
   // Create a new class attribute
   // Do not remove any existing class attribute.
   //////////

   ATTRIBUTEPOSITION pos;
   pos.pAttribute = IASClass::createAttribute(NULL);

   if (pos.pAttribute == NULL) { return E_OUTOFMEMORY; }

   //////////
   // Insert into the request.
   //////////

   HRESULT hr = pRaw->AddAttributes(1, &pos);
   IASAttributeRelease(pos.pAttribute);

   return hr;
}


LocalFile::LocalFile() throw ()
   : computerNameLen(0)
{
}


STDMETHODIMP LocalFile::Initialize()
{
   // Get the Unicode computer name.
   WCHAR uniName[MAX_COMPUTERNAME_LENGTH + 1];
   DWORD len = sizeof(uniName) / sizeof(WCHAR);
   if (!GetComputerNameW(uniName, &len))
   {
      // If it failed, we'll just use an empty string.
      len = 0;
   }

   // Convert the Unicode to UTF-8.
   computerNameLen = IASUnicodeToUtf8(uniName, len, computerName);

   IASClass::initialize();

   return Accountant::Initialize();
}


STDMETHODIMP LocalFile::Shutdown()
{
   log.Close();
   return Accountant::Shutdown();
}


STDMETHODIMP LocalFile::PutProperty(LONG Id, VARIANT *pValue)
{
   if (pValue == NULL) { return E_INVALIDARG; }

   switch (Id)
   {
      case PROPERTY_ACCOUNTING_LOG_OPEN_NEW_FREQUENCY:
      {
         if (V_VT(pValue) != VT_I4) { return DISP_E_TYPEMISMATCH; }
         switch (V_I4(pValue))
         {
            case IAS_LOGGING_UNLIMITED_SIZE:
            case IAS_LOGGING_WHEN_FILE_SIZE_REACHES:
            case IAS_LOGGING_DAILY:
            case IAS_LOGGING_WEEKLY:
            case IAS_LOGGING_MONTHLY:
               return log.SetPeriod(
                             static_cast<NEW_LOG_FILE_FREQUENCY>(
                                V_I4(pValue)
                                )
                             );
               break;

            default:
               return E_INVALIDARG;
         }
         break;
      }

      case PROPERTY_ACCOUNTING_LOG_OPEN_NEW_SIZE:
      {
         if (V_VT(pValue) != VT_I4) { return DISP_E_TYPEMISMATCH; }
         if (V_I4(pValue) <= 0) { return E_INVALIDARG; }
         log.SetMaxSize(V_I4(pValue) * 0x100000ui64);
         break;
      }

      case PROPERTY_ACCOUNTING_LOG_FILE_DIRECTORY:
      {
         if (V_VT(pValue) != VT_BSTR) { return DISP_E_TYPEMISMATCH; }
         if (V_BSTR(pValue) == NULL)
         { return E_INVALIDARG; }
         return log.SetDirectory(V_BSTR(pValue));
         break;
      }

      case PROPERTY_ACCOUNTING_LOG_IAS1_FORMAT:
      {
         if (V_VT(pValue) != VT_I4) { return DISP_E_TYPEMISMATCH; }
         switch (V_I4(pValue))
         {
            case INET_LOG_FORMAT_ODBC_RADIUS:
               format = formatODBCRecord;
               break;

            case INET_LOG_FORMAT_INTERNET_STD:
               format = formatW3CRecord;
               break;

            default:
               return E_INVALIDARG;
         }
         break;
      }

      case PROPERTY_ACCOUNTING_LOG_DELETE_IF_FULL:
      {
         if (V_VT(pValue) != VT_BOOL) { return DISP_E_TYPEMISMATCH; }
         log.SetDeleteIfFull((V_BOOL(pValue)) != 0);
         break;
      }

      default:
      {
         return Accountant::PutProperty(Id, pValue);
      }
   }

   return S_OK;
}


void LocalFile::Process(IASTL::IASRequest& request)
{
   // Do some custom preprocessing.
   switch (request.get_Request())
   {
      case IAS_REQUEST_ACCOUNTING:
      {
         if (request.get_Response() == IAS_RESPONSE_INVALID)
         {
            request.SetResponse(IAS_RESPONSE_ACCOUNTING, S_OK);
         }
         break;
      }

      case IAS_REQUEST_ACCESS_REQUEST:
      {
         InsertClassAttribute(request);
         break;
      }

      default:
      {
         break;
      }
   }

   // Create a FormattedBuffer of the correct type.
   FormattedBuffer buffer((format == formatODBCRecord) ? '\"' : '\0');

   RecordEvent(&buffer, request);
}


void LocalFile::InsertRecord(
                   void* context,
                   IASTL::IASRequest& request,
                   const SYSTEMTIME& localTime,
                   PATTRIBUTEPOSITION first,
                   PATTRIBUTEPOSITION last
                   )
{
   FormattedBuffer& buffer = *static_cast<FormattedBuffer*>(context);

   // Invoke the currently configured formatter.
   (this->*format)(request, buffer, localTime, first, last);

   // We're done.
   buffer.endRecord();
}


void LocalFile::Flush(
                   void* context,
                   IASTL::IASRequest& request,
                   const SYSTEMTIME& localTime
                   )
{
   FormattedBuffer& buffer = *static_cast<FormattedBuffer*>(context);

   if (!buffer.empty())
   {
      if (!log.Write(
                  request.get_Protocol(),
                  localTime,
                  buffer.getBuffer(),
                  buffer.getLength()
                  ))
      {
         IASTL::issue_error(HRESULT_FROM_WIN32(ERROR_WRITE_FAULT));
      }
   }
}


void LocalFile::formatODBCRecord(
                     IASTL::IASRequest& request,
                     FormattedBuffer& buffer,
                     const SYSTEMTIME& localTime,
                     PATTRIBUTEPOSITION firstPos,
                     PATTRIBUTEPOSITION lastPos
                     ) const
{
   //////////
   // Column 1: Computer name.
   //////////

   buffer.append('\"');
   buffer.append((PBYTE)computerName, computerNameLen);
   buffer.append('\"');

   //////////
   // Column 2: Service name.
   //////////

   buffer.beginColumn();

   switch (request.get_Protocol())
   {
      case IAS_PROTOCOL_RADIUS:
         buffer.append((const BYTE*)"\"IAS\"", 5);
         break;

      case IAS_PROTOCOL_RAS:
         buffer.append((const BYTE*)"\"RAS\"", 5);
         break;
   }

   //////////
   // Column 3: Record time.
   //////////

   buffer.beginColumn();
   buffer.appendDate(localTime);
   buffer.beginColumn();
   buffer.appendTime(localTime);

   //////////
   // Allocate a blank record.
   //////////

   PATTRIBUTEPOSITION *firstField, *curField, *lastField;
   size_t nfield = schema.getNumFields() + 1;
   firstField = STACK_ALLOC(PATTRIBUTEPOSITION, nfield);
   memset(firstField, 0, sizeof(PATTRIBUTEPOSITION) * nfield);
   lastField = firstField + nfield;

   //////////
   // Sort the attributes to coalesce multi-valued attributes.
   //////////

   std::sort(firstPos, lastPos, IASTL::IASOrderByID());

   //////////
   // Add a null terminator. This will make it easier to handle multi-valued
   // attributes.
   //////////

   lastPos->pAttribute = NULL;

   //////////
   // Fill in the fields.
   //////////

   PATTRIBUTEPOSITION curPos;
   DWORD lastSeen = (DWORD)-1;
   for (curPos = firstPos; curPos != lastPos; ++curPos)
   {
      // Only process if this is a new attribute type.
      if (curPos->pAttribute->dwId != lastSeen)
      {
         lastSeen = curPos->pAttribute->dwId;

         firstField[schema.getOrdinal(lastSeen)] = curPos;
      }
   }

   //////////
   // Pack the record into the buffer. We skip field 0, since that's where
   // we map all the attributes we don't want to log.
   //////////

   for (curField = firstField + 1; curField != lastField; ++curField)
   {
      buffer.beginColumn();

      if (*curField) { buffer.append(*curField); }
   }
}

void LocalFile::formatW3CRecord(
                     IASTL::IASRequest& request,
                     FormattedBuffer& buffer,
                     const SYSTEMTIME& localTime,
                     PATTRIBUTEPOSITION firstPos,
                     PATTRIBUTEPOSITION lastPos
                     ) const
{
   //////////
   // Column 1: NAS-IP-Addresses
   //////////

   PIASATTRIBUTE attr = IASPeekAttribute(
                           request,
                           RADIUS_ATTRIBUTE_NAS_IP_ADDRESS,
                           IASTYPE_INET_ADDR
                           );
   if (attr == 0)
   {
      attr = IASPeekAttribute(
                request,
                IAS_ATTRIBUTE_CLIENT_IP_ADDRESS,
                IASTYPE_INET_ADDR
                );
   }

   if (attr != 0)
   {
      buffer.append(attr->Value);
   }

   //////////
   // Column 2: User-Name
   //////////

   buffer.beginColumn();
   attr = IASPeekAttribute(request,
                           RADIUS_ATTRIBUTE_USER_NAME,
                           IASTYPE_OCTET_STRING);
   if (attr) { buffer.append(attr->Value); }

   //////////
   // Column 3: Record time.
   //////////

   buffer.beginColumn();
   buffer.appendDate(localTime);
   buffer.beginColumn();
   buffer.appendTime(localTime);

   //////////
   // Column 4: Service name.
   //////////

   buffer.beginColumn();

   switch (request.get_Protocol())
   {
      case IAS_PROTOCOL_RADIUS:
         buffer.append("IAS");
         break;

      case IAS_PROTOCOL_RAS:
         buffer.append("RAS");
         break;
   }

   //////////
   // Column 5: Computer name.
   //////////

   buffer.beginColumn();
   buffer.append((PBYTE)computerName, computerNameLen);

   //////////
   // Pack the attributes into the buffer.
   //////////

   PATTRIBUTEPOSITION curPos;
   for (curPos = firstPos; curPos != lastPos; ++curPos)
   {
      if (!schema.excludeFromLog(curPos->pAttribute->dwId))
      {
         buffer.beginColumn();
         buffer.append(curPos->pAttribute->dwId);
         buffer.beginColumn();
         buffer.append(*(curPos->pAttribute));
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\localfile.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class LocalFile
//
///////////////////////////////////////////////////////////////////////////////

#ifndef LOCALFILE_H
#define LOCALFILE_H
#pragma once

#include "lmcons.h"
#include "account.h"
#include "logfile.h"
#include "resource.h"

class FormattedBuffer;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    LocalFile
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE LocalFile
   : public Accountant,
     public CComCoClass<LocalFile, &__uuidof(Accounting)>
{
public:

IAS_DECLARE_REGISTRY(Accounting, 1, IAS_REGISTRY_AUTO, IASTypeLibrary)
IAS_DECLARE_OBJECT_ID(IAS_PROVIDER_MICROSOFT_ACCOUNTING)

   LocalFile() throw ();

protected:
   // IIasComponent
   STDMETHOD(Initialize)();
   STDMETHOD(Shutdown)();
   STDMETHOD(PutProperty)(LONG Id, VARIANT* pValue);

private:
   virtual void Process(IASTL::IASRequest& request);

   virtual void InsertRecord(
                   void* context,
                   IASTL::IASRequest& request,
                   const SYSTEMTIME& localTime,
                   PATTRIBUTEPOSITION first,
                   PATTRIBUTEPOSITION last
                   );

   virtual void Flush(
                   void* context,
                   IASTL::IASRequest& request,
                   const SYSTEMTIME& localTime
                   );

   // Signature of a record formatter.
   typedef void (__stdcall LocalFile::*Formatter)(
                                          IASTL::IASRequest& request,
                                          FormattedBuffer& buffer,
                                          const SYSTEMTIME& localTime,
                                          PATTRIBUTEPOSITION firstPos,
                                          PATTRIBUTEPOSITION lastPos
                                          ) const;

   // Formatter for ODBC records.
   void __stdcall formatODBCRecord(
                      IASTL::IASRequest& request,
                      FormattedBuffer& buffer,
                      const SYSTEMTIME& localTime,
                      PATTRIBUTEPOSITION firstPos,
                      PATTRIBUTEPOSITION lastPos
                      ) const;

   // Formatter for W3C records.
   void __stdcall formatW3CRecord(
                      IASTL::IASRequest& request,
                      FormattedBuffer& buffer,
                      const SYSTEMTIME& localTime,
                      PATTRIBUTEPOSITION firstPos,
                      PATTRIBUTEPOSITION lastPos
                      ) const;

   LogFile log;       // Log file.
   Formatter format;  // Pointer to member function being used for formatting.

   // Cached computername in UTF-8.
   CHAR computerName[MAX_COMPUTERNAME_LENGTH * 3];
   DWORD computerNameLen;
};

#endif // LOCALFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\logfile.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    logfile.cpp
//
// SYNOPSIS
//
//    Defines the class LogFile.
//
///////////////////////////////////////////////////////////////////////////////

#include "ias.h"
#include "logfile.h"
#include <climits>
#include <new>
#include "iasevent.h"
#include "iastrace.h"
#include "iasutil.h"
#include "mprlog.h"

inline StringSentry::StringSentry(wchar_t* p) throw ()
   : sz(p)
{
}


inline StringSentry::~StringSentry() throw ()
{
   delete[] sz;
}


inline const wchar_t* StringSentry::Get() const throw ()
{
   return sz;
}


inline bool StringSentry::IsNull() const throw ()
{
   return sz == 0;
}


inline StringSentry::operator const wchar_t*() const throw ()
{
   return sz;
}


inline StringSentry::operator wchar_t*() throw ()
{
   return sz;
}


inline void StringSentry::Swap(StringSentry& other) throw ()
{
   wchar_t* temp = sz;
   sz = other.sz;
   other.sz = temp;
}


inline StringSentry& StringSentry::operator=(wchar_t* p) throw ()
{
   if (sz != p)
   {
      delete[] sz;
      sz = p;
   }
   return *this;
}


LogFile::LogFile() throw ()
   : deleteIfFull(true),
     period(IAS_LOGGING_UNLIMITED_SIZE),
     seqNum(0),
     file(INVALID_HANDLE_VALUE),
     firstDayOfWeek(0),
     iasEventSource(RegisterEventSourceW(0, L"IAS")),
     rasEventSource(RegisterEventSourceW(0, L"RemoteAccess"))
{
   maxSize.QuadPart = _UI64_MAX;

   wchar_t buffer[4];
   if (GetLocaleInfo(
          LOCALE_SYSTEM_DEFAULT,
          LOCALE_IFIRSTDAYOFWEEK,
          buffer,
          sizeof(buffer)/sizeof(wchar_t)
          ))
   {
      // The locale info calls Monday day zero, while SYSTEMTIME calls
      // Sunday day zero.
      firstDayOfWeek = (1 +  static_cast<DWORD>(_wtoi(buffer))) % 7;
   }
}


LogFile::~LogFile() throw ()
{
   Close();

   if (iasEventSource != 0)
   {
      DeregisterEventSource(iasEventSource);
   }

   if (rasEventSource != 0)
   {
      DeregisterEventSource(rasEventSource);
   }
}


void LogFile::SetDeleteIfFull(bool newVal) throw ()
{
   Lock();

   deleteIfFull = newVal;

   Unlock();

   IASTracePrintf("LogFile.DeleteIfFull = %s", (newVal ? "true" : "false"));
}


DWORD LogFile::SetDirectory(const wchar_t* newVal) throw ()
{
   if (newVal == 0)
   {
      return ERROR_INVALID_PARAMETER;
   }

   // How big is the expanded directory string?
   DWORD len = ExpandEnvironmentStringsW(
                   newVal,
                   0,
                   0
                   );
   if (len == 0)
   {
      return GetLastError();
   }

   // Allocate memory to hold the new directory and expand any variables.
   StringSentry newDirectory(new (std::nothrow) wchar_t[len]);
   if (newDirectory.IsNull())
   {
      return E_OUTOFMEMORY;
   }
   len = ExpandEnvironmentStringsW(
            newVal,
            newDirectory,
            len
            );
   if (len == 0)
   {
      return GetLastError();
   }

   // Does it end in a backlash ?
   if ((len > 1) && (newDirectory[len - 2] == L'\\'))
   {
      // Null out the backslash.
      newDirectory[len - 2] = L'\0';
   }

   Lock();

   DWORD error = NO_ERROR;

   // Is this a new directory?
   if (directory.IsNull() || (wcscmp(newDirectory, directory) != 0))
   {
      // Save the new value.
      directory.Swap(newDirectory);

      // Close the old file.
      Close();

      // Rescan the sequence number.
      error = UpdateSequence();
   }

   Unlock();

   IASTracePrintf("LogFile.Directory = %S", directory.Get());

   return error;
}


void LogFile::SetMaxSize(const ULONGLONG& newVal) throw ()
{
   Lock();

   maxSize.QuadPart = newVal;

   Unlock();

   IASTracePrintf(
      "LogFile.MaxSize = 0x%08X%08X",
      maxSize.HighPart,
      maxSize.LowPart
      );
}


DWORD LogFile::SetPeriod(NEW_LOG_FILE_FREQUENCY newVal) throw ()
{
   DWORD error = NO_ERROR;

   Lock();

   if (newVal != period)
   {
      // A new period means a new filename.
      Close();

      period = newVal;

      if (!directory.IsNull())
      {
         error = UpdateSequence();
      }
   }

   Unlock();

   IASTracePrintf("LogFile.Period = %u", newVal);

   return error;
}



bool LogFile::Write(
                 IASPROTOCOL protocol,
                 const SYSTEMTIME& st,
                 const BYTE* buf,
                 DWORD buflen,
                 bool allowRetry
                 ) throw ()
{
   Lock();

   // Save the currently cached file handle (may be null or stale).
   HANDLE cached = file;

   // Get the correct handle for the write.
   CheckFileHandle(protocol, st, buflen);

   bool success = false;

   if (file != INVALID_HANDLE_VALUE)
   {
      DWORD error;
      do
      {
         DWORD bytesWritten;
         if (WriteFile(file, buf, buflen, &bytesWritten, 0))
         {
           currentSize.QuadPart += buflen;
           success = true;
           error = NO_ERROR;
         }
         else
         {
            error = GetLastError();
            IASTracePrintf("WriteFile failed; error = %lu", error);
         }
      }
      while ((error == ERROR_DISK_FULL) && DeleteOldestFile(protocol, st));

      if ((error != NO_ERROR) && (error != ERROR_DISK_FULL))
      {
         // If we used a cached handle and allowRetry, then try again.
         bool retry = (cached == file) && allowRetry;

         // Prevent others from using the bad handle.
         Close();

         // Now that we've closed the bad handle try again.
         if (retry)
         {
            // Set allowRetry to false to prevent an infinite recursion.
            success = Write(protocol, st, buf, buflen, false);
         }
      }
   }

   Unlock();

   return success;
}


void LogFile::Close() throw ()
{
   Lock();

   if (file != INVALID_HANDLE_VALUE)
   {
      CloseHandle(file);
      file = INVALID_HANDLE_VALUE;
   }

   Unlock();
}


void LogFile::CheckFileHandle(
                 IASPROTOCOL protocol,
                 const SYSTEMTIME& st,
                 DWORD buflen
                 ) throw ()
{
   // Do we have a valid handle?
   if (file == INVALID_HANDLE_VALUE)
   {
      OpenFile(protocol, st);
   }

   // Have we reached the next period?
   switch (period)
   {
      case IAS_LOGGING_DAILY:
      {
         if ((st.wDay != whenOpened.wDay) ||
             (st.wMonth != whenOpened.wMonth) ||
             (st.wYear != whenOpened.wYear))
         {
            OpenFile(protocol, st);
         }
         break;
      }

      case IAS_LOGGING_WEEKLY:
      {
         if ((GetWeekOfMonth(st) != weekOpened) ||
             (st.wMonth != whenOpened.wMonth) ||
             (st.wYear != whenOpened.wYear))
         {
            OpenFile(protocol, st);
         }
         break;
      }

      case IAS_LOGGING_MONTHLY:
      {
         if ((st.wMonth != whenOpened.wMonth) ||
             (st.wYear != whenOpened.wYear))
         {
            OpenFile(protocol, st);
         }
         break;
      }

      case IAS_LOGGING_WHEN_FILE_SIZE_REACHES:
      {
         while ((currentSize.QuadPart + buflen) > maxSize.QuadPart)
         {
            ++seqNum;
            OpenFile(protocol, st);
         }
         break;
      }

      case IAS_LOGGING_UNLIMITED_SIZE:
      default:
      {
         break;
      }
   }
}


HANDLE LogFile::CreateDirectoryAndFile() throw ()
{
   if (filename.IsNull())
   {
      SetLastError(ERROR_INVALID_FUNCTION);
      return INVALID_HANDLE_VALUE;
   }

   // Open the file if it exists or else create a new one.
   HANDLE newFile = CreateFileW(
                       filename,
                       GENERIC_WRITE,
                       FILE_SHARE_READ,
                       0,
                       OPEN_ALWAYS,
                       FILE_FLAG_SEQUENTIAL_SCAN,
                       0
                       );
   if (newFile != INVALID_HANDLE_VALUE)
   {
      return newFile;
   }

   if (GetLastError() != ERROR_PATH_NOT_FOUND)
   {
      return INVALID_HANDLE_VALUE;
   }

   // If the path is just a drive letter, there's nothing we can do.
   size_t len = wcslen(directory);
   if ((len != 0) && (directory[len - 1] == L':'))
   {
      return INVALID_HANDLE_VALUE;
   }

   // Otherwise, let's try to create the directory.
   if (!CreateDirectoryW(directory, NULL))
   {
      IASTracePrintf(
         "CreateDirectoryW(%S) failed; error = %lu",
         directory.Get(),
         GetLastError()
         );
      return INVALID_HANDLE_VALUE;
   }

   // Then try again to create the file.
   newFile = CreateFileW(
                filename,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                0,
                OPEN_ALWAYS,
                FILE_FLAG_SEQUENTIAL_SCAN,
                0
                );
   if (newFile == INVALID_HANDLE_VALUE)
   {
      IASTracePrintf(
         "CreateFileW(%S) failed; error = %lu",
         filename.Get(),
         GetLastError()
         );
   }

   return newFile;
}


bool LogFile::DeleteOldestFile(
                 IASPROTOCOL protocol,
                 const SYSTEMTIME& st
                 ) throw ()
{
   if (!deleteIfFull ||
       (period == IAS_LOGGING_UNLIMITED_SIZE) ||
       directory.IsNull() ||
       filename.IsNull())
   {
      return false;
   }

   bool success = false;

   // Find the lowest (oldest) file number.
   unsigned int number;
   DWORD error = FindFileNumber(st, true, number);
   switch (error)
   {
      case NO_ERROR:
      {
         // Convert the file number to a file name.
         StringSentry oldfile(FormatFileName(number));
         if (oldfile.IsNull())
         {
            ReportOldFileDeleteError(protocol, L"", ERROR_NOT_ENOUGH_MEMORY);
         }
         else if (_wcsicmp(oldfile, filename) == 0)
         {
            // Oldest file is the current file.
            ReportOldFileNotFound(protocol);
         }
         else if (DeleteFileW(oldfile))
         {
            ReportOldFileDeleted(protocol, oldfile);
            success = true;
         }
         else
         {
            ReportOldFileDeleteError(protocol, oldfile, GetLastError());
         }

         break;
      }

      case ERROR_FILE_NOT_FOUND:
      case ERROR_PATH_NOT_FOUND:
      {
         ReportOldFileNotFound(protocol);
         break;
      }

      default:
      {
         ReportOldFileDeleteError(protocol, L"", error);
         break;
      }
   }

   return success;
}


unsigned int LogFile::ExtendFileNumber(
                         const SYSTEMTIME& st,
                         unsigned int narrow
                         ) const throw ()
{
   unsigned int wide = narrow;
   switch (period)
   {
      case IAS_LOGGING_DAILY:
      case IAS_LOGGING_WEEKLY:
      {
         unsigned int century = st.wYear / 100;
         if (GetFileNumber(st) >= narrow)
         {
            wide += century * 1000000;
         }
         else
         {
            // We assume that log files are never from the future, so this file
            // must be from the previous century.
            wide += (century - 1) * 1000000;
         }
         break;
      }

      case IAS_LOGGING_MONTHLY:
      {
         unsigned int century = st.wYear / 100;
         if (GetFileNumber(st) >= narrow)
         {
            wide += century * 10000;
         }
         else
         {
            // We assume that log files are never from the future, so this file
            // must be from the previous century.
            wide += (century - 1) * 10000;
         }
         break;
      }

      case IAS_LOGGING_UNLIMITED_SIZE:
      case IAS_LOGGING_WHEN_FILE_SIZE_REACHES:
      default:
      {
         break;
      }
   }

   return wide;
}


DWORD LogFile::FindFileNumber(
                  const SYSTEMTIME& st,
                  bool findLowest,
                  unsigned int& result
                  ) const throw ()
{
   // Can't call this function until after the directory's been initialized.
   if (directory.IsNull())
   {
      return ERROR_INVALID_FUNCTION;
   }

   // The search filter passed to FindFirstFileW.
   StringSentry filter(
                   ias_makewcs(
                      directory.Get(),
                      L"\\",
                      GetFileNameFilter(),
                      0
                      )
                   );
   if (filter.IsNull())
   {
      return ERROR_NOT_ENOUGH_MEMORY;
   }

   // Format string used for extracting the numeric portion of the filename.
   const wchar_t* format = GetFileNameFormat();

   WIN32_FIND_DATAW findData;
   HANDLE hFind = FindFirstFileW(filter, &findData);
   if (hFind == INVALID_HANDLE_VALUE)
   {
      return GetLastError();
   }

   // Stores the best extended result found so far.
   unsigned int bestWideMatch = findLowest ? UINT_MAX : 0;
   // Stores the narrow version of bestWideMatch.
   unsigned int bestNarrowMatch = UINT_MAX;

   // Iterate through all the files that match the filter.
   do
   {
      // Extract the numeric portion and test its validity.
      unsigned int narrow;
      if (swscanf(findData.cFileName, format, &narrow) == 1)
      {
         if (IsValidFileNumber(wcslen(findData.cFileName), narrow))
         {
            // Extend the file number to include the century.
            unsigned int wide = ExtendFileNumber(st, narrow);

            // Update bestMatch as appropriate.
            if (wide < bestWideMatch)
            {
               if (findLowest)
               {
                  bestWideMatch = wide;
                  bestNarrowMatch = narrow;
               }
            }
            else
            {
               if (!findLowest)
               {
                  bestWideMatch = wide;
                  bestNarrowMatch = narrow;
               }
            }
         }
      }
   }
   while (FindNextFileW(hFind, &findData));

   FindClose(hFind);

   // Did we find a valid file?
   if (bestNarrowMatch == UINT_MAX)
   {
      return ERROR_FILE_NOT_FOUND;
   }

   // We found a valid file, so return the result.
   result = bestNarrowMatch;
   return NO_ERROR;
}


wchar_t* LogFile::FormatFileName(unsigned int number) const throw ()
{
   // Longest filename is iaslog4294967295.log
   wchar_t buffer[21];
   swprintf(buffer, GetFileNameFormat(), number);
   return ias_makewcs(directory.Get(), L"\\", buffer, 0);
}


const wchar_t* LogFile::GetFileNameFilter() const throw ()
{
   const wchar_t* filter;

   switch (period)
   {
      case IAS_LOGGING_WHEN_FILE_SIZE_REACHES:
      {
         filter = L"iaslog*.log";
         break;
      }

      case IAS_LOGGING_DAILY:
      case IAS_LOGGING_WEEKLY:
      case IAS_LOGGING_MONTHLY:
      {
         filter = L"IN*.log";
         break;
      }

      case IAS_LOGGING_UNLIMITED_SIZE:
      default:
      {
         filter = L"iaslog.log";
         break;
      }
   }

   return filter;
}


const wchar_t* LogFile::GetFileNameFormat() const throw ()
{
   const wchar_t* format;
   switch (period)
   {
      case IAS_LOGGING_WHEN_FILE_SIZE_REACHES:
      {
         format = L"iaslog%u.log";
         break;
      }

      case IAS_LOGGING_DAILY:
      case IAS_LOGGING_WEEKLY:
      {
         format = L"IN%06u.log";
         break;
      }

      case IAS_LOGGING_MONTHLY:
      {
         format = L"IN%04u.log";
         break;
      }

      case IAS_LOGGING_UNLIMITED_SIZE:
      default:
      {
         format = L"iaslog.log";
         break;
      }
   }

   return format;
}


unsigned int LogFile::GetFileNumber(const SYSTEMTIME& st) const throw ()
{
   unsigned int number;

   switch (period)
   {
      case IAS_LOGGING_WHEN_FILE_SIZE_REACHES:
      {
         number = seqNum;
         break;
      }

      case IAS_LOGGING_DAILY:
      {
         number = ((st.wYear % 100) * 10000) + (st.wMonth * 100) + st.wDay;
         break;
      }

      case IAS_LOGGING_WEEKLY:
      {
         number = ((st.wYear % 100) * 10000) + (st.wMonth * 100) +
                  GetWeekOfMonth(st);
         break;
      }

      case IAS_LOGGING_MONTHLY:
      {
         number = ((st.wYear % 100) * 100) + st.wMonth;
         break;
      }

      case IAS_LOGGING_UNLIMITED_SIZE:
      default:
      {
         number = 0;
         break;
      }
   }

   return number;
}


DWORD LogFile::GetWeekOfMonth(const SYSTEMTIME& st) const throw ()
{
   DWORD dom = st.wDay - 1;
   DWORD wom = 1 + dom / 7;

   if ((dom % 7) > ((st.wDayOfWeek + 7 - firstDayOfWeek) % 7))
   {
      ++wom;
   }

   return wom;
}


bool LogFile::IsValidFileNumber(size_t len, unsigned int num) const throw ()
{
   bool valid;

   switch (period)
   {
      case IAS_LOGGING_DAILY:
      {
         // INyymmdd.log
         unsigned int day = num % 100;
         unsigned int month = (num / 100) % 100;

         valid = (len == 12) &&
                 (day >= 1) && (day <= 31) &&
                 (month >= 1) && (month <= 12);
         break;
      }

      case IAS_LOGGING_WEEKLY:
      {
         // INyymmww.log
         unsigned int week = num % 100;
         unsigned int month = (num / 100) % 100;

         valid = (len == 12) &&
                 (week >= 1) && (week <= 5) &&
                 (month >= 1) && (month <= 12);
         break;
      }

      case IAS_LOGGING_MONTHLY:
      {
         // INyymm.log
         unsigned int month = num % 100;

         valid = (len == 10) && (month >= 1) && (month <= 12);
         break;
      }

      case IAS_LOGGING_WHEN_FILE_SIZE_REACHES:
      {
         // iaslogN.log
         valid = (len > 10);
         break;
      }

      case IAS_LOGGING_UNLIMITED_SIZE:
      default:
      {
         // Doesn't contain a number, so never valid.
         valid = false;
         break;
      }
   }

   return valid;
}


void LogFile::OpenFile(IASPROTOCOL protocol, const SYSTEMTIME& st) throw ()
{
   // Save the time when the file was opened.
   whenOpened = st;
   weekOpened = GetWeekOfMonth(st);

   // Assume the currentSize is zero until we successfully open a file.
   currentSize.QuadPart = 0;

   // Close the exisisting file.
   Close();

   filename = FormatFileName(GetFileNumber(st));
   if (!filename.IsNull())
   {
      HANDLE newFile;
      do
      {
         newFile = CreateDirectoryAndFile();
      }
      while ((newFile == INVALID_HANDLE_VALUE) &&
             (GetLastError() == ERROR_DISK_FULL) &&
             DeleteOldestFile(protocol, st));

      if (newFile != INVALID_HANDLE_VALUE)
      {
         file = newFile;

         // Get the size of the file.
         currentSize.LowPart = GetFileSize(file, &currentSize.HighPart);
         if ((currentSize.LowPart == 0xFFFFFFFF) &&
             (GetLastError() != NO_ERROR))
         {
            Close();
         }
         else
         {
            // Start writing new information at the end of the file.
            SetFilePointer(file, 0, 0, FILE_END);
         }
      }
   }
}


DWORD LogFile::UpdateSequence() throw ()
{
   if (period != IAS_LOGGING_WHEN_FILE_SIZE_REACHES)
   {
      seqNum = 0;
   }
   else
   {
      // SYSTEMTIME is ignored for sized files, so we can simply pass an
      // unitialized struct.
      SYSTEMTIME st;
      DWORD error = FindFileNumber(st, false, seqNum);
      switch (error)
      {
         case NO_ERROR:
         {
            break;
         }

         case ERROR_FILE_NOT_FOUND:
         case ERROR_PATH_NOT_FOUND:
         {
            seqNum = 0;
            break;
         }

         default:
         {
            return error;
         }
      }
   }

   return NO_ERROR;
}


void LogFile::ReportOldFileDeleteError(
                 IASPROTOCOL protocol,
                 const wchar_t* oldfile,
                 DWORD error
                 ) const throw ()
{
   HANDLE eventLog;
   DWORD eventId;
   switch (protocol)
   {
      case IAS_PROTOCOL_RADIUS:
      {
         eventLog = iasEventSource;
         eventId = ACCT_E_OLD_LOG_DELETE_ERROR;
         break;
      }

      case IAS_PROTOCOL_RAS:
      {
         eventLog = rasEventSource;
         eventId = ROUTERLOG_OLD_LOG_DELETE_ERROR;
         break;
      }

      default:
      {
         return;
      }
   }

   ReportEventW(
      eventLog,
      EVENTLOG_ERROR_TYPE,
      0,
      eventId,
      0,
      1,
      sizeof(error),
      &oldfile,
      &error
      );
}


void LogFile::ReportOldFileDeleted(
                 IASPROTOCOL protocol,
                 const wchar_t* oldfile
                 ) const throw ()
{
   HANDLE eventLog;
   DWORD eventId;
   switch (protocol)
   {
      case IAS_PROTOCOL_RADIUS:
      {
         eventLog = iasEventSource;
         eventId = ACCT_S_OLD_LOG_DELETED;
         break;
      }

      case IAS_PROTOCOL_RAS:
      {
         eventLog = rasEventSource;
         eventId = ROUTERLOG_OLD_LOG_DELETED;
         break;
      }

      default:
      {
         return;
      }
   }

   ReportEventW(
      eventLog,
      EVENTLOG_SUCCESS,
      0,
      eventId,
      0,
      1,
      0,
      &oldfile,
      0
      );
}


void LogFile::ReportOldFileNotFound(
                 IASPROTOCOL protocol
                 ) const throw ()
{
   HANDLE eventLog;
   DWORD eventId;
   switch (protocol)
   {
      case IAS_PROTOCOL_RADIUS:
      {
         eventLog = iasEventSource;
         eventId = ACCT_I_OLD_LOG_NOT_FOUND;
         break;
      }

      case IAS_PROTOCOL_RAS:
      {
         eventLog = rasEventSource;
         eventId = ROUTERLOG_OLD_LOG_NOT_FOUND;
         break;
      }

      default:
      {
         return;
      }
   }

   ReportEventW(
      eventLog,
      EVENTLOG_INFORMATION_TYPE,
      0,
      eventId,
      0,
      0,
      0,
      0,
      0
      );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\logschema.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class LogSchema
//
///////////////////////////////////////////////////////////////////////////////

#ifndef LOGSCHEMA_H
#define LOGSCHEMA_H
#pragma once

#include <hashmap.h>
#include <nocopy.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    LogField
//
// DESCRIPTION
//
//    Describes a field in the logfile.
//
///////////////////////////////////////////////////////////////////////////////
class LogField
{
public:
   LogField() throw ()
   { }

   LogField(
      DWORD id,
      const wchar_t* attrName,
      DWORD order,
      BOOL shouldExclude
      ) throw ()
      : iasID(id),
        name(attrName),
        ordinal(order),
        excludeFromLog(shouldExclude),
        excludeFromDatabase(shouldExclude)
   {
      if ((id == RADIUS_ATTRIBUTE_USER_NAME) ||
          (id == RADIUS_ATTRIBUTE_NAS_IP_ADDRESS))
      {
         excludeFromDatabase = FALSE;
      }
   }

   bool operator<(const LogField& f) const throw ()
   { return ordinal < f.ordinal; }

   bool operator==(const LogField& f) const throw ()
   { return iasID == f.iasID; }

   DWORD hash() const throw ()
   { return iasID; }

   DWORD iasID;
   const wchar_t* name;
   DWORD ordinal;
   BOOL excludeFromLog;
   BOOL excludeFromDatabase;
};

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    LogSchema
//
// DESCRIPTION
//
//    This class reads the logfile schema from the dictionary and creates
//    a vector of DWORDs containing the attributes to be logged in column
//    order.
//
///////////////////////////////////////////////////////////////////////////////
class LogSchema : NonCopyable
{
public:

   LogSchema() throw ();
   ~LogSchema() throw ();

   DWORD getNumFields() const throw ()
   { return numFields; }

   // Returns TRUE if the given attribute ID should be excluded from the log.
   BOOL excludeFromLog(DWORD iasID) const throw ();

   // Returns the LogField data for a given attribute ID.
   const LogField* find(DWORD iasID) const throw ();

   // Return the ordinal for a given attribute ID. An ordinal of zero
   // indicates that the attribute should not be logged.
   DWORD getOrdinal(DWORD iasID) const throw ();

   // Initialize the dictionary for use.
   HRESULT initialize() throw ();

   // Shutdown the dictionary after use.
   void shutdown() throw ();

protected:
   // Clear the schema.
   void clear() throw ();

   typedef hash_table < LogField > SchemaTable;

   SchemaTable schema;
   DWORD numFields; // Number of fields in the ODBC schema.
   DWORD refCount;  // Initialization ref. count.
};

#endif // LOGSCHEMA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\outbuf.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    outbuf.h
//
// SYNOPSIS
//
//    Declares the class OutputBuffer.
//
// MODIFICATION HISTORY
//
//    08/04/1998    Original version.
//    07/09/1999    Add OutputBuffer::empty
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _OUTBUF_H_
#define _OUTBUF_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <nocopy.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    OutputBuffer
//
// DESCRIPTION
//
//    Implements a dynamically resized buffer suitable for formatting output.
//
///////////////////////////////////////////////////////////////////////////////
class OutputBuffer
   : NonCopyable
{
public:
   OutputBuffer() throw ();
   ~OutputBuffer() throw ();

   // Append an octet string.
   void append(const BYTE* buf, DWORD buflen);

   // Append a null-terminated ANSI string.
   void append(PCSTR sz);

   // Append a single ANSI character.
   void append(CHAR ch);

   bool empty() const throw ()
   { return next == start; }

   // Returns a pointer to the embedded buffer.
   PBYTE getBuffer() const throw ()
   { return start; }

   // Returns the number of bytes currently stored in the buffer.
   DWORD getLength() const throw ()
   { return (DWORD)(next - start); }

   // Reserves 'nbyte' bytes in the buffer and returns a pointer to the
   // reserved bytes.
   PBYTE reserve(DWORD nbyte);

protected:
   // Resizes the buffer and updates cursor to point into the new buffer.
   void resize(PBYTE& cursor);

   PBYTE start, next, end;
   BYTE scratch[0x400];
};

#endif  // _OUTBUF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\outbuf.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    outbuf.cpp
//
// SYNOPSIS
//
//    Defines the class OutputBuffer.
//
// MODIFICATION HISTORY
//
//    08/04/1998    Original version.
//    11/17/1998    Streamline resize().
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <outbuf.h>

OutputBuffer::OutputBuffer() throw ()
   : start(scratch),
     next(scratch),
     end(scratch + sizeof(scratch))
{ }

OutputBuffer::~OutputBuffer() throw ()
{
   // Delete the buffer if necessary.
   if (start != scratch) { delete[] start; }
}

//////////
// I defined this as a macro to force the compiler to inline it.
//////////
#define QUICK_RESERVE(p, nbyte) \
   p = next; if ((next += nbyte) > end) { resize(p); }

// Append an octet string.
void OutputBuffer::append(const BYTE* buf, DWORD buflen)
{
   PBYTE p;
   QUICK_RESERVE(p, buflen);
   memcpy(p, buf, buflen);
}

// Append a null-terminated ANSI string.
void OutputBuffer::append(PCSTR sz)
{
   DWORD len = strlen(sz);
   PBYTE p;
   QUICK_RESERVE(p, len);
   memcpy(p, sz, len);
}

// Append a single ANSI character.
void OutputBuffer::append(CHAR ch)
{
   PBYTE p;
   QUICK_RESERVE(p, 1);
   *p = (BYTE)ch;
}

// Reserves 'nbyte' bytes in the buffer and returns a pointer to the
// reserved bytes.
PBYTE OutputBuffer::reserve(DWORD nbyte)
{
   PBYTE p;
   QUICK_RESERVE(p, nbyte);
   return p;
}

void OutputBuffer::resize(PBYTE& cursor)
{
   // Convert everything to relative offsets.
   ptrdiff_t cursorOffset = cursor - start;
   ptrdiff_t nextOffset   = next   - start;
   ptrdiff_t endOffset    = end    - start;

   // We always at least double the buffer.
   endOffset *= 2;

   // Make sure it's big enough to hold the next chunk.
   if (endOffset < nextOffset) { endOffset = nextOffset; }

   // Allocate the new buffer and copy in the existing bytes.
   PBYTE newBuffer = new BYTE[(size_t)endOffset];
   memcpy(newBuffer, start, (size_t)cursorOffset);

   // Release the old buffer if necessary.
   if (start != scratch) { delete[] start; }

   // Save the new buffer.
   start = newBuffer;

   // Convert from offsets back to absolutes.
   next   = start + nextOffset;
   cursor = start + cursorOffset;
   end    = start + endOffset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\logfile.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    logfile.h
//
// SYNOPSIS
//
//    Declares the class LogFile.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef LOGFILE_H
#define LOGFILE_H
#pragma once

#include "guard.h"
#include "iaspolcy.h"
#include "sdoias.h"


// Assumes ownership of a string pointer allocated with operator new[] and
// frees the string in its destructor.
class StringSentry
{
public:
   explicit StringSentry(wchar_t* p = 0) throw ();
   ~StringSentry() throw ();

   const wchar_t* Get() const throw ();
   bool IsNull() const throw ();

   operator const wchar_t*() const throw ();
   operator wchar_t*() throw ();

   void Swap(StringSentry& other) throw ();

   StringSentry& operator=(wchar_t* p) throw ();

private:
   wchar_t* sz;

   // Not implemented.
   StringSentry(const StringSentry&);
   StringSentry& operator=(const StringSentry&);
};


// Maintains a generic logfile that is periodically rolled over either when a
// specified interval has elapsed or the logfile reaches a certain size.
class LogFile : private Guardable
{
public:
   LogFile() throw ();
   ~LogFile() throw ();

   // Various properties supported by the logfile.
   void SetDeleteIfFull(bool newVal) throw ();
   DWORD SetDirectory(const wchar_t* newVal) throw ();
   void SetMaxSize(const ULONGLONG& newVal) throw ();
   DWORD SetPeriod(NEW_LOG_FILE_FREQUENCY newVal) throw ();

   // Write a record to the logfile.
   bool Write(
           IASPROTOCOL protocol,
           const SYSTEMTIME& st,
           const BYTE* buf,
           DWORD buflen,
           bool allowRetry = true
           ) throw ();

   // Close the logfile.
   void Close() throw ();

private:
   // Checks the state of the current file handle and opens a new file if
   // necessary.
   void CheckFileHandle(
           IASPROTOCOL protocol,
           const SYSTEMTIME& st,
           DWORD buflen
           ) throw ();

   // Create a new file including the directory if necessary. The caller is
   // responsible for closing the returned handle.
   HANDLE CreateDirectoryAndFile() throw ();

   // Delete the oldest file in the logfile directory. Returns true if
   // successful.
   bool DeleteOldestFile(IASPROTOCOL protocol, const SYSTEMTIME& st) throw ();

   // Extends the file number to include the century if necessary.
   unsigned int ExtendFileNumber(
                   const SYSTEMTIME& st,
                   unsigned int narrow
                   ) const throw ();

   // Finds the lowest or highest log file number.
   DWORD FindFileNumber(
            const SYSTEMTIME& st,
            bool findLowest,
            unsigned int& result
            ) const throw ();

   // Returns the formatted logfile name. The caller is responsible for
   // deleting the returned string.
   wchar_t* FormatFileName(unsigned int number) const throw ();

   // Returns the filter used to search for the file name.
   const wchar_t* GetFileNameFilter() const throw ();

   // Returns the format string used to create the file name.
   const wchar_t* GetFileNameFormat() const throw ();

   // Returns the numeric portion of the file name.
   unsigned int GetFileNumber(const SYSTEMTIME& st) const throw ();

   // Returns the 1-based week within the month for the given SYSTEMTIME.
   DWORD GetWeekOfMonth(const SYSTEMTIME& st) const throw ();

   // Tests the validity of a file number. len is the length in characters of
   // the file name containing the number -- useful for width tests.
   bool IsValidFileNumber(size_t len, unsigned int num) const throw ();

   // Releases the current file (if any) and opens a new one.
   void OpenFile(IASPROTOCOL protocol, const SYSTEMTIME& st) throw ();

   // Scans the logfile directory to determine the next sequence number.
   DWORD UpdateSequence() throw ();

   // Functions that report the result of deleting an old log file to free up
   // disk space.
   void ReportOldFileDeleteError(
           IASPROTOCOL protocol,
           const wchar_t* oldfile,
           DWORD error
           ) const throw ();
   void ReportOldFileDeleted(
           IASPROTOCOL protocol,
           const wchar_t* oldfile
           ) const throw ();
   void ReportOldFileNotFound(
           IASPROTOCOL protocol
           ) const throw ();

   // The logfile directory; does not have a trailing backslash.
   StringSentry directory;
   // true if old logfiles should be deleted if the disk is full.
   bool deleteIfFull;
   // The max size in bytes that the logfile will be allowed to reach.
   ULARGE_INTEGER maxSize;
   // The period at which new log files are opened.
   NEW_LOG_FILE_FREQUENCY period;
   // The current sequence number used for sized log files.
   unsigned int seqNum;
   // Handle to the log file; may be invalid.
   HANDLE file;
   // Current log file name; may be null.
   StringSentry filename;
   // Time at which we last opened or tried to open the logfile.
   SYSTEMTIME whenOpened;
   // Week at which we last opened or tried to open the logfile.
   DWORD weekOpened;
   // Current size of the log file in bytes. Zero if no file is open.
   ULARGE_INTEGER currentSize;
   // First day of the week for our locale.
   DWORD firstDayOfWeek;
   // Handle used for reporting IAS events.
   HANDLE iasEventSource;
   // Handle used for reporting RemoteAccess events.
   HANDLE rasEventSource;

   // Not implemented.
   LogFile(const LogFile&);
   LogFile& operator=(const LogFile&);
};


#endif  // LOGFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\logschema.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    logschema.cpp
//
// SYNOPSIS
//
//    Defines the class LogSchema.
//
// MODIFICATION HISTORY
//
//    08/04/1998    Original version.
//    12/02/1998    Added excludeFromLog.
//    04/14/2000    Port to new dictionary API.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iastlb.h>
#include <iastlutl.h>
#include <iasutil.h>

#include <algorithm>
#include <vector>

#include <sdoias.h>
#include <logschema.h>

LogSchema::LogSchema() throw ()
   : numFields(0), refCount(0)
{ }

LogSchema::~LogSchema() throw ()
{ }

BOOL LogSchema::excludeFromLog(DWORD iasID) const throw ()
{
   LogField key;
   key.iasID = iasID;
   const SchemaTable::value_type* p = schema.find(key);
   return p ? p->excludeFromLog : FALSE;
}

// Returns the LogField data for a given attribute ID.
const LogField* LogSchema::find(DWORD iasID) const throw ()
{
   LogField key;
   key.iasID = iasID;
   return schema.find(key);
}

DWORD LogSchema::getOrdinal(DWORD iasID) const throw ()
{
   LogField key;
   key.iasID = iasID;
   const SchemaTable::value_type* p = schema.find(key);
   return p ? p->ordinal : 0;
}

HRESULT LogSchema::initialize() throw ()
{
   IASGlobalLockSentry sentry;

   // Have we already been initialized ?
   if (refCount != 0)
   {
      ++refCount;

      return S_OK;
   }

   try
   {
      // Names of various columns in the dictionary.
      const PCWSTR COLUMNS[] =
      {
         L"ID",
         L"Name",
         L"Exclude from NT4 IAS Log",
         L"ODBC Log Ordinal",
         NULL
      };

      // Open the attributes table.
      IASTL::IASDictionary dnary(COLUMNS);

      std::vector< LogField > record;

      while (dnary.next())
      {
         // Read ID.
         DWORD iasID = (DWORD)dnary.getLong(0);

         // Read the name.
         const wchar_t* name = dnary.getBSTR(1);

         // Read [Exclude from NT4 IAS Log] if present.
         BOOL exclude = (BOOL)dnary.getBool(2);

         // Read [ODBC Log Ordinal] if present.
         DWORD ordinal = (DWORD)dnary.getLong(3);

         record.push_back(LogField(iasID, name, ordinal, exclude));
      }

      // Sort the fields by ordinal.
      std::sort(record.begin(), record.end());

      //////////
      // Insert the fields into the table.
      //////////

      numFields = 0;
      for (std::vector< LogField >::iterator i = record.begin();
           i != record.end();
           ++i)
      {
         // Normalize the ordinal.
         if (i->ordinal) { i->ordinal = ++numFields; }

         schema.insert(*i);
      }
   }
   catch (const std::bad_alloc&)
   {
      clear();

      return E_OUTOFMEMORY;
   }
   catch (const _com_error& ce)
   {
      clear();

      return ce.Error();
   }

   // We were successful so add ref.
   refCount = 1;

   return S_OK;
}

void LogSchema::shutdown() throw ()
{
   IASGlobalLockSentry sentry;

   _ASSERT(refCount != 0);

   if (--refCount == 0) { clear(); }
}

void LogSchema::clear() throw ()
{
   schema.clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\reporteventcmd.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the class ReportEventCommand.
//
///////////////////////////////////////////////////////////////////////////////

#include "ias.h"
#include "reporteventcmd.h"
#include "msdasc.h"


HRESULT ReportEventCommand::Prepare(IDBCreateSession* dbCreateSession) throw ()
{
   HRESULT hr;

   CComPtr<IDBCreateCommand> dbCreateCommand;
   hr = dbCreateSession->CreateSession(
                            0,
                            __uuidof(IDBCreateCommand),
                            reinterpret_cast<IUnknown**>(&dbCreateCommand)
                            );
   if (FAILED(hr))
   {
      TraceOleDbError("IDBCreateSession::CreateSession", hr);
      return hr;
   }

   CComPtr<ICommandText> commandText;
   hr = dbCreateCommand->CreateCommand(
                            0,
                            __uuidof(ICommandText),
                            reinterpret_cast<IUnknown**>(&commandText)
                            );
   if (FAILED(hr))
   {
      TraceOleDbError("IDBCreateCommand::CreateCommand", hr);
      return hr;
   }

   hr = commandText->SetCommandText(
                        DBGUID_SQL,
                        L"{rpc dbo.report_event}"
                        );
   if (FAILED(hr))
   {
      TraceOleDbError("ICommandText::SetCommandText", hr);
      return hr;
   }

   CComPtr<ICommandWithParameters> commandWithParameters;
   hr = commandText->QueryInterface(
                        __uuidof(ICommandWithParameters),
                        reinterpret_cast<void**>(&commandWithParameters)
                        );
   if (FAILED(hr))
   {
      TraceComError("IUnknown::QueryInterface(ICommandWithParameters", hr);
      return hr;
   }

   // When using RPC call semantics, the stored procedure always has a return
   // value even if it's not declared. Thus, we bind and ignore.

   static const DB_UPARAMS paramOrdinal[] =
   {
      1,
      2
   };

   static const DBPARAMBINDINFO dbParamBindInfo[] =
   {
      {
         L"int",                // pwszDataSourceType
         L"return_value",       // pwszName
         sizeof(long),          // ulParamSize
         DBPARAMFLAGS_ISOUTPUT, // dwFlags
         0,                     // bPrecision
         0                      // bScale
      },
      {
         L"ntext",              // pwszDataSourceType
         L"@doc",               // pwszName
         ~0,                    // ulParamSize
         DBPARAMFLAGS_ISINPUT,  // dwFlags
         0,                     // bPrecision
         0                      // bScale
      }
   };

   hr = commandWithParameters->SetParameterInfo(
                                  2,
                                  paramOrdinal,
                                  dbParamBindInfo
                                  );
   if (FAILED(hr))
   {
      TraceOleDbError("ICommandWithParameters::SetParameterInfo", hr);
      return hr;
   }

   CComPtr<IAccessor> accessor;
   hr = commandText->QueryInterface(
                        __uuidof(IAccessor),
                        reinterpret_cast<void**>(&accessor)
                        );
   if (FAILED(hr))
   {
      TraceComError("IUnknown::QueryInterface(IAccessor)", hr);
      return hr;
   }

   static const DBBINDING dbBinding[] =
   {
      {
         1,                             // iOrdinal
         0,                             // obValue
         0,                             // obLength
         0,                             // obStatus
         0,                             // pTypeInfo
         0,                             // pObject
         0,                             // pBindExt
         DBPART_VALUE,                  // dwPart
         DBMEMOWNER_CLIENTOWNED,        // dwMemOwner
         DBPARAMIO_OUTPUT,              // eParamIO
         0,                             // cbMaxLen
         0,                             // dwFlags
         DBTYPE_I4,                     // wType
         0,                             // bPrecision
         0                              // bScale
      },
      {
         2,                             // iOrdinal
         offsetof(SprocParams, doc),    // obValue
         0,                             // obLength
         0,                             // obStatus
         0,                             // pTypeInfo
         0,                             // pObject
         0,                             // pBindExt
         DBPART_VALUE,                  // dwPart
         DBMEMOWNER_CLIENTOWNED,        // dwMemOwner
         DBPARAMIO_INPUT,               // eParamIO
         0,                             // cbMaxLen
         0,                             // dwFlags
         (DBTYPE_WSTR | DBTYPE_BYREF),  // wType
         0,                             // bPrecision
         0                              // bScale
      }
   };

   HACCESSOR h;
   hr = accessor->CreateAccessor(
                     DBACCESSOR_PARAMETERDATA,
                     2,
                     dbBinding,
                     sizeof(SprocParams),
                     &h,
                     0
                     );
   if (FAILED(hr))
   {
      TraceOleDbError("IAccessor::CreateAccessor", hr);
      return hr;
   }

   // Everything succeeded, so release the old resources ...
   ReleaseAccessorHandle();

   // ... and store the new.
   command = commandText;
   accessorManager = accessor;
   accessorHandle = h;

   return S_OK;
}


HRESULT ReportEventCommand::Execute(const wchar_t* doc) throw ()
{
   SprocParams data =
   {
      0,
      doc
   };

   DBPARAMS dbParmas =
   {
      &data,          // pData
      1,              // cParamSets
      accessorHandle  // hAccessor
   };

   HRESULT hr = command->Execute(
                            0,
                            IID_NULL,
                            &dbParmas,
                            0,
                            0
                            );
   if (FAILED(hr))
   {
      TraceOleDbError("ICommand::Execute", hr);
   }

   return hr;
}


void ReportEventCommand::Unprepare() throw ()
{
   ReleaseAccessorHandle();
   accessorManager.Release();
   command.Release();
   version = 0;
}


HRESULT ReportEventCommand::CreateDataSource(
                               const wchar_t* initString,
                               IDBCreateSession** newDataSource
                               ) throw ()
{
   HRESULT hr;

   CComPtr<IDataInitialize> dataInitialize;
   hr = CoCreateInstance(
           CLSID_MSDAINITIALIZE,
           0,
           CLSCTX_INPROC_SERVER,
           __uuidof(IDataInitialize),
           reinterpret_cast<void**>(&dataInitialize)
           );
   if (FAILED(hr))
   {
      TraceComError("CoCreateInstance(MSDAINITIALIZE)", hr);
      return hr;
   }

   CComPtr<IDBInitialize> dbInitialize;
   hr = dataInitialize->GetDataSource(
                           0,
                           CLSCTX_INPROC_SERVER,
                           initString,
                           __uuidof(IDBInitialize),
                           reinterpret_cast<IUnknown**>(&dbInitialize)
                           );
   if (FAILED(hr))
   {
      TraceOleDbError("IDataInitialize::GetDataSource", hr);
      return hr;
   }

   hr = dbInitialize->Initialize();
   if (FAILED(hr))
   {
      TraceOleDbError("IDBInitialize::Initialize", hr);
      return hr;
   }

   hr = dbInitialize->QueryInterface(
                         __uuidof(IDBCreateSession),
                         reinterpret_cast<void**>(newDataSource)
                         );
   if (FAILED(hr))
   {
      TraceComError("IUnknown::QueryInterface(IDBCreateSession)", hr);
      return hr;
   }

   return S_OK;
}


void ReportEventCommand::ReleaseAccessorHandle() throw ()
{
   if ((accessorHandle != 0) && accessorManager)
   {
      accessorManager->ReleaseAccessor(accessorHandle, 0);
   }

   accessorHandle = 0;
}


void ReportEventCommand::TraceComError(
                            const char* function,
                            HRESULT error
                            ) throw ()
{
   IASTracePrintf("%s failed; return value = 0x%08X", function, error);
}


void ReportEventCommand::TraceOleDbError(
                            const char* function,
                            HRESULT error
                            ) throw ()
{
   IASTracePrintf("%s failed; return value = 0x%08X", function, error);

   IErrorInfo* errInfo;
   if (GetErrorInfo(0, &errInfo) == S_OK)
   {
      HRESULT hr;
      BSTR description;
      hr = errInfo->GetDescription(&description);
      if (SUCCEEDED(hr))
      {
         IASTracePrintf("\tDescription: %S", description);
         SysFreeString(description);
      }

      IErrorRecords* errRecords;
      hr = errInfo->QueryInterface(
                       __uuidof(IErrorRecords),
                       reinterpret_cast<void**>(&errRecords)
                       );
      if (SUCCEEDED(hr))
      {
         ULONG numRecords = 0;
         errRecords->GetRecordCount(&numRecords);

         for (ULONG i = 0; i < numRecords; ++i)
         {
            ERRORINFO info;
            hr = errRecords->GetBasicErrorInfo(i, &info);
            if (SUCCEEDED(hr))
            {
               IASTracePrintf(
                   "\tRecord %lu: hrError = 0x%08X; dwMinor = 0x%08X",
                   i,
                   info.hrError,
                   info.dwMinor
                   );
            }
         }

         errRecords->Release();
      }

      errInfo->Release();
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\reporteventcmd.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class ReportEventCommand.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef REPORTEVENTCMD_H
#define REPORTEVENTCMD_H
#pragma once

#include "oledb.h"

// Invokes the report_event stored procedure.
class ReportEventCommand
{
public:
   ReportEventCommand() throw ();
   ~ReportEventCommand() throw ();

   // Used to detect stale command objects.
   unsigned int Version() const throw ();
   void SetVersion(unsigned int newVersion) throw ();

   // Functions for managing linked lists of commands.
   ReportEventCommand* Next() const throw ();
   void SetNext(ReportEventCommand* cmd) throw ();

   // Prepare the command for execution.
   HRESULT Prepare(IDBCreateSession* dbCreateSession) throw ();

   // Test if the command is prepared.
   bool IsPrepared() const throw ();

   // Execute the command. IsPrepared must be 'true'.
   HRESULT Execute(const wchar_t* doc) throw ();

   // Release all resources associated with the command.
   void Unprepare() throw ();

   static HRESULT CreateDataSource(
                     const wchar_t* dataSource,
                     IDBCreateSession** newDataSource
                     ) throw ();

private:
   // Parameters passed to the stored procedure.
   struct SprocParams
   {
      long retval;
      const wchar_t* doc;
   };

   void ReleaseAccessorHandle() throw ();

   static void TraceComError(
                  const char* function,
                  HRESULT error
                  ) throw ();
   static void TraceOleDbError(
                  const char* function,
                  HRESULT error
                  ) throw ();

   CComPtr<ICommand> command;
   CComPtr<IAccessor> accessorManager;
   HACCESSOR accessorHandle;
   unsigned int version;
   ReportEventCommand* next;

   // Not implemented.
   ReportEventCommand(const ReportEventCommand&);
   ReportEventCommand& operator=(const ReportEventCommand&);
};


inline ReportEventCommand::ReportEventCommand() throw ()
   : accessorHandle(0), version(0), next(0)
{
}


inline ReportEventCommand::~ReportEventCommand() throw ()
{
   ReleaseAccessorHandle();
}


inline unsigned int ReportEventCommand::Version() const throw ()
{
   return version;
}


inline void ReportEventCommand::SetVersion(
                                   unsigned int newVersion
                                   ) throw ()
{
   version = newVersion;
}


inline ReportEventCommand* ReportEventCommand::Next() const throw ()
{
   return next;
}


inline void ReportEventCommand::SetNext(ReportEventCommand* cmd) throw ()
{
   next = cmd;
}


inline bool ReportEventCommand::IsPrepared() const throw ()
{
   return command.p != 0;
}

#endif // REPORTEVENTCMD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\resource.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    resource.h
//
// SYNOPSIS
//
//    Resource ID's for the Accounting module.
//
// MODIFICATION HISTORY
//
//    08/04/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#define IDS_Accounting           101

#endif  // _RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\xmlwriter.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class XmlWriter.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef XMLWRITER_H
#define XMLWRITER_H
#pragma once

#include "iaspolcy.h"

struct IASClass;

// Used for converting IAS requests into an XML document.
class XmlWriter
{
public:
   // data types
   enum DataType
   {
      nonNegativeInteger,
      string,
      hexBinary,
      ipv4Address,
      sqlDateTime
   };

   XmlWriter();
   ~XmlWriter() throw ();

   void StartDocument();
   void EndDocument();

   void InsertElement(
           const wchar_t* name,
           const wchar_t* value,
           DataType dataType
           );

   void InsertAttribute(
           const wchar_t* name,
           const IASATTRIBUTE& value
           );

   const wchar_t* GetDocument() const throw ();

private:
   void InsertInteger(
           const wchar_t* name,
           DWORD value
           );

   void InsertInetAddr(
           const wchar_t* name,
           DWORD value
           );

   void InsertString(
           const wchar_t* name,
           const IAS_STRING& value
           );

   void InsertOctetString(
           const wchar_t* name,
           const IAS_OCTET_STRING& value
           );

   void InsertUTCTime(
           const wchar_t* name,
           const FILETIME& value
           );

   void InsertMicrosoftClass(
           const wchar_t* name,
           const IASClass& value
           );

   // Takes no action and returns false if value isn't printable UTF-8.
   bool InsertUtf8(
           const wchar_t* name,
           const char* value,
           DWORD valueLen
           );

   void InsertBinHex(
           const wchar_t* name,
           const IAS_OCTET_STRING& value
           );

   void Append(wchar_t c);
   void Append(const wchar_t* sz);

   void AppendStartTag(const wchar_t* name);
   void AppendStartTag(const wchar_t* name, DataType dataType);

   void AppendEndTag(const wchar_t* name);

   static wchar_t ConvertIntegerToHexWChar(unsigned char src) throw ();

   // Reserves nchar additional characters in the buffer and returns a pointer
   // to the beginning of the storage.
   wchar_t* Reserve(size_t nchar);

   // Ensures that the capacity of the scratch buffer is at least nchar. Does
   // not preserve the existing contents.
   void ReserveScratch(size_t nchar);

   // Initial size of the buffer.
   static const size_t initialCapacity = 2048;

   // Document buffer.
   wchar_t* begin;
   wchar_t* next;
   wchar_t* end;

   // 512 is enough to convert any RADIUS attribute to bin.hex.
   static const size_t minScratchCapcity = 512;

   // Scratch buffer used for conversions.
   wchar_t* scratch;
   size_t scratchCapacity;

   static const wchar_t rootElementName[];

   // Not implemented.
   XmlWriter(const XmlWriter&);
   XmlWriter& operator=(const XmlWriter&);
};


inline const wchar_t* XmlWriter::GetDocument() const throw ()
{
   return begin;
}

#endif // XMLWRITER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\accounting\xmlwriter.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the class XmlWriter.
//
///////////////////////////////////////////////////////////////////////////////

#include "ias.h"
#include "xmlwriter.h"
#include <cwchar>
#include <new>
#include "classattr.h"
#include "iasattr.h"
#include "iasutf8.h"
#include "iasutil.h"
#include "sdoias.h"

const wchar_t XmlWriter::rootElementName[] = L"Event";

XmlWriter::XmlWriter()
   : begin(new wchar_t[initialCapacity]),
     next(begin),
     end(begin + initialCapacity),
     scratch(0),
     scratchCapacity(0)
{
}


XmlWriter::~XmlWriter() throw ()
{
   delete[] begin;
   delete[] scratch;
}


void XmlWriter::StartDocument()
{
   AppendStartTag(rootElementName);
}


void XmlWriter::EndDocument()
{
   AppendEndTag(rootElementName);
   Append(L'\0');
}


void XmlWriter::InsertElement(
                   const wchar_t* name,
                   const wchar_t* value,
                   DataType dataType
                   )
{
   // XML markup characters. Technically, '>' only needs to be escaped if it's
   // part of a CDEnd sequence, but it's easier to do it every time.
   static const wchar_t markup[] = L"<>&";

   AppendStartTag(name, dataType);

   const wchar_t* end = value + wcslen(value);

   while (value < end)
   {
      // Look for markup.
      const wchar_t* p = wcspbrk(value, markup);

      // Copy until the markup or the end of the string.
      size_t nchar = (p == 0) ? (end - value) : (p - value);
      wmemcpy(Reserve(nchar), value, nchar);

      // Advance the cursor;
      value += nchar;

      // Escape the markup character if any.
      if (p != 0)
      {
         ++value;

         switch (*p)
         {
            case L'<':
            {
               Append(L"&lt;");
               break;
            }

            case L'>':
            {
               Append(L"&gt;");
               break;
            }

            case L'&':
            {
               Append(L"&amp;");
               break;
            }

            default:
            {
               __assume(0);
               break;
            }
         }
      }
   }

   AppendEndTag(name);
}


void XmlWriter::InsertAttribute(
                   const wchar_t* name,
                   const IASATTRIBUTE& value
                   )
{
   switch (value.Value.itType)
   {
      case IASTYPE_BOOLEAN:
      case IASTYPE_INTEGER:
      case IASTYPE_ENUM:
      {
         InsertInteger(name, value.Value.Integer);
         break;
      }

      case IASTYPE_INET_ADDR:
      {
         InsertInetAddr(name, value.Value.InetAddr);
         break;
      }

      case IASTYPE_STRING:
      {
         if (IASAttributeUnicodeAlloc(
                const_cast<IASATTRIBUTE*>(&value)
                ) != NO_ERROR)
         {
            throw std::bad_alloc();
         }
         InsertString(name, value.Value.String);
         break;
      }

      case IASTYPE_OCTET_STRING:
      case IASTYPE_PROV_SPECIFIC:
      {
         if (value.dwId == RADIUS_ATTRIBUTE_CLASS)
         {
            IASClass* cl = reinterpret_cast<IASClass*>(
                              value.Value.OctetString.lpValue
                              );

            if (cl->isMicrosoft(value.Value.OctetString.dwLength))
            {
               InsertMicrosoftClass(name, *cl);
               break;
            }
         }

         InsertOctetString(name, value.Value.OctetString);
         break;
      }

      case IASTYPE_UTC_TIME:
      {
         InsertUTCTime(name, value.Value.UTCTime);
         break;
      }

      case IASTYPE_INVALID:
      default:
      {
         InsertElement(name, L"", string);
         break;
      }
   }
}


inline void XmlWriter::InsertInteger(
                          const wchar_t* name,
                          DWORD value
                          )
{
   wchar_t buffer[33];
   _ultow(value, buffer, 10);
   InsertElement(name, buffer, nonNegativeInteger);
}


inline void XmlWriter::InsertInetAddr(
                          const wchar_t* name,
                          DWORD value
                          )
{
   wchar_t buffer[16];
   ias_inet_htow(value, buffer);
   InsertElement(name, buffer, ipv4Address);
}


inline void XmlWriter::InsertString(
                          const wchar_t* name,
                          const IAS_STRING& value
                          )
{
   InsertElement(name, ((value.pszWide != 0) ? value.pszWide : L""), string);
}


inline void XmlWriter::InsertOctetString(
                          const wchar_t* name,
                          const IAS_OCTET_STRING& value
                          )
{
   // First try to insert it as UTF-8.
   if (!InsertUtf8(
           name,
           reinterpret_cast<const char*>(value.lpValue),
           value.dwLength
           ))
   {
      // That failed, so insert as formatted octets.
      InsertBinHex(name, value);
   }
}


inline void XmlWriter::InsertUTCTime(
                          const wchar_t* name,
                          const FILETIME& value
                          )
{
   SYSTEMTIME st;
   FileTimeToSystemTime(&value, &st);

   // Use SQL Server format in case we need to convert to datetime.
   // 2002-01-11 11:00:12.239 plus null-terminator.
   const size_t maxLen = 24;
   wchar_t buffer[maxLen + 1];
   int nChar = _snwprintf(
                  buffer,
                  maxLen,
                  L"%hu-%02hu-%02hu %02hu:%02hu:%02hu.%03hu",
                  st.wYear,
                  st.wMonth,
                  st.wDay,
                  st.wHour,
                  st.wMinute,
                  st.wSecond,
                  st.wMilliseconds
                  );
   if ((nChar < 0) || (nChar == maxLen))
   {
      buffer[maxLen] = L'\0';
   }

   InsertElement(name, buffer, sqlDateTime);
}


inline void XmlWriter::InsertMicrosoftClass(
                          const wchar_t* name,
                          const IASClass& value
                          )
{
   wchar_t addr[16];
   ias_inet_htow(value.getServerAddress(), addr);

   FILETIME ft = value.getLastReboot();
   SYSTEMTIME st;
   FileTimeToSystemTime(&ft, &st);

   // 311 65535 255.255.255.255 01/01/2001 12:00:00 18446744073709551615 + null
   const size_t maxLen = 66;
   wchar_t buffer[maxLen + 1];
   int nChar = _snwprintf(
                  buffer,
                  maxLen,
                  L"311 %hu %s %02hu/%02hu/%04hu %02hu:%02hu:%02hu %I64u",
                  value.getVersion(),
                  addr,
                  st.wMonth,
                  st.wDay,
                  st.wYear,
                  st.wHour,
                  st.wMinute,
                  st.wSecond,
                  value.getSerialNumber()
                  );
   if ((nChar < 0) || (nChar == maxLen))
   {
      buffer[maxLen] = L'\0';
   }

   InsertElement(name, buffer, string);
}


inline bool XmlWriter::InsertUtf8(
                          const wchar_t* name,
                          const char* value,
                          DWORD valueLen
                          )
{
   // Remove any trailing null terminator.
   if ((valueLen > 0) && (value[valueLen - 1] == '\0'))
   {
      --valueLen;
   }

   // Scan for control characters and embedded nulls.
   const char* end = value + valueLen;
   for (const char* i = value; i != end; ++i)
   {
      if (((*i) & 0x60) == 0)
      {
         return false;
      }
   }

   // Compute the space needed for the Unicode value.
   long nchar = IASUtf8ToUnicodeLength(value, valueLen);
   if (nchar < 0)
   {
      return false;
   }

   // Reserve space for the conversion.
   ReserveScratch(nchar + 1);

   // Convert to null-terminated Unicode.
   IASUtf8ToUnicode(value, valueLen, scratch);
   scratch[nchar] = L'\0';

   InsertElement(name, scratch, string);

   return true;
}


inline void XmlWriter::InsertBinHex(
                          const wchar_t* name,
                          const IAS_OCTET_STRING& value
                          )
{
   // 2 characters per octet plus a null terminator.
   ReserveScratch((2 * value.dwLength) + 1);

   wchar_t* dst = scratch;

   const unsigned char* src = value.lpValue;
   for (DWORD i = 0; i < value.dwLength; ++i)
   {
      *dst = ConvertIntegerToHexWChar((*src) >> 4);
      ++dst;

      *dst = ConvertIntegerToHexWChar((*src) & 0x0F);
      ++dst;

      ++src;
   }

   *dst = L'\0';

   InsertElement(name, scratch, hexBinary);
}


inline void XmlWriter::Append(wchar_t c)
{
   *Reserve(1) = c;
}


void XmlWriter::Append(const wchar_t* sz)
{
   size_t nchar = wcslen(sz);
   wmemcpy(Reserve(nchar), sz, nchar);
}


inline void XmlWriter::AppendStartTag(const wchar_t* name)
{
   Append(L'<');
   Append(name);
   Append(L'>');
}

inline void XmlWriter::AppendStartTag(const wchar_t* name, DataType dataType)
{
   Append(L'<');
   Append(name);
   Append(L" data_type=\"");
   wchar_t type = L'0' + dataType;
   Append(type);
   Append(L'\"');
   Append(L'>');
}


inline void XmlWriter::AppendEndTag(const wchar_t* name)
{
   Append(L"</");
   Append(name);
   Append(L'>');
}

inline wchar_t XmlWriter::ConvertIntegerToHexWChar(unsigned char src) throw ()
{
   return (src < 10) ? (src + L'0') : (src + (L'A' - 10));
}


wchar_t* XmlWriter::Reserve(size_t nchar)
{
   wchar_t* retval = next;
   next += nchar;

   // Do we need more storage?
   if (next > end)
   {
      // Compute size needed and current size.
      size_t needed = next - begin;
      size_t size = needed - nchar;

      // At least double the capacity, but make sure it's big enough to satisfy
      // the request.
      size_t capacity = (end - begin) * 2;
      if (capacity < needed)
      {
         capacity = needed;
      }

      // Allocate the new buffer and copy in the data.
      wchar_t* newBuffer = new wchar_t[capacity];
      wmemcpy(newBuffer, begin, size);

      // Free up the old memory.
      delete[] begin;

      // Reset our state.
      begin = newBuffer;
      next = begin + size;
      end = begin + capacity;

      // Recompute now we that we have enough storage.
      retval = next;
      next += nchar;
   }

   return retval;
}


void XmlWriter::ReserveScratch(size_t nchar)
{
   if (nchar > scratchCapacity)
   {
      if (nchar < minScratchCapcity)
      {
         nchar = minScratchCapcity;
      }

      wchar_t* newScratch = new wchar_t[nchar];

      delete[] scratch;

      scratch = newScratch;
      scratchCapacity = nchar;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\cond\condition.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    Condition.h
//
// SYNOPSIS
//
//    This file declares the class Condition.
//
// MODIFICATION HISTORY
//
//    02/04/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _CONDITION_H_
#define _CONDITION_H_

#include <nap.h>
#include <nocopy.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Condition
//
// DESCRIPTION
//
//    This serves as an abstract base class for all condition objects.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE Condition : 
   public CComObjectRootEx<CComMultiThreadModelNoCS>,
   public ICondition,
   public IConditionText,
   private NonCopyable
{
public:

BEGIN_COM_MAP(Condition)
   COM_INTERFACE_ENTRY(ICondition)
   COM_INTERFACE_ENTRY(IConditionText)
END_COM_MAP()

   Condition() throw ()
      : conditionText(NULL)
   { }

   ~Condition() throw ()
   { SysFreeString(conditionText); }

//////////
// IConditionText
//////////
   STDMETHOD(get_ConditionText)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(put_ConditionText)(/*[in]*/ BSTR newVal);

protected:
   BSTR conditionText;
};

#endif  //_CONDITION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\cond\condition.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    Condition.cpp
//
// SYNOPSIS
//
//    This file implements the class Condition.
//
// MODIFICATION HISTORY
//
//    02/04/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <Condition.h>

STDMETHODIMP Condition::get_ConditionText(BSTR *pVal)
{
   if (!pVal) { return E_POINTER; }

   if (conditionText)
   {
      *pVal = SysAllocString(conditionText);

      if (*pVal == NULL) { return E_OUTOFMEMORY; }
   }
   else
   {
      *pVal = NULL;
   }

   return S_OK;
}

STDMETHODIMP Condition::put_ConditionText(BSTR newVal)
{
   ////////// 
   // Make our own copy of newVal.
   ////////// 
   if (newVal)
   {
      if ((newVal = SysAllocString(newVal)) == NULL) { return E_OUTOFMEMORY; }
   }

   ////////// 
   // Free any exisiting condition.
   ////////// 
   if (conditionText)
   {
      SysFreeString(conditionText);
   }

   ////////// 
   // Make the assignment.
   ////////// 
   conditionText = newVal;

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\cond\match.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    Match.cpp
//
// SYNOPSIS
//
//    This file defines the class AttributeMatch.
//
// MODIFICATION HISTORY
//
//    02/04/1998    Original version.
//    03/18/1998    Treat IASTYPE_ENUM as an Integer.
//    04/06/1998    Use the IASAttributeArray class so we can handle a large
//                  number of attributes.
//    08/10/1998    Use dictionary directly.
//    03/23/1999    Renamed Match to AttributeMatch.
//    04/05/1999    Need custom UpdateRegistry method.
//    04/17/2000    Port to new dictionary API.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iastlb.h>
#include <iastlutl.h>
#include <iasutil.h>

#include <factory.h>
#include <match.h>

#include <memory>

HRESULT AttributeMatch::UpdateRegistry(BOOL bRegister) throw ()
{
   // We can't use the IAS_DECLARE_REGISTRY macro because our ProgID doesn't
   // match the implementation class.
   return IASRegisterComponent(
              _Module.GetModuleInstance(),
              __uuidof(AttributeMatch),
              IASProgramName,
              L"Match",
              IAS_REGISTRY_INPROC | IAS_REGISTRY_FREE,
              __uuidof(NetworkPolicy),
              1,
              0,
              bRegister
              );
}

BOOL AttributeMatch::checkAttribute(PIASATTRIBUTE attr) const throw ()
{
   _ASSERT(attr != NULL);

   switch (attr->Value.itType)
   {
      case IASTYPE_ENUM:
      case IASTYPE_INTEGER:
      {
         WCHAR wsz[11] = L"";
         return regex.testString(_ultow(attr->Value.Integer, wsz, 10));
      }

      case IASTYPE_INET_ADDR:
      {
         WCHAR wsz[16];
         return regex.testString(ias_inet_htow(attr->Value.InetAddr, wsz));
      }

      case IASTYPE_STRING:
      {
         IASAttributeUnicodeAlloc(attr);
         return regex.testString(attr->Value.String.pszWide);
      }

      case IASTYPE_OCTET_STRING:
      case IASTYPE_PROV_SPECIFIC:
      {
         PWSTR wsz = IAS_OCT2WIDE(attr->Value.OctetString);
         return regex.testString(wsz);
      }
   }

   return false;
}


STDMETHODIMP AttributeMatch::IsTrue(IRequest* pRequest, VARIANT_BOOL *pVal)
{
   _ASSERT(pRequest != NULL);
   _ASSERT(pVal != NULL);
   _ASSERT(dfa != NULL);

   *pVal = VARIANT_FALSE;

   try
   {
      //////////
      // Retrieve the relevant attributes.
      //////////

      IASTL::IASRequest request(pRequest);
      IASTL::IASAttributeVectorWithBuffer<8> attrs;
      attrs.load(request, targetID);

      //////////
      // Look for a match.
      //////////

      IASTL::IASAttributeVector::iterator it;
      for (it = attrs.begin(); it != attrs.end(); ++it)
      {
         if (checkAttribute(it->pAttribute))
         {
            *pVal = VARIANT_TRUE;
            break;
         }
      }
   }
   CATCH_AND_RETURN()

   return S_OK;
}


STDMETHODIMP AttributeMatch::put_ConditionText(BSTR newVal)
{
   if (newVal == NULL) { return E_INVALIDARG; }

   //////////
   // Make a local copy so we can modify it.
   //////////

   size_t len = sizeof(WCHAR) * (wcslen(newVal) + 1);
   PWSTR attrName = (PWSTR)memcpy(_alloca(len), newVal, len);

   //////////
   // Split into attribute name and regular expression: "<attrName>=<regex>"
   //////////

   PWSTR pattern = wcschr(attrName, L'=');
   if (pattern == NULL) { return E_INVALIDARG; }
   *pattern++ = '\0';

   HRESULT hr;
   DWORD attrID;

   try
   {
      // Names of various columns in the dictionary.
      const PCWSTR COLUMNS[] = { L"Name", L"ID", NULL };

      // Get the dictionary.
      IASTL::IASDictionary dnary(COLUMNS);

      // Lookup the target attribute in the dictionary.
      do
      {
         if (!dnary.next()) { return E_INVALIDARG; }

         if (_wcsicmp(dnary.getBSTR(0), attrName) == 0)
         {
            attrID = (DWORD)dnary.getLong(1);
            break;
         }

      } while (true);
   }
   catch (const _com_error& ce)
   {
      return ce.Error();
   }

   // Create a new RegularExpression.
   RegularExpression tmp;
   hr = tmp.setGlobal(TRUE);
   if (FAILED(hr)) { return hr; }
   hr = tmp.setIgnoreCase(TRUE);
   if (FAILED(hr)) { return hr; }
   hr = tmp.setPattern(pattern);
   if (FAILED(hr)) { return hr; }

   // Store the condition text.
   hr = Condition::put_ConditionText(newVal);
   if (FAILED(hr)) { return hr; }

   // Everything succeeded, so save the results.
   targetID = attrID;
   regex.swap(tmp);

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\cond\match.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    Match.h
//
// SYNOPSIS
//
//    This file declares the class AttributeMatch.
//
// MODIFICATION HISTORY
//
//    02/04/1998    Original version.
//    03/23/1999    Renamed Match to AttributeMatch.
//    04/05/1999    Need custom UpdateRegistry method.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _MATCH_H_
#define _MATCH_H_

#include <condition.h>
#include <regex.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    AttributeMatch
//
// DESCRIPTION
//
//    Applies a regular expression to a single attribute.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE AttributeMatch :
   public Condition,
   public CComCoClass<AttributeMatch, &__uuidof(AttributeMatch)>
{
public:

   static HRESULT WINAPI UpdateRegistry(BOOL bRegister) throw ();

   AttributeMatch() throw ()
      : targetID(0)
   { }

//////////
// ICondition
//////////
   STDMETHOD(IsTrue)(/*[in]*/ IRequest* pRequest,
                     /*[out, retval]*/ VARIANT_BOOL *pVal);

//////////
// IConditionText
//////////
   STDMETHOD(put_ConditionText)(/*[in]*/ BSTR newVal);

protected:
   BOOL checkAttribute(PIASATTRIBUTE attr) const throw ();

   DWORD targetID;           // The target attribute.
   RegularExpression regex;  // Regular expression to test.
};

#endif  //_MATCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\cond\ntgroups.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    NTGroups.cpp
//
// SYNOPSIS
//
//    This file declares the class NTGroups.
//
// MODIFICATION HISTORY
//
//    02/04/1998    Original version.
//    04/06/1998    Check the enabled flag.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iastlutl.h>
#include <sdoias.h>
#include <ntgroups.h>
#include <parser.h>
#include <textsid.h>

//////////
// We'll allow a broad range of delimiters.
//////////
const WCHAR DELIMITERS[] = L" ,;\t\n|";

STDMETHODIMP NTGroups::IsTrue(IRequest* pRequest, VARIANT_BOOL *pVal)
{
   _ASSERT(pRequest != NULL);
   _ASSERT(pVal != NULL);

   CComQIPtr<IAttributesRaw, &__uuidof(IAttributesRaw)> attrsRaw(pRequest);

   _ASSERT(attrsRaw != NULL);

   *pVal = VARIANT_FALSE;

   //////////
   // Get the NT-Token-Groups attribute.
   //////////

   PIASATTRIBUTE attr = IASPeekAttribute(attrsRaw,
                                         IAS_ATTRIBUTE_TOKEN_GROUPS,
                                         IASTYPE_OCTET_STRING);

   if (attr)
   {
      //////////
      // See if the user belongs to one of the allowed groups.
      //////////

      PTOKEN_GROUPS tokenGroups;
      tokenGroups = (PTOKEN_GROUPS)attr->Value.OctetString.lpValue;

      for (DWORD dw = 0; dw < tokenGroups->GroupCount; ++dw)
      {
         if (groups.contains(tokenGroups->Groups[dw].Sid) &&
             (tokenGroups->Groups[dw].Attributes & SE_GROUP_ENABLED))
         {
            *pVal = VARIANT_TRUE;

            break;
         }
      }
   }

   return S_OK;
}


STDMETHODIMP NTGroups::put_ConditionText(BSTR newVal)
{
   if (newVal == NULL) { return E_INVALIDARG; }

   //////////
   // Make a local copy so we can modify it.
   //////////

   size_t len = sizeof(WCHAR) * (wcslen(newVal) + 1);
   Parser p((PWSTR)memcpy(_alloca(len), newVal, len));

   //////////
   // Parse the input text and create SIDs.
   //////////

   SidSet temp;

   try
   {
      //////////
      // Iterate through the individual SID tokens.
      //////////

      PCWSTR token;

      while ((token = p.seekToken(DELIMITERS)) != NULL)
      {
         PSID sid;

         // Try to convert.
         DWORD status = IASSidFromTextW(token, &sid);

         if (status == NO_ERROR)
         {
            temp.insert(sid);
         }
         else
         {
            return E_INVALIDARG;
         }

         // We're done with the token.
         p.releaseToken();
      }
   }
   catch (std::bad_alloc)
   {
      return E_OUTOFMEMORY;
   }

   // Try to save the condition next.
   HRESULT hr = Condition::put_ConditionText(newVal);

   if (SUCCEEDED(hr))
   {
      // All went well so save the new set of groups.
      groups.swap(temp);
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\cond\textmap.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    textmap.h
//
// SYNOPSIS
//
//    This file declares functions for converting Time of Day restriction
//    hour maps to and from a textual representation.
//
// MODIFICATION HISTORY
//
//    02/05/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _TEXTMAP_H_
#define _TEXTMAP_H_

#ifdef __cplusplus
extern "C" {
#endif

#define IAS_HOUR_MAP_LENGTH (21)

DWORD
WINAPI
IASHourMapFromText(
    IN PCWSTR szText,
    IN BOOL keepMap,
    IN OUT PBYTE pHourMap
    );

#ifdef __cplusplus
}
#endif
#endif  // _TEXTMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\cond\ntgroups.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    NTGroups.h
//
// SYNOPSIS
//
//    This file declares the class NTGroups.
//
// MODIFICATION HISTORY
//
//    02/04/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _NTGROUPS_H_
#define _NTGROUPS_H_

#include <condition.h>
#include <nocopy.h>

#include <vector>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    SidSet
//
// DESCRIPTION
//
//    Simple wrapper around a collection of SIDs.
//
///////////////////////////////////////////////////////////////////////////////
class SidSet
   : NonCopyable
{
public:
   ~SidSet() throw ()
   {
      for (Sids::iterator it = sids.begin() ; it != sids.end(); ++it)
      {
         FreeSid(*it);
      }
   }

   bool contains(PSID sid) const throw ()
   {
      for (Sids::const_iterator it = sids.begin() ; it != sids.end(); ++it)
      {
         if (EqualSid(sid, *it)) { return true; }
      }

      return false;
   }

   void insert(PSID sid)
   {
      sids.push_back(sid);
   }

   void swap(SidSet& s) throw ()
   {
      sids.swap(s.sids);
   }

protected:
   typedef std::vector<PSID> Sids;
   Sids sids;
};


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    NTGroups
//
// DESCRIPTION
//
//    Policy condition that evaluates NT Group membership.
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE NTGroups :
   public Condition,
   public CComCoClass<NTGroups, &__uuidof(NTGroups)>
{
public:

IAS_DECLARE_REGISTRY(NTGroups, 1, IAS_REGISTRY_AUTO, NetworkPolicy)

//////////
// ICondition
//////////
   STDMETHOD(IsTrue)(/*[in]*/ IRequest* pRequest,
                     /*[out, retval]*/ VARIANT_BOOL *pVal);

//////////
// IConditionText
//////////
   STDMETHOD(put_ConditionText)(/*[in]*/ BSTR newVal);

protected:
   SidSet groups;                  // Set of allowed groups.
};

#endif  //_NTGROUPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\cond\textsid.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    textsid.h
//
// SYNOPSIS
//
//    This file declares functions for converting Security Indentifiers (SIDs)
//    to and from a textual representation.
//
// MODIFICATION HISTORY
//
//    01/18/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _TEXTSID_H_
#define _TEXTSID_H_

#ifdef __cplusplus
extern "C" {
#endif

DWORD
WINAPI
IASSidToTextW( 
    IN PSID pSid,
    OUT PWSTR szTextualSid,
    IN OUT PDWORD pdwBufferLen
    );

DWORD
WINAPI
IASSidFromTextW(
    IN PCWSTR szTextualSid,
    OUT PSID *pSid
    );

#ifdef __cplusplus
}
#endif
#endif  // _TEXTSID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\cond\textsid.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    textsid.c
//
// SYNOPSIS
//
//    This file defines functions for converting Security Indentifiers (SIDs)
//    to and from a textual representation.
//
// MODIFICATION HISTORY
//
//    01/18/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <stdio.h>
#include <textsid.h>

DWORD
WINAPI
IASSidToTextW( 
    IN PSID pSid,
    OUT PWSTR szTextualSid,
    IN OUT PDWORD pdwBufferLen
    )
{ 
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;

    // Ensure input parameters are valid.
    if ((szTextualSid == NULL && pdwBufferLen != 0) || !IsValidSid(pSid))
    {
       return ERROR_INVALID_PARAMETER;
    }

    // obtain SidIdentifierAuthority
    psia=GetSidIdentifierAuthority(pSid);

    // obtain SidSubSuthority count
    dwSubAuthorities=*GetSidSubAuthorityCount(pSid);

    //////////
    // compute buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //////////
    dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1);

    //////////
    // check provided buffer length.
    // If not large enough, indicate proper size and return error.
    //////////
    if (*pdwBufferLen < dwSidSize)
    {
        *pdwBufferLen = dwSidSize;

        return ERROR_INSUFFICIENT_BUFFER;
    }

    ////////// 
    // prepare S-SID_REVISION-
    ////////// 
    dwSidSize=swprintf(szTextualSid, L"S-%lu-", dwSidRev );

    //////////
    // prepare SidIdentifierAuthority
    //////////
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        dwSidSize+=swprintf(szTextualSid + lstrlenW(szTextualSid),
                            L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                            (USHORT)psia->Value[0],
                            (USHORT)psia->Value[1],
                            (USHORT)psia->Value[2],
                            (USHORT)psia->Value[3],
                            (USHORT)psia->Value[4],
                            (USHORT)psia->Value[5]);
    }
    else
    {
        dwSidSize+=swprintf(szTextualSid + wcslen(szTextualSid),
                            L"%lu",
                            (ULONG)(psia->Value[5]      ) +
                            (ULONG)(psia->Value[4] <<  8) +
                            (ULONG)(psia->Value[3] << 16) +
                            (ULONG)(psia->Value[2] << 24) );
    }

    //////////
    // loop through SidSubAuthorities
    //////////
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        dwSidSize+=swprintf(szTextualSid + dwSidSize,
                            L"-%lu",
                            *GetSidSubAuthority(pSid, dwCounter));
    }

    return NO_ERROR;
} 


DWORD
WINAPI
IASSidFromTextW(
    IN PCWSTR szTextualSid,
    OUT PSID *pSid
    )
{
   DWORDLONG rawsia;
   DWORD revision;
   DWORD subAuth[8];
   SID_IDENTIFIER_AUTHORITY sia;
   int fields;

   if (szTextualSid == NULL || pSid == NULL)
   {
      return ERROR_INVALID_PARAMETER;
   }

   ////////// 
   // Scan the input string.
   ////////// 
   fields = swscanf(szTextualSid,
                    L"S-%lu-%I64u-%lu-%lu-%lu-%lu-%lu-%lu-%lu-%lu",
                    &revision,
                    &rawsia,
                    subAuth,
                    subAuth + 1,
                    subAuth + 2,
                    subAuth + 3,
                    subAuth + 4,
                    subAuth + 5,
                    subAuth + 6,
                    subAuth + 7);

   ////////// 
   // We must have at least three fields (revision, identifier authority, and
   // at least one sub authority), the current revision, and a 48-bit SIA.
   ////////// 
   if (fields < 3 || revision != SID_REVISION || rawsia > 0xffffffffffffI64)
   {
      return ERROR_INVALID_PARAMETER;
   }

   ////////// 
   // Pack the SID_IDENTIFIER_AUTHORITY.
   ////////// 
   sia.Value[0] = (UCHAR)((rawsia >> 40) & 0xff);
   sia.Value[1] = (UCHAR)((rawsia >> 32) & 0xff);
   sia.Value[2] = (UCHAR)((rawsia >> 24) & 0xff);
   sia.Value[3] = (UCHAR)((rawsia >> 16) & 0xff);
   sia.Value[4] = (UCHAR)((rawsia >>  8) & 0xff);
   sia.Value[5] = (UCHAR)((rawsia      ) & 0xff);

   ////////// 
   // Allocate the SID. Must be freed through FreeSid().
   ////////// 
   if (!AllocateAndInitializeSid(&sia,
                                 (BYTE)(fields - 2),
                                 subAuth[0],
                                 subAuth[1],
                                 subAuth[2],
                                 subAuth[3],
                                 subAuth[4],
                                 subAuth[5],
                                 subAuth[6],
                                 subAuth[7],
                                 pSid))
   {
      return GetLastError();
   }

   return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\cond\timeofday.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the class TimeOfDay and functions for manipulating hour maps.
//
///////////////////////////////////////////////////////////////////////////////

#include "ias.h"
#include "TimeOfDay.h"


bool IsHourSet(
        const SYSTEMTIME& now,
        const BYTE* hourMap
        ) throw ()
{
   // Compute the byte and bit for the current hour.
   size_t hourOfWeek = (now.wDayOfWeek * 24) + now.wHour;
   size_t currentByte = hourOfWeek / 8;
   BYTE currentBit = 0x80 >> (hourOfWeek % 8);

   return (hourMap[currentByte] & currentBit) != 0;
}


DWORD ComputeTimeout(
         const SYSTEMTIME& now,
         const BYTE* hourMap
         ) throw ()
{
   const size_t hoursPerWeek = 7 * 24;

   // Compute the index of the current hour (our starting point).
   size_t idx = (now.wDayOfWeek * 24) + now.wHour;

   // Number of hours until we hit an unset bit.
   size_t lastHour = 0;

   // Search up to one week for an unset bit.
   while (lastHour < hoursPerWeek)
   {
      // Test the corresponding bit.
      if ((hourMap[idx / 8] & (0x1 << (idx % 8))) == 0)
      {
         break;
      }

      ++lastHour;
      ++idx;

      // Wrap around if necessary.
      if (idx == hoursPerWeek)
      {
         idx = 0;
      }
   }

   DWORD secondsLeft;

   if (lastHour == hoursPerWeek)
   {
      // All bits were set, so timeout is infinite.
      secondsLeft = 0xFFFFFFFF;
   }
   else if (lastHour > 0)
   {
      secondsLeft = (lastHour - 1) * 3600;
      secondsLeft += (59 - now.wMinute) * 60;
      secondsLeft += (60 - now.wSecond);
   }
   else
   {
      // First bit was unset, so access denied.
      secondsLeft = 0;
   }

   return secondsLeft;
}


STDMETHODIMP TimeOfDay::IsTrue(IRequest*, VARIANT_BOOL *pVal)
{
   _ASSERT(pVal != 0);

   SYSTEMTIME now;
   GetLocalTime(&now);

   *pVal = IsHourSet(now, hourMap) ? VARIANT_TRUE : VARIANT_FALSE;

   return S_OK;
}


STDMETHODIMP TimeOfDay::put_ConditionText(BSTR newVal)
{
   // Convert the string to an hour map.
   BYTE tempMap[IAS_HOUR_MAP_LENGTH];
   DWORD dw = IASHourMapFromText(newVal, FALSE, tempMap);
   if (dw != NO_ERROR)
   {
      return HRESULT_FROM_WIN32(dw);
   }

   // Save the text.
   HRESULT hr = Condition::put_ConditionText(newVal);

   // Save the hour map.
   if (SUCCEEDED(hr))
   {
      memcpy(hourMap, tempMap, sizeof(hourMap));
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\cond\timeofday.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class TimeOfDay and functions for manipulating hour maps.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef TIMEOFDAY_H
#define TIMEOFDAY_H
#pragma once

#include "Condition.h"
#include "textmap.h"

// Returns true if the hour indicated by 'now' is set in the hour map.
bool IsHourSet(
        const SYSTEMTIME& now,
        const BYTE* hourMap
        ) throw ();

// Computes the number of seconds from 'now' until the first unset hour. If
// 'currentHourOnly' is true, it only checks the current hour block. Otherwise,
// it checks the entire map.
DWORD ComputeTimeout(
         const SYSTEMTIME& now,
         const BYTE* hourMap
         ) throw ();


// Imposes a Time of Day contraint for network policies.
class ATL_NO_VTABLE TimeOfDay
   : public Condition,
     public CComCoClass<TimeOfDay, &__uuidof(TimeOfDay)>
{
public:

IAS_DECLARE_REGISTRY(TimeOfDay, 1, IAS_REGISTRY_AUTO, NetworkPolicy)

   TimeOfDay() throw ();

   // Use compiler-generated version.
   // ~TimeOfDay() throw ();

   // ICondition
   STDMETHOD(IsTrue)(
                IRequest* pRequest,
                VARIANT_BOOL* pVal
                );

   // IConditionText
   STDMETHOD(put_ConditionText)(BSTR newVal);

private:
   // Hour map being enforced.
   BYTE hourMap[IAS_HOUR_MAP_LENGTH];

   // Not implemented.
   TimeOfDay(const TimeOfDay&);
   TimeOfDay& operator=(const TimeOfDay&);
};


inline TimeOfDay::TimeOfDay() throw ()
{
   memset(hourMap, 0, sizeof(hourMap));
}

#endif  // TIMEOFDAY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\cond\textmap.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    textmap.cpp
//
// SYNOPSIS
//
//    This file defines functions for converting Time of Day restriction
//    hour maps to and from a textual representation.
//
// MODIFICATION HISTORY
//
//    02/05/1998    Original version.
//    04/06/1998    Sunday is day zero again.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <Parser.h>
#include <textmap.h>

//////////
// Definition of whitespace.
//////////
#define WSP L" "

//////////
// Valid delimiters for days.
//////////
#define DELIM L",;|"

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    TimeOfDayParser
//
// DESCRIPTION
//
//    This class extends Parser to extract hour maps from a string.
//
///////////////////////////////////////////////////////////////////////////////
class TimeOfDayParser : public Parser
{
public:

   TimeOfDayParser(PWSTR source) throw ()
      : Parser(source) { }

   // Extract time of day in the format hh:mm.
   void extractTime(ULONG* hour, ULONG* minute) throw (ParseError)
   {
      *hour = extractUnsignedLong();
      skip(WSP);

      // Minutes are optional.
      if (*current == L':')
      {
         ++current;

         *minute = extractUnsignedLong();
      }
      else
      {
         *minute = 0;
      }

      if (*hour > 24 || *minute > 59 || (*hour == 24 && *minute != 0))
      {
         throw ParseError();
      }
   }

   // Extracts a single day's hour map.
   void extractDay(PBYTE hourMap) throw (ParseError)
   {
      // Get the day of week (an integer from 0-6).
      ULONG dayOfWeek = extractUnsignedLong();
      skip(WSP);

      if (dayOfWeek > 6) { throw ParseError(); }

      do
      {
         // Get the start time of the range.
         ULONG startHour, startMinute;
         extractTime(&startHour, &startMinute);
         skip(WSP);

         ignore(L'-');

         // Get the end time of the range.
         ULONG endHour, endMinute;
         extractTime(&endHour, &endMinute);
         skip(WSP);

         // Make sure the values are legit.
         if (startHour * 60 + startMinute > endHour * 60 + endMinute)
         {
            throw ParseError();
         }

         // Set all bits in the range.
         for (size_t i=startHour; i<endHour; ++i)
         {
            hourMap[dayOfWeek * 3 + i / 8] |= 0x80 >> (i % 8);
         }

      } while (more());
   }
};


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASTextToHourMap
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASHourMapFromText(
    IN PCWSTR szText,
    IN BOOL keepMap,
    IN OUT PBYTE pHourMap
    )
{
   if (szText == NULL || pHourMap == NULL)
   {
      return ERROR_INVALID_PARAMETER;
   }

   if (keepMap == FALSE)
   {
      memset(pHourMap, 0, IAS_HOUR_MAP_LENGTH);
   }

   ////////// 
   // Make a local copy so we can modify the text.
   ////////// 

   PWSTR copy = (PWSTR)_alloca((wcslen(szText) + 1) * sizeof(WCHAR));

   wcscpy(copy, szText);

   ////////// 
   // Parse the text.
   ////////// 

   try
   {
      // Each day should be separated by a comma or semicolon.
      PWSTR token = wcstok(copy, DELIM);

      while (token)
      {
         TimeOfDayParser parser(token);

         parser.extractDay(pHourMap);

         token = wcstok(NULL, DELIM);
      }
   }
   catch (Parser::ParseError)
   {
      return ERROR_INVALID_DATA;
   }

   return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\dll\action.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    action.h
//
// SYNOPSIS
//
//    Declares the class Action.
//
// MODIFICATION HISTORY
//
//    02/01/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef ACTION_H
#define ACTION_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <realm.h>

#include <memory>

#include <iastlutl.h>
using namespace IASTL;

class TunnelTagger;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Action
//
///////////////////////////////////////////////////////////////////////////////
class Action
{
public:
   Action(
      PCWSTR name,
      DWORD nameAttr,
      _variant_t& action,
      const TunnelTagger& tagger
      );

   // Perform the action.
   void doAction(IASRequest& pRequest) const;

protected:
   // Create a VSA from the string format used by the UI.
   static PIASATTRIBUTE VSAFromString(PCWSTR string);

private:
   // Profile attributes to be added to the request.
   IASAttributeVector attributes;

   // Provider information.
   IASAttributeVectorWithBuffer<2> authProvider;
   IASAttributeVectorWithBuffer<2> acctProvider;

   // Attribute manipulation.
   DWORD realmsTarget;
   Realms realms;

   // Not implemented.
   Action(const Action&) throw ();
   Action& operator=(const Action&) throw ();
};

typedef std::auto_ptr<Action> ActionPtr;

#endif // ACTION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\dll\enforcer.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class PolicyEnforcer.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef ENFORCER_H
#define ENFORCER_H
#pragma once

#include <policylist.h>
#include <iastl.h>

class TunnelTagger;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    PolicyEnforcerBase
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE PolicyEnforcerBase :
   public IASTL::IASRequestHandlerSync
{
public:

//////////
// IIasComponent
//////////
   STDMETHOD(Shutdown)();
   STDMETHOD(PutProperty)(LONG Id, VARIANT* pValue);

protected:

   PolicyEnforcerBase(DWORD name) throw ()
      : nameAttr(name), tagger(0)
   { }

   ~PolicyEnforcerBase() throw ();

   // Main request processing routine.
   virtual IASREQUESTSTATUS onSyncRequest(IRequest* pRequest) throw ();

   static void processException(
                  IRequest* pRequest,
                  const _com_error& ce
                  ) throw ();

   // Update the PolicyList.
   void setPolicies(IDispatch* pDisp);

   PolicyList policies;  // Processed policies used for run-time enforcement.
   DWORD nameAttr;       // Attribute used for storing policy name.
   TunnelTagger* tagger; // Tags tunnel attributes.
};


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ProxyPolicyEnforcer
//
// DESCRIPTION
//
//    Enforces Proxy Policies.
//
///////////////////////////////////////////////////////////////////////////////

class __declspec(uuid("6BC098A8-0CE6-11D1-BAAE-00C04FC2E20D"))
ProxyPolicyEnforcer;

class ProxyPolicyEnforcer :
   public PolicyEnforcerBase,
   public CComCoClass<ProxyPolicyEnforcer, &__uuidof(ProxyPolicyEnforcer)>
{
public:

IAS_DECLARE_REGISTRY(ProxyPolicyEnforcer, 1, IAS_REGISTRY_AUTO, NetworkPolicy)

protected:
   ProxyPolicyEnforcer() throw ()
      : PolicyEnforcerBase(IAS_ATTRIBUTE_PROXY_POLICY_NAME)
   { }

   // Main request processing routine.
   virtual IASREQUESTSTATUS onSyncRequest(IRequest* pRequest) throw ();
};


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    PolicyEnforcer
//
// DESCRIPTION
//
//    Enforces Remote Access Policies.
//
///////////////////////////////////////////////////////////////////////////////
class PolicyEnforcer :
   public PolicyEnforcerBase,
   public CComCoClass<PolicyEnforcer, &__uuidof(PolicyEnforcer)>
{
public:

IAS_DECLARE_REGISTRY(PolicyEnforcer, 1, IAS_REGISTRY_AUTO, NetworkPolicy)

protected:
   PolicyEnforcer() throw ()
      : PolicyEnforcerBase(IAS_ATTRIBUTE_NP_NAME)
   { }

   // Main request processing routine.
   virtual IASREQUESTSTATUS onSyncRequest(IRequest* pRequest) throw ();
};

#endif  // _ENFORCER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\dll\action.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the class Action.
//
///////////////////////////////////////////////////////////////////////////////

#include "ias.h"
#include "action.h"
#include "attrcvt.h"
#include "eapprofile.h"
#include "sdoias.h"
#include "TunnelTagger.h"

_COM_SMARTPTR_TYPEDEF(ISdo, __uuidof(ISdo));
_COM_SMARTPTR_TYPEDEF(ISdoCollection, __uuidof(ISdoCollection));

Action::Action(
            PCWSTR name,
            DWORD nameAttr,
            _variant_t& action,
            const TunnelTagger& tagger
            )
   : attributes(4),
     realmsTarget(RADIUS_ATTRIBUTE_USER_NAME)
{
   using _com_util::CheckError;

   //////////
   // Add the policy name attribute.
   //////////

   IASAttribute policyName(true);
   policyName->dwId = nameAttr;
   policyName.setString(name);
   policyName.setFlag(IAS_INCLUDE_IN_RESPONSE);
   attributes.push_back(policyName);

   //////////
   // Get an enumerator for the attributes collection.
   //////////

   ISdoCollectionPtr profile(action);
   IUnknownPtr unk;
   CheckError(profile->get__NewEnum(&unk));
   IEnumVARIANTPtr iter(unk);

   //////////
   // Iterate through the attributes.
   //////////

   _variant_t element;
   unsigned long fetched;
   while (iter->Next(1, &element, &fetched) == S_OK && fetched == 1)
   {
      // Convert to an SDO.
      ISdoPtr attribute(element);
      element.Clear();

      // Get the necessary properties.
      _variant_t id, value, syntax;
      CheckError(attribute->GetProperty(PROPERTY_ATTRIBUTE_ID, &id));
      CheckError(attribute->GetProperty(PROPERTY_ATTRIBUTE_VALUE, &value));
      CheckError(attribute->GetProperty(PROPERTY_ATTRIBUTE_SYNTAX, &syntax));

      // Attribute-Manipulation-Rule gets processed 'as is'.
      if (V_I4(&id) == IAS_ATTRIBUTE_MANIPULATION_RULE)
      {
         realms.setRealms(&value);
         continue;
      }
      // As does the EAP per-policy config.
      else if (V_I4(&id) == IAS_ATTRIBUTE_EAP_CONFIG)
      {
         EapProfile eap;
         CheckError(eap.Load(value));
         while (!eap.IsEmpty())
         {
            IASAttribute config(true);

            EapProfile::ConfigData data;
            eap.Pop(data);

            config->dwId = IAS_ATTRIBUTE_EAP_CONFIG;
            config->Value.itType = IASTYPE_OCTET_STRING;
            config->Value.OctetString.dwLength = data.length;
            config->Value.OctetString.lpValue = data.value;

            attributes.push_back(config);
         }
         continue;
      }

      // For everything else we process the VARIANTs one at a time.
      VARIANT *begin, *end;
      if (V_VT(&value) == (VT_VARIANT | VT_ARRAY))
      {
         begin = (VARIANT*)V_ARRAY(&value)->pvData;
         end = begin + V_ARRAY(&value)->rgsabound[0].cElements;
      }
      else
      {
         begin = &value;
         end = begin + 1;
      }

      // Iterate through each value.
      for (VARIANT* v = begin; v != end; ++v)
      {
         // Process based on the attribute ID.
         switch (V_I4(&id))
         {
            case IAS_ATTRIBUTE_MANIPULATION_TARGET:
            {
               realmsTarget = V_I4(v);
               break;
            }
            case IAS_ATTRIBUTE_AUTH_PROVIDER_TYPE:
            {
               IASAttribute type(true);
               type->dwId = IAS_ATTRIBUTE_PROVIDER_TYPE;
               type->Value.itType = IASTYPE_ENUM;
               type->Value.Integer = V_I4(v);
               authProvider.push_back(type);
               break;
            }
            case IAS_ATTRIBUTE_AUTH_PROVIDER_NAME:
            {
               IASAttribute name(true);
               name->dwId = IAS_ATTRIBUTE_PROVIDER_NAME;
               name.setString(V_BSTR(v));
               authProvider.push_back(name);
               break;
            }
            case IAS_ATTRIBUTE_ACCT_PROVIDER_TYPE:
            {
               IASAttribute type(true);
               type->dwId = IAS_ATTRIBUTE_PROVIDER_TYPE;
               type->Value.itType = IASTYPE_ENUM;
               type->Value.Integer = V_I4(v);
               acctProvider.push_back(type);
               break;
            }
            case IAS_ATTRIBUTE_ACCT_PROVIDER_NAME:
            {
               IASAttribute name(true);
               name->dwId = IAS_ATTRIBUTE_PROVIDER_NAME;
               name.setString(V_BSTR(v));
               acctProvider.push_back(name);
               break;
            }
            case RADIUS_ATTRIBUTE_VENDOR_SPECIFIC:
            {
               IASAttribute attr(VSAFromString(V_BSTR(v)), false);
               attr->dwId = RADIUS_ATTRIBUTE_VENDOR_SPECIFIC;
               attr.setFlag(IAS_INCLUDE_IN_ACCEPT);
               attributes.push_back(attr);
               break;
            }
            default:
            {
               IASTYPEENUM type = (IASTYPEENUM)V_I4(&syntax);
               IASAttribute attr(IASAttributeFromVariant(v, type), false);
               attr->dwId = V_I4(&id);
               attr.setFlag(IAS_INCLUDE_IN_ACCEPT);
               attributes.push_back(attr);
            }
         }
      }
   }

   tagger.Tag(attributes);
}


void Action::doAction(IASRequest& request) const
{
   // Populate the provider information:
   switch (request.get_Request())
   {
      case IAS_REQUEST_ACCESS_REQUEST:
         authProvider.store(request);
         break;

      case IAS_REQUEST_ACCOUNTING:
         acctProvider.store(request);
         break;
   }

   // Perform attribute manipulation.
   if (!realms.empty())
   {
      IASAttribute attr;
      attr.load(request, realmsTarget, IASTYPE_OCTET_STRING);

      if (attr)
      {
         CComBSTR newVal;
         realms.process(IAS_OCT2WIDE(attr->Value.OctetString), &newVal);
         if (newVal)
         {
            if (realmsTarget == RADIUS_ATTRIBUTE_USER_NAME)
            {
               IASAttribute userName(true);
               userName->dwId = RADIUS_ATTRIBUTE_USER_NAME;
               userName->dwFlags = attr->dwFlags;
               userName.setOctetString(newVal);
               userName.store(request);

               // Now that the new User-Name is safely stored, we can rename
               // the old User-Name.
               attr->dwId = IAS_ATTRIBUTE_ORIGINAL_USER_NAME;
            }
            else
            {
               // No need to save the old, so modify in place.
               attr.setOctetString(newVal);
            }
         }
      }
   }

   // Store the profile attributes.
   attributes.store(request);

}

/////////
// Various formats of VSA strings.
/////////
enum Format
{
   FORMAT_RAW_HEX,
   FORMAT_STRING,
   FORMAT_INTEGER,
   FORMAT_HEX,
   FORMAT_INET_ADDR
};

/////////
// Layout of the VSA strings.
/////////
struct VSAFormat
{
   WCHAR format[2];
   WCHAR vendorID[8];
   union
   {
      WCHAR rawValue[1];
      struct
      {
         WCHAR vendorType[2];
         WCHAR vendorLength[2];
         WCHAR value[1];
      };
   };
};

//////////
// Convert a hex digit to the number it represents.
//////////
BYTE digit2Num(WCHAR digit) throw ()
{
   if ((digit >= L'0') && (digit <= L'9'))
   {
      return digit - L'0';
   }
   else if ((digit >= L'A')  && (digit <= L'F'))
   {
      return digit - (L'A' - 10);
   }
   else
   {
      return digit - (L'a' - 10);
   }
}

//////////
// Pack a hex digit into a byte stream.
//////////
PBYTE packHex(PCWSTR src, ULONG srclen, PBYTE dst) throw ()
{
   for (ULONG dstlen = srclen / 2; dstlen; --dstlen)
   {
      *dst    = digit2Num(*src++) << 4;
      *dst++ |= digit2Num(*src++);
   }

   return dst;
}

//////////
// Convert a string describing a VSA into an IASATTRIBUTE.
//////////
PIASATTRIBUTE Action::VSAFromString(PCWSTR string)
{
   // Number of characters to process.
   SIZE_T len = wcslen(string);

   // Overlay the layout struct.
   VSAFormat* vsa = (VSAFormat*)string;

   // Get the string format.
   ULONG format = digit2Num(vsa->format[0]);
   format <<= 8;
   format |= digit2Num(vsa->format[1]);

   // Temporary buffer used for formatting the VSA.
   BYTE buffer[253], *dst = buffer;

   // Pack the Vendor-ID.
   dst = packHex(vsa->vendorID, 8, dst);

   // Pack the Vendor-Type and Vendor-Length for conformant VSAs.
   if (format != FORMAT_RAW_HEX)
   {
      dst = packHex(vsa->vendorType, 2, dst);
      dst = packHex(vsa->vendorLength, 2, dst);
   }

   // Pack the value.
   switch (format)
   {
      case FORMAT_RAW_HEX:
      {
         dst = packHex(
                   vsa->rawValue,
                   len - 10,
                   dst
                   );
         break;
      }

      case FORMAT_INTEGER:
      case FORMAT_HEX:
      case FORMAT_INET_ADDR:
      {
         dst = packHex(
                   vsa->value,
                   len - 14,
                   dst
                   );
         break;
      }

      case FORMAT_STRING:
      {
         int nchar = WideCharToMultiByte(
                         CP_ACP,
                         0,
                         vsa->value,
                         len - 14,
                         (PSTR)dst,
                         sizeof(buffer) - 6,
                         NULL,
                         NULL
                         );
         dst += nchar;
         break;
      }
   }

   // Store the temporary buffer in an attribute ...
   IASAttribute attr(true);
   attr.setOctetString(dst - buffer, buffer);

   // ... and return.
   return attr.detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\dll\iasnap.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasnap.cpp
//
// SYNOPSIS
//
//    Implementation of DLL exports for an ATL in proc server.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasutil.h>
#include <newop.cpp>

#include <enforcer.h>
#include <match.h>
#include <ntgroups.h>
#include <posteap.h>
#include <timeofday.h>
#include <userr.h>

CComModule _Module;
#include <atlimpl.cpp>

BEGIN_OBJECT_MAP(ObjectMap)
   OBJECT_ENTRY(__uuidof(AttributeMatch), AttributeMatch)
   OBJECT_ENTRY(__uuidof(NTGroups), NTGroups)
   OBJECT_ENTRY(__uuidof(TimeOfDay), TimeOfDay)
   OBJECT_ENTRY(__uuidof(PolicyEnforcer),
                IASTL::IASRequestHandlerObject<PolicyEnforcer> )
   OBJECT_ENTRY(__uuidof(ProxyPolicyEnforcer),
                IASTL::IASRequestHandlerObject<ProxyPolicyEnforcer> )
   OBJECT_ENTRY(__uuidof(URHandler),
                IASTL::IASRequestHandlerObject<UserRestrictions> )
   OBJECT_ENTRY(__uuidof(PostEapRestrictions),
                IASTL::IASRequestHandlerObject<PostEapRestrictions> )
END_OBJECT_MAP()


//////////
// DLL Entry Point
//////////
BOOL
WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID /*lpReserved*/
    )
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
     _Module.Init(ObjectMap, hInstance);

     DisableThreadLibraryCalls(hInstance);
   }
   else if (dwReason == DLL_PROCESS_DETACH)
   {
     _Module.Term();
   }

   return TRUE;
}


//////////
// Used to determine whether the DLL can be unloaded by OLE
//////////
STDAPI DllCanUnloadNow(void)
{
   return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


//////////
// Returns a class factory to create an object of the requested type.
//////////
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
   return _Module.GetClassObject(rclsid, riid, ppv);
}


//////////
// DllRegisterServer - Adds entries to the system registry
//////////
STDAPI DllRegisterServer(void)
{
   return  _Module.RegisterServer(TRUE);
}


//////////
// DllUnregisterServer - Removes entries from the system registry
//////////
STDAPI DllUnregisterServer(void)
{
   HRESULT hr = _Module.UnregisterServer();

   if (FAILED(hr)) return hr;

   hr = UnRegisterTypeLib(__uuidof(NetworkPolicy),
                          1,
                          0,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                          SYS_WIN32);

   return hr;
}

#include <BuildTree.h>
#include <xprparse.h>
#include <xprparse.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\dll\enforcer.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// FILE
//
//    enforcer.cpp
//
// SYNOPSIS
//
//    This file defines the class PolicyEnforcer.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iastlutl.h>
#include <iasutil.h>
#include <sdoias.h>
#include <enforcer.h>
#include <factory.h>
#include <policylist.h>
#include <SortedSdoCollection.h>
#include <TunnelTagger.h>

#include <BuildTree.h>
#include <xprparse.h>

_COM_SMARTPTR_TYPEDEF(ISdo, __uuidof(ISdo));
_COM_SMARTPTR_TYPEDEF(ISdoCollection, __uuidof(ISdoCollection));


PolicyEnforcerBase::~PolicyEnforcerBase() throw ()
{
   TunnelTagger::Free(tagger);
}


void PolicyEnforcerBase::processException(
                            IRequest* pRequest,
                            const _com_error& ce
                            ) throw ()
{
   LONG reason;
   if (ce.Error() == HRESULT_FROM_WIN32(ERROR_MORE_DATA))
   {
      reason = IAS_MALFORMED_REQUEST;
   }
   else
   {
      reason = IAS_INTERNAL_ERROR;
   }

   // If there was any kind of error, discard the packet.
   pRequest->SetResponse(IAS_RESPONSE_DISCARD_PACKET, reason);
}


void PolicyEnforcerBase::setPolicies(IDispatch* pDisp)
{
   using _com_util::CheckError;

   if (tagger == 0)
   {
      tagger = TunnelTagger::Alloc();
   }

   // Get the underlying collection.
   ISdoCollectionPtr collection(pDisp);

   // Get the enumerator out of the collection.
   IUnknownPtr unk;
   CheckError(get__NewSortedEnum(collection, &unk, PROPERTY_POLICY_MERIT));
   IEnumVARIANTPtr iter(unk);

   // Find out how many policies there are ...
   long count;
   CheckError(collection->get_Count(&count));

   // ... and create a temporary list to hold them.
   PolicyList temp;
   temp.reserve(count);

   //////////
   // Iterate through each policy in the collection.
   //////////

   _variant_t element;
   unsigned long fetched;

   while (iter->Next(1, &element, &fetched) == S_OK && fetched == 1)
   {
      // Get an SDO out of the variant.
      ISdoPtr policy(element);
      element.Clear();

      // Get the action and expression from the SDO.
      _variant_t policyName, propAction, propExpr;
      CheckError(policy->GetProperty(PROPERTY_SDO_NAME, &policyName));
      CheckError(policy->GetProperty(PROPERTY_POLICY_ACTION, &propAction));
      CheckError(policy->GetProperty(PROPERTY_POLICY_CONSTRAINT, &propExpr));

      // Create the Action object.
      ActionPtr action(
                   new Action(
                          V_BSTR(&policyName),
                          nameAttr,
                          propAction,
                          *tagger
                          )
                   );

      // Parse the msNPConstraint strings into a token array.
      _variant_t tokens;
      CheckError(IASParseExpressionEx(&propExpr, &tokens));

      // Convert the token array into a logic tree.
      IConditionPtr expr;
      CheckError(IASBuildExpression(&tokens, &expr));

      // Insert the objects into our policy list.
      temp.insert(expr, action);
   }

   //////////
   // We successfully traversed the collection, so save the results.
   //////////

   policies.swap(temp);
}


STDMETHODIMP PolicyEnforcerBase::Shutdown()
{
   policies.clear();

   // We may as well clear the factory cache here.
   theFactoryCache.clear();

   return S_OK;
}


STDMETHODIMP PolicyEnforcerBase::PutProperty(LONG Id, VARIANT *pValue)
{
   if (pValue == NULL) { return E_INVALIDARG; }

   switch (Id)
   {
      case PROPERTY_NAP_POLICIES_COLLECTION:
      {
         if (V_VT(pValue) != VT_DISPATCH) { return DISP_E_TYPEMISMATCH; }
         try
         {
            setPolicies(V_DISPATCH(pValue));
         }
         CATCH_AND_RETURN();
         break;
      }

      default:
      {
         return DISP_E_MEMBERNOTFOUND;
      }
   }

   return S_OK;
}

IASREQUESTSTATUS PolicyEnforcerBase::onSyncRequest(IRequest* pRequest) throw ()
{
   _ASSERT(pRequest != NULL);
   return IAS_REQUEST_STATUS_ABORT;
}


IASREQUESTSTATUS PolicyEnforcer::onSyncRequest(IRequest* pRequest) throw ()
{
   _ASSERT(pRequest != NULL);

   try
   {
      IASRequest request(pRequest);

      if (!policies.apply(request))
      {
         // Access-Request: reject the user.
         request.SetResponse(IAS_RESPONSE_ACCESS_REJECT,
                             IAS_NO_POLICY_MATCH);
      }
   }
   catch (const _com_error& ce)
   {
      processException(pRequest, ce);
   }

   return IAS_REQUEST_STATUS_HANDLED;
}

IASREQUESTSTATUS ProxyPolicyEnforcer::onSyncRequest(IRequest* pRequest) throw ()
{
   _ASSERT(pRequest != NULL);

   try
   {
      IASRequest request(pRequest);

      if (!policies.apply(request))
      {
         // If no policy fired, then check is that was an Accounting
         // or an access request
         // Accounting: discard the packet
         if (request.get_Request() == IAS_REQUEST_ACCOUNTING)
         {
            request.SetResponse(IAS_RESPONSE_DISCARD_PACKET,
                                IAS_NO_CXN_REQ_POLICY_MATCH);
         }
         else
         {
            // Access-Request: reject the user.
            request.SetResponse(IAS_RESPONSE_ACCESS_REJECT,
                                IAS_NO_CXN_REQ_POLICY_MATCH);
         }
      }
   }
   catch (const _com_error& ce)
   {
      processException(pRequest, ce);
   }

   return IAS_REQUEST_STATUS_HANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\dll\policylist.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    policylist.h
//
// SYNOPSIS
//
//    This file defines the class PolicyList.
//
// MODIFICATION HISTORY
//
//    02/06/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <guard.h>
#include <nap.h>
#include <policylist.h>


PolicyList::PolicyList()
{
   _com_util::CheckError(FinalConstruct());
}


bool PolicyList::apply(IASRequest& request) const
{
   using _com_util::CheckError;

   // This will acquire a scoped shared lock.
   Guard<PolicyList> guard(*this);

   for (MyList::const_iterator i = policies.begin(); i != policies.end(); ++i)
   {
      VARIANT_BOOL result;

      CheckError(i->first->IsTrue(request, &result));

      // If the condition holds, ...
      if (result != VARIANT_FALSE)
      {
         // ... apply the action.
         i->second->doAction(request);

         return true;
      }
   }

   return false;
}

void PolicyList::clear() throw ()
{
   LockExclusive();
   policies.clear();
   Unlock();
}

void PolicyList::swap(PolicyList& pe) throw ()
{
   // Acquire an exclusive lock on the object.
   LockExclusive();

   // Swap in the new list of policies.
   policies.swap(pe.policies);

   // Get out.
   Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\dll\policylist.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    policylist.h
//
// SYNOPSIS
//
//    This file declares the class PolicyList.
//
// MODIFICATION HISTORY
//
//    02/06/1998    Original version.
//    02/03/2000    Convert to use Action instead of IPolicyAction.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _POLICYLIST_H_
#define _POLICYLIST_H_

#include <nocopy.h>
#include <perimeter.h>
#include <vector>

#include <action.h>
interface ICondition;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    PolicyList
//
// DESCRIPTION
//
//    This class maintains and enforces a list of (condition, action) tuples.
//
///////////////////////////////////////////////////////////////////////////////
class PolicyList
   : public Perimeter, NonCopyable
{
public:
   PolicyList();

   // Applies the current policy list to the request. Returns true if an
   // action was triggered.
   bool apply(IASRequest& request) const;

   void clear() throw ();

   // Inserts a new (condition, action) tuple at the end of the list. This
   // method is not thread-safe. The user should create a temporary list
   // insert all the policies, then use swap() to update the real list.
   void insert(IConditionPtr& cond, ActionPtr& action)
   { policies.push_back(std::make_pair(cond, action)); }

   // Reserve enough space for at least N policies.
   void reserve(size_t N)
   { policies.reserve(N); }

   // Replaces the current policy list with the new one.
   void swap(PolicyList& pe) throw ();

protected:
   typedef std::vector< std::pair<IConditionPtr, ActionPtr> > MyList;

   MyList policies;  // The policy list.
};

#endif   // _POLICYLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\dll\posteap.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// SYNOPSIS
//
//    Defines the class PostEapRestrictions.
//
///////////////////////////////////////////////////////////////////////////////

#include "ias.h"
#include "posteap.h"
#include "sdoias.h"


IASREQUESTSTATUS PostEapRestrictions::onSyncRequest(
                                         IRequest* pRequest
                                         ) throw ()
{
   try
   {
      IASTL::IASRequest request(pRequest);

      IASRESPONSE response = request.get_Response();
      if (response == IAS_RESPONSE_INVALID)
      {
         IASATTRIBUTE* state = IASPeekAttribute(
                                   request,
                                   RADIUS_ATTRIBUTE_STATE,
                                   IASTYPE_OCTET_STRING
                                   );
         if ((state != 0) && (state->Value.OctetString.dwLength > 0))
         {
            // If we made it here, then we have a Challenge-Reponse that no
            // handler recognized, so we discard.
            request.SetResponse(
                        IAS_RESPONSE_DISCARD_PACKET,
                        IAS_UNEXPECTED_REQUEST
                        );
            return IAS_REQUEST_STATUS_HANDLED;
         }
      }

      IASREASON result;

      if (!CheckCertificateEku(request))
      {
         result = IAS_INVALID_CERT_EKU;
      }
      else
      {
         GenerateSessionTimeout(request);

         result = IAS_SUCCESS;

         // We apply user restrictions to Access-Rejects as well, so we only
         // want to set Access-Accept if the response code is still invalid.
         // This should only be true for unauthenticated requests.
         if (response == IAS_RESPONSE_INVALID)
         {
            request.SetResponse(IAS_RESPONSE_ACCESS_ACCEPT, IAS_SUCCESS);
         }
      }

      if (result != IAS_SUCCESS)
      {
         request.SetResponse(IAS_RESPONSE_ACCESS_REJECT, result);
      }
   }
   catch (const _com_error&)
   {
      pRequest->SetResponse(IAS_RESPONSE_DISCARD_PACKET, IAS_INTERNAL_ERROR);
   }

   return IAS_REQUEST_STATUS_HANDLED;
}


bool PostEapRestrictions::CheckCertificateEku(IASTL::IASRequest& request)
{
   // Is it an EAP-TLS request or a PEAP request?
   IASTL::IASAttribute eapType;
   DWORD attributeId = IAS_ATTRIBUTE_EAP_TYPEID;
   if ( !eapType.load(request, attributeId) )
   {
      // should never go there. At least one EAP type should be enabled
      return true;
   }

   if (eapType->Value.Integer != 13)
   {
      // Neither EAP-TLS nor PEAP-TLS
      return true;
   }

   // Here it is either EAP-TLS or PEAP-TLS

   // Are there any constraints on the certificate EKU?
   AttributeVector allowed;
   allowed.load(request, IAS_ATTRIBUTE_ALLOWED_CERTIFICATE_EKU);
   if (allowed.empty())
   {
      return true;
   }

   //////////
   // Check the constraints.
   //////////

   AttributeVector actual;
   actual.load(request, IAS_ATTRIBUTE_CERTIFICATE_EKU);

   for (AttributeVector::iterator i = actual.begin();
        i != actual.end();
        ++i)
   {
      const char* actualOid = GetAnsiString(*(i->pAttribute));
      if (actualOid != 0)
      {
         for (AttributeVector::iterator j = allowed.begin();
              j != allowed.end();
              ++j)
         {
            const char* allowedOid = GetAnsiString(*(j->pAttribute));
            if ((allowedOid != 0) && (strcmp(allowedOid, actualOid) == 0))
            {
               return true;
            }
         }
      }
   }

   return false;
}


void PostEapRestrictions::GenerateSessionTimeout(IASTL::IASRequest& request)
{
   // retrieve the generate-session-timeout attribute.
   IASATTRIBUTE* generate = IASPeekAttribute(
                               request,
                               IAS_ATTRIBUTE_GENERATE_SESSION_TIMEOUT,
                               IASTYPE_BOOLEAN
                               );
   if ((generate == 0) || !generate->Value.Boolean)
   {
      IASTraceString("Auto-generation of Session-Timeout is disabled.");
      return;
   }

   // retrieve all the ms-session-timeout and session-timeout from the request.
   DWORD attrIDs[] =
   {
      MS_ATTRIBUTE_SESSION_TIMEOUT,
      RADIUS_ATTRIBUTE_SESSION_TIMEOUT
   };

   AttributeVector sessionTimeouts;
   if (!sessionTimeouts.load(request, RTL_NUMBER_OF(attrIDs), attrIDs))
   {
      IASTraceString("Session-Timeout not present.");
      return;
   }

   DWORD minTimeout = MAXDWORD;
   // get the minimum value found. Store it in the local min value (seconds)
   for (AttributeVector::const_iterator i = sessionTimeouts.begin();
        i != sessionTimeouts.end();
        ++i)
   {
      IASTracePrintf("Session-Timeout = %lu", i->pAttribute->Value.Integer);

      if (i->pAttribute->Value.Integer < minTimeout)
      {
         minTimeout = i->pAttribute->Value.Integer;
      }
   }

   IASTracePrintf("Consensus Session-Timeout = %lu", minTimeout);

   // delete all the session-timeout from the request
   request.RemoveAttributesByType(2, attrIDs);

   // add one session-timeout with the new value to the request
   IASTL::IASAttribute sessionTimeout(true);
   sessionTimeout->dwId = RADIUS_ATTRIBUTE_SESSION_TIMEOUT;
   sessionTimeout->Value.itType = IASTYPE_INTEGER;
   sessionTimeout->Value.Integer = minTimeout;
   sessionTimeout.setFlag(IAS_INCLUDE_IN_ACCEPT);
   sessionTimeout.store(request);
}


const char* PostEapRestrictions::GetAnsiString(IASATTRIBUTE& attr)
{
   if (attr.Value.itType != IASTYPE_STRING)
   {
      return 0;
   }

   DWORD error = IASAttributeAnsiAlloc(&attr);
   if (error != NO_ERROR)
   {
      IASTL::issue_error(HRESULT_FROM_WIN32(error));
   }

   return attr.Value.String.pszAnsi;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\dll\realm.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    realm.h
//
// SYNOPSIS
//
//    Declares the class Realms.
//
// MODIFICATION HISTORY
//
//    09/08/1998    Original version.
//    03/03/1999    Rewritten to use the VBScript RegExp object.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef REALM_H
#define REALM_H
#if _MSC_VER >= 1000
#pragma once
#endif

#include <perimeter.h>
#include <regex.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    Realms
//
// DESCRIPTION
//
//    Manages a sequence of realm stripping rules.
//
///////////////////////////////////////////////////////////////////////////////
class Realms
{
public:
   Realms();
   ~Realms() throw ();

   HRESULT setRealms(VARIANT* pValue) throw ();

   bool empty() const throw ()
   { return begin == end; }

   HRESULT process(PCWSTR in, BSTR* out) const throw ();

protected:
   struct Rule
   {
      RegularExpression regexp;
      BSTR replace;

      Rule() throw ();
      ~Rule() throw ();
   };

   void setRules(Rule* rules, ULONG numRules) throw ();

private:
   mutable Perimeter monitor;
   Rule* begin;
   Rule* end;
};

#endif  // REALM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\dll\sortedsdocollection.cpp ===
//////////////////////////////////////////////////////////////////////////////
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    SortedSdoCollection.cpp

Abstract:


	Implements the get__NewSortedEnum function.
	Given an ISdoCollection interface pointer and a property ID, this function
	gives back an IEnumVARIANT interface which can be used to iterate through
	the Sdo's in a sorted order.

	Include directly in file where needed.

Author:

    Michael A. Maguire 05/19/98

Revision History:
	mmaguire 05/19/98 - created
   sbens    05/27/98 - Always return an enumerator even if the collection does
                       not need to be sorted.

--*/
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BEGIN INCLUDES
//
#include <ias.h>
#include <sdoias.h>

#include <vector>
#include <algorithm>

#include <SortedSdoCollection.h>

//
// END INCLUDES
//////////////////////////////////////////////////////////////////////////////

// VC smart pointer typedefs.
_COM_SMARTPTR_TYPEDEF(ISdo, __uuidof(ISdo));
_COM_SMARTPTR_TYPEDEF(ISdoCollection, __uuidof(ISdoCollection));

//////////////////////////////////////////////////////////////////////////////
// Functor needed for sort routine used below
//////////////////////////////////////////////////////////////////////////////
class MySort
{

public:

	MySort(LONG propertyID)
		: m_lpropertyID(propertyID) { }

	bool operator()(const _variant_t& x, const _variant_t& y) const throw ()
	{

		bool bReturnValue = FALSE;
		IDispatch * pDispatchX = NULL;
		IDispatch * pDispatchY = NULL;
		_variant_t varSequenceX;
		_variant_t varSequenceY;

		HRESULT hr;


		try
		{

			// Remember that we must free these.
			pDispatchX = (IDispatch *) (x);
			pDispatchY = (IDispatch *) (y);


			ISdoPtr spSdoX(pDispatchX);
			if( spSdoX == NULL )
				throw FALSE;

			ISdoPtr spSdoY(pDispatchY);
			if( spSdoY == NULL )
				throw FALSE;


			hr = spSdoX->GetProperty( m_lpropertyID, &varSequenceX );
			if( FAILED(hr ) )
				throw FALSE;


			hr = spSdoY->GetProperty( m_lpropertyID, &varSequenceY );
			if( FAILED(hr ) )
				throw FALSE;


			long lValX = (long) (varSequenceX);
			long lValY = (long) (varSequenceY);


			bReturnValue = (lValX < lValY);

		}
		catch(...)
		{
			// Catch all exceptions -- we'll just return FALSE.
			;
		}

		if( NULL != pDispatchX )
		{
			pDispatchX->Release();
		}
		if( NULL != pDispatchY )
		{
			pDispatchY->Release();
		}

		return bReturnValue;

	}


private:

	LONG m_lpropertyID;

};



/////////////////////////////////////////////////////////////////////////////
// get__NewSortedEnum() - Get the SDO collection item enumerator
/////////////////////////////////////////////////////////////////////////////
HRESULT get__NewSortedEnum( ISdoCollection *pSdoCollection, IUnknown** pVal, LONG lPropertyID )
{


	HRESULT hr = S_OK;

	// Don't know why get__Count takes a long but Next takes unsigned long.
	long lCount;
	unsigned long ulCountReceived;


	//
	// Check function preconditions
	//
	_ASSERT ( NULL != pSdoCollection );
	if( pSdoCollection == NULL )
		return E_POINTER;
	_ASSERT ( NULL != pVal );
	if (pVal == NULL)
		return E_POINTER;

	//
	// Get the underlying collection.
	//
	ISdoCollectionPtr spSdoCollection = pSdoCollection;


	//
	// We check the count of items in our collection and don't bother sorting the
	// enumerator if the count is zero.
	// This saves time and also helps us to a void a bug in the the enumerator which
	// causes it to fail if we call next when it is empty.
	//
	spSdoCollection->get_Count( & lCount );
	if( lCount <= 1 )
	{
		// No point in sorting.
		return spSdoCollection->get__NewEnum(pVal);
	}



	std::vector< _variant_t >	vaObjects;


	//
	// Load values from the items from ISdoCollection into our local container item.
	//

	CComPtr< IUnknown > spUnknown;

	hr = spSdoCollection->get__NewEnum( (IUnknown **) & spUnknown );
	if( FAILED( hr ) || spUnknown == NULL )
	{
		return E_FAIL;
	}

	CComQIPtr<IEnumVARIANT, &IID_IEnumVARIANT> spEnumVariant(spUnknown);
	spUnknown.Release();
	if( spEnumVariant == NULL )
	{
		return E_FAIL;
	}

	CComVariant spVariant;

	// Get the first item.
	hr = spEnumVariant->Next( 1, & spVariant, &ulCountReceived );

	while( SUCCEEDED( hr ) && ulCountReceived == 1 )
	{

		vaObjects.push_back( spVariant );

		// Clear the variant of whatever it had --
		// this will release any data associated with it.

		//ISSUE: Need to make sure that each item we copy here is being AddRef'ed.
		// Check that copy into _variant_t is causing AddRef.
		spVariant.Clear();

		// Get the next item.
		hr = spEnumVariant->Next( 1, & spVariant, &ulCountReceived );
	}


	//
	// Now that we have the objects in our STL vector of variant's,
	// let's sort them.
	//
	std::sort( vaObjects.begin(), vaObjects.end(), MySort(lPropertyID) );


	//
	//  Use ATL implementation of IEnumVARIANT
	//
	typedef CComEnum< IEnumVARIANT,
					  &__uuidof(IEnumVARIANT),
					  VARIANT,
					  _Copy<VARIANT>,
					  CComSingleThreadModel
					> EnumVARIANT;

	EnumVARIANT* newEnum = new (std::nothrow) CComObject<EnumVARIANT>;

	if (newEnum == NULL)
	{
		// ISSUE: Check that cleanup code for vector calls cleanup code for
		// _variant_t which should automatically call release on IDispatch pointers.

		return E_OUTOFMEMORY;
	}

	//
	// The AtlFlagCopy below should ensure that a new copy of the vector is made
	// which will persist in the enumerator once we've left this routine.
	//
	hr = newEnum->Init(
						vaObjects.begin(),
						vaObjects.end(),
						NULL,
						AtlFlagCopy
					   );


	//
	// Hand out the enumerator to our consumer.
	//
	if (SUCCEEDED(hr))
	{
		//  Enumerator object will be destroyed when the caller releases it.
		(*pVal = newEnum)->AddRef();

		// LEAVE!
		return S_OK;
	}

	//
	// ISSUE: Check that cleanup code for vector calls cleanup code for
	// _variant_t which should automatically call release on IDispatch pointers.
	//

	delete newEnum;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\dll\sortedsdocollection.h ===
///////////////////////////////////////////////////////////////////////////////
//
// FILE
//
//    SortedSdoCollection.h
//
// SYNOPSIS
//
//    Declares the get__NewSortedEnum function.
//
// MODIFICATION HISTORY
//
//    05/26/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _SORTEDSDOCOLLECTION_H_
#define _SORTEDSDOCOLLECTION_H_
#if _MSC_VER >= 1000
#pragma once
#endif

struct ISdoCollection;

HRESULT
get__NewSortedEnum(
    ISdoCollection* pSdoCollection,
    IUnknown** pVal,
    LONG lPropertyID
    );

#endif  // _SORTEDSDOCOLLECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\dll\posteap.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// SYNOPSIS
//
//    Declares the class PostEapRestrictions.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef POSTEAP_H
#define POSTEAP_H
#pragma once

#include "iastl.h"
#include "iastlutl.h"

class __declspec(novtable)
      __declspec(uuid("01A3BF5C-CC93-4C12-A4C3-09B0BBE7F63F"))
      PostEapRestrictions
   : public IASTL::IASRequestHandlerSync,
     public CComCoClass<PostEapRestrictions, &__uuidof(PostEapRestrictions)>
{

public:
IAS_DECLARE_REGISTRY(PostEapRestrictions, 1, IAS_REGISTRY_AUTO, IASTypeLibrary)

   PostEapRestrictions();

   // Use compiler-generated version.
   // ~PostEapRestrictions() throw ();

private:
   virtual IASREQUESTSTATUS onSyncRequest(IRequest* pRequest) throw ();

   // Functions for each of the restrictions we enforce.
   static bool CheckCertificateEku(IASTL::IASRequest& request);

   // Auto-generates the session-timeout attribute.
   static void GenerateSessionTimeout(IASTL::IASRequest& request);

   // Retrieves an ANSI string from an attribute.
   static const char* GetAnsiString(IASATTRIBUTE& attr);

   // Default buffer size for retrieving attributes.
   typedef IASTL::IASAttributeVectorWithBuffer<16> AttributeVector;

   // Not implemented.
   PostEapRestrictions(const PostEapRestrictions&);
   PostEapRestrictions& operator=(const PostEapRestrictions&);
};


inline PostEapRestrictions::PostEapRestrictions()
{
}

#endif  // POSTEAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\dll\tunneltagger.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Defines the class TunnelTagger.
//
///////////////////////////////////////////////////////////////////////////////

#include "ias.h"
#include "TunnelTagger.h"
#include <algorithm>

long TunnelTagger::refCount = 0;
TunnelTagger* TunnelTagger::instance = 0;


void TunnelTagger::Tag(IASTL::IASAttributeVector& attrs) const
{
   // Find the Tunnel-Tag attribute in the vector.
   IASTL::IASAttributeVector::iterator tagAttr =
      std::find_if(
              attrs.begin(),
              attrs.end(),
              IASTL::IASSelectByID<IAS_ATTRIBUTE_TUNNEL_TAG>()
              );
   if (tagAttr != attrs.end())
   {
      DWORD tag = tagAttr->pAttribute->Value.Integer;

      // Always erase the Tunnel-Tag since no one downstream needs it.
      attrs.erase(tagAttr);

      // If the tag is in range, ...
      if ((tag > 0) && (tag <= 0x1F))
      {
         // ... apply it to each attribute in the vector.
         for (IASTL::IASAttributeVector::iterator i = attrs.begin();
              i != attrs.end();
              ++i)
         {
            if (i->pAttribute != 0)
            {
               Tag(tag, *(i->pAttribute));
            }
         }
      }
   }
}


TunnelTagger* TunnelTagger::Alloc()
{
   IASGlobalLockSentry sentry;

   if (instance == 0)
   {
      instance = new TunnelTagger;
   }

   ++refCount;

   return instance;
}


void TunnelTagger::Free(TunnelTagger* tagger) throw ()
{
   if (tagger != 0)
   {
      IASGlobalLockSentry sentry;

      if (tagger == instance)
      {
         if (--refCount == 0)
         {
            delete instance;
            instance = 0;
         }
      }
   }
}


inline TunnelTagger::TunnelTagger()
{
   static const wchar_t* const selectNames[] =
   {
      L"IsTunnelAttribute",
      L"ID",
      0
   };

   IASTL::IASDictionary dnary(selectNames);

   while (dnary.next())
   {
      if (!dnary.isEmpty(0) && dnary.getBool(0))
      {
         tunnelAttributes.push_back(dnary.getLong(1));
      }
   }

   std::sort(tunnelAttributes.begin(), tunnelAttributes.end());
}


inline TunnelTagger::~TunnelTagger() throw ()
{
}


void TunnelTagger::Tag(DWORD tag, IASATTRIBUTE& attr) const
{
   if (IsTunnelAttribute(attr.dwId))
   {
      // The Tunnel-Password already has a tag byte.  We just have to overwrite
      // the current value (which the UI always sets to zero).
      if (attr.dwId == RADIUS_ATTRIBUTE_TUNNEL_PASSWORD)
      {
         if ((attr.Value.itType == IASTYPE_OCTET_STRING) &&
             (attr.Value.OctetString.dwLength > 0))
         {
            attr.Value.OctetString.lpValue[0] = static_cast<BYTE>(tag);
         }
      }
      else
      {
         switch (attr.Value.itType)
         {
            case IASTYPE_BOOLEAN:
            case IASTYPE_INTEGER:
            case IASTYPE_ENUM:
            {
               // For integer attributes, we store the tag in the high order
               // byte of the value.
               attr.Value.Integer &= 0x00FFFFFF;
               attr.Value.Integer |= (tag << 24);
               break;
            }

            case IASTYPE_OCTET_STRING:
            case IASTYPE_PROV_SPECIFIC:
            {
               // For octet string attributes, we shift the value right and
               // store the tag in the first byte of the value.
               IASTL::IASAttribute tmp(true);
               tmp.setOctetString((attr.Value.OctetString.dwLength + 1), 0);

               tmp->Value.OctetString.lpValue[0] = static_cast<BYTE>(tag);

               memcpy(
                  (tmp->Value.OctetString.lpValue + 1),
                  attr.Value.OctetString.lpValue,
                  attr.Value.OctetString.dwLength
                  );

               std::swap(tmp->Value.OctetString, attr.Value.OctetString);

               break;
            }

            case IASTYPE_INET_ADDR:
            case IASTYPE_UTC_TIME:
            case IASTYPE_STRING:
            case IASTYPE_INVALID:
            default:
            {
               // We don't know how to tag any of these types.
               break;
            }
         }
      }
   }
}


bool TunnelTagger::IsTunnelAttribute(DWORD id) const throw ()
{
   return std::binary_search(
                  tunnelAttributes.begin(),
                  tunnelAttributes.end(),
                  id
                  );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\dll\realm.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    realm.cpp
//
// SYNOPSIS
//
//    Defines the class Realms.
//
// MODIFICATION HISTORY
//
//    09/08/1998    Original version.
//    03/03/1999    Rewritten to use the VBScript RegExp object.
//    01/25/2000    Handle case where identity maps to an empty string.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <memory>

#include <realm.h>

inline Realms::Rule::Rule() throw ()
   : replace(NULL)
{ }

inline Realms::Rule::~Rule() throw ()
{
   SysFreeString(replace);
}

Realms::Realms()
   : begin(NULL), end(NULL)
{
   _com_util::CheckError(monitor.FinalConstruct());
}

Realms::~Realms() throw ()
{
   delete[] begin;
}

HRESULT Realms::setRealms(VARIANT* pValue)
{
   // If the VARIANT is empty, we clear the realms list and return.
   if (pValue == NULL || V_VT(pValue) == VT_EMPTY)
   {
      setRules(NULL, 0);
      return S_OK;
   }

   // It must be a SAFEARRAY of VARIANTs.
   if (V_VT(pValue) != (VT_VARIANT | VT_ARRAY))
   { return DISP_E_TYPEMISMATCH; }

   // It must be non-NULL.
   LPSAFEARRAY psa = V_ARRAY(pValue);
   if (psa == NULL) { return E_POINTER; }

   // It must be a one-dimensional array with an even number of elements.
   if (psa->cDims != 1 || (psa->rgsabound[0].cElements % 2) != 0)
   { return E_INVALIDARG; }

   // Allocate a temporary array of Rules.
   size_t nelem = psa->rgsabound[0].cElements / 2;
   Rule* tmp = new (std::nothrow) Rule[nelem];
   if (tmp == NULL) { return E_OUTOFMEMORY; }

   // Iterate through the vector and construct the rules.
   VARIANT* v   = (VARIANT*)psa->pvData;
   VARIANT* end = v + psa->rgsabound[0].cElements;
   Rule* dst = tmp;

   HRESULT hr = S_OK;

   while (v != end)
   {
      // Get the find string ...
      if (V_VT(v) != VT_BSTR)
      {
         hr = DISP_E_TYPEMISMATCH;
         break;
      }

      BSTR find = V_BSTR(v++);

      // ... and the replace string.
      if (V_VT(v) != VT_BSTR)
      {
         hr = DISP_E_TYPEMISMATCH;
         break;
      }
      BSTR replace = V_BSTR(v++);

      // Don't allow NULL's.
      if (find == NULL || replace == NULL)
      {
         hr = E_POINTER;
         break;
      }

      // Initialize the RegularExpression.
      hr = dst->regexp.setIgnoreCase(TRUE);
      if (FAILED(hr)) { break; }
      hr = dst->regexp.setGlobal(TRUE);
      if (FAILED(hr)) { break; }
      hr = dst->regexp.setPattern(find);
      if (FAILED(hr)) { break; }

      // Save the replacement string.
      dst->replace = SysAllocString(replace);
      if (dst->replace == NULL)
      {
         hr = E_OUTOFMEMORY;
         break;
      }

      // Advance to the next rule.
      ++dst;
   }

   if (SUCCEEDED(hr))
   {
      setRules(tmp, nelem);
   }
   else
   {
      delete[] tmp;
   }

   return hr;
}

HRESULT Realms::process(PCWSTR in, BSTR* out) const throw ()
{
   if (out == NULL) { return E_INVALIDARG; }
   *out = NULL;

   // Quick short-circuit if there are no rules.
   if (begin == end) { return S_OK; }

   // Convert the string to a BSTR.
   BSTR input = SysAllocString(in);
   if (!input) { return E_OUTOFMEMORY; }

   // Output is set to the new string (if any).
   BSTR output = NULL;

   // Status of rules processing.
   HRESULT hr = S_OK;

   // Acquire the shared lock.
   monitor.Lock();

   // Iterate through the rules.
   for (Rule* r = begin; r != end; ++r)
   {
      // We'll first test for a match to avoid unnecessary allocation.
      if (r->regexp.testBSTR(input))
      {
         // We have a match so, replace.
         hr = r->regexp.replace(input, r->replace, &output);
         if (FAILED(hr)) { break; }

         // If it maps to nothing, replace returns NULL instead of an empty
         // string.
         if (!output)
         {
            output = SysAllocString(L"");

            if (!output)
            {
               hr = E_OUTOFMEMORY;
               break;
            }
         }

         // The current output is the input to the next iteration.
         SysFreeString(input);
         input = output;
      }
   }

   monitor.Unlock();

   // If we succeeded in finding a match, ...
   if (SUCCEEDED(hr) && output)
   {
      *out = output;
   }
   else
   {
      // Free the latest input.
      SysFreeString(input);
   }

   return hr;
}

void Realms::setRules(Rule* rules, ULONG numRules) throw ()
{
   monitor.LockExclusive();

   // Delete the old rules ...
   delete[] begin;

   // ... and save the new ones.
   begin = rules;
   end = begin + numRules;

   monitor.Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\dll\tunneltagger.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the class TunnelTagger.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef TUNNELTAGGER_H
#define TUNNELTAGGER_H
#pragma once

#include <vector>
#include "iastlutl.h"

// Adds tag bytes to the tunnel attributes in a profile. This class is MT-Safe.
class TunnelTagger
{
public:
   // Removes the Tunnel-Tag attribute from the supplied vector and uses its
   // value to tag all the tunnel attributes in the vector.  If the Tunnel-Tag
   // attribute isn't present or is out of range, no attributes are tagged.
   // This function is weakly exception safe.
   void Tag(IASTL::IASAttributeVector& attrs) const;

   // Allocate a new TunnelTagger. Must be freed with a call to Free.
   static TunnelTagger* Alloc();

   // 'tagger' may be null
   static void Free(TunnelTagger* tagger) throw ();

private:
   TunnelTagger();
   ~TunnelTagger() throw ();

   // Tag an attribute if necessary. Assumes that tag is in range.
   void Tag(DWORD tag, IASATTRIBUTE& attr) const;

   // Tests whether an attribute with the given ID is a tunnel attribute.
   bool IsTunnelAttribute(DWORD id) const throw ();

   // There is at most one TunnelTagger for the process.
   static long refCount;
   static TunnelTagger* instance;

   // The set of tunnel attributes.
   std::vector<DWORD> tunnelAttributes;

   // Not implemented.
   TunnelTagger(const TunnelTagger&);
   TunnelTagger& operator=(const TunnelTagger&);
};



#endif // TUNNELTAGGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\dll\userr.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    userr.h
//
// SYNOPSIS
//
//    Declares the class UserRestrictions.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef USERR_H
#define USERR_H

#include <iastl.h>
#include <iastlutl.h>
using namespace IASTL;


///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    UserRestrictions
//
///////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE UserRestrictions:
   public IASRequestHandlerSync,
   public CComCoClass<UserRestrictions, &__uuidof(URHandler)>
{

public:

IAS_DECLARE_REGISTRY(URHandler, 1, IAS_REGISTRY_AUTO, IASTypeLibrary)

protected:
   virtual IASREQUESTSTATUS onSyncRequest(IRequest* pRequest) throw ();

private:
   // Helper functions for each of the restrictions we enforce.
   static BOOL checkAllowDialin(IAttributesRaw* request);
   static BOOL checkTimeOfDay(IAttributesRaw* request);
   static BOOL checkAuthenticationType(IAttributesRaw* request);
   static BOOL checkCallingStationId(IAttributesRaw* request);
   static BOOL checkCalledStationId(IAttributesRaw* request);
   static BOOL checkAllowedPortType(IAttributesRaw* request);
   static BOOL checkPasswordMustChange(IASRequest& request);

   static BOOL checkStringMatch(
                  IAttributesRaw* request,
                  DWORD allowedId,
                  DWORD userId
                  );

   // Default buffer size for retrieving attributes.
   typedef IASAttributeVectorWithBuffer<16> AttributeVector;
};

#endif  // USERR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\dll\userr.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    userr.cpp
//
// SYNOPSIS
//
//    Defines the class UserRestrictions.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <userr.h>
#include <TimeOfDay.h>

IASREQUESTSTATUS UserRestrictions::onSyncRequest(IRequest* pRequest) throw ()
{
   try
   {
      IASRequest request(pRequest);

      IASREASON result;

      if (!checkAllowDialin(request))
      {
         result = IAS_DIALIN_DISABLED;
      }
      else if (!checkTimeOfDay(request))
      {
         result = IAS_INVALID_DIALIN_HOURS;
      }
      else if (!checkAuthenticationType(request))
      {
         result = IAS_INVALID_AUTH_TYPE;
      }
      else if (!checkCallingStationId(request))
      {
         result = IAS_INVALID_CALLING_STATION;
      }
      else if (!checkCalledStationId(request))
      {
         result = IAS_INVALID_CALLED_STATION;
      }
      else if (!checkAllowedPortType(request))
      {
         result = IAS_INVALID_PORT_TYPE;
      }
      else if (!checkPasswordMustChange(request))
      {
         result = IAS_CPW_NOT_ALLOWED;
      }
      else
      {
         result = IAS_SUCCESS;
      }

      if (result != IAS_SUCCESS)
      {
         request.SetResponse(IAS_RESPONSE_ACCESS_REJECT, result);
      }
   }
   catch (const _com_error&)
   {
      pRequest->SetResponse(IAS_RESPONSE_DISCARD_PACKET, IAS_INTERNAL_ERROR);
   }

   return IAS_REQUEST_STATUS_HANDLED;
}

BOOL UserRestrictions::checkAllowDialin(
                            IAttributesRaw* request
                            )
{
   PIASATTRIBUTE attr = IASPeekAttribute(
                            request,
                            IAS_ATTRIBUTE_ALLOW_DIALIN,
                            IASTYPE_BOOLEAN
                            );

   return !attr || attr->Value.Boolean;
}

BOOL UserRestrictions::checkTimeOfDay(
                            IAttributesRaw* request
                            )
{
   AttributeVector attrs;
   attrs.load(request, IAS_ATTRIBUTE_NP_TIME_OF_DAY);
   if (attrs.empty()) { return TRUE; }

   BYTE hourMap[IAS_HOUR_MAP_LENGTH];
   memset(hourMap, 0, sizeof(hourMap));

   for (AttributeVector::iterator i = attrs.begin(); i != attrs.end(); ++i)
   {
      IASAttributeUnicodeAlloc(i->pAttribute);
      if (!i->pAttribute->Value.String.pszWide) { issue_error(E_OUTOFMEMORY); }

      // Convert the text to an hour map.
      DWORD dw = IASHourMapFromText(
                    i->pAttribute->Value.String.pszWide,
                    TRUE,
                    hourMap
                    );
      if (dw != NO_ERROR)
      {
         issue_error(HRESULT_FROM_WIN32(dw));
      }
   }

   SYSTEMTIME now;
   GetLocalTime(&now);
   DWORD timeOut = ComputeTimeout(now, hourMap);

   if (timeOut == 0)
   {
      return FALSE;
   }

   if (timeOut != 0xFFFFFFFF)
   {
      // Add the Session-Timeout attribute to the request.
      // it'll be carried over to the response later on.
      IASAttribute sessionTimeout(true);
      sessionTimeout->dwId = MS_ATTRIBUTE_SESSION_TIMEOUT;
      sessionTimeout->Value.itType = IASTYPE_INTEGER;
      sessionTimeout->Value.Integer = timeOut;
      sessionTimeout.setFlag(IAS_INCLUDE_IN_ACCEPT);
      sessionTimeout.store(request);
   }

   return TRUE;
}

BOOL UserRestrictions::checkAuthenticationType(
                            IAttributesRaw* request
                            )
{
   // special case for the external Auth provider
   PIASATTRIBUTE provider = IASPeekAttribute(
                            request,
                            IAS_ATTRIBUTE_PROVIDER_TYPE,
                            IASTYPE_ENUM
                            );
   _ASSERT(provider != 0);
   if (provider->Value.Enumerator == IAS_PROVIDER_EXTERNAL_AUTH)
   {
      return TRUE;
   }

   AttributeVector attrs;
   attrs.load(request, IAS_ATTRIBUTE_NP_AUTHENTICATION_TYPE);
   if (attrs.empty()) {return TRUE;}

   PIASATTRIBUTE attr = IASPeekAttribute(
                            request,
                            IAS_ATTRIBUTE_AUTHENTICATION_TYPE,
                            IASTYPE_ENUM
                            );
   DWORD authType = attr ? attr->Value.Enumerator : IAS_AUTH_NONE;

   // We bypass the check for BaseCamp extensions.
   if (authType == IAS_AUTH_CUSTOM) { return TRUE; }

   for (AttributeVector::iterator i = attrs.begin(); i != attrs.end(); ++i)
   {
      if (i->pAttribute->Value.Integer == authType) { return TRUE; }
   }

   return FALSE;
}

BOOL UserRestrictions::checkCallingStationId(
                            IAttributesRaw* request
                            )
{
   return checkStringMatch(
              request,
              IAS_ATTRIBUTE_NP_CALLING_STATION_ID,
              RADIUS_ATTRIBUTE_CALLING_STATION_ID
              );
}

BOOL UserRestrictions::checkCalledStationId(
                            IAttributesRaw* request
                            )
{
   return checkStringMatch(
              request,
              IAS_ATTRIBUTE_NP_CALLED_STATION_ID,
              RADIUS_ATTRIBUTE_CALLED_STATION_ID
              );
}

BOOL UserRestrictions::checkAllowedPortType(
                            IAttributesRaw* request
                            )
{
   AttributeVector attrs;
   attrs.load(request, IAS_ATTRIBUTE_NP_ALLOWED_PORT_TYPES);
   if (attrs.empty()) { return TRUE; }

   PIASATTRIBUTE attr = IASPeekAttribute(
                            request,
                            RADIUS_ATTRIBUTE_NAS_PORT_TYPE,
                            IASTYPE_ENUM
                            );
   if (!attr) { return FALSE; }

   for (AttributeVector::iterator i = attrs.begin(); i != attrs.end(); ++i)
   {
      if (i->pAttribute->Value.Enumerator == attr->Value.Enumerator)
      {
         return TRUE;
      }
   }

   return FALSE;
}

// If the password must change, we check to see if the subsequent change
// password request would be authorized. This prevents prompting the user for a
// new password when he's not allowed to change it anyway.
BOOL UserRestrictions::checkPasswordMustChange(
                            IASRequest& request
                            )
{
   if (request.get_Reason() != IAS_PASSWORD_MUST_CHANGE)
   {
      return TRUE;
   }

   PIASATTRIBUTE attr = IASPeekAttribute(
                            request,
                            IAS_ATTRIBUTE_AUTHENTICATION_TYPE,
                            IASTYPE_ENUM
                            );

   DWORD cpwType;
   switch (attr ? attr->Value.Enumerator : IAS_AUTH_NONE)
   {
      case IAS_AUTH_MSCHAP:
         cpwType = IAS_AUTH_MSCHAP_CPW;
         break;

      case IAS_AUTH_MSCHAP2:
         cpwType = IAS_AUTH_MSCHAP2_CPW;
         break;

      default:
         return TRUE;
   }

   AttributeVector attrs;
   attrs.load(request, IAS_ATTRIBUTE_NP_AUTHENTICATION_TYPE);
   for (AttributeVector::iterator i = attrs.begin(); i != attrs.end(); ++i)
   {
      if (i->pAttribute->Value.Integer == cpwType) { return TRUE; }
   }

   return FALSE;
}

BOOL UserRestrictions::checkStringMatch(
                            IAttributesRaw* request,
                            DWORD allowedId,
                            DWORD usedId
                            )
{
   AttributeVector attrs;
   attrs.load(request, allowedId);
   if (attrs.empty()) { return TRUE; }

   PIASATTRIBUTE attr = IASPeekAttribute(
                            request,
                            usedId,
                            IASTYPE_OCTET_STRING
                            );
   if (!attr) { return FALSE; }

   PCWSTR used = IAS_OCT2WIDE(attr->Value.OctetString);

   for (AttributeVector::iterator i = attrs.begin(); i != attrs.end(); ++i)
   {
      IASAttributeUnicodeAlloc(i->pAttribute);
      if (!i->pAttribute->Value.String.pszWide) { issue_error(E_OUTOFMEMORY); }

      if (!_wcsicmp(i->pAttribute->Value.String.pszWide, used)) { return TRUE; }
   }

   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\flex\exprbuilder.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    exprbuilder.h
//
// SYNOPSIS
//
//    Declares the class ExpressionBuilder.
//
// MODIFICATION HISTORY
//
//    08/14/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _EXPRBUILDER_H_
#define _EXPRBUILDER_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <nocopy.h>
#include <varvec.h>

#include <vector>

#include <nap.h>
#include <factory.h>

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    ExpressionBuilder
//
// DESCRIPTION
//
//    Assembles a vector of expression tokens.
//
///////////////////////////////////////////////////////////////////////////////
class ExpressionBuilder
   : public NonCopyable
{
public:
   // Add a condition object to the expression.
   void addCondition(PCWSTR progID)
   {
      IConditionPtr condition;
      theFactoryCache.createInstance(progID,
                                     NULL,
                                     __uuidof(ICondition),
                                     (PVOID*)&condition);
      expression.push_back(condition.GetInterfacePtr());
   }

   // Set the condition text for the condition object just added.
   void addConditionText(PCWSTR text)
   {
      if (expression.empty()) { _com_issue_error(E_INVALIDARG); }
      IConditionTextPtr cond(expression.back());
      _com_util::CheckError(cond->put_ConditionText(_bstr_t(text)));
   }

   // Add a logical operator.
   void addToken(IAS_LOGICAL_TOKEN eToken)
   {
      expression.push_back((LONG)eToken);
   }

   // Detach the fully assembled expression.
   void detach(VARIANT* pVal)
   {
      CVariantVector<VARIANT> vec(pVal, expression.size());

      for (size_t i = 0; i < expression.size(); ++i)
      {
         vec[i] = expression[i].Detach();
      }

      expression.clear();
   }

protected:
   std::vector<_variant_t> expression;
};

#endif  // _EXPRBUILDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\flex\factory.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    Factory.cpp
//
// SYNOPSIS
//
//    This file defines the class FactoryCache.
//
// MODIFICATION HISTORY
//
//    02/05/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>
#include <iasutil.h>
#include <factory.h>

//////////
// The global factory cache.
//////////
FactoryCache theFactoryCache(IASProgramName);

Factory::Factory(PCWSTR progID, IClassFactory* classFactory)
{
   // Check the arguments.
   if (progID == NULL || classFactory == NULL)
   { _com_issue_error(E_POINTER); }

   // Copy the progID string.
   name = wcscpy(new WCHAR[wcslen(progID) + 1], progID);

   // Save the classFactory pointer. We must do this after the string
   // copy since the memory allocation may throw std::bad_alloc.
   (factory = classFactory)->AddRef();
}

Factory::Factory(const Factory& f)
   : name(wcscpy(new WCHAR[wcslen(f.name) + 1], f.name)),
     factory(f.factory)
{
   factory->AddRef();
}

Factory& Factory::operator=(const Factory& f)
{
   // Make sure the copy succeeds before we release our state.
   PWSTR newName = wcscpy(new WCHAR[wcslen(f.name) + 1], f.name);

   // Free up our current state.
   delete[] name;
   factory->Release();

   // Copy in the new state.
   name = newName;
   (factory = f.factory)->AddRef();

   return *this;
}

Factory::~Factory() throw ()
{
   factory->Release();
   delete[] name;
}

FactoryCache::FactoryCache(PCWSTR defaultPrefix)
{
   if (defaultPrefix)
   {
      // Allocate memory.
      prefixLen = wcslen(defaultPrefix) + 2;
      prefix = new WCHAR[prefixLen];

      // Copy in the prefix.
      wcscpy(prefix, defaultPrefix);

      // Add the dot delimiter.
      wcscat(prefix, L".");
   }
   else
   {
      prefixLen = 0;
      prefix = NULL;
   }
}

FactoryCache::~FactoryCache() throw ()
{
   delete[] prefix;
}

void FactoryCache::clear() throw ()
{
   _serialize
   factories.clear();
}

void FactoryCache::CLSIDFromProgID(PCWSTR progID, LPCLSID pclsid) const
{
   if (prefix)
   {
      // Concatenate the prefix and the progID.
      size_t len = wcslen(progID) + prefixLen;
      PWSTR withPrefix = (PWSTR)_alloca(len * sizeof(WCHAR));
      memcpy(withPrefix, prefix, prefixLen * sizeof(WCHAR));
      wcscat(withPrefix, progID);

      // Try with the prefix prepended ...
      if (SUCCEEDED(::CLSIDFromProgID(withPrefix, pclsid))) { return; }
   }

   // ... then try it exactly as passed in.
   _com_util::CheckError(::CLSIDFromProgID(progID, pclsid));
}

void FactoryCache::createInstance(PCWSTR progID,
                                  IUnknown* pUnkOuter,
                                  REFIID riid,
                                  void** ppvObject)
{
   // This is *very* hokey, but it beats creating a real Factory object.
   Factory& key = *(Factory*)(&progID);

   _serialize

   // Check our cache for the progID.
   std::set<Factory>::iterator factory = factories.find(key);

   if (factory == factories.end())
   {
      // Look up the CLSID for this progID.
      CLSID clsid;
      CLSIDFromProgID(progID, &clsid);

      // Retrieve the Class Factory.
      CComPtr<IClassFactory> newFactory;
      _com_util::CheckError(CoGetClassObject(clsid,
                                             CLSCTX_INPROC_SERVER,
                                             NULL,
                                             __uuidof(IClassFactory),
                                             (PVOID*)&newFactory));

      // Insert it into the cache.
      factories.insert(Factory(progID, newFactory));

      // Retrieve the newly created master.
      factory = factories.find(key);
   }

   // Create the requested object.
   factory->createInstance(pUnkOuter, riid, ppvObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\inc\xprparse.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    xprparse.h
//
// SYNOPSIS
//
//    This file declares the function IASParseExpression.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef XPRPARSE_H
#define XPRPARSE_H

#ifdef __cplusplus
extern "C" {
#endif

HRESULT
WINAPI
IASParseExpressionEx(
    IN VARIANT* pvExpression,
    OUT VARIANT* pVal
    );

#ifdef __cplusplus
}
#endif
#endif  // XPRPARSE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\flex\xprparse.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    xprparse.cpp
//
// SYNOPSIS
//
//    This file implements the function IASParseExpression.
//
// MODIFICATION HISTORY
//
//    02/06/1998    Original version.
//    05/21/1999    Remove old style trace.
//    03/23/2000    Use two quotes to escape a quote.
//
///////////////////////////////////////////////////////////////////////////////

#include <ias.h>

#include <ExprBuilder.h>
#include <Parser.h>
#include <xprparse.h>

//////////
// Struct for converting an identifier to a logical token.
//////////
struct KeyWord
{
   PCWSTR identifier;
   IAS_LOGICAL_TOKEN token;
};

//////////
// Table of keywords. These must be sorted alphabetically.
//////////
const KeyWord KEYWORDS[] =
{
   { L"AND",   IAS_LOGICAL_AND         },
   { L"FALSE", IAS_LOGICAL_FALSE       },
   { L"NOT",   IAS_LOGICAL_NOT         },
   { L"OR",    IAS_LOGICAL_OR          },
   { L"TRUE",  IAS_LOGICAL_TRUE        },
   { L"XOR",   IAS_LOGICAL_XOR         },
   { NULL,     IAS_LOGICAL_NUM_TOKENS  }
};

//////////
// Returns the IAS_LOGICAL_TOKEN equivalent for 'key' or IAS_LOGICAL_NUM_TOKENS
// if no such equivalent exists.
//////////
IAS_LOGICAL_TOKEN findKeyWord(PCWSTR key) throw ()
{
   // We'll use a linear search since the table is so small.
   for (const KeyWord* i = KEYWORDS; i->identifier; ++i)
   {
      int cmp = _wcsicmp(key, i->identifier);

      // Did we find it ?
      if (cmp == 0) { return i->token; }

      // Did we we go past it ?
      if (cmp < 0) { break; }
   }

   return IAS_LOGICAL_NUM_TOKENS;
}

//////////
// Special characters for parsing.
//////////
const WCHAR WHITESPACE[]       = L" \t\n";
const WCHAR TOKEN_DELIMITERS[] = L" \t\n()";

//////////
// Parse a chunk of expression text and add it to the ExpressionBuilder.
//////////
void addExpressionString(ExpressionBuilder& expression, PCWSTR szExpression)
{
   //////////
   // Make a local copy because parser can temporarily modify the string.
   //////////

   size_t len = sizeof(WCHAR) * (wcslen(szExpression) + 1);
   Parser p((PWSTR)memcpy(_alloca(len), szExpression, len));

   //////////
   // Loop through the expression until we hit the null-terminator.
   //////////
   while (*p.skip(WHITESPACE) != L'\0')
   {
      //////////
      // Parentheses are handled separately since they don't have to be
      // delimited by whitespace.
      //////////
      if (*p == L'(')
      {
         expression.addToken(IAS_LOGICAL_LEFT_PAREN);
         ++p;
      }
      else if (*p == L')')
      {
         expression.addToken(IAS_LOGICAL_RIGHT_PAREN);
         ++p;
      }
      else
      {
         // Get the next token.
         const wchar_t* token = p.findToken(TOKEN_DELIMITERS);

         // Check if it's a keyword.
         IAS_LOGICAL_TOKEN keyWord = findKeyWord(token);
         if (keyWord != IAS_LOGICAL_NUM_TOKENS)
         {
            // If it is a keyword, add it to the expression ...
            expression.addToken(keyWord);
            p.releaseToken();
         }
         else
         {
            // If it's not a keyword, it must be a condition object.
            expression.addCondition(token);
            p.releaseToken();

            // Skip the leading parenthesis.
            p.skip(WHITESPACE);
            p.ignore(L'(');

            // Skip the leading quote.
            p.skip(WHITESPACE);
            p.ignore(L'\"');

            // We're now at the beginning of the condition text.
            p.beginToken();

            // Find the trailing quote, skipping any escaped characters.
            while (p.findNext(L'\"')[1] == L'\"')
            {
               ++p;
               p.erase(1);
            }

            // Add the condition text.
            expression.addConditionText(p.endToken());
            p.releaseToken();

            // Skip the trailing quote
            p.ignore(L'\"');

            // Skip the trailing parenthesis.
            p.skip(WHITESPACE);
            p.ignore(L')');
         }
      }
   }
}


HRESULT
WINAPI
IASParseExpression(
    PCWSTR szExpression,
    VARIANT* pVal
    )
{
   if (szExpression == NULL || pVal == NULL) { return E_INVALIDARG; }

   VariantInit(pVal);

   try
   {
      ExpressionBuilder expression;

      addExpressionString(expression, szExpression);

      expression.detach(pVal);
   }
   catch (Parser::ParseError)
   {
      return E_INVALIDARG;
   }
   CATCH_AND_RETURN()

   return S_OK;
}


HRESULT
WINAPI
IASParseExpressionEx(
    IN VARIANT* pvExpression,
    OUT VARIANT* pVal
    )
{
   if (pvExpression == NULL || pVal == NULL) { return E_INVALIDARG; }

   // If the VARIANT contains a single BSTR, we can just use the method
   // defined above.
   if (V_VT(pvExpression) == VT_BSTR)
   {
      return IASParseExpression(V_BSTR(pvExpression), pVal);
   }

   VariantInit(pVal);

   try
   {
      ExpressionBuilder expression;

      if (V_VT(pvExpression) == VT_EMPTY)
      {
         // If the variant is empty, the expression is always false.
         expression.addToken(IAS_LOGICAL_FALSE);
      }
      else
      {
         CVariantVector<VARIANT> values(pvExpression);

         for (size_t i = 0; i < values.size(); ++i)
         {
            // If we have more than one value, join them by AND's.
            if (i != 0) { expression.addToken(IAS_LOGICAL_AND); }

            if (V_VT(&values[i]) != VT_BSTR)
            {
               _com_issue_error(DISP_E_TYPEMISMATCH);
            }

            addExpressionString(expression, V_BSTR(&values[i]));
         }
      }

      expression.detach(pVal);
   }
   catch (Parser::ParseError)
   {
      return E_INVALIDARG;
   }
   CATCH_AND_RETURN()

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\providers\nap\regex\fa.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       FA.cxx
//
//  Contents:   Non-deterministic finite automata
//
//  Classes:    CNFA
//
//  History:    01-20-92  KyleP     Created
//				03-11-97  arunk		Modified for Kessel
//--------------------------------------------------------------------------

#include <fa.hxx>
#include <stateset.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CFA::CFA, public
//
//  Synopsis:   Copy constructor
//
//  History:    13-Jul-95 KyleP     Created
//
//--------------------------------------------------------------------------

CFA::CFA( CFA const & src )
        : _cTotal( src._cTotal ),
          _ppState( 0 )
{
    _ppState = new CFAState * [ _cTotal ];

    unsigned i = 0;

        for ( ; i < _cTotal; i++ )
        {
            if ( 0 == src._ppState[i] )
                _ppState[i] = 0;
            else
                _ppState[i] = new CFAState( *src._ppState[i] );
        }
}

//+-------------------------------------------------------------------------
//
//  Member:     CFA::~CFA, protected
//
//  Synopsis:   Frees automata.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

CFA::~CFA()
{
    if( _ppState )
    {
        for ( UINT i = 0; i < _cTotal; i++ )
        {
            delete _ppState[i];
        }

        delete _ppState;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CFA::Add, protected
//
//  Synopsis:   Adds new state to automata.
//
//  Arguments:  [pState] -- New state.  State number is member data.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CFA::Add( CFAState * pState )
{
    if ( pState->StateNumber() > _cTotal )
    {
        for( UINT newTotal = (_cTotal) ? _cTotal * 2 : 1;
             pState->StateNumber() > newTotal;
             newTotal *= 2 );

        CFAState ** oldState = _ppState;

        _ppState = new CFAState * [ newTotal ];

        memcpy( _ppState, oldState,
                _cTotal * sizeof( CFAState * ) );
        memset( _ppState + _cTotal,
                0,
                (newTotal - _cTotal) * sizeof( CFAState * ) );

        _cTotal = newTotal;
    }

    _ppState[pState->StateNumber() - 1] = pState;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFA::Get, protected
//
//  Arguments:  [iState] -- State to fetch.
//
//  Returns:    State [iState].
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

CFAState * CFA::Get( UINT iState ){
    return( _ppState[ iState - 1 ] );
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::CNFA, public
//
//  Synopsis:   Converts regular expression string to NFA.
//
//  Arguments:  [pwcs]      -- Regular expression.
//              [fCaseSens] -- true if case sensitive search.
//
//  History:    20-Jan-92 Kyleap    Created
//
//--------------------------------------------------------------------------

CNFA::CNFA( WCHAR const * pwcs, bool fCaseSens )
        : _iNextState( 1 ),
          _iStart( 0 ),
          _chars( fCaseSens ),
          _pState( 0 )
{
    UINT iEnd;

    //
    // _pState initially contains room for 2 * #chars in regex.  According
    // to the Dragon Book pg. 121 this is guaranteed to be sufficient space.
    // Of course the dragon book doesn't completely take DOS or CMS into
    // account. For DOS, we need to treat beginning (and end) of line as
    // 'characters' in the string. For CMS, I agreed to support the
    // {m,n} construct, which clearly violates this rule.
    //

    if ( 0 == pwcs )
    {
        throw ERROR_INVALID_PARAMETER;
    }

    _cState = wcslen( pwcs ) * 2 + 2*2;  // 2*2 for beginning & end of line
    _pState = new CNFAState [ _cState ];

    for ( unsigned i = 1 ; i <= _cState; i++ )
        Get(i)->Init(i);

    FindCharClasses( pwcs );
    Parse( pwcs, &_iStart, &iEnd );

    Get( iEnd )->MakeFinal();

}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::CNFA, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [src] -- Source
//
//  History:    13-Jul-95 Kylep    Created
//
//--------------------------------------------------------------------------

CNFA::CNFA( CNFA const & src )
        : _iNextState( src.NumStates() ),
          _iStart( src._iStart ),
          _chars( src._chars ),
          _cState( src._cState ),
          _pState( new CNFAState [ src._cState ] )
{
    for ( unsigned i = 0; i < _cState; i++ )
        _pState[i] = src._pState[i];

}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::~CNFA, public
//
//  Synopsis:   Free state table.
//
//  History:    13-Oct-92 KyleP     Created
//
//--------------------------------------------------------------------------

CNFA::~CNFA()
{
    delete [] _pState;
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::EpsClosure, public
//
//  Synopsis:   Computes the epsilon closure for state [StateNum]
//
//  Effects:    States in the epsilon closure of state [StateNum]
//              are added to the state set [ssOut].
//
//  Arguments:  [StateNum] -- Initial state.
//              [ssOut]    -- Output state set.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFA::EpsClosure( UINT StateNum, CStateSet & ssOut )
{
    CStateSet ssTraversed;

    ssOut.Add( StateNum );

    bool changed = true;

    while ( changed )
    {
        changed = false;

        for ( UINT i = ssOut.Count(); i > 0; i-- )
        {
            if ( !ssTraversed.IsMember( ssOut.State( i ) ) )
            {
                ssTraversed.Add( ssOut.State( i ) );

                Get( ssOut.State( i ) )->Move( ssOut, symEpsilon );

                changed = true;
            }
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::EpsClosure, public
//
//  Synopsis:   Computes the epsilon closure for state set [ssIn]
//
//  Effects:    States in the epsilon closure of [ssIn]
//              are added to the state set [ssOut].
//
//  Arguments:  [ssIn]  -- Initial state set.
//              [ssOut] -- Output state set.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFA::EpsClosure( CStateSet & ssIn, CStateSet & ssOut )
{
    for ( UINT i = ssIn.Count(); i > 0; i-- )
    {
        EpsClosure( ssIn.State( i ), ssOut );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::IsFinal, public
//
//  Arguments:  [ss] -- State set
//
//  Returns:    true if some state in [ss] is final.
//
//  History:    20-Jan-92 Kyleap    Created
//
//--------------------------------------------------------------------------

bool CNFA::IsFinal( CStateSet & ss )
{
    bool fFinal = false;

    for ( UINT i = ss.Count(); i > 0 && !fFinal; i-- )
    {
        fFinal = (Get( ss.State( i ) )->IsFinal() != NULL);
    }

    return( fFinal );
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::Move, public
//
//  Effects:    Performs a non-deterministic move from every state
//              in [ssIn] on [symbol].  The new state set is in
//              [ssOut].
//
//  Arguments:  [ssIn]   -- Initial state set.
//              [ssOut]  -- Final state set.
//              [symbol] -- Transition symbol.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFA::Move( CStateSet & ssIn, CStateSet & ssOut, UINT symbol )
{
    for ( UINT i = ssIn.Count(); i > 0; i-- )
    {
        Get( ssIn.State( i ) )->Move( ssOut, symbol );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::FindCharClasses, private
//
//  Effects:    Partitions the UniCode character space (2^16 characters)
//              into equivalence classes such that all characters in
//              a given class will have identical transitions in the NFA.
//
//  Arguments:  [wcs] -- Original regular expression string.
//
//  History:    20-Jan-92 KyleP     Created
//
//  Notes:      If case sensitivity is turned off, two ranges will be
//              added for characters with upper/lower case.  Even though
//              both ranges react identically the mapping algorithm can
//              only deal with contiguous ranges of characters.
//
//--------------------------------------------------------------------------

void CNFA::FindCharClasses( WCHAR const * wcs )
{
    //
    // Scan the regex looking for characters with (potentially)
    // different transitions.
    //

    while ( *wcs )
    {
        switch ( *wcs )
        {
        case wcAnySingle:
        case wcAnyMultiple:
        case wcDOSDot:
            break;

        case wcEscape:
        {
            wcs++;

            switch ( *wcs )
            {
            case 0:
                throw ERROR_INVALID_PARAMETER;
                break;

            case wcAnySingle:
            case wcRepeatZero:
            case wcRepeatOne:
            case wcOr:
            case wcBeginParen:
            case wcEndParen:
                break;

            case wcBeginRepeat:
                for ( wcs++; *wcs; wcs++ )
                {
                    if ( *wcs == wcEscape && *(wcs+1) == wcEndRepeat )
                    {
                        wcs++;
                        break;
                    }
                }
                break;

            case wcBeginRange:
                wcs++;

                //
                // Check the special cases of ^ and ]
                //

                if ( *wcs == wcInvertRange )
                    wcs++;

                if ( *wcs == wcEndRange )
                {
                    _chars.AddRange( *wcs, *wcs );
                    wcs++;
                }

                for ( ; *wcs && *wcs != wcEndRange; wcs++ )
                {
                    if ( *(wcs + 1) == wcRangeSep )
                    {
                        _chars.AddRange( *wcs, *(wcs+2) );
                    }
                    else
                    {
                        _chars.AddRange( *wcs, *wcs );
                    }
                }

                if ( *wcs != wcEndRange )
                {
                   throw ERROR_INVALID_PARAMETER;
                }

                break;

            default:
                _chars.AddRange( *wcs, *wcs );
                break;
            }

            break;
        }

        default:
            _chars.AddRange( *wcs, *wcs );
            break;
        }

        wcs++;
    }

    _chars.Prepare();
}

WCHAR * CNFA::_wcsNull = (WCHAR*)"";

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::Parse, private
//
//  Synopsis:   Creates a NFA from [wcs]
//
//  Effects:    Parses [wcs] until end of string or character wcHalt is
//              encountered.  On exit, [iStart] and [iEnd] contain the
//              starting and ending states of the NFA, respectively.
//              [pwcsEnd] points to the last character of [wcs] that was
//              parsed.
//
//  Arguments:  [wcs]     -- Regular expression.
//              [iStart]  -- Starting state of NFA.
//              [iEnd]    -- Ending state of NFA
//              [pwcsEnd] -- Last character of [wcs] that was parsed.
//              [wcHalt]  -- Stop parsing if this character encountered.
//
//  History:    20-Jan-92 KyleP     Created
//              08-Jun-98 SBens     Fixed so that all top-level OR clauses
//                                  must terminate with symEndLine.
//
//--------------------------------------------------------------------------

void CNFA::Parse( WCHAR const * wcs,
                  UINT * iStart,
                  UINT * iEnd,
                  WCHAR const * * pwcsEnd,
                  WCHAR wcHalt )
{
    unsigned iCurrent;
    unsigned iNext;

    unsigned iLocalStart;               // Used for */+/? repositioning
    bool fRepeat = false;            // Used for +
    bool fTopLevel = (*iStart == 0); // true if at top level;

    *iEnd = 0;

    //
    // Get a starting state.  *iStart == 0 implies this is the 'top-level'
    // parse of the regular expression (e.g. we're not parsing a
    // parenthesized subexpression.
    //

    if ( fTopLevel )
    {
        iCurrent = _iNextState;
        *iStart = _iNextState++;
        iLocalStart = 0;

        //
        // non-EGREP (DOS) regex match entire string.
        //

        if ( *wcs != wcAnyMultiple )
        {
            iNext = _iNextState;
            Get( iCurrent )->AddTransition( symBeginLine, _iNextState );
            _iNextState++;
            iCurrent = iNext;
        }
        else
        {
            //
            // Add a 'special' transition on the very first state to
            // eat up characters until we actually jump into the
            // regular expresion.
            //

            Get( iCurrent )->AddTransition( symAny, Get( iCurrent )->StateNumber() );
        }
    }
    else
    {
        iCurrent = *iStart;
        iLocalStart = *iStart;
    }

    unsigned iOrStart = Get( iCurrent )->StateNumber();

    //
    // wcsLocalStart tracks the piece of string to be repeated for wcZeroOrOne, etc.
    //

    WCHAR const * wcsLocalStart = wcs;

    //
    // Parse the regular expression until there is no more or a
    // termination character is hit.
    //

    for ( ; *wcs && *wcs != wcHalt; wcs++ )
    {
        switch ( *wcs )
        {
        case wcAnySingle:
            iNext = _iNextState;
            Get( iCurrent )->AddTransition( symAny, _iNextState );
            iLocalStart = Get( iCurrent )->StateNumber();
            wcsLocalStart = wcs;
            _iNextState++;
            iCurrent = iNext;
            break;

        case wcAnyMultiple:
            //
            // Any single
            //

            iNext = _iNextState;
            Get( iCurrent )->AddTransition( symAny, _iNextState );
            iLocalStart = Get( iCurrent )->StateNumber();
            wcsLocalStart = wcs;
            _iNextState++;
            iCurrent = iNext;

            //
            // Repeat zero or more
            //

            Get( iLocalStart )->AddTransition( symEpsilon,
                                               Get( iCurrent )->StateNumber() );
            Get( iCurrent )->AddTransition( symEpsilon, iLocalStart );
            break;

        case wcEscape:
        {
            wcs++;

            switch ( *wcs )
            {
            case wcBeginParen:
            {
                UINT iLocalEnd;

                iLocalStart = Get( iCurrent )->StateNumber();
                wcsLocalStart = wcs - 1;
                wcs++;                      // Eat '('.
                Parse( wcs, &iLocalStart, &iLocalEnd, &wcs, wcEndParen );
                wcs--;                      // Provide character for loop to eat.
                iCurrent = iLocalEnd;

                break;
            }

            case wcEndParen:
                //
                // Taken care of at outer level.  Just backup so we hit the end.
                //

                wcs--;
                break;

            case wcBeginRepeat:
            {
                if ( wcHalt == wcBeginRepeat )
                {
                    //
                    // Taken care of at outer level.  Just backup so we hit the end.
                    //

                    wcs--;
                }
                else
                {
                    //
                    // Setup: Bounds of repeated regex
                    //

                    WCHAR const * wcsStartRepeat = wcsLocalStart;
                    WCHAR const * wcsEndRepeat = wcs + 1;

                    //
                    // Setup: Repeat parameters.
                    //

                    unsigned cRepeat1, cRepeat2;
                    wcs++;

                    ParseRepeat( wcs, cRepeat1, cRepeat2 );

                    unsigned iLocalEnd;

                    //
                    // The minimum set has no epsilon transitions.
                    //

                    if ( cRepeat1 > 1 )
                    {
                        iLocalStart = Get( iCurrent )->StateNumber();
                        iLocalEnd = iLocalStart;

                        for ( unsigned i = 1; i < cRepeat1; i++ )
                        {
                            WCHAR const * wcsEnd;

                            iLocalStart = iLocalEnd;
                            iLocalEnd = 0;  // Must be zero!

                            Parse( wcsLocalStart, &iLocalStart, &iLocalEnd, &wcsEnd, wcBeginRepeat );

                            if ( wcsEnd != wcsEndRepeat )
                            {
                               throw ERROR_INVALID_PARAMETER;
                            }
                        }
                    }
                    else
                        iLocalEnd = Get( iCurrent )->StateNumber();

                    if ( cRepeat1 == cRepeat2 )
                    {
                    }
                    else if ( cRepeat2 == 0 )
                    {

                        Get( iLocalEnd )->AddTransition( symEpsilon, iLocalStart );
                    }
                    else if ( cRepeat2 > cRepeat1 )
                    {
                        for ( unsigned i = cRepeat1; i < cRepeat2; i++ )
                        {
                            WCHAR const * wcsEnd;

                            iLocalStart = iLocalEnd;
                            iLocalEnd = 0;  // Must be zero!

                            Parse( wcsLocalStart, &iLocalStart, &iLocalEnd, &wcsEnd, wcBeginRepeat );
                            Get( iLocalStart )->AddTransition( symEpsilon, iLocalEnd );

                            if ( wcsEnd != wcsEndRepeat )
                            {
                               throw ERROR_INVALID_PARAMETER;
                            }
                        }
                    }
                    else
                    {
                       throw ERROR_INVALID_PARAMETER;
                    }

                    iCurrent = iLocalEnd;
                    iLocalStart = 0;
                    wcsLocalStart = _wcsNull;
                }
                break;
            }

            case wcOr:
                // Top level 'OR' clauses must terminate with symEndLine.
                if ( fTopLevel )
                {
                    iNext = _iNextState;
                    Get( iCurrent )->AddTransition( symEndLine, _iNextState );
                    _iNextState++;
                    iCurrent = iNext;
                }

                if ( *iEnd == 0 )
                {
                    //
                    // First part of OR clause.
                    //

                    *iEnd = Get( iCurrent )->StateNumber();
                }
                else
                {
                    //
                    // Subsequent OR clause.  Epsilon link to end
                    //

                    Get( iCurrent )->AddTransition( symEpsilon, *iEnd );
                }
                iCurrent = iOrStart;
                wcsLocalStart = _wcsNull;
                iLocalStart = 0;
                break;

            case wcBeginRange:
            {
                bool fReverse = false;

                wcsLocalStart = wcs-1;
                iNext = _iNextState;
                wcs++;                      // Eat '['.  ']' eaten by loop.

                //
                // Check the special cases of ^ and ]
                //

                if ( *wcs == wcInvertRange )
                {
                    wcs++;

                    fReverse = true;

                    //
                    // Add all transitions, they will be removed later.
                    //

                    for ( UINT uiNext = _chars.TranslateRange( 1,
                                                               (USHORT) symLastValidChar );
                          uiNext != 0;
                          uiNext = _chars.TranslateRange( 0, (USHORT) symLastValidChar ) )
                    {
                        Get( iCurrent )->AddTransition( uiNext,
                                                  _iNextState );
                    }

                }

                if ( *wcs == wcEndRange )
                {
                    if ( fReverse )
                    {
                        Get( iCurrent )->RemoveTransition( _chars.Translate( *wcs++ ),
                                                     _iNextState );
                    }
                    else
                    {
                        Get( iCurrent )->AddTransition( _chars.Translate( *wcs++ ),
                                                  _iNextState );
                    }
                }

                for ( ; *wcs && *wcs != wcEndRange; wcs++ )
                {
                    if ( *(wcs + 1) == wcRangeSep )
                    {
                        if ( fReverse )
                        {
                            Get( iCurrent )->RemoveTransition(
                                    _chars.TranslateRange( *wcs, *(wcs+2) ),
                                    _iNextState );
                        }
                        else
                        {
                            Get( iCurrent )->AddTransition(
                                    _chars.TranslateRange( *wcs, *(wcs+2) ),
                                    _iNextState );
                        }

                        for ( UINT uiNext = _chars.TranslateRange( 0,
                                                                   *(wcs+2) );
                              uiNext != 0;
                              uiNext = _chars.TranslateRange( 0, *(wcs+2) ) )
                        {
                            if ( fReverse )
                            {
                                Get( iCurrent )->RemoveTransition( uiNext,
                                                             _iNextState );
                            }
                            else
                            {
                                Get( iCurrent )->AddTransition( uiNext,
                                                          _iNextState );
                            }
                        }

                        wcs += 2;
                    }
                    else
                    {
                        if ( fReverse )
                        {
                            Get( iCurrent )->RemoveTransition(
                                    _chars.Translate( *wcs ),
                                    _iNextState );
                        }
                        else
                        {
                            Get( iCurrent )->AddTransition(
                                    _chars.Translate( *wcs ),
                                    _iNextState );
                        }
                    }
                }

                if ( *wcs != wcEndRange )
                {
                   throw ERROR_INVALID_PARAMETER;
                }

                iLocalStart = Get( iCurrent )->StateNumber();
                _iNextState++;
                iCurrent = iNext;
                break;
            }

            case wcRepeatOne:
                if ( iLocalStart == 0 )
                {
                   throw ERROR_INVALID_PARAMETER;
                }

                Get( iCurrent )->AddTransition( symEpsilon, iLocalStart );
                break;

            case wcRepeatZero:
                if ( iLocalStart == 0 )
                {
                   throw ERROR_INVALID_PARAMETER;
                }
                Get( iLocalStart )->AddTransition( symEpsilon,
                                                   Get( iCurrent )->StateNumber() );
                Get( iCurrent )->AddTransition( symEpsilon, iLocalStart );
                break;

            case wcRepeatZeroOrOne:
            {
                if ( iLocalStart == 0 )
                {
                   throw ERROR_INVALID_PARAMETER;
                }
                Get( iLocalStart )->AddTransition( symEpsilon,
                                                   Get( iCurrent )->StateNumber() );
                break;
            }

            d