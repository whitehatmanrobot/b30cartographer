   * first call to ReadRequest, and nothing has been read.
     */
    
    if (numBytes == (DWORD) -1)
    {
        cbNeeded = _cchHeader;
        pvRead = (void *)_achHeader;
    }
    else
    {
        if (_psi != NULL)
        {
            /*
             * We're reading in content. Check if we 
             * need to read more.
             */

            _cbContentRead += (int) numBytes;
            ASSERT(_cbContentRead <= _contentLength);
            cbNeeded = _contentLength - _cbContentRead;
            if (cbNeeded > 0)
            {
                pvRead = (void *) &(_psi->GetContent()[_cbContentRead]);
            }
        }
        else
        {
            /*
             * We're reading headers. Look for the end of the headers.
             */
    
            _cchHeaderRead += (int) numBytes;
            ASSERT(_cchHeaderRead <= _cchHeader);
            _achHeader[_cchHeaderRead] = '\0';

            pchEndOfHeader = strstr(&_achHeader[_iCurrent], "\r\n\r\n");
            if (pchEndOfHeader != NULL)
            {
                /*
                 * We've read in the header. Parse it.
                 */
                _iContent = PtrToLong(pchEndOfHeader - _achHeader) + 4;
                _iCurrent = _iContent;
                hr = ParseHeader();
                ON_ERROR_EXIT();

                if (_contentLength > 0)
                {
                    /*
                     * Alloc the content buffer, copy any content in the header buffer
                     * to the content buffer, and check how much we have left to read.
                     */

                    _psi = StateItem::Create(_contentLength);
                    ON_OOM_EXIT(_psi);

                    cchContentInHeader = _cchHeaderRead - _iContent;
                    cchContentInHeader = min(cchContentInHeader, _contentLength);
                    CopyMemory(_psi->GetContent(), &_achHeader[_iContent], cchContentInHeader);
                    _iCurrent += cchContentInHeader;
                    _cbContentRead = cchContentInHeader;
                    cbNeeded = _contentLength - _cbContentRead;
                    if (cbNeeded > 0)
                    {
                        pvRead = (void *) &(_psi->GetContent()[_cbContentRead]);
                    }
                }
            }
            else 
            {
                /*
                 * Read some more.
                 *
                 * Advance _iCurrent for next end-of-headers search.
                 */
                _iCurrent = max(_iCurrent, _cchHeaderRead - 3);

                if (_cchHeaderRead == _cchHeader)
                {
                    /*
                     * Alloc more buffer space.
                     */

                    pchOldHeader = _achHeader;
                    _cchHeader += READ_BUF_SIZE;
                    _achHeader = new char[_cchHeader + 1];
                    ON_OOM_EXIT(_achHeader);

                    CopyMemory(_achHeader, pchOldHeader, _cchHeaderRead + 1);
                }
    
                ASSERT(_cchHeader > _cchHeaderRead);
                cbNeeded = _cchHeader - _cchHeaderRead;
                pvRead = (void *) &_achHeader[_cchHeaderRead];
            }
        }
    }

    if (cbNeeded <= 0)
    {
        /*
         * Use an empty header as a signal to disconnect. This allows
         * us to use sendsock to send multiple requests.        
         */
        ASSERT(_iContent >= 4);
        if (_iContent == 4)
        {
            EXIT_WITH_HRESULT(E_INVALIDARG);
        }
    }
    else
    {
        hr = _ptracker->Read(pvRead, cbNeeded);
        ON_ERROR_EXIT();

        /* not done reading */
        hr = S_FALSE;
    }

Cleanup:
    delete [] pchOldHeader;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\state\service.cxx ===
/**
 * service.cxx
 * 
 * Service routines for the web server.
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

#include "precomp.h"
#include "stweb.h"

/*
 * Port for state web server requests must be different than 80
 * and not conflict with other server ports.
 */
#define STATEWEB_SERVICE_TYPE   (SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS)
#define WAIT_HINT               100


HRESULT 
StateWebServer::RunAsService()
{
    HRESULT hr = S_OK;
    int     result;

    SERVICE_TABLE_ENTRY st[] = 
    {
        {s_serviceName, ServiceMain},
        {NULL, NULL}
    };

    /*
     * StartServiceCtrlDispatcher runs a loop that terminates when all
     * the services in the process have stopped. Each service runs on
     * its own separate thread that is different from this main thread.
     * 
     * The only other code that runs on this thread is the ServiceCtrlHandler
     * callback of each service. This callback receives notifications from the 
     * Service Control Manager when control requests are made of the service,
     * such as stopping, pausing, continuing, etc.
     */
    result = StartServiceCtrlDispatcher(st);
    ON_ZERO_EXIT_WITH_LAST_ERROR(result);

Cleanup:
    return hr;
}


void WINAPI 
StateWebServer::ServiceCtrlHandler(DWORD dwControl)
{
    s_pstweb->DoServiceCtrlHandler(dwControl);
}


/**
 * This function is the ServiceCtrlHandler callback for the xspstate
 * service. To make the SCM responsive and keep synchronization simple,
 * it simply queues the control request and notifies the main thread for
 * the xspstate service that a new control request is available.
 * 
 * @param dwControl
 */
void    
StateWebServer::DoServiceCtrlHandler(DWORD dwControl)
{
    HRESULT                 hr = S_OK;
    int                     result;
    ServiceControlEvent *   psce;

    if (_bShuttingDown) {
        EXIT();
    }

    if (    dwControl == SERVICE_CONTROL_SHUTDOWN ||
            dwControl == SERVICE_CONTROL_STOP) {
        _bShuttingDown = true;
    }

    psce = new ServiceControlEvent();
    ON_OOM_EXIT(psce);

    psce->_dwControl = dwControl;

    _serviceControlEventListLock.AcquireWriterLock();
    InsertTailList(&_serviceControlEventList, &psce->_serviceControlEventList);
    _serviceControlEventListLock.ReleaseWriterLock();

    result = SetEvent(_eventControl);
    ASSERT(result != 0);

Cleanup:
    return;
}


/**
 * Helper function to set the status of the service.
 * 
 * @param dwCurrentState
 * @param dwWin32ExitCode
 * @param dwWaitHint
 * @return 
 */
void
StateWebServer::SetServiceStatus(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint)
{
    int             result;
    SERVICE_STATUS  serviceStatus;

    _serviceState = dwCurrentState;

    serviceStatus.dwServiceType = STATEWEB_SERVICE_TYPE;
    serviceStatus.dwCurrentState = dwCurrentState;
    serviceStatus.dwControlsAccepted = 
            SERVICE_ACCEPT_STOP |
            SERVICE_ACCEPT_PAUSE_CONTINUE |
            SERVICE_ACCEPT_SHUTDOWN;

    serviceStatus.dwWin32ExitCode = dwWin32ExitCode;
    serviceStatus.dwServiceSpecificExitCode = NO_ERROR;
    serviceStatus.dwCheckPoint = 0;
    serviceStatus.dwWaitHint = dwWaitHint;
    
    ASSERT(_serviceStatus != NULL);    
    result = ::SetServiceStatus(_serviceStatus, &serviceStatus);
    ASSERT(result != 0);    
}



/**
 * The main function of the xspstate service. Delegates to DoServiceMain
 * for easy access to "this".
 * 
 * @param dwNumServicesArgs
 * @param lpServiceArgVectors
 */
void WINAPI 
StateWebServer::ServiceMain(DWORD dwNumServicesArgs, LPWSTR *lpServiceArgVectors)
{
    s_pstweb->DoServiceMain(dwNumServicesArgs, lpServiceArgVectors);
}



/**
 * 
 * This is the main loop for the xspstate service. It runs on its own
 * thread created on its behalf by the Service Control Manager.
 * 
 * This thread first starts the service by creating listening sockets
 * for session state requests. It then simply waits for service control
 * events and acts upon them. It exits when a request is made to 
 * stop the service.
 * 
 * @param dwNumServicesArgs
 * @param lpServiceArgVectors
 */

void
StateWebServer::DoServiceMain(DWORD /* dwNumServicesArgs */, LPWSTR * /*lpServiceArgVectors */)
{
    HRESULT                 hr = S_OK;            
    DWORD                   dwControl;            
    DWORD                   serviceStatePrevious; 
    bool                    fCleanedUp = false;
    bool                    fSetServiceStatus = true;
    ServiceControlEvent *   psce;
    LIST_ENTRY  *           plistentry;

    /*
     * Let the ServiceControlManager know that we've started and register
     * our control event handler.
     */
    _serviceStatus = RegisterServiceCtrlHandler(s_serviceName, ServiceCtrlHandler);
    ON_ZERO_EXIT_WITH_LAST_ERROR(_serviceStatus);

    /*
     * Let the ServiceControlManager know that we're initializing.
     */
    SetServiceStatus(SERVICE_START_PENDING, ERROR_SUCCESS, WAIT_HINT);

    hr = PrepareToRun();
    ON_ERROR_EXIT();
    
    hr = StartListening();
    ON_ERROR_EXIT();
    
    hr = StartSocketTimer();
    ON_ERROR_EXIT();

#if DBG    
    hr = StartSocketTimeoutMonitor();
    ON_ERROR_EXIT();
#endif    

    SetServiceStatus(SERVICE_RUNNING, ERROR_SUCCESS, 0);
    fSetServiceStatus = false;

    for (;;)
    {
        /*
         * Wait for notifications from the ServiceCtrlHandler.
         */
        WaitForSingleObject(_eventControl, INFINITE);
        
        for (;;)
        {
            /*
             * Dequeue control notifications and act upon them.
             */
            _serviceControlEventListLock.AcquireWriterLock();
            plistentry = RemoveHeadList(&_serviceControlEventList);
            _serviceControlEventListLock.ReleaseWriterLock();

            if (plistentry == &_serviceControlEventList)
                break;

            psce = (ServiceControlEvent *) plistentry;
            dwControl = psce->_dwControl;
            delete psce;
            psce = NULL;
            plistentry = NULL;

            serviceStatePrevious = _serviceState;

            ASSERT(serviceStatePrevious == SERVICE_RUNNING ||
                   serviceStatePrevious == SERVICE_PAUSED);

            // Note:
            // For every action that shuts down the server, you have to set
            // _bShuttingDown to true in DoServiceCtrlHandler

            switch (dwControl)
            {
            case SERVICE_CONTROL_SHUTDOWN:
                StopSocketTimer();
#if DBG                
                StopSocketTimeoutMonitor();
#endif
                StopListening();
                WaitForZeroTrackers();
                CleanupAfterRunning();
                fCleanedUp = true;
                EXIT();

            case SERVICE_CONTROL_STOP:
                SetServiceStatus(SERVICE_STOP_PENDING, ERROR_SUCCESS, WAIT_HINT);
                StopSocketTimer();
#if DBG                
                StopSocketTimeoutMonitor();
#endif
                StopListening();
                WaitForZeroTrackers();
                CleanupAfterRunning();
                fCleanedUp = true;
                SetServiceStatus(SERVICE_STOPPED, ERROR_SUCCESS, 0);
                EXIT();

            case SERVICE_CONTROL_PAUSE:
                if (serviceStatePrevious == SERVICE_RUNNING)
                {
                    SetServiceStatus(SERVICE_PAUSE_PENDING, ERROR_SUCCESS, WAIT_HINT);
                    StopSocketTimer();
#if DBG                
                    StopSocketTimeoutMonitor();
#endif
                    StopListening();
                    WaitForZeroTrackers();
                    SetServiceStatus(SERVICE_PAUSED, ERROR_SUCCESS, 0);
                }

                break;

            case SERVICE_CONTROL_CONTINUE:
                if (serviceStatePrevious == SERVICE_PAUSED)
                {
                    SetServiceStatus(SERVICE_CONTINUE_PENDING, ERROR_SUCCESS, WAIT_HINT);
                    do {
                        hr = StartListening();
                        if (hr != S_OK)
                            break;
                            
                        hr = StartSocketTimer();
                        if (hr != S_OK)
                            break;

#if DBG                            
                        hr = StartSocketTimeoutMonitor();
                        if (hr != S_OK)
                            break;
#endif                            
                    } while (0);
                    SetServiceStatus((hr == S_OK) ? SERVICE_RUNNING : SERVICE_PAUSED, hr, 0);
                }

                break;

            case SERVICE_CONTROL_INTERROGATE:
                SetServiceStatus(_serviceState, ERROR_SUCCESS, 0);
                break;

            default:
                ASSERT(!"Shouldn't get here");
                break;   
            }
        }
    }

Cleanup:
    if (hr && fSetServiceStatus)
    {
        SetServiceStatus(SERVICE_STOPPED, hr, 0);
    }
    
    if (!fCleanedUp)
    {
        CleanupAfterRunning();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\state\sources.inc ===
!include $(DNAROOT)\src\xsp\place.inc

!if "$(ASPNET_PRODUCT)" == "redist"
SYNCHRONIZE_BLOCK=1
!endif

TARGETNAME=$(ASPNET_NAME_PREFIX)state
TARGETPATH=$(O)
TARGETTYPE=PROGRAM

UMENTRY=wmain
UMTYPE=console

LINKER_FLAGS=$(LINKER_FLAGS) /LARGEADDRESSAWARE

PRECOMPILED_CXX=1
PRECOMPILED_SHARED_INCLUDE=precomp.h
PRECOMPILED_SHARED_PCH=..\..\inc\$(ASPNET_PRODUCT)\$(O)\precomp.pch

TARGETLIBS=                                     \
        $(SDK_LIB_PATH)\kernel32.lib            \
        $(SDK_LIB_PATH)\mswsock.lib             \
        $(SDK_LIB_PATH)\ole32.lib               \
        $(SDK_LIB_PATH)\oleaut32.lib            \
        $(SDK_LIB_PATH)\user32.lib              \
        $(SDK_LIB_PATH)\uuid.lib                \
        $(SDK_LIB_PATH)\ws2_32.lib              \
        $(URTSDKTARGET)\lib\mscoree.lib         \
        $(XSPBASEDIR)\isapi\$(ASPNET_PRODUCT)\$(O)\$(ASPNET_NAME_PREFIX)isapi.lib   \

LINKLIBS=                                       \
        $(XSPBASEDIR)\inc\$(ASPNET_PRODUCT)\$(O)\precomp.lib      \
        $(XSPBASEDIR)\util\$(ASPNET_PRODUCT)\$(O)\util.lib        \

SOURCES=\
        ..\stweb.rc        \
        ..\blockmem.cxx    \
        ..\readbuf.cxx     \
        ..\service.cxx     \
        ..\stsrv.cxx       \
        ..\stweb.cxx       \
        ..\stwnd.cxx       \
        ..\submit.cxx      \
        ..\tracker.cxx     \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\state\stwnd.cxx ===
/**
 * stwnd.cxx
 * 
 * NDirect interface for state web.
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */


#include "precomp.h"
#include "stweb.h"

extern "C" __declspec(dllexport)
void __stdcall 
STWNDCloseConnection(Tracker * ptracker)
{
    ptracker->CloseConnection();
}


extern "C" __declspec(dllexport)
void __stdcall 
STWNDDeleteStateItem(StateItem *psi)
{
    psi->Release();
}


extern "C" __declspec(dllexport)
void __stdcall 
STWNDEndOfRequest(Tracker *ptracker)
{
    ptracker->EndOfRequest();
}

extern "C" __declspec(dllexport)
void __stdcall 
STWNDGetLocalAddress(Tracker *ptracker, char * buf)
{
    ptracker->GetLocalAddress(buf);
}

extern "C" __declspec(dllexport)
int __stdcall 
STWNDGetLocalPort(Tracker *ptracker)
{
    return ptracker->GetLocalPort();
}

extern "C" __declspec(dllexport)
void __stdcall 
STWNDGetRemoteAddress(Tracker *ptracker, char * buf)
{
    ptracker->GetRemoteAddress(buf);
}

extern "C" __declspec(dllexport)
int __stdcall 
STWNDGetRemotePort(Tracker *ptracker)
{
    return ptracker->GetRemotePort();
}

extern "C" __declspec(dllexport)
BOOL __stdcall 
STWNDIsClientConnected(Tracker *ptracker)
{
    return ptracker->IsClientConnected();
}

extern "C" __declspec(dllexport)
void __stdcall 
STWNDSendResponse(
        Tracker *   ptracker, 
        WCHAR *     status, 
        int         statusLength,  
        WCHAR *     headers, 
        int         headersLength,  
        StateItem * psi)
{
    ptracker->SendResponse(status, statusLength, headers, headersLength, psi);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\state\stsrv.cxx ===
/**
 * stsrv.cxx
 * 
 * Starts and stops the web server.
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

#include "precomp.h"
#include "stweb.h"
#include "event.h"

/*
 * We define our own LISTEN_BACKLOG instead of using SOMAXCONN, 
 * since we are including winsock.h instead of winsock2.h, but we
 * want the value in winsock2.h.
 */
#define LISTEN_BACKLOG 0x7fffffff 

/*
 * Number of Trackers to keep listening.
 */
#define NUM_LISTENERS_PER_CPU   (3)

/*
 * Timeout to wait for trackers to complete their work before
 * listening is stopped.
 */
#define WAIT_FOR_ZERO_TRACKERS_TIMEOUT  5000

HRESULT
StateWebServer::StartListening()
{
    HRESULT     hr = S_OK;
    int         result, i, cCpu;
    SOCKADDR_IN addr;
    SYSTEM_INFO sysinfo;

    if (_bListening)
        return S_OK;

    ASSERT(_listenSocket == INVALID_SOCKET);

    // See if we allow remote connection
    hr = GetAllowRemoteConnectionFromReg();
    ON_ERROR_EXIT();

    /*
     * Get the no. of CPUs
     */
    GetSystemInfo(&sysinfo);
    cCpu = sysinfo.dwNumberOfProcessors;
    ASSERT(cCpu > 0);

    /*
     * Create the listening socket.    
     */
    _listenSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, 
                               NULL, 0, WSA_FLAG_OVERLAPPED);

    if (_listenSocket == INVALID_SOCKET)
        EXIT_WITH_LAST_SOCKET_ERROR();

    /*
     * Set properties that will be inherited by sockets in AcceptEx.
     */

    BOOL nodelay = TRUE;
    result = setsockopt(_listenSocket, IPPROTO_TCP, TCP_NODELAY, (char *) &nodelay, sizeof(nodelay));
    ON_SOCKET_ERROR_EXIT(result);

    // The following may cause bind() to fail if running as a non-Admin account, depending on the OS
    // version and SP's installed.
    BOOL val = TRUE;
    setsockopt(_listenSocket, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (char*) &val, sizeof(val));
    
    /*
     * Associate it with the completion port.
     */
    hr = AttachHandleToThreadPool((HANDLE)_listenSocket);
    ON_ERROR_EXIT();

    /*
     *  it to the wildcard IP address.    
     */
    addr.sin_family = AF_INET;
    addr.sin_port = htons( _port );
    addr.sin_addr.s_addr = INADDR_ANY;


    result = bind(_listenSocket, (SOCKADDR *)&addr, sizeof(addr));
    if (result == SOCKET_ERROR && WSAGetLastError() == WSAEACCES) {
        TRACE(TAG_STATE_SERVER, L"Have to turn off SO_EXCLUSIVEADDRUSE");
        
        // Since we are setting SO_EXCLUSIVEADDRUSE to TRUE, we may get this error
        // if the OS is W2K and are not running as Admin.  In this case,
        // we have to turn this security feature off.
        val = FALSE;
        setsockopt(_listenSocket, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (char*) &val, sizeof(val));
        
        result = bind(_listenSocket, (SOCKADDR *)&addr, sizeof(addr));
    }
    ON_SOCKET_ERROR_EXIT(result);

    /*
     * Put it into listen mode.    
     */
    result = listen(_listenSocket, LISTEN_BACKLOG);
    ON_SOCKET_ERROR_EXIT(result);

    _bListening = true;

    for (i = NUM_LISTENERS_PER_CPU * cCpu; i > 0; i--)
    {
        hr = AcceptNewConnection();
        ON_ERROR_EXIT();
    }

    XspLogEvent(IDS_EVENTLOG_STATE_SERVER_START_LISTENING, L"%d", NUM_LISTENERS_PER_CPU * cCpu);

Cleanup:
    if (hr)
    {
        StopListening();
    }

    return hr;
}


void
StateWebServer::StopListening()
{
    HRESULT hr = S_OK;
    int     result;

    if (!_bListening)
        return;

    if (_listenSocket != INVALID_SOCKET)
    {
        /*
         * This call to closesocket will cause the outstanding
         * listeners to post completions, which will in turn
         * cause their deletion.
         */
        result = closesocket(_listenSocket);
        ON_SOCKET_ERROR_CONTINUE(result);

        _listenSocket = INVALID_SOCKET;
    }

    _bListening = false;
    
    XspLogEvent(IDS_EVENTLOG_STATE_SERVER_STOP_LISTENING, NULL);

}


HRESULT
StateWebServer::WaitForZeroTrackers()
{
    HRESULT hr = S_OK;
    int     err;

    Tracker::SignalZeroTrackers();

    err = WaitForSingleObject(Tracker::EventZeroTrackers(), WAIT_FOR_ZERO_TRACKERS_TIMEOUT);
    if (err == WAIT_FAILED)
    {
        EXIT_WITH_LAST_ERROR();
    }
    else if (err == WAIT_TIMEOUT)
    {
        EXIT_WITH_WIN32_ERROR(WAIT_TIMEOUT);
    }

    ASSERT(err == WAIT_OBJECT_0 || err == ERROR_SUCCESS);

Cleanup:
    return hr;    
}


HRESULT
StateWebServer::AcceptNewConnection()
{
    HRESULT     hr = S_OK;
    Tracker *   ptracker = NULL;

    if (!_bListening)
        return S_OK;

    /*
     * Create the socket.
     */
    ptracker = new Tracker();
    ON_OOM_EXIT(ptracker);

    hr = ptracker->Init(TRUE);
    ON_ERROR_EXIT();

    hr = ptracker->Listen(_listenSocket);
    ON_ERROR_EXIT();

Cleanup:
    if (hr)
    {
        ClearInterface(&ptracker);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\state\stweb.cxx ===
/**
 * stweb.cxx
 * 
 * Entrypoint to state web server (wmain),
 * argument parsing, and RunAsExe.
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

#include "precomp.h"
#include "stweb.h"
#include "event.h"
#include "perfcounters.h"

#define DEFAULT_HTTP_PORT       42424

StateWebServer *    StateWebServer::s_pstweb;
WCHAR               StateWebServer::s_serviceName[] = STATE_SERVICE_NAME_L;
WCHAR               StateWebServer::s_serviceKeyNameParameters[] = REGPATH_STATE_SERVER_PARAMETERS_KEY_L;
WCHAR               StateWebServer::s_serviceValueNamePort[] = REGVAL_STATEPORT;

DEFINE_DBG_COMPONENT(STATE_MODULE_FULL_NAME_L);

extern "C"
int
__cdecl
wmain(int argc, WCHAR * argv[])
{
    HRESULT             hr = S_OK;
    StateWebServer *    pstweb = NULL;

    hr = InitializeLibrary();
    ON_ERROR_EXIT();

    pstweb = new StateWebServer();
    ON_OOM_EXIT(pstweb);

    hr = pstweb->main(argc, argv);
    ON_ERROR_EXIT();

Cleanup:
    delete pstweb;
    return hr;
}


HRESULT
StateWebServer::main(int argc, WCHAR * argv[])
{
    HRESULT             hr = S_OK;

    hr = ParseArgs(argc, argv, &_action);
    ON_ERROR_EXIT();

    switch (_action)
    {
    case ACTION_RUN_AS_EXE:
        hr = RunAsExe();
        break;

    case ACTION_RUN_AS_SERVICE:
        hr = RunAsService();
        break;
        
    case ACTION_NOACTION:
    default:
        ASSERT(!"Shouldn't get here");
        hr = E_FAIL;
    }

    ON_ERROR_EXIT();

Cleanup:
    if (hr)
    {
        wprintf(STATE_MODULE_BASE_NAME_L L": exiting with error code 0x%.8x.\n", hr);
    }

    return hr;
}


StateWebServer::StateWebServer() 
    : _serviceControlEventListLock("StateWebServer._serviceControlEventListLock")
{
    ASSERT(s_pstweb == NULL);
    s_pstweb = this;
    _listenSocket = INVALID_SOCKET;
    _eventControl = INVALID_HANDLE_VALUE;
    _serviceState = SERVICE_STOPPED;
    InitializeListHead(&_serviceControlEventList);
    _lSocketTimeoutValue = STATE_SOCKET_DEFAULT_TIMEOUT;
    _port = DEFAULT_HTTP_PORT;
    _bShuttingDown = false;
}


HRESULT
StateWebServer::ParseArgs(int argc, WCHAR * argv[], StateWebServer::MainAction * paction)
{
    HRESULT hr = S_OK;

    /*
     * Parse arguments to determine action. No arguments means
     * run as service.
     */
    *paction = ACTION_RUN_AS_SERVICE;
    if (argc == 1)
        EXIT();

#if DBG
    if (argc > 2)
        EXIT_WITH_HRESULT(E_FAIL);

    switch (argv[1][0])
    {
    case L'-':
    case L'/':
        break;

    default:
        EXIT_WITH_HRESULT(E_FAIL);
    }

    switch (argv[1][1])
    {
    case L'e':
    case L'E': *paction = ACTION_RUN_AS_EXE; break;

    default:
        EXIT_WITH_HRESULT(E_INVALIDARG);
    }

    if (argv[1][2] != L'\0')
        EXIT_WITH_HRESULT(E_INVALIDARG);
#else
    EXIT_WITH_HRESULT(E_INVALIDARG);
#endif

Cleanup:
    if (hr)
    {
        PrintUsage();
    }

    return hr;
}


void
StateWebServer::PrintUsage()
{
#if DBG    
    wprintf(STATE_MODULE_BASE_NAME_L L": Invalid arguments to " STATE_MODULE_BASE_NAME_L L"\n");
    wprintf(STATE_MODULE_BASE_NAME_L L" usage: " STATE_MODULE_BASE_NAME_L L" [-e]");
#else
    wprintf(STATE_MODULE_BASE_NAME_L L": it can run only as a service\n");
#endif
}


/*
 *  The socket expiry thread will run this function. This function will wait on a timer,
 *  and when done, call a function to check all the pending TRACKER and expire those
 *  that have timed out.
 */
HRESULT
StateWebServer::RunSocketExpiry()
{
    HRESULT             hr = S_OK;
    bool                ret;
    LARGE_INTEGER       liDueTime;
    int                 cFailed = 0;

    while(1) {

        liDueTime.QuadPart = -1 * (LONGLONG)SocketTimeout() * TICKS_PER_SEC;
    
        ret = SetWaitableTimer(
                _hSocketTimer,
                &liDueTime,
                0,
                NULL,
                NULL,
                FALSE);
        ON_ZERO_EXIT_WITH_LAST_ERROR(ret);

        // Wait for the timer.

        if (WaitForSingleObject(_hSocketTimer, INFINITE) != WAIT_OBJECT_0) {
            if (++cFailed == 3) {
                // If we have failed 3 times in a row, log an error and exit
                XspLogEvent( IDS_EVENTLOG_STATE_SERVER_SOCKET_EXPIRY_ERROR, L"0x%08x",
                            GetLastWin32Error());
                EXIT_WITH_LAST_ERROR();
            }
            else {
                Sleep(3000);
                continue;
            }
        }

        cFailed = 0;

        if (_bTimerStopped) {
            TRACE1(TAG_STATE_SERVER, L"## Timer Thread exits (%d)##", GetTickCount());
            break;
        }

        // Close expired Trackers
        Tracker::FlushExpiredTrackers();
    }

Cleanup:    
    return hr;
}


DWORD WINAPI
SocketExpiryThreadFunc(LPVOID lpParam) {
    StateWebServer *    pServer = StateWebServer::Server();
    return pServer->RunSocketExpiry();
}


/**
 *  Called during shutdown or service pause to wake up the potentially sleeping
 *  Expiry thread, and signals it to exit.
 **/
HRESULT
StateWebServer::StopSocketTimer()
{
    HRESULT         hr = S_OK;
    LARGE_INTEGER   liDueTime;
    bool            ret;
    DWORD           dwRet;

    if (_bTimerStopped)
        EXIT();

    ASSERT(_hSocketTimer != NULL);
    ASSERT(_hTimerThread != NULL);

    TRACE1(TAG_STATE_SERVER, L"## Timer being stopped... (%d)##", GetTickCount());
    
    _bTimerStopped = TRUE;

    liDueTime.QuadPart = -1;  // 100 nanoseconds relative to now

    if (_hSocketTimer == NULL)
        EXIT();

    // Set a small timeout value to wake up the expiry thread
    ret = SetWaitableTimer(
            _hSocketTimer,
            &liDueTime,
            0,
            NULL,
            NULL,
            FALSE);
    ON_ZERO_EXIT_WITH_LAST_ERROR(ret);

    dwRet = WaitForSingleObject(_hTimerThread, INFINITE);
    if (dwRet != WAIT_OBJECT_0) {
        EXIT_WITH_LAST_ERROR();
    }

    CloseHandle(_hTimerThread);
                        
    TRACE1(TAG_STATE_SERVER, L"## Timer stopped (%d)##", GetTickCount());
    
Cleanup:
    return hr;
}


/**
 *  Read the socket timeout value from the registry. If error, set the
 *  socket timeout value to default value.
 **/
HRESULT
StateWebServer::GetSocketTimeoutValueFromReg() {
    HRESULT hr = S_OK;
    HKEY    key = NULL;
    int     err;
    LONG    lDueTime;
    DWORD   size;

    // Read the timer value        
    err = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        ServiceKeyNameParameters(),
        0,
        KEY_READ,
        &key);

    ON_WIN32_ERROR_EXIT(err);

    size = sizeof(LONG);
    err = RegQueryValueEx(key, REGVAL_STATESOCKETTIMEOUT, NULL, NULL, (BYTE *)&lDueTime, &size);
    ON_WIN32_ERROR_EXIT(err);

    // Ignore all invalid values
    if (lDueTime <= 0 || lDueTime > MAXLONG) {
        lDueTime = STATE_SOCKET_DEFAULT_TIMEOUT;
    }
    
        _lSocketTimeoutValue = lDueTime;    
    
Cleanup:    
    if (key)
        RegCloseKey(key);
    if (hr) {
        // Use default value if error
        _lSocketTimeoutValue = STATE_SOCKET_DEFAULT_TIMEOUT;    
    }
    
    return hr;
}


#if DBG
/*
 *  The socket timeout monitor thread will run this function. This function 
 *  waits on any change in the Parameters registry key, re-read the socket
 *  timeout value and reset the socket expiry timer.
 */
HRESULT
StateWebServer::RunSocketTimeoutMonitor() {
    HKEY    key = NULL;
    long    result = ERROR_SUCCESS;
    HRESULT hr = 0;
    HANDLE  event;
    LARGE_INTEGER   liDueTime;
    bool    ret;
    
    event = CreateEvent(NULL, FALSE, FALSE, FALSE);
    ON_ZERO_EXIT_WITH_LAST_ERROR(event);

    for (;;)
    {
        result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                    ServiceKeyNameParameters(),
                    0, KEY_READ, &key);
        ON_WIN32_ERROR_EXIT(result);

        VERIFY(RegNotifyChangeKeyValue(
            key,
            TRUE,
            REG_NOTIFY_CHANGE_NAME       |  
            REG_NOTIFY_CHANGE_LAST_SET,
            event,
            TRUE) == ERROR_SUCCESS);

        VERIFY(WaitForSingleObject(event, INFINITE) != WAIT_FAILED);
        VERIFY(RegCloseKey(key) == ERROR_SUCCESS);

        hr = GetSocketTimeoutValueFromReg();
        ON_ERROR_CONTINUE();

        liDueTime.QuadPart = -1 * (LONGLONG)SocketTimeout() * TICKS_PER_SEC;

        ASSERT(_hSocketTimer != NULL);
        
        ret = SetWaitableTimer(
                _hSocketTimer,
                &liDueTime,
                0,
                NULL,
                NULL,
                FALSE);
        ON_ZERO_EXIT_WITH_LAST_ERROR(ret);
    }
    
Cleanup:
    return hr;
}


DWORD WINAPI
TimeoutMonitorThreadFunc(LPVOID lpParam) {
    StateWebServer *    pServer = StateWebServer::Server();

    return pServer->RunSocketTimeoutMonitor();
}


HRESULT        
StateWebServer::StartSocketTimeoutMonitor()
{
    // Timeout monitor is for debug build only
    
    HRESULT     hr = S_OK;
    
    // Create the thread that'll monitor the socket timeout value
    _hTimeoutMonitorThread = CreateThread(NULL, 
                                0, 
                                TimeoutMonitorThreadFunc,
                                NULL,
                                0,
                                NULL);
    ON_ZERO_EXIT_WITH_LAST_ERROR(_hTimeoutMonitorThread);
    
Cleanup:    
    return hr;
}


void        
StateWebServer::StopSocketTimeoutMonitor()
{
    // Timeout monitor is for debug build only
    if (_hTimeoutMonitorThread != NULL)
    {
        TerminateThread(_hTimeoutMonitorThread, 0);
        CloseHandle(_hTimeoutMonitorThread);
        _hTimeoutMonitorThread = NULL;
    }
}
#endif    


HRESULT
StateWebServer::StartSocketTimer()
{
    HRESULT hr = S_OK;
    
    TRACE(TAG_STATE_SERVER, L"## Timer being started... ##");
    
    ASSERT(_hSocketTimer != NULL);
    
    _bTimerStopped = FALSE;

    GetSocketTimeoutValueFromReg();

    // Then create the thread that'll set the periodic timer
    _hTimerThread = CreateThread(NULL, 
                                0, 
                                SocketExpiryThreadFunc,
                                NULL,
                                0,
                                NULL);
    ON_ZERO_EXIT_WITH_LAST_ERROR(_hTimerThread);

Cleanup:    
    TRACE(TAG_STATE_SERVER, L"## Timer started... ##");
    return hr;
}


/**
 *  Read the allow remote connection value from the registry.
 **/
HRESULT
StateWebServer::GetAllowRemoteConnectionFromReg() {
    HRESULT hr = S_OK;
    HKEY    key = NULL;
    int     err;
    DWORD   allow;
    DWORD   size;

    // Read the timer value        
    err = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        ServiceKeyNameParameters(),
        0,
        KEY_READ,
        &key);

    ON_WIN32_ERROR_EXIT(err);

    size = sizeof(DWORD);
    err = RegQueryValueEx(key, REGVAL_STATEALLOWREMOTE, NULL, NULL, (BYTE *)&allow, &size);
    ON_WIN32_ERROR_EXIT(err);

    _bAllowRemote = (allow != 0);
    
Cleanup:    
    if (key)
        RegCloseKey(key);
    
    if (hr) {
        // Use default value if error
        _bAllowRemote = TRUE;

        // Ignore error
        hr = S_OK;
    }
    
    return hr;
}


HRESULT
StateWebServer::PrepareToRun()
{
    HRESULT hr = S_OK;
    int     err;
    WSADATA wsaData;
    HANDLE  eventControl;
    HKEY    key = NULL;
    DWORD   port;
    DWORD   regtype;
    DWORD   cbData;

    hr = BlockMem::Init();
    ON_ERROR_EXIT();

    err = WSAStartup(0x0202, &wsaData);
    ON_WIN32_ERROR_EXIT(err);

    _bWinSockInitialized = true;

    eventControl = CreateEvent(NULL, FALSE, FALSE, NULL);
    ON_ZERO_EXIT_WITH_LAST_ERROR(_eventControl);
    _eventControl = eventControl;

    _port = DEFAULT_HTTP_PORT;

    err = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        s_serviceKeyNameParameters,
        0,
        KEY_READ,
        &key);

    ON_WIN32_ERROR_CONTINUE(err);
    if (err == ERROR_SUCCESS) {
        regtype = REG_DWORD;
        cbData = sizeof(port);
        err = RegQueryValueEx(key, s_serviceValueNamePort, NULL, &regtype, (BYTE *)&port, &cbData);
        ON_WIN32_ERROR_CONTINUE(err);

        if (err == ERROR_SUCCESS && 0 < port && port <= USHRT_MAX) {
            _port = (u_short) port;
        }
    }

    hr = Tracker::staticInit();
    ON_ERROR_EXIT();

    _hSocketTimer = CreateWaitableTimer(NULL, FALSE, NULL);
    ON_ZERO_EXIT_WITH_LAST_ERROR(_hSocketTimer);

    hr = PerfCounterInitialize();
    ON_ERROR_CONTINUE(); hr = S_OK;

Cleanup:
    if (key)
    {
#if DBG
        LONG result = 
#endif

        RegCloseKey(key);

        ASSERT(result == ERROR_SUCCESS);
    }

    return hr;
}


void
StateWebServer::CleanupAfterRunning()
{
    int result;

    // This function could be called because of an error in DoServiceMain
    // In this case, setting _bShuttingDown in here can avoid
    // DoServiceCtrlHandler from using _eventControl.  Although there is still
    // a very small chance that DoServiceCtrlHandler is called before this
    // line is called, but the chance is very small and the problem
    // is not disastrous.
    _bShuttingDown = true;

    Tracker::staticCleanup();

    if (_eventControl != INVALID_HANDLE_VALUE)
    {
        result = CloseHandle(_eventControl);
        ASSERT(result != 0);
    }

    if (_bWinSockInitialized)
    {
        result = WSACleanup();
        ASSERT(result == 0);
    }

    if (_hSocketTimer)
    {
        result = CloseHandle(_hSocketTimer);
        ASSERT(result != 0);
    }
}


BOOL WINAPI 
StateWebServer::ConsoleCtrlHandler(DWORD /* dwCtrlType */)
{
    int result;

    if (s_pstweb->_eventControl != INVALID_HANDLE_VALUE)
    {
        result = SetEvent(s_pstweb->_eventControl);
        ASSERT(result != 0);
    }

    return TRUE;
}


HRESULT
StateWebServer::RunAsExe()
{
    HRESULT hr = S_OK;
    int     result;
    int     err;

    hr = PrepareToRun();
    ON_ERROR_EXIT();

    result = SetConsoleCtrlHandler(&ConsoleCtrlHandler, TRUE);
    ON_ZERO_EXIT_WITH_LAST_ERROR(result);

    hr = StartListening();
    ON_ERROR_EXIT();

    hr = StartSocketTimer();
    ON_ERROR_EXIT();

#if DBG
    hr = StartSocketTimeoutMonitor();
    ON_ERROR_EXIT();
#endif    

    err = WaitForSingleObject(_eventControl, INFINITE);
    if (err == WAIT_FAILED)
        EXIT_WITH_LAST_ERROR();

    StopListening();
    hr = WaitForZeroTrackers();
    ON_ERROR_CONTINUE();

Cleanup:
    CleanupAfterRunning();    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\state\submit.cxx ===
/**
 * submit.cxx
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

#include "precomp.h"
#include "names.h"
#include "stweb.h"
#include <mscoree.h>

HRESULT
Tracker::GetManagedRuntime(xspmrt::_StateRuntime ** ppManagedRuntime)
{
    HRESULT hr = S_OK;

    if (s_pManagedRuntime == NULL)
    {
        s_lockManagedRuntime.AcquireWriterLock();
        if (s_pManagedRuntime == NULL)
        {
            *ppManagedRuntime = NULL;
            hr = CreateManagedRuntime();
        }

        s_lockManagedRuntime.ReleaseWriterLock();
        ON_ERROR_EXIT();
    }

    *ppManagedRuntime = s_pManagedRuntime;

Cleanup:
    return hr;
}


/**
 * Static method to connect to the managed runtime code
 */
HRESULT
Tracker::CreateManagedRuntime()
{
    HRESULT     hr = S_OK;
    BOOL        needCoUninit = FALSE;

    ASSERT(s_pManagedRuntime == NULL);

    // CoInit
    hr = EnsureCoInitialized(&needCoUninit);
    ON_ERROR_EXIT();

    // CoCreate
    hr = ClrCreateManagedInstance(
            L"System.Web.SessionState.StateRuntime,System.Web,version=" VER_ASSEMBLYVERSION_STR_L,
            __uuidof(xspmrt::_StateRuntime),  /* IID */
            (LPVOID*)&s_pManagedRuntime);
    ON_ERROR_EXIT();

Cleanup:
    if (needCoUninit)
        CoUninitialize();

    return hr;
}

/**
 * Static method to disconnect from the managed runtime code
 */
HRESULT
Tracker::DeleteManagedRuntime()
{
    HRESULT hr = S_OK;
    BOOL    needCoUninit = FALSE;
    BOOL    locked = FALSE;

    if (s_pManagedRuntime != NULL)
    {
        s_lockManagedRuntime.AcquireWriterLock();
        locked = TRUE;
        if (s_pManagedRuntime != NULL)
        {
            hr = EnsureCoInitialized(&needCoUninit);
            ON_ERROR_EXIT();
    
            hr = s_pManagedRuntime->StopProcessing();
            ON_ERROR_EXIT();
        }
    }

Cleanup:
    ClearInterface(&s_pManagedRuntime);

    if (needCoUninit)
        CoUninitialize();

    if (locked)
    {
        s_lockManagedRuntime.ReleaseWriterLock();
    }

    return hr;
}

/**
 * Static method to report error in case the code never made it to
 * the managed runtime.
 */
void
Tracker::ReportHttpError()
{
#define STR_ERROR_STATUS  L"500 Internal Server Error\r\n"
#define STR_ERROR_HEADERS L"Content-Length: 0\r\n\r\n"

    SendResponse(
            STR_ERROR_STATUS,
            ARRAY_SIZE(STR_ERROR_STATUS) - 1,
            STR_ERROR_HEADERS,
            ARRAY_SIZE(STR_ERROR_HEADERS) - 1,
            NULL);
}


HRESULT
Tracker::SubmitRequest()
{
    HRESULT     hr = S_OK;
    StateItem   *psi = NULL;
    int         contentLength;
    xspmrt::_StateRuntime * pManagedRuntime = NULL;

    contentLength = _pReadBuffer->GetContentLength();
    if (contentLength > 0)
    {
        psi = _pReadBuffer->DetachStateItem();
        contentLength = sizeof(void *);
    }

    hr = GetManagedRuntime(&pManagedRuntime);
    ON_ERROR_EXIT();

    hr = pManagedRuntime->ProcessRequest(
        (INT_PTR)this,
        _pReadBuffer->GetVerb(),
        (INT_PTR)_pReadBuffer->GetUri(),
        _pReadBuffer->GetExclusive(),
        _pReadBuffer->GetTimeout(),
        _pReadBuffer->GetLockCookieExists(),
        _pReadBuffer->GetLockCookie(),
        contentLength,
        (INT_PTR)psi);

    ON_ERROR_EXIT();

    /*
     * We have successfully completed the request.
     */

    /*
     * Keep the StateItem created above.
     * 
     * CONSIDER (adams 12/5/99): This is not the right place to check for an error
     * adding the StateItem to the cache. If the item was successfully added to the 
     * cache but an error subsequently occurred, causing 
     * s_pManagedRuntime->ProcessRequest to return failure, then the item 
     * will be erroneously released.
     */
    psi = NULL;

    /*
     * End the request if managed code failed to do so.
     */
    EndOfRequest();

    /*
     * We are done with the request. Release the reference matching the
     * reference used to create this Tracker.
     */
    Release();

Cleanup:
    if (psi)
    {
        psi->Release();
    }

    if (hr)
    {
        /*
         * Failure means it didn't have a chance to cleanup the request
         * in the managed code - need to report error and end the request.
         */
        ReportHttpError();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\state\tracker.cxx ===
/**
 * tracker
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

#include "precomp.h"
#include "stweb.h"
#include "ary.h"
#include "event.h"

#define FIX_RESPONSE 0

long               StateItem::s_cStateItems;

TrackerList        Tracker::s_TrackerList;
TrackerList        Tracker::s_TrackerListenerList;
long               Tracker::s_cTrackers;
HANDLE             Tracker::s_eventZeroTrackers = INVALID_HANDLE_VALUE;
bool               Tracker::s_bSignalZeroTrackers;
xspmrt::_StateRuntime * Tracker::s_pManagedRuntime;
CReadWriteSpinLock Tracker::s_lockManagedRuntime("Tracker::s_lockManagedRuntime");  


RefCount::RefCount()
{
    _refs = 1;
}

RefCount::~RefCount()
{
}

STDMETHODIMP
RefCount::QueryInterface(
    REFIID iid, 
    void **ppvObj)
{
    if (iid == IID_IUnknown)
    {
        *ppvObj = this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
RefCount::AddRef() {
    return InterlockedIncrement(&_refs);
}

STDMETHODIMP_(ULONG)
RefCount::Release() {
    long r = InterlockedDecrement(&_refs);

    if (r == 0)
    {
        delete this;
        return 0;
    }

    return r;
}

TrackerCompletion::TrackerCompletion(Tracker * pTracker)
{
    _pTracker = pTracker;
    _pTracker->AddRef();
}


TrackerCompletion::~TrackerCompletion()
{
    ReleaseInterface(_pTracker);
}


STDMETHODIMP
TrackerCompletion::ProcessCompletion(
        HRESULT hrErr, int numBytes, LPOVERLAPPED pOverlapped)
{
    HRESULT hr;
     
    hr = _pTracker->ProcessCompletion(hrErr, numBytes, pOverlapped);
    Release();
    return hr;
}


StateItem *
StateItem::Create(int length) {
    HRESULT hr = S_OK;
    StateItem * psi;

    psi = (StateItem *) BlockMem::Alloc(sizeof(StateItem) + length);
    ON_OOM_EXIT(psi);

    psi->_refs = 1;
    psi->_length = length;

    InterlockedIncrement(&s_cStateItems);

Cleanup:
    return psi;
}


void
StateItem::Free(StateItem * psi) {
    BlockMem::Free(psi);
    InterlockedDecrement(&s_cStateItems);
}

ULONG
StateItem::AddRef() {
    return InterlockedIncrement(&_refs);
}

ULONG
StateItem::Release() {
    long r = InterlockedDecrement(&_refs);

    if (r == 0)
    {
        Free(this);
        return 0;
    }

    return r;
}

HRESULT  
Tracker::staticInit() {
    HRESULT hr = S_OK;
    HANDLE  eventZeroTrackers;

    eventZeroTrackers = CreateEvent(NULL, FALSE, FALSE, NULL);
    ON_ZERO_EXIT_WITH_LAST_ERROR(s_eventZeroTrackers);
    s_eventZeroTrackers = eventZeroTrackers;

Cleanup:
    return hr;
}

void
Tracker::staticCleanup() {
    HRESULT hr = S_OK;

    hr = DeleteManagedRuntime();
    ON_ERROR_CONTINUE();
}

Tracker::Tracker() {
    InterlockedIncrement(&s_cTrackers);

    _acceptedSocket = INVALID_SOCKET;
    _iTrackerList = -1;
}

HRESULT
Tracker::Init(bool fListener) {
    HRESULT hr;
    
    _bListener = fListener;

    // If a Tracker is a listener it will be stored in s_TrackerListenerList,
    // while non-listener will be stored in s_TrackerList. By putting them
    // in a separate list, the listeners, which can potentially stay in the 
    // list for a long period if no new connection arrives, will not prevent
    // s_TrackerList from shrinking if the # of non-listening Trackers are
    // dropping.
    //
    // Please note that when a Tracker is changed from a listener to a
    // non-listener (see ProcessListening), it will be moved from
    // s_TrackerListenerList to s_TrackerList.
    
    if (fListener) {
        hr = s_TrackerListenerList.AddEntry(this, &_iTrackerList);
    }
    else {
        hr = s_TrackerList.AddEntry(this, &_iTrackerList);
    }
    ON_ERROR_EXIT();
    
Cleanup:
    return hr;
}


Tracker::~Tracker() {
    HRESULT hr = S_OK;
    int     result;

    LogError();

    if (_iTrackerList != -1) {
        if (_bListener) {
#if DBG
            Tracker *pTracker = 
#endif            
            s_TrackerListenerList.RemoveEntry(_iTrackerList);
            ASSERT(pTracker == this);
        }
        else {
#if DBG
            Tracker *pTracker = 
#endif            
            s_TrackerList.RemoveEntry(_iTrackerList);
            ASSERT(pTracker == this);
        }
    }
    
    delete [] _pchProcessErrorFuncList;

    if (_acceptedSocket != INVALID_SOCKET) {
        result = closesocket(_acceptedSocket);
        ON_SOCKET_ERROR_CONTINUE(result);
    }

    delete _pReadBuffer;

    delete [] _wsabuf[0].buf;
    if (_psi) {
        _psi->Release();
    }

    result = InterlockedDecrement(&s_cTrackers);
    if (result == 0 && s_bSignalZeroTrackers) {
        s_bSignalZeroTrackers = false;
        result = SetEvent(s_eventZeroTrackers);
        ASSERT(result != 0);
    }

}


void
Tracker::SignalZeroTrackers() {
    int result;

    s_bSignalZeroTrackers = true;
    if (s_cTrackers == 0) {
        s_bSignalZeroTrackers = false;
        result = SetEvent(s_eventZeroTrackers);
        ASSERT(result != 0);
    }
}



HRESULT
Tracker::Listen(SOCKET listenSocket) {
    HRESULT             hr = S_OK;
    int                 result;
    DWORD               byteCount = 0;
    TrackerCompletion * pCompletion = NULL;

    ASSERT(_acceptedSocket == INVALID_SOCKET);

    /*
     * Create accept socket.
     */
    _acceptedSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, 
                               NULL, 0, WSA_FLAG_OVERLAPPED);
    if (_acceptedSocket == INVALID_SOCKET) 
        EXIT_WITH_LAST_SOCKET_ERROR();

    /*
     * Associate it with the completion port.
     */
    hr = AttachHandleToThreadPool((HANDLE)_acceptedSocket);
    ON_ERROR_EXIT();

    _pmfnProcessCompletion = &Tracker::ProcessListening;

    pCompletion = new TrackerCompletion(this);
    ON_OOM_EXIT(pCompletion);

    pCompletion->AddRef();
    
    /*
     * Issue the accept/recv/etc call.
     */
    result = AcceptEx(
                 listenSocket,              // sListenSocket
                 _acceptedSocket,           // sAcceptSocket
                 _addrInfo._bufAddress,     // lpOutputBuffer
                 0,                         // dwReceiveDataLength
                 ADDRESS_LENGTH,            // dwLocalAddressLength
                 ADDRESS_LENGTH,            // dwRemoteAddressLength
                 &byteCount,                // lpdwBytesReceived
                 pCompletion->Overlapped()  // lpOverlapped
                 );

    if (result == FALSE) {
        hr = GetLastWin32Error();
        if (hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING)) {
            hr = S_OK;
        }
        else {
            pCompletion->Release();
            _pmfnProcessCompletion = NULL;
            EXIT();
        }
    }

Cleanup:
    ReleaseInterface(pCompletion);
    RecordProcessError(hr, L"Listen");
    return hr;
}


HRESULT
Tracker::ProcessCompletion(HRESULT hrErr, int numBytes, LPOVERLAPPED) {
    HRESULT                 hr = S_OK;
    pmfnProcessCompletion   pmfn;

    ASSERT(_iTrackerList != -1);

    // We've set an expiry if we're not a Listener
    if (!_bListener) {
        
        // The timer might have expired us already.  If that's the case, 
        // SetNoExpire will return FALSE, and the timer thread 
        // is on its way to close the socket.
        
        if (s_TrackerList.SetNoExpire(_iTrackerList) != TRUE) {
            // Release because the timer has expired and closed
            // the socket already
            hr = HRESULT_FROM_WIN32(ERROR_TIMEOUT);
            RecordProcessError(hr, L"ProcessCompletion");

            // ProcessWriting will not release the tracker's ref count            
            if (_pmfnProcessCompletion != &Tracker::ProcessWriting) {
                Release();
            }
                
            ON_ERROR_EXIT();
        }
    }

    // (adams) 6/26/00: Debugging code to catch ASURT 37649.
    _pmfnLast = _pmfnProcessCompletion;

    pmfn = _pmfnProcessCompletion;
    _pmfnProcessCompletion = NULL;

    ASSERT(pmfn != NULL);

    hr = (this->*pmfn)(hrErr, numBytes);
    if (hr) {
        /* Release this tracker when an error occurs*/
        RecordProcessError(hr, L"ProcessCompletion");
        Release();
                
        if (IsExpectedError(hr)) {
            // Don't want expected error to be reported in
            // ThreadPoolThreadProc() in threadpool.cxx
            hr = S_OK;
        }
        else {
            TRACE_ERROR(hr);
            TRACE1(TAG_STATE_SERVER, L"Error occurred (%08x), releasing tracker.", hr);
        }
    }

Cleanup:
    return hr;
}


BOOL
Tracker::IsExpectedError(HRESULT hr) {
    //
    //  ERROR_GRACEFUL_DISCONNECT: Happens when the client closed the socket
    //  ERROR_OPERATION_ABORTED: Happens when we shut down
    //  ERROR_NETNAME_DELETED: Happens when the timer expires the socket
    //  WSAECONNABORTED: Happens when the client times out the connection
    //  
    //
    
    return (hr == HRESULT_FROM_WIN32(ERROR_GRACEFUL_DISCONNECT) ||
            hr == HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED) ||
            hr == HRESULT_FROM_WIN32(ERROR_NETNAME_DELETED) ||
            hr == HRESULT_FROM_WIN32(WSAECONNABORTED));
}


__int64 g_LastSocketExpiryError = 0;

#define FT_SECOND ((__int64) 10000000)

void
Tracker::LogSocketExpiryError( DWORD dwEventId )
{
    SYSTEMTIME  st;
    FILETIME    ft;
    WCHAR       *pchOp;
    __int64     now;

    GetSystemTimeAsFileTime((FILETIME *) &now);
        
    if (now - g_LastSocketExpiryError < FT_SECOND * 60) {
        return;
    }

    FileTimeToLocalFileTime(&_IOStartTime, &ft);
    FileTimeToSystemTime(&ft, &st);
    if (_pmfnProcessCompletion == &Tracker::ProcessWriting) {
        pchOp = L"Write";
    }
    else if (_pmfnProcessCompletion == &Tracker::ProcessReading) {
        pchOp = L"Read";
    }
    else {
        pchOp = L"Unknown";
    }
    XspLogEvent( dwEventId, L"%d^%d^%d^%d^%s^%02d^%02d^%04d^%02d^%02d^%02d", 
            _addrInfo._sockAddrs._addrRemote.sin_addr.S_un.S_un_b.s_b1,
            _addrInfo._sockAddrs._addrRemote.sin_addr.S_un.S_un_b.s_b2,
            _addrInfo._sockAddrs._addrRemote.sin_addr.S_un.S_un_b.s_b3,
            _addrInfo._sockAddrs._addrRemote.sin_addr.S_un.S_un_b.s_b4,
            pchOp, st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);

    g_LastSocketExpiryError = now;
}


void
Tracker::LogError()
{
    WCHAR * pchFunc;
    HRESULT hr = S_OK;

    if (_hrProcessError == S_OK)
        EXIT();

    if (_hrProcessError == HRESULT_FROM_WIN32(ERROR_TIMEOUT)) {
        LogSocketExpiryError( IDS_EVENTLOG_STATE_SERVER_EXPIRE_CONNECTION );
    }
    else {
        if (_pchProcessErrorFuncList) {
            pchFunc = _pchProcessErrorFuncList;
        }
        else {
            pchFunc = L"Unknown";
        }

        XspLogEvent( IDS_EVENTLOG_STATE_SERVER_ERROR, L"%s^0x%08x", pchFunc, _hrProcessError );
    }

Cleanup:
    return;
}


HRESULT
Tracker::ProcessListening(HRESULT hrCompletion, int) {
    HRESULT     hr;
    int         result;
    SOCKET      listenSocket;
    SOCKADDR *  paddrLocal;
    SOCKADDR *  paddrRemote;
    int         lengthLocal;
    int         lengthRemote;

    hr = hrCompletion;
    ON_ERROR_EXIT();

    TRACE(TAG_STATE_SERVER, L"Accepted a new connection.");

    /*
     * Inherit socket options from listener.
     */
    listenSocket = StateWebServer::Server()->ListenSocket();
    result = setsockopt(_acceptedSocket, SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT, 
        (char *)&listenSocket, sizeof(listenSocket)); 

    /*
     * We've accepted a connection. Accept another connection to 
     * replace this one.
     */
    hr = StateWebServer::Server()->AcceptNewConnection();
    ON_ERROR_CONTINUE();
    hr = S_OK;

    /*
     * Get the local and remote addresses.
     */
    GetAcceptExSockaddrs(
            _addrInfo._bufAddress,
            0,
            ADDRESS_LENGTH,
            ADDRESS_LENGTH,
            &paddrLocal,
            &lengthLocal,
            &paddrRemote,
            &lengthRemote);

    ASSERT(lengthLocal == sizeof(_addrInfo._sockAddrs._addrLocal));
    ASSERT(lengthRemote == sizeof(_addrInfo._sockAddrs._addrRemote));

    _addrInfo._sockAddrs._addrLocal = * (SOCKADDR_IN *) paddrLocal;
    _addrInfo._sockAddrs._addrRemote = * (SOCKADDR_IN *) paddrRemote;

    /*
     * This Tracker is no longer a listener. Let's remove it from
     * s_TrackerListenerList and add it to s_TrackerList
     */
    ASSERT(_iTrackerList != -1);
    ASSERT(_bListener);

#if DBG
    Tracker *pTracker =
#endif    
    s_TrackerListenerList.RemoveEntry(_iTrackerList);
    ASSERT(pTracker == this);

    _bListener = FALSE;
    _iTrackerList = -1;
    hr = s_TrackerList.AddEntry(this, &_iTrackerList);
    ON_ERROR_EXIT();

    if (!StateWebServer::Server()->AllowRemote() && !IsLocalConnection()) {
        EXIT_WITH_WIN32_ERROR(ERROR_NETWORK_ACCESS_DENIED);
    }

    hr = StartReading();
    ON_ERROR_EXIT();

Cleanup:
    RecordProcessError(hr, L"ProcessListening");
    return hr;
}



HRESULT
Tracker::StartReading() {
    HRESULT hr = S_OK;

    _pReadBuffer = new ReadBuffer;
    ON_OOM_EXIT(_pReadBuffer);

    hr = _pReadBuffer->Init(this, NULL, NULL);
    ON_ERROR_EXIT();

    hr = ProcessReading(S_OK, (DWORD) -1);
    ON_ERROR_EXIT();

Cleanup:
    RecordProcessError(hr, L"StartReading");
    return hr;
}


HRESULT
Tracker::ContinueReading(Tracker * pTracker)
{
    HRESULT hr = S_OK;
    int     toread;

    ASSERT(pTracker->_acceptedSocket != INVALID_SOCKET);

    _acceptedSocket = pTracker->_acceptedSocket;
    _addrInfo._sockAddrs = pTracker->_addrInfo._sockAddrs;
    pTracker->_acceptedSocket = INVALID_SOCKET;

    _pReadBuffer = new ReadBuffer;
    ON_OOM_EXIT(_pReadBuffer);

    hr = _pReadBuffer->Init(this, pTracker->_pReadBuffer, &toread);
    ON_ERROR_EXIT();

    hr = ProcessReading(S_OK, toread);
    ON_ERROR_EXIT();

Cleanup:
    RecordProcessError(hr, L"ContinueReading");
    return hr;
}


HRESULT
Tracker::ProcessReading(HRESULT hrCompletion, int numBytes) {
    HRESULT hr = hrCompletion;

    if (IsExpectedError(hr)) {
        EXIT_WITH_SUCCESSFUL_HRESULT(hr);
    }
    
    ON_ERROR_EXIT();

    hr = _pReadBuffer->ReadRequest(numBytes);
    if (hr == S_OK) {
        /* done reading, submit */
        hr = SubmitRequest();
        ON_ERROR_EXIT();
    }
    else if (hr == S_FALSE) {
        /* OK so far, but still reading */
        hr = S_OK;
    }
    else {
        if (IsExpectedError(hr)) {
            EXIT_WITH_SUCCESSFUL_HRESULT(hr);
        }
        
        ON_ERROR_EXIT();
    }

Cleanup:
    RecordProcessError(hr, L"ProcessReading");
    return hr;
}


HRESULT
Tracker::Read(void * buf, int cb)
{
    HRESULT             hr = S_OK;
    int                 err;
    DWORD               cbRecv;
    DWORD               flags;
    WSABUF              awsabuf[1];
    TrackerCompletion * pCompletion = NULL;

    ASSERT(_acceptedSocket != INVALID_SOCKET);
    _pmfnProcessCompletion = &Tracker::ProcessReading;

    pCompletion = new TrackerCompletion(this);
    ON_OOM_EXIT(pCompletion);

    pCompletion->AddRef();

    awsabuf[0].len = cb;
    awsabuf[0].buf = (char *) buf;
    cbRecv = 0;
    flags = 0;

    // Set Expiry info first so that the Completion thread
    // has the correct info.
    s_TrackerList.SetExpire(_iTrackerList);

    // For trapping ASURT 91153
    GetSystemTimeAsFileTime(&_IOStartTime);
    
    err = WSARecv(_acceptedSocket, awsabuf, 1, &cbRecv, &flags, pCompletion->Overlapped(), NULL);
    if (err == SOCKET_ERROR) {
        err = WSAGetLastError();
        if (err != WSA_IO_PENDING) {
            s_TrackerList.SetNoExpire(_iTrackerList);
            _pmfnProcessCompletion = NULL;
            pCompletion->Release();
            EXIT_WITH_WIN32_ERROR(err);
        }
    }

Cleanup:
    ReleaseInterface(pCompletion);
    RecordProcessError(hr, L"Tracker::Read");
    return hr;
}


void
Tracker::RecordProcessError(HRESULT hrProcess, WCHAR *CurrFunc)
{
    WCHAR   *pchCallStack;
    int     len;
    HRESULT hr = S_OK;

    // Skip success or expected error case
    if (hrProcess == S_OK || IsExpectedError(hrProcess))
    {
        EXIT();
    }

    TRACE_ERROR(hrProcess);
    
    if (_hrProcessError == S_OK) {
        _hrProcessError = hrProcess;
    }

    len = lstrlenW(CurrFunc) + 1;
    if (_pchProcessErrorFuncList) {
        len += lstrlenW(_pchProcessErrorFuncList) 
                + 3;    // "-->"
    }

    pchCallStack = new WCHAR[len];
    ON_OOM_EXIT(pchCallStack);

    StringCchCopyW(pchCallStack, len, CurrFunc);
    
    if (_pchProcessErrorFuncList) {
        StringCchCatW(pchCallStack, len, L"-->");
        StringCchCatW(pchCallStack, len, _pchProcessErrorFuncList);
    }

    delete [] _pchProcessErrorFuncList;
    _pchProcessErrorFuncList = pchCallStack;
    
Cleanup:
    return;
}


#define STR_HTTP_11         "HTTP/1.1 "
#define STR_CONTENT_LENGTH  "Content-Length: "
#define STR_CRLFCRLF        "\r\n\r\n"

void
Tracker::SendResponse(
        WCHAR * status, 
        int     statusLength,  
        WCHAR * headers, 
        int     headersLength,  
        StateItem *psi) {
    HRESULT hr = S_OK;
    int     result, err;
    int     maxLength, size;
    char    *pchHeaders = NULL;
    char    *pch;
    int     currentLength;
    int     contentLength;
    int     cBuffers = 1;
    DWORD   cbSent;
    TrackerCompletion * pCompletion = NULL;


    /*
     * Only try to submit the response once. Reporting errors from this function
     * doesn't make sense, because an error could occur during the write that
     * will only be detected the completion. And if we run out of memory 
     * constructing the reponse, we probably won't have enough
     * memory to construct another response to report the error.
     * 
     * Also, we only use a single completion for writes, because we expect
     * to write just once. We must prevent reuse of this completion.
     */
    if (_responseSent)
        return;

    _responseSent = true;

    if (psi != NULL) {
        contentLength = psi->GetLength();
    }
    else {
        contentLength = 0;
    }

    /*
     * Create buffer to write headers.
     */
    maxLength = 
            statusLength + 
            headersLength + 
            ARRAY_SIZE(STR_CONTENT_LENGTH) + 
            10 + /* max digits in a base-10 32-bit integer */
            sizeof(STR_CRLFCRLF) - 1;

#if FIX_RESPONSE
    maxLength += ARRAY_SIZE(STR_HTTP_11);
#endif

    size = (maxLength * 2);

    pchHeaders = new char[size];
    ON_OOM_EXIT(pchHeaders);

    currentLength = 0;

#if FIX_RESPONSE
    CopyMemory(pchHeaders + currentLength, STR_HTTP_11, sizeof(STR_HTTP_11) - 1);
    currentLength += sizeof(STR_HTTP_11) - 1;
#endif

    currentLength += WideCharToMultiByte(CP_ACP, 0, status, statusLength, pchHeaders + currentLength, size, NULL, NULL);
#if FIX_RESPONSE
    ASSERT(currentLength > sizeof(STR_HTTP_11) - 1);
#else
    ASSERT(currentLength > 0);
#endif

    result = WideCharToMultiByte(CP_ACP, 0, headers, headersLength, pchHeaders + currentLength, size - currentLength, NULL, NULL);
    ASSERT(result > 0);
    currentLength += result;

    CopyMemory(pchHeaders + currentLength, STR_CONTENT_LENGTH, sizeof(STR_CONTENT_LENGTH) - 1);
    currentLength += (sizeof(STR_CONTENT_LENGTH) - 1);

    _itoa(contentLength, pchHeaders + currentLength, 10);

    pch = pchHeaders + currentLength;
    while (*pch != '\0') {
        pch++;
    }

    currentLength = PtrToLong(pch - pchHeaders);

    CopyMemory(pch, STR_CRLFCRLF, sizeof(STR_CRLFCRLF) - 1);
    currentLength += sizeof(STR_CRLFCRLF) - 1;

    _wsabuf[0].len = currentLength;
    _wsabuf[0].buf = pchHeaders;
    pchHeaders = NULL;

    /*
     * Write content.
     */
    if (contentLength > 0) {
        _psi = psi;
        _psi->AddRef();
        _wsabuf[1].len = contentLength;
        _wsabuf[1].buf = (char *) psi->GetContent();
        cBuffers = 2;
    }

    _pmfnProcessCompletion = &Tracker::ProcessWriting;
    pCompletion = new TrackerCompletion(this);
    ON_OOM_EXIT(pCompletion);

    pCompletion->AddRef();

    // Set Expiry info first so that the Completion thread
    // has the correct info.
    s_TrackerList.SetExpire(_iTrackerList);

    // For trapping ASURT 91153
    GetSystemTimeAsFileTime(&_IOStartTime);
    
    ASSERT(_acceptedSocket != INVALID_SOCKET);
    err = WSASend(_acceptedSocket, _wsabuf, cBuffers, &cbSent, 0, pCompletion->Overlapped(), NULL);
    if (err == SOCKET_ERROR) {
        err = WSAGetLastError();
        if (err != WSA_IO_PENDING) {
            s_TrackerList.SetNoExpire(_iTrackerList);
            
            _pmfnProcessCompletion = NULL;
            pCompletion->Release();
            EXIT_WITH_WIN32_ERROR(err);
        }
    }
#if DBG
    else {
        ASSERT(cbSent == (int) (_wsabuf[0].len + _wsabuf[1].len));
    }
#endif

Cleanup:
    ReleaseInterface(pCompletion);
    delete [] pchHeaders;
}


/*
 * N.B. ProcessWriting may be called while this Tracker
 * is still being used by managed code. So we can only
 * refer to fields in this object that are protected in
 * some way (such as the refcount is protected by interlocked
 * operations).
 */
HRESULT
Tracker::ProcessWriting(HRESULT hrCompletion, int numBytes)
{
#if DBG
    if (hrCompletion == S_OK) {
        ASSERT(numBytes == (int) (_wsabuf[0].len + _wsabuf[1].len));
    }
#else
    UNREFERENCED_PARAMETER(numBytes);
#endif

    RecordProcessError(hrCompletion, L"ProcessWriting");
    return hrCompletion;
}

void
Tracker::EndOfRequest()
{
    HRESULT     hr = S_OK;
    Tracker *   pTracker = NULL;

    if (_ended)
        return;

    _ended = true;

    if (!_bCloseConnection) {
        pTracker = new Tracker();
        if (pTracker != NULL) {
            hr = pTracker->Init(false);
            if (hr == S_OK) {
                hr = pTracker->ContinueReading(this);
            }
            if (hr) {
                RecordProcessError(hr, L"EndOfRequest");
                pTracker->Release();
            }
        }
    }

}


BOOL
Tracker::IsClientConnected() {
    return IsSocketConnected(_acceptedSocket);
}


void
Tracker::CloseConnection() {
    /*
     * Don't want to close the connection immediately if there
     * is outstanding I/O.
     */
    _bCloseConnection = true;
}


HRESULT
Tracker::CloseSocket() {
    HRESULT     hr = S_OK;
    int         result;
    SOCKET      socket = _acceptedSocket;

    // _acceptedSocket can be INVALID_SOCKET if it still has
    // a pending WSASend, but EndOfRequest has been called.
    if (socket != INVALID_SOCKET) {
        _acceptedSocket = INVALID_SOCKET;

        result = closesocket(socket);
        ON_SOCKET_ERROR_EXIT(result);
    }

Cleanup:
    return hr;
}


void
Tracker::GetRemoteAddress(char * buf) {
    char * s;

    s = inet_ntoa(_addrInfo._sockAddrs._addrRemote.sin_addr);
    StringCchCopyUnsafeA(buf, s);
}

int
Tracker::GetRemotePort() {
    return ntohs(_addrInfo._sockAddrs._addrRemote.sin_port);
}

void
Tracker::GetLocalAddress(char * buf) {
    char * s;

    s = inet_ntoa(_addrInfo._sockAddrs._addrLocal.sin_addr);
    StringCchCopyUnsafeA(buf, s);
}

int
Tracker::GetLocalPort() {
    return ntohs(_addrInfo._sockAddrs._addrLocal.sin_port);
}

bool
Tracker::IsLocalConnection() {
    PHOSTENT phe;
    
    if (    _addrInfo._sockAddrs._addrRemote.sin_addr.S_un.S_un_b.s_b1 == 127 &&
            _addrInfo._sockAddrs._addrRemote.sin_addr.S_un.S_un_b.s_b2 == 0 &&
            _addrInfo._sockAddrs._addrRemote.sin_addr.S_un.S_un_b.s_b3 == 0 &&
            _addrInfo._sockAddrs._addrRemote.sin_addr.S_un.S_un_b.s_b4 == 1) {
         return TRUE;
    }
    
    phe = gethostbyname(NULL);

    if((phe == NULL) || (phe->h_addr_list == NULL))
        return FALSE;

    for(DWORD** ppAddress = (DWORD**)phe->h_addr_list; *ppAddress != NULL; ++ppAddress)
    {
        if(**ppAddress == _addrInfo._sockAddrs._addrRemote.sin_addr.s_addr)
            return TRUE;
    }
    
    return FALSE;
}


TrackerList::TrackerList():_TrackerListLock("TrackerList::_TrackerListLock")
{
    _iFreeHead = -1;
    _iFreeTail = -1;
}

TrackerList::~TrackerList()    
{
    ASSERT(IsValid());
    delete _pTLEArray;
}

HRESULT
TrackerList::AddEntry(Tracker *pTracker, int *pIndex) {
    HRESULT hr = S_OK;
    int     index;

    ASSERT(pTracker != NULL);

    *pIndex = -1;
    
    _TrackerListLock.AcquireWriterLock();

    __try {
        
        if (_cFreeElem == 0) {
            hr = Grow();
            ON_ERROR_EXIT();
        }

        index = _iFreeHead;
        _iFreeHead = _pTLEArray[index]._iNext;  // Point to the next free element
    
        _cFreeElem--;

        // Adjust no. of free elements in the 2nd half of the array
        if (index >= _ArraySize/2) {
            _cFree2ndHalf--;
        }

        if (_cFreeElem == 0) {
            _iFreeTail = -1;
        }

        _pTLEArray[index]._pTracker = pTracker;
        _pTLEArray[index]._ExpireTime = -1;
        
        *pIndex = index;
    }
    __finally {
        ASSERT(IsValid());
        _TrackerListLock.ReleaseWriterLock();
    }

Cleanup:    
    return hr;
}


Tracker *  
TrackerList::RemoveEntry(int index) {
    HRESULT hr = S_OK;
    Tracker *pTracker = NULL;
    
    _TrackerListLock.AcquireWriterLock();

    __try {
        ASSERT(index >= 0 && index < _ArraySize);
        if (index < 0 || index >= _ArraySize) {
            hr = ERROR_NOT_FOUND;
            ON_WIN32_ERROR_EXIT(hr);
        }

        pTracker = _pTLEArray[index]._pTracker;
        ASSERT(pTracker != NULL);

        // Return the element to the free list

        // Trick:
        // If we want to contract the array, we can only free up consecutive 
        // elements at the end, because we cannot rearrange the locations
        // of used elements inside the array. In order to make the contraction
        // more efficient, we want to avoid an AddEntry call to pickup a free slot
        // near the end of the array.
        // Because AddEntry always picks up free slot from the head, when freeing
        // an item, we will stick it to either the head or the tail of the free
        // list, based on its index. Small index goes to head, big index goes
        // to tail.  This way, free slot with small index should be used first,
        // and thus help out the contraction.

        // Catch the boundary case

        if (_iFreeHead == _iFreeTail && _iFreeHead == -1) {
            _iFreeHead = index;
            _iFreeTail = index;
            _pTLEArray[index]._iNext = -1;
        }
        else if (index < _ArraySize/2) {
            // Smaller half
            _pTLEArray[index]._iNext = _iFreeHead;
            _iFreeHead = index;
        }
        else {
            // Larger half
            _pTLEArray[_iFreeTail]._iNext = index;
            _pTLEArray[index]._iNext = -1;
            _iFreeTail = index;
        }

        _pTLEArray[index].MarkAsFree();
        _cFreeElem++;
        
        // Adjust no. of free elements in the 2nd half of the array
        if (index >= _ArraySize/2) {
            _cFree2ndHalf++;
        }
    }
    __finally {
        ASSERT(IsValid());
        _TrackerListLock.ReleaseWriterLock();
    }

    
Cleanup:    
    return pTracker;
}


void TrackerList::TryShrink() {
    int     NewSize, ShrinkBy, i, cFree;
    TLE     *pNewArray;
    HRESULT hr = S_OK;

    _TrackerListLock.AcquireWriterLock();

    __try {
        while (_ArraySize > TRACKERLIST_ALLOC_SIZE &&
            _cFree2ndHalf == _ArraySize/2) {
            // Shrink the array by multiples of TRACKERLIST_ALLOC_SIZE,
            // up to half of _ArraySize
            ShrinkBy = (_ArraySize / 2 / TRACKERLIST_ALLOC_SIZE) * TRACKERLIST_ALLOC_SIZE;
            

            ASSERT(IsShrinkable());

            // Realloc a new buffer for the elements
            NewSize = _ArraySize - ShrinkBy;
            pNewArray = new (_pTLEArray, NewReAlloc) TLE[NewSize];
            ON_OOM_EXIT(pNewArray);
            _pTLEArray = pNewArray;

            _cFreeElem -= ShrinkBy;
            _ArraySize = NewSize;

            _iFreeHead = -1;
            _iFreeTail = -1;
            
            // Reconstruct the free list and recount _cFree2ndHalf
            _cFree2ndHalf = 0;
            cFree = 0;
            for (i=_ArraySize-1; i >= 0; i--) {
                if (_pTLEArray[i].IsFree()) {
                    if (_iFreeHead == -1) {
                        ASSERT(_iFreeTail == -1);
                        _iFreeHead = _iFreeTail = i;
                        _pTLEArray[i]._iNext = -1;
                    }
                    else {
                        _pTLEArray[i]._iNext = _iFreeHead;
                        _iFreeHead = i;
                    }

                    if (i >= _ArraySize/2) {
                        _cFree2ndHalf++;
                    }
#if DBG
                    cFree++;
#endif
                }
            }

#if DBG
            _cShrink++;
#endif
            ASSERT(cFree == _cFreeElem);
            
        }
    }
    __finally {
        ASSERT(IsValid());
        _TrackerListLock.ReleaseWriterLock();
    }

Cleanup:
    return;
}


__int64 TrackerList::NewExpireTime() { 
    __int64     now;
    
    GetSystemTimeAsFileTime((FILETIME *) &now);
    
    // We allow 3 sec of slack time so that the thread has enough
    // time between setting expiry time and make the winsock call
    return now + 
        (__int64)(StateWebServer::Server()->SocketTimeout() + 3)*TICKS_PER_SEC;
}


void TrackerList::SetExpire(int index) {
    _TrackerListLock.AcquireReaderLock();

    __try {
        ASSERT(index >= 0 && index < _ArraySize);
        ASSERT(!_pTLEArray[index].IsFree());

        // The current logic in Tracker will not set the expire time again
        // without first calling SetNoExpire
        ASSERT(_pTLEArray[index]._ExpireTime == -1);

        _pTLEArray[index]._ExpireTime = NewExpireTime();
    }
    __finally {
        _TrackerListLock.ReleaseReaderLock();
    }

    return;
}


bool 
TrackerList::SetNoExpire(int index) {
    bool    ret = TRUE;;
    
    _TrackerListLock.AcquireReaderLock();

    __try {
        
        ASSERT(index >= 0 && index < _ArraySize);
        ASSERT(!_pTLEArray[index].IsFree());

        // For each entry in the array, potentially only ONE tracker and the
        // Timer can "check expire time and update it" concurrently.
        // Since the Timer always acquires a Writer Lock when traversing the array,
        // the Tracker only needs to acquire a Reader Lock.

        if (_pTLEArray[index]._ExpireTime == -1) {
            ret = FALSE;    // Returning FALSE means someone has unset it already
        }
        else {
            _pTLEArray[index]._ExpireTime = -1;
        }
    }
    __finally {
        _TrackerListLock.ReleaseReaderLock();
    }

    return ret;
}


HRESULT
TrackerList::Grow() {
    int     NewSize, i;
    HRESULT hr = S_OK;
    TLE     *pNewArray;

    _TrackerListLock.AcquireWriterLock();

    __try {

        // Realloc a new buffer for the elements
        NewSize = _ArraySize + TRACKERLIST_ALLOC_SIZE;
        pNewArray = new (_pTLEArray, NewReAlloc) TLE[NewSize];
        ON_OOM_EXIT(pNewArray);

        _pTLEArray = pNewArray;

        ZeroMemory(&_pTLEArray[_ArraySize], TRACKERLIST_ALLOC_SIZE * sizeof(TLE));

        // Initialize new free list
        _iFreeHead = _ArraySize;
        _iFreeTail = NewSize - 1;
        for (i=_iFreeHead; i < _iFreeTail; i++) {
            _pTLEArray[i]._iNext = i+1;
        }

        // Point the last element to -1
        _pTLEArray[_iFreeTail]._iNext = -1;

        _cFreeElem = TRACKERLIST_ALLOC_SIZE;
        _ArraySize = NewSize;

        ASSERT(_cFree2ndHalf == 0);

        if (_ArraySize == TRACKERLIST_ALLOC_SIZE)
            _cFree2ndHalf = TRACKERLIST_ALLOC_SIZE/2;
        else
            _cFree2ndHalf = TRACKERLIST_ALLOC_SIZE;
    }
    __finally {
        ASSERT(IsValid());
        _TrackerListLock.ReleaseWriterLock();
    }
Cleanup:
    return hr;
}


void
TrackerList::CloseExpiredSockets() 
{
    HRESULT     hr = S_OK;
    int         i;
    __int64     now;
    Tracker     *pTracker;

#if DBG    
    SYSTEMTIME  st;
    GetLocalTime(&st);
#endif    
    
    GetSystemTimeAsFileTime((FILETIME *) &now);
    
    TRACE4(TAG_STATE_SERVER, L"CloseSockets: Shrink=%d Size=%d Free=%d 2ndHalfFre=%d", _cShrink,
            _ArraySize, _cFreeElem, _cFree2ndHalf);
    
    _TrackerListLock.AcquireWriterLock();

    __try {

        for (i=0; i<_ArraySize; i++) {
            // Skip:
            // - Free item
            // - Item that has no expiry time
            // - Item that hasn't expired yet
            if (_pTLEArray[i].IsFree() ||
                _pTLEArray[i]._ExpireTime == -1 || 
                _pTLEArray[i]._ExpireTime > now) {
                continue;
            }

            // The item has expired.  
            pTracker = _pTLEArray[i]._pTracker;

            TRACE4(TAG_STATE_SERVER, L"Close expired socket (%p), Time (%02d:%02d:%02d)", 
                    pTracker->AcceptedSocket(), st.wHour, st.wMinute, st.wSecond);
            
            hr = pTracker->CloseSocket();
            ON_ERROR_CONTINUE();

#if DBG
            // For trapping ASURT 91153            
            pTracker->LogSocketExpiryError( IDS_EVENTLOG_STATE_SERVER_EXPIRE_CONNECTION_DEBUG );
#endif
            
            // Unset the expiry time so that the owning Tracker object
            // knows that we've expired it already
            _pTLEArray[i]._ExpireTime = -1;
        }

        // We'll also try to shrink the array as part of
        // flushing the list.
        TryShrink();
    }
    __finally {
        _TrackerListLock.ReleaseWriterLock();
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\state\stweb.h ===
/**
 * stweb.h
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

#include "names.h"
#include "nisapi.h"
#include "xspmrt_stateruntime.h"
#include "xspstate.h"

/*
 * Debug tags.
 */
#define TAG_STATE_SERVER                       L"StateServer"                      
#define TAG_STATE_SERVER_COMPLETION            L"StateServerCompletion"

#define READ_BUF_SIZE                  (1024)

#define ADDRESS_LENGTH  ( sizeof(SOCKADDR_IN) + 16 )  

class Tracker;
class TrackerList;

// Tracker List Entry
struct TLE {
    Tracker *   _pTracker;      // Points to the Tracker class.  
                                // NULL means this entry isn't used.
    union {
        int     _iNext;         // If it's a free entry,
        __int64 _ExpireTime;    // Expire time (in nano sec) since 1/1/1601
    };

    inline bool IsFree() { return (_pTracker == NULL); }
    inline void MarkAsFree() { _pTracker = NULL; }
};

#define TRACKERLIST_ALLOC_SIZE      (32)

//
// TrackerList is a double-link-list implemented within an array.  It's used
// to store TLE objects.  The reason for using an array (vs. a real linked 
// list) to implement this list is to avoid memory paging when the expiry 
// thread is enumerating all the Trackers with pending I/O operations.
//
class TrackerList {
private:
    DECLARE_MEMCLEAR_NEW_DELETE();

public:
    TrackerList();
    ~TrackerList();
    
    HRESULT AddEntry(Tracker *pTracker, int *pIndex);
    Tracker *RemoveEntry(int index);
    void    SetExpire(int index);
    bool    SetNoExpire(int index);
    void    CloseExpiredSockets();
    
private:
    CReadWriteSpinLock      _TrackerListLock;
    
    TLE *   _pTLEArray;     // The allocated memory for the array
    int     _ArraySize;     // Size (# of elements) of the allocated array
    int     _iFreeHead;     // Index of the head of free element list
    int     _iFreeTail;     // Index of the tail of free element list
    int     _cFreeElem;     // # of free elements
    int     _cFree2ndHalf;  // # of free elements in the 2nd half of the array
    
    __int64 NewExpireTime();
    HRESULT Grow();
    void    TryShrink();

#if DBG
    int     _cShrink;

    BOOL    IsValid() 
    {
        int     i, used = 0, Free2ndHalf = 0, free=0;

        if (_cFreeElem > 0) {
            ASSERT(_iFreeHead >= 0);
            ASSERT(_iFreeHead < _ArraySize);
            ASSERT(_iFreeTail >= 0);
            ASSERT(_iFreeTail < _ArraySize);
        }
        else {
            ASSERT(_iFreeHead == -1);
            ASSERT(_iFreeTail == -1);
        }

        for (i=0; i < _ArraySize; i++) {
            if (_pTLEArray[i].IsFree() != TRUE)
            {
                used++;
            } 
            else if (i >= _ArraySize/2) {
                Free2ndHalf++;
            }
        }

        ASSERT(used + _cFreeElem == _ArraySize);

        ASSERT(Free2ndHalf == _cFree2ndHalf);

        for (free=0, i=_iFreeHead; i != -1; i=_pTLEArray[i]._iNext) {
            free++;
        }

        ASSERT(free == _cFreeElem);
        
        return TRUE;
    }

    BOOL    IsShrinkable() 
    {
        int i;

        for (i = _ArraySize/2; i < _ArraySize;i++) {
            ASSERT(_pTLEArray[i].IsFree() == TRUE);
        }

        return TRUE;
    }
#endif
};


class StateItem
{
public:
    static StateItem *  Create(int length);

    ULONG   AddRef();
    ULONG   Release();

    BYTE *  GetContent()    {return _content;}
    int     GetLength()     {return _length;}

private:
    static void Free(StateItem * psi);

    static long s_cStateItems;

    long    _refs;
    int     _length;
    BYTE    _content[0];
};

/**
 *  The main functions of ReadBuffer are:
 *  - Parse the header into Header array, content array, and other 
 *      info (e.g. lockCookie)
 *  - Contains the logic to determine if the reading is done.
 *  - Call Tracker::Read if reading isn't finished
 */
class ReadBuffer
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    ~ReadBuffer();

    HRESULT Init(Tracker * ptracker, ReadBuffer * pReadBuffer, int * toread);
    HRESULT ReadRequest(DWORD numBytes); 

    int     GetVerb()               {return _verb;}
    WCHAR * GetUri()                {return _pwcUri;}
    int     GetContentLength()      {return (_contentLength != -1) ? _contentLength : 0;}
    int     GetTimeout()            {return _timeout;}
    int     GetLockCookieExists()   {return _lockCookieExists;}
    int     GetLockCookie()         {return _lockCookie;}
    int     GetExclusive()          {return _exclusive;}
    StateItem * DetachStateItem()         
    {
        StateItem * psi = _psi;

        _psi = NULL; 
        _contentLength = 0; 
        return psi;
    }

private:
    HRESULT ParseHeader();

    Tracker *   _ptracker;

    char *      _achHeader;     // Array for the header
    int         _cchHeader;     // Size of _achHeader
    int         _cchHeaderRead; // # of bytes read so far in _achHeader

    int         _iCurrent;      // Index in _achHeader of how far we've read, including
                                // those content we've copied to _psi->GetContent
    int         _iContent;      // Index in _achHeader of the beginning of content

    int         _verb;          
    WCHAR *     _pwcUri;        // Buffer to store the URI, which specifies the state object

    int         _contentLength; // Size of content sent from client, also size of _psi->GetContent
    int         _timeout;
    int         _exclusive;     // Whether it's an Exclusive Acquire or Exclusive Release
    int         _lockCookieExists;  // Used in Exclusive Release if the state is locked by another session
    int         _lockCookie;        // Id of the lock (by another session)

    StateItem * _psi;           // State item
    int         _cbContentRead; // # of bytes copied to _psi->GetContent
};

class Tracker;

class TrackerCompletion : public Completion
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    TrackerCompletion(Tracker * pTracker);
    virtual ~TrackerCompletion();

    STDMETHOD(ProcessCompletion)(HRESULT, int, LPOVERLAPPED);

private:
    Tracker *   _pTracker;
};


class RefCount : public IUnknown 
{
public:
    DECLARE_MEMALLOC_NEW_DELETE();

            RefCount();
    virtual ~RefCount();

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID, void **);

private:
    long    _refs;
};

class Tracker : public RefCount
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    static HRESULT  staticInit();
    static void     staticCleanup();

                    Tracker();
    virtual         ~Tracker();

    HRESULT         Init(bool fListener);
    HRESULT ProcessCompletion(HRESULT, int, LPOVERLAPPED);

    /* StateWebServer interface */
    HRESULT         Listen(SOCKET listenSocket);

    /* NDirect interface to managed state runtime. */
    void    SendResponse(
        WCHAR * status, 
        int     statusLength,  
        WCHAR * headers, 
        int     headersLength,  
        StateItem *psi);

    void    EndOfRequest();

    void    GetRemoteAddress(char * buf);
    int     GetRemotePort();
    void    GetLocalAddress(char * buf);
    int     GetLocalPort();

    BOOL    IsClientConnected();
    void    CloseConnection();
    HRESULT CloseSocket();
    void    LogSocketExpiryError( DWORD dwEventId );

    /* helper for ReadBuffer */
    HRESULT Read(void * buf, int c);

    /* helpers for StateWebServer */
    static void     SignalZeroTrackers();
    static HANDLE   EventZeroTrackers() {return s_eventZeroTrackers;}
    static void     FlushExpiredTrackers() {s_TrackerList.CloseExpiredSockets();}

#if DBG
    SOCKET  AcceptedSocket() { return _acceptedSocket;}
#endif

private:
    HRESULT         StartReading();
    HRESULT         ContinueReading(Tracker * pTracker);
    HRESULT         SubmitRequest();

    typedef HRESULT (Tracker::*pmfnProcessCompletion)(HRESULT hrCompletion, int numBytes);
    HRESULT         ProcessListening(HRESULT hrCompletion, int numBytes);
    HRESULT         ProcessReading(HRESULT hrCompletion, int numBytes);
    HRESULT         ProcessWriting(HRESULT hrCompletion, int numBytes);

    void            ReportHttpError();

    static HRESULT  GetManagedRuntime(xspmrt::_StateRuntime ** ppManagedRuntime);
    static HRESULT  CreateManagedRuntime();
    static HRESULT  DeleteManagedRuntime();
    
    void            RecordProcessError(HRESULT hr, WCHAR *CurrFunc);
    void            LogError();
    BOOL            IsExpectedError(HRESULT hr);
    bool            IsLocalConnection();

    WCHAR          *_pchProcessErrorFuncList;
    HRESULT         _hrProcessError;


    /* pointer to function to handle the completion */
    pmfnProcessCompletion   _pmfnProcessCompletion;
    pmfnProcessCompletion   _pmfnLast;

    /* accept stage fields */
    SOCKET                  _acceptedSocket;

    union {
        BYTE                _bufAddress[2*ADDRESS_LENGTH];
        struct {
            SOCKADDR_IN     _addrLocal;
            SOCKADDR_IN     _addrRemote;
        } _sockAddrs;
    } _addrInfo;

    /* read stage fields */
    ReadBuffer *    _pReadBuffer;

    /* Index inside TrackerList or TrackerListenerList */
    int             _iTrackerList;

    /*   For trapping ASURT 91153 */
    FILETIME        _IOStartTime;

    /* write stage fields */
    WSABUF          _wsabuf[2];
    StateItem *     _psi;
    bool            _responseSent;
    bool            _bCloseConnection;

    /* EndOfRequest called */
    bool            _ended;

    bool            _bListener;

    static TrackerList        s_TrackerList;
    static TrackerList        s_TrackerListenerList;
    
    static long               s_cTrackers;           
    
    static HANDLE             s_eventZeroTrackers;   
    static bool               s_bSignalZeroTrackers; 

    static xspmrt::_StateRuntime * s_pManagedRuntime;
    static CReadWriteSpinLock s_lockManagedRuntime;  
};

class ServiceControlEvent
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    LIST_ENTRY  _serviceControlEventList;
    DWORD       _dwControl;      
};

#define STATE_SOCKET_DEFAULT_TIMEOUT        (15)

class StateWebServer 
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    StateWebServer();

    HRESULT main(int argc, WCHAR * argv[]);
    HRESULT AcceptNewConnection();                                                           
    SOCKET  ListenSocket() {return _listenSocket;}
    HRESULT RunSocketExpiry();
    int     SocketTimeout() {return _lSocketTimeoutValue;}
    bool    AllowRemote() { return _bAllowRemote; }
    
#if DBG    
    HRESULT RunSocketTimeoutMonitor();
#endif
    
    static StateWebServer * Server() {return s_pstweb;}
    static WCHAR *ServiceKeyNameParameters() {return s_serviceKeyNameParameters;}

private:
    enum MainAction {
            ACTION_NOACTION = 0,
            ACTION_RUN_AS_EXE, 
            ACTION_RUN_AS_SERVICE};

    HRESULT     PrepareToRun();
    void        CleanupAfterRunning();
    HRESULT     ParseArgs(int argc, WCHAR * argv[], MainAction * paction);
    HRESULT     RunAsExe();
    HRESULT     RunAsService();

    void        PrintUsage();                                                                    
    void        SetServiceStatus(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint); 
    void        DoServiceMain(DWORD dwNumServicesArgs, LPWSTR *lpServiceArgVectors);             
    void        DoServiceCtrlHandler(DWORD dwControl);                                           

    HRESULT     StartListening();                                                                
    void        StopListening();                                                                 
    void        RemoveTracker(Tracker * ptracker);                                               
    HRESULT     WaitForZeroTrackers();
    HRESULT     StartSocketTimer();
    HRESULT     StopSocketTimer();
    HRESULT     GetSocketTimeoutValueFromReg();
#if DBG    
    HRESULT     StartSocketTimeoutMonitor();
    void        StopSocketTimeoutMonitor();
#endif    
    HRESULT     GetAllowRemoteConnectionFromReg();


    static BOOL WINAPI ConsoleCtrlHandler(DWORD dwCtrlType);
    static void WINAPI ServiceMain(DWORD dwNumServicesArgs, LPWSTR *lpServiceArgVectors);
    static void WINAPI ServiceCtrlHandler(DWORD dwControl);

    MainAction              _action;
    bool                    _bWinSockInitialized;

    HANDLE                  _hTimerThread;
    bool                    _bTimerStopped;
    HANDLE                  _hSocketTimer;
    int                     _lSocketTimeoutValue;
    HANDLE                  _hTimeoutMonitorThread;

    u_short                 _port;                   
    SOCKET                  _listenSocket;
    HANDLE                  _eventControl;
    bool                    _bListening;
    bool                    _bShuttingDown;
    bool                    _bAllowRemote;

    SERVICE_STATUS_HANDLE   _serviceStatus;
    DWORD                   _serviceState;
    LIST_ENTRY              _serviceControlEventList;
    CReadWriteSpinLock      _serviceControlEventListLock;

    static StateWebServer * s_pstweb;
    static WCHAR            s_serviceName[];
    static WCHAR            s_serviceKeyNameParameters[];
    static WCHAR            s_serviceValueNamePort[];
};


struct BlockMemHeapInfo {
    HANDLE       heap;
    unsigned int size;
};

#define NUM_HEAP_ENTRIES 67

class BlockMem {
public:
    static HRESULT Init();
    static void *  Alloc(unsigned int size);
    static void    Free(void * p);

private:
    static int IndexFromSize(unsigned int size);

    static BlockMemHeapInfo s_heaps[NUM_HEAP_ENTRIES];
    static HANDLE           s_lfh;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\state\xspmrt_stateruntime.h ===
/**
 * Contains IID and interface definition for StateRuntime managed class.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

#pragma once
#pragma pack(push, 8)

#include <comdef.h>

namespace xspmrt 
{

struct __declspec(uuid("721ee43c-12d5-11d3-8fcb-00c04f72d620")) StateRuntime;

struct __declspec(uuid("7297744b-e188-40bf-b7e9-56698d25cf44")) _StateRuntime;

struct _StateRuntime : IUnknown
{
    virtual HRESULT __stdcall StopProcessing ( ) = 0;
    virtual HRESULT __stdcall ProcessRequest ( 
            INT_PTR tracker,
            int verb,
            INT_PTR uri,
            int exclusive,
            int timeout,
            int lockCookieExists,
            int lockCookie,
            int contentLength,
            INT_PTR content
            ) = 0;
};


} // namespace xspmrt

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\bufferallocator.cs ===
//------------------------------------------------------------------------------
// <copyright file="BufferAllocator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Buffer Allocators with recycling
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web {

    using System.Collections;
    using System.IO;
    using System.Globalization;

    using System.Web.Util;

    //////////////////////////////////////////////////////////////////////////////
    // Generic buffer recycling

    /*
     * Base class for allocator doing buffer recycling
     */
    internal abstract class BufferAllocator {
        private int _maxFree;
        private int _numFree;
        private Stack _buffers;

        private static int s_ProcsFudgeFactor;

        static BufferAllocator() {
            s_ProcsFudgeFactor = SafeNativeMethods.CurProcInitialize();
            if (s_ProcsFudgeFactor < 1) 
                s_ProcsFudgeFactor = 1;

            if (s_ProcsFudgeFactor > 4)
                s_ProcsFudgeFactor = 4;
        }


        internal BufferAllocator(int maxFree) {
            _buffers = new Stack();
            _numFree = 0;
            _maxFree = maxFree * s_ProcsFudgeFactor;
        }

        internal /*public*/ Object GetBuffer() {
            Object buffer = null;

            if (_numFree > 0) {
                lock(this) {
                    if (_numFree > 0) {
                        buffer = _buffers.Pop();
                        _numFree--;
                    }
                }
            }

            if (buffer == null)
                buffer = AllocBuffer();

            return buffer;
        }

        internal void ReuseBuffer(Object buffer) {
            if (_numFree < _maxFree) {
                lock(this) {
                    if (_numFree < _maxFree) {
                        _buffers.Push(buffer);
                        _numFree++;
                    }
                }
            }
        }

        /*
         * To be implemented by a derived class
         */
        abstract protected Object AllocBuffer();
    }

    /*
     * Concrete allocator class for ubyte[] buffer recycling
     */
    internal class UbyteBufferAllocator : BufferAllocator {
        private int _bufferSize;

        internal UbyteBufferAllocator(int bufferSize, int maxFree)

        : base(maxFree) {
            _bufferSize = bufferSize;
        }

        protected override Object AllocBuffer() {
            return new byte[_bufferSize];
        }
    }

    /*
     * Concrete allocator class for char[] buffer recycling
     */
    internal class CharBufferAllocator : BufferAllocator {
        private int _bufferSize;

        internal CharBufferAllocator(int bufferSize, int maxFree)

        : base(maxFree) {
            _bufferSize = bufferSize;
        }

        protected override Object AllocBuffer() {
            return new char[_bufferSize];
        }
    }

    /*
     * Concrete allocator class for int[] buffer recycling
     */
    internal class IntegerArrayAllocator : BufferAllocator {
        private int _arraySize;

        internal IntegerArrayAllocator(int arraySize, int maxFree)

        : base(maxFree) {
            _arraySize = arraySize;
        }

        protected override Object AllocBuffer() {
            return new int[_arraySize];
        }
    }

    /*
     * Concrete allocator class for IntPtr[] buffer recycling
     */
    internal class IntPtrArrayAllocator : BufferAllocator {
        private int _arraySize;

        internal IntPtrArrayAllocator(int arraySize, int maxFree)

        : base(maxFree) {
            _arraySize = arraySize;
        }

        protected override Object AllocBuffer() {
            return new IntPtr[_arraySize];
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\crosssitescriptingvalidation.cs ===
//------------------------------------------------------------------------------
// <copyright file="CrossSiteScriptingValidation.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Detection of unsafe strings from the client (aee ASURT 122278 for details)
 * 
 */

namespace System.Web {
    using System;
    using System.Globalization;

    internal class CrossSiteScriptingValidation {
        internal CrossSiteScriptingValidation() {}

        private static bool IsAtoZ(char c) {
            return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
        }

        // Detect strings like "OnFocus="
        private static bool IsDangerousOnString(string s, int index) {
            // If the next character is not an 'n', it's safe
            if (s[index+1] != 'n' && s[index+1] != 'N') return false;
        
            // If the previous character is a letter, it's safe (e.g. "won")
            if (index > 0 && IsAtoZ(s[index-1])) return false;
        
            int len = s.Length;

            // Skip any number of letters, then any number of white spaces
            index += 2;
            while (index < len && IsAtoZ(s[index])) index++;
            while (index < len && Char.IsWhiteSpace(s[index])) index++;
        
            // If there is an equal, it's unsafe
            return (index < len && s[index] == '=');
        }

        // Detect strings like "javascript:"
        private static bool IsDangerousScriptString(string s, int index) {

            int len = s.Length;

            // Check for end of string case
            if (index+6 >= len) return false;

            // If the 's' is not followed by "cript", it's safe
            // We avoid calling String.Compare for perf reasons.
            if ((s[index+1] != 'c' && s[index+1] != 'C') ||
                (s[index+2] != 'r' && s[index+2] != 'R') ||
                (s[index+3] != 'i' && s[index+3] != 'I') ||
                (s[index+4] != 'p' && s[index+4] != 'P') ||
                (s[index+5] != 't' && s[index+5] != 'T')) return false;

            // Skip any number of white spaces
            index += 6;
            while (index < len && Char.IsWhiteSpace(s[index])) index++;
        
            // If there is a colon, it's unsafe
            return (index < len && s[index] == ':');
        }

        // Detect "expression(". (as in style="qqq:expression(alert('Attack!'))", see ASURT 127079)
        private static bool IsDangerousExpressionString(string s, int index) {

            // Check for end of string case
            if (index+10 >= s.Length) return false;

            // If the 'e' is not followed by an "x", it's safe.
            // This avoids calling String.Compare in most cases ("ex?" is rare)
            if (s[index+1] != 'x' && s[index+1] != 'X') return false;

            // Check the rest of the string
            return (String.Compare(
                s, index+2, "pression(", 0, 9, true /*ignoreCase*/,
                    CultureInfo.InvariantCulture) == 0);
        }

        // This check is equivalent to the regex "<[a-z]|<!|&#|\Won[a-z]*\s*=|(script\s*:)|expression("
        private static char[] startingChars = new char[] { '<', '&', 'o', 'O', 's', 'S' , 'e', 'E' };
        internal static bool IsDangerousString(string s, out int matchIndex) {
            matchIndex = 0;

            for (int i=0;;) {

                // Look for the start of one of our patterns
                int n = s.IndexOfAny(startingChars, i);
            
                // If not found, the string is safe
                if (n<0) return false;

                // If it's the last char, it's safe
                if (n == s.Length-1) return false;

                matchIndex = n;

                switch (s[n]) {
                case '<':
                    // If the < is followed by a letter or '!', it's unsafe (looks like a tag or HTML comment)
                    if (IsAtoZ(s[n+1]) || s[n+1] == '!') return true;
                    break;
                case '&':
                    // If the & is followed by a #, it's unsafe (e.g. &#83;)
                    if (s[n+1] == '#') return true;
                    break;
                case 'o':
                case 'O':
                    if (IsDangerousOnString(s, n))
                        return true;
                    break;
                case 's':
                case 'S':
                    if (IsDangerousScriptString(s, n))
                        return true;
                    break;
                case 'e':
                case 'E':
                    if (IsDangerousExpressionString(s, n))
                        return true;
                    break;
                }

                // Continue searching
                i=n+1;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpasyncresult.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpAsyncResult.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * ASP.NET simple internal implementation of IAsyncResult
 * 
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web {

    using System;
    using System.Threading;

    internal class HttpAsyncResult : IAsyncResult {
        private AsyncCallback _callback;
        private Object        _asyncState;

        private bool          _completed;
        private bool          _completedSynchronously;

        private Object        _result;
        private Exception     _error;


        /*
         * Constructor with pending result
         */
        internal HttpAsyncResult(AsyncCallback cb, Object state) {
            _callback    = cb;
            _asyncState  = state;
        }

        /*
         * Constructor with known result
         */
        internal HttpAsyncResult(AsyncCallback cb, Object state,
                                 bool completed, Object result, Exception error) {
            _callback    = cb;
            _asyncState  = state;

            _completed = completed;
            _completedSynchronously = completed;

            _result = result;
            _error = error;

            if (_completed && _callback != null)
                _callback(this);
        }

        /*
         * Helper method to process completions
         */
        internal void Complete(bool synchronous, Object result, Exception error) {
            _completed = true;
            _completedSynchronously = synchronous;
            _result = result;
            _error = error;

            if (_callback != null)
                _callback(this);
        }

        /*
         * Helper method to implement End call to async method
         */
        internal Object End() {
            if (_error != null)
                throw new HttpException(null, _error);

            return _result;
        }

        //
        // Properties that are not part of IAsyncResult
        //

        internal Exception   Error { get { return _error;}}

        //
        // IAsyncResult implementation
        //

        public bool         IsCompleted { get { return _completed;}}
        public bool         CompletedSynchronously { get { return _completedSynchronously;}}
        internal Object     AsyncObject { get { return null;}}
        public Object       AsyncState { get { return _asyncState;}}
        public WaitHandle   AsyncWaitHandle { get { return null;}} // wait not supported
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpapplicationstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="httpapplicationstate.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Application State Dictionary class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web {
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Security.Permissions;

    using System.Collections;
    using System.Collections.Specialized;
    using System.Web;
    using System.Web.Util;

    //
    //  Application state collection
    //
    
    /// <include file='doc\httpapplicationstate.uex' path='docs/doc[@for="HttpApplicationState"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The HttpApplicationState class enables developers to
    ///       share global information across multiple requests, sessions, and pipelines
    ///       within an ASP.NET application. (An ASP.NET application is the sum of all files, pages,
    ///       handlers, modules, and code
    ///       within the scope of a virtual directory and its
    ///       subdirectories on a single web server).
    ///    </para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpApplicationState : NameObjectCollectionBase {
        // app lock with auto-unlock feature
        private HttpApplicationStateLock _lock = new HttpApplicationStateLock();

        // static object collections
        private HttpStaticObjectsCollection _applicationStaticObjects;
        private HttpStaticObjectsCollection _sessionStaticObjects;

        internal HttpApplicationState() {
            _applicationStaticObjects = new HttpStaticObjectsCollection();
            _sessionStaticObjects = new HttpStaticObjectsCollection();
        }

        internal HttpApplicationState(HttpStaticObjectsCollection applicationStaticObjects,
                                      HttpStaticObjectsCollection sessionStaticObjects) {
            _applicationStaticObjects = applicationStaticObjects;

            if (_applicationStaticObjects == null)
                _applicationStaticObjects = new HttpStaticObjectsCollection();

            _sessionStaticObjects = sessionStaticObjects;

            if (_sessionStaticObjects == null)
                _sessionStaticObjects = new HttpStaticObjectsCollection();
        }

        //
        // Internal accessor to session static objects collection
        //

        internal HttpStaticObjectsCollection SessionStaticObjects {
            get { return _sessionStaticObjects;}
        }

        //
        // Implementation of standard collection stuff
        //

        /// <include file='doc\httpapplicationstate.uex' path='docs/doc[@for="HttpApplicationState.Count"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       the number of item objects in the application state collection.</para>
        /// </devdoc>
        public override int Count {
            get {
                int c = 0;
                _lock.AcquireRead(); try {
                    c = base.Count;
                }
                finally {
                    _lock.ReleaseRead();
                }

                return c;
            }
        }

        // modifying methods

        /// <include file='doc\httpapplicationstate.uex' path='docs/doc[@for="HttpApplicationState.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds
        ///       a new state object to the application state collection.
        ///    </para>
        /// </devdoc>
        public void Add(String name, Object value) {
            _lock.AcquireWrite(); try {
                BaseAdd(name, value);
            }
            finally {
                _lock.ReleaseWrite();
            }
        }

        /// <include file='doc\httpapplicationstate.uex' path='docs/doc[@for="HttpApplicationState.Set"]/*' />
        /// <devdoc>
        ///    <para>Updates an HttpApplicationState value within the collection.</para>
        /// </devdoc>
        public void Set(String name, Object value) {
            _lock.AcquireWrite(); try {
                BaseSet(name, value);
            }
            finally {
                _lock.ReleaseWrite();
            }
        }

        /// <include file='doc\httpapplicationstate.uex' path='docs/doc[@for="HttpApplicationState.Remove"]/*' />
        /// <devdoc>
        ///    <para>Removes
        ///       an
        ///       object from the application state collection by name.</para>
        /// </devdoc>
        public void Remove(String name) {
            _lock.AcquireWrite(); try {
                BaseRemove(name);
            }
            finally {
                _lock.ReleaseWrite();
            }
        }

        /// <include file='doc\httpapplicationstate.uex' path='docs/doc[@for="HttpApplicationState.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>Removes
        ///       an
        ///       object from the application state collection by name.</para>
        /// </devdoc>
        public void RemoveAt(int index) {
            _lock.AcquireWrite(); try {
                BaseRemoveAt(index);
            }
            finally {
                _lock.ReleaseWrite();
            }
        }

        /// <include file='doc\httpapplicationstate.uex' path='docs/doc[@for="HttpApplicationState.Clear"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes
        ///       all objects from the application state collection.
        ///    </para>
        /// </devdoc>
        public void Clear() {
            _lock.AcquireWrite(); try {
                BaseClear();
            }
            finally {
                _lock.ReleaseWrite();
            }
        }

        /// <include file='doc\httpapplicationstate.uex' path='docs/doc[@for="HttpApplicationState.RemoveAll"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes
        ///       all objects from the application state collection.
        ///    </para>
        /// </devdoc>
        public void RemoveAll() {
            Clear();
        }

        // access by key

        /// <include file='doc\httpapplicationstate.uex' path='docs/doc[@for="HttpApplicationState.Get"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Enables user to retrieve application state object by name.
        ///    </para>
        /// </devdoc>
        public Object Get(String name) {
            Object obj = null;
            _lock.AcquireRead(); try {
                obj = BaseGet(name);
            }
            finally {
                _lock.ReleaseRead();
            }

            return obj;
        }

        /// <include file='doc\httpapplicationstate.uex' path='docs/doc[@for="HttpApplicationState.this"]/*' />
        /// <devdoc>
        ///    <para>Enables
        ///       a user to add/remove/update a single application state object.</para>
        /// </devdoc>
        public Object this[String name]
        {
            get { return Get(name);}
            set { Set(name, value);}
        }

        // access by index

        /// <include file='doc\httpapplicationstate.uex' path='docs/doc[@for="HttpApplicationState.Get1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Enables user
        ///       to retrieve a single application state object by index.
        ///    </para>
        /// </devdoc>
        public Object Get(int index) {
            Object obj = null;

            _lock.AcquireRead(); try {
                obj = BaseGet(index);
            }
            finally {
                _lock.ReleaseRead();
            }

            return obj;
        }

        /// <include file='doc\httpapplicationstate.uex' path='docs/doc[@for="HttpApplicationState.GetKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Enables user to retrieve an application state object name by index.
        ///    </para>
        /// </devdoc>
        public String GetKey(int index) {
            String s = null;
            _lock.AcquireRead(); try {
                s = BaseGetKey(index);
            }
            finally {
                _lock.ReleaseRead();
            }

            return s;
        }

        /// <include file='doc\httpapplicationstate.uex' path='docs/doc[@for="HttpApplicationState.this1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Enables
        ///       user to retrieve an application state object by index.
        ///    </para>
        /// </devdoc>
        public Object this[int index]
        {
            get { return Get(index);}
        }

        // access to keys and values as arrays
        
        /// <include file='doc\httpapplicationstate.uex' path='docs/doc[@for="HttpApplicationState.AllKeys"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Enables user
        ///       to retrieve all application state object names in collection.
        ///    </para>
        /// </devdoc>
        public String[] AllKeys {
            get {
                String [] allKeys = null;

                _lock.AcquireRead(); try {
                    allKeys = BaseGetAllKeys();
                }
                finally {
                    _lock.ReleaseRead();
                }

                return allKeys;
            }
        }

        //
        // Public properties
        //

        /// <include file='doc\httpapplicationstate.uex' path='docs/doc[@for="HttpApplicationState.Contents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns "this". Provided for legacy ASP compatibility.
        ///    </para>
        /// </devdoc>
        public HttpApplicationState Contents {
            get { return this;}
        }

        /// <include file='doc\httpapplicationstate.uex' path='docs/doc[@for="HttpApplicationState.StaticObjects"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Exposes all objects declared via an &lt;object
        ///       runat=server&gt;&lt;/object&gt; tag within the ASP.NET application file.
        ///    </para>
        /// </devdoc>
        public HttpStaticObjectsCollection StaticObjects {
            get { return _applicationStaticObjects;}
        }

        //
        //  Locking support
        //

        /// <include file='doc\httpapplicationstate.uex' path='docs/doc[@for="HttpApplicationState.Lock"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Locks
        ///       access to all application state variables. Facilitates access
        ///       synchronization.
        ///    </para>
        /// </devdoc>
        public void Lock() {
            _lock.AcquireWrite();
        }

        /// <include file='doc\httpapplicationstate.uex' path='docs/doc[@for="HttpApplicationState.UnLock"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Unocks access to all application state variables. Facilitates access
        ///       synchronization.
        ///    </para>
        /// </devdoc>
        public void UnLock() {
            _lock.ReleaseWrite();
        }

        internal void EnsureUnLock() {
            _lock.EnsureReleaseWrite();
        }
    }


    //
    //  Recursive read-write lock that allows removing of all
    //  outstanding write locks from the current thread at once
    //
    internal class HttpApplicationStateLock : ReadWriteObjectLock {
        private int _recursionCount;
        private int _threadId;

        internal HttpApplicationStateLock() {
        }

        internal override void AcquireRead() {
            int currentThreadId = SafeNativeMethods.GetCurrentThreadId();

            if (_threadId != currentThreadId)
                base.AcquireRead();  // only if no write lock
        }

        internal override void ReleaseRead() {
            int currentThreadId = SafeNativeMethods.GetCurrentThreadId();

            if (_threadId != currentThreadId)
                base.ReleaseRead();  // only if no write lock
        }

        internal override void AcquireWrite() {
            int currentThreadId = SafeNativeMethods.GetCurrentThreadId();

            if (_threadId == currentThreadId) {
                _recursionCount++;
            }
            else {
                base.AcquireWrite();
                _threadId = currentThreadId;
                _recursionCount = 1;
            }
        }

        internal override void ReleaseWrite() {
            int currentThreadId = SafeNativeMethods.GetCurrentThreadId();

            if (_threadId == currentThreadId) {
                if (--_recursionCount == 0) {
                    _threadId = 0;
                    base.ReleaseWrite();
                }
            }
        }

        //
        // release all write locks held by the current thread
        //

        internal void EnsureReleaseWrite() {
            int currentThreadId = SafeNativeMethods.GetCurrentThreadId();

            if (_threadId == currentThreadId) {
                _threadId = 0;
                _recursionCount = 0;
                base.ReleaseWrite();
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\customerrors.cs ===
//------------------------------------------------------------------------------
// <copyright file="CustomErrors.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Custom errors support
 */
namespace System.Web {
    using System.Collections;
    using System.Configuration;
    using System.Web.Configuration;
    using System.Web.Util;
    using System.Xml;

    //
    // Custome errors class encapsulates custom erros config data
    //
    // Example:
    //
    //  <customErrors defaultredirect="http://myhost/error.aspx" mode="remoteonly">
    //  	  <error statuscode="500" redirect="http:/error/pages/callsupport.html">
    //  	  <error statuscode="404" redirect="http:/error/pages/adminmessage.html">
    //  	  <error statuscode="403" redirect="http:/error/pages/noaccess.html">
    //  </customErrors>
    //
    //

    internal enum CustomErrorsMode {
        On = 1,
        Off = 2,
        RemoteOnly = 3
    }

    internal class CustomErrors {
        private static CustomErrors _default;  // default settings if nothing in config

        private CustomErrorsMode _mode;
        private String           _defaultRedirect;
        private IDictionary      _codeRedirects;

        //
        // Get current settings
        //

        internal static CustomErrors GetSettings(HttpContext context) {
            return GetSettings(context, false);
        }

        internal static CustomErrors GetSettings(HttpContext context, bool canThrow) {
            CustomErrors ce = null;

            if (canThrow) {
                ce = (CustomErrors) context.GetConfig("system.web/customErrors");
            }
            else {
                ce = (CustomErrors) context.GetLKGConfig("system.web/customErrors");
            }

            if (ce == null) {
                if (_default == null)
                    _default = new CustomErrors();

                ce = _default;
            }

            return ce;
        }

        //
        // default constructor when no custom errors found in config
        //

        private CustomErrors() {
            _mode = CustomErrorsMode.RemoteOnly;
        }

        //
        // helper to create absolute redirect
        //

        private static String GetAbsoluteRedirect(String path, String basePath) {
            if (UrlPath.IsRelativeUrl(path)) {
                if (basePath == null || basePath.Length == 0)
                    basePath = "/";
                path = UrlPath.Combine(basePath, path);
            }

            return path;
        }

        //
        // constructor used by config section handler
        //
        internal CustomErrors(XmlNode node, String basePath, CustomErrors parent) {
            _mode = CustomErrorsMode.Off;

            // inherit parent settings

            if (parent != null) {
                _mode = parent._mode;
                _defaultRedirect = parent._defaultRedirect;

                if (parent._codeRedirects != null) {
                    _codeRedirects = new Hashtable();
                    for (IDictionaryEnumerator e = parent._codeRedirects.GetEnumerator(); e.MoveNext();)
                        _codeRedirects.Add(e.Key, e.Value);
                }
            }

            // add current settings

            XmlNode a;
            String redirect = null;

            // get default and mode from the main tag

            HandlerBase.GetAndRemoveStringAttribute(node, "defaultRedirect", ref redirect);

            if (redirect != null)
                _defaultRedirect = GetAbsoluteRedirect(redirect, basePath);

            int iMode = 0;
            a = HandlerBase.GetAndRemoveEnumAttribute(node, "mode", typeof(CustomErrorsMode), ref iMode);
            if (a != null) {
                _mode = (CustomErrorsMode)iMode;
            }

            // report errors on bad attribures
            HandlerBase.CheckForUnrecognizedAttributes(node);

            // child tags

            foreach (XmlNode child in node.ChildNodes) {

                if (HandlerBase.IsIgnorableAlsoCheckForNonElement(child))
                    continue;

                int status = 0; // set when req. attr. is read

                // only <error> is allowed

                if (child.Name != "error") {
                    HandlerBase.ThrowUnrecognizedElement(child);
                }

                // status code attribure

                a = HandlerBase.GetAndRemoveRequiredIntegerAttribute(child, "statusCode", ref status);
                if (status < 100 && status > 999) {
                    throw new ConfigurationException(
                                                    HttpRuntime.FormatResourceString(SR.Customerrors_invalid_statuscode),
                                                    a);
                }

                // redirect attribure
                redirect = HandlerBase.RemoveRequiredAttribute(child, "redirect");

                // errors on other attributes
                HandlerBase.CheckForUnrecognizedAttributes(child);
                // <error> tags contain no content
                HandlerBase.CheckForChildNodes(child);

                // remember

                if (_codeRedirects == null)
                    _codeRedirects = new Hashtable();

                _codeRedirects[status.ToString()] = GetAbsoluteRedirect(redirect, basePath);
            } 
        }

        //
        // Check if custom errors are enabled for a request
        //

        internal bool CustomErrorsEnabled(HttpRequest request) {
            switch (_mode) {
                case CustomErrorsMode.Off:
                    return false;

                case CustomErrorsMode.On:
                    return true;

                case CustomErrorsMode.RemoteOnly:
                    return(!request.IsLocal);

                default:
                    return false;
            }
        }

        //
        // Get the custom errors redirect string for a code
        //

        internal String GetRedirectString(int code) {
            String r = null;

            if (_codeRedirects != null)
                r = (String)_codeRedirects[code.ToString()];

            if (r == null)
                r = _defaultRedirect;

            return r;
        }
    }
}

//
// Config section handler for custom errors
//

namespace System.Web.Configuration {
    using System.Configuration;
    internal class CustomErrorsConfigHandler : IConfigurationSectionHandler {
        internal CustomErrorsConfigHandler() {
        }

        public virtual object Create(Object parent, Object configContextObj, Xml.XmlNode section) {
            // if called through client config don't even load HttpRuntime
            if (!HandlerBase.IsServerConfiguration(configContextObj))
                return null;

            HttpConfigurationContext httpConfigContext = (HttpConfigurationContext)configContextObj;
            return new CustomErrors(section, httpConfigContext.VirtualPath, (CustomErrors)parent);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpcacheparams.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpCacheParams.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Cache Vary class.  Wraps Vary header
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web {
    using System.Text;
    using System.Runtime.InteropServices;
    using System.Web.Util;
    using System.Security.Permissions;

    /// <include file='doc\HttpCacheParams.uex' path='docs/doc[@for="HttpCacheVaryByParams"]/*' />
    /// <devdoc>
    ///    <para>Indicates that a cache should contain multiple 
    ///       representations for a particular Uri. This class is an encapsulation that
    ///       provides a rich, type-safe way to set the Vary header.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpCacheVaryByParams {
        HttpDictionary  _parameters;
        int             _ignoreParams;
        bool            _isModified;
        bool            _paramsStar;

        internal HttpCacheVaryByParams() {
            Reset();
        }

        internal void Reset() {
            _isModified = false;
            _paramsStar = false;
            _parameters = null;
            _ignoreParams = -1;
        }

        /*
         * Reset based on the cached vary headers.
         */
        internal void ResetFromParams(String[] parameters) {
            int i, n;

            Reset();
            if (parameters != null) {
                _isModified = true;
                if (parameters[0].Length == 0) {
                    Debug.Assert(parameters.Length == 1, "parameters.Length == 1");

                    IgnoreParams = true;
                }
                else if (parameters[0].Equals("*")) {
                    Debug.Assert(parameters.Length == 1, "parameters.Length == 1");

                    _paramsStar = true;
                }
                else {
                    _parameters = new HttpDictionary();
                    for (i = 0, n = parameters.Length; i < n; i++) {
                        _parameters.SetValue(parameters[i], parameters[i]);
                    }
                }
            }
        }

        internal bool IsModified() {
            return _isModified;
        }

        internal bool AcceptsParams() {
            return _ignoreParams == 1 || _paramsStar || _parameters != null;
        }

        internal String[] GetParams() {
            String[]    s = null;
            Object      item;
            int         i, j, c, n;

            if (_ignoreParams == 1) {
                s =  new String[1] {""};
            }
            else if (_paramsStar) {
                s =  new String[1] {"*"};
            }
            else if (_parameters != null) {
                n = _parameters.Size;
                c = 0;
                for (i = 0; i < n; i++) {
                    item = _parameters.GetValue(i);
                    if (item != null) {
                        c++;
                    }
                }

                if (c > 0) {
                    s = new string[c];
                    j = 0;
                    for (i = 0; i < n; i++) {
                        item = _parameters.GetValue(i);
                        if (item != null) {
                            s[j] = (String) item;
                            j++;
                        }
                    }

                    Debug.Assert(j == c, "j == c");
                }
            }

            return s;
        }

        //
        // Public methods and properties
        //

        /// <include file='doc\HttpCacheParams.uex' path='docs/doc[@for="HttpCacheVaryByParams.this"]/*' />
        /// <devdoc>
        ///    <para> Default property.
        ///       Indexed property indicating that a cache should (or should not) vary according
        ///       to a custom header.</para>
        /// </devdoc>
        public bool this[String header]
        {
            get {
                if (header == null) {
                    throw new ArgumentNullException("header");
                }

                if (header.Length == 0) {
                    return _ignoreParams == 1;
                }
                else {
                    return _paramsStar || 
                           (_parameters != null && _parameters.GetValue(header) != null);
                }
            }

            set {
                if (header == null) {
                    throw new ArgumentNullException("header");
                }

                if (header.Length == 0) {
                    IgnoreParams = value;
                }
                /*
                 * Since adding a Vary parameter is more restrictive, we don't
                 * want components to be able to set a Vary parameter to false
                 * if another component has set it to true.
                 */
                else if (value) {
                    _isModified = true;
                    _ignoreParams = 0;
                    if (header.Equals("*")) {
                        _paramsStar = true;
                        _parameters = null;
                    }
                    else {
                        // set value to header if true or null if false
                        if (!_paramsStar) {
                            if (_parameters == null) {
                                _parameters = new HttpDictionary();
                            }

                            _parameters.SetValue(header, header);
                        }
                    }
                }
            }
        }

        /// <include file='doc\HttpCacheParams.uex' path='docs/doc[@for="HttpCacheVaryByParams.IgnoreParams"]/*' />
        public bool IgnoreParams {
            get {
                return _ignoreParams == 1;
            }

            set {
                // Don't ignore if params have been added
                if (_paramsStar || _parameters != null) {
                    return;
                }

                if (_ignoreParams == -1 || _ignoreParams == 1) {
                    _ignoreParams = value ? 1 : 0;
                    _isModified = true;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpcachepolicy.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpCachePolicy.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Cache Policy class
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web {
    using System.Text;
    using System.Threading;
    using System.Collections;
    using System.Globalization;
    using System.Web.Util;
    using System.Security.Cryptography;
    using Debug=System.Web.Util.Debug;
    using System.Web.Configuration;
    using System.Web.Caching;
    using System.Security.Permissions;

    //
    // Public constants for cache-control
    //
    
    /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCacheability"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides enumeration values for all cache-control header settings.
    ///    </para>
    /// </devdoc>
    public enum HttpCacheability {
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCacheability.NoCache"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates that
        ///       without a field name, a cache must force successful revalidation with the
        ///       origin server before satisfying the request. With a field name, the cache may
        ///       use the response to satisfy a subsequent request.
        ///    </para>
        /// </devdoc>
        NoCache = 1,
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCacheability.Private"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Default value. Specifies that the response is cachable only on the client,
        ///       not by shared caches.
        ///    </para>
        /// </devdoc>
        Private,
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCacheability.Server"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the response should only be cached at the server.
        ///       Clients receive headers equivalent to a NoCache directive.
        ///    </para>
        /// </devdoc>
        Server,
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCacheability.ServerAndNoCache"]/*' />
        ServerAndNoCache = Server,
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCacheability.Public"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the response is cachable by clients and shared caches.
        ///    </para>
        /// </devdoc>
        Public,
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCacheability.ServerAndPrivate"]/*' />
        ServerAndPrivate,
    }
    
    enum HttpCacheabilityLimits {
        MinValue = HttpCacheability.NoCache,
        MaxValue = HttpCacheability.ServerAndPrivate, 
        None = MaxValue + 1,          
    }
    
    /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCacheRevalidation"]/*' />
    /// <devdoc>
    ///    <para>
    ///       This class is a light abstraction over the Cache-Control: revalidation
    ///       directives.
    ///    </para>
    /// </devdoc>
    public enum HttpCacheRevalidation {
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCacheRevalidation.AllCaches"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates that Cache-Control: must-revalidate should be sent.
        ///    </para>
        /// </devdoc>
        AllCaches = 1,
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCacheRevalidation.ProxyCaches"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates that Cache-Control: proxy-revalidate should be sent.
        ///    </para>
        /// </devdoc>
        ProxyCaches = 2,
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCacheRevalidation.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Default value. Indicates that no property has been set. If this is set, no
        ///       cache revalitation directive is sent.
        ///    </para>
        /// </devdoc>
        None = 3,
    }
    
    enum HttpCacheRevalidationLimits {
        MinValue = HttpCacheRevalidation.AllCaches,
        MaxValue = HttpCacheRevalidation.None
    }
    
    
    /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpValidationStatus"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum HttpValidationStatus {
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpValidationStatus.Invalid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Invalid = 1,
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpValidationStatus.IgnoreThisRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        IgnoreThisRequest = 2,
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpValidationStatus.Valid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Valid = 3
    }

    /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCacheValidateHandler"]/*' />
    /// <devdoc>
    ///    <para>Called back when the handler wants validation on a cache
    ///       item before it's served from the cache. If any handler invalidates
    ///       the item, the item is evicted from the cache and the request is handled as
    ///       if a cache miss were generated.</para>
    /// </devdoc>
    public delegate void HttpCacheValidateHandler(
            HttpContext context, Object data, ref HttpValidationStatus validationStatus);

    sealed class ValidationCallbackInfo {
        internal readonly HttpCacheValidateHandler  handler;
        internal readonly Object                    data;

        internal ValidationCallbackInfo(HttpCacheValidateHandler handler, Object data) {
            this.handler = handler;
            this.data = data;
        }
    }

    sealed class HttpCachePolicySettings {
        /* internal access */
        readonly bool                       _isModified;
        readonly ValidationCallbackInfo[]   _validationCallbackInfo;
        readonly HttpResponseHeader         _headerCacheControl;  
        readonly HttpResponseHeader         _headerPragma;        
        readonly HttpResponseHeader         _headerExpires;       
        readonly HttpResponseHeader         _headerLastModified;  
        readonly HttpResponseHeader         _headerEtag;          
        readonly HttpResponseHeader         _headerVaryBy;        

        /* internal access */
        readonly bool                       _noServerCaching;                 
        readonly String                     _cacheExtension;                  
        readonly bool                       _noTransforms;                    
        readonly String[]                   _varyByHeaderValues;              
        readonly String[]                   _varyByParamValues;               
        readonly string                     _varyByCustom;                    
        readonly HttpCacheability           _cacheability;                    
        readonly bool                       _noStore;                         
        readonly String[]                   _privateFields;                   
        readonly String[]                   _noCacheFields;                   
        readonly DateTime                   _utcExpires;                         
        readonly bool                       _isExpiresSet;                    
        readonly TimeSpan                   _maxAge;                          
        readonly bool                       _isMaxAgeSet;                     
        readonly TimeSpan                   _proxyMaxAge;                     
        readonly bool                       _isProxyMaxAgeSet;                
        readonly int                        _slidingExpiration;               
        readonly TimeSpan                   _slidingDelta;
        readonly DateTime                   _utcTimestampCreated;
        readonly int                        _validUntilExpires;               
        readonly int                        _allowInHistory;
        readonly HttpCacheRevalidation      _revalidation;                    
        readonly DateTime                   _utcLastModified;                    
        readonly bool                       _isLastModifiedSet;               
        readonly String                     _etag;                            
        readonly bool                       _generateLastModifiedFromFiles;   
        readonly bool                       _generateEtagFromFiles;           

        internal HttpCachePolicySettings(
                bool                        isModified,
                ValidationCallbackInfo[]    validationCallbackInfo,
                bool                        noServerCaching,    
                String                      cacheExtension,     
                bool                        noTransforms,       
                String[]                    varyByHeaderValues, 
                String[]                    varyByParamValues,  
                string                      varyByCustom,       
                HttpCacheability            cacheability,
                bool                        noStore,                
                String[]                    privateFields,          
                String[]                    noCacheFields,          
                DateTime                    utcExpires,                
                bool                        isExpiresSet,           
                TimeSpan                    maxAge,                 
                bool                        isMaxAgeSet,            
                TimeSpan                    proxyMaxAge,            
                bool                        isProxyMaxAgeSet,       
                int                         slidingExpiration,      
                TimeSpan                    slidingDelta,
                DateTime                    utcTimestampCreated,
                int                         validUntilExpires,      
                int                         allowInHistory,
                HttpCacheRevalidation       revalidation,
                DateTime                    utcLastModified,                  
                bool                        isLastModifiedSet,             
                String                      etag,                          
                bool                        generateLastModifiedFromFiles, 
                bool                        generateEtagFromFiles,
                HttpResponseHeader          headerCacheControl,    
                HttpResponseHeader          headerPragma,          
                HttpResponseHeader          headerExpires,         
                HttpResponseHeader          headerLastModified,    
                HttpResponseHeader          headerEtag,            
                HttpResponseHeader          headerVaryBy) {

            _isModified                     = isModified                        ;
            _validationCallbackInfo         = validationCallbackInfo            ;

            _noServerCaching                = noServerCaching                   ;
            _cacheExtension                 = cacheExtension                    ;
            _noTransforms                   = noTransforms                      ;
            _varyByHeaderValues             = varyByHeaderValues                ;
            _varyByParamValues              = varyByParamValues                 ;
            _varyByCustom                   = varyByCustom                      ;
            _cacheability                   = cacheability                      ;
            _noStore                        = noStore                           ;
            _privateFields                  = privateFields                     ;
            _noCacheFields                  = noCacheFields                     ;
            _utcExpires                     = utcExpires                        ;
            _isExpiresSet                   = isExpiresSet                      ;
            _maxAge                         = maxAge                            ;
            _isMaxAgeSet                    = isMaxAgeSet                       ;
            _proxyMaxAge                    = proxyMaxAge                       ;
            _isProxyMaxAgeSet               = isProxyMaxAgeSet                  ;
            _slidingExpiration              = slidingExpiration                 ;
            _slidingDelta                   = slidingDelta                      ;
            _utcTimestampCreated            = utcTimestampCreated               ;
            _validUntilExpires              = validUntilExpires                 ;
            _allowInHistory                 = allowInHistory                    ;
            _revalidation                   = revalidation                      ;
            _utcLastModified                = utcLastModified                   ;
            _isLastModifiedSet              = isLastModifiedSet                 ;
            _etag                           = etag                              ;
            _generateLastModifiedFromFiles  = generateLastModifiedFromFiles     ;
            _generateEtagFromFiles          = generateEtagFromFiles             ;

            _headerCacheControl             = headerCacheControl                ;
            _headerPragma                   = headerPragma                      ;
            _headerExpires                  = headerExpires                     ;
            _headerLastModified             = headerLastModified                ;
            _headerEtag                     = headerEtag                        ;
            _headerVaryBy                   = headerVaryBy                      ;
        }

        internal bool                       IsModified              {get {return _isModified                ;}}
        internal ValidationCallbackInfo[]   ValidationCallbackInfo  {get {return _validationCallbackInfo    ;}}   

        internal HttpResponseHeader         HeaderCacheControl      {get {return _headerCacheControl        ;}}   
        internal HttpResponseHeader         HeaderPragma            {get {return _headerPragma              ;}}   
        internal HttpResponseHeader         HeaderExpires           {get {return _headerExpires             ;}}   
        internal HttpResponseHeader         HeaderLastModified      {get {return _headerLastModified        ;}}   
        internal HttpResponseHeader         HeaderEtag              {get {return _headerEtag                ;}}   
        internal HttpResponseHeader         HeaderVaryBy            {get {return _headerVaryBy              ;}}   

        internal bool                       NoServerCaching         {get {return _noServerCaching           ;}}   
        internal String                     CacheExtension          {get {return _cacheExtension            ;}}   
        internal bool                       NoTransforms            {get {return _noTransforms              ;}}   
        internal String[]                   VaryByHeaders           {get {
                    return (_varyByHeaderValues == null) ? null : (string[]) _varyByHeaderValues.Clone()    ;}} 

        internal String[]                   VaryByParams            {get {
                    return (_varyByParamValues == null) ? null : (string[]) _varyByParamValues.Clone()      ;}} 

        internal bool                       IgnoreParams            {get {
                    return _varyByParamValues != null && _varyByParamValues[0].Length == 0;}}

        internal HttpCacheability           CacheabilityInternal    {get { return _cacheability;}}
        internal HttpCacheability           Cacheability            {get {
                    return((int) _cacheability == (int) HttpCacheabilityLimits.None) ? 
                        HttpCacheability.Private :  // default when not set
                        _cacheability; }} 

        internal bool                       NoStore                 {get {return _noStore                   ;}}

        internal String[]                   PrivateFields           {get {
                    return (_privateFields == null) ? null : (string[]) _privateFields.Clone()              ;}}    

        internal String[]                   NoCacheFields           {get {
                return (_noCacheFields == null) ? null : (string[]) _noCacheFields.Clone()                  ;}}    

        internal DateTime                   UtcExpires              {get {return _utcExpires                ;}}     
        internal bool                       IsExpiresSet            {get {return _isExpiresSet              ;}}     
        internal TimeSpan                   MaxAge                  {get {return _maxAge                    ;}}     
        internal bool                       IsMaxAgeSet             {get {return _isMaxAgeSet               ;}}     
        internal TimeSpan                   ProxyMaxAge             {get {return _proxyMaxAge               ;}}     
        internal bool                       IsProxyMaxAgeSet        {get {return _isProxyMaxAgeSet          ;}}     

        internal int                        SlidingExpirationInternal {get {return _slidingExpiration       ;}}
        internal bool                       SlidingExpiration         {get {return _slidingExpiration == 1  ;}}

        internal TimeSpan                   SlidingDelta            {get {return _slidingDelta              ;}}
        internal DateTime                   UtcTimestampCreated     {get {return _utcTimestampCreated       ;}}

        internal int                        ValidUntilExpiresInternal {get {return _validUntilExpires       ;}}
        internal bool                       ValidUntilExpires       {get {
                return     _validUntilExpires == 1 
                        && !SlidingExpiration
                        && !GenerateLastModifiedFromFiles 
                        && !GenerateEtagFromFiles
                        && ValidationCallbackInfo == null;}}

        internal int                        AllowInHistoryInternal  {get {return _allowInHistory            ;}}

        internal HttpCacheRevalidation      Revalidation            {get {return _revalidation              ;}}       
        internal DateTime                   UtcLastModified         {get {return _utcLastModified           ;}}       
        internal bool                       IsLastModifiedSet       {get {return _isLastModifiedSet         ;}}       
        internal String                     ETag                    {get {return _etag                      ;}}       
        internal bool                       GenerateLastModifiedFromFiles {get {return _generateLastModifiedFromFiles;}}    
        internal bool                       GenerateEtagFromFiles         {get {return _generateEtagFromFiles        ;}}    

        internal string                     VaryByCustom            {get {return _varyByCustom              ;}}

        internal bool HasValidationPolicy() {
            return      ValidUntilExpires
                   ||   GenerateLastModifiedFromFiles  
                   ||   GenerateEtagFromFiles          
                   ||   ValidationCallbackInfo != null;
        }
    }


    /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy"]/*' />
    /// <devdoc>
    ///    <para>Contains methods for controlling the ASP.NET output cache.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpCachePolicy {
        static TimeSpan s_oneYear = new TimeSpan(TimeSpan.TicksPerDay * 366);
        static HttpResponseHeader   s_headerPragmaNoCache;
        static HttpResponseHeader   s_headerExpiresMinus1;

        bool                    _isModified;
        bool                    _noServerCaching;
        String                  _cacheExtension;
        bool                    _noTransforms;
        HttpCacheVaryByHeaders  _varyByHeaders;
        HttpCacheVaryByParams   _varyByParams;
        string                  _varyByCustom;

        HttpCacheability        _cacheability;
        bool                    _noStore;       
        HttpDictionary          _privateFields; 
        HttpDictionary          _noCacheFields; 

        DateTime                _utcExpires;           
        bool                    _isExpiresSet;      
        TimeSpan                _maxAge;            
        bool                    _isMaxAgeSet;       
        TimeSpan                _proxyMaxAge;       
        bool                    _isProxyMaxAgeSet;  
        int                     _slidingExpiration; 
        DateTime                _utcTimestampCreated;    
        TimeSpan                _slidingDelta; 
        DateTime                _utcTimestampRequest;    
        int                     _validUntilExpires; 
        int                     _allowInHistory;

        HttpCacheRevalidation   _revalidation;
        DateTime                _utcLastModified;      
        bool                    _isLastModifiedSet; 
        String                  _etag;              

        bool                    _generateLastModifiedFromFiles; 
        bool                    _generateEtagFromFiles;         

        ArrayList               _validationCallbackInfo;


        bool                    _useCachedHeaders;
        HttpResponseHeader      _headerCacheControl; 
        HttpResponseHeader      _headerPragma;       
        HttpResponseHeader      _headerExpires;      
        HttpResponseHeader      _headerLastModified; 
        HttpResponseHeader      _headerEtag;         
        HttpResponseHeader      _headerVaryBy;       

        bool                    _noMaxAgeInCacheControl;


        internal HttpCachePolicy() {
            _varyByHeaders = new HttpCacheVaryByHeaders();
            _varyByParams = new HttpCacheVaryByParams();
            Reset();
        }

        /*
         * Restore original values
         */
        internal void Reset() {
            _varyByHeaders.Reset();
            _varyByParams.Reset();

            _isModified = false;
            _noServerCaching = false;
            _cacheExtension = null;
            _noTransforms = false;
            _varyByCustom = null;
            _cacheability = (HttpCacheability) (int) HttpCacheabilityLimits.None;
            _noStore = false;
            _privateFields = null;
            _noCacheFields = null;
            _utcExpires = DateTime.MinValue;
            _isExpiresSet = false;
            _maxAge = TimeSpan.Zero;
            _isMaxAgeSet = false;
            _proxyMaxAge = TimeSpan.Zero;
            _isProxyMaxAgeSet = false;
            _slidingExpiration = -1;
            _slidingDelta = TimeSpan.Zero;
            _utcTimestampCreated = DateTime.MinValue;
            _utcTimestampRequest = DateTime.MinValue;
            _validUntilExpires = -1;
            _allowInHistory = -1;
            _revalidation = HttpCacheRevalidation.None;
            _utcLastModified = DateTime.MinValue;
            _isLastModifiedSet = false;
            _etag = null;

            _generateLastModifiedFromFiles = false; 
            _generateEtagFromFiles = false;         
            _validationCallbackInfo = null;       
        
            _useCachedHeaders = false;
            _headerCacheControl = null;
            _headerPragma = null;        
            _headerExpires = null;       
            _headerLastModified = null;  
            _headerEtag = null;          
            _headerVaryBy = null;       

            _noMaxAgeInCacheControl = false;
        }

        /*
         * Reset based on a cached response. Includes data needed to generate
         * header for a cached response.
         */
        internal void ResetFromHttpCachePolicySettings(
                HttpCachePolicySettings settings,
                DateTime                utcTimestampRequest) {

            int i, n;

            _utcTimestampRequest = utcTimestampRequest;

            _varyByHeaders.ResetFromHeaders(settings.VaryByHeaders);                          
            _varyByParams.ResetFromParams(settings.VaryByParams);

            _isModified                       = settings.IsModified;                    
            _noServerCaching                  = settings.NoServerCaching;               
            _cacheExtension                   = settings.CacheExtension;                
            _noTransforms                     = settings.NoTransforms;                  
            _varyByCustom                     = settings.VaryByCustom;
            _cacheability                     = settings.CacheabilityInternal;                  
            _noStore                          = settings.NoStore;
            _utcExpires                       = settings.UtcExpires;                       
            _isExpiresSet                     = settings.IsExpiresSet;                  
            _maxAge                           = settings.MaxAge;                        
            _isMaxAgeSet                      = settings.IsMaxAgeSet;                   
            _proxyMaxAge                      = settings.ProxyMaxAge;                   
            _isProxyMaxAgeSet                 = settings.IsProxyMaxAgeSet;              
            _slidingExpiration                = settings.SlidingExpirationInternal;             
            _slidingDelta                     = settings.SlidingDelta;
            _utcTimestampCreated              = settings.UtcTimestampCreated;
            _validUntilExpires                = settings.ValidUntilExpiresInternal;
            _allowInHistory                   = settings.AllowInHistoryInternal;
            _revalidation                     = settings.Revalidation;                  
            _utcLastModified                  = settings.UtcLastModified;                  
            _isLastModifiedSet                = settings.IsLastModifiedSet;             
            _etag                             = settings.ETag;                          
            _generateLastModifiedFromFiles    = settings.GenerateLastModifiedFromFiles; 
            _generateEtagFromFiles            = settings.GenerateEtagFromFiles;         

            _useCachedHeaders = true;
            _headerCacheControl = settings.HeaderCacheControl;
            _headerPragma = settings.HeaderPragma;        
            _headerExpires = settings.HeaderExpires;       
            _headerLastModified = settings.HeaderLastModified;  
            _headerEtag = settings.HeaderEtag;          
            _headerVaryBy = settings.HeaderVaryBy;        

            _noMaxAgeInCacheControl = false;

            if (settings.PrivateFields != null) {
                _privateFields = new HttpDictionary();
                for (i = 0, n = settings.PrivateFields.Length; i < n; i++) {
                    _privateFields.SetValue(settings.PrivateFields[i], settings.PrivateFields[i]);
                }
            }

            if (settings.NoCacheFields != null) {
                _noCacheFields = new HttpDictionary();
                for (i = 0, n = settings.NoCacheFields.Length; i < n; i++) {
                    _noCacheFields.SetValue(settings.NoCacheFields[i], settings.NoCacheFields[i]);
                }
            }

            if (settings.ValidationCallbackInfo != null) {
                _validationCallbackInfo = new ArrayList();
                for (i = 0, n = settings.ValidationCallbackInfo.Length; i < n; i++) {
                    _validationCallbackInfo.Add(new ValidationCallbackInfo(
                            settings.ValidationCallbackInfo[i].handler,
                            settings.ValidationCallbackInfo[i].data));
                }
            }
        }

        internal bool IsModified() {
            return _isModified || _varyByHeaders.IsModified() || _varyByParams.IsModified();
        }

        void Dirtied() {
            _isModified = true;
            _useCachedHeaders = false;
        }

        static internal void AppendValueToHeader(StringBuilder s, String value) {
            if (value != null && value.Length > 0) {
                if (s.Length > 0) {
                    s.Append(", ");
                }

                s.Append(value);
            }
        }

        static readonly string[] s_cacheabilityTokens = new String[]
        {
            null,           // no enum
            "no-cache",     // HttpCacheability.NoCache
            "private",      // HttpCacheability.Private
            "no-cache",     // HttpCacheability.ServerAndNoCache
            "public",       // HttpCacheability.Public
            "private",      // HttpCacheability.ServerAndPrivate
            null            // None - not specified
        };

        static readonly string[] s_revalidationTokens = new String[]
        {
            null,               // no enum
            "must-revalidate",  // HttpCacheRevalidation.AllCaches
            "proxy-revalidate", // HttpCacheRevalidation.ProxyCaches
            null                // HttpCacheRevalidation.None
        };

        static readonly int[] s_cacheabilityValues = new int[]
        {
            -1,     // no enum
            0,      // HttpCacheability.NoCache
            2,      // HttpCacheability.Private
            1,      // HttpCacheability.ServerAndNoCache
            4,      // HttpCacheability.Public
            3,      // HttpCacheability.ServerAndPrivate
            100,    // None - though private by default, an explicit set will override
        };

        /*
         * Calculate LastModified and ETag
         * 
         * The LastModified date is the latest last-modified date of 
         * every file that is added as a dependency.
         * 
         * The ETag is generated by concatentating the appdomain id, 
         * filenames and last modified dates of all files into a single string, 
         * then hashing it and Base 64 encoding the hash.
         */
        void UpdateFromDependencies(HttpResponse response) {
            string[]        fileDependencies;
            string[]        cacheItemDependencies;
            DateTime        utcFileLastModifiedMax;
            DateTime        utcFileLastModified;
            long            length;
            StringBuilder   sb = null;
            DateTime        utcNow;

            if (!_generateLastModifiedFromFiles && !_generateEtagFromFiles) {
                return;
            }

            fileDependencies = response.GetFileDependencies();
            cacheItemDependencies = response.GetCacheItemDependencies();

            if (fileDependencies == null && cacheItemDependencies == null) {
                return;
            }

            utcFileLastModifiedMax = _utcLastModified;

            if (_generateEtagFromFiles) {
                sb = new StringBuilder(HttpRuntime.AppDomainIdInternal);
            }

            if (fileDependencies != null) {
                FileChangesMonitor fmon = HttpRuntime.FileChangesMonitor;
                foreach (string filename in fileDependencies) {
                    fmon.UtcGetFileAttributes(filename, out utcFileLastModified, out length);
                    if (utcFileLastModifiedMax < utcFileLastModified) {
                        utcFileLastModifiedMax = utcFileLastModified;
                    }

                    if (_generateEtagFromFiles) {
                        sb.Append(filename);
                        sb.Append(utcFileLastModified.Ticks.ToString());
                        sb.Append(length.ToString());
                    }
                }
            }

            if (cacheItemDependencies != null) {
                Cache cachePublic = HttpRuntime.Cache;
                foreach (string cacheKey in cacheItemDependencies) {
                    CacheEntry entry = (CacheEntry) cachePublic.Get(cacheKey, CacheGetOptions.ReturnCacheEntry);
                    if (entry != null) {
                        DateTime utcCreated = entry.UtcCreated;
                        if (utcFileLastModifiedMax < utcCreated) {
                            utcFileLastModifiedMax = utcCreated;
                        }

                        if (_generateEtagFromFiles) {
                            sb.Append(cacheKey);
                            sb.Append(utcCreated.Ticks.ToString());
                        }
                    }
                }
            }

            // account for difference between file system time 
            // and DateTime.Now. On some machines it appears that
            // the last modified time is further in the future
            // that DateTime.Now
            utcNow = DateTime.UtcNow;
            if (utcFileLastModifiedMax > utcNow) {
                utcFileLastModifiedMax = utcNow;
            }

            if (_generateLastModifiedFromFiles) {
                UtcSetLastModified(utcFileLastModifiedMax);
            }

            if (_generateEtagFromFiles) {
                sb.Append("+LM");
                sb.Append(utcFileLastModifiedMax.Ticks.ToString());

                _etag = MachineKey.HashAndBase64EncodeString(sb.ToString());
            }
        }


        void UpdateCachedHeaders(HttpResponse response) {
            StringBuilder       sb;
            HttpCacheability    cacheability;
            int                 i, n;
            String              expirationDate;           
            String              lastModifiedDate;         
            String              varyByHeaders;            

            if (_useCachedHeaders) {
                return;
            }

            Debug.Assert((_utcTimestampCreated == DateTime.MinValue && _utcTimestampRequest == DateTime.MinValue) ||
                         (_utcTimestampCreated != DateTime.MinValue && _utcTimestampRequest != DateTime.MinValue),
                        "_utcTimestampCreated and _utcTimestampRequest are out of sync in UpdateCachedHeaders");

            if (_utcTimestampCreated == DateTime.MinValue) {
                _utcTimestampCreated = _utcTimestampRequest = response.Context.UtcTimestamp;
            }

            if (_slidingExpiration != 1) {
                _slidingDelta = TimeSpan.Zero;
            }
            else if (_isMaxAgeSet) {
                _slidingDelta = _maxAge;
            }
            else if (_isExpiresSet) {
                _slidingDelta = _utcExpires - _utcTimestampCreated;
            }
            else {
                _slidingDelta = TimeSpan.Zero;
            }

            _headerCacheControl = null;
            _headerPragma = null;      
            _headerExpires = null;     
            _headerLastModified = null;
            _headerEtag = null;        
            _headerVaryBy = null;      

            UpdateFromDependencies(response);

            /*
             * Cache control header
             */
            sb = new StringBuilder();

            if (_cacheability == (HttpCacheability) (int) HttpCacheabilityLimits.None) {
                cacheability = HttpCacheability.Private;
            }
            else {
                cacheability = _cacheability;
            }

            AppendValueToHeader(sb, s_cacheabilityTokens[(int) cacheability]);

            if (cacheability == HttpCacheability.Public && _privateFields != null) {
                Debug.Assert(_privateFields.Size > 0);

                AppendValueToHeader(sb, "private=\"");
                sb.Append(_privateFields.GetKey(0));
                for (i = 1, n = _privateFields.Size; i < n; i++) {
                    AppendValueToHeader(sb, _privateFields.GetKey(i));
                }

                sb.Append('\"');
            }

            if (    cacheability != HttpCacheability.NoCache &&
                    cacheability != HttpCacheability.ServerAndNoCache && 
                    _noCacheFields != null) {

                Debug.Assert(_noCacheFields.Size > 0);

                AppendValueToHeader(sb, "no-cache=\"");
                sb.Append(_noCacheFields.GetKey(0));
                for (i = 1, n = _noCacheFields.Size; i < n; i++) {
                    AppendValueToHeader(sb, _noCacheFields.GetKey(i));
                }

                sb.Append('\"');
            }

            if (_noStore) {
                AppendValueToHeader(sb, "no-store");
            }

            AppendValueToHeader(sb, s_revalidationTokens[(int)_revalidation]);

            if (_noTransforms) {
                AppendValueToHeader(sb, "no-transform");
            }

            if (_cacheExtension != null) {
                AppendValueToHeader(sb, _cacheExtension);
            }


            /*
             * don't send expiration information when item shouldn't be cached
             * for cached header, only add max-age when it doesn't change
             * based on the time requested
             */
            if (      _slidingExpiration == 1                 
                 &&   cacheability != HttpCacheability.NoCache
                 &&   cacheability != HttpCacheability.ServerAndNoCache) {
                
                if (_isMaxAgeSet && !_noMaxAgeInCacheControl) {
                    AppendValueToHeader(sb, "max-age=" + ((long)_maxAge.TotalSeconds).ToString());
                }
    
                if (_isProxyMaxAgeSet && !_noMaxAgeInCacheControl) {
                    AppendValueToHeader(sb, "s-maxage=" + ((long)(_proxyMaxAge).TotalSeconds).ToString());
                }
            }

            if (sb.Length > 0) {
                _headerCacheControl = new HttpResponseHeader(HttpWorkerRequest.HeaderCacheControl, sb.ToString());
            }

            /*
             * Pragma: no-cache and Expires: -1
             */
            if (cacheability == HttpCacheability.NoCache || cacheability == HttpCacheability.ServerAndNoCache) {
                if (s_headerPragmaNoCache == null) {
                    s_headerPragmaNoCache = new HttpResponseHeader(HttpWorkerRequest.HeaderPragma, "no-cache");
                }

                _headerPragma = s_headerPragmaNoCache;

                if (_allowInHistory != 1) {
                    if (s_headerExpiresMinus1 == null) {
                        s_headerExpiresMinus1 = new HttpResponseHeader(HttpWorkerRequest.HeaderExpires, "-1");
                    }

                    _headerExpires = s_headerExpiresMinus1;
                }
            }
            else {
                /*
                 * Expires header.
                 */
                if (_isExpiresSet && _slidingExpiration != 1) {
                    expirationDate = HttpUtility.FormatHttpDateTimeUtc(_utcExpires);
                    _headerExpires = new HttpResponseHeader(HttpWorkerRequest.HeaderExpires, expirationDate);
                }

                /*
                 * Last Modified header.
                 */
                if (_isLastModifiedSet) {
                    lastModifiedDate = HttpUtility.FormatHttpDateTimeUtc(_utcLastModified);
                    _headerLastModified = new HttpResponseHeader(HttpWorkerRequest.HeaderLastModified, lastModifiedDate);
                }


                if (cacheability != HttpCacheability.Private) {
                    /*
                     * Etag.
                     */
                    if (_etag != null) {
                        _headerEtag = new HttpResponseHeader(HttpWorkerRequest.HeaderEtag, _etag);
                    }

                    /*
                     * Vary
                     */
                    if (    cacheability == HttpCacheability.ServerAndPrivate || 
                            _varyByCustom != null || 
                            (_varyByParams.IsModified() && !_varyByParams.IgnoreParams)) {

                        varyByHeaders = "*";
                    }
                    else {
                        varyByHeaders = _varyByHeaders.ToHeaderString();
                    }

                    if (varyByHeaders != null) {
                        _headerVaryBy = new HttpResponseHeader(HttpWorkerRequest.HeaderVary, varyByHeaders);
                    }
                }
            }

            _useCachedHeaders = true;
        }



        /*
         * Generate headers and append them to the list
         */
        internal void GetHeaders(ArrayList headers, HttpResponse response) {
            StringBuilder       sb;
            String              expirationDate;           
            TimeSpan            age, maxAge, proxyMaxAge; 
            DateTime            utcExpires;                  
            HttpResponseHeader  headerExpires;
            HttpResponseHeader  headerCacheControl;

            UpdateCachedHeaders(response);
            headerExpires = _headerExpires;
            headerCacheControl = _headerCacheControl;

            /* 
             * reconstruct headers that vary with time 
             * don't send expiration information when item shouldn't be cached
             */
            if (_cacheability != HttpCacheability.NoCache && _cacheability != HttpCacheability.ServerAndNoCache) {
                if (_slidingExpiration == 1) {
                    /* update Expires header */
                    if (_isExpiresSet) {
                        utcExpires = _utcTimestampRequest + _slidingDelta;
                        expirationDate = HttpUtility.FormatHttpDateTimeUtc(utcExpires);
                        headerExpires = new HttpResponseHeader(HttpWorkerRequest.HeaderExpires, expirationDate);
                    }
                }
                else {
                    if (_isMaxAgeSet || _isProxyMaxAgeSet) {
                        /* update max-age, s-maxage components of Cache-Control header */
                        if (headerCacheControl != null) {
                            sb = new StringBuilder(headerCacheControl.Value);
                        }
                        else {
                            sb = new StringBuilder();
                        }

                        age = _utcTimestampRequest - _utcTimestampCreated;
                        if (_isMaxAgeSet) {
                            maxAge = _maxAge - age;
                            if (maxAge < TimeSpan.Zero) {
                                maxAge = TimeSpan.Zero;
                            }

                            if (!_noMaxAgeInCacheControl)
                                AppendValueToHeader(sb, "max-age=" + ((long)maxAge.TotalSeconds).ToString());
                        }

                        if (_isProxyMaxAgeSet) {
                            proxyMaxAge = _proxyMaxAge - age;
                            if (proxyMaxAge < TimeSpan.Zero) {
                                proxyMaxAge = TimeSpan.Zero;
                            }

                            if (!_noMaxAgeInCacheControl)
                                AppendValueToHeader(sb, "s-maxage=" + ((long)(proxyMaxAge).TotalSeconds).ToString());
                        }

                        headerCacheControl = new HttpResponseHeader(HttpWorkerRequest.HeaderCacheControl, sb.ToString());
                    }
                }
            }

            if (headerCacheControl != null) {
                headers.Add(headerCacheControl);
            }

            if (_headerPragma != null) {
                headers.Add(_headerPragma);
            }

            if (headerExpires != null) {
                headers.Add(headerExpires);
            }

            if (_headerLastModified != null) {
                headers.Add(_headerLastModified);
            }

            if (_headerEtag != null) {
                headers.Add(_headerEtag);
            }

            if (_headerVaryBy != null) {
                headers.Add(_headerVaryBy);
            }
        }

        /*
         * Public methods
         */

        internal HttpCachePolicySettings GetCurrentSettings(HttpResponse response) {
            String[]                    varyByHeaders;
            String[]                    varyByParams;
            String[]                    privateFields;
            String[]                    noCacheFields;
            ValidationCallbackInfo[]    validationCallbackInfo;
            
            UpdateCachedHeaders(response);

            varyByHeaders = _varyByHeaders.GetHeaders();
            varyByParams = _varyByParams.GetParams();

            if (_privateFields != null) {
                privateFields = _privateFields.GetAllKeys();
            }
            else {
                privateFields = null;
            }

            if (_noCacheFields != null) {
                noCacheFields = _noCacheFields.GetAllKeys();
            }
            else {
                noCacheFields = null;
            }

            if (_validationCallbackInfo != null) {
                validationCallbackInfo = new ValidationCallbackInfo[_validationCallbackInfo.Count];
                _validationCallbackInfo.CopyTo(0, validationCallbackInfo, 0, _validationCallbackInfo.Count);
            }
            else {
                validationCallbackInfo = null;
            }

            return new HttpCachePolicySettings(
                    _isModified,                   
                    validationCallbackInfo,
                    _noServerCaching,   
                    _cacheExtension,             
                    _noTransforms,
                    varyByHeaders,                  
                    varyByParams,                  
                    _varyByCustom,
                    _cacheability,                 
                    _noStore,
                    privateFields,
                    noCacheFields,               
                    _utcExpires,                      
                    _isExpiresSet,                 
                    _maxAge,                       
                    _isMaxAgeSet,                  
                    _proxyMaxAge,                  
                    _isProxyMaxAgeSet,             
                    _slidingExpiration,            
                    _slidingDelta,
                    _utcTimestampCreated,
                    _validUntilExpires,
                    _allowInHistory,
                    _revalidation,                 
                    _utcLastModified,                 
                    _isLastModifiedSet,            
                    _etag,                         
                    _generateLastModifiedFromFiles,
                    _generateEtagFromFiles,
                    _headerCacheControl, 
                    _headerPragma,       
                    _headerExpires,      
                    _headerLastModified,
                    _headerEtag,
                    _headerVaryBy);
        }

        internal bool   HasValidationPolicy() {

            return      _generateLastModifiedFromFiles  
                   ||   _generateEtagFromFiles          
                   ||   _validationCallbackInfo != null 
                   ||  (_validUntilExpires == 1 && _slidingExpiration != 1);

        }

        internal bool   HasExpirationPolicy() {
            return _slidingExpiration != 1 && (_isExpiresSet || _isMaxAgeSet);
        }

        internal bool   IsKernelCacheable() {
            return  _cacheability == HttpCacheability.Public
                && !_noServerCaching
                && HasExpirationPolicy()
                && _cacheExtension == null
                && !_varyByHeaders.IsModified()
                && (!_varyByParams.IsModified() || _varyByParams.IgnoreParams)
                && !_noStore
                && _varyByCustom == null
                && _privateFields == null
                && _noCacheFields == null
                && _validationCallbackInfo == null;
        }

        internal DateTime UtcGetAbsoluteExpiration() {
            DateTime absoluteExpiration = Cache.NoAbsoluteExpiration;

            Debug.Assert(_utcTimestampCreated != DateTime.MinValue, "_utcTimestampCreated != DateTime.MinValue");
            if (_slidingExpiration != 1) {
                if (_isMaxAgeSet) {
                    absoluteExpiration = _utcTimestampCreated + _maxAge;
                }
                else if (_isExpiresSet) {
                    absoluteExpiration = _utcExpires;
                }
            }

            return absoluteExpiration;
        }

        /*
         * Cache at server?
         */
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.SetNoServerCaching"]/*' />
        /// <devdoc>
        ///    <para>A call to this method stops all server caching for the current response. </para>
        /// </devdoc>
        public void SetNoServerCaching() {
            Dirtied();
            _noServerCaching = true;
        }

        internal bool GetNoServerCaching() {
            return _noServerCaching;
        }

        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.SetVaryByCustom"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetVaryByCustom(string custom) {
            if (custom == null) {
                throw new ArgumentNullException("custom");
            }

            if (_varyByCustom != null) {
                throw new InvalidOperationException(HttpRuntime.FormatResourceString(SR.VaryByCustom_already_set));
            }

            Dirtied();
            _varyByCustom = custom;
        }

        /*
         * Cache-Control: extension        
         */
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.AppendCacheExtension"]/*' />
        /// <devdoc>
        ///    <para>Appends a cache control extension directive to the Cache-Control: header.</para>
        /// </devdoc>
        public void AppendCacheExtension(String extension) {
            if (extension == null) {
                throw new ArgumentNullException("extension");
            }

            Dirtied();
            if (_cacheExtension == null) {
                _cacheExtension = extension;
            }
            else {
                _cacheExtension = _cacheExtension + ", " + extension;
            }
        }

        /*
         * Cache-Control: no-transform        
         */
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.SetNoTransforms"]/*' />
        /// <devdoc>
        ///    <para>Enables the sending of the CacheControl:
        ///       no-transform directive.</para>
        /// </devdoc>
        public void SetNoTransforms() {
            Dirtied();
            _noTransforms = true;
        }

        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.VaryByHeaders"]/*' />
        /// <devdoc>
        ///    <para>Contains policy for the Vary: header.</para>
        /// </devdoc>
        public HttpCacheVaryByHeaders VaryByHeaders { 
            get {
                return _varyByHeaders;
            }
        }

        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.VaryByParams"]/*' />
        /// <devdoc>
        ///    <para>Contains params to vary GETs and POSTs by.</para>
        /// </devdoc>
        public HttpCacheVaryByParams VaryByParams { 
            get {
                return _varyByParams;
            }
        }

        /*
         * Cacheability policy
         * 
         * Cache-Control: public | private[=1#field] | no-cache[=1#field] | no-store
         */
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.SetCacheability"]/*' />
        /// <devdoc>
        ///    <para>Sets the Cache-Control header to one of the values of 
        ///       HttpCacheability. This is used to enable the Cache-Control: public, private, and no-cache directives.</para>
        /// </devdoc>
        public void SetCacheability(HttpCacheability cacheability) {
            if ((int) cacheability < (int) HttpCacheabilityLimits.MinValue || 
                (int) HttpCacheabilityLimits.MaxValue < (int) cacheability) {

                throw new ArgumentOutOfRangeException("cacheability");
            }

            if (s_cacheabilityValues[(int)cacheability] < s_cacheabilityValues[(int)_cacheability]) {
                Dirtied();
                _cacheability = cacheability;
            }
        }

        internal HttpCacheability GetCacheability() {
            return _cacheability;
        }

        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.SetCacheability1"]/*' />
        /// <devdoc>
        ///    <para>Sets the Cache-Control header to one of the values of HttpCacheability in 
        ///       conjunction with a field-level exclusion directive.</para>
        /// </devdoc>
        public void SetCacheability(HttpCacheability cacheability, String field) {
            if (field == null) {
                throw new ArgumentNullException("field");
            }

            switch (cacheability) {
                case HttpCacheability.Private:
                    if (_privateFields == null) {
                        _privateFields = new HttpDictionary();
                    }

                    _privateFields.SetValue(field, field);

                    break;

                case HttpCacheability.NoCache:
                    if (_noCacheFields == null) {
                        _noCacheFields = new HttpDictionary();
                    }

                    _noCacheFields.SetValue(field, field);

                    break;

                default:
                    throw new ArgumentException(
                            HttpRuntime.FormatResourceString(SR.Cacheability_for_field_must_be_private_or_nocache),
                            "cacheability");
            }

            Dirtied();
        }


        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.SetNoStore"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetNoStore() {
            Dirtied();
            _noStore = true;
        }

        /*
         * Expiration policy.
         */

        /*
         * Expires: RFC date
         */
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.SetExpires"]/*' />
        /// <devdoc>
        ///    <para>Sets the Expires: header to the given absolute date.</para>
        /// </devdoc>
        public void SetExpires(DateTime date) {
            DateTime utcDate;

            utcDate = DateTimeUtil.ConvertToUniversalTime(date);

            if (!_isExpiresSet || utcDate < _utcExpires) {
                Dirtied();
                _utcExpires = utcDate;
                _isExpiresSet = true;
            }
        }

        /*
         * Cache-Control: max-age=delta-seconds
         */
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.SetMaxAge"]/*' />
        /// <devdoc>
        ///    <para>Sets Cache-Control: s-maxage based on the specified time span</para>
        /// </devdoc>
        public void SetMaxAge(TimeSpan delta) {
            if (delta < TimeSpan.Zero || s_oneYear < delta) {
                throw new ArgumentOutOfRangeException("delta");
            }

            if (!_isMaxAgeSet || delta < _maxAge) {
                Dirtied();
                _maxAge = delta;
                _isMaxAgeSet = true;
            }
        }

        // Suppress max-age and s-maxage in cache-control header (required for IIS6 kernel mode cache)
        internal void SetNoMaxAgeInCacheControl() {
            _noMaxAgeInCacheControl = true;
        }

        /*
         * Cache-Control: s-maxage=delta-seconds
         */
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.SetProxyMaxAge"]/*' />
        /// <devdoc>
        ///    <para>Sets the Cache-Control: s-maxage header based on the specified time span.</para>
        /// </devdoc>
        public void SetProxyMaxAge(TimeSpan delta) {
            if (delta < TimeSpan.Zero) {
                throw new ArgumentOutOfRangeException("delta");
            }

            if (!_isProxyMaxAgeSet || delta < _proxyMaxAge) {
                Dirtied();
                _proxyMaxAge = delta;
                _isProxyMaxAgeSet = true;
            }
        }

        /*
         * Sliding Expiration
         */
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.SetSlidingExpiration"]/*' />
        /// <devdoc>
        ///    <para>Make expiration sliding: that is, if cached, it should be renewed with each
        ///       response. This feature is identical in spirit to the IIS
        ///       configuration option to add an expiration header relative to the current response
        ///       time. This feature is identical in spirit to the IIS configuration option to add
        ///       an expiration header relative to the current response time.</para>
        /// </devdoc>
        public void SetSlidingExpiration(bool slide) {
            if (_slidingExpiration == -1 || _slidingExpiration == 1) {
                Dirtied();
                _slidingExpiration = (slide) ? 1 : 0;
            }
        }

        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.SetValidUntilExpires"]/*' />
        public void SetValidUntilExpires(bool validUntilExpires) {
            if (_validUntilExpires == -1 || _validUntilExpires == 1) {
                Dirtied();
                _validUntilExpires = (validUntilExpires) ? 1 : 0;
            }
        }

        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.SetAllowResponseInBrowserHistory"]/*' />
        public void SetAllowResponseInBrowserHistory(bool allow) {
            if (_allowInHistory == -1 || _allowInHistory == 1) {
                Dirtied();
                _allowInHistory = (allow) ? 1 : 0;
            }
        }

        /* 
         * Validation policy. 
         */

        /*
         * Cache-control: must-revalidate | proxy-revalidate
         */
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.SetRevalidation"]/*' />
        /// <devdoc>
        ///    <para>Set the Cache-Control: header to reflect either the must-revalidate or 
        ///       proxy-revalidate directives based on the supplied value. The default is to
        ///       not send either of these directives unless explicitly enabled using this
        ///       method.</para>
        /// </devdoc>
        public void SetRevalidation(HttpCacheRevalidation revalidation) {
            if ((int) revalidation < (int) HttpCacheRevalidationLimits.MinValue || 
                (int) HttpCacheRevalidationLimits.MaxValue < (int) revalidation) {
                throw new ArgumentOutOfRangeException("revalidation");
            }

            if ((int) revalidation < (int) _revalidation) {
                Dirtied();
                _revalidation = revalidation;
            }
        }

        /*
         * Etag
         */
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.SetETag"]/*' />
        /// <devdoc>
        ///    <para>Set the ETag header to the supplied string. Once an ETag is set, 
        ///       subsequent attempts to set it will fail and an exception will be thrown.</para>
        /// </devdoc>
        public void SetETag(String etag) {
            if (etag == null) {
                throw new ArgumentNullException("etag");
            }

            if (_etag != null) {
                throw new InvalidOperationException(HttpRuntime.FormatResourceString(SR.Etag_already_set));
            }

            if (_generateEtagFromFiles) {
                throw new InvalidOperationException(HttpRuntime.FormatResourceString(SR.Cant_both_set_and_generate_Etag));
            }

            Dirtied();
            _etag = etag;
        }

        /*
         * Last-Modified: RFC Date
         */
        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.SetLastModified"]/*' />
        /// <devdoc>
        ///    <para>Set the Last-Modified: header to the DateTime value supplied. If this 
        ///       violates the restrictiveness hierarchy, this method will fail.</para>
        /// </devdoc>
        public void SetLastModified(DateTime date) {
            DateTime utcDate = DateTimeUtil.ConvertToUniversalTime(date);
            UtcSetLastModified(utcDate);
        }

        void UtcSetLastModified(DateTime utcDate) {

            /*
             * Because HTTP dates have a resolution of 1 second, we
             * need to store dates with 1 second resolution or comparisons
             * will be off.
             */

            utcDate = new DateTime(utcDate.Ticks - (utcDate.Ticks % TimeSpan.TicksPerSecond));
            if (utcDate > DateTime.UtcNow) {
                throw new ArgumentOutOfRangeException("date");
            }

            if (!_isLastModifiedSet || utcDate > _utcLastModified) {
                Dirtied();
                _utcLastModified = utcDate;
                _isLastModifiedSet = true;
            }
        }

        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.SetLastModifiedFromFileDependencies"]/*' />
        /// <devdoc>
        ///    <para>Sets the Last-Modified: header based on the timestamps of the
        ///       file dependencies of the handler.</para>
        /// </devdoc>
        public void SetLastModifiedFromFileDependencies() {
            Dirtied();
            _generateLastModifiedFromFiles = true; 
        }

        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.SetETagFromFileDependencies"]/*' />
        /// <devdoc>
        ///    <para>Sets the Etag header based on the timestamps of the file 
        ///       dependencies of the handler.</para>
        /// </devdoc>
        public void SetETagFromFileDependencies() {
            if (_etag != null) {
                throw new InvalidOperationException(HttpRuntime.FormatResourceString(SR.Cant_both_set_and_generate_Etag));
            }

            Dirtied();
            _generateEtagFromFiles = true;         
        }

        /// <include file='doc\HttpCachePolicy.uex' path='docs/doc[@for="HttpCachePolicy.AddValidationCallback"]/*' />
        /// <devdoc>
        ///    <para>Registers a validation callback for the current response.</para>
        /// </devdoc>
        public void AddValidationCallback(
                HttpCacheValidateHandler handler, Object data) {

            if (handler == null) {
                throw new ArgumentNullException("handler");
            }

            Dirtied();
            if (_validationCallbackInfo == null) {
                _validationCallbackInfo = new ArrayList();
            }

            _validationCallbackInfo.Add(new ValidationCallbackInfo(handler, data));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\filechangesmonitor.cs ===
//------------------------------------------------------------------------------
// <copyright file="FileChangesMonitor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web {

    using System.Text;
    using System.Globalization;
    using System.Threading;
    using System.Runtime.InteropServices;    
    using System.Collections;    
    using System.Collections.Specialized;
    using System.Web.Util;
    using System.IO;
    using System.Security;
    using System.Security.Permissions;

    //
    // Wraps the Win32 API FindFirstFile
    //
    sealed class FindFileData {
        internal readonly uint      FileAttributes;
        internal readonly DateTime  UtcCreationTime;
        internal readonly DateTime  UtcLastAccessTime;
        internal readonly DateTime  UtcLastWriteTime;
        internal readonly long      FileSize;
        internal readonly string    FileNameLong;
        internal readonly string    FileNameShort;

        static internal int FindFile(string path, out FindFileData data) {
            IntPtr hFindFile;
            UnsafeNativeMethods.WIN32_FIND_DATA wfd;

            data = null;

#if DBG
            Debug.Assert(path == FileChangesMonitor.GetFullPath(path), "path == FileChangesMonitor.GetFullPath(path)");
            Debug.Assert(Path.GetDirectoryName(path) != null, "Path.GetDirectoryName(path) != null");
            Debug.Assert(Path.GetFileName(path) != null, "Path.GetFileName(path) != null");
#endif

            hFindFile = UnsafeNativeMethods.FindFirstFile(path, out wfd);
            if (hFindFile == UnsafeNativeMethods.INVALID_HANDLE_VALUE) {
                return HttpException.HResultFromLastError(Marshal.GetLastWin32Error());
            }

            UnsafeNativeMethods.FindClose(hFindFile);

#if DBG
            string file = Path.GetFileName(path);
            Debug.Assert(String.Compare(file, wfd.cFileName, true, CultureInfo.InvariantCulture) == 0 ||
                         String.Compare(file, wfd.cAlternateFileName, true, CultureInfo.InvariantCulture) == 0,
                         "Path to FindFile is not for a single file: " + path);
#endif

            data = new FindFileData(ref wfd);
            return HResults.S_OK;
        }

        FindFileData(ref UnsafeNativeMethods.WIN32_FIND_DATA wfd) {
            FileAttributes = wfd.dwFileAttributes;
            UtcCreationTime   = DateTimeUtil.FromFileTimeToUtc(((long)wfd.ftCreationTime_dwHighDateTime)   << 32 | (long)wfd.ftCreationTime_dwLowDateTime);
            UtcLastAccessTime = DateTimeUtil.FromFileTimeToUtc(((long)wfd.ftLastAccessTime_dwHighDateTime) << 32 | (long)wfd.ftLastAccessTime_dwLowDateTime);
            UtcLastWriteTime  = DateTimeUtil.FromFileTimeToUtc(((long)wfd.ftLastWriteTime_dwHighDateTime)  << 32 | (long)wfd.ftLastWriteTime_dwLowDateTime);
            FileSize       = (long)wfd.nFileSizeHigh << 32 | (long)wfd.nFileSizeLow;
            FileNameLong   = wfd.cFileName;
            if (    wfd.cAlternateFileName != null && 
                    wfd.cAlternateFileName.Length > 0 &&
                    string.Compare(wfd.cFileName, wfd.cAlternateFileName, true, CultureInfo.InvariantCulture) != 0) {
                FileNameShort = wfd.cAlternateFileName;
            }
        }
    }

    //
    // Wraps the Win32 API GetFileAttributesEx
    // We use this api in addition to FindFirstFile because FindFirstFile
    // does not work for volumes (e.g. "c:\")
    //
    sealed class FileAttributesData {
        internal readonly int       FileAttributes;
        internal readonly DateTime  UtcCreationTime;
        internal readonly DateTime  UtcLastAccessTime;
        internal readonly DateTime  UtcLastWriteTime;
        internal readonly long      FileSize;

        static internal int GetFileAttributes(string path, out FileAttributesData fa) {
            fa = null;

            UnsafeNativeMethods.WIN32_FILE_ATTRIBUTE_DATA  data;
            if (!UnsafeNativeMethods.GetFileAttributesEx(path, UnsafeNativeMethods.GetFileExInfoStandard, out data)) {
                return HttpException.HResultFromLastError(Marshal.GetLastWin32Error());
            }

            fa = new FileAttributesData(ref data);
            return HResults.S_OK;
        }

        FileAttributesData(ref UnsafeNativeMethods.WIN32_FILE_ATTRIBUTE_DATA data) {
            FileAttributes = data.fileAttributes;
            UtcCreationTime   = DateTimeUtil.FromFileTimeToUtc(((long)data.ftCreationTimeHigh)   << 32 | (long)data.ftCreationTimeLow);
            UtcLastAccessTime = DateTimeUtil.FromFileTimeToUtc(((long)data.ftLastAccessTimeHigh) << 32 | (long)data.ftLastAccessTimeLow);
            UtcLastWriteTime  = DateTimeUtil.FromFileTimeToUtc(((long)data.ftLastWriteTimeHigh)  << 32 | (long)data.ftLastWriteTimeLow);
            FileSize       = (long)(uint)data.fileSizeHigh << 32 | (long)(uint)data.fileSizeLow;
        }
    }


    delegate void FileChangeEventHandler(Object sender, FileChangeEvent e); 

    enum FileAction {
        Dispose = -2,
        Error = -1,
        Overwhelming = 0,
        Added = 1,
        Removed = 2,
        Modified = 3,
        RenamedOldName = 4,
        RenamedNewName = 5
    }

    // Event data for a file change notification
    sealed class FileChangeEvent : EventArgs {
        internal FileAction   Action;       // the action
        internal string       FileName;     // the file that caused the action

        internal FileChangeEvent(FileAction action, string fileName) {
            this.Action = action;
            this.FileName = fileName;
        }
    }

    // Contains information about the target of a file change notification
    sealed class FileMonitorTarget {
        internal readonly FileChangeEventHandler Callback;  // the callback
        internal readonly string                 Alias;     // the filename used to name the file
        int                                      _refs;

        internal FileMonitorTarget(FileChangeEventHandler callback, string alias) {
            Callback = callback;
            Alias = alias;
            _refs = 1;
        }

        internal int AddRef() {
            _refs++;
            return _refs;
        }

        internal int Release() {
            _refs--;
            return _refs;
        }
    }

    // holds information about a single file and the targets of change notification
    sealed class FileMonitor {
        internal readonly DirectoryMonitor  DirectoryMonitor;   // the parent
        internal readonly Hashtable         Aliases;            // aliases for this file
        string                              _fileNameLong;      // long file name - if null, represents any file in this directory
        string                              _fileNameShort;     // short file name, may be null
        Hashtable                           _targets;           // targets of notification
        bool                                _exists;            // does the file exist?
        DateTime                            _utcLastWrite;      // cached last write time - is DateTime.MinValue
                                                                // if unknown or file has changed
        long                                _length;            // cached file length - is -1 if unknown or
                                                                // files has changed

        internal FileMonitor(
                DirectoryMonitor dirMon, string fileNameLong, string fileNameShort, 
                bool exists, DateTime utcLastWrite, long length) {

            DirectoryMonitor = dirMon;
            _fileNameLong = fileNameLong;
            _fileNameShort = fileNameShort;
            _exists = exists;
            _utcLastWrite = utcLastWrite;
            _length = length;
            _targets = new Hashtable();
            Aliases = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);
        }

        internal string FileNameLong    {get {return _fileNameLong;}}
        internal string FileNameShort   {get {return _fileNameShort;}}
        internal bool   Exists          {get {return _exists;}}
        internal bool   IsDirectory     {get {return (FileNameLong == null);}}

        // Returns the utcLastWrite and length attributes of a file, updating them
        // if the file has changed.
        internal void UtcGetFileAttributes(out DateTime utcLastWrite, out long length) {
            string path;
            int hr;
            FileAttributesData fa = null;

            if (_utcLastWrite == DateTime.MinValue && FileNameLong != null) {
                path = Path.Combine(DirectoryMonitor.Directory, FileNameLong);

                hr = FileAttributesData.GetFileAttributes(path, out fa);
                if (hr == HResults.S_OK) {
                    _utcLastWrite = fa.UtcLastWriteTime;
                    _length = fa.FileSize;
                    _exists = true;
                }
                else {
                    _exists = false;
                }
            }

            utcLastWrite = _utcLastWrite;
            length = _length;
        }

        internal void ResetCachedAttributes() {
            _utcLastWrite = DateTime.MinValue;
            _length = -1;
        }

        // Set new file information when a file comes into existence
        internal void MakeExist(FindFileData fd) {
            _fileNameLong = fd.FileNameLong;
            _fileNameShort = fd.FileNameShort;
            _utcLastWrite = fd.UtcLastWriteTime;
            _length = fd.FileSize;
            _exists = true;
        }

        // Remove a file from existence
        internal void MakeExtinct() {
            _utcLastWrite = DateTime.MinValue;
            _length = -1;
            _exists = false;
        }

        internal void RemoveFileNameShort() {
            _fileNameShort = null;
        }

        internal ICollection Targets {
            get {return _targets.Values;}
        }

         // Add delegate for this file.
        internal void AddTarget(FileChangeEventHandler callback, string alias, bool newAlias) {
            FileMonitorTarget target = (FileMonitorTarget)_targets[callback.Target];
            if (target != null) {
                target.AddRef();
            }
            else {
                _targets.Add(callback.Target, new FileMonitorTarget(callback, alias));
            }

            if (newAlias) {
                Aliases[alias] = alias;
            }
        }

        
        // Remove delegate for this file given the target object.
        internal int RemoveTarget(object callbackTarget) {
            FileMonitorTarget target = (FileMonitorTarget)_targets[callbackTarget];
            Debug.Assert(target != null, "removing file monitor target that was never added or already been removed");
            if (target != null && target.Release() == 0) {
                _targets.Remove(callbackTarget);
            }

            return _targets.Count;
        }

#if DBG
        internal string DebugDescription(string indent) {
            StringBuilder   sb = new StringBuilder(200);
            string          i2 = indent + "    ";
            DictionaryEntryTypeComparer detcomparer = new DictionaryEntryTypeComparer();

            sb.Append(indent + "System.Web.FileMonitor: ");
            if (FileNameLong != null) {
                sb.Append(FileNameLong);
                if (FileNameShort != null) {
                    sb.Append("; ShortFileName=" + FileNameShort);
                }

                sb.Append("; FileExists="); sb.Append(_exists);                
            }
            else {
                sb.Append("<ANY>");
            }
            sb.Append("\n");

            sb.Append(indent + "Last Modified Time=" + _utcLastWrite + "; length=" + _length + "\n");
            sb.Append(indent + "Count=" + _targets.Count + "\n");

            DictionaryEntry[] delegateEntries = new DictionaryEntry[_targets.Count];
            _targets.CopyTo(delegateEntries, 0);
            Array.Sort(delegateEntries, detcomparer);
            
            foreach (DictionaryEntry d in delegateEntries) {
                sb.Append(i2 + "Delegate " + d.Key.GetType() + "(HC=" + d.Key.GetHashCode() + ")\n");
            }

            return sb.ToString();
        }
#endif

    }

    // Change notifications delegate from native code.
    delegate void NativeFileChangeNotification(FileAction action, [In, MarshalAs(UnmanagedType.LPWStr)] string fileName);

    // 
    // Wraps N/Direct calls to native code that does completion port
    // based ReadDirectoryChangesW().
    // This needs to be a separate object so that a DirectoryMonitory
    // can start monitoring while the old _rootCallback has not been
    // disposed.
    //
    sealed class DirMonCompletion : IDisposable {
        DirectoryMonitor    _dirMon;                        // directory monitor
        IntPtr              _ndirMonCompletionPtr;          // pointer to native dir mon as int (used only to construct HandleRef)
        HandleRef           _ndirMonCompletionHandle;       // handleref of a pointer to native dir mon as int
        GCHandle            _rootCallback;                  // roots this callback to prevent collection

        internal DirMonCompletion(DirectoryMonitor dirMon, string dir, bool watchSubtree, uint notifyFilter) {
            Debug.Trace("FileChangesMonitor", "DirMonCompletion::ctor");

            int                             hr;
            NativeFileChangeNotification    myCallback;

            _dirMon = dirMon;
            myCallback = new NativeFileChangeNotification(this.OnFileChange);
            _rootCallback = GCHandle.Alloc(myCallback);
            hr = UnsafeNativeMethods.DirMonOpen(dir, watchSubtree, notifyFilter, myCallback, out _ndirMonCompletionPtr);
            if (hr != HResults.S_OK) {
                _rootCallback.Free();
                throw FileChangesMonitor.CreateFileMonitoringException(hr, dir);
            }
            _ndirMonCompletionHandle = new HandleRef(this, _ndirMonCompletionPtr);
        }

        ~DirMonCompletion() {
            Dispose(false);
        }

        void IDisposable.Dispose() {
            Dispose(true);
            System.GC.SuppressFinalize(this);
        }

        void Dispose(bool disposing) {
            Debug.Trace("FileChangesMonitor", "DirMonCompletion::Dispose");
            if (_ndirMonCompletionHandle.Handle != IntPtr.Zero) {
                UnsafeNativeMethods.DirMonClose(_ndirMonCompletionHandle);
                _ndirMonCompletionHandle = new HandleRef(this, IntPtr.Zero);
            }
        }

        void OnFileChange(FileAction action, string fileName) {
            //
            // The native DirMonCompletion sends FileAction.Dispose
            // when there are no more outstanding calls on the 
            // delegate. Only then can _rootCallback be freed.
            //
            if (action == FileAction.Dispose) {
                if (_rootCallback.IsAllocated) {
                    _rootCallback.Free();
                }
            }
            else {
                _dirMon.OnFileChange(action, fileName);
            }
        }
    }

    //
    // Monitor changes in a single directory.
    //
    sealed class DirectoryMonitor : IDisposable {
        internal readonly string    Directory;                      // directory being monitored
        Hashtable                   _fileMons;                      // fileName -> FileMonitor
        int                         _cShortNames;                   // number of file monitors that are added with their short name
        FileMonitor                 _anyFileMon;                    // special file monitor to watch for any changes in directory
        bool                        _watchSubtree;                  // watch subtree?
        uint                        _notifyFilter;                  // watch renames only?
        DirMonCompletion            _dirMonCompletion;              // dirmon completion

        internal DirectoryMonitor(string dir, bool watchSubtree, uint notifyFilter) {
            Directory = dir;
            _fileMons = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);
            _watchSubtree = watchSubtree;
            _notifyFilter = notifyFilter;
        }

        void IDisposable.Dispose() {
            if (_dirMonCompletion != null) {
                ((IDisposable)_dirMonCompletion).Dispose();
                _dirMonCompletion = null;
            }

            //
            // Remove aliases to this object in FileChangesMonitor so that
            // it is not rooted.
            //
            if (_anyFileMon != null) {
                HttpRuntime.FileChangesMonitor.RemoveAliases(_anyFileMon);
                _anyFileMon = null;
            }

            foreach (DictionaryEntry e in _fileMons) {
                string key = (string) e.Key;
                FileMonitor fileMon = (FileMonitor) e.Value;
                if (fileMon.FileNameLong == key) {
                    HttpRuntime.FileChangesMonitor.RemoveAliases(fileMon);
                }
            }

            _fileMons.Clear();
            _cShortNames = 0;
        }

        internal bool IsMonitoring() {
            return GetFileMonitorsCount() > 0;
        }

        void StartMonitoring() {
            if (_dirMonCompletion == null) {
                _dirMonCompletion = new DirMonCompletion(this, Directory, _watchSubtree, _notifyFilter);
            }
        }

        internal void StopMonitoring() {
            lock (this) {
                ((IDisposable)this).Dispose();
            }    
        }

        FileMonitor FindFileMonitor(string file) {
            FileMonitor fileMon;

            if (file == null) {
                fileMon = _anyFileMon;
            }
            else {
                fileMon = (FileMonitor)_fileMons[file];
            }

            return fileMon;
        }

        FileMonitor AddFileMonitor(string file) {
            string path;
            FileMonitor fileMon;
            FindFileData fd = null;
            int hr;

            if (file == null || file.Length == 0) {
                // add as the <ANY> file monitor
                fileMon = new FileMonitor(this, null, null, true, DateTime.MinValue, -1);
                _anyFileMon = fileMon;
            }
            else {
                // Get the long and short name of the file
                path = Path.Combine(Directory, file);
                hr = FindFileData.FindFile(path, out fd);
                if (hr == HResults.S_OK) {
                    // Don't monitor changes to a directory - this will not pickup changes 
                    // to files in the directory.
                    if ((fd.FileAttributes & UnsafeNativeMethods.FILE_ATTRIBUTE_DIRECTORY) != 0) {
                        throw FileChangesMonitor.CreateFileMonitoringException(HResults.E_INVALIDARG, path);
                    }

                    fileMon = new FileMonitor(this, fd.FileNameLong, fd.FileNameShort, true, fd.UtcLastWriteTime, fd.FileSize);
                    _fileMons.Add(fd.FileNameLong, fileMon);

                    // Update short name aliases to this file
                    UpdateFileNameShort(fileMon, null, fd.FileNameShort);
                }
                else if (hr == HResults.E_PATHNOTFOUND || hr == HResults.E_FILENOTFOUND) {
                    // Don't allow possible short file names to be added as non-existant,
                    // because it is impossible to track them if they are indeed a short name.
                    if (file.IndexOf('~') != -1) {
                        throw FileChangesMonitor.CreateFileMonitoringException(HResults.E_INVALIDARG, path);
                    }

                    // Add as non-existent file
                    fileMon = new FileMonitor(this, file, null, false, DateTime.MinValue, -1);
                    _fileMons.Add(file, fileMon);
                }
                else {
                    throw FileChangesMonitor.CreateFileMonitoringException(hr, path);
                }
            }

            return fileMon;
        }

        //
        // Update short names of a file
        //
        void UpdateFileNameShort(FileMonitor fileMon, string oldFileNameShort, string newFileNameShort) {
            if (oldFileNameShort != null) {
                FileMonitor oldFileMonShort = (FileMonitor)_fileMons[oldFileNameShort];
                if (oldFileMonShort != null) {
                    // The old filemonitor no longer has this short file name.
                    // Update the monitor and _fileMons
                    if (oldFileMonShort != fileMon) {
                        oldFileMonShort.RemoveFileNameShort();
                    }

                    
                    _fileMons.Remove(oldFileNameShort);
                    _cShortNames--;
                }
            }

            if (newFileNameShort != null) {
                // Add the new short file name.
                _fileMons.Add(newFileNameShort, fileMon);
                _cShortNames++;
            }
        }

        void RemoveFileMonitor(FileMonitor fileMon) {
            if (fileMon == _anyFileMon) {
                _anyFileMon = null;
            }
            else {
                _fileMons.Remove(fileMon.FileNameLong);
                if (fileMon.FileNameShort != null) {
                    _fileMons.Remove(fileMon.FileNameShort);
                    _cShortNames--;
                }
            }

            HttpRuntime.FileChangesMonitor.RemoveAliases(fileMon);
        }

        int GetFileMonitorsCount() {
            int c = _fileMons.Count - _cShortNames;
            if (_anyFileMon != null) {
                c++;
            }

            return c;
        }

        internal FileMonitor StartMonitoringFile(string file, FileChangeEventHandler callback, string alias) {
            FileMonitor fileMon = null;
            bool firstFileMonAdded = false;

            lock (this) {
                // Find existing file monitor
                fileMon = FindFileMonitor(file);
                if (fileMon == null) {
                    // Add a new monitor
                    fileMon = AddFileMonitor(file);
                    if (GetFileMonitorsCount() == 1) {
                        firstFileMonAdded = true;
                    }
                }

                // Add callback to the file monitor
                fileMon.AddTarget(callback, alias, true);

                // Start directory monitoring when the first file gets added
                if (firstFileMonAdded) {
                    StartMonitoring();
                }
            }

            return fileMon;
        }

        //
        // Request to stop monitoring a file.
        //
        internal void StopMonitoringFile(string file, object target) {
            FileMonitor fileMon;
            int numTargets;

            lock (this) {
                // Find existing file monitor
                fileMon = FindFileMonitor(file);
                if (fileMon != null) {
                    numTargets = fileMon.RemoveTarget(target);
                    if (numTargets == 0) {
                        RemoveFileMonitor(fileMon);

                        // last target for the file monitor gone 
                        // -- remove the file monitor
                        if (GetFileMonitorsCount() == 0) {
                            ((IDisposable)this).Dispose();
                        }
                    }
                }
            }

#if DBG
            if (fileMon != null) {
                Debug.Dump("FileChangesMonitor", HttpRuntime.FileChangesMonitor);
            }
#endif
        }


        internal bool UtcGetFileAttributes(string file, out DateTime utcLastWrite, out long length) {
            FileMonitor fileMon = null;
            utcLastWrite = DateTime.MinValue;
            length = -1;

            lock (this) {
                // Find existing file monitor
                fileMon = FindFileMonitor(file);
                if (fileMon != null) {
                    // Get the attributes
                    fileMon.UtcGetFileAttributes(out utcLastWrite, out length);
                    return true;
                }
            }

            return false;
        }

        //
        // Delegate callback from native code.
        //
        internal void OnFileChange(FileAction action, string fileName) {
            //
            // Use try/catch to prevent runtime exceptions from propagating 
            // into native code.
            //
            try {
                FileMonitor             fileMon;
                ArrayList               targets = null;
                int                     i, n;
                FileMonitorTarget       target;
                ICollection             col;
                string                  key;

                // We've already stopped monitoring, but a change completion was
                // posted afterwards. Ignore it.
                if (_dirMonCompletion == null) {
                    return;
                }

                lock (this) {
                    if (_fileMons.Count > 0) {
                        if (action == FileAction.Error || action == FileAction.Overwhelming) {
                            // Overwhelming change -- notify all file monitors
                            Debug.Assert(fileName == null, "fileName == null");
                            Debug.Trace("FileChangesMonitor", "OnFileChange\n" + "\tArgs: Action=" + action.ToString() + "; Dir=" + Directory + "; fileName is NULL, overwhelming change");

                            HttpRuntime.SetShutdownMessage("Overwhelming Change Notification in " + Directory);

                            // Get targets for all files
                            targets = new ArrayList();    
                            foreach (DictionaryEntry d in _fileMons) {
                                key = (string) d.Key;
                                fileMon = (FileMonitor) d.Value;
                                if (fileMon.FileNameLong == key && fileMon.Exists) {
                                    fileMon.ResetCachedAttributes();
                                    col = fileMon.Targets;
                                    targets.AddRange(col);
                                }
                            }
                        }
                        else {
                            Debug.Assert((int) action >= 1 && fileName != null && fileName.Length > 0,
                                        "(int) action >= 1 && fileName != null && fileName.Length > 0");

                            Debug.Trace("FileChangesMonitor", "OnFileChange\n" + "\tArgs: Action=" + action.ToString() + "; Dir=" + Directory + "; fileName=" +  fileName);

                            // Find the file monitor
                            fileMon = (FileMonitor)_fileMons[fileName];
                            if (fileMon != null) {
                                // File has been modified - file attributes no longer valid
                                fileMon.ResetCachedAttributes();

                                // Get the targets
                                col = fileMon.Targets;
                                targets = new ArrayList(col);

                                if (action == FileAction.Removed || action == FileAction.RenamedOldName) {
                                    // File not longer exists.
                                    fileMon.MakeExtinct();
                                }
                                else if (!fileMon.Exists) {
                                    // File now exists - update short name and attributes.
                                    FindFileData fd = null;
                                    int hr = FindFileData.FindFile(Path.Combine(Directory, fileMon.FileNameLong), out fd);
                                    if (hr == HResults.S_OK) {
                                        Debug.Assert(string.Compare(fileMon.FileNameLong, fd.FileNameLong, true, CultureInfo.InvariantCulture) == 0,
                                                    "string.Compare(fileMon.FileNameLong, fd.FileNameLong, true, CultureInfo.InvariantCulture) == 0");

                                        string oldFileNameShort = fileMon.FileNameShort;
                                        fileMon.MakeExist(fd);
                                        UpdateFileNameShort(fileMon, oldFileNameShort, fd.FileNameShort);
                                    }
                                }
                            }
                        }
                    }

                    // Notify the delegate waiting for any changes
                    if (_anyFileMon != null) {
                        col = _anyFileMon.Targets;
                        if (targets != null) {
                            targets.AddRange(col);
                        }
                        else {
                            targets = new ArrayList(col);
                        }
                    }

                    if (action == FileAction.Error || action == FileAction.Overwhelming) {
                        // Stop monitoring.
                        ((IDisposable)this).Dispose();
                    }
                }

                if (targets != null) {
                    Debug.Dump("FileChangesMonitor", HttpRuntime.FileChangesMonitor);

                    for (i = 0, n = targets.Count; i < n; i++) {
                        target = (FileMonitorTarget)targets[i];
                        Debug.Trace("FileChangesMonitor", "Firing change event\n" + "\tArgs: Action=" + action.ToString() + "; fileName=" + fileName + "; Target=" + target.Callback.Target + "(HC=" + target.Callback.Target.GetHashCode() + ")");
                        try {
                            target.Callback(this, new FileChangeEvent((FileAction)action, target.Alias)); 
                        }
                        catch (Exception ex) {
                            Debug.Trace(Debug.TAG_INTERNAL, 
                                        "Exception thrown in file change callback" +
                                        " action=" + action.ToString() +
                                        " fileName" + fileName);

                            Debug.TraceException(Debug.TAG_INTERNAL, ex);
                        }
                    }
                }
            }
            catch (Exception ex) {
                Debug.Trace(Debug.TAG_INTERNAL, 
                            "Exception thrown processing file change notification" +
                            " action=" + action.ToString() +
                            " fileName" + fileName);

                Debug.TraceException(Debug.TAG_INTERNAL, ex);
            }
        }

#if DBG
        internal string DebugDescription(string indent) {
            StringBuilder   sb = new StringBuilder(200);
            string          i2 = indent + "    ";
            DictionaryEntryCaseInsensitiveComparer  decomparer = new DictionaryEntryCaseInsensitiveComparer();
            
            lock (this) {
                DictionaryEntry[] fileEntries = new DictionaryEntry[_fileMons.Count];
                _fileMons.CopyTo(fileEntries, 0);
                Array.Sort(fileEntries, decomparer);
                
                sb.Append(indent + "System.Web.DirectoryMonitor: " + Directory + "\n");
                sb.Append(indent + "Count=" + GetFileMonitorsCount() + "\n");
                if (_anyFileMon != null) {
                    sb.Append(_anyFileMon.DebugDescription(i2));
                }

                foreach (DictionaryEntry d in fileEntries) {
                    FileMonitor fileMon = (FileMonitor)d.Value;
                    if (fileMon.FileNameShort == (string)d.Key)
                        continue;

                    sb.Append(fileMon.DebugDescription(i2));
                }
            }

            return sb.ToString();
        }
#endif
    }

    //
    // Manager for directory monitors.                       
    // Provides file change notification services in ASP.NET 
    //
    sealed class FileChangesMonitor {
        internal const int MAX_PATH = 260;

        ReadWriteSpinLock       _lockDispose;                       // spinlock for coordinating dispose
        bool                    _disposed;                          // have we disposed?
        Hashtable               _aliases;                           // alias -> FileMonitor
        Hashtable               _dirs;                              // dir -> DirectoryMonitor
        DirectoryMonitor        _dirMonSubdirs;                     // subdirs monitor for renames
        DirectoryMonitor        _dirMonBindir;                      // bindir monitor
        FileChangeEventHandler  _callbackRenameOrBindirChange;      // event handler for renames and bindir

        internal static HttpException CreateFileMonitoringException(int hr, string path) {
            string message;

            switch (hr) {
                case HResults.E_FILENOTFOUND:
                case HResults.E_PATHNOTFOUND:
                    message = SR.Directory_does_not_exist_for_monitoring;
                    break;

                case HResults.E_ACCESSDENIED:
                    message = SR.Access_denied_for_monitoring;
                    break;

                case HResults.E_INVALIDARG:
                    message = SR.Invalid_file_name_for_monitoring;
                    break;

                default:
                    message = SR.Failed_to_start_monitoring;
                    break;
            }

            return new HttpException(HttpRuntime.FormatResourceString(message, HttpRuntime.GetSafePath(path)), hr);
        }

        internal static string GetFullPath(string alias) {
            // Assert PathDiscovery before call to Path.GetFullPath
            try {
                new FileIOPermission(FileIOPermissionAccess.PathDiscovery, alias).Assert();
            }
            catch {
                throw CreateFileMonitoringException(HResults.E_INVALIDARG, alias);
            }

            return Path.GetFullPath(alias);
        }

        internal FileChangesMonitor() {
            _aliases = Hashtable.Synchronized(new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default));
            _dirs    = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);
        }

        //
        // Find the directory monitor. If not found, maybe add it.
        // If the directory is not actively monitoring, ensure that
        // it still represents an accessible directory.
        //
        DirectoryMonitor FindDirectoryMonitor(string dir, bool addIfNotFound, bool throwOnError) {
            DirectoryMonitor dirMon;
            FileAttributesData fa = null;
            int hr;

            dirMon = (DirectoryMonitor)_dirs[dir];
            if (dirMon != null) {
                if (!dirMon.IsMonitoring()) {
                    hr = FileAttributesData.GetFileAttributes(dir, out fa);
                    if (hr != HResults.S_OK || (fa.FileAttributes & UnsafeNativeMethods.FILE_ATTRIBUTE_DIRECTORY) == 0) {
                        dirMon = null;
                    }
                }
            }

            if (dirMon != null || !addIfNotFound) {
                return dirMon;
            }

            lock (_dirs.SyncRoot) {
                // Check again, this time under synchronization.
                dirMon = (DirectoryMonitor)_dirs[dir];
                if (dirMon != null) {
                    if (!dirMon.IsMonitoring()) {
                        // Fail if it's not a directory or inaccessible.
                        hr = FileAttributesData.GetFileAttributes(dir, out fa);
                        if (hr == HResults.S_OK && (fa.FileAttributes & UnsafeNativeMethods.FILE_ATTRIBUTE_DIRECTORY) == 0) {
                            // Fail if it's not a directory.
                            hr = HResults.E_INVALIDARG;
                        }

                        if (hr != HResults.S_OK) {
                            // Not accessible or a dir, so stop monitoring and remove.
                            _dirs.Remove(dir);
                            dirMon.StopMonitoring();
                            if (addIfNotFound && throwOnError) {
                                throw FileChangesMonitor.CreateFileMonitoringException(hr, dir);
                            }

                            return null;
                        }
                    }
                }
                else if (addIfNotFound) {
                    // Fail if it's not a directory or inaccessible.
                    hr = FileAttributesData.GetFileAttributes(dir, out fa);
                    if (hr == HResults.S_OK && (fa.FileAttributes & UnsafeNativeMethods.FILE_ATTRIBUTE_DIRECTORY) == 0) {
                        hr = HResults.E_INVALIDARG;
                    }

                    if (hr == HResults.S_OK) {
                        // Add a new directory monitor.
                        dirMon = new DirectoryMonitor(dir, false, UnsafeNativeMethods.RDCW_FILTER_FILE_AND_DIR_CHANGES);
                        _dirs.Add(dir, dirMon);
                    }
                    else if (throwOnError) {
                        throw FileChangesMonitor.CreateFileMonitoringException(hr, dir);
                    }
                }
            }

            return dirMon;
        }

        // Remove the aliases of a file monitor.
        internal void RemoveAliases(FileMonitor fileMon) {
            foreach (DictionaryEntry entry in fileMon.Aliases) {
                if (_aliases[entry.Key] == fileMon) {
                    _aliases.Remove(entry.Key);
                }
            }
        }

        //
        // Request to monitor a file, which may or may not exist.
        //
        internal DateTime StartMonitoringFile(string alias, FileChangeEventHandler callback) {
            Debug.Trace("FileChangesMonitor", "StartMonitoringFile\n" + "\tArgs: File=" + alias + "; Callback=" + callback.Target + "(HC=" + callback.Target.GetHashCode() + ")");

            FileMonitor         fileMon;
            DirectoryMonitor    dirMon;
            string              fullPathName, dir, file;
            DateTime            utcLastWrite = DateTime.MinValue;
            long                length = -1;
            bool                addAlias = false;

            if (alias == null) {
                throw CreateFileMonitoringException(HResults.E_INVALIDARG, alias);
            }

            _lockDispose.AcquireReaderLock();
            try{
                // Don't start monitoring if disposed.
                if (_disposed) {
                    return DateTime.MinValue;
                }

                fileMon = (FileMonitor)_aliases[alias];
                if (fileMon != null) {
                    // Used the cached directory monitor and file name.
                    dirMon = fileMon.DirectoryMonitor;
                    file = fileMon.FileNameLong;
                }
                else {
                    addAlias = true;

                    if (alias.Length == 0 || !UrlPath.IsAbsolutePhysicalPath(alias)) {
                        throw CreateFileMonitoringException(HResults.E_INVALIDARG, alias);
                    }

                    //
                    // Get the directory and file name, and lookup 
                    // the directory monitor.
                    //
                    fullPathName = GetFullPath(alias);
                    dir = UrlPath.GetDirectoryOrRootName(fullPathName);
                    file = Path.GetFileName(fullPathName);
                    if (file == null || file.Length == 0) {
                        // not a file
                        throw CreateFileMonitoringException(HResults.E_INVALIDARG, alias);
                    }

                    dirMon = FindDirectoryMonitor(dir, true, true);
                }

                fileMon = dirMon.StartMonitoringFile(file, callback, alias);
                if (addAlias) {
                    _aliases[alias] = fileMon;
                }
            }
            finally {
                _lockDispose.ReleaseReaderLock();
            }

            fileMon.DirectoryMonitor.UtcGetFileAttributes(file, out utcLastWrite, out length);

            Debug.Dump("FileChangesMonitor", this);

            return utcLastWrite;
        }

        //
        // Request to monitor a path, which may be file, directory, or non-existent
        // file.
        //
        internal DateTime StartMonitoringPath(string alias, FileChangeEventHandler callback) {
            Debug.Trace("FileChangesMonitor", "StartMonitoringFile\n" + "\tArgs: File=" + alias + "; Callback=" + callback.Target + "(HC=" + callback.Target.GetHashCode() + ")");

            FileMonitor         fileMon = null;
            DirectoryMonitor    dirMon = null;
            string              fullPathName, dir, file = null;
            DateTime            utcLastWrite = DateTime.MinValue;
            long                length = -1;
            bool                addAlias = false;

            if (alias == null) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_file_name_for_monitoring, ""));
            }

            _lockDispose.AcquireReaderLock();
            try{
                if (_disposed) {
                    return DateTime.MinValue;
                }

                // do/while loop once to make breaking out easy
                do {
                    fileMon = (FileMonitor)_aliases[alias];
                    if (fileMon != null) {
                        // Used the cached directory monitor and file name.
                        file = fileMon.FileNameLong;
                        fileMon = fileMon.DirectoryMonitor.StartMonitoringFile(file, callback, alias);
                        continue;
                    }

                    addAlias = true;

                    if (alias.Length == 0 || !UrlPath.IsAbsolutePhysicalPath(alias)) {
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_file_name_for_monitoring, HttpRuntime.GetSafePath(alias)));
                    }

                    fullPathName = GetFullPath(alias);

                    // try treating the path as a directory
                    dirMon = FindDirectoryMonitor(fullPathName, false, false);
                    if (dirMon != null) {
                        fileMon = dirMon.StartMonitoringFile(null, callback, alias);
                        continue;
                    }

                    // try treaing the path as a file
                    dir = UrlPath.GetDirectoryOrRootName(fullPathName);
                    file = Path.GetFileName(fullPathName);
                    if (file != null && file.Length > 0) {
                        dirMon = FindDirectoryMonitor(dir, false, false);
                        if (dirMon != null) {
                            // try to add it - a file is the common case,
                            // and we avoid hitting the disk twice
                            try {
                                fileMon = dirMon.StartMonitoringFile(file, callback, alias);
                            }
                            catch {
                            }

                            if (fileMon != null) {
                                continue;
                            }
                        }
                    }

                    // We aren't monitoring this path or its parent directory yet. 
                    // Hit the disk to determine if it's a directory or file.
                    dirMon = FindDirectoryMonitor(fullPathName, true, false);
                    if (dirMon != null) {
                        // It's a directory, so monitor all changes in it
                        file = null;
                    }
                    else {
                        // It's not a directory, so treat as file
                        if (file == null || file.Length == 0) {
                            throw CreateFileMonitoringException(HResults.E_INVALIDARG, alias);
                        }
    
                        dirMon = FindDirectoryMonitor(dir, true, true);
                    }

                    fileMon = dirMon.StartMonitoringFile(file, callback, alias);
                } while (false);

                if (!fileMon.IsDirectory) {
                    fileMon.DirectoryMonitor.UtcGetFileAttributes(file, out utcLastWrite, out length);
                }

                if (addAlias) {
                    _aliases[alias] = fileMon;
                }
            }
            finally {
                _lockDispose.ReleaseReaderLock();
            }

            Debug.Dump("FileChangesMonitor", this);

            return utcLastWrite;
        }

        //
        // Request to monitor the bin directory and directory renames anywhere under app
        //
        const string BIN_NAME="BIN";

        internal void StartMonitoringDirectoryRenamesAndBinDirectory(string dir, FileChangeEventHandler callback) {
            Debug.Trace("FileChangesMonitor", "StartMonitoringDirectoryRenamesAndBinDirectory\n" + "\tArgs: File=" + dir + "; Callback=" + callback.Target + "(HC=" + callback.Target.GetHashCode() + ")");

            if (dir == null || dir.Length == 0) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_file_name_for_monitoring, ""));
            }

            _lockDispose.AcquireReaderLock();
            try {
                if (_disposed) {
                    return;
                }
            
                _callbackRenameOrBindirChange = callback;

                string dirRoot, dirRootBin;

                dirRoot = GetFullPath(dir);
                if (dirRoot.EndsWith("\\")) {
                    dirRootBin = dirRoot + BIN_NAME;
                }
                else {
                    dirRootBin = dirRoot + "\\" + BIN_NAME;
                }

                // Monitor bin directory and app directory (for renames only) separately
                // to avoid overwhelming changes when the user writes to a subdirectory
                // of the app directory.

                _dirMonSubdirs = new DirectoryMonitor(dirRoot, true, UnsafeNativeMethods.RDCW_FILTER_DIR_RENAMES);
                try {
                    _dirMonSubdirs.StartMonitoringFile(null, new FileChangeEventHandler(this.OnSubdirChange), dirRoot);
                }
                catch {
                    ((IDisposable)_dirMonSubdirs).Dispose();
                    _dirMonSubdirs = null;
                    throw;
                }

                if (Directory.Exists(dirRootBin)) {
                    _dirMonBindir = new DirectoryMonitor(dirRootBin, true, UnsafeNativeMethods.RDCW_FILTER_FILE_CHANGES);
                    try {
                        _dirMonBindir.StartMonitoringFile(null, new FileChangeEventHandler(this.OnBindirChange), dirRootBin);
                    }
                    catch {
                        ((IDisposable)_dirMonBindir).Dispose();
                        _dirMonBindir = null;
                        throw;
                    }
                }
                else {
                    _dirMonBindir = new DirectoryMonitor(dirRoot, false, UnsafeNativeMethods.RDCW_FILTER_FILE_AND_DIR_CHANGES);
                    try {
                        _dirMonBindir.StartMonitoringFile(BIN_NAME, new FileChangeEventHandler(this.OnBindirChange), dirRootBin);
                    }
                    catch {
                        ((IDisposable)_dirMonBindir).Dispose();
                        _dirMonBindir = null;
                        throw;
                    }
                }
            }
            finally {
                _lockDispose.ReleaseReaderLock();
            }
        }

        void OnSubdirChange(Object sender, FileChangeEvent e) {
            Debug.Trace("FileChangesMonitor", "OnSubdirChange\n" + "\tArgs: Action=" + e.Action + "; fileName=" + e.FileName);
            FileChangeEventHandler handler = _callbackRenameOrBindirChange;
            if (    handler != null &&
                    e.Action == FileAction.Error || e.Action == FileAction.Overwhelming || e.Action == FileAction.RenamedOldName) {
                Debug.Trace("FileChangesMonitor", "Firing subdir change event\n" + "\tArgs: Action=" + e.Action + "; fileName=" + e.FileName + "; Target=" + _callbackRenameOrBindirChange.Target + "(HC=" + _callbackRenameOrBindirChange.Target.GetHashCode() + ")");
                HttpRuntime.SetShutdownMessage("Directory rename change notification for " + e.FileName);
                handler(this, e);
            }
        }

        void OnBindirChange(Object sender, FileChangeEvent e) {
            Debug.Trace("FileChangesMonitor", "OnBindirChange\n" + "\tArgs: Action=" + e.Action + "; fileName=" + e.FileName);
            HttpRuntime.SetShutdownMessage("Change Notification for BIN");
            FileChangeEventHandler handler = _callbackRenameOrBindirChange;
            if (handler != null) {
                handler(this, e);
            }
        }

        //
        // Request to stop monitoring a file.
        //
        internal void StopMonitoringFile(string alias, object target) {
            Debug.Trace("FileChangesMonitor", "StopMonitoringFile\n" + "File=" + alias + "; Callback=" + target);

            FileMonitor         fileMon;
            DirectoryMonitor    dirMon = null;
            string              fullPathName, file = null, dir;

            if (alias == null) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_file_name_for_monitoring, ""));
            }

            fileMon = (FileMonitor)_aliases[alias];
            if (fileMon != null && !fileMon.IsDirectory) {
                // Used the cached directory monitor and file name
                dirMon = fileMon.DirectoryMonitor;
                file = fileMon.FileNameLong;
            }
            else {
                if (alias.Length == 0 || !UrlPath.IsAbsolutePhysicalPath(alias)) {
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_file_name_for_monitoring, HttpRuntime.GetSafePath(alias)));
                }

                // Lookup the directory monitor
                fullPathName = GetFullPath(alias);
                dir = UrlPath.GetDirectoryOrRootName(fullPathName);
                file = Path.GetFileName(fullPathName);
                if (file == null || file.Length == 0) {
                    // not a file
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_file_name_for_monitoring, HttpRuntime.GetSafePath(alias)));
                }

                dirMon = FindDirectoryMonitor(dir, false, false);
            }

            if (dirMon != null) {
                dirMon.StopMonitoringFile(file, target);
            }
        }

        //
        // Request to stop monitoring a file.
        // 
        internal void StopMonitoringPath(String alias, object target) {
            Debug.Trace("FileChangesMonitor", "StopMonitoringFile\n" + "File=" + alias + "; Callback=" + target);

            FileMonitor         fileMon;
            DirectoryMonitor    dirMon = null;
            string              fullPathName, file = null, dir;

            if (alias == null) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_file_name_for_monitoring, ""));
            }

            fileMon = (FileMonitor)_aliases[alias];
            if (fileMon != null) {
                // Used the cached directory monitor and file name.
                dirMon = fileMon.DirectoryMonitor;
                file = fileMon.FileNameLong;
            }
            else {
                if (alias.Length == 0 || !UrlPath.IsAbsolutePhysicalPath(alias)) {
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_file_name_for_monitoring, HttpRuntime.GetSafePath(alias)));
                }

                // try treating the path as a directory
                fullPathName = GetFullPath(alias);
                dirMon = FindDirectoryMonitor(fullPathName, false, false);
                if (dirMon == null) {
                    // try treaing the path as a file
                    dir = UrlPath.GetDirectoryOrRootName(fullPathName);
                    file = Path.GetFileName(fullPathName);
                    if (file != null && file.Length > 0) {
                        dirMon = FindDirectoryMonitor(dir, false, false);
                    }
                }
            }

            if (dirMon != null) {
                dirMon.StopMonitoringFile(file, target);
            }
        }

         //
         // Returns the last modified time of the file. If the 
         // file does not exist, returns DateTime.MinValue.
         //
         internal void UtcGetFileAttributes(string alias, out DateTime utcLastWrite, out long length) {
             utcLastWrite = DateTime.MinValue;
             length = -1;

             FileMonitor        fileMon;
             DirectoryMonitor   dirMon = null;
             string             fullPathName, file = null, dir;
             FileAttributesData fa = null;
             int                hr;

             if (alias == null) {
                 throw FileChangesMonitor.CreateFileMonitoringException(HResults.E_INVALIDARG, alias);
             }

             fileMon = (FileMonitor)_aliases[alias];
             if (fileMon != null && !fileMon.IsDirectory) {
                 // Used the cached directory monitor and file name.
                 dirMon = fileMon.DirectoryMonitor;
                 file = fileMon.FileNameLong;
             }
             else {
                 if (alias.Length == 0 || !UrlPath.IsAbsolutePhysicalPath(alias)) {
                     throw FileChangesMonitor.CreateFileMonitoringException(HResults.E_INVALIDARG, alias);
                 }

                 // Lookup the directory monitor
                 fullPathName = GetFullPath(alias);
                 dir = UrlPath.GetDirectoryOrRootName(fullPathName);
                 file = Path.GetFileName(fullPathName);
                 if (file != null || file.Length > 0) {
                     dirMon = FindDirectoryMonitor(dir, false, false);
                 }
             }

             if (dirMon == null || !dirMon.UtcGetFileAttributes(file, out utcLastWrite, out length)) {
                 // If we're not monitoring the file, get the attributes.
                 hr = FileAttributesData.GetFileAttributes(alias, out fa);
                 if (hr == HResults.S_OK) {
                     utcLastWrite = fa.UtcLastWriteTime;
                     length = fa.FileSize;
                 }
             }
        }

        //
        // Request to stop monitoring everything -- release all native resources
        //
        internal void Stop() {
            Debug.Trace("FileChangesMonitor", "Stop!");

            _lockDispose.AcquireWriterLock();
            try {
                _disposed = true;
            }
            finally {
                _lockDispose.ReleaseWriterLock();
            }

            if (_dirMonSubdirs != null) {
                _dirMonSubdirs.StopMonitoring();
                _dirMonSubdirs = null;
            }

            if (_dirMonBindir != null) {
                _dirMonBindir.StopMonitoring();
                _dirMonBindir = null;
            }

            _callbackRenameOrBindirChange = null;

            if (_dirs != null) {
                IDictionaryEnumerator e = _dirs.GetEnumerator();
                while (e.MoveNext()) {
                    DirectoryMonitor dirMon = (DirectoryMonitor)e.Value;
                    dirMon.StopMonitoring();
                }
            }

            _dirs.Clear();
            _aliases.Clear();

            Debug.Dump("FileChangesMonitor", this);
        }

#if DBG
        internal string DebugDescription(string indent) {
            StringBuilder   sb = new StringBuilder(200);
            string          i2 = indent + "    ";
            DictionaryEntryCaseInsensitiveComparer  decomparer = new DictionaryEntryCaseInsensitiveComparer();

            sb.Append(indent + "System.Web.FileChangesMonitor\n");
            if (_dirMonSubdirs != null) {
                sb.Append(indent + "_dirMonSubdirs\n");
                sb.Append(_dirMonSubdirs.DebugDescription(i2));
            }

            if (_dirMonBindir != null) {
                sb.Append(indent + "_dirMonBindir\n");
                sb.Append(_dirMonBindir.DebugDescription(i2));
            }

            sb.Append(indent + "_dirs Count=" + _dirs.Count + "\n");

            DictionaryEntry[] dirEntries = new DictionaryEntry[_dirs.Count];
            _dirs.CopyTo(dirEntries, 0);
            Array.Sort(dirEntries, decomparer);
            
            foreach (DictionaryEntry d in dirEntries) {
                DirectoryMonitor dirMon = (DirectoryMonitor)d.Value;
                sb.Append(dirMon.DebugDescription(i2));
            }

            return sb.ToString();
        }
#endif
    }

#if DBG
    internal sealed class DictionaryEntryCaseInsensitiveComparer : IComparer {
        CaseInsensitiveComparer _cicomparer = new CaseInsensitiveComparer(CultureInfo.InvariantCulture);

        internal DictionaryEntryCaseInsensitiveComparer() {}
        
        int IComparer.Compare(object x, object y) {
            string a = (string) ((DictionaryEntry) x).Key;
            string b = (string) ((DictionaryEntry) y).Key;

            if (a != null && b != null) {
                return _cicomparer.Compare(a, b);
            }
            else {
                return InvariantComparer.Default.Compare(a, b);            
            }
        }
    }
#endif

#if DBG
    internal sealed class DictionaryEntryTypeComparer : IComparer {
        CaseInsensitiveComparer _cicomparer = new CaseInsensitiveComparer(CultureInfo.InvariantCulture);

        internal DictionaryEntryTypeComparer() {}

        int IComparer.Compare(object x, object y) {
            object a = ((DictionaryEntry) x).Key;
            object b = ((DictionaryEntry) y).Key;

            string i = null, j = null;
            if (a != null) {
                i = a.GetType().ToString();
            }

            if (b != null) {
                j = b.GetType().ToString();
            }

            if (i != null && j != null) {
                return _cicomparer.Compare(i, j);
            }
            else {
                return InvariantComparer.Default.Compare(i, j);            
            }
        }
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpbrowsercapabilities.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpBrowserCapabilities.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Built-in browser caps object
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web {
    using System.Collections;
    using System.Configuration;
    using System.Globalization;
    using System.Text.RegularExpressions;
    using System.Web.Configuration;
    using System.Security.Permissions;

    /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities"]/*' />
    /// <devdoc>
    ///    <para> Enables the server to compile
    ///       information on the capabilities of the browser running on the client.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HttpBrowserCapabilities : HttpCapabilitiesBase {

        // Lazy computation
        // NOTE: The methods below are designed to work on multiple threads
        // without a need for synchronization. Do NOT do something like replace
        // all the _haveX booleans with bitfields or something similar, because
        // the methods depend on the fact that "_haveX = true" is atomic.

        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.ClrVersion"]/*' />
        /// <devdoc>
        ///    <para>Returns the .NET Common Language Runtime version running 
        ///         on the client.  If no CLR version is specified on the 
        ///         User-Agent returns new Version(), which is 0,0.</para>
        /// </devdoc>
        public Version ClrVersion {
            get {
                ClrVersionEnsureInit();
                return _clrVersion;
            }
        }

        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.ClrVersions"]/*' />
        /// <devdoc>
        ///    <para>Returns all versions of the .NET CLR running on the   
        ///         client.  If no CLR version is specified on the User-Agent 
        ///         returns an array containing a single empty Version object, 
        ///         which is 0,0.</para>
        /// </devdoc>
        public Version [] GetClrVersions() {
            ClrVersionEnsureInit();
            return _clrVersions;
        }
        
        
        private void ClrVersionEnsureInit() {
            if (!_haveClrVersion) {
                Regex regex = new Regex("\\.NET CLR (?'clrVersion'[0-9\\.]*)");
                MatchCollection matches = regex.Matches(this[""]);

                if (matches.Count == 0) {
                    Version version = new Version();
                    Version [] clrVersions = new Version [1] {version};
                    _clrVersions = clrVersions;
                    _clrVersion = version;
                }
                else {
                    ArrayList versionList = new ArrayList();

                    foreach (Match match in matches) {
                        Version version = new Version(match.Groups["clrVersion"].Value);
                        versionList.Add(version);
                    }

                    versionList.Sort();

                    Version [] versions = (Version []) versionList.ToArray(typeof(Version));

                    _clrVersions = versions;
                    _clrVersion = versions[versions.Length - 1];
                }
                    
                _haveClrVersion = true;
            }
        }
        
        
        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.Type"]/*' />
        /// <devdoc>
        ///    <para>Returns the name of the client browser and its major version number. For example, "Microsoft Internet Explorer version
        ///       5".</para>
        /// </devdoc>
        public string  Type { 
            get { 
                if (!_havetype) {
                    _type = this["type"];       
                    _havetype = true;
                }
                return _type;
            }
        }
        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.Browser"]/*' />
        /// <devdoc>
        ///    <para>Browser string in User Agent (for example: "IE").</para>
        /// </devdoc>
        public string  Browser { 
            get { 
                if (!_havebrowser) {
                    _browser = this["browser"];    
                    _havebrowser = true;
                }
                return _browser;
            }
        }
        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.Version"]/*' />
        /// <devdoc>
        ///    <para>Returns the major version number + minor version number
        ///       of the client browser; for example: "5.5".</para>
        /// </devdoc>
        public string  Version { 
            get { 
                if (!_haveversion) {
                    _version =  this["version"];    
                    _haveversion = true;
                }
                return _version;
            }
        }
        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.MajorVersion"]/*' />
        /// <devdoc>
        ///    <para>Returns the major version number of the client browser; for example: 3.</para>
        /// </devdoc>
        public int MajorVersion { 
            get { 
                if (!_havemajorversion) {
                    try {
                        _majorversion = int.Parse(this["majorversion"], CultureInfo.InvariantCulture);  
                        _havemajorversion = true;
                    }
                    catch (FormatException e) {
                        throw BuildParseError(e, "majorversion");
                    }
                }
                return _majorversion;
            }
        }

        Exception BuildParseError(Exception e, string capsKey) {
            string message = SR.GetString(SR.Invalid_string_from_browser_caps, e.Message, capsKey, this[capsKey]);

            // to show ConfigurationException in stack trace
            ConfigurationException configEx = new ConfigurationException(message, e);

            // I want it to look like an unhandled exception
            HttpUnhandledException httpUnhandledEx = new HttpUnhandledException(null, null);

            // but show message from outer exception (it normally shows the inner-most)
            httpUnhandledEx.SetFormatter(new UseLastUnhandledErrorFormatter(configEx));

            return httpUnhandledEx;
        }

        bool CapsParseBool(string capsKey) {
            try {
                return bool.Parse(this[capsKey]);
            }
            catch (FormatException e) {
                throw BuildParseError(e, capsKey);
            }
        }

        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.MinorVersion"]/*' />
        /// <devdoc>
        ///    <para>Returns the minor version number of the client browser; for example: .01.</para>
        /// </devdoc>
        public double MinorVersion { 
            get { 
                if (!_haveminorversion) {
                    try {
                        // see ASURT 11176
                        _minorversion = double.Parse(
                            this["minorversion"], 
                            NumberStyles.Float | NumberStyles.AllowDecimalPoint, 
                            NumberFormatInfo.InvariantInfo);
                        _haveminorversion = true; 
                    }
                    catch (FormatException e) {
                        throw BuildParseError(e, "majorversion");
                    }
                }
                return _minorversion; 
            } 
        }
        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.Platform"]/*' />
        /// <devdoc>
        ///    <para>Returns the platform's name; for example, "Win32".</para>
        /// </devdoc>
        public string  Platform { 
            get { 
                if (!_haveplatform) {
                    _platform = this["platform"];
                    _haveplatform = true;
                }
                return _platform;
            }
        }

        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.TagWriter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Type TagWriter {
            get {
                try {
                    if (!_havetagwriter) {
                        string tagWriter = this["tagwriter"];
                        if (tagWriter == null || tagWriter.Length == 0) {
                            _tagwriter = null;
                        }
                        else if (string.Compare(tagWriter, typeof(System.Web.UI.HtmlTextWriter).FullName, false, CultureInfo.InvariantCulture) == 0) {
                            _tagwriter=  typeof(System.Web.UI.HtmlTextWriter);
                        }
                        else {
                            _tagwriter = System.Type.GetType(tagWriter, true /*throwOnError*/);
                        }
                        _havetagwriter = true;
                    }
                }
                catch (Exception e) {
                    throw BuildParseError(e, "tagwriter");
                }

                return _tagwriter;
            }
        }

        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.EcmaScriptVersion"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Version EcmaScriptVersion { 
            get { 
                if (!_haveecmascriptversion) {
                    _ecmascriptversion = new Version(this["ecmascriptversion"]);
                    _haveecmascriptversion = true;
                }
                return _ecmascriptversion;
            }
        }

        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.MSDomVersion"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Version MSDomVersion { 
            get { 
                if (!_havemsdomversion) {
                    _msdomversion = new Version(this["msdomversion"]);
                    _havemsdomversion = true;
                }
                return _msdomversion;
            }
        }

        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.W3CDomVersion"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Version W3CDomVersion { 
            get { 
                if (!_havew3cdomversion) {
                    _w3cdomversion = new Version(this["w3cdomversion"]);
                    _havew3cdomversion = true;
                }
                return _w3cdomversion;
            }
        }

        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.Beta"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the browser client is in beta.</para>
        /// </devdoc>
        public bool Beta {
            get {
                if (!_havebeta) {
                    _beta = CapsParseBool("beta");
                    _havebeta = true;
                }
                return _beta;
            }
        }

        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.Crawler"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the client browser is a Web-crawling search engine.</para>
        /// </devdoc>
        public bool Crawler {
            get {
                if (!_havecrawler) {
                    _crawler = CapsParseBool("crawler");
                    _havecrawler = true;
                }
                return _crawler;
            }
        }

        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.AOL"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the client is an AOL branded browser.</para>
        /// </devdoc>
        public bool AOL { 
            get { 
                if (!_haveaol) {
                    _aol = CapsParseBool("aol");
                    _haveaol = true;
                }
                return _aol;
            }
        }

        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.Win16"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the client is a Win16-based machine.</para>
        /// </devdoc>
        public bool Win16 { 
            get { 
                if (!_havewin16) {
                    _win16 = CapsParseBool("win16");     
                    _havewin16 = true;
                }
                return _win16;
            }
        }

        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.Win32"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the client is a Win32-based machine.</para>
        /// </devdoc>
        public bool Win32 { 
            get { 
                if (!_havewin32) {
                    _win32 = CapsParseBool("win32");     
                    _havewin32 = true;
                }
                return _win32;
            }
        }

        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.Frames"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the client browser supports HTML frames.</para>
        /// </devdoc>
        public bool Frames { 
            get { 
                if (!_haveframes) {
                    _frames = CapsParseBool("frames");    
                    _haveframes = true;
                }
                return _frames;
            }
        }

        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.Tables"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the client browser supports tables.</para>
        /// </devdoc>
        public bool Tables { 
            get { 
                if (!_havetables) {
                    _tables = CapsParseBool("tables");    
                    _havetables = true;
                }
                return _tables;
            }
        }

        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.Cookies"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the client browser supports cookies.</para>
        /// </devdoc>
        public bool Cookies { 
            get { 
                if (!_havecookies) {
                    _cookies = CapsParseBool("cookies");   
                    _havecookies = true;
                }
                return _cookies;
            }
        }

        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.VBScript"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the client browser supports VBScript.</para>
        /// </devdoc>
        public bool VBScript { 
            get { 
                if (!_havevbscript) {
                    _vbscript = CapsParseBool("vbscript");  
                    _havevbscript = true;
                }
                return _vbscript;
            }
        }

        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.JavaScript"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the client browser supports JavaScript.</para>
        /// </devdoc>
        public bool JavaScript { 
            get { 
                if (!_havejavascript) {
                    _javascript=CapsParseBool("javascript");
                    _havejavascript = true;
                }
                return _javascript;
            }
        }

        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.JavaApplets"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the client browser supports Java Applets.</para>
        /// </devdoc>
        public bool JavaApplets { 
            get { 
                if (!_havejavaapplets) {
                    _javaapplets=CapsParseBool("javaapplets"); 
                    _havejavaapplets = true;
                }
                return _javaapplets;
            }
        }

        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.ActiveXControls"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the client browser supports ActiveX Controls.</para>
        /// </devdoc>
        public bool ActiveXControls { 
            get { 
                if (!_haveactivexcontrols) {
                    _activexcontrols=CapsParseBool("activexcontrols"); 
                    _haveactivexcontrols = true;
                }
                return _activexcontrols;
            }
        }
        
        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.BackgroundSounds"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the client browser supports background sounds.</para>
        /// </devdoc>
        public bool BackgroundSounds { 
            get { 
                if (!_havebackgroundsounds) {
                    _backgroundsounds=CapsParseBool("backgroundsounds"); 
                    _havebackgroundsounds = true;
                }
                return _backgroundsounds;
            }
        }
        
        /// <include file='doc\HttpBrowserCapabilities.uex' path='docs/doc[@for="HttpBrowserCapabilities.CDF"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the client browser supports Channel Definition Format (CDF) for webcasting.</para>
        /// </devdoc>
        public bool CDF { 
            get { 
                if (!_havecdf) {
                    _cdf = CapsParseBool("cdf");       
                    _havecdf = true;
                }
                return _cdf;
            }
        }


        private string  _type;
        private string  _browser;
        private string  _version;
        private int     _majorversion;
        private double  _minorversion;
        private string  _platform;
        private Type    _tagwriter;
        private Version _ecmascriptversion;
        private Version _msdomversion;
        private Version _w3cdomversion;
        private Version _clrVersion;
        private Version [] _clrVersions;
        
        private bool _beta;
        private bool _crawler;
        private bool _aol;
        private bool _win16;
        private bool _win32;

        private bool _frames;
        private bool _tables;
        private bool _cookies;
        private bool _vbscript;
        private bool _javascript;
        private bool _javaapplets;
        private bool _activexcontrols;
        private bool _backgroundsounds;
        private bool _cdf;

        private bool _havetype;
        private bool _havebrowser;
        private bool _haveversion;
        private bool _havemajorversion;
        private bool _haveminorversion;
        private bool _haveplatform;
        private bool _havetagwriter;
        private bool _haveecmascriptversion;
        private bool _havemsdomversion;
        private bool _havew3cdomversion;
        private bool _haveClrVersion;

        private bool _havebeta;
        private bool _havecrawler;
        private bool _haveaol;
        private bool _havewin16;
        private bool _havewin32;

        private bool _haveframes;
        private bool _havetables;
        private bool _havecookies;
        private bool _havevbscript;
        private bool _havejavascript;
        private bool _havejavaapplets;
        private bool _haveactivexcontrols;
        private bool _havebackgroundsounds;
        private bool _havecdf;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpcachevary.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpCacheVary.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Cache Vary class.  Wraps Vary header
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web {
    using System.Text;
    using System.Runtime.InteropServices;
    using System.Web.Util;
    using System.Security.Permissions;

    /// <include file='doc\HttpCacheVary.uex' path='docs/doc[@for="HttpCacheVaryByHeaders"]/*' />
    /// <devdoc>
    ///    <para>Indicates that a cache should contain multiple 
    ///       representations for a particular Uri. This class is an encapsulation that
    ///       provides a rich, type-safe way to set the Vary header.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpCacheVaryByHeaders {
        bool            _isModified;
        bool            _varyStar;
        HttpDictionary  _headers;

        internal HttpCacheVaryByHeaders() {
            Reset();
        }

        internal void Reset() {
            _isModified = false;
            _varyStar = false;
            _headers = null;
        }

        /*
         * Reset based on the cached vary headers.
         */
        internal void ResetFromHeaders(String[] headers) {
            int i, n;

            if (headers == null) {
                _isModified = false;
                _varyStar = false;
                _headers = null;
            }
            else {
                _isModified = true;
                if (headers[0].Equals("*")) {
                    Debug.Assert(headers.Length == 1, "headers.Length == 1");

                    _varyStar = true;
                    _headers = null;
                }
                else {
                    _varyStar = false;
                    _headers = new HttpDictionary();
                    for (i = 0, n = headers.Length; i < n; i++) {
                        _headers.SetValue(headers[i], headers[i]);
                    }
                }
            }
        }

        internal bool IsModified() {
            return _isModified;
        }

        /*
         * Construct header value string
         */
        internal String ToHeaderString() {
            StringBuilder   s;
            Object          item;
            int             i, n;

            if (_varyStar) {
                return "*";
            }
            else if (_headers != null) {
                s = new StringBuilder();

                for (i = 0, n = _headers.Size; i < n; i++) {
                    item = _headers.GetValue(i);
                    if (item != null) {
                        HttpCachePolicy.AppendValueToHeader(s, (String)item);
                    }
                }

                if (s.Length > 0)
                    return s.ToString();
            }

            return null;
        }

        /*
         * Returns the headers, for package access only.
         * 
         * @return the headers.
         */
        internal String[] GetHeaders() {
            String[]    s = null;
            Object      item;
            int         i, j, c, n;

            if (_varyStar) {
                return new String[1] {"*"};
            }
            else if (_headers != null) {
                n = _headers.Size;
                c = 0;
                for (i = 0; i < n; i++) {
                    item = _headers.GetValue(i);
                    if (item != null) {
                        c++;
                    }
                }

                if (c > 0) {
                    s = new string[c];
                    j = 0;
                    for (i = 0; i < n; i++) {
                        item = _headers.GetValue(i);
                        if (item != null) {
                            s[j] = (String) item;
                            j++;
                        }
                    }

                    Debug.Assert(j == c, "j == c");
                }
            }

            return s;
        }

        //
        // Public methods and properties
        //

        /// <include file='doc\HttpCacheVary.uex' path='docs/doc[@for="HttpCacheVaryByHeaders.VaryByUnspecifiedParameters"]/*' />
        /// <devdoc>
        ///    <para>Sets the "Vary: *" header and causes all other Vary:
        ///       header information to be dropped.</para>
        /// </devdoc>
        public void VaryByUnspecifiedParameters() {
            _isModified = true;
            _varyStar = true;
            _headers = null;
        }

        internal bool GetVaryByUnspecifiedParameters() {
            return _varyStar;
        }

        /*
         * Vary by accept types
         */
        /// <include file='doc\HttpCacheVary.uex' path='docs/doc[@for="HttpCacheVaryByHeaders.AcceptTypes"]/*' />
        /// <devdoc>
        ///    <para>Retrieves or assigns a value indicating whether the cache should vary by Accept types. This causes the
        ///       Vary: header to include an Accept field.</para>
        /// </devdoc>
        public bool AcceptTypes {
            get { 
                return this["Accept"]; 
            }

            set {         
                _isModified = true;
                this["Accept"] = value; 
            }
        }

        /*
         * Vary by accept language
         */
        /// <include file='doc\HttpCacheVary.uex' path='docs/doc[@for="HttpCacheVaryByHeaders.UserLanguage"]/*' />
        /// <devdoc>
        ///    <para> Retrieves or assigns a Boolean value indicating whether
        ///       the cache should vary by user language.</para>
        /// </devdoc>
        public bool UserLanguage {
            get { 
                return this["Accept-Language"]; 
            }

            set { 
                _isModified = true;
                this["Accept-Language"] = value; 
            }
        }

        /*
         * Vary by user agent
         */
        /// <include file='doc\HttpCacheVary.uex' path='docs/doc[@for="HttpCacheVaryByHeaders.UserAgent"]/*' />
        /// <devdoc>
        ///    <para> Retrieves or assigns a Boolean value indicating whether
        ///       the cache should vary by user agent.</para>
        /// </devdoc>
        public bool UserAgent {
            get {   
                return this["User-Agent"]; 
            }

            set { 
                _isModified = true;
                this["User-Agent"] = value; 
            }
        }

        /*
         * Vary by charset
         */
        /// <include file='doc\HttpCacheVary.uex' path='docs/doc[@for="HttpCacheVaryByHeaders.UserCharSet"]/*' />
        /// <devdoc>
        ///    <para> Retrieves or assigns a value indicating whether the
        ///       cache should vary by browser character set.</para>
        /// </devdoc>
        public bool UserCharSet {
            get { 
                return this["Accept-Charset"]; 
            }

            set { 
                _isModified = true;
                this["Accept-Charset"] = value; 
            }
        }

        /*
         * Vary by a given header
         */
        /// <include file='doc\HttpCacheVary.uex' path='docs/doc[@for="HttpCacheVaryByHeaders.this"]/*' />
        /// <devdoc>
        ///    <para> Default property.
        ///       Indexed property indicating that a cache should (or should not) vary according
        ///       to a custom header.</para>
        /// </devdoc>
        public bool this[String header]
        {
            get {
                if (header == null) {
                    throw new ArgumentNullException("header");
                }

                if (header.Equals("*")) {
                    return _varyStar;
                }
                else {
                    return (_headers != null && _headers.GetValue(header) != null);
                }
            }

            set {
                if (header == null) {
                    throw new ArgumentNullException("header");
                }

                /*
                 * Since adding a Vary header is more restrictive, we don't
                 * want components to be able to set a Vary header to false
                 * if another component has set it to true.
                 */
                if (value == false) {
                    return;
                }

                _isModified = true;

                if (header.Equals("*")) {
                    VaryByUnspecifiedParameters();
                }
                else {
                    // set value to header if true or null if false
                    if (!_varyStar) {
                        if (_headers == null) {
                            _headers = new HttpDictionary();
                        }

                        _headers.SetValue(header, header);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpapplicationfactory.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpApplicationFactory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * The HttpApplicationFactory class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web {
    using System.Text;
    using System.Threading;
    using System.Runtime.Remoting.Messaging;
    using System.Web;
    using System.Web.Caching;
    using System.Web.Util;
    using System.Web.UI;
    using System.Web.SessionState;
    using System.Collections;
    using System.Reflection;
    using System.IO;
    using System.Globalization;

    /*
     * Application Factory only has and public static methods to get / recycle
     * application instances.  The information cached per application
     * config file is encapsulated by ApplicationData class.
     * Only one static instance of application factory is created.
     */
    internal class HttpApplicationFactory {

        internal const string applicationFileName = "global.asax";

        // the only instance of application factory
        private static HttpApplicationFactory _theApplicationFactory = new HttpApplicationFactory();

        // flag to indicate that initialization was done
        private bool _inited;

        // filename for the global.asax
        private String _appFilename;
        private Hashtable _fileDependencies;

        // call application on_end only once
        private bool _appOnEndCalled = false;

        // dictionary of application state
        private HttpApplicationState _state;

        // class of the application object
        private Type _theApplicationType;

        // free list of app objects
        private Stack _freeList = new Stack();
        private int _numFreeAppInstances = 0;
        private const int _maxFreeAppInstances = 100;

        // free list of special (context-less) app objects 
        // to be used for global events (App_OnEnd, Session_OnEnd, etc.)
        private Stack _specialFreeList = new Stack();
        private int _numFreeSpecialAppInstances = 0;
        private const int _maxFreeSpecialAppInstances = 20;

        // results of the reflection on the app class
        private MethodInfo   _onStartMethod;        // Application_OnStart
        private int          _onStartParamCount;
        private MethodInfo   _onEndMethod;          // Application_OnEnd
        private int          _onEndParamCount;
        private MethodInfo   _sessionOnEndMethod;   // Session_OnEnd
        private int          _sessionOnEndParamCount;
        // list of methods suspected as event handlers
        private MethodInfo[] _eventHandlerMethods;


        internal HttpApplicationFactory() {
        }
        //
        // Initialization on first request
        //

        private void Init(HttpContext context) {
            if (_customApplication != null)
                return;

            using (new HttpContextWrapper(context)) {
                // impersonation could be required (UNC share or app credentials)
                context.Impersonation.Start(true, true);

                try {
                    try {
                        _appFilename = GetApplicationFile(context);

                        CompileApplication(context);

                        SetupChangesMonitor();
                    }
                    finally {
                        // revert after impersonation
                        context.Impersonation.Stop();
                    }
                }
                catch { // Protect against exception filters
                    throw;
                }

                // fire outside of impersonation as HttpApplication logic takes
                // care of impersonation by itself
                FireApplicationOnStart(context);
            }
        }

        internal static String GetApplicationFile(HttpContext context) {
            return Path.Combine(context.Request.PhysicalApplicationPath, applicationFileName);
        }

        private void CompileApplication(HttpContext context) {

            // Get the Application Type and AppState from the global file

            if (FileUtil.FileExists(_appFilename)) {
                ApplicationFileParser parser;

                // Perform the compilation
                _theApplicationType = ApplicationFileParser.GetCompiledApplicationType(_appFilename,
                    context, out parser);

                // Create app state
                _state = new HttpApplicationState(parser.ApplicationObjects, parser.SessionObjects);

                // Remember file dependencies
                _fileDependencies = parser.SourceDependencies;
            }
            else {
                _theApplicationType = typeof(HttpApplication);
                _state = new HttpApplicationState();
            }

            // Prepare to hookup event handlers via reflection

            ReflectOnApplicationType();
        }

        private bool ReflectOnMethodInfoIfItLooksLikeEventHandler(MethodInfo m) {
            if (m.ReturnType != typeof(void))
                return false;

            // has to have either no args or two args (object, eventargs)
            ParameterInfo[] parameters = m.GetParameters();

            switch (parameters.Length) {
                case 0:
                    // ok
                    break;
                case 2:
                    // param 0 must be object
                    if (parameters[0].ParameterType != typeof(System.Object))
                        return false;
                    // param 1 must be eventargs
                    if (parameters[1].ParameterType != typeof(System.EventArgs) &&
                        !parameters[1].ParameterType.IsSubclassOf(typeof(System.EventArgs)))
                        return false;
                    // ok
                    break;

                default:
                    return false;
            }

            // check the name (has to have _ not as first or last char)
            String name = m.Name;
            int j = name.IndexOf('_');
            if (j <= 0 || j > name.Length-1)
                return false;

            // special pseudo-events
            if (String.Compare(name, "Application_OnStart", true, CultureInfo.InvariantCulture) == 0 ||
                String.Compare(name, "Application_Start", true, CultureInfo.InvariantCulture) == 0) {
                _onStartMethod = m;
                _onStartParamCount = parameters.Length;
            }
            else if (String.Compare(name, "Application_OnEnd", true, CultureInfo.InvariantCulture) == 0 ||
                     String.Compare(name, "Application_End", true, CultureInfo.InvariantCulture) == 0) {
                _onEndMethod = m;
                _onEndParamCount = parameters.Length;
            }
            else if (String.Compare(name, "Session_OnEnd", true, CultureInfo.InvariantCulture) == 0 ||
                     String.Compare(name, "Session_End", true, CultureInfo.InvariantCulture) == 0) {
                _sessionOnEndMethod = m;
                _sessionOnEndParamCount = parameters.Length;
            }

            return true;
        }

        private void ReflectOnApplicationType() {
            ArrayList handlers = new ArrayList();
            MethodInfo[] methods;

            // get this class methods
            methods = _theApplicationType.GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
            foreach (MethodInfo m in methods) {
                if (ReflectOnMethodInfoIfItLooksLikeEventHandler(m))
                    handlers.Add(m);
            }
            
            // get base class private methods (GetMethods would not return those)
            Type baseType = _theApplicationType.BaseType;
            if (baseType != null && baseType != typeof(HttpApplication)) {
                methods = baseType.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);
                foreach (MethodInfo m in methods) {
                    if (m.IsPrivate && ReflectOnMethodInfoIfItLooksLikeEventHandler(m))
                        handlers.Add(m);
                }
            }

            // remember as an array
            _eventHandlerMethods = new MethodInfo[handlers.Count];
            for (int i = 0; i < _eventHandlerMethods.Length; i++)
                _eventHandlerMethods[i] = (MethodInfo)handlers[i];
        }

        private void SetupChangesMonitor() {
            FileChangeEventHandler handler = new FileChangeEventHandler(this.OnAppFileChange);

            HttpRuntime.FileChangesMonitor.StartMonitoringFile(_appFilename, handler);

            if (_fileDependencies != null) {
                IDictionaryEnumerator en = _fileDependencies.GetEnumerator();
                for (; en.MoveNext();) {
                    string fileName = (string)en.Value;
                    HttpRuntime.FileChangesMonitor.StartMonitoringFile(fileName, handler);
                }
            }
        }

        private void OnAppFileChange(Object sender, FileChangeEvent e) {
            // shutdown the app domain if app file changed
            Debug.Trace("AppDomainFactory", "Shutting down appdomain because of application file change");
            HttpRuntime.ShutdownAppDomain("Change in GLOBAL.ASAX");
        }

        //
        //  Application instance management
        //

        private HttpApplication GetNormalApplicationInstance(HttpContext context) {
            HttpApplication app = null;

            lock (_freeList) {
                if (_numFreeAppInstances > 0) {
                    app = (HttpApplication)_freeList.Pop();
                    _numFreeAppInstances--;
                }
            }

            if (app == null) {
                // If ran out of instances, create a new one
                app = (HttpApplication)HttpRuntime.CreateNonPublicInstance(_theApplicationType);

                // be run while impersonating the token given by IIS (ASURT 112766)
                context.Impersonation.Start(true /*forGlobalCode*/, false /*throwOnError*/);

                try {
                    try {
                        app.InitInternal(context, _state, _eventHandlerMethods);
                    }
                    finally {
                        context.Impersonation.Stop();
                    }
                }
                catch { // Protect against exception filters
                    throw;
                }
            }

            return app;
        }

        private void RecycleNormalApplicationInstance(HttpApplication app) {
            if (_numFreeAppInstances < _maxFreeAppInstances) {
                lock (_freeList) {
                    _freeList.Push(app);
                    _numFreeAppInstances++;
                }
            }
            else {
                app.DisposeInternal();
            }
        }

        private HttpApplication GetSpecialApplicationInstance() {
            HttpApplication app = null;

            lock (_specialFreeList) {
                if (_numFreeSpecialAppInstances > 0) {
                    app = (HttpApplication)_specialFreeList.Pop();
                    _numFreeSpecialAppInstances--;
                }
            }

            if (app == null) {
                // If ran out of instances, create a new one
                app = (HttpApplication)HttpRuntime.CreateNonPublicInstance(_theApplicationType);
                app.InitSpecial(_state, _eventHandlerMethods);
            }

            return app;
        }

        private void RecycleSpecialApplicationInstance(HttpApplication app) {
            if (_numFreeSpecialAppInstances < _maxFreeSpecialAppInstances) {
                lock (_specialFreeList) {
                    _specialFreeList.Push(app);
                    _numFreeSpecialAppInstances++;
                }
            }
            else {
                // don't dispose these
            }
        }

        //
        //  Application on_start / on_end
        //

        private void FireApplicationOnStart(HttpContext context) {
            if (_onStartMethod != null) {
                HttpApplication app = GetSpecialApplicationInstance();

                app.ProcessSpecialRequest(
                                         context,
                                         _onStartMethod,
                                         _onStartParamCount,
                                         this, 
                                         EventArgs.Empty, 
                                         null);

                RecycleSpecialApplicationInstance(app);
            }
        }

        private void FireApplicationOnEnd() {
            if (_onEndMethod != null) {
                HttpApplication app = GetSpecialApplicationInstance();

                app.ProcessSpecialRequest(
                                         null,
                                         _onEndMethod, 
                                         _onEndParamCount,
                                         this, 
                                         EventArgs.Empty, 
                                         null);

                RecycleSpecialApplicationInstance(app);
            }
        }

        private void FireSessionOnEnd(HttpSessionState session, Object eventSource, EventArgs eventArgs) {
            if (_sessionOnEndMethod != null) {
                HttpApplication app = GetSpecialApplicationInstance();

                app.ProcessSpecialRequest(
                                         null,
                                         _sessionOnEndMethod,
                                         _sessionOnEndParamCount,
                                         eventSource, 
                                         eventArgs, 
                                         session);

                RecycleSpecialApplicationInstance(app);
            }
        }

        private void FireApplicationOnError(Exception error) {
            HttpApplication app = GetSpecialApplicationInstance();
            app.RaiseErrorWithoutContext(error);
            RecycleSpecialApplicationInstance(app);
        }

        //
        //  Dispose resources associated with the app factory
        //

        private void Dispose() {
            // dispose all app instances

            ArrayList apps = new ArrayList();

            lock (_freeList) {
                while (_numFreeAppInstances > 0) {
                    apps.Add(_freeList.Pop());
                    _numFreeAppInstances--;
                }
            }

            int n = apps.Count;

            for (int i = 0; i < n; i++)
                ((HttpApplication)(apps[i])).DisposeInternal();

            // call application_onEnd

            if (!_appOnEndCalled) {
                lock (this) {
                    if (!_appOnEndCalled) {
                        FireApplicationOnEnd();
                        _appOnEndCalled = true;
                    }
                }
            }
        }

        //
        // Static methods for outside use
        //

        // custom application -- every request goes directly to the same handler
        private static IHttpHandler _customApplication;

        internal static void SetCustomApplication(IHttpHandler customApplication) {
            // ignore this in app domains where we execute requests (ASURT 128047)
            if (HttpRuntime.AppDomainAppIdInternal == null) // only if 'clean' app domain
                _customApplication = customApplication;
        }

        internal static IHttpHandler GetApplicationInstance(HttpContext context) {
            if (_customApplication != null)
                return _customApplication;

            // Check to see if it's a debug auto-attach request
            if (HttpDebugHandler.IsDebuggingRequest(context))
                return new HttpDebugHandler();

            if (!_theApplicationFactory._inited) {
                lock (_theApplicationFactory) {
                    if (!_theApplicationFactory._inited) {
                        _theApplicationFactory.Init(context);
                        _theApplicationFactory._inited = true;
                    }
                }
            }

            return _theApplicationFactory.GetNormalApplicationInstance(context);
        }

        internal static void RecycleApplicationInstance(HttpApplication app) {
            _theApplicationFactory.RecycleNormalApplicationInstance(app);
        }

        internal static void EndApplication() {
            _theApplicationFactory.Dispose();
        }

        internal static void EndSession(HttpSessionState session, Object eventSource, EventArgs eventArgs) {
            _theApplicationFactory.FireSessionOnEnd(session, eventSource, eventArgs);
        }

        internal static void RaiseError(Exception error) {
            _theApplicationFactory.FireApplicationOnError(error);
        }

        internal static HttpApplicationState ApplicationState {
            get {
                HttpApplicationState state = _theApplicationFactory._state;
                if (state == null)
                    state = new HttpApplicationState();
                return state;
            }
        }

        internal static Type ApplicationType {
            get {
                Type type = _theApplicationFactory._theApplicationType;
                if (type == null)
                    type = typeof(HttpApplication);
                return type;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpclientcertificate.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpClientCertificate.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Client Certificate 
 * 
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web {
    using System.Collections;
    using System.Collections.Specialized;
    using System.Globalization;
    using System.Security.Permissions;

    /// <include file='doc\HttpClientCertificate.uex' path='docs/doc[@for="HttpClientCertificate"]/*' />
    /// <devdoc>
    ///    <para>The HttpClientCertificate collection retrieves the certification fields 
    ///       (specified in the X.509 standard) from a request issued by the Web browser.</para>
    ///    <para>If a Web browser uses the SSL3.0/PCT1 protocol (in other words, it uses a URL 
    ///       starting with https:// instead of http://) to connect to a server and the server
    ///       requests certification, the browser sends the certification fields.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HttpClientCertificate  : NameValueCollection {
        /////////////////////////////////////////////////////////////////////////////
        // Properties
        /// <include file='doc\HttpClientCertificate.uex' path='docs/doc[@for="HttpClientCertificate.Cookie"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public    String    Cookie { get { return _Cookie;}}
        /// <include file='doc\HttpClientCertificate.uex' path='docs/doc[@for="HttpClientCertificate.Certificate"]/*' />
        /// <devdoc>
        /// A string containing the binary stream of the entire certificate content in ASN.1 format.
        /// </devdoc>
        public    byte []   Certificate { get { return _Certificate;}}
        /// <include file='doc\HttpClientCertificate.uex' path='docs/doc[@for="HttpClientCertificate.Flags"]/*' />
        /// <devdoc>
        ///    <para>A set of flags that provide additional client certificate information. </para>
        /// </devdoc>
        public    int       Flags { get { return _Flags;}}
        /// <include file='doc\HttpClientCertificate.uex' path='docs/doc[@for="HttpClientCertificate.KeySize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public    int       KeySize { get { return _KeySize;}}
        /// <include file='doc\HttpClientCertificate.uex' path='docs/doc[@for="HttpClientCertificate.SecretKeySize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public    int       SecretKeySize { get { return _SecretKeySize;}}
        /// <include file='doc\HttpClientCertificate.uex' path='docs/doc[@for="HttpClientCertificate.Issuer"]/*' />
        /// <devdoc>
        ///    <para>A string that contains a list of subfield values containing information about 
        ///       the issuer of the certificate.</para>
        /// </devdoc>
        public    String    Issuer { get { return _Issuer;}}
        /// <include file='doc\HttpClientCertificate.uex' path='docs/doc[@for="HttpClientCertificate.ServerIssuer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public    String    ServerIssuer { get { return _ServerIssuer;}}
        /// <include file='doc\HttpClientCertificate.uex' path='docs/doc[@for="HttpClientCertificate.Subject"]/*' />
        /// <devdoc>
        ///    <para>A string that contains a list of subfield values. The subfield values contain 
        ///       information about the subject of the certificate. If this value is specified
        ///       without a <paramref name="SubField"/>, the ClientCertificate collection returns a
        ///       comma-separated list of subfields. For example, C=US, O=Msft, and so on.</para>
        /// </devdoc>
        public    String    Subject { get { return _Subject;}}
        /// <include file='doc\HttpClientCertificate.uex' path='docs/doc[@for="HttpClientCertificate.ServerSubject"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public    String    ServerSubject { get { return _ServerSubject;}}
        /// <include file='doc\HttpClientCertificate.uex' path='docs/doc[@for="HttpClientCertificate.SerialNumber"]/*' />
        /// <devdoc>
        ///    <para>A string that contains the certification serial number as an ASCII 
        ///       representation of hexadecimal bytes separated by hyphens (-). For example,
        ///       04-67-F3-02.</para>
        /// </devdoc>
        public    String    SerialNumber { get { return _SerialNumber;}}
        /// <include file='doc\HttpClientCertificate.uex' path='docs/doc[@for="HttpClientCertificate.ValidFrom"]/*' />
        /// <devdoc>
        ///    <para>A date specifying when the certificate becomes valid. This date varies with 
        ///       international settings. </para>
        /// </devdoc>
        public    DateTime  ValidFrom { get { return _ValidFrom;}}
        /// <include file='doc\HttpClientCertificate.uex' path='docs/doc[@for="HttpClientCertificate.ValidUntil"]/*' />
        /// <devdoc>
        ///    <para>A date specifying when the certificate expires. The year value is displayed 
        ///       as a four-digit number.</para>
        /// </devdoc>
        public    DateTime  ValidUntil { get { return _ValidUntil;}}

        /// <include file='doc\HttpClientCertificate.uex' path='docs/doc[@for="HttpClientCertificate.CertEncoding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public    int       CertEncoding    { get { return _CertEncoding;}}
        /// <include file='doc\HttpClientCertificate.uex' path='docs/doc[@for="HttpClientCertificate.PublicKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public    byte []   PublicKey       { get { return _PublicKey;}}
        /// <include file='doc\HttpClientCertificate.uex' path='docs/doc[@for="HttpClientCertificate.BinaryIssuer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public    byte []   BinaryIssuer    { get { return _BinaryIssuer;}}

        /// <include file='doc\HttpClientCertificate.uex' path='docs/doc[@for="HttpClientCertificate.IsPresent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public    bool      IsPresent       { get { return((_Flags & 0x1) == 1);}}
        /// <include file='doc\HttpClientCertificate.uex' path='docs/doc[@for="HttpClientCertificate.IsValid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public    bool      IsValid         { get { return((_Flags & 0x2) == 0);}}

        /////////////////////////////////////////////////////////////////////////////
        // Ctor
        internal HttpClientCertificate(HttpContext context) {
            String flags    = context.Request.ServerVariables["CERT_FLAGS"];
            if (flags != null && flags.Length > 0)
                _Flags = Int32.Parse(flags);
            else
                _Flags = 0;

            if (IsPresent == false)
                return;


            _Cookie         = context.Request.ServerVariables["CERT_COOKIE"];
            _Issuer         = context.Request.ServerVariables["CERT_ISSUER"];
            _ServerIssuer   = context.Request.ServerVariables["CERT_SERVER_ISSUER"];
            _Subject        = context.Request.ServerVariables["CERT_SUBJECT"];
            _ServerSubject  = context.Request.ServerVariables["CERT_SERVER_SUBJECT"];
            _SerialNumber   = context.Request.ServerVariables["CERT_SERIALNUMBER"];

            _Certificate    = context.WorkerRequest.GetClientCertificate();
            _ValidFrom      = context.WorkerRequest.GetClientCertificateValidFrom();
            _ValidUntil     = context.WorkerRequest.GetClientCertificateValidUntil();
            _BinaryIssuer   = context.WorkerRequest.GetClientCertificateBinaryIssuer();
            _PublicKey      = context.WorkerRequest.GetClientCertificatePublicKey();
            _CertEncoding   = context.WorkerRequest.GetClientCertificateEncoding();

            String keySize  = context.Request.ServerVariables["CERT_KEYSIZE"];
            String skeySize = context.Request.ServerVariables["CERT_SECRETKEYSIZE"];

            if (keySize != null && keySize.Length > 0)
                _KeySize = Int32.Parse(keySize);
            if (skeySize != null && skeySize.Length > 0)
                _SecretKeySize = Int32.Parse(skeySize);

            Add("ISSUER",        null);
            Add("SUBJECTEMAIL",  null);
            Add("BINARYISSUER",  null);
            Add("FLAGS",         null);
            Add("ISSUERO",       null);
            Add("PUBLICKEY",     null);
            Add("ISSUEROU",      null);
            Add("ENCODING",      null);
            Add("ISSUERCN",      null);
            Add("SERIALNUMBER",  null);
            Add("SUBJECT",       null);
            Add("SUBJECTCN",     null);
            Add("CERTIFICATE",   null);
            Add("SUBJECTO",      null);
            Add("SUBJECTOU",     null);
            Add("VALIDUNTIL",    null);
            Add("VALIDFROM",     null);
        }

        /// <include file='doc\HttpClientCertificate.uex' path='docs/doc[@for="HttpClientCertificate.Get"]/*' />
        /// <devdoc>
        ///    <para>Allows access to individual items in the collection by name.</para>
        /// </devdoc>
        public override String Get(String field)
        { 
            if (field == null)
                return String.Empty;

            field = field.ToLower(CultureInfo.InvariantCulture);

            switch (field) {
                case "cookie":
                    return Cookie;

                case "flags":
                    return Flags.ToString("G");

                case "keysize":
                    return KeySize.ToString("G");

                case "secretkeysize":
                    return SecretKeySize.ToString();

                case "issuer":
                    return Issuer;

                case "serverissuer":
                    return ServerIssuer;

                case "subject":
                    return Subject;

                case "serversubject":
                    return ServerSubject;

                case "serialnumber":
                    return SerialNumber;

                case "certificate":
                    return System.Text.Encoding.Default.GetString(Certificate);

                case "binaryissuer":
                    return System.Text.Encoding.Default.GetString(BinaryIssuer);

                case "publickey":
                    return System.Text.Encoding.Default.GetString(PublicKey);

                case "encoding":
                    return CertEncoding.ToString("G");

                case "validfrom":
                    return HttpUtility.FormatHttpDateTime(ValidFrom);

                case "validuntil":
                    return HttpUtility.FormatHttpDateTime(ValidUntil);
            }

            if (field.StartsWith("issuer"))
                return ExtractString(Issuer, field.Substring(6));

            if (field.StartsWith("subject")) {
                if (field.Equals("subjectemail"))
                    return ExtractString(Subject, "e");
                else
                    return ExtractString(Subject, field.Substring(7));
            }

            if (field.StartsWith("serversubject"))
                return ExtractString(ServerSubject, field.Substring(13));

            if (field.StartsWith("serverissuer"))
                return ExtractString(ServerIssuer, field.Substring(12));

            return String.Empty;
        }

        /////////////////////////////////////////////////////////////////////////////
        // Private data
        private    String    _Cookie              = "";
        private    byte []   _Certificate         = new byte[0];
        private    int       _Flags;
        private    int       _KeySize;
        private    int       _SecretKeySize;
        private    String    _Issuer              = "";
        private    String    _ServerIssuer        = "";
        private    String    _Subject             = "";
        private    String    _ServerSubject       = "";
        private    String    _SerialNumber        = "";
        private    DateTime  _ValidFrom           = DateTime.Now;
        private    DateTime  _ValidUntil          = DateTime.Now;
        private    int       _CertEncoding;
        private    byte []   _PublicKey           = new byte[0];
        private    byte []   _BinaryIssuer        = new byte[0];

        private String ExtractString(String strAll, String strSubject) {
            if (strAll == null || strSubject == null)
                return String.Empty;

            String strReturn = "";
            int    iStart    = 0;
            String strAllL   = strAll.ToLower(CultureInfo.InvariantCulture);

            while (iStart < strAllL.Length) {
                iStart = strAllL.IndexOf(strSubject + "=", iStart);
                if (iStart < 0)
                    return strReturn;
                if (strReturn.Length > 0)
                    strReturn += ";";

                iStart += strSubject.Length + 1;        
                int iEnd = 0;
                if (strAll[iStart]=='"') {
                    iStart++;
                    iEnd  = strAll.IndexOf('"' , iStart);
                }
                else
                    iEnd  = strAll.IndexOf(',' , iStart);

                if (iEnd < 0)
                    iEnd = strAll.Length;

                strReturn += strAll.Substring(iStart, iEnd - iStart);
                iStart = iEnd + 1;
            }

            return strReturn;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpcookiecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpCookieCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Collection of Http cookies for request and response intrinsics
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web {

    using System.Runtime.InteropServices;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Security.Permissions;

    /// <include file='doc\HttpCookieCollection.uex' path='docs/doc[@for="HttpCookieCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides a type-safe
    ///       way to manipulate HTTP cookies.
    ///    </para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpCookieCollection : NameObjectCollectionBase {
        // Response object to notify about changes in collection
        private HttpResponse _response;

        // cached All[] arrays
        private HttpCookie[] _all;
        private String[] _allKeys;

        internal HttpCookieCollection(HttpResponse response, bool readOnly) {
            _response = response;
            IsReadOnly = readOnly;
        }

        /// <include file='doc\HttpCookieCollection.uex' path='docs/doc[@for="HttpCookieCollection.HttpCookieCollection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the HttpCookieCollection
        ///       class.
        ///    </para>
        /// </devdoc>
        public HttpCookieCollection() {
        }

        internal void AddCookie(HttpCookie cookie, bool append) {
            _all = null;
            _allKeys = null;

            if (append)
                BaseAdd(cookie.Name, cookie);
            else
                BaseSet(cookie.Name, cookie);
        }

        internal void RemoveCookie(String name) {
            _all = null;
            _allKeys = null;

            BaseRemove(name);
        }

        internal void Reset() {
            _all = null;
            _allKeys = null;

            BaseClear();
        }

        //
        //  Public APIs to add / remove
        //

        /// <include file='doc\HttpCookieCollection.uex' path='docs/doc[@for="HttpCookieCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a cookie to the collection.
        ///    </para>
        /// </devdoc>
        public void Add(HttpCookie cookie) {
            if (_response != null)
                _response.BeforeCookieCollectionChange();

            AddCookie(cookie, true);

            if (_response != null)
                _response.OnCookieAdd(cookie);
        }
        
        /// <include file='doc\HttpCookieCollection.uex' path='docs/doc[@for="HttpCookieCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Array dest, int index) {
            if (_all == null) {
                int n = Count;
                _all = new HttpCookie[n];

                for (int i = 0; i < n; i++)
                    _all[i] = Get(i);
            }
            _all.CopyTo(dest, index);
        }

        /// <include file='doc\HttpCookieCollection.uex' path='docs/doc[@for="HttpCookieCollection.Set"]/*' />
        /// <devdoc>
        ///    <para> Updates the value of a cookie.</para>
        /// </devdoc>
        public void Set(HttpCookie cookie) {
            if (_response != null)
                _response.BeforeCookieCollectionChange();

            AddCookie(cookie, false);

            if (_response != null)
                _response.OnCookieCollectionChange();
        }

        /// <include file='doc\HttpCookieCollection.uex' path='docs/doc[@for="HttpCookieCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes a cookie from the collection.
        ///    </para>
        /// </devdoc>
        public void Remove(String name) {
            if (_response != null)
                _response.BeforeCookieCollectionChange();

            RemoveCookie(name);

            if (_response != null)
                _response.OnCookieCollectionChange();
        }

        /// <include file='doc\HttpCookieCollection.uex' path='docs/doc[@for="HttpCookieCollection.Clear"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Clears all cookies from the collection.
        ///    </para>
        /// </devdoc>
        public void Clear() {
            Reset();
        }

        //
        //  Access by name
        //

        /// <include file='doc\HttpCookieCollection.uex' path='docs/doc[@for="HttpCookieCollection.Get"]/*' />
        /// <devdoc>
        /// <para>Returns an <see cref='System.Web.HttpCookie'/> item from the collection.</para>
        /// </devdoc>
        public HttpCookie Get(String name) {
            HttpCookie cookie = (HttpCookie)BaseGet(name);

            if (cookie == null && _response != null) {
                // response cookies are created on demand
                cookie = new HttpCookie(name);
                AddCookie(cookie, true);
                _response.OnCookieAdd(cookie);
            }

            return cookie;
        }

        /// <include file='doc\HttpCookieCollection.uex' path='docs/doc[@for="HttpCookieCollection.this"]/*' />
        /// <devdoc>
        ///    <para>Indexed value that enables access to a cookie in the collection.</para>
        /// </devdoc>
        public HttpCookie this[String name]
        {
            get { return Get(name);}
        }

        //
        // Indexed access
        //

        /// <include file='doc\HttpCookieCollection.uex' path='docs/doc[@for="HttpCookieCollection.Get1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns an <see cref='System.Web.HttpCookie'/>
        ///       item from the collection.
        ///    </para>
        /// </devdoc>
        public HttpCookie Get(int index) {
            return(HttpCookie)BaseGet(index);
        }

        /// <include file='doc\HttpCookieCollection.uex' path='docs/doc[@for="HttpCookieCollection.GetKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns key name from collection.
        ///    </para>
        /// </devdoc>
        public String GetKey(int index) {
            return BaseGetKey(index);
        }

        /// <include file='doc\HttpCookieCollection.uex' path='docs/doc[@for="HttpCookieCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Default property.
        ///       Indexed property that enables access to a cookie in the collection.
        ///    </para>
        /// </devdoc>
        public HttpCookie this[int index]
        {
            get { return Get(index);}
        }

        //
        // Access to keys and values as arrays
        //
        
        /*
         * All keys
         */
        /// <include file='doc\HttpCookieCollection.uex' path='docs/doc[@for="HttpCookieCollection.AllKeys"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns
        ///       an array of all cookie keys in the cookie collection.
        ///    </para>
        /// </devdoc>
        public String[] AllKeys {
            get {
                if (_allKeys == null)
                    _allKeys = BaseGetAllKeys();

                return _allKeys;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpcookie.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpCookie.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HttpCookie - collection + name + path
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web {
    using System.Text;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Globalization;
    using System.Security.Permissions;

    /// <include file='doc\HttpCookie.uex' path='docs/doc[@for="HttpCookie"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides a type-safe way
    ///       to access multiple HTTP cookies.
    ///    </para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpCookie {
        private String _name;
        private String _path = "/";
        private bool _secure;
        private String _domain;
        private bool _expirationSet;
        private DateTime _expires;

        private String _stringValue;
        private HttpValueCollection _multiValue;


        internal HttpCookie() {
        }

        /*
         * Constructor - empty cookie with name
         */
        /// <include file='doc\HttpCookie.uex' path='docs/doc[@for="HttpCookie.HttpCookie"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.HttpCookie'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public HttpCookie(String name) {
            _name = name;
        }

        /*
         * Constructor - cookie with name and value
         */
        /// <include file='doc\HttpCookie.uex' path='docs/doc[@for="HttpCookie.HttpCookie1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.HttpCookie'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public HttpCookie(String name, String value) {
            _name = name;
            _stringValue = value;
        }

        /*
         * Cookie name
         */
        /// <include file='doc\HttpCookie.uex' path='docs/doc[@for="HttpCookie.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the name of cookie.
        ///    </para>
        /// </devdoc>
        public String Name {
            get { return _name;}
            set { _name = value;}
        }

        /*
         * Cookie path
         */
        /// <include file='doc\HttpCookie.uex' path='docs/doc[@for="HttpCookie.Path"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the URL prefix to transmit with the
        ///       current cookie.
        ///    </para>
        /// </devdoc>
        public String Path {
            get { return _path;}
            set { _path = value;}
        }

        /*
         * 'Secure' flag
         */
        /// <include file='doc\HttpCookie.uex' path='docs/doc[@for="HttpCookie.Secure"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the cookie should be transmitted only over HTTPS.
        ///    </para>
        /// </devdoc>
        public bool Secure {
            get { return _secure;}
            set { _secure = value;}
        }

        /*
         * Cookie domain
         */
        /// <include file='doc\HttpCookie.uex' path='docs/doc[@for="HttpCookie.Domain"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Restricts domain cookie is to be used with.
        ///    </para>
        /// </devdoc>
        public String Domain {
            get { return _domain;}
            set { _domain = value;}
        }

        /*
         * Cookie expiration
         */
        /// <include file='doc\HttpCookie.uex' path='docs/doc[@for="HttpCookie.Expires"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Expiration time for cookie (in minutes).
        ///    </para>
        /// </devdoc>
        public DateTime Expires {
            get {
                return(_expirationSet ? _expires : DateTime.MinValue);
            }

            set {
                _expires = value;
                _expirationSet = true;
            }
        }

        /*
         * Cookie value as string
         */
        /// <include file='doc\HttpCookie.uex' path='docs/doc[@for="HttpCookie.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or
        ///       sets an individual cookie value.
        ///    </para>
        /// </devdoc>
        public String Value {
            get {
                if (_multiValue != null)
                    return _multiValue.ToString(false);
                else
                    return _stringValue;
            }

            set {
                if (_multiValue != null) {
                    // reset multivalue collection to contain
                    // single keyless value
                    _multiValue.Reset();
                    _multiValue.Add(null, value);
                }
                else {
                    // remember as string
                    _stringValue = value;
                }
            }
        }

        /*
         * Checks is cookie has sub-keys
         */
        /// <include file='doc\HttpCookie.uex' path='docs/doc[@for="HttpCookie.HasKeys"]/*' />
        /// <devdoc>
        ///    <para>Gets a
        ///       value indicating whether the cookie has sub-keys.</para>
        /// </devdoc>
        public bool HasKeys {
            get { return Values.HasKeys();}
        }

        /*
         * Cookie values as multivalue collection
         */
        /// <include file='doc\HttpCookie.uex' path='docs/doc[@for="HttpCookie.Values"]/*' />
        /// <devdoc>
        ///    <para>Gets individual key:value pairs within a single cookie object.</para>
        /// </devdoc>
        public NameValueCollection Values {
            get {
                if (_multiValue == null) {
                    // create collection on demand
                    _multiValue = new HttpValueCollection();

                    // convert existing string value into multivalue
                    if (_stringValue != null) {
                        if (_stringValue.IndexOf('&') >= 0 || _stringValue.IndexOf('=') >= 0)
                            _multiValue.FillFromString(_stringValue);
                        else
                            _multiValue.Add(null, _stringValue);

                        _stringValue = null;
                    }
                }

                return _multiValue;
            }
        }

        /*
         * Default indexed property -- lookup the multivalue collection
         */
        /// <include file='doc\HttpCookie.uex' path='docs/doc[@for="HttpCookie.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Shortcut for HttpCookie$Values[key]. Required for ASP compatibility.
        ///    </para>
        /// </devdoc>
        public String this[String key]
        {
            get { 
                return Values[key]; 
            }

            set {
                Values[key] = value;
            }
        }

        /*
         * Construct set-cookie header
         */
        internal HttpResponseHeader GetSetCookieHeader() {
            StringBuilder s = new StringBuilder();

            // cookiename=
            if (_name != null && _name.Length > 0) {
                s.Append(_name);
                s.Append('=');
            }

            // key=value&...
            if (_multiValue != null)
                s.Append(_multiValue.ToString(false));
            else if (_stringValue != null)
                s.Append(_stringValue);

            // domain
            if (_domain != null && _domain.Length > 0) {
                s.Append("; domain=");
                s.Append(_domain);
            }

            // expiration
            if (_expirationSet && _expires != DateTime.MinValue) {
                s.Append("; expires=");
                s.Append(HttpUtility.FormatHttpCookieDateTime(_expires));
            }

            // path
            if (_path != null && _path.Length > 0) {
                s.Append("; path=");
                s.Append(_path);
            }

            // secure
            if (_secure)
                s.Append("; secure");

            // return as HttpResponseHeader
            return new HttpResponseHeader(HttpWorkerRequest.HeaderSetCookie, s.ToString());
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpcontext.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HttpContext class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web {
    using System.Collections;
    using System.Configuration;
    using System.Globalization;
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.Security.Principal;
    using System.Threading;
    using System.Web.Security;
    using System.Web.SessionState;
    using System.Web.Configuration;
    using System.Web.Caching;
    using System.Web.Util;
    using System.Web.UI;
    using System.Runtime.Remoting.Messaging;
    using System.Security.Permissions;

    /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext"]/*' />
    /// <devdoc>
    ///    <para>Encapsulates
    ///       all HTTP-specific
    ///       context used by the HTTP server to process Web requests.</para>
    /// <para>System.Web.IHttpModules and System.Web.IHttpHandler instances are provided a 
    ///    reference to an appropriate HttpContext object. For example
    ///    the Request and Response
    ///    objects.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpContext : IServiceProvider {
        private IHttpAsyncHandler  _asyncAppHandler;   // application as handler (not always HttpApplication)
        private HttpApplication    _appInstance;
        private IHttpHandler       _handler;
        private HttpRequest        _request;
        private HttpResponse       _response;
        private HttpServerUtility  _server;
        private Stack              _traceContextStack;
        private TraceContext       _topTraceContext;
        private Hashtable          _items;
        private ArrayList          _errors;
        private Exception          _tempError;
        private bool               _errorCleared = false;
        private IPrincipal         _user;
        private DateTime           _utcTimestamp;
        private HttpWorkerRequest  _wr;
        private GCHandle           _root;
        private string             _configPath;
        private bool               _skipAuthorization;
        private CultureInfo        _dynamicCulture;
        private CultureInfo        _dynamicUICulture;
        private int                _serverExecuteDepth;

        // impersonation support
        private ImpersonationData _impersonation;

        // timeout support
        private DateTime   _timeoutStartTime;
        private bool       _timeoutSet;
        private TimeSpan   _timeout;
        private int        _timeoutState;   // 0=non-cancelable, 1=cancelable, -1=canceled
        private DoubleLink _timeoutLink;    // link in the timeout's manager list

        // cached configuration
        private HttpConfigurationRecord _configrecord;

        // name of the slot in call context
        internal const String CallContextSlotName = "HtCt";


        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.HttpContext"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the HttpContext class.
        ///    </para>
        /// </devdoc>
        public HttpContext(HttpRequest request, HttpResponse response) {
            Init(request, response);
        }

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.HttpContext1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the HttpContext class.
        ///    </para>
        /// </devdoc>
        public HttpContext(HttpWorkerRequest wr) {
            _wr = wr;
            Init(new HttpRequest(wr, this), new HttpResponse(wr, this));
            _response.InitResponseWriter();
        }

        // ctor used in HttpRuntime
        internal HttpContext(HttpWorkerRequest wr, bool initResponseWriter) {
            _wr = wr;
            Init(new HttpRequest(wr, this), new HttpResponse(wr, this));

            if (initResponseWriter)
                _response.InitResponseWriter();

            PerfCounters.IncrementCounter(AppPerfCounter.REQUESTS_EXECUTING);
        }

        // Used to implement Clone(), used in batch compilation
        // We only copy the fields necessary to perform batch compilation.
        private HttpContext(HttpContext context) {
            //_asyncAppHandler = context._asyncAppHandler;
            _appInstance = context._appInstance;
            //_handler = context._handler;
            _request = context._request;
            _response = context._response;
            _server = context._server;
            //_traceContextStack = context._traceContextStack;
            //_topTraceContext = context._topTraceContext;
            //_items = context._items;
            //_errors = context._errors;
            //_tempError = context._tempError;
            //_errorCleared = context._errorCleared;
            _user = context._user;
            //_utcTimestamp = context._utcTimestamp;
            _wr = context._wr;
            //_root = context._root;
            _configPath = context._configPath;
            //_skipAuthorization = context._skipAuthorization;
            //_dynamicCulture = context._dynamicCulture;
            //_dynamicUICulture = context._dynamicUICulture;
            //_impersonation = context._impersonation;
            //_timeoutStartTime = context._timeoutStartTime;
            //_timeoutSet = context._timeoutSet;
            //_timeout = context._timeout;
            //_timeoutState = context._timeoutState;
            //_timeoutLink = context._timeoutLink;
            _configrecord = context._configrecord;
        }

        // Clone this context.  Used by batch compilation (ASURT 82744)
        internal HttpContext Clone() {
            return new HttpContext(this);
        }

        private void Init(HttpRequest request, HttpResponse response) {
            _request = request;
            _response = response;
            _utcTimestamp = DateTime.UtcNow;

            Profiler p = HttpRuntime.Profile;
            if (p != null && p.IsEnabled)
                _topTraceContext = new TraceContext(this);
        }

        // Current HttpContext off the call context

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.Current"]/*' />
        /// <devdoc>
        ///    <para>Returns the current HttpContext object.</para>
        /// </devdoc>
        public static HttpContext Current {
            get {
                return CallContext.GetData(CallContextSlotName) as HttpContext;
            }

            set {
                InternalSecurityPermissions.UnmanagedCode.Demand();
                CallContext.SetData(HttpContext.CallContextSlotName, value);
            }
        }

        //
        //  Root / unroot for the duration of async operation
        //

        internal void Root() {
            _root = GCHandle.Alloc(this);
        }

        internal void Unroot() {
            _root.Free();
        }

        // IServiceProvider implementation
        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.IServiceProvider.GetService"]/*' />
        /// <internalonly/>
        Object IServiceProvider.GetService(Type service) {
            Object obj;

            if (service == typeof(HttpWorkerRequest)) {
                InternalSecurityPermissions.UnmanagedCode.Demand();
                obj = _wr;
            }
            else if (service == typeof(HttpRequest))
                obj = Request;
            else if (service == typeof(HttpResponse))
                obj = Response;
            else if (service == typeof(HttpApplication))
                obj = ApplicationInstance;
            else if (service == typeof(HttpApplicationState))
                obj = Application;
            else if (service == typeof(HttpSessionState))
                obj = Session;
            else if (service == typeof(HttpServerUtility))
                obj = Server;
            else
                obj = null;

            return obj;
        }

        //
        // Async app handler is remembered for the duration of execution of the
        // request when application happens to be IHttpAsyncHandler. It is needed
        // for HttpRuntime to remember the object on which to call OnEndRequest.
        //
        // The assumption is that application is a IHttpAsyncHandler, not always
        // HttpApplication.
        //
        internal IHttpAsyncHandler AsyncAppHandler {
            get { return _asyncAppHandler; }
            set { _asyncAppHandler = value; }
        }


        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.ApplicationInstance"]/*' />
        /// <devdoc>
        ///    <para>Retrieves a reference to the application object for the current Http request.</para>
        /// </devdoc>
        public HttpApplication ApplicationInstance { 
            get { return _appInstance;} 
            set { _appInstance = value;} 
        }

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.Application"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a reference to the application object for the current
        ///       Http request.
        ///    </para>
        /// </devdoc>
        public HttpApplicationState Application {
            get { return HttpApplicationFactory.ApplicationState; }
        }

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.Handler"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves or assigns a reference to the <see cref='System.Web.IHttpHandler'/>
        ///       object for the current request.
        ///    </para>
        /// </devdoc>
        public IHttpHandler Handler {
            get { return _handler;}
            set { _handler = value;}
        }

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.Request"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a reference to the target <see cref='System.Web.HttpRequest'/>
        ///       object for the current request.
        ///    </para>
        /// </devdoc>
        public HttpRequest Request {
            get { return _request;} 
        }

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.Response"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a reference to the <see cref='System.Web.HttpResponse'/>
        ///       object for the current response.
        ///    </para>
        /// </devdoc>
        public HttpResponse Response {
            get { return _response;}
        }

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.Trace"]/*' />
        /// <devdoc>
        /// <para>Retrieves a reference to the <see cref='System.Web.TraceContext'/> object for the current 
        ///    response.</para>
        /// </devdoc>
        public TraceContext Trace {
            get { 
                if (_topTraceContext == null)
                    _topTraceContext = new TraceContext(this);
                return _topTraceContext;
            }
        }

        internal bool TraceIsEnabled {
            get {
                if (_topTraceContext == null)
                    return false;

                return _topTraceContext.IsEnabled;
            }
            set {
                if (value)
                    _topTraceContext = new TraceContext(this);
            }
                    
        }
        

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.Items"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a key-value collection that can be used to
        ///       build up and share data between an <see cref='System.Web.IHttpModule'/> and an <see cref='System.Web.IHttpHandler'/>
        ///       during a
        ///       request.
        ///    </para>
        /// </devdoc>
        public IDictionary Items {
            get {
                if (_items == null)
                    _items = new Hashtable();

                return _items;
            }
        }

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.Session"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a reference to the <see cref='System.Web.SessionState'/> instance for the current request.
        ///    </para>
        /// </devdoc>
        public HttpSessionState Session {
            get { return(HttpSessionState)Items[SessionStateModule.SESSION_KEY];}
        }

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.Server"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a reference to the <see cref='System.Web.HttpServerUtility'/>
        ///       for the current
        ///       request.
        ///    </para>
        /// </devdoc>
        public HttpServerUtility Server {
            get {
                // create only on demand
                if (_server == null)
                    _server = new HttpServerUtility(this);
                return _server;
            }
        }

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.Error"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the
        ///       first error (if any) accumulated during request processing.
        ///    </para>
        /// </devdoc>
        public Exception Error {
            get {
                if (_tempError != null)
                    return _tempError;
                if (_errors == null || _errors.Count == 0 || _errorCleared)
                    return null;
                return (Exception)_errors[0];
            }
        }

        //
        // Temp error (yet to be caught on app level)
        // to be reported as Server.GetLastError() but could be cleared later
        //
        internal Exception TempError {
            get { return _tempError; }
            set { _tempError = value; }
        }

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.AllErrors"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An array (collection) of errors accumulated while processing a
        ///       request.
        ///    </para>
        /// </devdoc>
        public Exception[] AllErrors {
            get {
                int n = (_errors != null) ? _errors.Count : 0;

                if (n == 0)
                    return null;

                Exception[] errors = new Exception[n];
                _errors.CopyTo(0, errors, 0, n);
                return errors;
            }
        }

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.AddError"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Registers an error for the current request.
        ///    </para>
        /// </devdoc>
        public void AddError(Exception errorInfo) {
            if (_errors == null)
                _errors = new ArrayList();

            _errors.Add(errorInfo);
        }

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.ClearError"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Clears all errors for the current request.
        ///    </para>
        /// </devdoc>
        public void ClearError() {
            if (_tempError != null)
                _tempError = null;
            else
                _errorCleared = true;
        }

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.User"]/*' />
        /// <devdoc>
        ///    <para>
        ///       IPrincipal security information.
        ///    </para>
        /// </devdoc>
        public IPrincipal User {
            get { return _user;} 
            set { 
                InternalSecurityPermissions.ControlPrincipal.Demand();
                _user = value;
            }
        }

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.SkipAuthorization"]/*' />
        public bool SkipAuthorization {
            get { return _skipAuthorization;} 
            set { 
                InternalSecurityPermissions.ControlPrincipal.Demand();
                _skipAuthorization = value;
            }
        }



        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.IsDebuggingEnabled"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Is this request in debug mode?
        ///    </para>
        /// </devdoc>
        public bool IsDebuggingEnabled {
            get {
                try {
                    return CompilationConfiguration.IsDebuggingEnabled(this); 
                }
                catch (Exception) {
                    // in case of config errors don't throw
                    return false;
                }
            }
        }

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.IsCustomErrorEnabled"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Is this custom error enabled for this request?
        ///    </para>
        /// </devdoc>
        public bool IsCustomErrorEnabled {
            get {
                return CustomErrors.GetSettings(this).CustomErrorsEnabled(_request);
            }
        }

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.Timestamp"]/*' />
        /// <devdoc>
        ///    <para>Gets the initial timestamp of the current request.</para>
        /// </devdoc>
        public DateTime Timestamp {
            get { return _utcTimestamp.ToLocalTime();}
        }

        internal DateTime UtcTimestamp {
            get { return _utcTimestamp;}
        }

        internal HttpWorkerRequest WorkerRequest {
            get { return _wr;} 
        }

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.Cache"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a reference to the System.Web.Cache.Cache object for the current request.
        ///    </para>
        /// </devdoc>
        public Cache Cache {
            get { return HttpRuntime.Cache;}
        }

        /*
         * The virtual path used to get config settings.  This allows the user
         * to specify a non default config path, without having to pass it to every
         * configuration call.
         */
        internal string ConfigPath {
            get {
                if (_configPath == null)
                    _configPath = _request.FilePath;
                
                return _configPath;
            }

            set {
                _configPath = value;
                _configrecord = null;
            }
        }

        /*
         * Uses the Config system to get the specified configuraiton
         *
         * The following method is the only accessors to the config system,
         * and it wraps config exceptions with an explanatory HTTP
         * exception with an error formatter. It also makes sure the client
         * is not impersonated while accessing the config system.
         */
        private HttpConfigurationRecord GetCompleteConfigRecord(String reqpath, IHttpMapPath configmap) {
            HttpConfigurationRecord configrecord = null;

            HttpContext.ImpersonationSuspendContext ictx = Impersonation.SuspendIfClient();

            try {
                try {
                    if (reqpath == null || reqpath.Length == 0 || HttpRuntime.IsPathWithinAppRoot(reqpath)) {
                        // lookup by path
                        using (new HttpContextWrapper(this)) {
                            configrecord = HttpConfigurationSystem.GetComplete(reqpath, _wr);
                        }
                    }
                    else {
                        // if the path is outside of the application (and not site or machine)
                        // then use application config
                        configrecord = HttpConfigurationSystem.GetCompleteForApp();
                    }
                }
                finally {
                    ictx.Resume();
                }
            }
            catch { // Protect against exception filters
                throw;
            }

            return configrecord;
        }

        internal HttpConfigurationRecord GetCompleteConfig() {
            if (_configrecord == null)
                _configrecord = GetCompleteConfigRecord(ConfigPath, _wr);
            return _configrecord;
        }

        internal HttpConfigurationRecord GetCompleteConfig(String path) {
            // if we're asking for the main request's path, the other API is faster

            if (path != null && String.Compare(path, ConfigPath, true, CultureInfo.InvariantCulture) == 0)
                return GetCompleteConfig();

            return GetCompleteConfigRecord(path, _wr);
        }

        /*
        internal HttpConfigurationRecord GetInitDefaultConfig() {
            return GetCompleteConfigRecord(_request.ApplicationPath, _wr);
        }
        */

        /*
         * Uses the Config system to get the specified configuraiton
         */
        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.GetConfig"]/*' />
        /// <devdoc>
        /// </devdoc>
        public Object GetConfig(String name) {
            Object config = null;

            HttpContext.ImpersonationSuspendContext ictx = Impersonation.SuspendIfClient();

            try {
                try {
                    config = GetCompleteConfig()[name];
                }
                finally {
                    ictx.Resume();
                }
            }
            catch { // Protect against exception filters
                throw;
            }

            return config;
        }

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.GetAppConfig"]/*' />
        public static Object GetAppConfig(String name) {
            HttpContext context = HttpContext.Current;
            HttpContext.ImpersonationSuspendContext ictx = null;

            if (context != null) {
                ictx = context.Impersonation.SuspendIfClient();
            }

            try {
                try {
                    HttpConfigurationRecord configRecord = HttpConfigurationSystem.GetCompleteForApp();
                    if (configRecord != null) {
                        return configRecord[name];
                    }
                }
                finally {
                    if (ictx != null) {
                        ictx.Resume();
                    }
                }
            }
            catch {
                throw;
            }

            return null;
        }

        internal Object GetConfig(String name, String path) {
            return GetCompleteConfig(path)[name];
        }

        internal Object GetSiteConfig(String name) {
            return GetConfig(name, String.Empty);
        }

        internal Object GetMachineConfig(String name) {
            return GetConfig(name, null);
        }

        // try current, app, root, machine  -- never throws (returns null)
        internal Object GetLKGConfig(String name) {
            try { return GetConfig(name);         } catch {}
            return GetAppLKGConfig(name);
        }

        // try app, root, machine -- never throws (returns null)
        internal Object GetAppLKGConfig(String name) {
            try { return GetAppConfig(name);      } catch {}
            try { return GetSiteConfig(name);     } catch {}
            try { return GetMachineConfig(name);  } catch {}
            return null;
        }
        /*
         * Helper to get a config value when config is a dictionary
         * doesn't catch config exceptions -- this tag can't have errors anyway
         * and it is used by infrastructure pieces
         */
        internal Object GetConfigDictionaryValue(String name, Object key) {
            IDictionary d = null;

            try {
                d = (IDictionary)GetConfig(name);
            }
            catch (Exception) {
            }

            return(d != null) ? d[key] : null;
        }

        internal Object GetConfigDictionaryValue(String name, Object key, String path) {
            IDictionary d = (IDictionary)GetConfig(name, path);
            return(d != null) ? d[key] : null;
        }

        /*
         * Returns an array of filenames who are dependancies of the given path.
         */
        internal string[] GetConfigurationDependencies(String reqpath) {
            return HttpConfigurationSystem.GetConfigurationDependencies(reqpath, _wr);
        }

        /*internal String MachineConfigPath {
            get {
                if (_wr == null)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_get_config_dir));

                return _wr.MachineConfigPath;
            }
        }*/

        /*
         * Called by the URL rewrite module to modify the path for downstream modules
         */
        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.RewritePath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void RewritePath(String path) {
            // extract query string
            String qs = null;
            int iqs = path.IndexOf('?');
            if (iqs >= 0) {
                qs = (iqs < path.Length-1) ? path.Substring(iqs+1) : String.Empty;
                path = path.Substring(0, iqs);
            }

            // resolve relative path
            path = UrlPath.Combine(Request.BaseDir, path);

            // disallow paths outside of app
            if (!HttpRuntime.IsPathWithinAppRoot(path))
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cross_app_not_allowed, path));

            // clear things that depend on path
            ConfigPath = null;

            // rewrite path on request
            Request.InternalRewritePath(path, qs);
        }

        /// <include file='doc\HttpContext.uex' path='docs/doc[@for="HttpContext.RewritePath1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void RewritePath(String filePath, String pathInfo, String queryString) {
            // resolve relative path
            filePath = UrlPath.Combine(Request.BaseDir, filePath);

            // disallow paths outside of app
            if (!HttpRuntime.IsPathWithinAppRoot(filePath))
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cross_app_not_allowed, filePath));

            // patch pathInfo
            if (pathInfo == null)
                pathInfo = String.Empty;

            // clear things that depend on path
            ConfigPath = null;

            // rewrite path on request
            Request.InternalRewritePath(filePath, pathInfo, queryString);
        }

        internal CultureInfo DynamicCulture {
            get { return _dynamicCulture; }
            set { _dynamicCulture = value; }
        }

        internal CultureInfo DynamicUICulture {
            get { return _dynamicUICulture; }
            set { _dynamicUICulture = value; }
        }

        internal int ServerExecuteDepth {
            get { return _serverExecuteDepth; }
            set { _serverExecuteDepth = value; }
        }

        /*
         * Access to impersonation data
         */
        internal ImpersonationData Impersonation {
            get { 
                if (_impersonation == null)
                    _impersonation = new ImpersonationData(this);
                return _impersonation; 
            }
        }

        internal static ImpersonationData GetAppLevelImpersonation() {
            return new ImpersonationData(null);
        }

        /*
         * The purpose of this event is to allows some code to finish executing
         * while the ecb is still valid.
         */
        internal event EventHandler BeforeDoneWithSession;
        internal void OnBeforeDoneWithSession(EventArgs e) {
            if (BeforeDoneWithSession != null)
                BeforeDoneWithSession(this, e);
        }

        internal bool HasBeforeDoneWithSessionHandlers {
            get { return (BeforeDoneWithSession != null); }
        }

        internal void ClearBeforeDoneWithSessionHandlers() {
            BeforeDoneWithSession = null;
        }

        //
        // Timeout support
        //

        internal TimeSpan Timeout {
            get {
                EnsureTimeout();
                return _timeout;
            }

            set {
                _timeout = value;
                _timeoutSet = true;
            }
        }

        internal void EnsureTimeout() {
            // Ensure that calls to Timeout property will not go to config after this call
            if (!_timeoutSet) {
                 HttpRuntimeConfig cfg = (HttpRuntimeConfig)GetConfig("system.web/httpRuntime");
                 int s = (cfg != null) ? cfg.ExecutionTimeout : HttpRuntimeConfig.DefaultExecutionTimeout;
                _timeout = new TimeSpan(0, 0, s);
                _timeoutSet = true;
            }
        }

        internal DoubleLink TimeoutLink {
            get { return _timeoutLink;}
            set { _timeoutLink = value;}
        }

        /*
        
        Notes on the following 3 functions:
        
        Execution can be cancelled only during certain periods, when inside the catch
        block for ThreadAbortException.  These periods are marked with the value of
        _timeoutState of 1.
        
        There is potential [rare] race condition when the timeout thread would call
        thread.abort but the execution logic in the meantime escapes the catch block.
        To avoid such race conditions _timeoutState of -1 (cancelled) is introduced.
        The timeout thread sets _timeoutState to -1 before thread abort and the
        unwinding logic just waits for the exception in this case. The wait cannot
        be done in EndCancellablePeriod because the function is call from inside of
        a finally block and thus would wait indefinetely. That's why another function
        WaitForExceptionIfCancelled had been added.
        
        */

        internal void BeginCancellablePeriod() {
            _timeoutStartTime = DateTime.UtcNow;
            _timeoutState = 1;
        }

        internal void EndCancellablePeriod() {
            Interlocked.CompareExchange(ref _timeoutState, 0, 1);
        }

        internal void WaitForExceptionIfCancelled() {
            while (_timeoutState == -1)
                Thread.Sleep(100);
        }

        internal bool IsInCancellablePeriod {
            get { return (_timeoutState == 1); }
        }

        internal bool MustTimeout(DateTime utcNow) {
            if (_timeoutState == 1) {  // fast check
                if (TimeSpan.Compare(utcNow.Subtract(_timeoutStartTime), Timeout) >= 0) {
                    // don't abort in debug mode
                    try {
                        if (CompilationConfiguration.IsDebuggingEnabled(this))
                            return false;
                    }
                    catch {
                        // ignore config errors
                        return false;
                    }

                    // abort the thread only if in cancelable state, avoiding race conditions
                    // the caller MUST timeout if the return is true
                    if (Interlocked.CompareExchange(ref _timeoutState, -1, 1) == 1)
                        return true;
                }
            }

            return false;
        }

        internal void PushTraceContext() {
            if (_traceContextStack == null) {
                _traceContextStack = new Stack();
            }

            // push current TraceContext on stack
            _traceContextStack.Push(_topTraceContext);

            // now make a new one for the top if necessary
            if (_topTraceContext != null) {
                TraceContext tc = new TraceContext(this);
                _topTraceContext.CopySettingsTo(tc);
                _topTraceContext = tc;
            }
        }

        internal void PopTraceContext() {
            Debug.Assert(_traceContextStack != null);
            _topTraceContext = (TraceContext) _traceContextStack.Pop();
        }

        internal bool RequestRequiresAuthorization()  {
            // if current user is anonymous, then trivially, this page does not require authorization
            if (!User.Identity.IsAuthenticated)
                return false;

            // Ask each of the authorization modules
            return
                ( FileAuthorizationModule.RequestRequiresAuthorization(this) ||  
                  UrlAuthorizationModule.RequestRequiresAuthorization(this)   );
        }

        internal int CallISAPI(UnsafeNativeMethods.CallISAPIFunc iFunction, byte [] bufIn, byte [] bufOut) {

            if (_wr == null || !(_wr is System.Web.Hosting.ISAPIWorkerRequest)) 
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_call_ISAPI_functions));

            return ((System.Web.Hosting.ISAPIWorkerRequest) _wr).CallISAPI(iFunction, bufIn, bufOut);            
        }

        internal void SendEmptyResponse() {
            if (_wr != null  && (_wr is System.Web.Hosting.ISAPIWorkerRequest)) 
                ((System.Web.Hosting.ISAPIWorkerRequest) _wr).SendEmptyResponse();            
        }
        //
        // Impersonation related
        //

        internal class ImpersonationSuspendContext {
            internal static ImpersonationSuspendContext Empty = new ImpersonationSuspendContext();

            private static IntPtr GetCurrentToken() {
                IntPtr token = IntPtr.Zero;

                if (UnsafeNativeMethods.OpenThreadToken(
                            UnsafeNativeMethods.GetCurrentThread(),
                            UnsafeNativeMethods.TOKEN_READ | UnsafeNativeMethods.TOKEN_IMPERSONATE,
                            true,
                            ref token) == 0) {
                    
                    // if the last error is ERROR_NO_TOKEN it is ok, otherwise throw
                    if (Marshal.GetLastWin32Error() != UnsafeNativeMethods.ERROR_NO_TOKEN) {
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_impersonate));
                    }
                }

                return token;
            }

            internal static bool IsImpersonating() {
                IntPtr token = GetCurrentToken();

                if (token == IntPtr.Zero)
                    return false;

                UnsafeNativeMethods.CloseHandle(token);
                return true;
            }

            private bool _revertSucceeded;
            private IntPtr _token;

            internal ImpersonationSuspendContext() {
            }

            internal void Suspend() {
                _token = GetCurrentToken();

                if (_token != IntPtr.Zero) {
                    if (UnsafeNativeMethods.RevertToSelf() != 0) {
                        _revertSucceeded = true;
                    }
                }
            }

            internal void Resume() {
                if (_token != IntPtr.Zero) {
                    bool impersonationFailed = false;

                    if (_revertSucceeded) {
                        if (UnsafeNativeMethods.SetThreadToken(IntPtr.Zero, _token) == 0)
                            impersonationFailed = true;
                    }

                    UnsafeNativeMethods.CloseHandle(_token);

                    if (impersonationFailed)
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_impersonate));
                }
            }
        }

        internal class ImpersonationData {

            private enum ImpersonationMode {
                None = 0,       // don't impersonate
                Client = 1,     // impersonate client for request processing minus compilation and config
                UNC = 2,        // impersonate client whenever context is available
                Application = 4 // impersonate application identity (from config) whenever client is available
            }

            private HttpContext _context;

            private bool _configKnown;
            private ImpersonationMode _mode = ImpersonationMode.None;
            private bool _inProgress;
            private bool _reimpersonating;
            private IntPtr _token;

            private static IdentityConfig s_appIdentityConfig;  // cache once per app domain

            internal ImpersonationData(HttpContext context) {
                _context = context;
            }

            private void Init(bool appLevel, bool throwOnError) {
                if (_configKnown)
                    return;

                lock(this) {

                    if (_configKnown)
                        return;

                    if (HttpRuntime.ConfigInited) {
                        IdentityConfig settings = null;

                        IntPtr tokenToReadConfig = IntPtr.Zero;

                        if (_context != null && HttpRuntime.IsOnUNCShareInternal && !_inProgress) {
                            // when reading config on UNC share we have to impersonate around it
                            // note: we are getting config here to figure out the impersonation mode
                            tokenToReadConfig = _context._wr.GetUserToken();
                            UnsafeNativeMethods.SetThreadToken(IntPtr.Zero, tokenToReadConfig);
                        }

                        try {
                            try {
                              using (new HttpContextWrapper(_context)) {  // getting config might require current context
                                if (appLevel || _context == null) {
                                    if (s_appIdentityConfig != null) {
                                        settings = s_appIdentityConfig;
                                    }
                                    else {
                                        settings = (IdentityConfig)HttpContext.GetAppConfig("system.web/identity");
                                        s_appIdentityConfig = settings;
                                    }
                                }
                                else {
                                    settings = (IdentityConfig)_context.GetConfig("system.web/identity");
                                }
                              } 
                            }
                            catch {
                                if (throwOnError)
                                    throw;
                            }
                            finally {
                                if (tokenToReadConfig != IntPtr.Zero) {
                                    UnsafeNativeMethods.RevertToSelf();
                                }
                            }
                        }
                        catch { // Protect against exception filters
                            throw;
                        }


                        if (settings != null) {
                            if (settings.EnableImpersonation) {
                                if (settings.ImpersonateToken != IntPtr.Zero) {
                                    _mode = ImpersonationMode.Application;
                                    _token = settings.ImpersonateToken;
                                }
                                else if (_context != null) {
                                    _mode = ImpersonationMode.Client;
                                    _token = _context._wr.GetUserToken();
                                }
                            }
                            else {
                                _mode = ImpersonationMode.None;
                                _token = IntPtr.Zero;
                            }
                        }

                        // don't remember app level setting with context
                        if (!appLevel)
                            _configKnown = true;
                    }

                    // UNC impersonation overrides everything but Application credentials
                    // it is in effect event before config system gets initialized
                    if (_context != null && HttpRuntime.IsOnUNCShareInternal && _mode != ImpersonationMode.Application) {
                        _mode = ImpersonationMode.UNC;
                        if (_token == IntPtr.Zero)
                            _token = _context._wr.GetUserToken();
                    }
                }
            }

            private IntPtr GetImpersonationToken(bool forGlobalCode, bool throwOnError) {
                // Figure out config, UNC, etc. (once per context lifetime)
                if (!_configKnown) {
                    Init(forGlobalCode, throwOnError);
                }

                // Decide if the impersonation is needed under the current circumstances
                if (_mode == ImpersonationMode.None)
                    return IntPtr.Zero;
                if (_mode == ImpersonationMode.Client && forGlobalCode)
                    return IntPtr.Zero; // client impersonation not needed for global code

                return _token;
            }

            internal bool IsClient {
                get {
                    return (_mode == ImpersonationMode.Client); 
                }
            }

            internal bool IsUNC {
                get {
                    return (_mode == ImpersonationMode.UNC);
                }
            }

            internal bool IsNoneOrApplication {
                get {
                    return (_mode == ImpersonationMode.None || _mode == ImpersonationMode.Application);
                }
            }

            internal bool Start(bool forGlobalCode, bool throwOnError) {
                return Start(forGlobalCode, throwOnError, false);
            }

            internal bool Start(bool forGlobalCode, bool throwOnError, bool fromAnotherThread) {
                if (!fromAnotherThread)
                    Debug.Assert(!_inProgress);

                IntPtr token = GetImpersonationToken(forGlobalCode, throwOnError);
                if (token == IntPtr.Zero)
                    return false;

                // Do the impersonation
                int rc = UnsafeNativeMethods.SetThreadToken(IntPtr.Zero, token);
                if (rc == 0)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_impersonate));
                if (!fromAnotherThread)
                    _inProgress = true;
                return true;
            }

            internal void Stop() {
                if (_inProgress) {
                    UnsafeNativeMethods.RevertToSelf();
                    _inProgress = false;
                }
            }
            
            internal void Stop(bool fromAnotherThread) {
                if (fromAnotherThread)
                    UnsafeNativeMethods.RevertToSelf();
                else
                    Stop();
            }

            internal ImpersonationSuspendContext SuspendIfClient() {
                if (_mode == ImpersonationMode.Client) {
                    ImpersonationSuspendContext ictx = new  ImpersonationSuspendContext();
                    ictx.Suspend();
                    return ictx;
                }
                else {
                    return ImpersonationSuspendContext.Empty;
                }

            }

            internal void ReimpersonateIfSuspended() {
                if (_mode == ImpersonationMode.Client) {
                    if (!ImpersonationSuspendContext.IsImpersonating()) {
                        int rc = UnsafeNativeMethods.SetThreadToken((IntPtr)0, _token);
                        if (rc == 0)
                            throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_impersonate));
                        _reimpersonating = true;
                    }
                }
            }

            internal void StopReimpersonation() {
                if (_reimpersonating) {
                    UnsafeNativeMethods.RevertToSelf();
                    _reimpersonating = false;
                }
            }
        }
    }

    //
    // Helper class to add/remove HttpContext to/from CallContext
    //
    // using (new HttpContextWrapper(context)) {
    //     // this code will have HttpContext.Current working
    // }
    //

    internal class HttpContextWrapper : IDisposable {
        private bool _needToUndo;
        private HttpContext _savedContext;

        internal static HttpContext SwitchContext(HttpContext context) {
            HttpContext oldContext = CallContext.GetData(HttpContext.CallContextSlotName) as HttpContext;
            if (oldContext != context)
                CallContext.SetData(HttpContext.CallContextSlotName, context);
            return oldContext;
        }

        internal HttpContextWrapper(HttpContext context) {
            if (context != null) {
                _savedContext = SwitchContext(context);
                _needToUndo = true;
            }
        }

        void IDisposable.Dispose() {
            if (_needToUndo) {
                SwitchContext(_savedContext);
                _savedContext = null;
                _needToUndo = false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpdictionary.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpDictionary.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Ordered dictionary keyed by string
 * -- Utility class used in Collections
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web {

    using System.Collections;
    using System.Collections.Specialized;

    internal class HttpDictionary : NameObjectCollectionBase {
        internal HttpDictionary() {
        }

        internal void Add(String key, Object value) {
            BaseAdd(key, value);
        }

        internal void Remove(String key) {
            BaseRemove(key);
        }

        internal void RemoveAt(int index) {
            BaseRemoveAt(index);
        }

        internal void Clear() {
            BaseClear();
        }

        internal int Size {
            get { return Count;}
        }

        internal Object GetValue(String key) {
            return BaseGet(key);
        }

        internal void SetValue(String key, Object value) {
            BaseSet(key, value);
        }

        internal Object GetValue(int index) {
            return BaseGet(index);
        }

        internal void SetValue(int index, Object value) {
            BaseSet(index, value);
        }

        internal String GetKey(int index) {
            return BaseGetKey(index);
        }

        internal bool HasKeys() {
            return BaseHasKeys();
        }

        internal String[] GetAllKeys() {
            return BaseGetAllKeys();
        }

        internal Object[] GetAllValues() {
            return BaseGetAllValues();
        }
    }

    /*
     * Enumerator for HttpDictionary as IDictionaryEnumerator
     */
    internal class HttpDictionaryEnumerator : IDictionaryEnumerator {
        private int _pos;
        private HttpDictionary _dict;

        internal HttpDictionaryEnumerator(HttpDictionary dict) {
            _dict = dict;
            _pos = -1;
        }

        // Enumerator

        public bool MoveNext() {
            return(++_pos < _dict.Count);
        }

        public void Reset() {
            _pos = -1;
        }

        public virtual Object Current {
            get {
                return Entry;
            }
        }

        public virtual DictionaryEntry Entry {
            get {
                if (_pos >= 0 && _pos < _dict.Size)
                    return new DictionaryEntry(_dict.GetKey(_pos), _dict.GetValue(_pos));
                else
                    return new DictionaryEntry(null, null);
            }
        }

        public virtual Object Key {
            get {
                if (_pos >= 0 && _pos < _dict.Size)
                    return _dict.GetKey(_pos);
                else
                    return null;
            }
        }

        public virtual Object Value {
            get {
                if (_pos >= 0 && _pos < _dict.Size)
                    return _dict.GetValue(_pos);
                else
                    return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpdebughandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpDebugHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Handler for DEBUG verb
 * 
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web {

    using System.Web.Util;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Globalization;
    
/*
This is just a temporary code to get some timings for the Http Debug request.  To enable it, add the following
to the app's "web.config" file:

<configuration>

        <configSections>
            <section name="httpDebug" type="System.Configuration.DictionarySectionHandler,System" />
        </configSections>

        <httpDebug>
           <add key="enable" value="1" />
           <add key="path" value="c:\dir\file.log" />
        </httpDebug>

</configuration>

*/
    using System.Collections;

    internal class HttpDebugHandlerTimeLog {
        private static int initialTick = 0;
        private static int isEnabled = -1;
        private static StreamWriter writer = null;
        private static FileStream fstream = null;

        internal HttpDebugHandlerTimeLog() {
        }

        private static bool IsEnabled {
            get {
                if (isEnabled == -1) {
                    // Else check to see if config settings enables it
                    Hashtable h = (Hashtable) HttpContext.GetAppConfig("httpDebug");
                    if (h != null) {
                        string s = (string) h["enable"];
                        if ((s != null) && (s == "1")) {
                            // Open file handle if needed
                            try {
                                string filename = (string) h["path"];
                                if (filename != null) {
                                    fstream = new FileStream(filename, FileMode.Create, FileAccess.ReadWrite, FileShare.Read);
                                    writer = new StreamWriter(fstream);
                                    isEnabled = 1;
                                }
                            }
                            catch (Exception) {
                                isEnabled = 0;
                                Close();
                            }
                        }
                    }
                    
                    // If still undecided here, then it's off
                    if (isEnabled == -1) {
                        isEnabled = 0;
                    }
                }

                return (isEnabled == 1) ? true : false;
            }
        }

        internal static void Close() {
            if (writer != null) {
                writer.Flush();
                writer.Close();
                writer = null;
            }
            if (fstream != null) {
                fstream.Close();
                fstream = null;
            }
        }
        
        internal static void PrintTickDelta(string s) {
            if (! IsEnabled) {
                return;
            }
            if (initialTick == 0) {
                initialTick = Environment.TickCount;
                SafeNativeMethods.OutputDebugString(s + " : " + initialTick + " (HttpDebugHandler + 0)\n");
                if (writer != null) {
                    writer.WriteLine(s + " : " + initialTick + " (HttpDebugHandler + 0)");
                }
            }
            else {
                int curTick = Environment.TickCount;
                SafeNativeMethods.OutputDebugString(s + " : " + curTick + " (HttpDebugHandler + " + (curTick - initialTick) + ")\n");
                if (writer != null) {
                    writer.WriteLine(s + " : " + curTick + " (HttpDebugHandler + " + (curTick - initialTick) + ")");
                }
            }
        }
    }

    /// <include file='doc\HttpDebugHandler.uex' path='docs/doc[@for="HttpDebugHandler"]/*' />
    /// <devdoc>
    ///    <para>Handler for debugging operations.</para>
    /// </devdoc>
    internal class HttpDebugHandler : IHttpHandler {

        private static string[] validClsIds = {"{70f65411-fe8c-4248-bcff-701c8b2f4529}",
                                               "{62a78ac2-7d9a-4377-b97e-6965919fdd02}",
                                               "{cc23651f-4574-438f-b4aa-bcb28b6b3ecf}",
                                               "{dbfdb1d0-04a4-4315-b15c-f874f6b6e90b}",
                                               "{a4fcb474-2687-4924-b0ad-7caf331db826}",
                                               "{beb261f6-d5f0-43ba-baf4-8b79785fffaf}",
                                               "{8e2f5e28-d4e2-44c0-aa02-f8c5beb70cac}",
                                               "{08100915-0f41-4ccf-9564-ebaa5d49446c}"};

        internal HttpDebugHandler () {
        }
        
        internal /*public*/ static bool IsDebuggingRequest(HttpContext context) {
            return (context.Request.HttpMethod == "DEBUG");
        }

        /// <include file='doc\HttpDebugHandler.uex' path='docs/doc[@for="HttpDebugHandler.ProcessRequest"]/*' />
        /// <devdoc>
        ///    <para>Drives web processing execution.</para>
        /// </devdoc>
        public void ProcessRequest(HttpContext context) {
            // Debugging must be enabled

            try {
                HttpDebugHandlerTimeLog.PrintTickDelta("Entered HttpDebugHandler");
                
                if (!HttpRuntime.DebuggingEnabled) {
                    context.Response.Write(HttpRuntime.FormatResourceString(SR.Debugging_forbidden, context.Request.Path));
                    context.Response.StatusCode = 403;
                    return;
                }

                // Check to see if it's a valid debug command.
                string command = context.Request.Headers["Command"];

                if (command == null) {
                    Debug.Trace("AutoAttach", "No debug command!!");
                    context.Response.Write(HttpRuntime.FormatResourceString(SR.Invalid_Debug_Request));
                    context.Response.StatusCode = 500;
                    return;
                }

                Debug.Trace("AutoAttach", "Debug command: " + command);

                if (string.Compare(command, "stop-debug", true, CultureInfo.InvariantCulture) == 0) {
                    context.Response.Write("OK");
                    return;
                }

                if (string.Compare(command, "start-debug", true, CultureInfo.InvariantCulture) != 0) {
                    context.Response.Write(HttpRuntime.FormatResourceString(SR.Invalid_Debug_Request));
                    context.Response.StatusCode = 500;
                    return;
                }

                // Request must be NTLM authenticated
                string authType = context.WorkerRequest.GetServerVariable("AUTH_TYPE"); // go the metal
                string logonUser  = context.WorkerRequest.GetServerVariable("LOGON_USER");

                Debug.Trace("AutoAttach", "Authentication type string: " + ((authType != null) ? authType : "NULL"));
                Debug.Trace("AutoAttach", "Logon user string: " + ((logonUser != null) ? logonUser : "NULL"));

                if (logonUser == null || logonUser.Length == 0 || authType == null || authType.Length == 0 || String.Compare(authType, "basic", true, CultureInfo.InvariantCulture) == 0) 
                {
                    Debug.Trace("AutoAttach", "Invalid logon_user or auth_type string.");
                    context.Response.Write(HttpRuntime.FormatResourceString(SR.Debug_Access_Denied, context.Request.Path));
                    context.Response.StatusCode = 401;
                    return;
                }

                // Get the session ID
                String sessId = context.Request.Form["DebugSessionID"];

                Debug.Trace("AutoAttach", "DebugSessionID: " + ((sessId != null) ? sessId : "NULL"));

                if (sessId == null || sessId.Length == 0) {
                    context.Response.Write(HttpRuntime.FormatResourceString(SR.Invalid_Debug_ID));
                    context.Response.StatusCode = 500;
                    return;
                }

                string s = sessId.Replace(';', '&');

                HttpValueCollection valCol = new HttpValueCollection(s, true, true, Encoding.UTF8);
                string clsId = (string) valCol["autoattachclsid"];

                // Verify clsId
                bool isClsIdOk = false;
                if (clsId != null) {
                    for (int i = 0; i < validClsIds.Length; i++) {
                        if (clsId.ToLower(System.Globalization.CultureInfo.InvariantCulture) == validClsIds[i]) {
                            isClsIdOk = true;
                            break;
                        }
                    }
                }
                if (isClsIdOk == false) {
                    context.Response.Write(HttpRuntime.FormatResourceString(SR.Debug_Access_Denied, context.Request.Path));
                    context.Response.StatusCode = 401;
                    Debug.Trace("AutoAttach", "Debug attach not attempted because of invalid CLSID.");
                    return;
                }

                // Attach the debugger
                HttpDebugHandlerTimeLog.PrintTickDelta("About to call into MDM");

                int rc = UnsafeNativeMethods.AttachDebugger(clsId, sessId, context.WorkerRequest.GetUserToken());

                HttpDebugHandlerTimeLog.PrintTickDelta("Returned from call to MDM");

                // If it's not S_OK, then we got a problem
                if (rc != 0) {
                    Debug.Trace("AutoAttach", "Debug attach failed! Return code: " + rc);
                    context.Response.Write(HttpRuntime.FormatResourceString(SR.Error_Attaching_with_MDM, "0x" + rc.ToString("X8")));
                    context.Response.StatusCode = 500;
                    return;
                }

                Debug.Trace("AutoAttach", "Debug attach successful!");

                // Everything ok -- increment counter, return something (not 204)
                PerfCounters.IncrementCounter(AppPerfCounter.DEBUGGING_REQUESTS);
                context.Response.Write("OK");

                // Set global flag for us
                HttpRuntime.VSDebugAttach = true;
            }
            finally {
                Debug.Trace("AutoAttach","Http Debug attach done!");

                HttpDebugHandlerTimeLog.PrintTickDelta("Leaving HttpDebugHandler");
                HttpDebugHandlerTimeLog.Close();
            }
        }

        /// <include file='doc\HttpDebugHandler.uex' path='docs/doc[@for="HttpDebugHandler.IsReusable"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether an HttpDebugHandler instance can be recycled and used for 
        ///       another request.</para>
        /// </devdoc>
        public bool IsReusable {
            get { return true; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\errorformatter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ErrorFormatter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Object used to put together ASP.NET HTML error messages
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web {
    using System.Runtime.Serialization.Formatters;
    using System.Text;
    using System.Diagnostics;
    using System.Reflection;
    using System.Configuration.Assemblies;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.IO;
    using System.Web.Util;
    using System.Web.Compilation;
    using System.Collections;
    using System.Text.RegularExpressions;            
    using System.CodeDom.Compiler;
    using System.ComponentModel;

    /*
     * This is an abstract base class from which we derive other formatters.
     */
    internal abstract class ErrorFormatter {
        internal /*public*/ string GetHtmlErrorMessage() {
            return GetHtmlErrorMessage(true);
        }

        internal /*public*/ string GetHtmlErrorMessage(bool dontShowSensitiveInfo) {

            // Give the formatter a chance to prepare its state
            PrepareFormatter();

            StringBuilder sb = new StringBuilder();

            // REVIEW: all the derived method should work directly with the string
            // builder instead of returning a string.

            sb.Append("<html>\r\n");
            sb.Append("    <head>\r\n");
            sb.Append("        <title>" + ErrorTitle + "</title>\r\n");
            sb.Append("        <style>\r\n");
            sb.Append("        	body {font-family:\"Verdana\";font-weight:normal;font-size: .7em;color:black;} \r\n");
            sb.Append("        	p {font-family:\"Verdana\";font-weight:normal;color:black;margin-top: -5px}\r\n");
            sb.Append("        	b {font-family:\"Verdana\";font-weight:bold;color:black;margin-top: -5px}\r\n");
            sb.Append("        	H1 { font-family:\"Verdana\";font-weight:normal;font-size:18pt;color:red }\r\n");
            sb.Append("        	H2 { font-family:\"Verdana\";font-weight:normal;font-size:14pt;color:maroon }\r\n");
            sb.Append("        	pre {font-family:\"Lucida Console\";font-size: .9em}\r\n");
            sb.Append("        	.marker {font-weight: bold; color: black;text-decoration: none;}\r\n");
            sb.Append("        	.version {color: gray;}\r\n");
            sb.Append("        	.error {margin-bottom: 10px;}\r\n");
            sb.Append("        	.expandable { text-decoration:underline; font-weight:bold; color:navy; cursor:hand; }\r\n");
            sb.Append("        </style>\r\n");
            sb.Append("    </head>\r\n\r\n");
            sb.Append("    <body bgcolor=\"white\">\r\n\r\n");
            sb.Append("            <span><H1>" + HttpRuntime.FormatResourceString(SR.Error_Formatter_ASPNET_Error, HttpRuntime.AppDomainAppVirtualPath) + "<hr width=100% size=1 color=silver></H1>\r\n\r\n");
            sb.Append("            <h2> <i>" + ErrorTitle + "</i> </h2></span>\r\n\r\n");
            sb.Append("            <font face=\"Arial, Helvetica, Geneva, SunSans-Regular, sans-serif \">\r\n\r\n");
            sb.Append("            <b> " + HttpRuntime.FormatResourceString(SR.Error_Formatter_Description) +  " </b>" + Description + "\r\n");
            sb.Append("            <br><br>\r\n\r\n");
            if (MiscSectionTitle != null) {
                sb.Append("            <b> " + MiscSectionTitle + ": </b>" + MiscSectionContent + "<br><br>\r\n\r\n");
            }

            WriteColoredSquare(sb, ColoredSquareTitle, ColoredSquareDescription, ColoredSquareContent, WrapColoredSquareContentLines);

            if (ShowSourceFileInfo) {
                string fileName = HttpRuntime.GetSafePath(SourceFileName);
                if (fileName == null)
                    fileName = HttpRuntime.FormatResourceString(SR.Error_Formatter_No_Source_File);
                sb.Append("            <b> " + HttpRuntime.FormatResourceString(SR.Error_Formatter_Source_File) + " </b> " + fileName + "<b> &nbsp;&nbsp; " + HttpRuntime.FormatResourceString(SR.Error_Formatter_Line) + " </b> " + SourceFileLineNumber + "\r\n");
                sb.Append("            <br><br>\r\n\r\n");
            }

            // If it's a FileNotFoundException/FileLoadException/BadImageFormatException with a FusionLog,
            // write it out (ASURT 83587)
            if (!dontShowSensitiveInfo && Exception != null) {
                // (Only display the fusion log in medium or higher (ASURT 126827)
                if (HttpRuntime.HasAspNetHostingPermission(AspNetHostingPermissionLevel.Medium)) {
                    for (Exception e = Exception; e != null; e = e.InnerException) {
                        string fusionLog = null;
                        string filename = null;
                        FileNotFoundException fnfException = e as FileNotFoundException;
                        if (fnfException != null) {
                            fusionLog = fnfException.FusionLog;
                            filename = fnfException.FileName;
                        }
                        FileLoadException flException = e as FileLoadException;
                        if (flException != null) {
                            fusionLog = flException.FusionLog;
                            filename = flException.FileName;
                        }
                        BadImageFormatException bifException = e as BadImageFormatException;
                        if (bifException != null) {
                            fusionLog = bifException.FusionLog;
                            filename = bifException.FileName;
                        }
                        if (fusionLog != null && fusionLog.Length > 0) {
                            WriteColoredSquare(sb,
                                HttpRuntime.FormatResourceString(SR.Error_Formatter_FusionLog),
                                HttpRuntime.FormatResourceString(SR.Error_Formatter_FusionLogDesc, filename),
                                HttpUtility.HtmlEncode(fusionLog),
                                false /*WrapColoredSquareContentLines*/);
                            break;
                        }
                    }
                }
            }

            WriteColoredSquare(sb, ColoredSquare2Title, ColoredSquare2Description, ColoredSquare2Content, false);

            if (!dontShowSensitiveInfo) {  // don't show version for security reasons
                sb.Append("            <hr width=100% size=1 color=silver>\r\n\r\n");
                sb.Append("            <b>" + HttpRuntime.FormatResourceString(SR.Error_Formatter_Version) + "</b>&nbsp;" +
                                       HttpRuntime.FormatResourceString(SR.Error_Formatter_CLR_Build) + VersionInfo.ClrVersion + 
                                       HttpRuntime.FormatResourceString(SR.Error_Formatter_ASPNET_Build) + VersionInfo.IsapiVersion + "\r\n\r\n");
                sb.Append("            </font>\r\n\r\n");
            }
            sb.Append("    </body>\r\n");
            sb.Append("</html>\r\n");

            sb.Append(PostMessage);

            return sb.ToString();
        }

        private void WriteColoredSquare(StringBuilder sb, string title, string description,
            string content, bool wrapContentLines) {
            if (title != null) {
                sb.Append("            <b>" + title + ":</b> " + description + "<br><br>\r\n\r\n");
                sb.Append("            <table width=100% bgcolor=\"#ffffcc\">\r\n");
                sb.Append("               <tr>\r\n");
                sb.Append("                  <td>\r\n");
                sb.Append("                      <code>");
                if (!wrapContentLines)
                    sb.Append("<pre>");
                sb.Append("\r\n\r\n");
                sb.Append(content);
                if (!wrapContentLines)
                    sb.Append("</pre>");
                sb.Append("</code>\r\n\r\n");
                sb.Append("                  </td>\r\n");
                sb.Append("               </tr>\r\n");
                sb.Append("            </table>\r\n\r\n");
                sb.Append("            <br>\r\n\r\n");
            }
        }


        internal /*public*/ virtual void PrepareFormatter() {}

        /*
         * Return the associated exception object (if any)
         */
        protected virtual Exception Exception {
            get { return null; }
        }

        /*
         * Return the type of error.  e.g. "Compilation Error."
         */
        protected abstract string ErrorTitle {
            get;
        }

        /*
         * Return a description of the error
         * e.g. "An error occurred during the compilation of a resource required to service"
         */
        protected abstract string Description {
            get;
        }

        /*
         * A section used differently by different types of errors (title)
         * e.g. "Compiler Error Message"
         * e.g. "Exception Details"
         */
        protected abstract string MiscSectionTitle {
            get;
        }

        /*
         * A section used differently by different types of errors (content)
         * e.g. "BC30198: Expected: )"
         * e.g. "System.NullReferenceException"
         */
        protected abstract string MiscSectionContent {
            get;
        }

        /*
         * e.g. "Source Error"
         */
        protected virtual string ColoredSquareTitle {
            get { return null;}
        }

        /*
         * Optional text between color square title and the color square itself
         */
        protected virtual string ColoredSquareDescription {
            get { return null;}
        }

        /*
         * e.g. a piece of source code with the error context
         */
        protected virtual string ColoredSquareContent {
            get { return null;}
        }

        /*
         * If false, use a <pre></pre> tag around it
         */
        protected virtual bool WrapColoredSquareContentLines {
            get { return false;}
        }

        /*
         * e.g. "Source Error"
         */
        protected virtual string ColoredSquare2Title {
            get { return null;}
        }

        /*
         * Optional text between color square title and the color square itself
         */
        protected virtual string ColoredSquare2Description {
            get { return null;}
        }

        /*
         * e.g. a piece of source code with the error context
         */
        protected virtual string ColoredSquare2Content {
            get { return null;}
        }

        /*
         * Determines whether SourceFileName and SourceFileLineNumber will be used
         */
        protected abstract bool ShowSourceFileInfo {
            get;
        }

        /*
         * e.g. d:\samples\designpreview\test.aspx
         */
        protected virtual string SourceFileName {
            get { return null;}
        }

        /*
         * The line number in the source file
         */
        protected virtual int SourceFileLineNumber {
            get { return 0;}
        }

        protected virtual String PostMessage {
            get { return null; }
        }

        /*
         * Does this error have only information that we want to 
         * show over the web to random users?
         */
        internal virtual bool CanBeShownToAllUsers {
            get { return false;}
        }

        internal static string ResolveHttpFileName(string filename) {

            // When running under VS debugger, we use URL's instead of paths in our #line pragmas.
            // When we detect this situation, we need to do a MapPath to get back to the file name (ASURT 76211/114867)
            if (filename != null) {
                try {
                    Uri uri = new Uri(filename);
                    if (uri.Scheme == Uri.UriSchemeHttp || uri.Scheme == Uri.UriSchemeHttps)
                        filename = HttpContext.Current.Request.MapPath(uri.LocalPath);
                }
                catch {}
            }

            return filename;
        }
    }

    /*
     * This formatter is used for runtime exceptions that don't fall into a
     * specific category.
     */
    internal class UnhandledErrorFormatter : ErrorFormatter {
        protected Exception _e;
        protected Exception _initialException;
        protected ArrayList _exStack = new ArrayList();
        protected string _fileName;
        protected int _line;
        private string _coloredSquare2Content;
        private bool _fGeneratedCodeOnStack;
        protected String _message;
        protected String _postMessage;

        internal UnhandledErrorFormatter(Exception e) : this(e, null, null){
        }

        internal UnhandledErrorFormatter(Exception e, String message, String postMessage) {
            _message = message;
            _postMessage = postMessage;
            _e = e;
        }

        internal /*public*/ override void PrepareFormatter() {

            // Build a stack of exceptions
            for (Exception e = _e; e != null; e = e.InnerException) {
                _exStack.Add(e);

                // Keep track of the initial exception (first one thrown)
                _initialException = e;
            }

            // Get the Square2Content first so the line number gets calculated
            _coloredSquare2Content = ColoredSquare2Content;
        }

        protected override Exception Exception {
            get { return _e; }
        }

        protected override string ErrorTitle {
            get {
                // Use the exception's message if there is one
                string msg = _initialException.Message;
                if (msg != null && msg.Length > 0)
                    return HttpUtility.HtmlEncode(msg);

                // Otherwise, use some default string
                return HttpRuntime.FormatResourceString(SR.Unhandled_Err_Error);
            }
        }

        protected override string Description {
            get {
                if (_message != null) {
                    return _message;
                }
                else {
                    return HttpRuntime.FormatResourceString(SR.Unhandled_Err_Desc);
                }
            }
        }

        protected override string MiscSectionTitle {
            get { return HttpRuntime.FormatResourceString(SR.Unhandled_Err_Exception_Details);}
        }

        protected override string MiscSectionContent {
            get {
                StringBuilder msg = new StringBuilder(_initialException.GetType().FullName);

                if (_initialException.Message != null) {
                    msg.Append(": ");
                    msg.Append(HttpUtility.HtmlEncode(_initialException.Message));
                }

                if (_initialException is UnauthorizedAccessException) {
                    msg.Append("\r\n<br><br>");
                    msg.Append(HttpUtility.HtmlEncode(HttpRuntime.FormatResourceString(SR.Unauthorized_Err_Desc1)));
                    msg.Append("\r\n<br><br>");
                    msg.Append(HttpUtility.HtmlEncode(HttpRuntime.FormatResourceString(SR.Unauthorized_Err_Desc2)));
                }

                return msg.ToString();
            }
        }

        protected override string ColoredSquareTitle {
            get { return HttpRuntime.FormatResourceString(SR.TmplCompilerSourceSecTitle);}
        }

        protected override string ColoredSquareContent {
            get {

                // If we couldn't get line info for the error, display a standard message
                if (_fileName == null) {

                    // The error text depends on whether .aspx code was found on the stack
                    string errorCode;
                    if (!_fGeneratedCodeOnStack)
                        errorCode = SR.Src_not_available_nodebug;
                    else
                        errorCode = SR.Src_not_available;

                    string msg = HttpRuntime.FormatResourceString(errorCode);
                    msg = HttpUtility.FormatPlainTextAsHtml(msg);
                    return msg;
                }

                return FormatterWithFileInfo.GetSourceFileLines(_fileName, Encoding.Default, null, _line);
            }
        }

        protected override bool WrapColoredSquareContentLines {
            // Only wrap the text if we're displaying the standard message
            get { return (_fileName == null);}
        }

        protected override string ColoredSquare2Title {
            get { return HttpRuntime.FormatResourceString(SR.Unhandled_Err_Stack_Trace);}
        }

        protected override string ColoredSquare2Content {
            get {
                if (_coloredSquare2Content != null)
                    return _coloredSquare2Content;

                StringBuilder sb = new StringBuilder();

                for (int i = _exStack.Count - 1; i >=0; i--) {
                    if (i < _exStack.Count - 1)
                        sb.Append("\r\n");

                    Exception e = (Exception)_exStack[i];

                    sb.Append("[" + _exStack[i].GetType().Name);

                    // Display the error code if there is one
                    if ((e is ExternalException) && ((ExternalException) e).ErrorCode != 0)
                        sb.Append(" (0x" + (((ExternalException) e).ErrorCode).ToString("x") + ")");

                    // Display the message if there is one
                    if (e.Message != null && e.Message.Length > 0)
                        sb.Append(": " + e.Message);

                    sb.Append("]\r\n");

                    // Display the stack trace
                    StackTrace st = new StackTrace(e, true /*fNeedFileInfo*/);
                    for (int j = 0; j < st.FrameCount; j++) {
                        StackFrame sf = st.GetFrame(j);

                        MethodBase mb = sf.GetMethod();
                        Type declaringType = mb.DeclaringType;
                        string ns = String.Empty;
                        if (declaringType != null)
                            ns = declaringType.Namespace;
                        if (ns != null) {

                            // Check if this stack item is for ASP generated code (ASURT 51063)
                            if (BaseCompiler.IsAspNetNamespace(ns))
                                _fGeneratedCodeOnStack = true;

                            ns = ns + ".";
                        }

                        if (declaringType == null) {
                            sb.Append("   " + mb.Name + "(");
                        }
                        else {
                            sb.Append("   " + ns + declaringType.Name + "." +
                                mb.Name + "(");
                        }

                        ParameterInfo[] arrParams = mb.GetParameters();

                        for (int k = 0; k < arrParams.Length; k++) {
                            sb.Append((k != 0 ? ", " : "") + arrParams[k].ParameterType.Name + " " +
                                arrParams[k].Name);
                        }

                        sb.Append(")");
     
                        if (sf.GetILOffset() != -1) {
                            string fileName = sf.GetFileName();

                            // ASURT 114867: if it's an http path, turn it into a local path
                            fileName = ResolveHttpFileName(fileName);
                            if (fileName != null) {

                                // Remember the file/line number of the top level stack
                                // item for which we have symbols
                                if (_fileName == null && FileUtil.FileExists(fileName)) {
                                    _fileName = fileName;
                                    _line = sf.GetFileLineNumber();
                                }

                                sb.Append(" in " + HttpRuntime.GetSafePath(fileName) +
                                    ":" + sf.GetFileLineNumber());
                            }
                        }
                        else {
                            sb.Append(" +" + sf.GetNativeOffset());
                        }

                        sb.Append("\r\n");
                    }
                }

                _coloredSquare2Content = HttpUtility.HtmlEncode(sb.ToString());

                return _coloredSquare2Content;
            }
        }

        protected override String PostMessage {
            get { return _postMessage; }
        }

        protected override bool ShowSourceFileInfo {
            get { return _fileName != null; }
        }

        protected override string SourceFileName {
            get { return _fileName; }
        }

        protected override int SourceFileLineNumber {
            get { return _line; }
        }
    }

    /*
     * This formatter is used for security exceptions.
     */
    internal class SecurityErrorFormatter : UnhandledErrorFormatter {

        internal SecurityErrorFormatter(Exception e) : base(e) {}

        protected override string ErrorTitle {
            get {
                return HttpRuntime.FormatResourceString(SR.Security_Err_Error);
            }
        }

        protected override string Description {
            get {
                return HttpRuntime.FormatResourceString(SR.Security_Err_Desc);
            }
        }
    }

    /*
     * This formatter is used for 404: page not found errors
     */
    internal class PageNotFoundErrorFormatter : ErrorFormatter {
        protected string _htmlEncodedUrl;

        internal PageNotFoundErrorFormatter(string url) {
            _htmlEncodedUrl = HttpUtility.HtmlEncode(url);
        }

        protected override string ErrorTitle {
            get { return HttpRuntime.FormatResourceString(SR.NotFound_Resource_Not_Found);}
        }

        protected override string Description {
            get { return HttpRuntime.FormatResourceString(SR.NotFound_Http_404);}
        }

        protected override string MiscSectionTitle {
            get { return HttpRuntime.FormatResourceString(SR.NotFound_Requested_Url);}
        }

        protected override string MiscSectionContent {
            get { return _htmlEncodedUrl;}
        }

        protected override bool ShowSourceFileInfo {
            get { return false;}
        }

        internal override bool CanBeShownToAllUsers {
            get { return true;}
        }
    }

    /*
     * This formatter is used for 403: forbidden
     */
    internal class PageForbiddenErrorFormatter : ErrorFormatter {
        protected string _htmlEncodedUrl;

        internal PageForbiddenErrorFormatter(string url) {
            _htmlEncodedUrl = HttpUtility.HtmlEncode(url);
        }

        protected override string ErrorTitle {
            get { return HttpRuntime.FormatResourceString(SR.Forbidden_Type_Not_Served);}
        }

        protected override string Description {
            get {
                Match m = Regex.Match(_htmlEncodedUrl, @"\.\w+$");

                String extMessage = String.Empty;

                if (m.Success)
                    extMessage = HttpRuntime.FormatResourceString(SR.Forbidden_Extension_Incorrect, m.ToString());

                return HttpRuntime.FormatResourceString(SR.Forbidden_Extension_Desc, extMessage);
            }
        }

        protected override string MiscSectionTitle {
            get { return HttpRuntime.FormatResourceString(SR.NotFound_Requested_Url);}
        }

        protected override string MiscSectionContent {
            get { return _htmlEncodedUrl;}
        }

        protected override bool ShowSourceFileInfo {
            get { return false;}
        }

        internal override bool CanBeShownToAllUsers {
            get { return true;}
        }
    }

    /*
     * This formatter is used for generic errors that hide sensitive information
     * error text is sometimes different for remote vs. local machines
     */
    internal class GenericApplicationErrorFormatter : ErrorFormatter {
        private bool _local;

        internal GenericApplicationErrorFormatter(bool local) {
            _local = local;
        }

        protected override string ErrorTitle {
            get {
                return HttpRuntime.FormatResourceString(SR.Generic_Err_Title);
            }
        }

        protected override string Description {
            get { 
                return HttpRuntime.FormatResourceString(
                                    _local ? SR.Generic_Err_Local_Desc 
                                           : SR.Generic_Err_Remote_Desc);
            }
        }

        protected override string MiscSectionTitle {
            get { 
                return null;
            }
        }

        protected override string MiscSectionContent {
            get { 
                return null;
            }
        }

        protected override string ColoredSquareTitle {
            get {
                return HttpRuntime.FormatResourceString(SR.Generic_Err_Details_Title);
            }
        }

        protected override string ColoredSquareDescription {
            get { 
                return HttpUtility.HtmlEncode(HttpRuntime.FormatResourceString(
                                    _local ? SR.Generic_Err_Local_Details_Desc
                                           : SR.Generic_Err_Remote_Details_Desc));
            }
        }

        protected override string ColoredSquareContent {
            get { 
                return HttpUtility.HtmlEncode(HttpRuntime.FormatResourceString(
                                    _local ? SR.Generic_Err_Local_Details_Sample
                                           : SR.Generic_Err_Remote_Details_Sample));
            }
        }

        protected override string ColoredSquare2Title {
            get {
                return HttpRuntime.FormatResourceString(SR.Generic_Err_Notes_Title);
            }
        }

        protected override string ColoredSquare2Description {
            get { 
                return HttpUtility.HtmlEncode(HttpRuntime.FormatResourceString(SR.Generic_Err_Notes_Desc));
            }
        }

        protected override string ColoredSquare2Content {
            get { 
                return HttpUtility.HtmlEncode(HttpRuntime.FormatResourceString(
                                    _local ? SR.Generic_Err_Local_Notes_Sample
                                           : SR.Generic_Err_Remote_Notes_Sample));
            }
        }

        protected override bool ShowSourceFileInfo {
            get { return false;}
        }

        internal override bool CanBeShownToAllUsers {
            get { return true;}
        }
    }


    /*
     * This is the base class for formatter that handle errors that have an
     * associated file / line number.
     */
    internal abstract class FormatterWithFileInfo : ErrorFormatter {
        protected string _fileName;
        protected string _sourceCode;
        protected int _line;

        // Number of lines before and after the error lines included in the report
        private const int errorRange = 2;

        /*
         * Return the text of the error line in the source file, with a few
         * lines around it.  It is returned in HTML format.
         */
        internal static string GetSourceFileLines(string fileName, Encoding encoding, string sourceCode, int lineNumber) {

            // Don't show any source file if the user doesn't have access to it (ASURT 122430)
            if (fileName != null && !HttpRuntime.HasFilePermission(fileName))
                return HttpRuntime.FormatResourceString(SR.WithFile_No_Relevant_Line);

            // REVIEW: write directly to the main builder
            StringBuilder sb = new StringBuilder();

            if (lineNumber <= 0) {
                return HttpRuntime.FormatResourceString(SR.WithFile_No_Relevant_Line);
            }

            TextReader reader = null;

            fileName = ResolveHttpFileName(fileName);

            try {
                // Open the source file
                reader = new StreamReader(fileName, encoding, true, 4096);
            }
            catch (Exception) {
                // Can't open the file?  Use the dynamically generated content...
                reader = new StringReader(sourceCode);
            }

            try {
                bool fFoundLine = false;

                for (int i=1; ; i++) {
                    // Get the current line from the source file
                    string sourceLine = reader.ReadLine();
                    if (sourceLine == null)
                        break;

                    // If it's the error line, make it red
                    if (i == lineNumber)
                        sb.Append("<font color=red>");

                    // Is it in the range we want to display
                    if (i >= lineNumber-errorRange && i <= lineNumber+errorRange) {
                        fFoundLine = true;
                        String linestr = i.ToString("G");

                        sb.Append(HttpRuntime.FormatResourceString(SR.WithFile_Line_Num, linestr));
                        if (linestr.Length < 3)
                            sb.Append(' ', 3 - linestr.Length);
                        sb.Append(HttpUtility.HtmlEncode(sourceLine));

                        if (i != lineNumber+errorRange)
                            sb.Append("\r\n");
                    }

                    if (i == lineNumber)
                        sb.Append("</font>");

                    if (i>lineNumber+errorRange)
                        break;
                }

                if (!fFoundLine)
                    return HttpRuntime.FormatResourceString(SR.WithFile_No_Relevant_Line);
            }
            finally {
                // Make sure we always close the reader
                reader.Close();
            }

            return sb.ToString();
        }

        private string GetSourceFileLines() {
            return GetSourceFileLines(_fileName, SourceFileEncoding, _sourceCode, _line);
        }

        internal FormatterWithFileInfo(string filename, string sourceCode, int line) {

            // ASURT 76211: if it's an http path, turn it into a local path
            _fileName = ResolveHttpFileName(filename);

            _sourceCode = sourceCode;
            _line = line;
        }

        protected virtual Encoding SourceFileEncoding {
            get { return Encoding.Default; }
        }

        protected override string ColoredSquareContent {
            get { return GetSourceFileLines();}
        }

        protected override bool ShowSourceFileInfo {
            get { return true;}
        }

        protected override string SourceFileName {
            get { return _fileName;}
        }

        protected override int SourceFileLineNumber {
            get { return _line;}
        }
    }

    /*
     * Formatter used for compilation errors
     */
    internal sealed class DynamicCompileErrorFormatter : ErrorFormatter {

        private const string startExpandableBlock =
            "<br><div class=\"expandable\" onclick=\"OnToggleTOCLevel1()\" level2ID=\"{0}\">" +
            "{1}" +
            ":</div>\r\n" +
            "<div id=\"{0}\" style=\"display: none;\">\r\n" +
            "            <br><table width=100% bgcolor=\"#ffffcc\">\r\n" +
            "               <tr>\r\n" +
            "                  <td>\r\n" +
            "                      <code><pre>\r\n\r\n";

        private const string endExpandableBlock =
            "</pre></code>\r\n\r\n" +
            "                  </td>\r\n" +
            "               </tr>\r\n" +
            "            </table>\r\n\r\n" +
            "            \r\n\r\n" +
            "</div>\r\n";

        // Number of lines before and after the error lines included in the report
        private const int errorRange = 2;

        HttpCompileException _excep;

        internal DynamicCompileErrorFormatter(HttpCompileException excep) {
            _excep = excep;
        }

        protected override Exception Exception {
            get { return _excep; }
        }

        protected override bool ShowSourceFileInfo {
            get { 
                return false; 
            }
        }

        protected override string ErrorTitle {
            get { 
                return HttpRuntime.FormatResourceString(SR.TmplCompilerErrorTitle); 
            }
        }

        protected override string Description {
            get {
                return HttpRuntime.FormatResourceString(SR.TmplCompilerErrorDesc);
            }
        }

        protected override string MiscSectionTitle {
            get { 
                return HttpRuntime.FormatResourceString(SR.TmplCompilerErrorSecTitle);
            }
        }

        protected override string MiscSectionContent {
            get { 
                StringBuilder sb = new StringBuilder(128);

                CompilerResults results = _excep.Results;

                // Handle fatal errors where we coun't find an error line
                if (results.Errors.Count == 0 && results.NativeCompilerReturnValue != 0) {
                    sb.Append(HttpRuntime.FormatResourceString(SR.TmplCompilerFatalError,
                        results.NativeCompilerReturnValue.ToString("G")));
                    sb.Append("<br><br>\r\n");
                }

                if (results.Errors.HasErrors) {

                    CompilerError e = null;

                    foreach (CompilerError error in results.Errors) {
                        
                        // Ignore warnings
                        if (error.IsWarning) continue;

                        // If we found an error that's not in the generated code, use it
                        if (!error.FileName.StartsWith(HttpRuntime.CodegenDirInternal)) {
                            e = error;
                            break;
                        }

                        // The current error is in the generated code.  Keep track of
                        // it if it's the first one, but keep on looking in case we find another
                        // one that's not in the generated code (ASURT 62600)
                        if (e == null)
                            e = error;
                    }

                    if (e != null) {
                        sb.Append(HttpUtility.HtmlEncode(e.ErrorNumber));
                        sb.Append(": ");
                        sb.Append(HttpUtility.HtmlEncode(e.ErrorText));
                        sb.Append("<br><br>\r\n");

                        sb.Append("<b>");
                        sb.Append(HttpRuntime.FormatResourceString(SR.TmplCompilerSourceSecTitle));
                        sb.Append(":</b><br><br>\r\n");
                        sb.Append("            <table width=100% bgcolor=\"#ffffcc\">\r\n");
                        sb.Append("               <tr><td>\r\n");
                        sb.Append("               ");
                        sb.Append("               </td></tr>\r\n");
                        sb.Append("               <tr>\r\n");
                        sb.Append("                  <td>\r\n");
                        sb.Append("                      <code><pre>\r\n\r\n");
                        sb.Append(FormatterWithFileInfo.GetSourceFileLines(e.FileName, Encoding.Default, _excep.SourceCode, e.Line));
                        sb.Append("</pre></code>\r\n\r\n");
                        sb.Append("                  </td>\r\n");
                        sb.Append("               </tr>\r\n");
                        sb.Append("            </table>\r\n\r\n");
                        sb.Append("            <br>\r\n\r\n");

                        // display file
                        sb.Append("            <b>");
                        sb.Append(HttpRuntime.FormatResourceString(SR.TmplCompilerSourceFileTitle));
                        sb.Append(":</b> ");
                        sb.Append(HttpUtility.HtmlEncode(HttpRuntime.GetSafePath(e.FileName)));
                        sb.Append("\r\n");

                        // display number
                        TypeConverter itc = new Int32Converter();
                        sb.Append("            &nbsp;&nbsp; <b>");
                        sb.Append(HttpRuntime.FormatResourceString(SR.TmplCompilerSourceFileLine));
                        sb.Append(":</b>  ");
                        sb.Append(HttpUtility.HtmlEncode(itc.ConvertToString(e.Line)));
                        sb.Append("\r\n");
                        sb.Append("            <br><br>\r\n");
                    }
                }

                if (results.Errors.HasWarnings) {
                    sb.Append("<br><div class=\"expandable\" onclick=\"OnToggleTOCLevel1()\" level2ID=\"warningDiv\">");
                    sb.Append(HttpRuntime.FormatResourceString(SR.TmplCompilerWarningBanner));
                    sb.Append(":</div>\r\n");
                    sb.Append("<div id=\"warningDiv\" style=\"display: none;\">\r\n");
                    foreach (CompilerError e in results.Errors) {
                        if (e.IsWarning) {
                            sb.Append("<b>");
                            sb.Append(HttpRuntime.FormatResourceString(SR.TmplCompilerWarningSecTitle));
                            sb.Append(":</b> ");
                            sb.Append(HttpUtility.HtmlEncode(e.ErrorNumber));
                            sb.Append(": ");
                            sb.Append(HttpUtility.HtmlEncode(e.ErrorText));
                            sb.Append("<br>\r\n");

                            sb.Append("<b>");
                            sb.Append(HttpRuntime.FormatResourceString(SR.TmplCompilerSourceSecTitle));
                            sb.Append(":</b><br><br>\r\n");
                            sb.Append("            <table width=100% bgcolor=\"#ffffcc\">\r\n");
                            sb.Append("               <tr><td>\r\n");
                            sb.Append("               <b>");
                            sb.Append(HttpUtility.HtmlEncode(HttpRuntime.GetSafePath(e.FileName)));
                            sb.Append("</b>\r\n");
                            sb.Append("               </td></tr>\r\n");
                            sb.Append("               <tr>\r\n");
                            sb.Append("                  <td>\r\n");
                            sb.Append("                      <code><pre>\r\n\r\n");
                            sb.Append(FormatterWithFileInfo.GetSourceFileLines(e.FileName, Encoding.Default, _excep.SourceCode, e.Line));
                            sb.Append("</pre></code>\r\n\r\n");
                            sb.Append("                  </td>\r\n");
                            sb.Append("               </tr>\r\n");
                            sb.Append("            </table>\r\n\r\n");
                            sb.Append("            <br>\r\n\r\n");
                        }
                    }
                    sb.Append("</div>\r\n");
                }

                if (results.Output.Count > 0) {
                    // (Only display the compiler output in medium or higher (ASURT 126827)
                    if (HttpRuntime.HasAspNetHostingPermission(AspNetHostingPermissionLevel.Medium)) {
                        sb.Append(String.Format(startExpandableBlock, "compilerOutputDiv",
                            HttpRuntime.FormatResourceString(SR.TmplCompilerCompleteOutput)));
                        foreach (string line in results.Output) {
                            sb.Append(HttpUtility.HtmlEncode(line));
                            sb.Append("\r\n");
                        }
                        sb.Append(endExpandableBlock);
                    }
                }

                // If we have the generated source code, display it
                // (Only display the compiler output in medium or higher (ASURT 128039)
                if (_excep.SourceCode != null &&
                    HttpRuntime.HasAspNetHostingPermission(AspNetHostingPermissionLevel.Medium)) {
                    
                    sb.Append(String.Format(startExpandableBlock, "dynamicCodeDiv",
                        HttpRuntime.FormatResourceString(SR.TmplCompilerGeneratedFile)));

                    string[] sourceLines = _excep.SourceCode.Split(new char[] {'\n'});
                    int currentLine = 1;
                    foreach (string s in sourceLines) {
                        string number = currentLine.ToString("G");
                        sb.Append(HttpRuntime.FormatResourceString(SR.TmplCompilerLineHeader, number));
                        if (number.Length < 5) {
                            sb.Append(' ', 5 - number.Length);
                        }
                        currentLine++;

                        sb.Append(HttpUtility.HtmlEncode(s));
                    }
                    sb.Append(endExpandableBlock);
                }

                sb.Append(@"
<script language=""JavaScript"">
function OnToggleTOCLevel1()
{
  var elemSrc = window.event.srcElement;
  var elemLevel2 = document.all(elemSrc.level2ID);

  if (elemLevel2.style.display == 'none')
  {
    elemLevel2.style.display = '';
    if (elemSrc.usesGlyph == '1')
      elemSrc.innerHTML = '&#054;';
  }
  else {
    elemLevel2.style.display = 'none';
    if (elemSrc.usesGlyph == '1')
      elemSrc.innerHTML = '&#052;';
  }
}
</script>
                      ");

                return sb.ToString(); 
            }
        }
    }

    /*
     * Formatter used for parse errors
     */
    internal class ParseErrorFormatter : FormatterWithFileInfo {
        protected string _message;
        HttpParseException _excep;

        internal ParseErrorFormatter(HttpParseException e, string fileName,
            string sourceCode, int line, string message)
        : base(fileName, sourceCode, line) {
            _excep = e;
            _message = message;
        }

        protected override Exception Exception {
            get { return _excep; }
        }

        protected override string ErrorTitle {
            get { return HttpRuntime.FormatResourceString(SR.Parser_Error);}
        }

        protected override string Description {
            get { return HttpRuntime.FormatResourceString(SR.Parser_Desc);}
        }

        protected override string MiscSectionTitle {
            get { return HttpRuntime.FormatResourceString(SR.Parser_Error_Message);}
        }

        protected override string MiscSectionContent {
            get { return HttpUtility.HtmlEncode(_message);}
        }

        protected override string ColoredSquareTitle {
            get { return HttpRuntime.FormatResourceString(SR.Parser_Source_Error);}
        }
    }

    /*
     * Formatter used for configuration errors
     */
    internal class ConfigErrorFormatter : FormatterWithFileInfo {
        protected string _message;
        private Exception _e;

        internal ConfigErrorFormatter(System.Configuration.ConfigurationException e)
        : base(e.Filename, null, e.Line) {
            _e = e;
            PerfCounters.IncrementCounter(AppPerfCounter.ERRORS_PRE_PROCESSING);
            PerfCounters.IncrementCounter(AppPerfCounter.ERRORS_TOTAL);
            _message = e.BareMessage;
        }

        protected override Encoding SourceFileEncoding {
            get { return Encoding.UTF8; }
        }

        protected override Exception Exception {
            get { return _e; }
        }

        protected override string ErrorTitle {
            get { return HttpRuntime.FormatResourceString(SR.Config_Error);}
        }

        protected override string Description {
            get { return HttpRuntime.FormatResourceString(SR.Config_Desc);}
        }

        protected override string MiscSectionTitle {
            get { return HttpRuntime.FormatResourceString(SR.Parser_Error_Message);}
        }

        protected override string MiscSectionContent {
            get { return HttpUtility.HtmlEncode(_message);}
        }

        protected override string ColoredSquareTitle {
            get { return HttpRuntime.FormatResourceString(SR.Parser_Source_Error);}
        }
    }

    /*
     * Formatter to allow user-specified description strings
     * use if showing inner-most exception message is not appropriate
     */
    internal class UseLastUnhandledErrorFormatter : UnhandledErrorFormatter {

        internal UseLastUnhandledErrorFormatter(Exception e) 
            : base(e) {
        }

        internal /*public*/ override void PrepareFormatter() {
            base.PrepareFormatter();

            // use the outer-most exception instead of the inner-most in the misc section
            _initialException = Exception;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Exception thrown by ASP.NET managed runtime
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web {
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.Configuration;
    using System.Security;
    using System.CodeDom.Compiler;
    using System.Security.Permissions;

    /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpException"]/*' />
    /// <devdoc>
    ///    <para> Enables ASP.NET
    ///       to send exception information.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HttpException : ExternalException {
        private const int FACILITY_WIN32 = 7;

        private int _httpCode;
        private ErrorFormatter _errorFormatter;

        // N.B. The last error code can be lost if we were to 
        // call UnsafeNativeMethods.GetLastError from this function
        // and it were not yet jitted.
        internal static int HResultFromLastError(int lastError) {
            int hr;

            if (lastError < 0) {
                hr = lastError;
            }
            else {
                hr = (int)(((uint)lastError & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);
            }

            return hr;
        }

        /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpException.CreateFromLastError"]/*' />
        /// <devdoc>
        ///    <para>Creates a new Exception based on the previous Exception. </para>
        /// </devdoc>
        public static HttpException CreateFromLastError(String message) {
            return new HttpException(message, HResultFromLastError(Marshal.GetLastWin32Error()));
        }

        /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpException.HttpException"]/*' />
        /// <devdoc>
        /// <para> Default constructor.</para>
        /// </devdoc>
        public HttpException() {}

        /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpException.HttpException1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Construct an exception using error message.
        ///    </para>
        /// </devdoc>
        public HttpException(String message)

        : base(message) {
        }

        /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpException.HttpException2"]/*' />
        /// <devdoc>
        ///    <para>Construct an exception using error message and hr.</para>
        /// </devdoc>
        public HttpException(String message, int hr)

        : base(message) {
            HResult = hr;
        }

        /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpException.HttpException3"]/*' />
        /// <devdoc>
        ///    <para>Construct an exception using error message, HTTP code, 
        ///       and innerException
        ///       .</para>
        /// </devdoc>
        public HttpException(String message, Exception innerException)

        : base(message, innerException) {
        }

        /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpException.HttpException4"]/*' />
        /// <devdoc>
        ///    <para>Construct an exception using HTTP error code, error message, 
        ///       and innerException
        ///       .</para>
        /// </devdoc>
        public HttpException(int httpCode, String message, Exception innerException)

        : base(message, innerException) {
            _httpCode = httpCode;
        }

        /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpException.HttpException5"]/*' />
        /// <devdoc>
        ///    <para>Construct an
        ///       exception using HTTP error code and error message.</para>
        /// </devdoc>
        public HttpException(int httpCode, String message)

        : base(message) {
            _httpCode = httpCode;
        }

        /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpException.HttpException6"]/*' />
        /// <devdoc>
        ///    <para> Construct an exception
        ///       using HTTP error code, error message, and hr.</para>
        /// </devdoc>
        public HttpException(int httpCode, String message, int hr)

        : base(message) {
            HResult = hr;
            _httpCode = httpCode;
        }

        /*
         * If we have an Http code (non-zero), return it.  Otherwise, return
         * the inner exception's code.  If there isn't one, return 500.
         */
        /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpException.GetHttpCode"]/*' />
        /// <devdoc>
        ///    <para>HTTP return code to send back to client. If there is a 
        ///       non-zero Http code, it is returned. Otherwise, the System.HttpException.innerException
        ///       code is returned. If
        ///       there isn't an inner exception, error code 500 is returned.</para>
        /// </devdoc>
        public int GetHttpCode() {
            return GetHttpCodeForException(this);
        }

        internal void SetFormatter(ErrorFormatter errorFormatter) {
            _errorFormatter = errorFormatter;
        }

        internal static int GetHttpCodeForException(Exception e) {
            int code = 500;

            if (e is HttpException) {
                HttpException he = (HttpException)e;

                if (he._httpCode > 0)
                    code = he._httpCode;
                else if (he.InnerException != null)
                    code = GetHttpCodeForException(he.InnerException);
                else
                    code = 500;
            }
/*
404 conversion is done in HttpAplpication.MapHttpHandler

            else if (e is FileNotFoundException || e is DirectoryNotFoundException)
            {
                code = 404;
            }
*/
            else if (e is UnauthorizedAccessException) {
                code = 401;
            }
            else if (e is PathTooLongException) {
                code = 414;
            }

            return code;
        }

        /*
         * Return the formatter associated with this exception
         */
        internal static ErrorFormatter GetErrorFormatter(Exception e) {
            Exception inner = e.InnerException;
            ErrorFormatter nestedFormatter = null;

            // First, see if the inner exception has a formatter
            if (inner != null) {
                if (inner is ConfigurationException)
                    nestedFormatter = new ConfigErrorFormatter((ConfigurationException)inner);
                else if (inner is SecurityException)
                    nestedFormatter = new SecurityErrorFormatter(inner);
                else
                    nestedFormatter = GetErrorFormatter(inner);
            }

            // If it does, return it rather than our own
            if (nestedFormatter != null)
                return nestedFormatter;

            HttpException httpExc = e as HttpException;
            if (httpExc != null)
                return httpExc._errorFormatter;

            return null;
        }

        /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpException.GetHtmlErrorMessage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string GetHtmlErrorMessage() {
            ErrorFormatter formatter = GetErrorFormatter(this);
            if (formatter == null) return null;
            return formatter.GetHtmlErrorMessage();
        }
    }

    /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpUnhandledException"]/*' />
    /// <devdoc>
    ///    <para> Exception thrown when a generic error occurs.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpUnhandledException : HttpException {

        /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpUnhandledException.HttpUnhandledException"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Construct an HttpUnhandledException.</para>
        /// </devdoc>
        internal HttpUnhandledException(string message, Exception innerException)
        : base(message, innerException) {
           
            SetFormatter(new UnhandledErrorFormatter(innerException, message, null));
        }

        /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpUnhandledException.HttpUnhandledException1"]/*' />
        /// <internalonly/>
        internal HttpUnhandledException(string message, string postMessage, Exception innerException)
        : base(message, innerException) {
           
            SetFormatter(new UnhandledErrorFormatter(innerException, message, postMessage));
        }
    }

    /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpCompileException"]/*' />
    /// <devdoc>
    ///    <para> Exception thrown when a compilation error occurs.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpCompileException : HttpException {

        private CompilerResults _results;
        private string _sourceCode;

        /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpCompileException.HttpCompileException"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Construct an HttpCompileException.</para>
        /// </devdoc>
        internal HttpCompileException(CompilerResults results, string sourceCode) {
            _results = results;
            _sourceCode = sourceCode;

            SetFormatter(new DynamicCompileErrorFormatter(this));
        }

        /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpCompileException.Results"]/*' />
        /// <devdoc>
        ///    <para> The CompilerResults object describing the compile error.</para>
        /// </devdoc>
        public CompilerResults Results {
            get { 
                InternalSecurityPermissions.AspNetHostingPermissionLevelHigh.Demand();
                return _results;
            } 
        }

        /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpCompileException.SourceCode"]/*' />
        /// <devdoc>
        ///    <para> The source code that was compiled.</para>
        /// </devdoc>
        public string SourceCode {
            get { 
                InternalSecurityPermissions.AspNetHostingPermissionLevelHigh.Demand();
                return _sourceCode; 
            }
        }
    }

    /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpParseException"]/*' />
    /// <devdoc>
    ///    <para> Exception thrown when a parse error occurs.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpParseException : HttpException {

        private string _fileName;
        private int _line;

        /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpParseException.HttpParseException"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Construct an HttpParseException.</para>
        /// </devdoc>
        internal HttpParseException(string message, Exception innerException, string fileName,
            string sourceCode, int line)
            : base(message, innerException) {

            _fileName = fileName;
            _line = line;

            string formatterMessage;
            if (innerException != null)
                formatterMessage = innerException.Message;
            else
                formatterMessage = message;

            SetFormatter(new ParseErrorFormatter(this, fileName, sourceCode, line, formatterMessage));
        }

        /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpParseException.FileName"]/*' />
        /// <devdoc>
        ///    <para> The source code that was compiled.</para>
        /// </devdoc>
        public string FileName {
            get {
                // Demand path discovery before returning the path (ASURT 123798)
                InternalSecurityPermissions.PathDiscovery(_fileName).Demand();
                return _fileName;
            } 
        }

        /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpParseException.Line"]/*' />
        /// <devdoc>
        ///    <para> The CompilerResults object describing the compile error.</para>
        /// </devdoc>
        public int Line {
            get { return _line;} 
        }
    }

    /// <include file='doc\HttpException.uex' path='docs/doc[@for="HttpRequestValidationException"]/*' />
    /// <devdoc>
    ///    <para> Exception thrown when a potentially unsafe input string is detected (ASURT 122278)</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpRequestValidationException : HttpException {
	    internal HttpRequestValidationException(string message)
            : base(message) {

            SetFormatter(new UnhandledErrorFormatter(
                this, HttpRuntime.FormatResourceString(SR.Dangerous_input_detected_descr), null));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpinputstream.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpInputStream.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Input stream used in response and uploaded file objects
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web {

    using System.IO;

    /*
     * Stream object over byte array
     * Not a publc class - used internally, returned as Stream
     */
    internal class HttpInputStream : Stream {
        private byte[] _data;      // the buffer with the content
        private int _offset;        // offset to the start of this stream
        private int _length;        // length of this stream
        private int _pos;           // current reader posision

        //
        // Internal access (from this package)
        //

        internal HttpInputStream(byte[] data, int offset, int length) {
            Init(data, offset, length);
        }

        protected void Init(byte[] data, int offset, int length) {
            _data = data;
            _offset = offset;
            _length = length;
            _pos = 0; 
        }

        protected void Uninit() {
            _data = null;
            _offset = 0;
            _length = 0;
            _pos = 0;
        }

        internal byte[] Data {
            get { return _data;}
        }

        internal int DataOffset {
            get { return _offset;}
        }

        internal int DataLength {
            get { return _length;}
        }                          

        //
        // BufferedStream implementation
        //

        public override bool CanRead {
            get {return true;}
        }

        public override bool CanSeek {
            get {return true;}
        }

        public override bool CanWrite {
            get {return false;}
        }         

        public override long Length {
            get {return _length;}                       
        }

        public override long Position {
            get {return _pos;}

            set {
                Seek(value, SeekOrigin.Begin);
            }            
        }                     

        public override void Close() {
            Uninit();
        }        

        public override void Flush() {
        }

        public override long Seek(long offset, SeekOrigin origin) {
            int newpos = _pos;
            int offs = (int)offset;

            switch (origin) {
                case SeekOrigin.Begin:
                    newpos = offs;
                    break;
                case SeekOrigin.Current:
                    newpos = _pos + offs;
                    break;
                case SeekOrigin.End:
                    newpos = _length + offs;
                    break;
                default:
                    throw new ArgumentOutOfRangeException("origin");
            }

            if (newpos < 0 || newpos > _length)
                throw new ArgumentOutOfRangeException("offset");

            _pos = newpos;
            return _pos;
        }

        public override void SetLength(long length) {
            throw new NotSupportedException(); 
        }

        public override int Read(byte[] buffer, int offset, int count) {
            // find the number of bytes to copy
            int numBytes = _length - _pos;
            if (count < numBytes)
                numBytes = count;

            // copy the bytes
            if (numBytes > 0)
                Buffer.BlockCopy(_data, _offset+_pos, buffer, offset, numBytes);

            // adjust the position
            _pos += numBytes;
            return numBytes;
        }

        public override void Write(byte[] buffer, int offset, int count) {
            throw new NotSupportedException();
        }
    }

    /*
     * Stream used as the source for input filtering
     */

    internal class HttpInputStreamFilterSource : HttpInputStream {
        internal HttpInputStreamFilterSource() : base(null, 0, 0) {
        }

        internal void SetContent(byte[] data) {
            if (data != null)
                base.Init(data, 0, data.Length);
            else
                base.Uninit();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpfilecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpFileCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Collection of posted files for the request intrinsic
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web {

    using System.Runtime.InteropServices;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Security.Permissions;

    /// <include file='doc\HttpFileCollection.uex' path='docs/doc[@for="HttpFileCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Accesses incoming files uploaded by a client (using
    ///       multipart MIME and the Http Content-Type of multipart/formdata).
    ///    </para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpFileCollection : NameObjectCollectionBase {
        // cached All[] arrays
        private HttpPostedFile[] _all;
        private String[] _allKeys;

        internal HttpFileCollection() {
        }
        
        /// <include file='doc\HttpFileCollection.uex' path='docs/doc[@for="HttpFileCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Array dest, int index) {
            if (_all == null) {
                int n = Count;
                _all = new HttpPostedFile[n];
                for (int i = 0; i < n; i++)
                    _all[i] = Get(i);
            }

            if (_all != null) {
                _all.CopyTo(dest, index);
            }
        }

        internal void AddFile(String key, HttpPostedFile file) {
            _all = null;
            _allKeys = null;

            BaseAdd(key, file);
        }

#if UNUSED
        internal void Reset() {
            _all = null;
            _allKeys = null;

            BaseClear();
        }
#endif

        //
        //  Access by name
        //

        /// <include file='doc\HttpFileCollection.uex' path='docs/doc[@for="HttpFileCollection.Get"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a file from
        ///       the collection by file name.
        ///    </para>
        /// </devdoc>
        public HttpPostedFile Get(String name) {
            return(HttpPostedFile)BaseGet(name);
        }

        /// <include file='doc\HttpFileCollection.uex' path='docs/doc[@for="HttpFileCollection.this"]/*' />
        /// <devdoc>
        ///    <para>Returns item value from collection.</para>
        /// </devdoc>
        public HttpPostedFile this[String name]
        {
            get { return Get(name);}
        }

        //
        // Indexed access
        //

        /// <include file='doc\HttpFileCollection.uex' path='docs/doc[@for="HttpFileCollection.Get1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a file from
        ///       the file collection by index.
        ///    </para>
        /// </devdoc>
        public HttpPostedFile Get(int index) {
            return(HttpPostedFile)BaseGet(index);
        }

        /// <include file='doc\HttpFileCollection.uex' path='docs/doc[@for="HttpFileCollection.GetKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns key name from collection.
        ///    </para>
        /// </devdoc>
        public String GetKey(int index) {
            return BaseGetKey(index);
        }

        /// <include file='doc\HttpFileCollection.uex' path='docs/doc[@for="HttpFileCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns an
        ///       item from the collection.
        ///    </para>
        /// </devdoc>
        public HttpPostedFile this[int index]
        {
            get { return Get(index);}
        }

        //
        // Access to keys and values as arrays
        //
        
        /// <include file='doc\HttpFileCollection.uex' path='docs/doc[@for="HttpFileCollection.AllKeys"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an
        ///       array of keys in the collection.
        ///    </para>
        /// </devdoc>
        public String[] AllKeys {
            get {
                if (_allKeys == null)
                    _allKeys = BaseGetAllKeys();

                return _allKeys;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpmodulecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpModuleCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Collection of IHttpModules
 * 
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web {
    using System.Runtime.InteropServices;

    using System.Collections;
    using System.Collections.Specialized;
    using System.Web;
    using System.Web.Util;
    using System.Security.Permissions;

    /// <include file='doc\HttpModuleCollection.uex' path='docs/doc[@for="HttpModuleCollection"]/*' />
    /// <devdoc>
    ///    <para>A collection of IHttpModules</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpModuleCollection : NameObjectCollectionBase {
        // cached All[] arrays
        private IHttpModule[] _all;
        private String[] _allKeys;

        internal HttpModuleCollection() {
        }

        /// <include file='doc\HttpModuleCollection.uex' path='docs/doc[@for="HttpModuleCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Array dest, int index) {                            
            if (_all == null) {
                int n = Count;
                _all = new IHttpModule[n];
                for (int i = 0; i < n; i++)
                    _all[i] = Get(i);
            }

            if (_all != null) {
                _all.CopyTo(dest, index);
            }
        }
        
        internal void AddModule(String name, IHttpModule m) {
            _all = null;
            _allKeys = null;

            BaseAdd(name, m);
        }
        
#if UNUSED
        internal void Reset() {
            _all = null;
            _allKeys = null;

            BaseClear();
        }
#endif

        //
        //  Access by name
        //

        /// <include file='doc\HttpModuleCollection.uex' path='docs/doc[@for="HttpModuleCollection.Get"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IHttpModule Get(String name) {
            return(IHttpModule)BaseGet(name);
        }

        /// <include file='doc\HttpModuleCollection.uex' path='docs/doc[@for="HttpModuleCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IHttpModule this[String name]
        {
            get { return Get(name);}
        }

        //
        // Indexed access
        //

        /// <include file='doc\HttpModuleCollection.uex' path='docs/doc[@for="HttpModuleCollection.Get1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IHttpModule Get(int index) {
            return(IHttpModule)BaseGet(index);
        }

        /// <include file='doc\HttpModuleCollection.uex' path='docs/doc[@for="HttpModuleCollection.GetKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public String GetKey(int index) {
            return BaseGetKey(index);
        }

        /// <include file='doc\HttpModuleCollection.uex' path='docs/doc[@for="HttpModuleCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IHttpModule this[int index]
        {
            get { return Get(index);}
        }

        //
        // Access to keys and values as arrays
        //
        
        /// <include file='doc\HttpModuleCollection.uex' path='docs/doc[@for="HttpModuleCollection.AllKeys"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public String[] AllKeys {
            get {
                if (_allKeys == null)
                    _allKeys = BaseGetAllKeys();

                return _allKeys;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httprawresponse.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpRawResponse.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Lean representation of response data
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web {

    using System.Collections;

    internal class HttpRawResponse {
        private int _statusCode = 200;
        private String _statusDescr;
        private ArrayList _headers;
        private ArrayList _buffers;
        private bool _hasSubstBlocks;

        internal HttpRawResponse() {
        }

        internal int StatusCode {
            get { return _statusCode;}
            set { _statusCode = value;}
        }

        internal String StatusDescription {
            get { return _statusDescr;}
            set { _statusDescr = value;}
        }

        // list of HttpResponseHeader objects
        internal ArrayList Headers {
            get { return _headers;}
            set { _headers = value;}
        }

        // list of IHttpResponseElement objects
        internal ArrayList Buffers {
            get { return _buffers;}
            set { _buffers = value;}
        }

        internal bool HasSubstBlocks {
            get { return _hasSubstBlocks;}
            set { _hasSubstBlocks = value;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httppostedfile.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpPostedFile.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HttpCookie - collection + name + path
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web {

    using System.IO;
    using System.Security.Permissions;

    /// <include file='doc\HttpPostedFile.uex' path='docs/doc[@for="HttpPostedFile"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides a way to
    ///       access files uploaded by a client.
    ///    </para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpPostedFile {
        private String _filename;
        private String _contentType;
        private HttpInputStream _stream;

        internal HttpPostedFile(String filename, String contentType, HttpInputStream stream) {
            _filename = filename;
            _contentType = contentType;
            _stream = stream;
        }

        /*
         * File name
         */
        /// <include file='doc\HttpPostedFile.uex' path='docs/doc[@for="HttpPostedFile.FileName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the full path of a file on the local browser's machine (for
        ///       example, &quot;c:\temp\test.txt&quot;).
        ///    </para>
        /// </devdoc>
        public String FileName {
            get { return _filename;}
        }

        /*
         * Content type
         */
        /// <include file='doc\HttpPostedFile.uex' path='docs/doc[@for="HttpPostedFile.ContentType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the MIME content type of an incoming file sent by a client.
        ///    </para>
        /// </devdoc>
        public String ContentType {
            get { return _contentType;}
        }

        /*
         * Content length
         */
        /// <include file='doc\HttpPostedFile.uex' path='docs/doc[@for="HttpPostedFile.ContentLength"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the size of an uploaded file, in bytes.
        ///    </para>
        /// </devdoc>
        public int ContentLength {
            get { return _stream.DataLength;}
        }

        /*
         * Stream
         */
        /// <include file='doc\HttpPostedFile.uex' path='docs/doc[@for="HttpPostedFile.InputStream"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides raw access to
        ///       contents of an uploaded file.
        ///    </para>
        /// </devdoc>
        public Stream InputStream {
            get { return _stream;}
        }

        /*
         * Save into file
         */
        /// <include file='doc\HttpPostedFile.uex' path='docs/doc[@for="HttpPostedFile.SaveAs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initiates a utility method to save an uploaded file to disk.
        ///    </para>
        /// </devdoc>
        public void SaveAs(String filename) {
            FileStream f = new FileStream(filename, FileMode.Create);

            try {

                // use non-public properties to access the buffer directly
                if (_stream.DataLength > 0)
                    f.Write(_stream.Data, _stream.DataOffset, _stream.DataLength);

                f.Flush();
            }
            finally {
                f.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpnotfoundhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="HTTPNotFoundHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Synchronous Http request handler interface
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web {

    /// <include file='doc\HTTPNotFoundHandler.uex' path='docs/doc[@for="HttpNotFoundHandler"]/*' />
    /// <devdoc>
    ///    <para>Provides a synchronous Http request handler interface.</para>
    /// </devdoc>
    internal class HttpNotFoundHandler : IHttpHandler {
        
        internal HttpNotFoundHandler() {
        }

        /// <include file='doc\HTTPNotFoundHandler.uex' path='docs/doc[@for="HttpNotFoundHandler.ProcessRequest"]/*' />
        /// <devdoc>
        ///    <para>Drives web processing execution.</para>
        /// </devdoc>
        public void ProcessRequest(HttpContext context) {
            PerfCounters.IncrementCounter(AppPerfCounter.REQUESTS_NOT_FOUND);

            throw new HttpException(404, 
                                    HttpRuntime.FormatResourceString(SR.Path_not_found, context.Request.Path));
        }

        /// <include file='doc\HTTPNotFoundHandler.uex' path='docs/doc[@for="HttpNotFoundHandler.IsReusable"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether an HttpNotFoundHandler instance can be recycled and used 
        ///       for another request.</para>
        /// </devdoc>
        public bool IsReusable {
            get { return true; }
        }
    }

    /// <include file='doc\HTTPNotFoundHandler.uex' path='docs/doc[@for="HttpForbiddenHandler"]/*' />
    internal class HttpForbiddenHandler : IHttpHandler {
        
        internal HttpForbiddenHandler() {
        }

        /// <include file='doc\HTTPNotFoundHandler.uex' path='docs/doc[@for="HttpForbiddenHandler.ProcessRequest"]/*' />
        /// <devdoc>
        ///    <para>Drives web processing execution.</para>
        /// </devdoc>
        public void ProcessRequest(HttpContext context) {
            PerfCounters.IncrementCounter(AppPerfCounter.REQUESTS_NOT_FOUND);

            throw new HttpException(403, 
                                    HttpRuntime.FormatResourceString(SR.Path_forbidden, context.Request.Path));
        }

        /// <include file='doc\HTTPNotFoundHandler.uex' path='docs/doc[@for="HttpForbiddenHandler.IsReusable"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether an HttpForbiddenHandler instance can be recycled and used 
        ///       for another request.</para>
        /// </devdoc>
        public bool IsReusable {
            get { return true; }
        }
    }

    /// <include file='doc\HTTPNotFoundHandler.uex' path='docs/doc[@for="HttpMethodNotAllowedHandler"]/*' />
    /// <devdoc>
    ///    <para>Provides a synchronous Http request handler interface.</para>
    /// </devdoc>
    internal class HttpMethodNotAllowedHandler : IHttpHandler {
        
        internal HttpMethodNotAllowedHandler() {
        }

        /// <include file='doc\HTTPNotFoundHandler.uex' path='docs/doc[@for="HttpMethodNotAllowedHandler.ProcessRequest"]/*' />
        /// <devdoc>
        ///    <para> Drives 
        ///       web processing execution.</para>
        /// </devdoc>
        public void ProcessRequest(HttpContext context) {
            throw new HttpException(405,
                                    HttpRuntime.FormatResourceString(SR.Path_forbidden, context.Request.HttpMethod));
        }

        /// <include file='doc\HTTPNotFoundHandler.uex' path='docs/doc[@for="HttpMethodNotAllowedHandler.IsReusable"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether an HttpForbiddenHandler instance can be recycled and used 
        ///       for another request.</para>
        /// </devdoc>
        public bool IsReusable {
            get { return true; }
        }
    }

    /// <include file='doc\HTTPNotFoundHandler.uex' path='docs/doc[@for="HttpNotImplementedHandler"]/*' />
    /// <devdoc>
    ///    <para>Provides a synchronous Http request handler interface.</para>
    /// </devdoc>
    internal class HttpNotImplementedHandler : IHttpHandler {
        
        internal HttpNotImplementedHandler() {
        }

        /// <include file='doc\HTTPNotFoundHandler.uex' path='docs/doc[@for="HttpNotImplementedHandler.ProcessRequest"]/*' />
        /// <devdoc>
        ///    <para>Drives web processing execution.</para>
        /// </devdoc>
        public void ProcessRequest(HttpContext context) {
            throw new HttpException(501, 
                                    HttpRuntime.FormatResourceString(SR.Method_for_path_not_implemented, context.Request.HttpMethod, context.Request.Path));
        }

        /// <include file='doc\HTTPNotFoundHandler.uex' path='docs/doc[@for="HttpNotImplementedHandler.IsReusable"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether an HttpNotImplementedHandler instance can be recycled and 
        ///       used for another request.</para>
        /// </devdoc>
        public bool IsReusable {
            get { return true; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpresponseheader.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpResponseHeader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Single http header representation
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web {

    using System.Collections;

    /*
     * Response header (either known or unknown)
     */
    internal class HttpResponseHeader {
        private String _unknownHeader;
        private int _knownHeaderIndex;
        private String _value;

        internal HttpResponseHeader(int knownHeaderIndex, String value) {
            _unknownHeader = null;
            _knownHeaderIndex = knownHeaderIndex;
            _value = value;
        }

        internal HttpResponseHeader(String unknownHeader, String value) {
            _unknownHeader = unknownHeader;
            _knownHeaderIndex = HttpWorkerRequest.GetKnownResponseHeaderIndex(_unknownHeader);
            _value = value;
        }

        internal virtual String Name {
            get {
                if (_unknownHeader != null)
                    return _unknownHeader;
                else
                    return HttpWorkerRequest.GetKnownResponseHeaderName(_knownHeaderIndex);
            }
        }

        internal String Value {
            get { return _value;}
        }

        internal void Send(HttpWorkerRequest wr) {
            if (_knownHeaderIndex >= 0)
                wr.SendKnownResponseHeader(_knownHeaderIndex, _value);
            else
                wr.SendUnknownResponseHeader(_unknownHeader, _value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpresponse.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpResponse.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Response intrinsic
 */
namespace System.Web {

    using System.Text;
    using System.Threading;
    using System.Runtime.Serialization;
    using System.IO;
    using System.Collections;
    using System.Globalization;
    using System.Web.Util;
    using System.Web.Caching;
    using System.Web.Configuration;
    using System.Web.UI;
    using System.Configuration;
    using System.Security.Permissions;

    /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse"]/*' />
    /// <devdoc>
    ///    <para> Enables type-safe server to browser communication. Used to
    ///       send Http output to a client.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpResponse {
        private HttpWorkerRequest _wr;              // some response have HttpWorkerRequest
        private HttpContext _context;               // context
        private HttpWriter _httpWriter;             // and HttpWriter
        private TextWriter _writer;                 // others just have Writer

        private bool _headersWritten;
        private bool _completed;    // after final flush
        private bool _ended;        // response.end
        private bool _flushing;
        private bool _clientDisconnected;
        private bool _filteringCompleted;
        private bool _closeConnectionAfterError;

        // simple properties

        private int         _statusCode = 200;
        private String      _statusDescription;
        private bool        _bufferOutput = true;
        private String      _contentType = "text/html";
        private String      _charSet;
        private bool        _customCharSet;
        private int         _contentLength;
        private String      _redirectLocation;
        private Encoding    _encoding;
        private Encoder     _encoder; // cached encoder for the encoding
        private bool        _cacheControlHeaderAdded;
        private HttpCachePolicy _cachePolicy;
        private ArrayList   _cacheHeaders;
        private bool        _suppressHeaders;
        private bool        _suppressContentSet;
        private bool        _suppressContent;
        private string      _appPathModifier;

        // complex properties

        private ArrayList               _customHeaders;
        private HttpCookieCollection    _cookies;
        private ResponseDependencyList  _fileDependencyList;
        private ResponseDependencyList  _cacheItemDependencyList;

        // cache properties
        int         _expiresInMinutes;
        bool        _expiresInMinutesSet;
        DateTime    _expiresAbsolute;
        bool        _expiresAbsoluteSet;
        string      _cacheControl;

        // chunking
        bool        _transferEncodingSet;
        bool        _chunked;

        internal HttpContext Context {
            get { return _context; }
        }

        internal HttpRequest Request {
            get {
                if (_context == null)
                    return null;
                return _context.Request;
            }
        }

        /*
         * Internal package visible constructor to create responses that
         * have HttpWorkerRequest
         *
         * @param wr Worker Request
         */
        internal HttpResponse(HttpWorkerRequest wr, HttpContext context) {
            _wr = wr;
            _context = context;
            // HttpWriter is created in InitResponseWriter
        }

        /*
         * Public constructor for responses that go to an arbitrary writer
         *
         * @param writer TextWriter
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.HttpResponse"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see langword='HttpResponse'/> class.</para>
        /// </devdoc>
        public HttpResponse(TextWriter writer) {
            _wr = null;
            _httpWriter = null;
            _writer = writer;
        }

        private bool UsingHttpWriter {
            get {
                return (_httpWriter != null && _writer == _httpWriter);
            }
        }

        /*
         *  Cleanup code
         */
        internal void Dispose() {
            // recycle buffers
            if (_httpWriter != null)
                _httpWriter.Dispose();
        }

        internal void InitResponseWriter() {
            if (_httpWriter == null) {
                _httpWriter = new HttpWriter(this);
                _writer = _httpWriter;
            }
        }

        //
        // Private helper methods
        //

        private void AppendHeader(HttpResponseHeader h) {
            if (_customHeaders == null)
                _customHeaders = new ArrayList();
            _customHeaders.Add(h);
        }

        private ArrayList GenerateResponseHeaders(bool forCache) {
            ArrayList   headers = new ArrayList();

            // ASP.NET version header
            if (!forCache) {
                String versionHeader = null;
                try {
                    HttpRuntimeConfig runtimeConfig = (HttpRuntimeConfig)_context.GetConfig("system.web/httpRuntime");
                    if (runtimeConfig != null)
                        versionHeader = runtimeConfig.VersionHeader;
                }
                catch {
                }
                if (versionHeader != null && versionHeader.Length > 0)
                    headers.Add(new HttpResponseHeader("X-AspNet-Version", versionHeader));
            }

            // custom headers
            if (_customHeaders != null) {
                int numCustomHeaders = _customHeaders.Count;
                for (int i = 0; i < numCustomHeaders; i++)
                    headers.Add(_customHeaders[i]);
            }

            // location of redirect
            if (_redirectLocation != null) {
                headers.Add(new HttpResponseHeader(HttpWorkerRequest.HeaderLocation, _redirectLocation));
            }

            // don't include headers that the cache changes or omits on a cache hit
            if (!forCache) {  
                // cookies
                if (_cookies != null) {
                    int numCookies = _cookies.Count;

                    for (int i = 0; i < numCookies; i++) {
                        headers.Add(_cookies[i].GetSetCookieHeader());
                    }
                }

                // cache policy
                if (_cachePolicy != null && _cachePolicy.IsModified()) {
                    _cachePolicy.GetHeaders(headers, this);
                }
                else {
                    if (_cacheHeaders != null) {
                        headers.AddRange(_cacheHeaders);
                    }
    
                    /*
                     * Ensure that cacheability is set to cache-control: private
                     * if it is not explicitly set.
                     */
                    if (!_cacheControlHeaderAdded) {
                        headers.Add(new HttpResponseHeader(HttpWorkerRequest.HeaderCacheControl, "private"));
                    }
                }
            }

            // content type
            if (_statusCode != 204 && _contentType != null) {
                String contentType = _contentType;

                // charset=xxx logic -- append if
                //      not there already and
                //          custom set or response encoding used by http writer to convert bytes to chars
                if (_contentType.IndexOf("charset=") < 0) {
                    if (_customCharSet || (_httpWriter != null && _httpWriter.ResponseEncodingUsed)) {
                        String charset = Charset;
                        if (charset.Length > 0)  // not suppressed
                            contentType = _contentType + "; charset=" + charset;
                    }
                }

                headers.Add(new HttpResponseHeader(HttpWorkerRequest.HeaderContentType, contentType));
            }

            // content length
            if (_contentLength > 0)
                headers.Add(new HttpResponseHeader(HttpWorkerRequest.HeaderContentLength, (_contentLength).ToString(NumberFormatInfo.InvariantInfo)));

            // done
            return headers;
        }

        private void WriteHeaders() {
            if (_wr == null)
                return;

            // Fire pre-send headers event

            if (_context != null && _context.ApplicationInstance != null)
                _context.ApplicationInstance.RaiseOnPreSendRequestHeaders();

            // status

            _wr.SendStatus(this.StatusCode, this.StatusDescription);

            // headers

            ArrayList headers = GenerateResponseHeaders(false);

            int n = (headers != null) ? headers.Count : 0;
            for (int i = 0; i < n; i++)
                ((HttpResponseHeader)(headers[i])).Send(_wr);
        }

        internal int GetBufferedLength() {
            return (_httpWriter != null) ? _httpWriter.GetBufferedLength() : 0;
        }

        private static byte[] s_chunkSuffix = new byte[2] { (byte)'\r', (byte)'\n'};
        private static byte[] s_chunkEnd    = new byte[5] { (byte)'0',  (byte)'\r', (byte)'\n', (byte)'\r', (byte)'\n'};

        private void Flush(bool finalFlush) {
            // Already completed or inside Flush?
            if (_completed || _flushing)
                return;

            // Special case for non HTTP Writer
            if (_httpWriter == null) {
                _writer.Flush();
                return;
            }

            // Avoid recursive flushes
            _flushing = true;

            try {
                int bufferedLength = 0;

                //
                // Headers
                //

                if (!_headersWritten) {
                    if (!_suppressHeaders && !_clientDisconnected) {
                        if (finalFlush) {
                            bufferedLength = _httpWriter.GetBufferedLength();

                            // suppress content-type for empty responses
                            if (_contentLength == 0 && bufferedLength == 0)
                                _contentType = null;

                            // kernel mode caching (only if the entire response goes in a single flush)
                            SetKernelModeCacheability();

                            // generate response headers
                            WriteHeaders();

                            // recalculate as sending headers might change it (PreSendHeaders)
                            bufferedLength = _httpWriter.GetBufferedLength();

                            // Calculate content-length if not set explicitely
                            if (_contentLength == 0)
                                _wr.SendCalculatedContentLength(bufferedLength);
                        }
                        else {
                            // Check if need chunking for HTTP/1.1
                            if (_contentLength == 0 && !_transferEncodingSet && _statusCode == 200) {
                                String protocol = _wr.GetHttpVersion();

                                if (protocol != null && protocol.Equals("HTTP/1.1")) {
                                    AppendHeader(new HttpResponseHeader(HttpWorkerRequest.HeaderTransferEncoding, "chunked"));
                                    _chunked = true;
                                }

                                bufferedLength = _httpWriter.GetBufferedLength();
                            }

                            WriteHeaders();
                        }
                    }

                    _headersWritten = true;
                }
                else {
                    bufferedLength = _httpWriter.GetBufferedLength();
                }

                //
                // Filter and recalculate length if not done already
                //

                if (!_filteringCompleted) {
                    _httpWriter.Filter(false);
                    bufferedLength = _httpWriter.GetBufferedLength();
                }

                //
                // Content
                //

                // suppress HEAD content unless overriden
                if (!_suppressContentSet && Request != null && Request.HttpMethod.Equals("HEAD"))
                    _suppressContent = true;

                if (_suppressContent || _ended) {
                    _httpWriter.ClearBuffers();
                    bufferedLength = 0;
                }

                if (!_clientDisconnected) {
                    // Fire pre-send request event
                    if (_context != null && _context.ApplicationInstance != null)
                        _context.ApplicationInstance.RaiseOnPreSendRequestContent();

                    if (_chunked) {
                        if (bufferedLength > 0) {
                            byte[] chunkPrefix = Encoding.ASCII.GetBytes(Convert.ToString(bufferedLength, 16) + "\r\n");
                            _wr.SendResponseFromMemory(chunkPrefix, chunkPrefix.Length);

                            _httpWriter.Send(_wr);

                            _wr.SendResponseFromMemory(s_chunkSuffix, s_chunkSuffix.Length);
                        }

                        if (finalFlush)
                            _wr.SendResponseFromMemory(s_chunkEnd, s_chunkEnd.Length);
                    }
                    else {
                        _httpWriter.Send(_wr);
                    }

                    _wr.FlushResponse(finalFlush);

                    if (!finalFlush)
                        _httpWriter.ClearBuffers();
                }
            }
            finally {
                _flushing = false;

                // Remember if completed
                if (finalFlush)
                    _completed = true;
            }
        }

        internal void FinalFlushAtTheEndOfRequestProcessing() {
            if (_context.HasBeforeDoneWithSessionHandlers) {
                // Disable automatic 'doneWithSession' on final flush if someone is
                // listening to BeforeDoneWithSession event on the context
                // (don't flush if no content)
                if (_httpWriter != null && _httpWriter.GetBufferedLength() > 0)
                    Flush(false);
            }
            else {
                // Finish the request for good
                Flush(true);
            }
        }

        //
        // Resposne is suitable for kernel mode caching in IIS6 and set the cache policy
        //
        private void SetKernelModeCacheability() {
            // check cache policy
            if (_cachePolicy == null || !_cachePolicy.IsKernelCacheable())
                return;

            // must be on IIS6
            System.Web.Hosting.ISAPIWorkerRequestInProcForIIS6 iis6wr =
                (_wr as System.Web.Hosting.ISAPIWorkerRequestInProcForIIS6);
            if (iis6wr == null)
                return;

            // only 200 Ok responses are cacheable
            if (_statusCode != 200)
                return;

            // check for GET request
            if (Request == null || Request.HttpMethod != "GET")
                return;

            // check configuration if the kernel mode cache is enabled
            bool enabledInConfig = false; 
            try {
                HttpRuntimeConfig runtimeConfig = (HttpRuntimeConfig)_context.GetConfig("system.web/httpRuntime");
                if (runtimeConfig != null)
                    enabledInConfig = runtimeConfig.EnableKernelOutputCache;
                else
                    enabledInConfig = HttpRuntimeConfig.DefaultEnableKernelOutputCache;
            }
            catch {
            }
            if (!enabledInConfig)
                return;

            // passed all the checks -- tell IIS6 to cache
            iis6wr.CacheInKernelMode(GetCacheDependency(null), _cachePolicy.UtcGetAbsoluteExpiration());

            // tell cache policy not to use max-age as kernel mode cache doesn't update it
            _cachePolicy.SetNoMaxAgeInCacheControl();
        }

        internal void FilterOutput() {
            if (UsingHttpWriter)
                _httpWriter.Filter(true);
            _filteringCompleted = true;
        }

        internal void DisableFiltering() {
            _filteringCompleted = true;
        }

        /*
         * Is the entire response buffered so far
         */
        internal bool IsBuffered() {
            return !_headersWritten && UsingHttpWriter;
        }

        /*
         *  Expose cookie collection to request
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.Cookies"]/*' />
        /// <devdoc>
        ///    <para>Gets the HttpCookie collection sent by the current request.</para>
        /// </devdoc>
        public HttpCookieCollection Cookies {
            get {
                if (_cookies == null)
                    _cookies = new HttpCookieCollection(this, false);

                return _cookies;
            }
        }

        /*
         * Add dependency on a file to the current response
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.AddFileDependency"]/*' />
        /// <devdoc>
        ///    <para>Adds dependency on a file to the current response.</para>
        /// </devdoc>
        public void AddFileDependency(String filename) {
            _fileDependencyList.AddDependency(filename, "filename");
        }

        /*
         * Add dependency on a file to the current response
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.AddFileDependencies"]/*' />
        /// <devdoc>
        ///    <para>Adds dependency on a group of files to the current response.</para>
        /// </devdoc>
        public void AddFileDependencies(ArrayList filenames) {
            _fileDependencyList.AddDependencies(filenames, "filenames");
        }

        /*
         * Add dependency on a file to the current response
         */
        internal string[] GetFileDependencies() {
            return _fileDependencyList.GetDependencies();
        }

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.AddCacheItemDependency"]/*' />
        public void AddCacheItemDependency(string cacheKey) {
            _cacheItemDependencyList.AddDependency(cacheKey, "cacheKey");
        }

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.AddCacheItemDependencies"]/*' />
        public void AddCacheItemDependencies(ArrayList cacheKeys) {
            _cacheItemDependencyList.AddDependencies(cacheKeys, "cacheKeys");
        }

        /*
         * Add dependency on a file to the current response
         */
        internal string[] GetCacheItemDependencies() {
            return _cacheItemDependencyList.GetDependencies();
        }

        internal CacheDependency GetCacheDependency(CacheDependency dependencyVary) {
            CacheDependency dependency;

            // N.B. - add file dependencies last so that we hit the file changes monitor
            // just once.
            dependency = _cacheItemDependencyList.GetCacheDependency(false, dependencyVary);
            dependency = _fileDependencyList.GetCacheDependency(true, dependency);
            return dependency;
        }

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.RemoveOutputCacheItem"]/*' />
        public static void RemoveOutputCacheItem(string path) {
            if (path == null)
                throw new ArgumentNullException("path");
            if (path.StartsWith("\\\\") || path.IndexOf(':') >= 0 || !UrlPath.IsRooted(path))
                throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Invalid_path_for_remove, path));
            
            CacheInternal cacheInternal = HttpRuntime.CacheInternal;

            string key = OutputCacheModule.CreateOutputCachedItemKey(
                    path, CacheRequestMethod.Get, null, null);

            cacheInternal.Remove(key);

            key = OutputCacheModule.CreateOutputCachedItemKey(
                    path, CacheRequestMethod.Post, null, null);

            cacheInternal.Remove(key);
        }

        /*
         * Get response headers and content as HttpRawResponse
         */
        internal HttpRawResponse GetSnapshot() {
            if (!IsBuffered())
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_get_snapshot_if_not_buffered));

            HttpRawResponse data = new HttpRawResponse();

            // data

            if (!_suppressContent) {
                bool hasSubstBlocks;
                data.Buffers = _httpWriter.GetSnapshot(out hasSubstBlocks);
                data.HasSubstBlocks = hasSubstBlocks;
            }

            // headers (after data as the data has side effects (like charset, see ASURT 113202))

            if (!_suppressHeaders) {
                data.StatusCode = _statusCode;
                data.StatusDescription = _statusDescription;
                data.Headers = GenerateResponseHeaders(true);
            }

            return data;
        }

        /*
         * Send saved response snapshot as the entire response
         */
        internal void UseSnapshot(HttpRawResponse rawResponse, bool sendBody) {
            if (_headersWritten)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_use_snapshot_after_headers_sent));

            if (_httpWriter == null)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_use_snapshot_for_TextWriter));

            ClearAll();

            // restore status

            _statusCode = rawResponse.StatusCode;
            _statusDescription = rawResponse.StatusDescription;

            // restore headers

            ArrayList headers = rawResponse.Headers;
            int n = (headers != null) ? headers.Count : 0;
            for (int i = 0; i < n; i++) {
                HttpResponseHeader h = (HttpResponseHeader)(headers[i]);
                this.AppendHeader(h.Name, h.Value);
            }

            // restore content

            _httpWriter.UseSnapshot(rawResponse.Buffers);

            _suppressContent = !sendBody;
        }

        internal void CloseConnectionAfterError() {
            _closeConnectionAfterError = true;
        }

        private void WriteErrorMessage(Exception e, bool dontShowSensitiveErrors) {
            ErrorFormatter errorFormatter = null;
            CultureInfo uiculture = null, savedUiculture = null;
            bool needToRestoreUiculture = false;

            if (_context.DynamicUICulture != null) {
                // if the user set the culture dynamically use it
                uiculture =  _context.DynamicUICulture;
            }
            else  {
                // get the UI culture under which the error text must be created (use LKG to avoid errors while reporting error)
                GlobalizationConfig globConfig = (GlobalizationConfig)_context.GetLKGConfig("system.web/globalization");
                if (globConfig != null)
                    uiculture =  globConfig.UICulture;
            }

            // set the UI culture
            if (uiculture != null) {
                savedUiculture = Thread.CurrentThread.CurrentUICulture;
                Thread.CurrentThread.CurrentUICulture = uiculture;
                needToRestoreUiculture = true;
            }

            try {
                try {
                    // Try to get an error formatter
                    errorFormatter = HttpException.GetErrorFormatter(e);

                    if (errorFormatter == null) {
                        ConfigurationException ce = e as ConfigurationException;
                        if (ce != null)
                            errorFormatter = new ConfigErrorFormatter(ce);
                    }

                    // If we couldn't get one, create one here
                    if (errorFormatter == null) {
                        // If it's a 404, use a special error page, otherwise, use a more
                        // generic one.
                        if (_statusCode == 404)
                            errorFormatter = new PageNotFoundErrorFormatter(Request.Path);
                        else if (_statusCode == 403)
                            errorFormatter = new PageForbiddenErrorFormatter(Request.Path);
                        else {
                            if (e is System.Security.SecurityException)
                                errorFormatter = new SecurityErrorFormatter(e);
                            else
                                errorFormatter = new UnhandledErrorFormatter(e);
                        }
                    }

#if DBG
                    Debug.Trace("internal", "Error stack for " + Request.Path);
                    System.Web.UI.Util.DumpExceptionStack(e);
#endif

                    if (dontShowSensitiveErrors && !errorFormatter.CanBeShownToAllUsers)
                        errorFormatter = new GenericApplicationErrorFormatter(Request.IsLocal);
                
                    _writer.Write(errorFormatter.GetHtmlErrorMessage(dontShowSensitiveErrors));

                    // Write a stack dump in an HTML comment for debugging purposes
                    // Only show it for Asp permission medium or higher (ASURT 126373)
                    if (!dontShowSensitiveErrors &&
                        HttpRuntime.HasAspNetHostingPermission(AspNetHostingPermissionLevel.Medium)) {
                        _writer.Write("<!-- \r\n");
                        WriteExceptionStack(e);
                        _writer.Write("-->");
                    }


                    if (_closeConnectionAfterError) {
                        Flush();
                        Close();
                    }
                }
                finally {
                    // restore ui culture
                    if (needToRestoreUiculture)
                        Thread.CurrentThread.CurrentUICulture = savedUiculture;
                }
            }
            catch { // Protect against exception filters
                throw;
            }
        }

        internal void WriteExceptionStack(Exception e) {
            Exception subExcep = e.InnerException;
            if (subExcep != null)
                WriteExceptionStack(subExcep);

            string title = "[" + e.GetType().Name + "]";
            if (e.Message != null && e.Message.Length > 0)
                title += ": " + HttpUtility.HtmlEncode(e.Message);
            _writer.WriteLine(title);
            if (e.StackTrace != null)
                _writer.WriteLine(e.StackTrace);
        }

        internal void ReportRuntimeError(Exception e, bool canThrow) {
            if (_completed)
                return;

            CustomErrors customErrorsSetting = CustomErrors.GetSettings(_context, canThrow);

            bool useCustomErrors = customErrorsSetting.CustomErrorsEnabled(Request);

            if (!_headersWritten) {
                // nothing sent yet - entire response

                int code = HttpException.GetHttpCodeForException(e);

                // change 401 to 500 in case the config is not to impersonate
                if (code == 401 && !_context.Impersonation.IsClient)
                    code = 500;

                if (_context.TraceIsEnabled)
                    _context.Trace.StatusCode = code;

                if (useCustomErrors) {
                    String redirect = customErrorsSetting.GetRedirectString(code);

                    if (!RedirectToErrorPage(redirect)) {
                        // if no redirect display generic error
                        ClearAll();
                        StatusCode = code;
                        WriteErrorMessage(e, true);
                    }
                }
                else {
                    ClearAll();
                    StatusCode = code;
                    WriteErrorMessage(e, false);
                }
            }
            else {
                Clear();

                if (_contentType != null && _contentType.Equals("text/html")) {
                    // in the middle of Html - break Html
                    Write("\r\n\r\n</pre></table></table></table></table></table>");
                    Write("</font></font></font></font></font>");
                    Write("</i></i></i></i></i></b></b></b></b></b></u></u></u></u></u>");
                    Write("<p>&nbsp;</p><hr>\r\n\r\n");

                    WriteErrorMessage(e, useCustomErrors);
                }
            }
        }

        //
        // Public properties
        //

        /*
         * Http status code
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.StatusCode"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       or sets the HTTP status code of output returned to
        ///       client.</para>
        /// </devdoc>
        public int StatusCode {
            get {
                return _statusCode; 
            }

            set {
                if (_headersWritten)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_set_status_after_headers_sent));

                if (_statusCode != value) {
                    _statusCode = value;
                    _statusDescription = null;
                }
            }
        }

        /*
         * Http status description string
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.StatusDescription"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the HTTP status string of output returned to the
        ///       client.</para>
        /// </devdoc>
        public String StatusDescription {
            get {
                if (_statusDescription == null)
                    _statusDescription = HttpWorkerRequest.GetStatusDescription(_statusCode);

                return _statusDescription; 
            }

            set {
                if (_headersWritten)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_set_status_after_headers_sent));

                if (value != null && value.Length > 512)  // ASURT 124743
                    throw new ArgumentOutOfRangeException("value");

                _statusDescription = value;
            }
        }

        /*
         * Flag indicating to buffer the output
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.BufferOutput"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating
        ///       whether HTTP output is buffered.</para>
        /// </devdoc>
        public bool BufferOutput { 
            get {
                return _bufferOutput;
            }

            set {
                if (_bufferOutput != value) {
                    _bufferOutput = value;

                    if (_httpWriter != null)
                        _httpWriter.UpdateResponseBuffering();
                }
            }
        }

        /*
         * Content-type
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.ContentType"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the
        ///       HTTP MIME type of output.</para>
        /// </devdoc>
        public String ContentType {
            get { return _contentType;}

            set {
                if (_headersWritten)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_set_content_type_after_headers_sent));
                _contentType = value;
            }
        }

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.Charset"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the HTTP
        ///       charset of output.</para>
        /// </devdoc>
        public String Charset {
            get {
                if (_charSet == null)
                    _charSet = ContentEncoding.WebName;

                return _charSet;
            }

            set {
                if (_headersWritten)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_set_content_type_after_headers_sent));

                if (value != null)
                    _charSet = value;
                else
                    _charSet = String.Empty;  // to differentiate between not set (default) and empty chatset

                _customCharSet = true;
            }
        }

        /*
         * Content encoding for conversion
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.ContentEncoding"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets
        ///       the HTTP character set of output.</para>
        /// </devdoc>
        public Encoding ContentEncoding {
            get {
                if (_encoding == null) {
                    // use LKG config because Response.ContentEncoding is need to display [config] error
                    GlobalizationConfig globConfig = (GlobalizationConfig)_context.GetLKGConfig("system.web/globalization");
                    if (globConfig != null)
                        _encoding = globConfig.ResponseEncoding;

                    if (_encoding == null)
                        _encoding = Encoding.Default;
                }

                return _encoding;
            }

            set {
                if (value == null)
                    throw new ArgumentNullException("value");

                if (_encoding == null || !_encoding.Equals(value)) {
                    _encoding = value;
                    _encoder = null;   // flush cached encoder

                    if (_httpWriter != null)
                        _httpWriter.UpdateResponseEncoding();
                }
            }
        }

        /*
         * Encoder cached for the current encoding
         */
        internal Encoder ContentEncoder {
            get {
                if (_encoder == null)
                    _encoder = ContentEncoding.GetEncoder();
                return _encoder;
            }
        }

        /*
         * Cache policy
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.Cache"]/*' />
        /// <devdoc>
        ///    <para>Returns the caching semantics of the Web page
        ///       (expiration time, privacy, vary clauses).</para>
        /// </devdoc>
        public HttpCachePolicy Cache {
            get {
                if (_cachePolicy == null) {
                    _cachePolicy = new HttpCachePolicy();
                }

                return _cachePolicy; 
            }
        }

        /*
         * Client connected flag
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.IsClientConnected"]/*' />
        /// <devdoc>
        ///    <para>Gets a value
        ///       Indicating whether the client is still connected to the server.</para>
        /// </devdoc>
        public bool IsClientConnected {
            get {
                if (_clientDisconnected)
                    return false;

                if (_wr != null && !_wr.IsClientConnected()) {
                    _clientDisconnected = true;
                    return false;
                }

                return true;
            }
        }

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.RedirectLocation"]/*' />
        /// <devdoc>
        ///    <para>Gets or Sets a redirection string (value of location resposne header) for redirect response.</para>
        /// </devdoc>
        public String RedirectLocation {
            get { return _redirectLocation; }
            set { _redirectLocation = value; }
        }

        /*
         * Disconnect client
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.Close"]/*' />
        /// <devdoc>
        ///    <para>Closes the socket connection to a client.</para>
        /// </devdoc>
        public void Close() {
            if (!_clientDisconnected && !_completed && _wr != null) {
                _wr.CloseConnection();
                _clientDisconnected = true;
            }
        }

        /*
         * TextWriter object
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.Output"]/*' />
        /// <devdoc>
        ///    <para>Enables custom output to the outgoing Http content body.</para>
        /// </devdoc>
        public TextWriter Output {
            get { return _writer;}
        }

        internal TextWriter SwitchWriter(TextWriter writer) {
            TextWriter oldWriter = _writer;
            _writer = writer;
            return oldWriter;
        }

        /*
         * Output stream
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.OutputStream"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Enables binary output to the outgoing Http content body.
        ///    </para>
        /// </devdoc>
        public Stream OutputStream {
            get {
                if (!UsingHttpWriter)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.OutputStream_NotAvail));

                return _httpWriter.OutputStream;
            }
        }

        /*
         * ASP classic compat
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.BinaryWrite"]/*' />
        /// <devdoc>
        ///    <para>Writes a string of binary characters to the HTTP output stream.</para>
        /// </devdoc>
        public void BinaryWrite(byte[] buffer) {
            OutputStream.Write(buffer, 0, buffer.Length);
        }

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.Pics"]/*' />
        /// <devdoc>
        ///    <para> Appends a PICS (Platform for Internet Content Selection) label HTTP header to the output stream.</para>
        /// </devdoc>
        public void Pics(String value) {
            AppendHeader("PICS-Label", value);
        }

        /*
         * Filtering stream
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.Filter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies a wrapping filter object to modify HTTP entity body
        ///       before transmission.
        ///    </para>
        /// </devdoc>
        public Stream Filter {
            get {
                if (UsingHttpWriter)
                    return _httpWriter.GetCurrentFilter();
                else
                    return null;
            }

            set {
                if (UsingHttpWriter)
                    _httpWriter.InstallFilter(value);
                else
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Filtering_not_allowed));
            }

        }

        /*
         * Flag to suppress writing of content
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.SuppressContent"]/*' />
        /// <devdoc>
        ///    <para>Gets or
        ///       sets a value indicating that HTTP content will not be sent to client.</para>
        /// </devdoc>
        public bool SuppressContent {
            get {
                return _suppressContent; 
            }

            set {
                _suppressContent = value;
                _suppressContentSet = true;
            }
        }

        //
        // Public methods
        //

        /*
          * Add Http custom header
          *
          * @param name header name
          * @param value header value
          */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.AppendHeader"]/*' />
        /// <devdoc>
        ///    <para>Adds an HTTP
        ///       header to the output stream.</para>
        /// </devdoc>
        public void AppendHeader(String name, String value) {
            if (_headersWritten)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_append_header_after_headers_sent));

            // some headers are stored separately or require special action
            int knownHeaderIndex = HttpWorkerRequest.GetKnownResponseHeaderIndex(name);

            switch (knownHeaderIndex) {
                case HttpWorkerRequest.HeaderContentType:
                    _contentType = value;
                    return; // don't keep as custom header

                case HttpWorkerRequest.HeaderContentLength:
                    _contentLength = Int32.Parse(value);
                    return; // don't keep as custom header

                case HttpWorkerRequest.HeaderLocation:
                    _redirectLocation = value;
                    return; // don't keep as custom header

                case HttpWorkerRequest.HeaderTransferEncoding:
                    _transferEncodingSet = true;
                    break;

                case HttpWorkerRequest.HeaderCacheControl:
                    _cacheControlHeaderAdded = true;
                    goto
                case HttpWorkerRequest.HeaderExpires;

                case HttpWorkerRequest.HeaderExpires: 
                case HttpWorkerRequest.HeaderLastModified:
                case HttpWorkerRequest.HeaderEtag:
                case HttpWorkerRequest.HeaderVary:
                    if (_cacheHeaders == null) {
                        _cacheHeaders = new ArrayList();
                    }

                    _cacheHeaders.Add(new HttpResponseHeader(knownHeaderIndex, value));
                    return; // don't keep as custom header
            }

            HttpResponseHeader h;
            if (knownHeaderIndex >= 0)
                h = new HttpResponseHeader(knownHeaderIndex, value);
            else
                h = new HttpResponseHeader(name, value);

            AppendHeader(h);
        }

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.AppendCookie"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Adds an HTTP
        ///       cookie to the output stream.
        ///    </para>
        /// </devdoc>
        public void AppendCookie(HttpCookie cookie) {
            if (_headersWritten)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_append_cookie_after_headers_sent));

            Cookies.AddCookie(cookie, true);
            OnCookieAdd(cookie);
        }

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.SetCookie"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public void SetCookie(HttpCookie cookie) {
            if (_headersWritten)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_append_cookie_after_headers_sent));

            Cookies.AddCookie(cookie, false);
            OnCookieCollectionChange();
        }

        internal void BeforeCookieCollectionChange() {
            if (_headersWritten)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_modify_cookies_after_headers_sent));
        }

        internal void OnCookieAdd(HttpCookie cookie) {
            // add to request's cookies as well
            Request.AddResponseCookie(cookie);
        }

        internal void OnCookieCollectionChange() {
            // synchronize with request cookie collection
            Request.ResetCookies();
        }

        /*
         * Clear response headers
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.ClearHeaders"]/*' />
        /// <devdoc>
        ///    <para>Clears all headers from the buffer stream.</para>
        /// </devdoc>
        public void ClearHeaders() {
            if (_headersWritten)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_clear_headers_after_headers_sent));

            _statusCode = 200;
            _statusDescription = null;

            _contentType = "text/html";
            _charSet = null;
            _customCharSet = false;
            _contentLength = 0;

            _redirectLocation = null;

            _customHeaders = null;

            _transferEncodingSet = false;

            if (_cookies != null) {
                _cookies.Reset();
                Request.ResetCookies();
            }

            if (_cachePolicy != null) {
                _cachePolicy.Reset();
            }

            _cacheControlHeaderAdded = false;
            _cacheHeaders = null;

            _suppressHeaders = false;
            _suppressContent = false;
            _suppressContentSet = false;

            _expiresInMinutes = 0;
            _expiresInMinutesSet = false;
            _expiresAbsolute = DateTime.MinValue;
            _expiresAbsoluteSet = false;
            _cacheControl = null;
        }

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.ClearContent"]/*' />
        /// <devdoc>
        ///    <para>Clears all content output from the buffer stream.</para>
        /// </devdoc>
        public void ClearContent() {
            Clear();
        }

        /*
         * Clear response buffer and headers. (For ASP compat doesn't clear headers)
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.Clear"]/*' />
        /// <devdoc>
        ///    <para>Clears all headers and content output from the buffer stream.</para>
        /// </devdoc>
        public void Clear() {
            if (UsingHttpWriter)
                _httpWriter.ClearBuffers();
        }

        /*
         * Clear response buffer and headers. Internal. Used to be 'Clear'.
         */
        internal void ClearAll() {
            if (!_headersWritten)
                ClearHeaders();
            Clear();
        }

        /*
         * Flush response currently buffered
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.Flush"]/*' />
        /// <devdoc>
        ///    <para>Sends all currently buffered output to the client.</para>
        /// </devdoc>
        public void Flush() {
            if (_completed)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_flush_completed_response));

            Flush(false);
        }

        /*
         * Append string to the log record
         *
         * @param param string to append to the log record
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.AppendToLog"]/*' />
        /// <devdoc>
        ///    <para>Adds custom log information to the IIS log file.</para>
        /// </devdoc>
        public void AppendToLog(String param) {
            InternalSecurityPermissions.AspNetHostingPermissionLevelMedium.Demand();

            // only makes sense for IIS
            if (_wr is System.Web.Hosting.ISAPIWorkerRequest)
                ((System.Web.Hosting.ISAPIWorkerRequest)_wr).AppendLogParameter(param);
        }

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.Redirect"]/*' />
        /// <devdoc>
        ///    <para>Redirects a client to a new URL.</para>
        /// </devdoc>
        public void Redirect(String url) {
            Redirect(url, true);
        }

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.Redirect2"]/*' />
        /// <devdoc>
        ///    <para>Redirects a client to a new URL.</para>
        /// </devdoc>
        public void Redirect(String url, bool endResponse) {
            if (url == null)
                throw new ArgumentNullException("url");

            if (url.IndexOf('\n') >= 0)
                throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Cannot_redirect_to_newline));

            if (_headersWritten)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_redirect_after_headers_sent));

            url = ApplyAppPathModifier(url);

            url = ConvertToFullyQualifiedRedirectUrlIfRequired(url);

            url = UrlEncodeRedirect(url);

            Clear();

            // If it's a Page and SmartNavigation is on, return a short script
            // to perform the redirect instead of returning a 302 (bugs ASURT 82331/86782)
            Page page = _context.Handler as Page;
            if (page != null && page.IsPostBack && page.SmartNavigation) {
                Write("<BODY><ASP_SMARTNAV_RDIR url=\"");
                Write(url);
                Write("\"></ASP_SMARTNAV_RDIR>");

                Write("</BODY>");
            }
            else {
                this.StatusCode = 302;
                _redirectLocation = url;
                Write("<html><head><title>Object moved</title></head><body>\r\n");
                Write("<h2>Object moved to <a href='" + HttpUtility.HtmlEncode(url) + "'>here</a>.</h2>\r\n");
                Write("</body></html>\r\n");
            }

            if (endResponse)
                End();
        }

        //
        // Redirect to error page appending ?aspxerrorpath if no query string in the url.
        // Fails to redirect if request is already for error page.
        // Suppresses all errors.
        // Returns true if redirect performed successfuly
        //
        internal bool RedirectToErrorPage(String url) {
            const String qsErrorMark = "aspxerrorpath";

            try {
                if (url == null)
                    return false;   // nowhere to redirect

                if (_headersWritten)
                    return false;

                if (Request.QueryString[qsErrorMark] != null)
                    return false;   // already in error redirect

                // append query string
                if (url.IndexOf('?') < 0)
                    url = url + "?" + qsErrorMark + "=" + Request.Path;

                // redirect without response.end
                Redirect(url, false /*endResponse*/);
            }
            catch (Exception) {
                return false;
            }

            return true;
        }

        //
        // Methods to write from file
        //

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.Write"]/*' />
        /// <devdoc>
        ///    <para>Writes values to an HTTP output content stream.</para>
        /// </devdoc>
        public void Write(String s) {
            _writer.Write(s);
        }

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.Write1"]/*' />
        /// <devdoc>
        ///    <para>Writes values to an HTTP output content stream.</para>
        /// </devdoc>
        public void Write(Object obj) {
            _writer.Write(obj);
        }

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.Write2"]/*' />
        /// <devdoc>
        ///    <para>Writes values to an HTTP output content stream.</para>
        /// </devdoc>
        public void Write(char ch) {
            _writer.Write(ch);
        }

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.Write3"]/*' />
        /// <devdoc>
        ///    <para>Writes values to an HTTP output content stream.</para>
        /// </devdoc>
        public void Write(char[] buffer, int index, int count) {
            _writer.Write(buffer, index, count);
        }


        /*
         * Helper method to write from file stream
         *
         * Handles only TextWriter case. For real requests
         * HttpWorkerRequest can take files
         */
        private void WriteFileInternal(FileStream f, long offset, long size) {
            if (size < 0)
                size = f.Length - offset;

            if (size > 0) {
                if (offset > 0)
                    f.Seek(offset, SeekOrigin.Begin);

                byte[] fileBytes = new byte[(int)size];            
                int bytesRead = f.Read(fileBytes, 0, (int)size);
                _writer.Write(Encoding.Default.GetChars(fileBytes, 0, bytesRead));
            }
        }

        /*
         * Helper method to get absolute physical filename from the argument to WriteFile
         */
        private String GetNormalizedFilename(String fn) {
            if (Request != null) {
                // can map if not absolute physical path
                if (!(fn.Length > 2 && (fn[0] == '\\' || fn[1] == ':')))
                    fn = Request.MapPath(fn);
            }

            return fn;
        }

        /*
         * Write file
         *
         * @param filename file to write
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.WriteFile"]/*' />
        /// <devdoc>
        ///    <para>Writes
        ///       a named file directly to an HTTP content output stream.</para>
        /// </devdoc>
        public void WriteFile(String filename) {
            WriteFile(filename, false);
        }

        /*
         * Write file
         *
         * @param filename file to write
         * @readIntoMemory flag to read contents into memory immediately
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.WriteFile1"]/*' />
        /// <devdoc>
        ///    <para> Reads a file into a memory block.</para>
        /// </devdoc>
        public void WriteFile(String filename, bool readIntoMemory) {
            filename = GetNormalizedFilename(filename);

            FileStream f = null;

            try {
                f = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read);

                if (UsingHttpWriter) {
                    long size = f.Length;

                    if (size > 0) {
                        if (readIntoMemory) {
                            // write as memory block
                            byte[] fileBytes = new byte[(int)size];
                            int bytesRead = f.Read(fileBytes, 0, (int) size);
                            _httpWriter.WriteBytes(fileBytes, 0, bytesRead);
                        }
                        else {
                            // write as file block
                            f.Close(); // close before writing
                            f = null;
                            _httpWriter.WriteFile(filename, 0, size);
                        }
                    }
                }
                else {
                    // Write file contents
                    WriteFileInternal(f, 0, -1);
                }
            }
            finally {
                if (f != null)
                    f.Close();
            }
        }

        private void ValidateFileRange(String filename, long offset, long length) {
            FileStream f = null;

            try {
                f = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read);

                long fileSize = f.Length;

                if (length == -1)
                    length = fileSize - offset;

                if (offset < 0 || length > fileSize - offset)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_range));
            }
            finally {
                if (f != null)
                    f.Close();
            }
        }

        /*
         * Write file
         *
         * @param filename file to write
         * @param offset file offset to start writing
         * @param size number of bytes to write
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.WriteFile2"]/*' />
        /// <devdoc>
        ///    <para>Writes a file directly to an HTTP content output stream.</para>
        /// </devdoc>
        public void WriteFile(String filename, long offset, long size) {
            if (size == 0)
                return;

            filename = GetNormalizedFilename(filename);

            ValidateFileRange(filename, offset, size);

            if (UsingHttpWriter) {
                // HttpWriter can take files -- don't open here (but Demand permission)
                InternalSecurityPermissions.FileReadAccess(filename).Demand();
                _httpWriter.WriteFile(filename, offset, size);
            }
            else {
                FileStream f = null;

                try {
                    f = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read);
                    WriteFileInternal(f, offset, size);
                }
                finally {
                    if (f != null)
                        f.Close();
                }
            }
        }

        /*
         * Write file
         *
         * @param handle file to write
         * @param offset file offset to start writing
         * @param size number of bytes to write
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.WriteFile3"]/*' />
        /// <devdoc>
        ///    <para>Writes a file directly to an HTTP content output stream.</para>
        /// </devdoc>
        public void WriteFile(IntPtr fileHandle, long offset, long size) {
            InternalSecurityPermissions.UnmanagedCode.Demand();

            if (size <= 0)
                return;

            FileStream f = null;

            try {
                f = new FileStream(fileHandle, FileAccess.Read, false);

                if (UsingHttpWriter) {
                    long fileSize = f.Length;

                    if (size == -1)
                        size = fileSize - offset;

                    if (offset < 0 || size > fileSize - offset)
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_range));

                    if (offset > 0)
                        f.Seek(offset, SeekOrigin.Begin);

                    // write as memory block
                    byte[] fileBytes = new byte[(int)size];
                    int bytesRead = f.Read(fileBytes, 0, (int)size);
                    _httpWriter.WriteBytes(fileBytes, 0, bytesRead);
                }
                else {
                    WriteFileInternal(f, offset, size);
                }
            }
            finally {
                if (f != null)
                    f.Close();
            }
        }

        //
        // Methods to support substitution blocks
        //

        /*
         * Write named substitution block
         */
        /*
        internal void WriteSubstBlock(String name, String defaultValue) {
            if (UsingHttpWriter) {
                // HttpWriter can take substitution blocks
                _httpWriter.WriteSubstBlock(name, defaultValue);
            }
            else {
                // text writer -- write as string
                _writer.Write(defaultValue);
            }
        }
        */

        /*
         * Check if the substitution block exists
         */
        /*
        internal bool HasSubstBlock(String name) {
            if (_httpWriter == null)
                return false;

            return(_httpWriter.FindSubstitutionBlock(name) >= 0);
        }
        */

        /*
         * Return array of substitution block names
         */
        /*
        internal String[] GetSubstBlockNames(String name) {
            if (_httpWriter == null)
                return null;

            return _httpWriter.GetSubstitutionBlockNames();
        }
        */

        /*
         * Make substitution -- user string instead of named substitution block
         */
        /*internal void MakeSubstitution(String substBlockName, String substString) {
            if (UsingHttpWriter) {
                // HttpWriter can take substitution blocks (last arg to indicate
                // the permission to change the content length)
                _httpWriter.MakeSubstitution(substBlockName, substString, (_contentLength == 0));
            }
            else {
                // can't do it for regular text writer
            }
        }
        */

        //
        // Deprecated ASP compatibility methods and properties
        //

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.Status"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Same as StatusDescription. Provided only for ASP compatibility.
        ///    </para>
        /// </devdoc>
        public string Status {
            get {
                return this.StatusCode.ToString(NumberFormatInfo.InvariantInfo) + " " + this.StatusDescription;
            }

            set {
                int code = 200;
                String descr = "OK";

                try {
                    int i = value.IndexOf(' ');
                    code = Int32.Parse(value.Substring(0, i));
                    descr = value.Substring(i+1);
                }
                catch (Exception) {
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_status_string));
                }

                this.StatusCode = code;
                this.StatusDescription = descr;
            }
        }

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.Buffer"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Same as BufferOutput. Provided only for ASP compatibility.
        ///    </para>
        /// </devdoc>
        public bool Buffer { 
            get { return this.BufferOutput;}
            set { this.BufferOutput = value;}
        }

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.AddHeader"]/*' />
        /// <devdoc>
        ///    <para>Same as Appendheader. Provided only for ASP compatibility.</para>
        /// </devdoc>
        public void AddHeader(String name, String value) {
            AppendHeader(name, value);
        }

        /*
         * Cancelles handler processing of the current request
         * throws special [non-]exception uncatchable by the user code
         * to tell application to stop module execution.
         */
        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.End"]/*' />
        /// <devdoc>
        ///    <para>Sends all currently buffered output to the client then closes the
        ///       socket connection.</para>
        /// </devdoc>
        public void End() {

            if (_context.IsInCancellablePeriod) {
                InternalSecurityPermissions.ControlThread.Assert();
                Thread.CurrentThread.Abort(new HttpApplication.CancelModuleException(false));
            }
            else {
                // when cannot abort execution, flush and supress further output
                Flush();
                _ended = true;
                _context.ApplicationInstance.CompleteRequest();
            }
        }

        /*
         * ASP compatible caching properties
         */

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.Expires"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the time, in minutes, until cached
        ///       information will be removed from the cache. Provided for ASP compatiblility. Use
        ///       the <see cref='System.Web.HttpResponse.Cache'/>
        ///       Property instead.
        ///    </para>
        /// </devdoc>
        public int Expires {
            get {
                return _expiresInMinutes;
            }
            set {
                if (!_expiresInMinutesSet || value < _expiresInMinutes) {
                    _expiresInMinutes = value;
                    Cache.SetExpires(_context.Timestamp + new TimeSpan(0, _expiresInMinutes, 0));
                }
            }
        }

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.ExpiresAbsolute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the absolute time that cached information
        ///       will be removed from the cache. Provided for ASP compatiblility. Use the <see cref='System.Web.HttpResponse.Cache'/>
        ///       property instead.
        ///    </para>
        /// </devdoc>
        public DateTime ExpiresAbsolute {
            get {
                return _expiresAbsolute;
            }
            set {
                if (!_expiresAbsoluteSet || value < _expiresAbsolute) {
                    _expiresAbsolute = value;
                    Cache.SetExpires(_expiresAbsolute);
                }
            }
        }

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.CacheControl"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provided for ASP compatiblility. Use the <see cref='System.Web.HttpResponse.Cache'/>
        ///       property instead.
        ///    </para>
        /// </devdoc>
        public string CacheControl {
            get {
                if (_cacheControl == null) {
                    // the default
                    return "private";
                }

                return _cacheControl;
            }
            set {
                if (value == null || value.Length == 0) {
                    _cacheControl = null;
                    Cache.SetCacheability(HttpCacheability.NoCache);
                }
                else if (String.Compare(value, "private", true, CultureInfo.InvariantCulture) == 0) {
                    _cacheControl = value;
                    Cache.SetCacheability(HttpCacheability.Private);
                }
                else if (String.Compare(value, "public", true, CultureInfo.InvariantCulture) == 0) {
                    _cacheControl = value;
                    Cache.SetCacheability(HttpCacheability.Public);
                }
                else if (String.Compare(value, "no-cache", true, CultureInfo.InvariantCulture) == 0) {
                    _cacheControl = value;
                    Cache.SetCacheability(HttpCacheability.NoCache);
                }
                else {
                    throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Invalid_value_for_CacheControl, value));
                }
            }
        }

        internal void SetAppPathModifier(string appPathModifier) {
            if (appPathModifier != null && (
                appPathModifier.Length == 0 || 
                appPathModifier[0] == '/' ||
                appPathModifier[appPathModifier.Length - 1] == '/')) {

                throw new ArgumentException(HttpRuntime.FormatResourceString(SR.InvalidArgumentValue, "appPathModifier"));
            }

            _appPathModifier = appPathModifier;
        }

        /// <include file='doc\HttpResponse.uex' path='docs/doc[@for="HttpResponse.ApplyAppPathModifier"]/*' />
        public string ApplyAppPathModifier(string virtualPath) {
            if (virtualPath == null)
                return null;

            if (UrlPath.IsRelativeUrl(virtualPath)) {
                virtualPath = UrlPath.Combine(Request.BaseDir, virtualPath);
            }
            else {
                // ignore paths with http://server/...
                if (!UrlPath.IsRooted(virtualPath)) {
                    return virtualPath;
                }

                virtualPath = UrlPath.Reduce(virtualPath);
            }

            if (_appPathModifier == null || virtualPath.IndexOf(_appPathModifier) >= 0)
                return virtualPath;

            // Compensate when application paths don't include trailing '/'
            string  appPath = Request.ApplicationPath;

            if (appPath[appPath.Length - 1] != '/') {
                appPath += "/";
            }

            int compareLength = appPath.Length;
            bool isVirtualPathShort = (virtualPath.Length == appPath.Length - 1);
            if (isVirtualPathShort) {
                compareLength--;
            }

            // String.Compare will throw exception if there aren't compareLength characters
            if (virtualPath.Length < compareLength) {
                return virtualPath;
            }

            if (String.Compare(virtualPath, 0, appPath, 0, compareLength, true, CultureInfo.InvariantCulture) != 0) {
                return virtualPath;
            }

            if (isVirtualPathShort) {
                virtualPath += "/";
            }

            Debug.Assert(virtualPath.Length >= appPath.Length);
            if (virtualPath.Length == appPath.Length) {
                virtualPath = virtualPath.Substring(0, appPath.Length) + _appPathModifier + "/";
            }
            else {
                virtualPath = 
                    virtualPath.Substring(0, appPath.Length) + 
                    _appPathModifier + 
                    "/" + 
                    virtualPath.Substring(appPath.Length);
            }

            return virtualPath;
        }

        internal String RemoveAppPathModifier(string virtualPath) {
            if (_appPathModifier == null || _appPathModifier.Length == 0)
                return virtualPath;

            int pos = virtualPath.IndexOf(_appPathModifier);

            if (pos <= 0 || virtualPath[pos-1] != '/')
                return virtualPath;

            return virtualPath.Substring(0, pos-1) + virtualPath.Substring(pos + _appPathModifier.Length);
        }

        private String ConvertToFullyQualifiedRedirectUrlIfRequired(String url) {
            
            HttpRuntimeConfig runtimeConfig = (HttpRuntimeConfig)_context.GetConfig("system.web/httpRuntime");

            if (runtimeConfig != null && runtimeConfig.UseFullyQualifiedRedirectUrl) {
                return (new Uri(Request.Url, url, true)).AbsoluteUri ;
            }
            else {
                return url;
            }
        }

        private String UrlEncodeRedirect(String url) {
            // convert all non-ASCII chars before ? to %XX using UTF-8 and
            // after ? using Response.ContentEncoding

            int iqs = url.IndexOf('?');

            if (iqs >= 0) {
                Encoding qsEncoding = (Request != null) ? Request.ContentEncoding : ContentEncoding;
                url = HttpUtility.UrlEncodeSpaces(HttpUtility.UrlEncodeNonAscii(url.Substring(0, iqs), Encoding.UTF8)) +
                      HttpUtility.UrlEncodeNonAscii(url.Substring(iqs), qsEncoding);
            }
            else {
                url = HttpUtility.UrlEncodeSpaces(HttpUtility.UrlEncodeNonAscii(url, Encoding.UTF8));
            }

            return url;
        }
    }

    class ResponseDependencyInfo {
        internal readonly string[]    items;
        internal readonly DateTime    utcDate;

        internal ResponseDependencyInfo(string[] items, DateTime utcDate) {
            this.items = items;
            this.utcDate = utcDate;
        }
    }

    struct ResponseDependencyList {
        internal ArrayList   _dependencies;
        internal string[]    _dependencyArray;

        internal void AddDependency(string item, string argname) {
            if (item == null) {
                throw new ArgumentNullException(argname);
            }
    
            _dependencyArray = null;
    
            if (_dependencies == null) {
                _dependencies = new ArrayList(1);
            }
    
            _dependencies.Add(new ResponseDependencyInfo(
                    new string[] {item}, DateTime.UtcNow));
        }

        internal void AddDependencies(ArrayList items, string argname) {
            if (items == null) {
                throw new ArgumentNullException(argname);
            }

            foreach (object o in items) {
                string item = o as string;
                if (item == null || item.Length == 0) {
                    throw new ArgumentNullException(argname);
                }
            }

            _dependencyArray = null;

            if (_dependencies == null) {
                _dependencies = new ArrayList(1);
            }
        
            string[] a = (string[]) items.ToArray(typeof(string));
            _dependencies.Add(new ResponseDependencyInfo(a, DateTime.UtcNow));
        }

        internal string[] GetDependencies() {
            if (_dependencyArray == null && _dependencies != null) {
                int size = 0;
                foreach (ResponseDependencyInfo info in _dependencies) {
                    size += info.items.Length;
                }

                _dependencyArray = new string[size];

                int index = 0;
                foreach (ResponseDependencyInfo info in _dependencies) {
                    int length = info.items.Length;
                    Array.Copy(info.items, 0, _dependencyArray, index, length);
                    index += length;
                }
            }

            return _dependencyArray;
        }

        internal CacheDependency GetCacheDependency(bool files, CacheDependency dependency) {
            if (_dependencies != null) {
                foreach (ResponseDependencyInfo info in _dependencies) {
                    CacheDependency dependencyOld = dependency;
                    if (files) {
                        dependency = new CacheDependency(false, info.items, null, dependencyOld, info.utcDate);
                    }
                    else {
                        // We create a "public" CacheDepdency here, since the keys are for
                        // public items.
                        dependency = new CacheDependency(null, info.items, dependencyOld, DateTimeUtil.ConvertToLocalTime(info.utcDate));
                    }

                    if (dependencyOld != null) {
                        dependencyOld.Dispose();
                    }
                }
            }

            return dependency;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpservervarscollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpServerVarsCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Collection of server variables with callback to HttpRequest for 'dynamic' ones
 * 
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web {
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters;
    using System.Text;

    using System.Collections;
    using System.Collections.Specialized;
    using System.Web.Util;
    using System.Globalization;
    
    internal class HttpServerVarsCollection : HttpValueCollection {
        private bool _populated;
        private HttpRequest _request;

        // We preallocate the base collection with a size that should be sufficient
        // to store all server variables w/o having to expand
        internal HttpServerVarsCollection(HttpRequest request) : base(59) {
            _request = request;
            _populated = false;
        }

        internal HttpServerVarsCollection(int capacity, HttpRequest request) : base(capacity) {
            _request = request;
            _populated = false;
        }

        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            // this class, while derived from class implementing ISerializable, is not serializable
            throw new SerializationException();
        }

        internal void Dispose() {
            _request = null;
        }

        internal void AddStatic(String name, String value) {
            if (value == null)
                value = String.Empty;

            InvalidateCachedArrays();
            BaseAdd(name, new HttpServerVarsCollectionEntry(name, value));
        }

        internal void AddDynamic(String name, DynamicServerVariable var) {
            InvalidateCachedArrays();
            BaseAdd(name, new HttpServerVarsCollectionEntry(name, var));
        }

        private String GetServerVar(Object e) {
            HttpServerVarsCollectionEntry entry = (HttpServerVarsCollectionEntry)e;
            return (entry != null) ? entry.GetValue(_request) : null;
        }

        //
        //  Support for deferred population of the collection
        //

        private void Populate() {
            if (!_populated) {
                if (_request != null) {
                    MakeReadWrite();
                    _request.FillInServerVariablesCollection();
                    MakeReadOnly();
                }
                _populated = true;
            }
        }

        private String GetSimpleServerVar(String name) {
            // get server var without population of the collection
            // only most popular are included

            if (name != null && name.Length > 1 && _request != null) {
                switch (name[0]) {
                    case 'A':
                    case 'a':
                        if (String.Compare(name, "AUTH_TYPE", true, CultureInfo.InvariantCulture) == 0)
                            return _request.CalcDynamicServerVariable(DynamicServerVariable.AUTH_TYPE);
                        else if (String.Compare(name, "AUTH_USER", true, CultureInfo.InvariantCulture) == 0)
                            return _request.CalcDynamicServerVariable(DynamicServerVariable.AUTH_USER);
                        break;
                    case 'H':
                    case 'h':
                        if (String.Compare(name, "HTTP_USER_AGENT", true, CultureInfo.InvariantCulture) == 0)
                            return _request.UserAgent;
                        break;
                    case 'Q':
                    case 'q':
                        if (String.Compare(name, "QUERY_STRING", true, CultureInfo.InvariantCulture) == 0)
                            return _request.QueryStringText;
                        break;
                    case 'P':
                    case 'p':
                        if (String.Compare(name, "PATH_INFO", true, CultureInfo.InvariantCulture) == 0)
                            return _request.Path;
                        else if (String.Compare(name, "PATH_TRANSLATED", true, CultureInfo.InvariantCulture) == 0)
                            return _request.PhysicalPath;
                        break;
                    case 'R':
                    case 'r':
                        if (String.Compare(name, "REQUEST_METHOD", true, CultureInfo.InvariantCulture) == 0)
                            return _request.HttpMethod;
                        else if (String.Compare(name, "REMOTE_USER", true, CultureInfo.InvariantCulture) == 0)
                            return _request.CalcDynamicServerVariable(DynamicServerVariable.AUTH_USER);
                        else if (String.Compare(name, "REMOTE_HOST", true, CultureInfo.InvariantCulture) == 0)
                            return _request.UserHostName;
                        else if (String.Compare(name, "REMOTE_ADDRESS", true, CultureInfo.InvariantCulture) == 0)
                            return _request.UserHostAddress;
                        break;
                    case 'S':
                    case 's':
                        if (String.Compare(name, "SCRIPT_NAME", true, CultureInfo.InvariantCulture) == 0)
                            return _request.FilePath;
                        break;
                }
            }

            // do the default processing (populate the collection)
            return null;
        }

        //
        //  NameValueCollection overrides
        //

        public override int Count {
            get {
                Populate();
                return base.Count;
            }
        }

        public override void Add(String name, String value) {
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_modify_server_vars));
        }

        public override String Get(String name) {
            if (!_populated) {
                String value = GetSimpleServerVar(name);

                if (value != null)
                    return value;

                Populate();
            }

            return GetServerVar(BaseGet(name));
        }

        public override String[] GetValues(String name) {
            String s = Get(name);
            return(s != null) ? new String[1] { s} : null;
        }

        public override void Set(String name, String value) {
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_modify_server_vars));
        }

        public override void Remove(String name) {
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_modify_server_vars));
        }

        public override String Get(int index)  {
            Populate();
            return GetServerVar(BaseGet(index));
        }

        public override String[] GetValues(int index) {
            String s = Get(index);
            return(s != null) ? new String[1] { s} : null;
        }

        public override String GetKey(int index) {
            Populate();
            return base.GetKey(index);
        }

        public override string[] AllKeys {
            get {
                Populate();
                return base.AllKeys;
            }
        }

        //
        //  HttpValueCollection overrides
        //

        internal override string ToString(bool urlencoded) {
            Populate();

            StringBuilder s = new StringBuilder();
            int n = Count;
            String key, value;

            for (int i = 0; i < n; i++) {
                if (i > 0)
                    s.Append('&');

                key = GetKey(i);
                if (urlencoded)
                    key = HttpUtility.UrlEncodeUnicode(key);
                s.Append(key);

                s.Append('=');

                value = Get(i);
                if (urlencoded)
                    value = HttpUtility.UrlEncodeUnicode(value);
                s.Append(value);
            }

            return s.ToString();
        }
    }

/*
 *  Entry in a server vars colleciton
 */
    internal class HttpServerVarsCollectionEntry {
        internal readonly String Name;
        internal readonly bool   IsDynamic;
        internal readonly String Value;
        internal readonly DynamicServerVariable Var;

        internal HttpServerVarsCollectionEntry(String name, String value) {
            Name = name;
            Value = value;
            IsDynamic = false;
        }

        internal HttpServerVarsCollectionEntry(String name, DynamicServerVariable var) {
            Name = name;
            Var = var;
            IsDynamic = true;
        }

        internal String GetValue(HttpRequest request) {
            String v = null;

            if (IsDynamic) {
                if (request != null)
                    v = request.CalcDynamicServerVariable(Var);
            }
            else {
                v = Value;
            }

            return v;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpapplication.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpApplication.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web {
    using System.Runtime.Serialization.Formatters;
    using System.IO;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Collections;
    using System.Reflection;
    using System.Globalization;
    using System.Security.Principal;
    using System.Web;
    using System.Web.SessionState;
    using System.Web.Security;
    using System.Web.UI;
    using System.Web.Util;
    using System.Web.Configuration;
    using System.Runtime.Remoting.Messaging;
    using System.Security.Permissions;

    //
    // Async EventHandler support
    //

    /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="BeginEventHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public delegate IAsyncResult BeginEventHandler(object sender, EventArgs e, AsyncCallback cb, object extraData);
    /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="EndEventHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public delegate void EndEventHandler(IAsyncResult ar);

    /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The  HttpApplication class defines the methods, properties and events common to all
    ///       HttpApplication objects within the ASP.NET Framework.
    ///    </para>
    /// </devdoc>
    [
    ToolboxItem(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HttpApplication : IHttpAsyncHandler, IComponent {
        // application state dictionary
        private HttpApplicationState _state;

        // context during init for config lookups
        private HttpContext _initContext;

        // async support
        private HttpAsyncResult _ar; // currently pending async result for call into application

        // list of modules
        private HttpModuleCollection  _moduleCollection;

        private IPrincipal _savedPrincipal;
        private bool       _restorePrincipal;

        // event handlers
        // private EventHandler _startAppEventHandler;
        // private EventHandler _endAppEventHandler;
        private static readonly object EventDisposed = new object();
        private static readonly object EventErrorRecorded = new object();
        private static readonly object EventPreSendRequestHeaders = new object();
        private static readonly object EventPreSendRequestContent = new object();
        private static readonly object EventBeginRequest = new object();
        private static readonly object EventAuthenticateRequest = new object();
        internal  static readonly object EventDefaultAuthentication = new object();  // internal event for back-stop auth
        private static readonly object EventAuthorizeRequest = new object();
        private static readonly object EventResolveRequestCache = new object();
        private static readonly object EventAcquireRequestState = new object();
        private static readonly object EventPreRequestHandlerExecute = new object();
        private static readonly object EventPostRequestHandlerExecute = new object();
        private static readonly object EventReleaseRequestState = new object();
        private static readonly object EventUpdateRequestCache = new object();
        private static readonly object EventEndRequest = new object();

        private EventHandlerList _events;

        // async event handlers

        private AsyncAppEventHandler _beginRequestEventHandlerAsync;
        private AsyncAppEventHandler _authenticateRequestEventHandlerAsync;
        private AsyncAppEventHandler _authorizeRequestEventHandlerAsync;
        private AsyncAppEventHandler _resolveRequestCacheEventHandlerAsync;
        private AsyncAppEventHandler _acquireRequestStateEventHandlerAsync;
        private AsyncAppEventHandler _preRequestHandlerExecuteEventHandlerAsync;
        private AsyncAppEventHandler _postRequestHandlerExecuteEventHandlerAsync;
        private AsyncAppEventHandler _releaseRequestStateEventHandlerAsync;
        private AsyncAppEventHandler _updateRequestCacheEventHandlerAsync;
        private AsyncAppEventHandler _endRequestEventHandlerAsync;

        // execution steps
        private IExecutionStep[] _execSteps;
        private int _endRequestStepIndex;

        // callback for ResumeSteps
        private WaitCallback _resumeStepsWaitCallback;

        // event passed to modules
        private EventArgs _appEvent;

        // list of handler mappings
        private Hashtable _handlerFactories = new Hashtable();

        // list of handler/factory pairs to be recycled
        private ArrayList _handlerRecycleList;

        // flag to hide request and response intrinsics
        private bool _hideRequestResponse;

        // application execution variables
        private HttpContext _context;
        private HttpContext _savedContext;
        private Exception _lastError;  // placeholder for the error when context not avail
        private int _currentStepIndex;
        private bool _requestCompleted;
        private int _numStepCalls;
        private int _numSyncStepCalls;

        // session (supplied by session-on-end outside of context)
        private HttpSessionState _session;

        // culture (needs to be set per thread)
        private CultureInfo _appLevelCulture;
        private CultureInfo _appLevelUICulture;
        private CultureInfo _savedCulture;
        private CultureInfo _savedUICulture;

        // IComponent support
        private ISite _site;

        //
        // Public Application properties
        //

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.Context"]/*' />
        /// <devdoc>
        ///    <para>
        ///          HTTPRuntime provided context object that provides access to additional
        ///          pipeline-module exposed objects.
        ///       </para>
        ///    </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public HttpContext Context {
            get { 
                return(_context != null) ? _context : _initContext; 
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.Disposed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler Disposed {
            add {
                Events.AddHandler(EventDisposed, value);
            }

            remove {
                Events.RemoveHandler(EventDisposed, value);
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.Events"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected EventHandlerList Events {
            get {
                if (_events == null) {
                    _events = new EventHandlerList();
                }
                return _events;
            }
        }

        // Last error during the processing of the current request.
        internal Exception LastError {
            get { 
                // only temporaraly public (will be internal and not related context)
                return (_context != null) ? _context.Error : _lastError;
            }

        }

        internal void ClearError() {
            _lastError = null;
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.Request"]/*' />
        /// <devdoc>
        ///    <para>HTTPRuntime provided request intrinsic object that provides access to incoming HTTP
        ///       request data.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public HttpRequest Request {
            get { 
                HttpRequest request = null;

                if (_context != null && !_hideRequestResponse)
                    request = _context.Request;

                if (request == null)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Request_not_available));

                return request;
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.Response"]/*' />
        /// <devdoc>
        ///    <para>HTTPRuntime provided 
        ///       response intrinsic object that allows transmission of HTTP response data to a
        ///       client.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public HttpResponse Response {
            get { 
                HttpResponse response = null;

                if (_context != null && !_hideRequestResponse)
                    response = _context.Response;

                if (response == null)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Response_not_available));

                return response;
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.Session"]/*' />
        /// <devdoc>
        ///    <para>
        ///    HTTPRuntime provided session intrinsic.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public HttpSessionState Session {
            get {
                HttpSessionState session = null;

                if (_session != null)
                    session = _session;
                else if (_context != null)
                    session = _context.Session;

                if (session == null)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Session_not_available));

                return session;
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.Application"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns 
        ///          a reference to an HTTPApplication state bag instance.
        ///       </para>
        ///    </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public HttpApplicationState Application {
            get {
                Debug.Assert(_state != null);  // app state always available
                return _state; 
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.Server"]/*' />
        /// <devdoc>
        ///    <para>Provides the web server Intrinsic object.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public HttpServerUtility Server {
            get {
                if (_context != null)
                    return _context.Server;
                else
                    return new HttpServerUtility(this); // special Server for application only
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.User"]/*' />
        /// <devdoc>
        ///    <para>Provides the User Intrinsic object.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public IPrincipal User {
            get {
                if (_context == null)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.User_not_available));

                return _context.User; 
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.Modules"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Collection 
        ///          of all IHTTPModules configured for the current application.
        ///       </para>
        ///    </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public HttpModuleCollection Modules {
            get { 
                InternalSecurityPermissions.AspNetHostingPermissionLevelHigh.Demand();

                if (_moduleCollection == null)
                    _moduleCollection = new HttpModuleCollection();
                return _moduleCollection; 
            }
        }

        // event passed to all modules
        internal EventArgs AppEvent {
            get {
                if (_appEvent == null)
                    _appEvent = EventArgs.Empty;

                return _appEvent;
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.AcquireRequestState"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler AcquireRequestState {
            add {
                Events.AddHandler(EventAcquireRequestState, value);
            }
            remove {
                Events.RemoveHandler(EventAcquireRequestState, value);
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.AuthenticateRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler AuthenticateRequest {
            add {
                Events.AddHandler(EventAuthenticateRequest, value);
            }
            remove {
                Events.RemoveHandler(EventAuthenticateRequest, value);
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.AuthorizeRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler AuthorizeRequest {
            add {
                Events.AddHandler(EventAuthorizeRequest, value);
            }
            remove {
                Events.RemoveHandler(EventAuthorizeRequest, value);
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.BeginRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler BeginRequest {
            add {
                Events.AddHandler(EventBeginRequest, value);
            }
            remove {
                Events.RemoveHandler(EventBeginRequest, value);
            }
        }

        // internal - for back-stop module only
        internal event EventHandler DefaultAuthentication {
            add {
                Events.AddHandler(EventDefaultAuthentication, value);
            }
            remove {
                Events.RemoveHandler(EventDefaultAuthentication, value);
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.EndRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler EndRequest {
            add {
                Events.AddHandler(EventEndRequest, value);
            }
            remove {
                Events.RemoveHandler(EventEndRequest, value);
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.Error"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler Error {
            add {
                Events.AddHandler(EventErrorRecorded, value);
            }
            remove {
                Events.RemoveHandler(EventErrorRecorded, value);
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.PreSendRequestHeaders"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler PreSendRequestHeaders {
            add {
                Events.AddHandler(EventPreSendRequestHeaders, value);
            }
            remove {
                Events.RemoveHandler(EventPreSendRequestHeaders, value);
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.PreSendRequestContent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler PreSendRequestContent {
            add {
                Events.AddHandler(EventPreSendRequestContent, value);
            }
            remove {
                Events.RemoveHandler(EventPreSendRequestContent, value);
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.PreRequestHandlerExecute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler PreRequestHandlerExecute {
            add {
                Events.AddHandler(EventPreRequestHandlerExecute, value);
            }
            remove {
                Events.RemoveHandler(EventPreRequestHandlerExecute, value);
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.PostRequestHandlerExecute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler PostRequestHandlerExecute {
            add {
                Events.AddHandler(EventPostRequestHandlerExecute, value);
            }
            remove {
                Events.RemoveHandler(EventPostRequestHandlerExecute, value);
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.ReleaseRequestState"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler ReleaseRequestState {
            add {
                Events.AddHandler(EventReleaseRequestState, value);
            }
            remove {
                Events.RemoveHandler(EventReleaseRequestState, value);
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.ResolveRequestCache"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler ResolveRequestCache {
            add {
                Events.AddHandler(EventResolveRequestCache, value);
            }
            remove {
                Events.RemoveHandler(EventResolveRequestCache, value);
            }
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.UpdateRequestCache"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler UpdateRequestCache {
            add {
                Events.AddHandler(EventUpdateRequestCache, value);
            }
            remove {
                Events.RemoveHandler(EventUpdateRequestCache, value);
            }
        }


        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.CompleteRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CompleteRequest() {
            //
            // Request completion (force skipping all steps until RequestEnd
            //
            _requestCompleted = true;
        }

        private void RaiseOnError() {
            EventHandler handler = (EventHandler)Events[EventErrorRecorded];
            if (handler != null) {
                try {
                    handler(this, AppEvent);
                }
                catch (Exception e) {
                    if (_context != null) {
                        _context.AddError(e);
                    }
                }
            }
        }

        internal void RaiseOnPreSendRequestHeaders() {
            EventHandler handler = (EventHandler)Events[EventPreSendRequestHeaders];
            if (handler != null) {
                try {
                    handler(this, AppEvent);
                }
                catch (Exception e) {
                    RecordError(e);
                }
            }
        }

        internal void RaiseOnPreSendRequestContent() {
            EventHandler handler = (EventHandler)Events[EventPreSendRequestContent];
            if (handler != null) {
                try {
                    handler(this, AppEvent);
                }
                catch (Exception e) {
                    RecordError(e);
                }
            }
        }

        //
        // Async event hookup
        //

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.AddOnBeginRequestAsync"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddOnBeginRequestAsync(BeginEventHandler bh, EndEventHandler eh) {
            if (_beginRequestEventHandlerAsync == null)
                _beginRequestEventHandlerAsync = new AsyncAppEventHandler();
            _beginRequestEventHandlerAsync.Add(bh, eh);
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.AddOnAuthenticateRequestAsync"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddOnAuthenticateRequestAsync(BeginEventHandler bh, EndEventHandler eh) {
            if (_authenticateRequestEventHandlerAsync == null)
                _authenticateRequestEventHandlerAsync = new AsyncAppEventHandler();
            _authenticateRequestEventHandlerAsync.Add(bh, eh);
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.AddOnAuthorizeRequestAsync"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddOnAuthorizeRequestAsync(BeginEventHandler bh, EndEventHandler eh) {
            if (_authorizeRequestEventHandlerAsync == null)
                _authorizeRequestEventHandlerAsync = new AsyncAppEventHandler();
            _authorizeRequestEventHandlerAsync.Add(bh, eh);
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.AddOnResolveRequestCacheAsync"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddOnResolveRequestCacheAsync(BeginEventHandler bh, EndEventHandler eh) {
            if (_resolveRequestCacheEventHandlerAsync == null)
                _resolveRequestCacheEventHandlerAsync = new AsyncAppEventHandler();
            _resolveRequestCacheEventHandlerAsync.Add(bh, eh);
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.AddOnAcquireRequestStateAsync"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddOnAcquireRequestStateAsync(BeginEventHandler bh, EndEventHandler eh) {
            if (_acquireRequestStateEventHandlerAsync == null)
                _acquireRequestStateEventHandlerAsync = new AsyncAppEventHandler();
            _acquireRequestStateEventHandlerAsync.Add(bh, eh);
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.AddOnPreRequestHandlerExecuteAsync"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddOnPreRequestHandlerExecuteAsync(BeginEventHandler bh, EndEventHandler eh) {
            if (_preRequestHandlerExecuteEventHandlerAsync == null)
                _preRequestHandlerExecuteEventHandlerAsync = new AsyncAppEventHandler();
            _preRequestHandlerExecuteEventHandlerAsync.Add(bh, eh);
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.AddOnPostRequestHandlerExecuteAsync"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddOnPostRequestHandlerExecuteAsync(BeginEventHandler bh, EndEventHandler eh) {
            if (_postRequestHandlerExecuteEventHandlerAsync == null)
                _postRequestHandlerExecuteEventHandlerAsync = new AsyncAppEventHandler();
            _postRequestHandlerExecuteEventHandlerAsync.Add(bh, eh);
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.AddOnReleaseRequestStateAsync"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddOnReleaseRequestStateAsync(BeginEventHandler bh, EndEventHandler eh) {
            if (_releaseRequestStateEventHandlerAsync == null)
                _releaseRequestStateEventHandlerAsync = new AsyncAppEventHandler();
            _releaseRequestStateEventHandlerAsync.Add(bh, eh);
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.AddOnUpdateRequestCacheAsync"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddOnUpdateRequestCacheAsync(BeginEventHandler bh, EndEventHandler eh) {
            if (_updateRequestCacheEventHandlerAsync == null)
                _updateRequestCacheEventHandlerAsync = new AsyncAppEventHandler();
            _updateRequestCacheEventHandlerAsync.Add(bh, eh);
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.AddOnEndRequestAsync"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddOnEndRequestAsync(BeginEventHandler bh, EndEventHandler eh) {
            if (_endRequestEventHandlerAsync == null)
                _endRequestEventHandlerAsync = new AsyncAppEventHandler();
            _endRequestEventHandlerAsync.Add(bh, eh);
        }

        //
        // Public Application virtual methods
        //

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.Init"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Used 
        ///          to initialize a HttpModule?s instance variables, and to wireup event handlers to
        ///          the hosting HttpApplication.
        ///       </para>
        ///    </devdoc>
        public virtual void Init() {
            // derived class implements this
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.Dispose"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Used 
        ///          to clean up an HttpModule?s instance variables
        ///       </para>
        ///    </devdoc>
        public virtual void Dispose() {
            // also part of IComponent
            // derived class implements this
            _site = null;
            
            EventHandler handler = (EventHandler)Events[EventDisposed];
            if (handler != null)
                handler(this, EventArgs.Empty);
        }

        private HandlerMapping GetHandlerMapping(HttpContext context, String requestType, String path) {
            // get correct config for path

            HttpConfigurationRecord record = context.GetCompleteConfig(path);

            // grab mapping from cache - verify that the verb matches exactly

            HandlerMappingMemo memo = (HandlerMappingMemo)record.CachedHandler;

            if (memo != null && !memo.IsMatch(requestType))
                memo = null;

            if (memo == null) {
                // Find matching mapping

                HandlerMapping mapping = null;

                {
                    HandlerMap map = (HandlerMap)record["system.web/httpHandlers"];

                    if (map != null)
                        mapping = map.FindMapping(requestType, path);
                }

                if (mapping == null && path != null && path.Length > 0 && path[0] == '/') {
                    String pathdir = UrlPath.GetDirectory(path);
                    HandlerMap map = (HandlerMap)context.GetConfig("system.web/httpHandlers", pathdir);

                    if (map != null)
                        mapping = map.FindMapping(requestType, path);
                }

                if (mapping == null) {
                    HandlerMap map = (HandlerMap)record["system.web/httphandlerfactories"];

                    if (map != null)
                        mapping = map.FindMapping(requestType, path);
                }

                memo = new HandlerMappingMemo(mapping, requestType);

                record.CachedHandler = memo;
            }

            return memo.Mapping;
        }

        private HandlerMapping GetAppLevelHandlerMapping(HttpContext context, String requestType, String path) {
            HandlerMapping mapping = null;

            HandlerMap map = (HandlerMap)HttpContext.GetAppConfig("system.web/httpHandlers");

            if (map != null)
                mapping = map.FindMapping(requestType, path);

            if (mapping == null) {
                map = (HandlerMap)HttpContext.GetAppConfig("system.web/httphandlerfactories");

                if (map != null)
                    mapping = map.FindMapping(requestType, path);
            }

            return mapping;
        }

        internal IHttpHandler MapHttpHandler(HttpContext context, String requestType, String path, String pathTranslated, bool useAppConfig) {
            IHttpHandler handler = null;

            // Suspend client impersonation (for compilation)
            HttpContext.ImpersonationSuspendContext ictx = context.Impersonation.SuspendIfClient();

            try {
                try {
                    HandlerMapping mapping;

                    if (useAppConfig) {
                        mapping = GetAppLevelHandlerMapping(context, requestType, path);
                    }
                    else {
                        mapping = GetHandlerMapping(context, requestType, path);
                    }

                    // If a page developer has removed the default mappings with <httpHandlers><clear>
                    // without replacing them then we need to give a more descriptive error than
                    // a null parameter exception.
                    if (mapping == null) {
                        PerfCounters.IncrementCounter(AppPerfCounter.REQUESTS_NOT_FOUND);
                        PerfCounters.IncrementCounter(AppPerfCounter.REQUESTS_FAILED);
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Http_handler_not_found_for_request_type, requestType));
                    }

                    // Get factory from the mapping
                    IHttpHandlerFactory factory = GetFactory(mapping);

                    try {
                        handler = factory.GetHandler(context, requestType, path, pathTranslated);
                    }
                    catch (FileNotFoundException e) {
                        if (HttpRuntime.HasPathDiscoveryPermission(pathTranslated))
                            throw new HttpException(404, null, e);
                        else
                            throw new HttpException(404, null);
                    }
                    catch (DirectoryNotFoundException e) {
                        if (HttpRuntime.HasPathDiscoveryPermission(pathTranslated))
                            throw new HttpException(404, null, e);
                        else
                            throw new HttpException(404, null);
                    }
                    catch (PathTooLongException e) {
                        if (HttpRuntime.HasPathDiscoveryPermission(pathTranslated))
                            throw new HttpException(414, null, e);
                        else
                            throw new HttpException(414, null);
                    }

                    // Remember for recycling
                    if (_handlerRecycleList == null)
                        _handlerRecycleList = new ArrayList();
                    _handlerRecycleList.Add(new HandlerWithFactory(handler, factory));
                }
                finally {
                    // Resume client impersonation
                    ictx.Resume();
                }
            }
            catch { // Protect against exception filters
                throw;
            }

            return handler;
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.GetVaryByCustomString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual string GetVaryByCustomString(HttpContext context, string custom) {
            if (custom.ToLower(CultureInfo.InvariantCulture) == "browser") {
                return context.Request.Browser.Type;
            }

            return null;
        }

        //
        // IComponent implementation
        //

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.Site"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public ISite Site { 
            get { return _site;} 
            set { _site = value;} 
        }

        //
        // IHttpAsyncHandler implementation
        //

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.IHttpAsyncHandler.BeginProcessRequest"]/*' />
        /// <internalonly/>
        IAsyncResult IHttpAsyncHandler.BeginProcessRequest(HttpContext context, AsyncCallback cb, Object extraData) {
            HttpAsyncResult result;

            // Setup the asynchronous stuff and application variables
            _context = context;
            _context.ApplicationInstance = this;
            _requestCompleted   = false;
            _currentStepIndex   = -1;
            _numStepCalls       = 0;
            _numSyncStepCalls   = 0;

            // Make sure the context stays rooted (including all async operations)
            _context.Root();

            // Create the async result
            result = new HttpAsyncResult(cb, extraData);

            // Remember the async result for use in async completions
            _ar = result;

            if (_context.TraceIsEnabled)
                HttpRuntime.Profile.StartRequest(_context);

            // Start the application
            ResumeSteps(null);

            // Return the async result
            return result;
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.IHttpAsyncHandler.EndProcessRequest"]/*' />
        /// <internalonly/>
        void IHttpAsyncHandler.EndProcessRequest(IAsyncResult result) {
            // throw error caught during execution
            HttpAsyncResult ar = (HttpAsyncResult)result;
            if (ar.Error != null)
                throw ar.Error;
        }

        //
        // IHttpHandler implementation
        //

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.IHttpHandler.ProcessRequest"]/*' />
        /// <internalonly/>
        void IHttpHandler.ProcessRequest(HttpContext context) {
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Sync_not_supported));
        }

        /// <include file='doc\HttpApplication.uex' path='docs/doc[@for="HttpApplication.IHttpHandler.IsReusable"]/*' />
        /// <internalonly/>
        bool IHttpHandler.IsReusable {
            get { return true; }
        }

        //
        // Support for external calls into the application like app_onStart
        //

        internal void ProcessSpecialRequest(HttpContext context, 
                                            MethodInfo method, 
                                            int paramCount,
                                            Object eventSource,
                                            EventArgs eventArgs,
                                            HttpSessionState session) {
            _context = context;
            _hideRequestResponse = true;
            _session = session;
            _lastError = null;

            using (new HttpContextWrapper(context)) {

                // setup impersonation
                HttpContext.ImpersonationData impersonation;

                if (_context != null)
                    impersonation = context.Impersonation;
                else
                    impersonation = HttpContext.GetAppLevelImpersonation();

                impersonation.Start(true /*forGlobalCode*/, false /*throwOnError*/);

                // set culture on the current thread
                SetCulture(true);

                try {
                    try {
                        if (paramCount == 0) {
                            method.Invoke(this, new Object[0]);
                        }
                        else {
                            Debug.Assert(paramCount == 2);

                            method.Invoke(this, new Object[2] { eventSource, eventArgs} );
                        }
                    }
                    catch (Exception e) {
                        // dereference reflection invocation exceptions
                        Exception eActual;
                        if (e is TargetInvocationException)
                            eActual = e.InnerException;
                        else
                            eActual = e;

                        RecordError(eActual);
                    }
                    finally {

                        // this thread should not be locking app state
                        if (_state != null)
                            _state.EnsureUnLock();

                        // unimpersonate
                        impersonation.Stop();

                        // restore culture
                        RestoreCulture();

                        _hideRequestResponse = false;
                        _context = null;
                        _session = null;
                        _lastError = null;
                        _appEvent = null;
                    }
                }
                catch { // Protect against exception filters
                }

            }
        }

        //
        // Report context-less error
        //

        internal void RaiseErrorWithoutContext(Exception error) {
            try {
                try {
                    SetCulture(true);
                    _lastError = error;

                    RaiseOnError();
                }
                finally {
                    // this thread should not be locking app state
                    if (_state != null)
                        _state.EnsureUnLock();

                    RestoreCulture();
                    _lastError = null;
                    _appEvent = null;
                }
            }
            catch { // Protect against exception filters
                throw;
            }
        }

        //
        //
        //

        internal void InitInternal(HttpContext context, HttpApplicationState state, MethodInfo[] handlers) {
            // Remember state
            _state = state;

            Debug.Assert(context != null);

            PerfCounters.IncrementCounter(AppPerfCounter.PIPELINES);

            // Remember context for config lookups
            _initContext = context;
            _initContext.ApplicationInstance = this;

            try {
                try {
                    // Set config path to be application path for the application initialization
                    context.ConfigPath = context.Request.ApplicationPath;

                    // keep HttpContext.Current working while running user code
                    using (new HttpContextWrapper(context)) {
                        // Build module list from config
                        InitModules();

                        // Hookup event handlers via reflection
                        if (handlers != null)
                            HookupEventHandlersForAppplicationAndModules(handlers);

                        // Initialization of the derived class
                        _context = context;
                        _hideRequestResponse = true;

                        try {
                            Init();
                        }
                        catch (Exception e) {
                            RecordError(e);
                        }
                    }

                    _hideRequestResponse = false;
                    _context = null;

                    // Construct the execution steps array

                    ArrayList steps = new ArrayList();

                    CreateAsyncEventExecutionSteps(_beginRequestEventHandlerAsync, steps);

                    CreateSyncEventExecutionSteps(EventBeginRequest, steps);

                    CreateAsyncEventExecutionSteps(_authenticateRequestEventHandlerAsync, steps);

                    CreateSyncEventExecutionSteps(EventAuthenticateRequest, steps);

                    steps.Add(new SyncEventExecutionStep(this, (EventHandler)Events[EventDefaultAuthentication])); // back-stop

                    CreateAsyncEventExecutionSteps(_authorizeRequestEventHandlerAsync, steps);

                    CreateSyncEventExecutionSteps(EventAuthorizeRequest, steps);

                    CreateAsyncEventExecutionSteps(_resolveRequestCacheEventHandlerAsync, steps);

                    CreateSyncEventExecutionSteps(EventResolveRequestCache, steps);

                    steps.Add(new MapHandlerExecutionStep(this));     // map handler

                    CreateAsyncEventExecutionSteps(_acquireRequestStateEventHandlerAsync, steps);

                    CreateSyncEventExecutionSteps(EventAcquireRequestState, steps);

                    CreateAsyncEventExecutionSteps(_preRequestHandlerExecuteEventHandlerAsync, steps);

                    CreateSyncEventExecutionSteps(EventPreRequestHandlerExecute, steps);

                    steps.Add(new CallHandlerExecutionStep(this));  // execute handler

                    CreateAsyncEventExecutionSteps(_postRequestHandlerExecuteEventHandlerAsync, steps);

                    CreateSyncEventExecutionSteps(EventPostRequestHandlerExecute, steps);

                    CreateAsyncEventExecutionSteps(_releaseRequestStateEventHandlerAsync, steps);

                    CreateSyncEventExecutionSteps(EventReleaseRequestState, steps);

                    steps.Add(new CallFilterExecutionStep(this));  // filtering

                    CreateAsyncEventExecutionSteps(_updateRequestCacheEventHandlerAsync, steps);

                    CreateSyncEventExecutionSteps(EventUpdateRequestCache, steps);

                    _endRequestStepIndex = steps.Count;

                    CreateAsyncEventExecutionSteps(_endRequestEventHandlerAsync, steps);

                    CreateSyncEventExecutionSteps(EventEndRequest, steps);

                    steps.Add(new SyncEventExecutionStep(this, null)); // the last is always there

                    _execSteps = new IExecutionStep[steps.Count];
                    steps.CopyTo(_execSteps);

                    // callback for async completion when reposting to threadpool thread
                    _resumeStepsWaitCallback = new WaitCallback(this.ResumeStepsWaitCallback);
                }
                finally {
                    // Reset config path
                    context.ConfigPath = null;

                    // don't hold on to the context
                    _initContext.ApplicationInstance = null;
                    _initContext = null;
                }
            }
            catch { // Protect against exception filters
                throw;
            }
        }

        // helper to expand an event handler into application steps
        private void CreateSyncEventExecutionSteps(Object eventIndex, ArrayList steps) {
            EventHandler handler = (EventHandler)Events[eventIndex];

            if (handler != null) {
                Delegate[] handlers = handler.GetInvocationList();

                for (int i = 0; i < handlers.Length; i++) 
                    steps.Add(new SyncEventExecutionStep(this, (EventHandler)handlers[i]));
            }
        }

        // helper to expand an async event handler into application steps
        private void CreateAsyncEventExecutionSteps(AsyncAppEventHandler handler, ArrayList steps) {
            if (handler != null)
                handler.CreateExecutionSteps(this, steps);
        }

        internal void InitSpecial(HttpApplicationState state, MethodInfo[] handlers) {
            // Remember state
            _state = state;

            // Hookup event handlers via reflection
            if (handlers != null)
                HookupEventHandlersForAppplicationAndModules(handlers);
        }

        internal void DisposeInternal() {
            PerfCounters.DecrementCounter(AppPerfCounter.PIPELINES);

            // call derived class

            try {
                Dispose();
            }
            catch (Exception e) {
                RecordError(e);
            }

            // dispose modules

            if (_moduleCollection != null) {
                int numModules = _moduleCollection.Count;

                for (int i = 0; i < numModules; i++) {
                    try {
                        _moduleCollection[i].Dispose();
                    }
                    catch {
                    }
                }

                _moduleCollection = null;
            }
        }

        private void HookupEventHandlersForAppplicationAndModules(MethodInfo[] handlers) {
            for (int i = 0; i < handlers.Length; i++) {
                MethodInfo appMethod = handlers[i];
                String appMethodName = appMethod.Name;
                int namePosIndex = appMethodName.IndexOf('_');
                String targetName = appMethodName.Substring(0, namePosIndex);

                // Find target for method
                Object target = null;

                if (String.Compare(targetName, "Application", true, CultureInfo.InvariantCulture) == 0)
                    target = this;
                else if (_moduleCollection != null)
                    target = _moduleCollection[targetName];

                if (target == null)
                    continue;

                // Find event on the module type
                Type targetType = target.GetType();
                EventDescriptorCollection events = TypeDescriptor.GetEvents(targetType);
                string eventName = appMethodName.Substring(namePosIndex+1);

                EventDescriptor foundEvent = events.Find(eventName, true);
                if (foundEvent == null 
                    && string.Compare(eventName.Substring(0, 2), "on", true, CultureInfo.InvariantCulture) == 0) {

                    eventName = eventName.Substring(2);
                    foundEvent = events.Find(eventName, true);
                }

                MethodInfo addMethod = null;
                if (foundEvent != null) {
                    EventInfo reflectionEvent = targetType.GetEvent(foundEvent.Name);
                    Debug.Assert(reflectionEvent != null);
                    if (reflectionEvent != null) {
                        addMethod = reflectionEvent.GetAddMethod();
                    }
                }

                if (addMethod == null)
                    continue;

                ParameterInfo[] addMethodParams = addMethod.GetParameters();

                if (addMethodParams.Length != 1)
                    continue;

                // Create the delegate from app method to pass to AddXXX(handler) method

                Delegate handlerDelegate = null;

                ParameterInfo[] appMethodParams = appMethod.GetParameters();

                if (appMethodParams.Length == 0) {
                    // If the app method doesn't have arguments --
                    // -- hookup via intermidiate handler

                    // only can do it for EventHandler, not strongly typed
                    if (addMethodParams[0].ParameterType != typeof(System.EventHandler))
                        continue;

                    ArglessEventHandlerProxy proxy = new ArglessEventHandlerProxy(this, appMethod);
                    handlerDelegate = proxy.Handler;
                }
                else {
                    // Hookup directly to the app methods hoping all types match

                    try {
                        handlerDelegate = Delegate.CreateDelegate(addMethodParams[0].ParameterType, this, appMethodName);
                    }
                    catch (Exception) {
                        // some type mismatch
                        continue;
                    }
                }

                // Call the AddXXX() to hook up the delegate

                try {
                    addMethod.Invoke(target, new Object[1]{handlerDelegate});
                }
                catch (Exception) {
                }
            }
        }

        //
        // Application execution logic
        //

        private void SetCulture(bool useAppCulture) {
            CultureInfo culture = null;
            CultureInfo uiculture = null;

            if (useAppCulture) {
                culture = _appLevelCulture;
                uiculture = _appLevelUICulture;
            }
            else {
                GlobalizationConfig globConfig = (GlobalizationConfig)_context.GetConfig("system.web/globalization");
                if (globConfig != null) {
                    culture = globConfig.Culture;
                    uiculture =  globConfig.UICulture;
                }

                if (_context != null) {
                    if (_context.DynamicCulture != null)
                        culture = _context.DynamicCulture;
                    if (_context.DynamicUICulture != null)
                        uiculture = _context.DynamicUICulture;
                }
            }

            _savedCulture = Thread.CurrentThread.CurrentCulture;
            _savedUICulture = Thread.CurrentThread.CurrentUICulture;

            if (culture != null)
                Thread.CurrentThread.CurrentCulture = culture;

            if (uiculture != null)
                Thread.CurrentThread.CurrentUICulture = uiculture;
        }

        private void RestoreCulture() {
            CultureInfo currentCulture = Thread.CurrentThread.CurrentCulture;
            CultureInfo currentUICulture = Thread.CurrentThread.CurrentUICulture;

            if (_context != null) {
                // remember changed culture for the rest of the request
                if (currentCulture != _savedCulture)
                    _context.DynamicCulture = currentCulture;
                if (currentUICulture != _savedUICulture)
                    _context.DynamicUICulture = currentUICulture;
            }

            if (_savedCulture != null) {
                Thread.CurrentThread.CurrentCulture = _savedCulture;
                _savedCulture = null;
            }

            if (_savedUICulture != null) {
                Thread.CurrentThread.CurrentUICulture = _savedUICulture;
                _savedUICulture = null;
            }
        }

        internal void SetPrincipalOnThread(IPrincipal principal) {
            if (!_restorePrincipal) {
                _restorePrincipal = true;
                _savedPrincipal = Thread.CurrentPrincipal;
            }

            Thread.CurrentPrincipal = principal;
        }

        private void RestorePrincipalOnThread() {
            if (_restorePrincipal) {
                Thread.CurrentPrincipal = _savedPrincipal;
                _savedPrincipal = null;
                _restorePrincipal = false;
            }
        }

        /*
         * Code to run when entering thread
         */
        internal void OnThreadEnter() {
            Debug.Assert(_context != null); // only to be used when context is available

            // attach http context to the call context
            _savedContext = HttpContextWrapper.SwitchContext(_context);

            // set impersonation on the current thread
            _context.Impersonation.Start(false, true);

            // add request to the timeout manager
            HttpRuntime.RequestTimeoutManager.Add(_context);

            // set principal on the current thread
            SetPrincipalOnThread(_context.User);

            // set culture on the current thread
            SetCulture(false);
        }

        /*
         * Code to run when leaving thread
         */
        internal void OnThreadLeave() {
            Debug.Assert(_context != null); // only to be used when context is available

            // this thread should not be locking app state
            if (_state != null)
                _state.EnsureUnLock();

            // restore culture
            RestoreCulture();

            // restore thread principal
            RestorePrincipalOnThread();

            // stop impersonation
            _context.Impersonation.Stop();

            // remove http context from the call context
            HttpContextWrapper.SwitchContext(_savedContext);
            _savedContext = null;

            // remove request from the timeout manager
            HttpRuntime.RequestTimeoutManager.Remove(_context);
        }

        /*
         * Execute single step catching exceptions in a fancy way (see below)
         */
        internal Exception ExecuteStep(IExecutionStep step, ref bool completedSynchronously) {
            Exception error = null;

            try {
                try {
                    if (step.IsCancellable) {
                        _context.BeginCancellablePeriod();  // request can be cancelled from this point

                        try {
                            step.Execute();
                        }
                        finally {
                            _context.EndCancellablePeriod();  // request can be cancelled until this point
                        }

                        _context.WaitForExceptionIfCancelled();  // wait outside of finally
                    }
                    else {
                        step.Execute();
                    }

                    if (!step.CompletedSynchronously) {
                        completedSynchronously = false;
                        return null;
                    }
                }
                catch (Exception e) {
                    error = e;
                    // This might force ThreadAbortException to be thrown
                    // automatically, because we consumed an exception that was
                    // hiding ThreadAbortException behind it
                }
                catch {
                    // ignore non-Exception objects that could be thrown
                }
            }
            catch (ThreadAbortException e) {
                // ThreadAbortException could be masked as another one
                // the try-catch above consumes all exceptions, only
                // ThreadAbortException can filter up here because it gets
                // auto rethrown if no other exception is thrown on catch

                if (e.ExceptionState != null && e.ExceptionState is CancelModuleException) {
                    // one of ours (Response.End or timeout) -- cancel abort

                    CancelModuleException cancelException = (CancelModuleException)e.ExceptionState;

                    if (cancelException.Timeout) {
                        // Timed out
                        error = new HttpException(HttpRuntime.FormatResourceString(SR.Request_timed_out));
                        PerfCounters.IncrementCounter(AppPerfCounter.REQUESTS_TIMED_OUT);
                    }
                    else {
                        // Response.End
                        error = null;
                        _requestCompleted = true;
                    }

                    Thread.ResetAbort();
                }
            }

            completedSynchronously = true;
            return error;
        }

        /*
         * Resume execution of the app steps
         */

        private void ResumeStepsFromThreadPoolThread(Exception error) {
            if (Thread.CurrentThread.IsThreadPoolThread) {
                // if on thread pool thread, use the current thread
                ResumeSteps(error);
            }
            else {
                // if on a non-threadpool thread, requeue
                ThreadPool.QueueUserWorkItem(_resumeStepsWaitCallback, error);
            }
        }

        private void ResumeStepsWaitCallback(Object error) {
            ResumeSteps(error as Exception);
        }

        private void ResumeSteps(Exception error) {
            bool appCompleted  = false;
            bool stepCompletedSynchronously = true;

            lock (this) {
                // avoid race between the app code and fast async completion from a module 

                try {
                    OnThreadEnter();
                }
                catch (Exception e) {
                    if (error == null)
                        error = e;
                }

                try {
                    try {
                        for (;;) {
                            // record error

                            if (error != null) {
                                RecordError(error);
                                error = null;
                            }

                            // advance to next step

                            if (_currentStepIndex < _endRequestStepIndex && (_context.Error != null || _requestCompleted)) {
                                // end request
                                _currentStepIndex = _endRequestStepIndex;
                                _context.Response.DisableFiltering();
                            }
                            else {
                                _currentStepIndex++;
                            }

                            if (_currentStepIndex >= _execSteps.Length) {
                                appCompleted = true;
                                break;
                            }

                            // execute the current step

                            _numStepCalls++;          // count all calls

                            // call to execute current step catching thread abort exception
                            error = ExecuteStep(_execSteps[_currentStepIndex], ref stepCompletedSynchronously);

                            // unwind the stack in the async case
                            if (!stepCompletedSynchronously)
                                break;

                            _numSyncStepCalls++;      // count synchronous calls
                        }
                    }
                    finally {
                        OnThreadLeave();
                    }
                }
                catch { // Protect against exception filters
                    throw;
                }

            }   // lock

            if (appCompleted) {
                // unroot context (async app operations ended)
                _context.Unroot();

                if (_context.TraceIsEnabled)
                    HttpRuntime.Profile.EndRequest(_context);

                // async completion
                _ar.Complete((_numStepCalls == _numSyncStepCalls), null, null);

                // could be recycled, need to reset
                _context.Handler = null;

                // recycle all handlers for this request
                RecycleHandlers();

                // cleanup
                _context.ApplicationInstance = null;
                _context = null;
                _appEvent = null;
                _ar = null;

                // recycle this app
                HttpApplicationFactory.RecycleApplicationInstance(this);
            }
        }

        /*
         * Add error to the context fire OnError on first error
         */
        private void RecordError(Exception error) {
            bool firstError = true;

            if (_context != null) {
                if (_context.Error != null)
                    firstError = false;

                _context.AddError(error);
            }
            else {
                if (_lastError != null)
                    firstError = false;

                _lastError = error;
            }

            if (firstError)
                RaiseOnError();
        }

        //
        // Init module list
        //

        private void InitModules() {
            // List of modules

            HttpModulesConfiguration pconfig = (HttpModulesConfiguration)HttpContext.GetAppConfig("system.web/httpModules");

            if (pconfig == null)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Missing_modules_config));

            _moduleCollection = pconfig.CreateModules();

            int n = _moduleCollection.Count;

            for (int i = 0; i < n; i++) {
                _moduleCollection[i].Init(this);
            }

            // Get app-level culture info (needed to context-less 'global' methods)

            GlobalizationConfig globConfig = (GlobalizationConfig)HttpContext.GetAppConfig("system.web/globalization");
            if (globConfig != null) {
                _appLevelCulture = globConfig.Culture;
                _appLevelUICulture =  globConfig.UICulture;
            }
        }

        //
        // Request mappings management functions
        //

        private IHttpHandlerFactory GetFactory(HandlerMapping mapping) {
            HandlerFactoryCache entry = (HandlerFactoryCache)_handlerFactories[mapping.TypeName];
            if (entry == null) {
                entry = new HandlerFactoryCache(mapping);
                _handlerFactories[mapping.TypeName] = entry;
            }

            return entry.Factory;
        }

        /*
         * Recycle all handlers mapped during the request processing
         */
        private void RecycleHandlers() {
            if (_handlerRecycleList != null) {
                int numHandlers = _handlerRecycleList.Count;

                for (int i = 0; i < numHandlers; i++)
                    ((HandlerWithFactory)_handlerRecycleList[i]).Recycle();

                _handlerRecycleList = null;
            }
        }

        /*
         * Special exception to cancel module execution (not really an exception)
         * used in Response.End and when cancelling requests
         */
        internal class CancelModuleException {
            private bool _timeout;

            internal CancelModuleException(bool timeout) {
                _timeout = timeout;
            }

            internal bool Timeout { get { return _timeout;}}
        }


        //
        // Internal classes to support [asynchronous] app execution logic
        //

        internal class AsyncAppEventHandler {
            int _count;
            ArrayList _beginHandlers;
            ArrayList _endHandlers;

            internal AsyncAppEventHandler() {
                _count = 0;
                _beginHandlers = new ArrayList();
                _endHandlers   = new ArrayList();
            }

            internal void Add(BeginEventHandler beginHandler, EndEventHandler endHandler) {
                _beginHandlers.Add(beginHandler);
                _endHandlers.Add(endHandler);
                _count++;
            }

            internal void CreateExecutionSteps(HttpApplication app, ArrayList steps) {
                for (int i = 0; i < _count; i++) {
                    steps.Add(new AsyncEventExecutionStep(
                                                         app, 
                                                         (BeginEventHandler)_beginHandlers[i], 
                                                         (EndEventHandler)_endHandlers[i]));
                }
            }
        }

        // interface to represent one execution step
        internal interface IExecutionStep {
            void Execute();
            bool CompletedSynchronously { get;}
            bool IsCancellable { get; }
        }

        // execution step -- call synchronous event
        internal class SyncEventExecutionStep : IExecutionStep {
            private HttpApplication _application;
            private EventHandler    _handler;

            internal SyncEventExecutionStep(HttpApplication app, EventHandler handler) {
                _application = app;
                _handler = handler;
            }

            void IExecutionStep.Execute() {
                if (_handler != null)
                    _handler(_application, _application.AppEvent);
            }

            bool IExecutionStep.CompletedSynchronously {
                get { return true;}
            }

            bool IExecutionStep.IsCancellable {
                get { return true; }
            }
        }

        // execution step -- call asynchronous event
        internal class AsyncEventExecutionStep : IExecutionStep {
            private HttpApplication     _application;
            private BeginEventHandler   _beginHandler;
            private EndEventHandler     _endHandler;
            private AsyncCallback       _completionCallback;
            private bool                _sync;          // per call

            internal AsyncEventExecutionStep(HttpApplication app, BeginEventHandler beginHandler, EndEventHandler endHandler) {
                _application = app;
                _beginHandler = beginHandler;
                _endHandler = endHandler;
                _completionCallback = new AsyncCallback(this.OnAsyncEventCompletion);
            }

            private void OnAsyncEventCompletion(IAsyncResult ar) {
                if (ar.CompletedSynchronously)  // handled in Execute()
                    return;

                Exception error = null;

                try {
                    _endHandler(ar);
                }
                catch (Exception e) {
                    error = e;
                }

                // Assert to disregard the user code up the stack
                InternalSecurityPermissions.Unrestricted.Assert();

                _application.ResumeStepsFromThreadPoolThread(error);
            }

            void IExecutionStep.Execute() {
                _sync = false;

                IAsyncResult ar = _beginHandler(_application, _application.AppEvent, _completionCallback, null);

                if (ar.CompletedSynchronously) {
                    _sync = true;
                    _endHandler(ar);
                }
            }

            bool IExecutionStep.CompletedSynchronously {
                get { return _sync;}
            }

            bool IExecutionStep.IsCancellable {
                get { return false; }
            }
        }

        // execution step -- map HTTP handler (used to be a separate module)
        internal class MapHandlerExecutionStep : IExecutionStep {
            private HttpApplication _application;

            internal MapHandlerExecutionStep(HttpApplication app) {
                _application = app;
            }

            void IExecutionStep.Execute() {
                HttpContext context = _application.Context;
                HttpRequest request = context.Request;

                context.Handler = _application.MapHttpHandler(
                                                             context,
                                                             request.RequestType,
                                                             request.FilePath,
                                                             request.PhysicalPathInternal,
                                                             false /*useAppConfig*/);
                Debug.Assert(context.ConfigPath == context.Request.FilePath, "context.ConfigPath (" +
                    context.ConfigPath + ") != context.Request.FilePath (" + context.Request.FilePath + ")");
            }

            bool IExecutionStep.CompletedSynchronously {
                get { return true;}
            }

            bool IExecutionStep.IsCancellable {
                get { return false; }
            }
        }

        // execution step -- call HTTP handler (used to be a separate module)
        internal class CallHandlerExecutionStep : IExecutionStep {
            private HttpApplication   _application;
            private AsyncCallback     _completionCallback;
            private IHttpAsyncHandler _handler;       // per call
            private bool              _sync;          // per call

            internal CallHandlerExecutionStep(HttpApplication app) {
                _application = app;
                _completionCallback = new AsyncCallback(this.OnAsyncHandlerCompletion);
            }

            private void OnAsyncHandlerCompletion(IAsyncResult ar) {
                if (ar.CompletedSynchronously)  // handled in Execute()
                    return;

                Exception error = null;

                try {
                    _handler.EndProcessRequest(ar);
                }
                catch (Exception e) {
                    error = e;
                }

                _handler = null; // not to remember

                // Assert to disregard the user code up the stack
                InternalSecurityPermissions.Unrestricted.Assert();

                _application.ResumeStepsFromThreadPoolThread(error);
            }

            void IExecutionStep.Execute() {
                HttpContext context = _application.Context;
                IHttpHandler handler = context.Handler;

                if (handler == null) {
                    _sync = true;
                }
                else if (handler is IHttpAsyncHandler) {
                    // asynchronous handler
                    IHttpAsyncHandler asyncHandler = (IHttpAsyncHandler)handler;

                    _sync = false;
                    _handler = asyncHandler;
                    IAsyncResult ar = asyncHandler.BeginProcessRequest(context, _completionCallback, null);

                    if (ar.CompletedSynchronously) {
                        _sync = true;
                        _handler = null; // not to remember
                        asyncHandler.EndProcessRequest(ar);
                    }
                }
                else {
                    // synchronous handler
                    _sync = true;
                    handler.ProcessRequest(context);
                }
            }

            bool IExecutionStep.CompletedSynchronously {
                get { return _sync;}
            }

            bool IExecutionStep.IsCancellable {
                // launching of async handler should not be cancellable
                get { return (_application.Context.Handler is IHttpAsyncHandler) ? false : true; }
            }
        }

        // execution step -- call response filter
        internal class CallFilterExecutionStep : IExecutionStep {
            private HttpApplication _application;

            internal CallFilterExecutionStep(HttpApplication app) {
                _application = app;
            }

            void IExecutionStep.Execute() {
                _application.Context.Response.FilterOutput();
            }

            bool IExecutionStep.CompletedSynchronously {
                get { return true;}
            }

            bool IExecutionStep.IsCancellable {
                get { return true; }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpstaticobjectscollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="httpstaticobjectscollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Static objects collection for application and session state
 * with deferred creation
 */
namespace System.Web {
    using System.Runtime.InteropServices;

    using System.Collections;
    using System.Collections.Specialized;
    using System.IO;
    using System.Web;
    using System.Web.Util;
    using System.Security.Permissions;

    //
    // Static objects collection class
    //
    /// <include file='doc\httpstaticobjectscollection.uex' path='docs/doc[@for="HttpStaticObjectsCollection"]/*' />
    /// <devdoc>
    ///    <para>Provides a static objects collection for the 
    ///       HTTPApplicationState.StaticObjects and TemplateParser.SessionObjects properties.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpStaticObjectsCollection : ICollection {
        private IDictionary _objects = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);

        /// <include file='doc\httpstaticobjectscollection.uex' path='docs/doc[@for="HttpStaticObjectsCollection.HttpStaticObjectsCollection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.HttpStaticObjectsCollection'/>
        ///       class.
        ///     </para>
        /// </devdoc>
        public HttpStaticObjectsCollection() {
            InternalSecurityPermissions.UnmanagedCode.Demand();
        }

        internal void Add(String name, Type t, bool lateBound) {
            _objects.Add(name, new HttpStaticObjectsEntry(name, t, lateBound));
        }

        // Expose the internal dictionary (for codegen purposes)
        internal IDictionary Objects {
            get { return _objects;}
        }

        /*
         * Create a copy without copying instances (names and types only)
         */
        internal HttpStaticObjectsCollection Clone() {
            HttpStaticObjectsCollection c = new HttpStaticObjectsCollection();

            IDictionaryEnumerator e = _objects.GetEnumerator();

            while (e.MoveNext()) {
                HttpStaticObjectsEntry entry = (HttpStaticObjectsEntry)e.Value;
                c.Add(entry.Name, entry.ObjectType, entry.LateBound);
            }

            return c;
        }

        /*
         * Get number of real instances created
         */
        internal int GetInstanceCount() {
            int count = 0;

            IDictionaryEnumerator e = _objects.GetEnumerator();

            while (e.MoveNext()) {
                HttpStaticObjectsEntry entry = (HttpStaticObjectsEntry)e.Value;

                if (entry.HasInstance)
                    count++;
            }

            return count;
        }

        //
        // Implementation of standard collection stuff
        //

        /// <include file='doc\httpstaticobjectscollection.uex' path='docs/doc[@for="HttpStaticObjectsCollection.this"]/*' />
        /// <devdoc>
        ///    <para>Gets the object in the collection with the given name (case 
        ///       insensitive). </para>
        /// </devdoc>
        public Object this[String name]
        {
            get {
                HttpStaticObjectsEntry e = (HttpStaticObjectsEntry)_objects[name];
                return(e != null) ? e.Instance : null;
            }
        }

        // Alternative to the default property
        /// <include file='doc\httpstaticobjectscollection.uex' path='docs/doc[@for="HttpStaticObjectsCollection.GetObject"]/*' />
        /// <devdoc>
        ///    <para>Gets the object in the collection with the given name 
        ///       (case insensitive). Alternative to the <paramref name="this"/> accessor.</para>
        /// </devdoc>
        public Object GetObject(String name) {
            return this[name];
        }

        /// <include file='doc\httpstaticobjectscollection.uex' path='docs/doc[@for="HttpStaticObjectsCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>Gets the number of objects in the collection.</para>
        /// </devdoc>
        public int Count {
            get {
                return _objects.Count;
            }
        }

        /// <include file='doc\httpstaticobjectscollection.uex' path='docs/doc[@for="HttpStaticObjectsCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>Returns a dictionary enumerator used for iterating through the key/value 
        ///       pairs contained in the collection.</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return new HttpStaticObjectsEnumerator((IDictionaryEnumerator)_objects.GetEnumerator());
        }

        /// <include file='doc\httpstaticobjectscollection.uex' path='docs/doc[@for="HttpStaticObjectsCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>Copies members of the collection into an array.</para>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            for (IEnumerator e = this.GetEnumerator(); e.MoveNext();)
                array.SetValue(e.Current, index++);
        }

        /// <include file='doc\httpstaticobjectscollection.uex' path='docs/doc[@for="HttpStaticObjectsCollection.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>Gets an object that can be used to synchronize access to the collection.</para>
        /// </devdoc>
        public Object SyncRoot {
            get { return this;}
        }

        /// <include file='doc\httpstaticobjectscollection.uex' path='docs/doc[@for="HttpStaticObjectsCollection.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the collection is read-only.</para>
        /// </devdoc>
        public bool IsReadOnly {
            get { return true;}
        }

        /// <include file='doc\httpstaticobjectscollection.uex' path='docs/doc[@for="HttpStaticObjectsCollection.IsSynchronized"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the collection is synchronized.</para>
        /// </devdoc>
        public bool IsSynchronized {
            get { return false;}
        }

        internal void Serialize(BinaryWriter writer) {
            IDictionaryEnumerator   e;
            HttpStaticObjectsEntry  entry;
            bool                    hasInstance;

            writer.Write(Count);

            e = _objects.GetEnumerator();
            while (e.MoveNext()) {
                entry = (HttpStaticObjectsEntry)e.Value;
                writer.Write(entry.Name);
                hasInstance = entry.HasInstance;
                writer.Write(hasInstance);

                if (hasInstance) {
                    AltSerialization.WriteValueToStream(entry.Instance, writer);
                }
                else {
                    writer.Write(entry.ObjectType.FullName);
                    writer.Write(entry.LateBound);
                }
            }
        }

        static internal HttpStaticObjectsCollection Deserialize(BinaryReader reader) {
            int     count;
            string  name;
            string  typename;
            bool    hasInstance;
            Object  instance;
            HttpStaticObjectsEntry  entry;
            HttpStaticObjectsCollection col;

            col = new HttpStaticObjectsCollection();

            count = reader.ReadInt32();
            while (count-- > 0) {
                name = reader.ReadString();
                hasInstance = reader.ReadBoolean();
                if (hasInstance) {
                    instance = AltSerialization.ReadValueFromStream(reader);
                    entry = new HttpStaticObjectsEntry(name, instance, 0);
                }
                else {
                    typename = reader.ReadString();
                    bool lateBound = reader.ReadBoolean();
                    entry = new HttpStaticObjectsEntry(name, Type.GetType(typename), lateBound);
                }

                col._objects.Add(name, entry);
            }

            return col;
        }
    }

//
// Dictionary entry class
//

    internal class HttpStaticObjectsEntry {
        private String _name;
        private Type   _type;
        private bool   _lateBound;
        private Object _instance;

        internal HttpStaticObjectsEntry(String name, Type t, bool lateBound) {
            _name = name;
            _type = t;
            _lateBound = lateBound;
            _instance = null;
        }

        internal HttpStaticObjectsEntry(String name, Object instance, int dummy) {
            _name = name;
            _type = instance.GetType();
            _instance = instance;
        }

        internal String Name {
            get { return _name;} 
        }

        internal Type ObjectType {
            get { return _type;} 
        }

        internal bool LateBound {
            get { return _lateBound;} 
        }

        internal Type DeclaredType {
            get { return _lateBound ? typeof(object) : ObjectType; }
        }

        internal bool HasInstance {
            get { return(_instance != null);}
        }

        internal Object Instance {
            get {
                if (_instance == null) {
                    lock (this) {
                        if (_instance == null)
                            _instance = Activator.CreateInstance(_type);
                    }
                }

                return _instance;
            }
        }
    }

    //
    // Enumerator class for static objects collection
    //
    internal class HttpStaticObjectsEnumerator : IDictionaryEnumerator {
        private IDictionaryEnumerator _enum;

        internal HttpStaticObjectsEnumerator(IDictionaryEnumerator e) {
            _enum = e;
        }

        // Dictionary enumarator implementation

        public void Reset() {
            _enum.Reset();
        }

        public bool MoveNext() {
            return _enum.MoveNext();
        }

        public Object Key {
            get {
                return _enum.Key;
            }
        }

        public Object Value {
            get {
                HttpStaticObjectsEntry e = (HttpStaticObjectsEntry)_enum.Value;

                if (e == null)
                    return null;

                return e.Instance;
            }
        }

        public Object Current {
            get {
                return Entry;
            }
        }

        public DictionaryEntry Entry {
            get {
                return new DictionaryEntry(_enum.Key, this.Value);
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpserverutility.cs ===
//------------------------------------------------------------------------------
// <copyright file="httpserverutility.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Server intrinsic used to match ASP's object model
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web {
    using System.Text;
    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.IO;
    using System.Collections;
    using System.Globalization;
    using System.Web.Util;
    using System.Web.UI;
    using System.Web.Configuration;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides several
    ///       helper methods that can be used in the processing of Web requests.
    ///    </para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpServerUtility {
        private HttpContext _context;
        private HttpApplication _application;

        internal HttpServerUtility(HttpContext context) {
            _context = context;
        }

        internal HttpServerUtility(HttpApplication application) {
            _application = application;
        }

        //
        // Misc ASP compatibility methods
        //

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.CreateObject"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Instantiates a COM object identified via a progid.
        ///    </para>
        /// </devdoc>
        public object CreateObject(string progID) {
            InternalSecurityPermissions.UnmanagedCode.Demand();

            Type type = null;
            object obj = null;

            try {
                type = Type.GetTypeFromProgID(progID);
            }
            catch (Exception) {
            }

            if (type == null) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Could_not_create_object_of_type, progID));
            }

            // Disallow Apartment components in non-compat mode
            AspCompatApplicationStep.CheckThreadingModel(progID, type.GUID);

            // Instantiate the object
            obj = Activator.CreateInstance(type);

            // For ASP compat: take care of OnPageStart/OnPageEnd
            AspCompatApplicationStep.OnPageStart(obj);

            return obj;
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.CreateObject1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Instantiates a COM object identified via a Type.
        ///    </para>
        /// </devdoc>
        public object CreateObject(Type type) {
            InternalSecurityPermissions.UnmanagedCode.Demand();

            // Disallow Apartment components in non-compat mode
            AspCompatApplicationStep.CheckThreadingModel(type.FullName, type.GUID);

            // Instantiate the object
            Object obj = Activator.CreateInstance(type);

            // For ASP compat: take care of OnPageStart/OnPageEnd
            AspCompatApplicationStep.OnPageStart(obj);

            return obj;
        }


        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.CreateObjectFromClsid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Instantiates a COM object identified via a clsid.
        ///    </para>
        /// </devdoc>
        public object CreateObjectFromClsid(string clsid) {
            InternalSecurityPermissions.UnmanagedCode.Demand();

            Type type = null;
            object obj = null;

            // Create a Guid out of it
            Guid guid = new Guid(clsid);

            // Disallow Apartment components in non-compat mode
            AspCompatApplicationStep.CheckThreadingModel(clsid, guid);

            try {
                type = Type.GetTypeFromCLSID(guid, null, true /*throwOnError*/);

                // Instantiate the object
                obj = Activator.CreateInstance(type);
            }
            catch (Exception) {
            }

            if (obj == null) {
                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Could_not_create_object_from_clsid, clsid));
            }

            // For ASP compat: take care of OnPageStart/OnPageEnd
            AspCompatApplicationStep.OnPageStart(obj);

            return obj;
        }

        // Internal static method that returns a read-only, non-user override accounted, CultureInfo object
        internal static CultureInfo CreateReadOnlyCultureInfo(string name) {
            CultureInfo culInfo = new CultureInfo(name, false);

            return CultureInfo.ReadOnly(culInfo);
        }

        // Internal static method that returns a read-only, non-user override accounted, CultureInfo object
        internal static CultureInfo CreateReadOnlyCultureInfo(int culture) {
            CultureInfo culInfo = new CultureInfo(culture, false);

            return CultureInfo.ReadOnly(culInfo);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.MapPath"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Maps a virtual path to a physical path.
        ///    </para>
        /// </devdoc>
        public string MapPath(string path) {
            if (_context == null)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Server_not_available));

            string realPath = _context.Request.MapPath(path);
            return realPath;
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.GetLastError"]/*' />
        /// <devdoc>
        ///    <para>Returns the last recorded exception.</para>
        /// </devdoc>
        public Exception GetLastError() {
            if (_context != null)
                return _context.Error;
            else if (_application != null)
                return _application.LastError;
            else
                return null;
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.ClearError"]/*' />
        /// <devdoc>
        ///    <para>Clears the last error.</para>
        /// </devdoc>
        public void ClearError() {
            if (_context != null)
                _context.ClearError();
            else if (_application != null)
                _application.ClearError();
        }

        //
        // Server.Transfer/Server.Execute -- child requests
        //

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.Execute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Executes a new request (using the specified URL path as the target). Unlike
        ///       the Transfer method, execution of the original page continues after the executed
        ///       page completes.
        ///    </para>
        /// </devdoc>
        public void Execute(string path) {
            ExecuteInternal(path, null, true /*preserveForm*/);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.Execute1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Executes a new request (using the specified URL path as the target). Unlike
        ///       the Transfer method, execution of the original page continues after the executed
        ///       page completes.
        ///    </para>
        /// </devdoc>
        public void Execute(string path, TextWriter writer) {
            ExecuteInternal(path, writer, true /*preserveForm*/);
        }

        private void ExecuteInternal(string path, TextWriter writer, bool preserveForm) {
            if (_context == null)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Server_not_available));

            if (path == null)
                throw new ArgumentNullException("path");
            if (!UrlPath.IsValidVirtualPathWithoutProtocol(path))
                throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Invalid_path_for_child_request, path));

            HttpValueCollection savedForm = null;
            string savedCurrentExecutionFilePath = null;
            string savedQueryString = null;
            string queryStringOverride = null;
            TextWriter savedOutputWriter = null;
            HttpRequest request = _context.Request;
            HttpResponse response = _context.Response;
            Exception error = null;

            // Remove potential cookie-less session id (ASURT 100558)
            path = response.RemoveAppPathModifier(path);

            // Allow query string override
            int iqs = path.IndexOf('?');
            if (iqs >= 0) {
                queryStringOverride = path.Substring(iqs+1);
                path = path.Substring(0, iqs);
            }

            // Find the handler for the path

            IHttpHandler handler = null;

            string physPath = request.MapPath(path);        // get physical path
            string filePath = UrlPath.Combine(request.BaseDir, path);   // vpath

            // Demand read access to the physical path of the target handler
            InternalSecurityPermissions.FileReadAccess(physPath).Demand();

            try {
                // paths that ends with . are disallowed as they are used to get around
                // extension mappings and server source as static file
                if (path.EndsWith("."))
                    throw new HttpException(404, "");

                bool useAppConfig = !HttpRuntime.IsPathWithinAppRoot(filePath);

                handler = _context.ApplicationInstance.MapHttpHandler(
                                                                     _context,
                                                                     request.RequestType,
                                                                     filePath,
                                                                     physPath,
                                                                     useAppConfig);
            }
            catch (Exception e) {
                error = e;
            }

            // Transaction wouldn't flow into ASPCOMPAT mode -- need to report an error
            VerifyTransactionFlow(handler);

            // create new trace context
            _context.PushTraceContext();

            // Execute the handler
            try {
                try {
                    _context.ServerExecuteDepth++;

                    savedCurrentExecutionFilePath = request.SwitchCurrentExecutionFilePath(filePath);

                    if (!preserveForm) {
                        savedForm = request.SwitchForm(new HttpValueCollection());

                        // Clear out the query string, but honor overrides
                        if (queryStringOverride == null)
                            queryStringOverride = String.Empty;
                    }

                    // override query string if requested
                    if (queryStringOverride != null) {
                        savedQueryString = request.QueryStringText;
                        request.QueryStringText = queryStringOverride;
                    }

                    // capture output if requested
                    if (writer != null)
                        savedOutputWriter = response.SwitchWriter(writer);

                    // If the source page of the transfer has smart nav on,
                    // always do as if the destination has it too (ASURT 97732)
                    Page targetPage = handler as Page;
                    if (targetPage != null) {
                        Page sourcePage = _context.Handler as Page;
                        if (sourcePage != null && sourcePage.SmartNavigation)
                            targetPage.SmartNavigation = true;
                    }

                    if (handler == null) {
                        // suppress non-500 errors -- pretend file not found
                        // 500 errors (compilation errors) get preserved
                        if (error is HttpException && ((HttpException)error).GetHttpCode() != 500)
                            error = new HttpException(404, "");
                    }
                    else if (handler is StaticFileHandler) {
                        // cannot apply static files handler directly
                        // -- it would dump the source of the current page
                        // instead just dump the file content into response
                        try {
                            response.WriteFile(physPath);
                        }
                        catch {
                            // hide the real error as it could be misleading
                            // in case of mismapped requests like /foo.asmx/bar
                            error = new HttpException(404, "");
                        }
                    }
                    else if (!(handler is Page || handler is TrivialPage)) {
                        // disallow anything but pages
                        error = new HttpException(404, "");
                    }
                    else if (handler is IHttpAsyncHandler) {
                        // Asynchronous handler

                        IHttpAsyncHandler asyncHandler = (IHttpAsyncHandler)handler;

                        IAsyncResult ar = asyncHandler.BeginProcessRequest(_context, null, null);

                        // wait for completion

                        if (!ar.IsCompleted) {
                            WaitHandle h = ar.AsyncWaitHandle;

                            if (h != null) {
                                h.WaitOne();
                            }
                            else {
                                while (!ar.IsCompleted)
                                    Thread.Sleep(0);
                            }
                        }

                        // end the async operation (get error if any)

                        try {
                            asyncHandler.EndProcessRequest(ar);
                        }
                        catch (Exception e) {
                            error = e;
                        }
                    }
                    else {
                        // Synchronous handler

                        try {
                            handler.ProcessRequest(_context);
                        }
                        catch (Exception e) {
                            error = e;
                        }
                    }
                }
                finally {
                    _context.ServerExecuteDepth--;

                    // restore output writer
                    if (savedOutputWriter != null)
                        response.SwitchWriter(savedOutputWriter);

                    // restore overriden query string
                    if (queryStringOverride != null && savedQueryString != null)
                        request.QueryStringText = savedQueryString;

                    if (savedForm != null)
                        request.SwitchForm(savedForm);

                    request.SwitchCurrentExecutionFilePath(savedCurrentExecutionFilePath);

                    // restore trace context
                    _context.PopTraceContext();
                }
            }
            catch { // Protect against exception filters
                throw;
            }

            // Report any error

            if (error != null) {
                // suppress errors with HTTP codes (for child requests they mislead more than help)
                if (error is HttpException && ((HttpException)error).GetHttpCode() != 500)
                    error = null;

                throw new HttpException(HttpRuntime.FormatResourceString(SR.Error_executing_child_request_for_path, path), error);
            }
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.Transfer"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Terminates execution of the current page and begins execution of a new
        ///       request using the supplied URL path.
        ///       If preserveForm is false, the QueryString and Form collections are cleared.
        ///    </para>
        /// </devdoc>
        public void Transfer(string path, bool preserveForm) {
            if (_context == null)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Server_not_available));

            // execute child request

            ExecuteInternal(path, null, preserveForm);

            // suppress the remainder of the current one

            _context.Response.End();
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.Transfer1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Terminates execution of the current page and begins execution of a new
        ///       request using the supplied URL path.
        ///    </para>
        /// </devdoc>
        public void Transfer(string path) {
            Transfer(path, true /*preserveForm*/);
        }

        private void VerifyTransactionFlow(IHttpHandler handler) {
            Page topPage = _context.Handler as Page;
            Page childPage = handler as Page;

            if (childPage != null && childPage.IsInAspCompatMode && // child page aspcompat
                topPage != null && !topPage.IsInAspCompatMode &&    // top page is not aspcompat
                Transactions.Utils.IsInTransaction) {               // we are in transaction

                throw new HttpException(HttpRuntime.FormatResourceString(SR.Transacted_page_calls_aspcompat));
            }
        }

        //
        // Computer name
        //

        private static string _machineName;
        private const int _maxMachineNameLength = 256;

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.MachineName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the server machine name.
        ///    </para>
        /// </devdoc>
        public string MachineName {
            get {
                if ( _machineName == null) {
                    StringBuilder buf = new StringBuilder(_maxMachineNameLength);
                    int len = _maxMachineNameLength;
                    if (UnsafeNativeMethods.GetComputerName(buf, ref len) == 0)
                        new HttpException("Couldn't obtain computer name");

                    _machineName = buf.ToString();
                }

                InternalSecurityPermissions.AspNetHostingPermissionLevelMedium.Demand();
                return _machineName;
            }
        }

        //
        // Request Timeout
        //

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.ScriptTimeout"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Request timeout in seconds
        ///    </para>
        /// </devdoc>
        public int ScriptTimeout {
            get {
                if (_context != null)
                    return Convert.ToInt32(_context.Timeout.TotalSeconds);
                else
                    return HttpRuntimeConfig.DefaultExecutionTimeout;
            }

            set {
                InternalSecurityPermissions.AspNetHostingPermissionLevelMedium.Demand();

                if (_context == null)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Server_not_available));
                if (value <= 0)
                    throw new ArgumentOutOfRangeException("value");
                _context.Timeout = new TimeSpan(0, 0, value);
            }
        }

        //
        // Encoding / Decoding -- wrappers for HttpUtility
        //

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.HtmlDecode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       HTML
        ///       decodes a given string and
        ///       returns the decoded string.
        ///    </para>
        /// </devdoc>
        public string HtmlDecode(string s) {
            return HttpUtility.HtmlDecode(s);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.HtmlDecode1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       HTML
        ///       decode a string and send the result to a TextWriter output
        ///       stream.
        ///    </para>
        /// </devdoc>
        public void HtmlDecode(string s, TextWriter output) {
            HttpUtility.HtmlDecode(s, output);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.HtmlEncode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       HTML
        ///       encodes a given string and
        ///       returns the encoded string.
        ///    </para>
        /// </devdoc>
        public string HtmlEncode(string s) {
            return HttpUtility.HtmlEncode(s);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.HtmlEncode1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       HTML
        ///       encodes
        ///       a string and returns the output to a TextWriter stream of output.
        ///    </para>
        /// </devdoc>
        public void HtmlEncode(string s, TextWriter output) {
            HttpUtility.HtmlEncode(s, output);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.UrlEncode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       URL
        ///       encodes a given
        ///       string and returns the encoded string.
        ///    </para>
        /// </devdoc>
        public string UrlEncode(string s) {
            Encoding e = (_context != null) ? _context.Response.ContentEncoding : Encoding.UTF8;
            return HttpUtility.UrlEncode(s, e);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.UrlPathEncode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       URL encodes a path portion of a URL string and returns the encoded string.
        ///    </para>
        /// </devdoc>
        public string UrlPathEncode(string s) {
            return HttpUtility.UrlPathEncode(s);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.UrlEncode1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       URL
        ///       encodes
        ///       a string and returns the output to a TextWriter output stream.
        ///    </para>
        /// </devdoc>
        public void UrlEncode(string s, TextWriter output) {
            if (s != null)
                output.Write(UrlEncode(s));
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.UrlDecode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       URL decodes a string and returns the output in a string.
        ///    </para>
        /// </devdoc>
        public string UrlDecode(string s) {
            Encoding e = (_context != null) ? _context.Request.ContentEncoding : Encoding.UTF8;
            return HttpUtility.UrlDecode(s, e);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpServerUtility.UrlDecode1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       URL decodes a string and returns the output as a TextWriter output
        ///       stream.
        ///    </para>
        /// </devdoc>
        public void UrlDecode(string s, TextWriter output) {
            if (s != null)
                output.Write(UrlDecode(s));
        }

    }

    /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility"]/*' />
    /// <devdoc>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpUtility {

        //////////////////////////////////////////////////////////////////////////
        //
        //  HTML Encoding / Decoding
        //

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.HtmlDecode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       HTML decodes a string and returns the decoded string.
        ///    </para>
        /// </devdoc>
        public static string HtmlDecode(string s) {
            if (s == null)
                return null;

            // See if this string needs to be decoded at all.  If no
            // ampersands are found, then no special HTML-encoded chars
            // are in the string.  
            if (s.IndexOf('&') < 0)
                return s;

            StringBuilder builder = new StringBuilder();
            StringWriter writer = new StringWriter(builder);

            HtmlDecode(s, writer);

            return builder.ToString();
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.HtmlDecode1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       HTML decode a string and send the result to a TextWriter output stream.
        ///    </para>
        /// </devdoc>
        public static void HtmlDecode(string s, TextWriter output) {
            if (s == null)
                return;

            if (s.IndexOf('&') < 0) {
                output.Write(s);        // good as is
                return;
            }

            int l = s.Length;
            for (int i = 0; i < l; i++) {
                char ch = s[i];

                if (ch == '&') {
                    int semicolonIndex = s.IndexOf(';', i + 1);
                    if (semicolonIndex > 0) {
                        string entity = s.Substring(i + 1, semicolonIndex - i - 1);

                        if ((entity[0] == '#') && (entity.Length > 1)) {
                            try {
                                // The # syntax can be in decimal or hex, e.g.
                                //      &#229;  --> decimal
                                //      &#xE5;  --> same char in hex
                                // See http://www.w3.org/TR/REC-html40/charset.html#entities
                                if (entity[1] == 'x' || entity[1] == 'X')
                                    ch = (char) Int32.Parse(entity.Substring(2), NumberStyles.AllowHexSpecifier);
                                else
                                    ch = (char) Int32.Parse(entity.Substring(1));
                                i = semicolonIndex; // already looked at everything until semicolon
                            }
                            catch (System.FormatException) {
                                i++;    //if the number isn't valid, ignore it
                            }
                            catch (System.ArgumentException) {
                                i++;    // if there is no number, ignore it. 
                            }
                        }
                        else {
                            i = semicolonIndex; // already looked at everything until semicolon

                            char entityChar = HtmlEntities.Lookup(entity);
                            if (entityChar != (char)0) {
                                ch = entityChar;
                            }
                            else {
                                output.Write('&');
                                output.Write(entity);
                                output.Write(';');
                                continue;
                            }
                        }

                    }
                }

                output.Write(ch);
            }
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.HtmlEncode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       HTML encodes a string and returns the encoded string.
        ///    </para>
        /// </devdoc>
        public static String HtmlEncode(String s) {
            if (s == null)
                return null;

            StringBuilder builder = new StringBuilder();
            StringWriter writer = new StringWriter(builder);

            HtmlEncode(s, writer);

            return builder.ToString();
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.HtmlEncode1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       HTML encodes a string and returns the output to a TextWriter stream of
        ///       output.
        ///    </para>
        /// </devdoc>
        public static void HtmlEncode(String s, TextWriter output) {
            if (s == null)
                return;

            int cb = s.Length;

            for (int i=0; i<cb; i++) {
                char ch = s[i];
                switch (ch) {
                    case '<':
                        output.Write("&lt;");
                        break;
                    case '>':
                        output.Write("&gt;");
                        break;
                    case '"':
                        output.Write("&quot;");
                        break;
                    case '&':
                        output.Write("&amp;");
                        break;
                    default:
                        // The seemingly arbitrary 160 comes from RFC
                        if (ch >= 160 && ch < 256) {
                            output.Write("&#" + ((int)ch).ToString(NumberFormatInfo.InvariantInfo) + ";");
                            break;
                        }

                        output.Write(ch);
                        break;
                }
            }
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.HtmlAttributeEncode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Encodes a string to make it a valid HTML attribute and returns the encoded string.
        ///    </para>
        /// </devdoc>
        public static String HtmlAttributeEncode(String s) {

            StringBuilder builder = new StringBuilder();

            HtmlAttributeEncode(s, builder);

            return builder.ToString();
        }

        private static readonly char[] attributeCharacters = new char[] {'"', '&'};

        private static void HtmlAttributeEncode(string s, StringBuilder builder) {
            int cb = s.Length;

            int pos = s.IndexOfAny(attributeCharacters);
            if (pos == -1) {
                builder.Append(s);
                return;
            }
            int startPos = 0;
            while (pos < cb) {
                if (pos > startPos) {
                    builder.Append(s, startPos, pos - startPos);
                }
                char ch = s[pos];
                switch (ch) {
                    case '"':
                        builder.Append("&quot;");
                        break;
                    case '&':
                        builder.Append("&amp;");
                        break;
                }
                startPos = pos + 1;
                pos = s.IndexOfAny(attributeCharacters, startPos);
                if (pos == -1) {
                    builder.Append(s, startPos, cb - startPos);
                    return;
                }
            }
        }

        internal static void HtmlAttributeEncodeInternal(String s, HttpWriter writer) {
            int cb = s.Length;

            int pos = s.IndexOfAny(attributeCharacters);
            if (pos == -1) {
                writer.Write(s);
                return;
            }
            int startPos = 0;
            while (pos < cb) {
                if (pos > startPos) {
                    writer.WriteString(s, startPos, pos - startPos);
                }
                char ch = s[pos];
                switch (ch) {
                    case '"':
                        writer.Write("&quot;");
                        break;
                    case '&':
                        writer.Write("&amp;");
                        break;
                }
                startPos = pos + 1;
                pos = s.IndexOfAny(attributeCharacters, startPos);
                if (pos == -1) {
                    writer.WriteString(s, startPos, cb - startPos);
                    return;
                }
            }
        }



        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.HtmlAttributeEncode1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Encodes a string to make it a valid HTML attribute and returns the output
        ///       to a TextWriter stream of
        ///       output.
        ///    </para>
        /// </devdoc>
        public static void HtmlAttributeEncode(String s, TextWriter output) {
            int cb = s.Length;

            for (int i=0; i<cb; i++) {
                char ch = s[i];
                switch (ch) {
                    case '"':
                        output.Write("&quot;");
                        break;
                    case '&':
                        output.Write("&amp;");
                        break;
                    default:
                        output.Write(ch);
                        break;
                }
            }
        }

        internal static String FormatPlainTextAsHtml(String s) {
            if (s == null)
                return null;

            StringBuilder builder = new StringBuilder();
            StringWriter writer = new StringWriter(builder);

            FormatPlainTextAsHtml(s, writer);

            return builder.ToString();
        }

        internal static void FormatPlainTextAsHtml(String s, TextWriter output) {
            if (s == null)
                return;

            int cb = s.Length;

            char prevCh = '\0';

            for (int i=0; i<cb; i++) {
                char ch = s[i];
                switch (ch) {
                    case '<':
                        output.Write("&lt;");
                        break;
                    case '>':
                        output.Write("&gt;");
                        break;
                    case '"':
                        output.Write("&quot;");
                        break;
                    case '&':
                        output.Write("&amp;");
                        break;
                    case ' ':
                        if (prevCh == ' ')
                            output.Write("&nbsp;");
                        else
                            output.Write(ch);
                        break;
                    case '\r':
                        // Ignore \r, only handle \n
                        break;
                    case '\n':
                        output.Write("<br>");
                        break;

                    // REVIEW: what to do with tabs?
                    default:
                        // The seemingly arbitrary 160 comes from RFC
                        if (ch >= 160 && ch < 256) {
                            output.Write("&#" + ((int)ch).ToString(NumberFormatInfo.InvariantInfo) + ";");
                            break;
                        }

                        output.Write(ch);
                        break;
                }

                prevCh = ch;
            }
        }

        //////////////////////////////////////////////////////////////////////////
        //
        //  ASII encode - everything all non-7-bit to '?'
        //

        /*internal static String AsciiEncode(String s) {
            if (s == null)
                return null;

            StringBuilder sb = new StringBuilder(s.Length);

            for (int i = 0; i < s.Length; i++) {
                char ch = s[i];
                if (((ch & 0xff80) != 0) || (ch < ' ' && ch != '\r' && ch != '\n' && ch != '\t'))
                    ch = '?';
                sb.Append(ch);
            }

            return sb.ToString();
        }*/

        //////////////////////////////////////////////////////////////////////////
        //
        //  URL decoding / encoding
        //
        //////////////////////////////////////////////////////////////////////////

        //
        //  Public static methods
        //

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.UrlEncode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string UrlEncode(string str) {
            if (str == null)
                return null;
            return UrlEncode(str, Encoding.UTF8);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.UrlPathEncode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       URL encodes a path portion of a URL string and returns the encoded string.
        ///    </para>
        /// </devdoc>
        public static string UrlPathEncode(string str) {
            if (str == null)
                return null;

            // recurse in case there is a query string
            int i = str.IndexOf('?');
            if (i >= 0)
                return UrlPathEncode(str.Substring(0, i)) + str.Substring(i);

            // encode DBCS characters and spaces only
            return UrlEncodeSpaces(UrlEncodeNonAscii(str, Encoding.UTF8));
        }

        internal static string AspCompatUrlEncode(string s) {
            s = UrlEncode(s);
            s = s.Replace("!", "%21");
            s = s.Replace("*", "%2A");
            s = s.Replace("(", "%28");
            s = s.Replace(")", "%29");
            s = s.Replace("-", "%2D");
            s = s.Replace(".", "%2E");
            s = s.Replace("_", "%5F");
            s = s.Replace("\\", "%5C");
            return s;
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.UrlEncode1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string UrlEncode(string str, Encoding e) {
            if (str == null)
                return null;
            return Encoding.ASCII.GetString(UrlEncodeToBytes(str, e));
        }

        //  Helper to encode the non-ASCII url characters only
        internal static String UrlEncodeNonAscii(string str, Encoding e) {
            if (str == null || str.Length == 0)
                return str;
            if (e == null)
                e = Encoding.UTF8;
            byte[] bytes = e.GetBytes(str);
            bytes = UrlEncodeBytesToBytesInternalNonAscii(bytes, 0, bytes.Length, false);
            return Encoding.ASCII.GetString(bytes);
        }

        //  Helper to encode spaces only
        internal static String UrlEncodeSpaces(string str) {
            if (str != null && str.IndexOf(' ') >= 0)
                str = str.Replace(" ", "%20");
            return str;
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.UrlEncode2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string UrlEncode(byte[] bytes) {
            if (bytes == null)
                return null;
            return Encoding.ASCII.GetString(UrlEncodeToBytes(bytes));
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.UrlEncode3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string UrlEncode(byte[] bytes, int offset, int count) {
            if (bytes == null)
                return null;
            return Encoding.ASCII.GetString(UrlEncodeToBytes(bytes, offset, count));
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.UrlEncodeToBytes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static byte[] UrlEncodeToBytes(string str) {
            if (str == null)
                return null;
            return UrlEncodeToBytes(str, Encoding.UTF8);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.UrlEncodeToBytes1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static byte[] UrlEncodeToBytes(string str, Encoding e) {
            if (str == null)
                return null;
            byte[] bytes = e.GetBytes(str);
            return UrlEncodeBytesToBytesInternal(bytes, 0, bytes.Length, false);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.UrlEncodeToBytes2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static byte[] UrlEncodeToBytes(byte[] bytes) {
            if (bytes == null)
                return null;
            return UrlEncodeToBytes(bytes, 0, bytes.Length);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.UrlEncodeToBytes3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static byte[] UrlEncodeToBytes(byte[] bytes, int offset, int count) {
            if (bytes == null && count == 0)
                return null;
            if (bytes == null) {
                throw new ArgumentNullException("bytes");
            }
            if (offset < 0 || offset > bytes.Length) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (count < 0 || offset+count > bytes.Length) {
                throw new ArgumentOutOfRangeException("count");
            }
            return UrlEncodeBytesToBytesInternal(bytes, offset, count, true);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.UrlEncodeUnicode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string UrlEncodeUnicode(string str) {
            if (str == null)
                return null;
            return UrlEncodeUnicodeStringToStringInternal(str, false);
        }

        //  Helper to encode the non-ASCII url characters only
        internal static String UrlEncodeUnicodeNonAscii(string str) {
            if (str == null)
                return null;
            return UrlEncodeUnicodeStringToStringInternal(str, true);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.UrlEncodeUnicodeToBytes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static byte[] UrlEncodeUnicodeToBytes(string str) {
            if (str == null)
                return null;
            return Encoding.ASCII.GetBytes(UrlEncodeUnicode(str));
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.UrlDecode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string UrlDecode(string str) {
            if (str == null)
                return null;
            return UrlDecode(str, Encoding.UTF8);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.UrlDecode1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string UrlDecode(string str, Encoding e) {
            if (str == null)
                return null;
            return UrlDecodeStringFromStringInternal(str, e);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.UrlDecode2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string UrlDecode(byte[] bytes, Encoding e) {
            if (bytes == null)
                return null;
            return UrlDecode(bytes, 0, bytes.Length, e);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.UrlDecode3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string UrlDecode(byte[] bytes, int offset, int count, Encoding e) {
            if (bytes == null && count == 0)
                return null;
            if (bytes == null) {
                throw new ArgumentNullException("bytes");
            }
            if (offset < 0 || offset > bytes.Length) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (count < 0 || offset+count > bytes.Length) {
                throw new ArgumentOutOfRangeException("count");
            }
            return UrlDecodeStringFromBytesInternal(bytes, offset, count, e);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.UrlDecodeToBytes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static byte[] UrlDecodeToBytes(string str) {
            if (str == null)
                return null;
            return UrlDecodeToBytes(str, Encoding.UTF8);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.UrlDecodeToBytes1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static byte[] UrlDecodeToBytes(string str, Encoding e) {
            if (str == null)
                return null;
            return UrlDecodeToBytes(e.GetBytes(str));
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.UrlDecodeToBytes2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static byte[] UrlDecodeToBytes(byte[] bytes) {
            if (bytes == null)
                return null;
            return UrlDecodeToBytes(bytes, 0, (bytes != null) ? bytes.Length : 0);
        }

        /// <include file='doc\httpserverutility.uex' path='docs/doc[@for="HttpUtility.UrlDecodeToBytes3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static byte[] UrlDecodeToBytes(byte[] bytes, int offset, int count) {
            if (bytes == null && count == 0)
                return null;
            if (bytes == null) {
                throw new ArgumentNullException("bytes");
            }
            if (offset < 0 || offset > bytes.Length) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (count < 0 || offset+count > bytes.Length) {
                throw new ArgumentOutOfRangeException("count");
            }
            return UrlDecodeBytesFromBytesInternal(bytes, offset, count);
        }

        //
        //  Implementation for encoding
        //

        private static byte[] UrlEncodeBytesToBytesInternal(byte[] bytes, int offset, int count, bool alwaysCreateReturnValue) {
            int cSpaces = 0;
            int cUnsafe = 0;

            // count them first
            for (int i = 0; i < count; i++) {
                char ch = (char)bytes[offset+i];

                if (ch == ' ')
                    cSpaces++;
                else if (!IsSafe(ch))
                    cUnsafe++;
            }

            // nothing to expand?
            if (!alwaysCreateReturnValue && cSpaces == 0 && cUnsafe == 0)
                return bytes;

            // expand not 'safe' characters into %XX, spaces to +s
            byte[] expandedBytes = new byte[count + cUnsafe*2];
            int pos = 0;

            for (int i = 0; i < count; i++) {
                byte b = bytes[offset+i];
                char ch = (char)b;

                if (IsSafe(ch)) {
                    expandedBytes[pos++] = b;
                }
                else if (ch == ' ') {
                    expandedBytes[pos++] = (byte)'+';
                }
                else {
                    expandedBytes[pos++] = (byte)'%';
                    expandedBytes[pos++] = (byte)IntToHex((b >> 4) & 0xf);
                    expandedBytes[pos++] = (byte)IntToHex(b & 0x0f);
                }
            }

            return expandedBytes;
        }

        private static byte[] UrlEncodeBytesToBytesInternalNonAscii(byte[] bytes, int offset, int count, bool alwaysCreateReturnValue) {
            int cNonAscii = 0;

            // count them first
            for (int i = 0; i < count; i++) {
                if ((bytes[offset+i] & 0x80) != 0)
                    cNonAscii++;
            }

            // nothing to expand?
            if (!alwaysCreateReturnValue && cNonAscii == 0)
                return bytes;

            // expand not 'safe' characters into %XX, spaces to +s
            byte[] expandedBytes = new byte[count + cNonAscii*2];
            int pos = 0;

            for (int i = 0; i < count; i++) {
                byte b = bytes[offset+i];

                if ((bytes[offset+i] & 0x80) == 0) {
                    expandedBytes[pos++] = b;
                }
                else {
                    expandedBytes[pos++] = (byte)'%';
                    expandedBytes[pos++] = (byte)IntToHex((b >> 4) & 0xf);
                    expandedBytes[pos++] = (byte)IntToHex(b & 0x0f);
                }
            }

            return expandedBytes;
        }


        private static string UrlEncodeUnicodeStringToStringInternal(string s, bool ignoreAscii) {
            int l = s.Length;
            StringBuilder sb = new StringBuilder(l);

            for (int i = 0; i < l; i++) {
                char ch = s[i];

                if ((ch & 0xff80) == 0) {  // 7 bit?
                    if (ignoreAscii || IsSafe(ch)) {
                        sb.Append(ch);
                    }
                    else if (ch == ' ') {
                        sb.Append('+');
                    }
                    else {
                        sb.Append('%');
                        sb.Append(IntToHex((ch >>  4) & 0xf));
                        sb.Append(IntToHex((ch      ) & 0xf));
                    }
                }
                else { // arbitrary Unicode?
                    sb.Append("%u");
                    sb.Append(IntToHex((ch >> 12) & 0xf));
                    sb.Append(IntToHex((ch >>  8) & 0xf));
                    sb.Append(IntToHex((ch >>  4) & 0xf));
                    sb.Append(IntToHex((ch      ) & 0xf));
                }
            }

            return sb.ToString();
        }

        //
        //  Implementation for decoding
        //

        // Internal class to facilitate URL decoding -- keeps char buffer and byte buffer, allows appending of either chars or bytes
        private class UrlDecoder {
            private int _bufferSize;

            // Accumulate characters in a special array
            private int _numChars;
            private char[] _charBuffer;

            // Accumulate bytes for decoding into characters in a special array
            private int _numBytes;
            private byte[] _byteBuffer;

            // Encoding to convert chars to bytes
            private Encoding _encoding;

            private void FlushBytes() {
                if (_numBytes > 0) {
                    _numChars += _encoding.GetChars(_byteBuffer, 0, _numBytes, _charBuffer, _numChars);
                    _numBytes = 0;
                }
            }

            internal UrlDecoder(int bufferSize, Encoding encoding) {
                _bufferSize = bufferSize;
                _encoding = encoding;

                _charBuffer = new char[bufferSize];
                // byte buffer created on demand
            }

            internal void AddChar(char ch) {
                if (_numBytes > 0)
                    FlushBytes();

                _charBuffer[_numChars++] = ch;
            }

            internal void AddByte(byte b) {
                // if there are no pending bytes treat 7 bit bytes as characters
                // this optimization is temp disable as it doesn't work for some encodings
/*
                if (_numBytes == 0 && ((b & 0x80) == 0)) {
                    AddChar((char)b);
                }
                else 
*/
                {
                    if (_byteBuffer == null)
                        _byteBuffer = new byte[_bufferSize];

                    _byteBuffer[_numBytes++] = b;
                }
            }

            internal String GetString() {
                if (_numBytes > 0)
                    FlushBytes();

                if (_numChars > 0)
                    return new String(_charBuffer, 0, _numChars);
                else
                    return String.Empty;
            }
        }

        private static string UrlDecodeStringFromStringInternal(string s, Encoding e) {
            int count = s.Length;
            UrlDecoder helper = new UrlDecoder(count, e);

            // go through the string's chars collapsing %XX and %uXXXX and
            // appending each char as char, with exception of %XX constructs
            // that are appended as bytes

            for (int pos = 0; pos < count; pos++) {
                char ch = s[pos];

                if (ch == '+') {
                    ch = ' ';
                }
                else if (ch == '%' && pos < count-2) {
                    if (s[pos+1] == 'u' && pos < count-5) {
                        int h1 = HexToInt(s[pos+2]);
                        int h2 = HexToInt(s[pos+3]);
                        int h3 = HexToInt(s[pos+4]);
                        int h4 = HexToInt(s[pos+5]);

                        if (h1 >= 0 && h2 >= 0 && h3 >= 0 && h4 >= 0) {   // valid 4 hex chars
                            ch = (char)((h1 << 12) | (h2 << 8) | (h3 << 4) | h4);
                            pos += 5;

                            // only add as char
                            helper.AddChar(ch);
                            continue;
                        }
                    }
                    else {
                        int h1 = HexToInt(s[pos+1]);
                        int h2 = HexToInt(s[pos+2]);

                        if (h1 >= 0 && h2 >= 0) {     // valid 2 hex chars
                            byte b = (byte)((h1 << 4) | h2);
                            pos += 2;

                            // don't add as char
                            helper.AddByte(b);
                            continue;
                        }
                    }
                }

                if ((ch & 0xFF80) == 0)
                    helper.AddByte((byte)ch); // 7 bit have to go as bytes because of Unicode
                else
                    helper.AddChar(ch);
            }

            return helper.GetString();
        }

        private static string UrlDecodeStringFromBytesInternal(byte[] buf, int offset, int count, Encoding e) {
            UrlDecoder helper = new UrlDecoder(count, e);

            // go through the bytes collapsing %XX and %uXXXX and appending
            // each byte as byte, with exception of %uXXXX constructs that
            // are appended as chars

            for (int i = 0; i < count; i++) {
                int pos = offset + i;
                byte b = buf[pos];

                // The code assumes that + and % cannot be in multibyte sequence

                if (b == '+') {
                    b = (byte)' ';
                }
                else if (b == '%' && i < count-2) {
                    if (buf[pos+1] == 'u' && i < count-5) {
                        int h1 = HexToInt((char)buf[pos+2]);
                        int h2 = HexToInt((char)buf[pos+3]);
                        int h3 = HexToInt((char)buf[pos+4]);
                        int h4 = HexToInt((char)buf[pos+5]);

                        if (h1 >= 0 && h2 >= 0 && h3 >= 0 && h4 >= 0) {   // valid 4 hex chars
                            char ch = (char)((h1 << 12) | (h2 << 8) | (h3 << 4) | h4);
                            i += 5;

                            // don't add as byte
                            helper.AddChar(ch);
                            continue;
                        }
                    }
                    else {
                        int h1 = HexToInt((char)buf[pos+1]);
                        int h2 = HexToInt((char)buf[pos+2]);

                        if (h1 >= 0 && h2 >= 0) {     // valid 2 hex chars
                            b = (byte)((h1 << 4) | h2);
                            i += 2;
                        }
                    }
                }

                helper.AddByte(b);
            }

            return helper.GetString();
        }

        private static byte[] UrlDecodeBytesFromBytesInternal(byte[] buf, int offset, int count) {
            int decodedBytesCount = 0;
            byte[] decodedBytes = new byte[count];

            for (int i = 0; i < count; i++) {
                int pos = offset + i;
                byte b = buf[pos];

                if (b == '+') {
                    b = (byte)' ';
                }
                else if (b == '%' && i < count-2) {
                    int h1 = HexToInt((char)buf[pos+1]);
                    int h2 = HexToInt((char)buf[pos+2]);

                    if (h1 >= 0 && h2 >= 0) {     // valid 2 hex chars
                        b = (byte)((h1 << 4) | h2);
                        i += 2;
                    }
                }

                decodedBytes[decodedBytesCount++] = b;
            }

            if (decodedBytesCount < decodedBytes.Length) {
                byte[] newDecodedBytes = new byte[decodedBytesCount];
                Array.Copy(decodedBytes, newDecodedBytes, decodedBytesCount);
                decodedBytes = newDecodedBytes;
            }

            return decodedBytes;
        }

        //
        // Private helpers for URL encoding/decoding
        //

        private static int HexToInt(char h) {
            return( h >= '0' && h <= '9' ) ? h - '0' :
            ( h >= 'a' && h <= 'f' ) ? h - 'a' + 10 :
            ( h >= 'A' && h <= 'F' ) ? h - 'A' + 10 :
            -1;
        }

        private static char IntToHex(int n) {
            Debug.Assert(n < 0x10);

            if (n <= 9)
                return(char)(n + (int)'0');
            else
                return(char)(n - 10 + (int)'a');
        }

        // Set of safe chars, from RFC 1738.4 minus '+'
        private static bool IsSafe(char ch) {
            if (ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9')
                return true;

            switch (ch) {
                case '-':
                case '_':
                case '.':
                case '!':
                case '*':
                case '\'':
                case '(':
                case ')':
                    return true;
            }

            return false;
        }

        //////////////////////////////////////////////////////////////////////////
        //
        //  Misc helpers
        //
        //////////////////////////////////////////////////////////////////////////

        internal static String FormatHttpDateTime(DateTime dt) {
            if (dt < DateTime.MaxValue.AddDays(-1) && dt > DateTime.MinValue.AddDays(1))
                dt = dt.ToUniversalTime();
            return dt.ToString("R", DateTimeFormatInfo.InvariantInfo);
        }

        internal static String FormatHttpDateTimeUtc(DateTime dt) {
            return dt.ToString("R", DateTimeFormatInfo.InvariantInfo);
        }

        internal static String FormatHttpCookieDateTime(DateTime dt) {
            if (dt < DateTime.MaxValue.AddDays(-1) && dt > DateTime.MinValue.AddDays(1))
                dt = dt.ToUniversalTime();
            return dt.ToString("ddd, dd-MMM-yyyy HH':'mm':'ss 'GMT'", DateTimeFormatInfo.InvariantInfo);
        }
    }

    // helper class for lookup of HTML encoding entities
    internal class HtmlEntities {
        // The list is from http://www.w3.org/TR/REC-html40/sgml/entities.html
        private static String[] _entitiesList = new String[] {
            "\x0022-quot",
            "\x0026-amp",
            "\x003c-lt",
            "\x003e-gt",
            "\x00a0-nbsp",
            "\x00a1-iexcl",
            "\x00a2-cent",
            "\x00a3-pound",
            "\x00a4-curren",
            "\x00a5-yen",
            "\x00a6-brvbar",
            "\x00a7-sect",
            "\x00a8-uml",
            "\x00a9-copy",
            "\x00aa-ordf",
            "\x00ab-laquo",
            "\x00ac-not",
            "\x00ad-shy",
            "\x00ae-reg",
            "\x00af-macr",
            "\x00b0-deg",
            "\x00b1-plusmn",
            "\x00b2-sup2",
            "\x00b3-sup3",
            "\x00b4-acute",
            "\x00b5-micro",
            "\x00b6-para",
            "\x00b7-middot",
            "\x00b8-cedil",
            "\x00b9-sup1",
            "\x00ba-ordm",
            "\x00bb-raquo",
            "\x00bc-frac14",
            "\x00bd-frac12",
            "\x00be-frac34",
            "\x00bf-iquest",
            "\x00c0-Agrave",
            "\x00c1-Aacute",
            "\x00c2-Acirc",
            "\x00c3-Atilde",
            "\x00c4-Auml",
            "\x00c5-Aring",
            "\x00c6-AElig",
            "\x00c7-Ccedil",
            "\x00c8-Egrave",
            "\x00c9-Eacute",
            "\x00ca-Ecirc",
            "\x00cb-Euml",
            "\x00cc-Igrave",
            "\x00cd-Iacute",
            "\x00ce-Icirc",
            "\x00cf-Iuml",
            "\x00d0-ETH",
            "\x00d1-Ntilde",
            "\x00d2-Ograve",
            "\x00d3-Oacute",
            "\x00d4-Ocirc",
            "\x00d5-Otilde",
            "\x00d6-Ouml",
            "\x00d7-times",
            "\x00d8-Oslash",
            "\x00d9-Ugrave",
            "\x00da-Uacute",
            "\x00db-Ucirc",
            "\x00dc-Uuml",
            "\x00dd-Yacute",
            "\x00de-THORN",
            "\x00df-szlig",
            "\x00e0-agrave",
            "\x00e1-aacute",
            "\x00e2-acirc",
            "\x00e3-atilde",
            "\x00e4-auml",
            "\x00e5-aring",
            "\x00e6-aelig",
            "\x00e7-ccedil",
            "\x00e8-egrave",
            "\x00e9-eacute",
            "\x00ea-ecirc",
            "\x00eb-euml",
            "\x00ec-igrave",
            "\x00ed-iacute",
            "\x00ee-icirc",
            "\x00ef-iuml",
            "\x00f0-eth",
            "\x00f1-ntilde",
            "\x00f2-ograve",
            "\x00f3-oacute",
            "\x00f4-ocirc",
            "\x00f5-otilde",
            "\x00f6-ouml",
            "\x00f7-divide",
            "\x00f8-oslash",
            "\x00f9-ugrave",
            "\x00fa-uacute",
            "\x00fb-ucirc",
            "\x00fc-uuml",
            "\x00fd-yacute",
            "\x00fe-thorn",
            "\x00ff-yuml",
            "\x0152-OElig",
            "\x0153-oelig",
            "\x0160-Scaron",
            "\x0161-scaron",
            "\x0178-Yuml",
            "\x0192-fnof",
            "\x02c6-circ",
            "\x02dc-tilde",
            "\x0391-Alpha",
            "\x0392-Beta",
            "\x0393-Gamma",
            "\x0394-Delta",
            "\x0395-Epsilon",
            "\x0396-Zeta",
            "\x0397-Eta",
            "\x0398-Theta",
            "\x0399-Iota",
            "\x039a-Kappa",
            "\x039b-Lambda",
            "\x039c-Mu",
            "\x039d-Nu",
            "\x039e-Xi",
            "\x039f-Omicron",
            "\x03a0-Pi",
            "\x03a1-Rho",
            "\x03a3-Sigma",
            "\x03a4-Tau",
            "\x03a5-Upsilon",
            "\x03a6-Phi",
            "\x03a7-Chi",
            "\x03a8-Psi",
            "\x03a9-Omega",
            "\x03b1-alpha",
            "\x03b2-beta",
            "\x03b3-gamma",
            "\x03b4-delta",
            "\x03b5-epsilon",
            "\x03b6-zeta",
            "\x03b7-eta",
            "\x03b8-theta",
            "\x03b9-iota",
            "\x03ba-kappa",
            "\x03bb-lambda",
            "\x03bc-mu",
            "\x03bd-nu",
            "\x03be-xi",
            "\x03bf-omicron",
            "\x03c0-pi",
            "\x03c1-rho",
            "\x03c2-sigmaf",
            "\x03c3-sigma",
            "\x03c4-tau",
            "\x03c5-upsilon",
            "\x03c6-phi",
            "\x03c7-chi",
            "\x03c8-psi",
            "\x03c9-omega",
            "\x03d1-thetasym",
            "\x03d2-upsih",
            "\x03d6-piv",
            "\x2002-ensp",
            "\x2003-emsp",
            "\x2009-thinsp",
            "\x200c-zwnj",
            "\x200d-zwj",
            "\x200e-lrm",
            "\x200f-rlm",
            "\x2013-ndash",
            "\x2014-mdash",
            "\x2018-lsquo",
            "\x2019-rsquo",
            "\x201a-sbquo",
            "\x201c-ldquo",
            "\x201d-rdquo",
            "\x201e-bdquo",
            "\x2020-dagger",
            "\x2021-Dagger",
            "\x2022-bull",
            "\x2026-hellip",
            "\x2030-permil",
            "\x2032-prime",
            "\x2033-Prime",
            "\x2039-lsaquo",
            "\x203a-rsaquo",
            "\x203e-oline",
            "\x2044-frasl",
            "\x20ac-euro",
            "\x2111-image",
            "\x2118-weierp",
            "\x211c-real",
            "\x2122-trade",
            "\x2135-alefsym",
            "\x2190-larr",
            "\x2191-uarr",
            "\x2192-rarr",
            "\x2193-darr",
            "\x2194-harr",
            "\x21b5-crarr",
            "\x21d0-lArr",
            "\x21d1-uArr",
            "\x21d2-rArr",
            "\x21d3-dArr",
            "\x21d4-hArr",
            "\x2200-forall",
            "\x2202-part",
            "\x2203-exist",
            "\x2205-empty",
            "\x2207-nabla",
            "\x2208-isin",
            "\x2209-notin",
            "\x220b-ni",
            "\x220f-prod",
            "\x2211-sum",
            "\x2212-minus",
            "\x2217-lowast",
            "\x221a-radic",
            "\x221d-prop",
            "\x221e-infin",
            "\x2220-ang",
            "\x2227-and",
            "\x2228-or",
            "\x2229-cap",
            "\x222a-cup",
            "\x222b-int",
            "\x2234-there4",
            "\x223c-sim",
            "\x2245-cong",
            "\x2248-asymp",
            "\x2260-ne",
            "\x2261-equiv",
            "\x2264-le",
            "\x2265-ge",
            "\x2282-sub",
            "\x2283-sup",
            "\x2284-nsub",
            "\x2286-sube",
            "\x2287-supe",
            "\x2295-oplus",
            "\x2297-otimes",
            "\x22a5-perp",
            "\x22c5-sdot",
            "\x2308-lceil",
            "\x2309-rceil",
            "\x230a-lfloor",
            "\x230b-rfloor",
            "\x2329-lang",
            "\x232a-rang",
            "\x25ca-loz",
            "\x2660-spades",
            "\x2663-clubs",
            "\x2665-hearts",
            "\x2666-diams",
        };

        private static Hashtable _entitiesLookupTable;

        private HtmlEntities() {
        }

        internal /*public*/ static char Lookup(String entity) {
            if (_entitiesLookupTable == null) {
                // populate hashtable on demand
                lock (typeof(HtmlEntities)) {
                    if (_entitiesLookupTable == null) {
                        Hashtable t = new Hashtable();

                        foreach (String s in _entitiesList)
                            t[s.Substring(2)] = s[0];  // 1st char is the code, 2nd '-'

                        _entitiesLookupTable = t;
                    }
                }
            }

            Object obj = _entitiesLookupTable[entity];

            if (obj != null)
                return (char)obj;
            else
                return (char)0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpvaluecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpValueCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Ordered String/String[] collection of name/value pairs
 * Based on NameValueCollection -- adds parsing from string, cookie collection
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web {
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters;
    using System.Text;
    using System.Runtime.InteropServices;

    using System.Collections;
    using System.Collections.Specialized;
    using System.Globalization;
    using System.Web.Util;

    [Serializable()]
    internal class HttpValueCollection : NameValueCollection {
        internal HttpValueCollection() {
        }

        internal HttpValueCollection(String str) : this(str, false, false, Encoding.UTF8) {
        }

        internal HttpValueCollection(String str, bool readOnly) : this(str, readOnly, false, Encoding.UTF8) {
        }

        internal HttpValueCollection(String str, bool readOnly, bool urlencoded, Encoding encoding) {
            if (str != null && str.Length > 0)
                FillFromString(str, urlencoded, encoding);

            IsReadOnly = readOnly;
        }

        internal HttpValueCollection(int capacity) : base(capacity) {
        }

        internal HttpValueCollection(int capacity, String str) : this(capacity, str, false, false, Encoding.UTF8) {
        }

        internal HttpValueCollection(int capacity, String str, bool readOnly) : this(capacity, str, readOnly, false, Encoding.UTF8) {
        }

        internal HttpValueCollection(int capacity, String str, bool readOnly, bool urlencoded, Encoding encoding) : base(capacity) {
            if (str != null && str.Length > 0)
                FillFromString(str, urlencoded, encoding);

            IsReadOnly = readOnly;
        }

        protected HttpValueCollection(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

        internal void MakeReadOnly() {
            IsReadOnly = true;
        }

        internal void MakeReadWrite() {
            IsReadOnly = false;
        }

        internal void FillFromString(String s) {
            FillFromString(s, false, null);
        }

        internal void FillFromString(String s, bool urlencoded, Encoding encoding) {
            int l = (s != null) ? s.Length : 0;
            int i = 0;

            while (i < l) {
                // find next & while noting first = on the way (and if there are more)

                int si = i;
                int ti = -1;

                while (i < l) {
                    char ch = s[i];

                    if (ch == '=') {
                        if (ti < 0)
                            ti = i;
                    }
                    else if (ch == '&') {
                        break;
                    }

                    i++;
                }

                // extract the name / value pair

                String name = null;
                String value = null;

                if (ti >= 0) {
                    name = s.Substring(si, ti-si);
                    value = s.Substring(ti+1, i-ti-1);
                }
                else {
                    value = s.Substring(si, i-si);
                }

                // add name / value pair to the collection

                if (urlencoded)
                    Add(
                       HttpUtility.UrlDecode(name, encoding), 
                       HttpUtility.UrlDecode(value, encoding));
                else
                    Add(name, value);

                // trailing '&'

                if (i == l-1 && s[i] == '&')
                    Add(null, "");

                i++;
            }
        }

        internal void FillFromEncodedBytes(byte[] bytes, Encoding encoding) {
            int l = (bytes != null) ? bytes.Length : 0;
            int i = 0;

            while (i < l) {
                // find next & while noting first = on the way (and if there are more)

                int si = i;
                int ti = -1;

                while (i < l) {
                    byte b = bytes[i];

                    if (b == '=') {
                        if (ti < 0)
                            ti = i;
                    }
                    else if (b == '&') {
                        break;
                    }

                    i++;
                }

                // extract the name / value pair

                String name, value;

                if (ti >= 0) {
                    name  = HttpUtility.UrlDecode(bytes, si, ti-si, encoding);
                    value = HttpUtility.UrlDecode(bytes, ti+1, i-ti-1, encoding);
                }
                else {
                    name = null;
                    value = HttpUtility.UrlDecode(bytes, si, i-si, encoding);
                }

                // add name / value pair to the collection

                Add(name, value);

                // trailing '&'

                if (i == l-1 && bytes[i] == '&')
                    Add(null, "");

                i++;
            }
        }

        internal void Add(HttpCookieCollection c) {
            int n = c.Count;

            for (int i = 0; i < n; i++) {
                HttpCookie cookie = c.Get(i);
                Add(cookie.Name, cookie.Value);
            }
        }

        internal void Reset() {
            Clear();
        }

        public override String ToString() {
            return ToString(true);
        }

        internal virtual String ToString(bool urlencoded) {
            StringBuilder s = new StringBuilder();
            int n = Count;
            String key, keyPrefix, item;

            for (int i = 0; i < n; i++) {
                key = GetKey(i);
                if (urlencoded)
                    key = HttpUtility.UrlEncodeUnicode(key);
                keyPrefix = (key != null && key.Length > 0) ? (key + "=") : "";

                ArrayList values = (ArrayList)BaseGet(i);
                int numValues = (values != null) ? values.Count : 0;

                if (i > 0)
                    s.Append('&');

                if (numValues == 1) {
                    s.Append(keyPrefix);
                    item = (String)values[0];
                    if (urlencoded)
                        item = HttpUtility.UrlEncodeUnicode(item);
                    s.Append(item);
                }
                else if (numValues == 0) {
                    s.Append(keyPrefix);
                }
                else {
                    for (int j = 0; j < numValues; j++) {
                        if (j > 0)
                            s.Append('&');
                        s.Append(keyPrefix);
                        item = (String)values[j];
                        if (urlencoded)
                            item = HttpUtility.UrlEncodeUnicode(item);
                        s.Append(item);
                    }
                }
            }

            return s.ToString();
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Response Writer and Stream implementation
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web {
    using System.Text;
    using System.Runtime.Serialization.Formatters;

    using System.Collections;
    using System.IO;
    using System.Globalization;

    using System.Web.Util;
    using System.Security.Permissions;

    //
    //  HttpWriter buffer recycling support
    //
    
    /*
     * Constants for buffering
     */
    internal class BufferingParams {
        internal const int OUTPUT_BUFFER_SIZE         = 31*1024;    // output is a chain of this size buffers
        internal const int MAX_FREE_BYTES_TO_CACHE    = 4096;       // don't compress when taking snapshot if free bytes < this
        internal const int MAX_FREE_OUTPUT_BUFFERS    = 64;         // keep this number of unused buffers
        internal const int CHAR_BUFFER_SIZE           = 1024;       // size of the buffers for chat conversion to bytes
        internal const int MAX_FREE_CHAR_BUFFERS      = 64;         // keep this number of unused buffers
        internal const int MAX_BYTES_TO_COPY          = 128;        // copy results of char conversion vs using recycleable buffers
        internal const int MAX_RESOURCE_BYTES_TO_COPY = 4*1024;       // resource strings below this size are copied to buffers
        
        internal BufferingParams() {}
    }

    /*
     * Interface implemented by elements of the response buffer list
     */
    internal interface IHttpResponseElement {
        int GetSize();
        byte[] GetBytes();                   // required for filtering
        void Send(HttpWorkerRequest wr);
    }

    /*
     * Memory response buffer
     */
    internal class HttpResponseBufferElement : IHttpResponseElement {
        private int _size;
        private int _free;
        private byte[] _data;
        private bool _recycle;

        private static UbyteBufferAllocator s_Allocator =
        new UbyteBufferAllocator(BufferingParams.OUTPUT_BUFFER_SIZE,
                                 BufferingParams.MAX_FREE_OUTPUT_BUFFERS);


        /*
         * Constructor that creates an empty buffer
         */
        internal HttpResponseBufferElement() {
            _data = (byte[])s_Allocator.GetBuffer();
            _size = BufferingParams.OUTPUT_BUFFER_SIZE;
            _free = _size;
            _recycle = true;
        }

        /*
         * Constructor that accepts the data buffer and holds on to it
         */
        internal HttpResponseBufferElement(byte[] data, int size) {
            _data = data;
            _size = size;
            _free = 0;
            _recycle = false;
        }

        /*
         *  Close the buffer copying the data
         *  (needed to 'compress' buffers for caching)
         */

        internal HttpResponseBufferElement Clone() {
            int clonedSize = _size - _free;
            byte[] clonedData = new byte[clonedSize];
            Buffer.BlockCopy(_data, 0, clonedData, 0, clonedSize);
            return new HttpResponseBufferElement(clonedData, clonedSize);
        }

        /*
         * Recycle the buffer
         */
        internal void Recycle() {
            if (_recycle && _data != null) {
                s_Allocator.ReuseBuffer(_data);
                _data = null;
                _free = 0;
                _recycle = false;
            }
        }

        /*
         * Mark not to be recyclable
         */
        internal void DisableRecycling() {
            _recycle = false;
        }

        //
        // Direct access to buffer for in-place char-to-byte conversion
        //

        internal byte[] ByteBuffer {
            get { return _data;}
        }

        internal int ByteOffset {
            get { return(_size - _free);}
        }

        internal int FreeBytes {
            get { return _free;}
            set { _free = value;}
        }

        internal int Append(Array data, int offset, int size) {
            if (_free == 0 || size == 0)
                return 0;
            int n = (_free >= size) ? size : _free;
            Buffer.BlockCopy(data, offset, _data, _size-_free, n);
            _free -= n;
            return n;
        }

        internal int Append(IntPtr data, int offset, int size) {
            if (_free == 0 || size == 0)
                return 0;
            int n = (_free >= size) ? size : _free;
            StringResourceManager.CopyResource(data, offset, _data, _size-_free, n);
            _free -= n;
            return n;
        }

        //
        // IHttpResponseElement implementation
        //

        /*
         * Get number of bytes
         */
        /*public*/ int IHttpResponseElement.GetSize() {
            return(_size - _free);
        }

        /*
         * Get bytes (for filtering)
         */
        /*public*/ byte[] IHttpResponseElement.GetBytes() {
            return _data;
        }

        /*
         * Write HttpWorkerRequest
         */
        /*public*/ void IHttpResponseElement.Send(HttpWorkerRequest wr) {
            int n = _size - _free;
            if (n > 0)
                wr.SendResponseFromMemory(_data, n);
        }
    }

    /*
     * Response element where data comes from resource
     */
    internal class HttpResourceResponseElement : IHttpResponseElement {
        private IntPtr _data;
        private int   _offset;
        private int   _size;

        internal HttpResourceResponseElement(IntPtr data, int offset, int size) {
            _data = data;
            _offset = offset;
            _size = size;
        }

        //
        // IHttpResponseElement implementation
        //

        /*
         * Get number of bytes
         */
        /*public*/ int IHttpResponseElement.GetSize() {
            return _size;
        }

        /*
         * Get bytes (used only for filtering)
         */
        /*public*/ byte[] IHttpResponseElement.GetBytes() {
            if (_size > 0) {
                byte[] data = new byte[_size];
                StringResourceManager.CopyResource(_data, _offset, data, 0, _size);
                return data;
            }
            else {
                return new byte[0];
            }
        }

        /*
         * Write HttpWorkerRequest
         */
        /*public*/ void IHttpResponseElement.Send(HttpWorkerRequest wr) {
            if (_size > 0) {
                wr.SendResponseFromMemory(new IntPtr(_data.ToInt64()+_offset), _size);
            }
        }
    }

    /*
     * Response element where data comes from file
     */
    internal class HttpFileResponseElement : IHttpResponseElement {
        private String _filename;
        private IntPtr _fileHandle;
        private long   _offset;
        private long   _size;

        /*
         * Constructor from filename and range
         */
        internal HttpFileResponseElement(String filename, long offset, long size) {
            _filename = filename;
            _fileHandle = (IntPtr)0;
            _offset = offset;
            _size = size;
        }

        /*
         * Constructor from file handle and range
         */
        internal HttpFileResponseElement(IntPtr fileHandle, long offset, long size) {
            _filename = null;
            _fileHandle = fileHandle;
            _offset = offset;
            _size = size;
        }

        //
        // IHttpResponseElement implementation
        //

        /*
         * Get number of bytes
         */
        /*public*/ int IHttpResponseElement.GetSize() {
            return(int)_size;
        }

        /*
         * Get bytes (for filtering)
         */
        /*public*/ byte[] IHttpResponseElement.GetBytes() {
            if (_size == 0)
                return new byte[0];

            byte[] data = null;
            FileStream f = null;

            try {
                if (_filename == null)
                    f = new FileStream(_fileHandle, FileAccess.Read, false);
                else
                    f = new FileStream(_filename, FileMode.Open, FileAccess.Read, FileShare.Read);

                long fileSize = f.Length;

                if (_offset < 0 || _size > fileSize - _offset)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_range));

                if (_offset > 0)
                    f.Seek(_offset, SeekOrigin.Begin);

                data = new byte[(int)_size];                                   
                f.Read(data, 0, (int)_size);            
            }
            finally {
                if (f != null)
                    f.Close();
            }

            return data;
        }

        /*
         * Write HttpWorkerRequest
         */
        /*public*/ void IHttpResponseElement.Send(HttpWorkerRequest wr) {
            if (_size > 0) {
                if (_filename != null)
                    wr.SendResponseFromFile(_filename, _offset, _size);
                else
                    wr.SendResponseFromFile(_fileHandle, _offset, _size);
            }
        }
    }

    /*
     * Response element for substituiton
     */
    internal class HttpSubstBlockResponseElement : IHttpResponseElement {
        private String _name;
        private byte[] _data;
        private int _size;

        /*
         * Constructor given the name and the data (fill char converted to bytes)
         * holds on to the data
         */
        internal HttpSubstBlockResponseElement(String name, byte[] data, int size) {
            _name = name;
            _data = data;
            _size = size;
        }

        internal String Name {
            get { return _name;}
        }

        internal byte[] Data {
            get { return _data;}
        }

        //
        // IHttpResponseElement implementation
        //

        /*
         * Get number of bytes
         */
        /*public*/ int IHttpResponseElement.GetSize() {
            return _size;
        }

        /*
         * Get bytes (for filtering)
         */
        /*public*/ byte[] IHttpResponseElement.GetBytes() {
            return _data;
        }

        /*
         * Write HttpWorkerRequest (only used if substitution never happened)
         */
        /*public*/ void IHttpResponseElement.Send(HttpWorkerRequest wr) {
            if (_size > 0)
                wr.SendResponseFromMemory(_data, _size);
        }
    }

    /*
     * Stream object synchronized with Writer
     */
    internal class HttpResponseStream : Stream {
        private HttpWriter _writer;

        internal HttpResponseStream(HttpWriter writer) {
            _writer = writer;
        }

        //
        // Public Stream method implementations
        //

        public override bool CanRead {
            get { return false;}
        }

        public override bool CanSeek {
            get { return false;}
        }     

        public override bool CanWrite {
            get { return true;}
        }

        public override long Length {
            get {throw new NotSupportedException();}        
        }

        public override long Position {
            get {throw new NotSupportedException();}

            set {throw new NotSupportedException();}
        }

        public override void Close() {
            _writer.Close();
        }

        public override void Flush() {
            _writer.Flush();
        }

        public override long Seek(long offset, SeekOrigin origin) {
            throw new NotSupportedException();
        }

        public override void SetLength(long value) {
            throw new NotSupportedException();
        }

        public override int Read(byte[] buffer, int offset, int count) {
            throw new NotSupportedException();
        }

        public override void Write(byte[] buffer, int offset, int count) {
            if (offset < 0) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (count < 0) {
                throw new ArgumentOutOfRangeException("count");
            }

            if (buffer.Length - offset < count)
                count = buffer.Length - offset;

            _writer.WriteFromStream(buffer, offset, count);
        }                                     
    }

    /*
     * Stream serving as sink for filters
     */
    internal class HttpResponseStreamFilterSink : HttpResponseStream {
        private bool _filtering = false;

        internal HttpResponseStreamFilterSink(HttpWriter writer) : base(writer) {
        }

        private void VerifyState() {
            // throw exception on unexpected filter writes

            if (!_filtering)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_use_of_response_filter));
        }

        internal bool Filtering {
            get { return _filtering;}
            set { _filtering = value;}
        }

        //
        // Stream methods just go to the base class with exception of Close and Flush that do nothing
        //

        public override void Close() {
            // do nothing
        }

        public override void Flush() {
            // do nothing (this is not a buffering stream)
        }

        public override void Write(byte[] buffer, int offset, int count) {
            VerifyState();
            base.Write(buffer, offset, count);
        }       
    }

    /*
     * TextWriter synchronized with the response object
     */
    /// <include file='doc\HttpWriter.uex' path='docs/doc[@for="HttpWriter"]/*' />
    /// <devdoc>
    ///    <para>A TextWriter class synchronized with the Response object.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpWriter : TextWriter {
        private HttpResponse _response;
        private HttpResponseStream _stream;

        private HttpResponseStreamFilterSink _filterSink;       // sink stream for the filter writes
        private Stream                       _installedFilter;  // installed filtering stream

        private HttpResponseBufferElement _lastBuffer;
        private ArrayList _buffers;

        private char[] _charBuffer;
        private int _charBufferLength;
        private int _charBufferFree;

        private static CharBufferAllocator s_Allocator =
        new CharBufferAllocator(BufferingParams.CHAR_BUFFER_SIZE, 
                                BufferingParams.MAX_FREE_CHAR_BUFFERS);

        // cached data from the response
        // can be invalidated via UpdateResponseXXX methods

        private bool _responseBufferingOn;
        private Encoding _responseEncoding;
        private bool     _responseEncodingUsed;
        private Encoder  _responseEncoder;
        private int      _responseCodePage;
        private bool     _responseCodePageIsAsciiCompat;

        internal HttpWriter(HttpResponse response) {
            _response = response;
            _stream = new HttpResponseStream(this);

            _buffers = new ArrayList();
            _lastBuffer = null;

            _charBuffer = (char[])s_Allocator.GetBuffer();
            _charBufferLength = _charBuffer.Length;
            _charBufferFree = _charBufferLength;

            UpdateResponseBuffering();
            UpdateResponseEncoding();
        }

        internal void UpdateResponseBuffering() {
            _responseBufferingOn = _response.BufferOutput;
        }

        internal void UpdateResponseEncoding() {
            if (_charBufferLength != _charBufferFree)
                FlushCharBuffer(true);

            _responseEncoding = _response.ContentEncoding;
            _responseEncoder = _response.ContentEncoder;
            _responseCodePage = _responseEncoding.CodePage;
            _responseCodePageIsAsciiCompat = CodePageUtils.IsAsciiCompatibleCodePage(_responseCodePage);
        }
        
        /// <include file='doc\HttpWriter.uex' path='docs/doc[@for="HttpWriter.Encoding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Encoding Encoding {
            get {
                return _responseEncoding;
            }
        }
        
        internal void Dispose() {
            // recycle char buffers

            if (_charBuffer != null) {
                s_Allocator.ReuseBuffer(_charBuffer);
                _charBuffer = null;
            }

            // recycle output buffers

            if (_buffers != null) {
                RecycleBuffers();
                _buffers = null;
            }
        }

        private void RecycleBuffers() {
            int n = _buffers.Count;
            for (int i = 0; i < n; i++) {
                Object buf = _buffers[i];
                if (buf is HttpResponseBufferElement)
                    ((HttpResponseBufferElement)buf).Recycle();
            }
        }

        private void ClearCharBuffer() {
            _charBufferFree = _charBufferLength;
        }

        private void FlushCharBuffer(bool flushEncoder) {
            int numChars = _charBufferLength - _charBufferFree;

            Debug.Assert(numChars > 0);

            // remember that response required encoding (to indicate the charset= is needed)
            _responseEncodingUsed = true;

            // estimate conversion size
            int estByteSize = _responseEncoding.GetMaxByteCount(numChars);
            int realByteSize;

            if (estByteSize <= BufferingParams.MAX_BYTES_TO_COPY || !_responseBufferingOn) {
                // small size -- allocate intermediate buffer and copy into the output buffer
                byte[] byteBuffer = new byte[estByteSize];
                realByteSize = _responseEncoder.GetBytes(_charBuffer, 0, numChars, 
                                                         byteBuffer, 0, flushEncoder);
                BufferData(byteBuffer, 0, realByteSize, false);
            }
            else {
                // convert right into the output buffer

                int free = (_lastBuffer != null) ? _lastBuffer.FreeBytes : 0;

                if (free < estByteSize) {
                    // need new buffer -- last one doesn't have enough space
                    _lastBuffer = new HttpResponseBufferElement();
                    _buffers.Add(_lastBuffer);
                    free = _lastBuffer.FreeBytes;
                }

                // byte buffers must be long enough to keep everything in char buffer
                Debug.Assert(free >= estByteSize);

                realByteSize = _responseEncoder.GetBytes(_charBuffer, 0, numChars, 
                                                         _lastBuffer.ByteBuffer, _lastBuffer.ByteOffset, flushEncoder);
                _lastBuffer.FreeBytes = free - realByteSize;
            }

            _charBufferFree = _charBufferLength;
        }

        private void BufferData(byte[] data, int offset, int size, bool needToCopyData) {
            int n;

            // try last buffer
            if (_lastBuffer != null) {
                n = _lastBuffer.Append(data, offset, size);
                size -= n;
                offset += n;
            }
            else if (!needToCopyData && offset == 0 && !_responseBufferingOn) {
                // when not buffering, there is no need for big buffer accumulating multiple writes
                // the byte[] data can be sent as is

                _buffers.Add(new HttpResponseBufferElement(data, size));
                return;
            }

            // do other buffers if needed
            while (size > 0) {
                _lastBuffer = new HttpResponseBufferElement();
                _buffers.Add(_lastBuffer);
                n = _lastBuffer.Append(data, offset, size);
                offset += n;
                size -= n;
            }
        }

        private void BufferResource(IntPtr data, int offset, int size) {
            if (size > BufferingParams.MAX_RESOURCE_BYTES_TO_COPY || !_responseBufferingOn) {
                // for long response strings create its own buffer element to avoid copy cost
                // also, when not buffering, no need for an extra copy (nothing will get accumulated anyway)
                _lastBuffer = null;
                _buffers.Add(new HttpResourceResponseElement(data, offset, size));
                return;
            }

            int n;

            // try last buffer
            if (_lastBuffer != null) {
                n = _lastBuffer.Append(data, offset, size);
                size -= n;
                offset += n;
            }

            // do other buffers if needed
            while (size > 0) {
                _lastBuffer = new HttpResponseBufferElement();
                _buffers.Add(_lastBuffer);
                n = _lastBuffer.Append(data, offset, size);
                offset += n;
                size -= n;
            }
        }

        //
        // 'Write' methods to be called from other internal classes
        //

        internal void WriteFromStream(byte[] data, int offset, int size) {
            if (_charBufferLength != _charBufferFree)
                FlushCharBuffer(true);

            BufferData(data, offset, size, true);

            if (!_responseBufferingOn)
                _response.Flush();
        }

        internal void WriteUTF8ResourceString(IntPtr pv, int offset, int size, bool asciiOnly) {

            if (_responseCodePage == CodePageUtils.CodePageUT8 || // response encoding is UTF8
                (asciiOnly && _responseCodePageIsAsciiCompat)) {  // ASCII resource and ASCII-compat encoding

                _responseEncodingUsed = true;  // note the we used encoding (means that we need to generate charset=) see RAID#93415

                // write bytes directly
                if (_charBufferLength != _charBufferFree)
                    FlushCharBuffer(true);

                BufferResource(pv, offset, size);

                if (!_responseBufferingOn)
                    _response.Flush();
            }
            else {
                // have to re-encode with response's encoding -- use public Write(String)
                Write(StringResourceManager.ResourceToString(pv, offset, size));
            }
        }

        internal void WriteFile(String filename, long offset, long size) {
            if (_charBufferLength != _charBufferFree)
                FlushCharBuffer(true);

            _lastBuffer = null;
            _buffers.Add(new HttpFileResponseElement(filename, offset, size));

            if (!_responseBufferingOn)
                _response.Flush();
        }

        internal void WriteFile(IntPtr fileHandle, long offset, long size) {
            if (_charBufferLength != _charBufferFree)
                FlushCharBuffer(true);

            _lastBuffer = null;
            _buffers.Add(new HttpFileResponseElement(fileHandle, offset, size));

            if (!_responseBufferingOn)
                _response.Flush();
        }

#if UNUSED
        //
        // Support for substitution blocks
        //

        internal void WriteSubstBlock(String name, String defaultValue) {
            if (_charBufferLength != _charBufferFree)
                FlushCharBuffer(true);

            _lastBuffer = null;

            // convert filler to byte array bytes
            int numChars = defaultValue.Length;
            int maxNumBytes = _responseEncoding.GetMaxByteCount(numChars);
            byte[] fillerBytes = new byte[maxNumBytes];
            int numBytes = _responseEncoder.GetBytes(defaultValue.ToCharArray(), 0, numChars, fillerBytes, 0, true);

            // add new substitution block to the buffer list
            _buffers.Add(new HttpSubstBlockResponseElement(name, fillerBytes, numBytes));
        }

        internal String[] GetSubstitutionBlockNames() {
            int count = 0;

            // count first

            int n = _buffers.Count;

            for (int i = 0; i < n; i++) {
                if (_buffers[i] is HttpSubstBlockResponseElement)
                    count++;
            }

            if (count == 0)
                return null;

            // collect into string array

            String[] names = new String[count];
            int iname = 0;

            for (int i = 0; i < n; i++) {
                if (_buffers[i] is HttpSubstBlockResponseElement)
                    names[iname++] = ((HttpSubstBlockResponseElement)_buffers[i]).Name;
            }

            return names;
        }
#endif

        internal int FindSubstitutionBlock(String name) {
            int n = _buffers.Count;

            for (int i = 0; i < n; i++) {
                // find the substitution block by name

                IHttpResponseElement element = (IHttpResponseElement)_buffers[i];

                if (element is HttpSubstBlockResponseElement) {
                    HttpSubstBlockResponseElement block = (HttpSubstBlockResponseElement)element;

                    if (String.Compare(block.Name, name, true, CultureInfo.InvariantCulture) == 0)
                        return i;
                }
            }

            return -1;
        }

#if UNUSED
        internal void MakeSubstitution(String name, String value, bool canChangeSize) {
            // find the block by name
            int i = FindSubstitutionBlock(name);
            if (i < 0)
                return;
            HttpSubstBlockResponseElement block = (HttpSubstBlockResponseElement)_buffers[i];

            // allocate byte array
            int size = block.GetSize();
            int maxBytes = _responseEncoding.GetMaxByteCount(value.Length);
            if (maxBytes < size)
                maxBytes = size;
            byte[] bytes = new byte[maxBytes];

            // prefill with filler
            System.Array.Copy(block.Data, bytes, size);

            // convert string
            int newSize = _responseEncoder.GetBytes(value.ToCharArray(), 0, value.Length, bytes, 0, true);

            // adjust size if allowed
            if (canChangeSize)
                size = newSize;

            // replace substitution block with memory block
            _buffers[i] = new HttpResponseBufferElement(bytes, size);
        }
#endif

        //
        // Buffer management
        //

        internal void ClearBuffers() {
            ClearCharBuffer();

            _buffers = new ArrayList();
            _lastBuffer = null;
        }

        internal int GetBufferedLength() {
            if (_charBufferLength != _charBufferFree)
                FlushCharBuffer(true);

            int size = 0;
            int n = _buffers.Count;
            for (int i = 0; i < n; i++)
                size += ((IHttpResponseElement)_buffers[i]).GetSize();
            return size;
        }

        internal bool ResponseEncodingUsed {
            get { return _responseEncodingUsed; }
        }

        //
        //  Snapshot for caching
        //

        internal ArrayList GetSnapshot(out bool hasSubstBlocks) {
            if (_charBufferLength != _charBufferFree)
                FlushCharBuffer(true);

            _lastBuffer = null; // to make sure nothing gets appended after

            hasSubstBlocks = false;

            ArrayList buffers = new ArrayList();

            // copy buffer references to the returned list, make non-recyclable
            int n = _buffers.Count;
            for (int i = 0; i < n; i++) {
                Object responseElement = _buffers[i];

                HttpResponseBufferElement buffer = responseElement as HttpResponseBufferElement;

                if (buffer != null) {

                    if (buffer.FreeBytes > BufferingParams.MAX_FREE_BYTES_TO_CACHE) {
                        // copy data if too much is free
                        responseElement = buffer.Clone();
                    }
                    else {
                        // cache the buffer as is with free bytes
                        buffer.DisableRecycling();
                    }
                }
                else if (responseElement is HttpSubstBlockResponseElement) {
                    hasSubstBlocks = true;
                }

                buffers.Add(responseElement);
            }
            return buffers;
        }

        internal void UseSnapshot(ArrayList buffers) {
            ClearBuffers();

            // copy buffer references to the internal buffer list
            int n = buffers.Count;
            for (int i = 0; i < n; i++)
                _buffers.Add(buffers[i]);
        }

        //
        //  Support for response stream filters
        //

        internal Stream GetCurrentFilter() {
            if (_installedFilter != null)
                return _installedFilter;

            if (_filterSink == null)
                _filterSink = new HttpResponseStreamFilterSink(this);

            return _filterSink;
        }

        internal void InstallFilter(Stream filter) {
            if (_filterSink == null)  // have to redirect to the sink -- null means sink wasn't ever asked for
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_response_filter));

            _installedFilter = filter;
        }

        internal void Filter(bool finalFiltering) {
            // no filter?
            if (_installedFilter == null)
                return;

            // flush char buffer and remember old buffers
            if (_charBufferLength != _charBufferFree)
                FlushCharBuffer(true);

            _lastBuffer = null;

            // no content to filter
            if (_buffers.Count == 0)
                return;

            // remember old buffers
            ArrayList oldBuffers = _buffers;
            _buffers = new ArrayList();

            // push old buffer list through the filter

            Debug.Assert(_filterSink != null);

            _filterSink.Filtering = true;

            try {
                int n = oldBuffers.Count;
                for (int i = 0; i < n; i++) {
                    IHttpResponseElement buf = (IHttpResponseElement)oldBuffers[i];

                    int len = buf.GetSize();

                    if (len > 0)
                        _installedFilter.Write(buf.GetBytes(), 0, len);
                }

                _installedFilter.Flush();

                if (finalFiltering)
                    _installedFilter.Close();
            }
            finally {
                _filterSink.Filtering = false;
            }
        }

        //
        //  Send via worker request
        //

        internal void Send(HttpWorkerRequest wr) {
            if (_charBufferLength != _charBufferFree)
                FlushCharBuffer(true);

            int n = _buffers.Count;

            if (n > 0) {
                // write data
                for (int i = 0; i < n; i++) {
                    ((IHttpResponseElement)_buffers[i]).Send(wr);
                }
            }
        }

        //
        // Public TextWriter method implementations
        //

        /// <include file='doc\HttpWriter.uex' path='docs/doc[@for="HttpWriter.Close"]/*' />
        /// <devdoc>
        ///    <para> Sends all buffered output to the client and closes the socket connection.</para>
        /// </devdoc>
        public override void Close() {
            // don't do anything (this could called from a wrapping text writer)
        }

        /// <include file='doc\HttpWriter.uex' path='docs/doc[@for="HttpWriter.Flush"]/*' />
        /// <devdoc>
        ///    <para> Sends all buffered output to the client.</para>
        /// </devdoc>
        public override void Flush() {
            // don't flush the response
        }

        /// <include file='doc\HttpWriter.uex' path='docs/doc[@for="HttpWriter.Write"]/*' />
        /// <devdoc>
        ///    <para> Sends a character to the client.</para>
        /// </devdoc>
        public override void Write(char ch) {
            if (_charBufferFree == 0)
                FlushCharBuffer(false);

            _charBuffer[_charBufferLength - _charBufferFree] = ch;
            _charBufferFree--;

            if (!_responseBufferingOn)
                _response.Flush();
        }

        /// <include file='doc\HttpWriter.uex' path='docs/doc[@for="HttpWriter.Write1"]/*' />
        /// <devdoc>
        ///    <para> Sends a stream of buffered characters to the client 
        ///       using starting position and number of characters to send. </para>
        /// </devdoc>
        public override void Write(char[] buffer, int index, int count) {
            if (buffer == null || index < 0 || count < 0 ||
                buffer.Length - index < count) {
                throw new ArgumentOutOfRangeException("index");
            }

            if (count == 0)
                return;

            while (count > 0) {
                if (_charBufferFree == 0)
                    FlushCharBuffer(false);
                int n = (count < _charBufferFree) ? count : _charBufferFree;
                System.Array.Copy(buffer, index, _charBuffer, _charBufferLength - _charBufferFree, n);
                _charBufferFree -= n;
                index += n;
                count -= n;
            }

            if (!_responseBufferingOn)
                _response.Flush();
        }

        /// <include file='doc\HttpWriter.uex' path='docs/doc[@for="HttpWriter.Write2"]/*' />
        /// <devdoc>
        ///    <para>Sends a string to the client.</para>
        /// </devdoc>
        public override void Write(String s) {

            if (s == null)
                return;

            int count = s.Length;
            int index = 0;
            int n;

            while (count > 0) {
                if (_charBufferFree == 0)
                    FlushCharBuffer(false);
                n = (count < _charBufferFree) ? count : _charBufferFree;                

                s.CopyTo(index, _charBuffer, _charBufferLength - _charBufferFree, n);
                _charBufferFree -= n;
                index += n;
                count -= n;
            }

            if (!_responseBufferingOn)
                _response.Flush();
        }

        /// <include file='doc\HttpWriter.uex' path='docs/doc[@for="HttpWriter.WriteString"]/*' />
        /// <devdoc>
        ///    <para>Sends a string or a sub-string to the client.</para>
        /// </devdoc>
        public void WriteString(String s, int index, int count) {

            if (s == null)
                return;

            int n;

            while (count > 0) {
                if (_charBufferFree == 0)
                    FlushCharBuffer(false);
                n = (count < _charBufferFree) ? count : _charBufferFree;                

                s.CopyTo(index, _charBuffer, _charBufferLength - _charBufferFree, n);
                _charBufferFree -= n;
                index += n;
                count -= n;
            }

            if (!_responseBufferingOn)
                _response.Flush();
        }

        /// <include file='doc\HttpWriter.uex' path='docs/doc[@for="HttpWriter.Write3"]/*' />
        /// <devdoc>
        ///    <para>Sends an object to the client.</para>
        /// </devdoc>
        public override void Write(Object obj) {
            if (obj != null)
                Write(obj.ToString());
        }

        //
        // Support for binary data
        //

        /// <include file='doc\HttpWriter.uex' path='docs/doc[@for="HttpWriter.WriteBytes"]/*' />
        /// <devdoc>
        ///    <para>Sends a buffered stream of bytes to the client.</para>
        /// </devdoc>
        public void WriteBytes(byte[] buffer, int index, int count) {
            WriteFromStream(buffer, index, count);
        }

        /// <include file='doc\HttpWriter.uex' path='docs/doc[@for="HttpWriter.WriteLine"]/*' />
        /// <devdoc>
        ///    <para>Writes out a CRLF pair into the the stream.</para>
        /// </devdoc>
        public override void WriteLine() {
            // It turns out this is way more efficient than the TextWriter version of
            // WriteLine which ends up calling Write with a 2 char array

            if (_charBufferFree < 2)
                FlushCharBuffer(false);

            int pos = _charBufferLength - _charBufferFree;
            _charBuffer[pos] = '\r';
            _charBuffer[pos + 1] = '\n';
            _charBufferFree -= 2;

            if (!_responseBufferingOn)
                _response.Flush();
        }

        /*
         * The Stream for writing binary data
         */
        /// <include file='doc\HttpWriter.uex' path='docs/doc[@for="HttpWriter.OutputStream"]/*' />
        /// <devdoc>
        ///    <para> Enables binary output to the client.</para>
        /// </devdoc>
        public Stream OutputStream {
            get { return _stream;}
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httprequest.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpRequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Request intrinsic
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web {
    using System;
    using System.Text;
    using System.Configuration.Assemblies;
    using System.Runtime.InteropServices;
    using System.Security.Permissions;
    using System.IO;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Globalization;
    using System.Web.Util;
    using System.Web.Configuration;

    // enumeration of dynamic server variables
    internal enum DynamicServerVariable {
        AUTH_TYPE = 1,
        AUTH_USER = 2,
        PATH_INFO = 3,
        PATH_TRANSLATED = 4,
        QUERY_STRING = 5,
        SCRIPT_NAME = 6
    };

    /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Enables
    ///       type-safe browser to server communication. Used to gain access to HTTP request data
    ///       elements supplied by a client.
    ///    </para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpRequest {
        // worker request
        private HttpWorkerRequest _wr;

        // context
        private HttpContext _context;

        // properties
        private String _httpMethod;
        private String _requestType;
        private String _path;
        private bool   _computePathInfo;
        private String _filePath;
        private String _currentExecutionFilePath;
        private String _pathInfo;
        private String _queryStringText;
        private bool   _queryStringOverriden;
        private byte[] _queryStringBytes;
        private String _pathTranslated;
        private String _baseVirtualDir;
        private String _contentType;
        private int    _contentLength = -1;
        private String _clientTarget;
        private String[] _acceptTypes;
        private String[] _userLanguages;
        private HttpBrowserCapabilities _browsercaps;
        private Uri _url;
        private Uri _referrer;
        private HttpInputStream _inputStream;
        private HttpClientCertificate _clientCertificate;

        // collections
        private HttpValueCollection _params;
        private HttpValueCollection _queryString;
        private HttpValueCollection _form;
        private HttpValueCollection _headers;
        private HttpServerVarsCollection _serverVariables;
        private HttpCookieCollection _cookies;
        private HttpFileCollection _files;

        // content (to be read once)
        private byte[] _rawContent;
        private MultipartContentElement[] _multipartContentElements;

        // encoding (for content and query string)
        private Encoding _encoding;

        // content filtering
        private HttpInputStreamFilterSource _filterSource;
        private Stream _installedFilter;

        // Input validation
        private SimpleBitVector32 _flags;
        // const masks into the BitVector32
        private const int needToValidateQueryString     = 0x0001;
        private const int needToValidateForm            = 0x0002;
        private const int needToValidateCookies         = 0x0004;
        private const int needToValidateHeaders         = 0x0008;
        private const int needToValidateServerVariables = 0x00010;

        // Browser caps one-time evaluator objects
        internal static object s_browserLock = new object();
        internal static bool s_browserCapsEvaled = false;

        /*
         * Internal constructor to create requests
         * that have associated HttpWorkerRequest
         *
         * @param wr HttpWorkerRequest
         */
        internal HttpRequest(HttpWorkerRequest wr, HttpContext context) {
            _wr = wr;
            _context = context;
        }

        /*
         * Public constructor for request that come from arbitrary place
         *
         * @param filename physical file name
         * @param queryString query string
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.HttpRequest"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes an HttpRequest object.
        ///    </para>
        /// </devdoc>
        public HttpRequest(String filename, String url, String queryString) {
            _wr = null;
            _pathTranslated = filename;
            _httpMethod = "GET";
            _url = new Uri(url);
            _path = _url.AbsolutePath;
            _queryStringText = queryString;
            _queryStringOverriden = true;
            _queryString = new HttpValueCollection(_queryStringText, true, true, Encoding.Default);

            PerfCounters.IncrementCounter(AppPerfCounter.REQUESTS_EXECUTING);

        }

        internal string ClientTarget {
            get {
                return (_clientTarget == null) ? "" : _clientTarget;
            }
            set {
                _clientTarget = value;
                // force re-create of browser caps
                _browsercaps = null;
            }
        }

        internal HttpContext Context {
            get { return _context; }
        }

        /*
         * internal response object
         */
        internal HttpResponse Response {
            get {
                if (_context == null)
                    return null;
                return _context.Response;
            }
        }

        /*
         * Internal property to determine if request is local
         */
        internal bool IsLocal {
            get {
                String remoteAddress = UserHostAddress;

                // check if localhost
                if (remoteAddress == "127.0.0.1" || remoteAddress == "::1")
                    return true;

                // if unknown, assume not local
                if (remoteAddress == null || remoteAddress.Length == 0)
                    return false;

                // compare with local address
                if (remoteAddress == LocalAddress)
                    return true;

                return false;
            }
        }


        /*
         *  Cleanup code
         */
        internal void Dispose() {
            PerfCounters.DecrementCounter(AppPerfCounter.REQUESTS_EXECUTING);
            if (_serverVariables != null)
                _serverVariables.Dispose();  // disconnect from request
        }

        //
        // Misc private methods to fill in collections from HttpWorkerRequest
        // properties
        //

        private static bool StringStartsWithAnotherIgnoreCase(String s1, String s2) {
            return (String.Compare(s1, 0, s2, 0, s2.Length, true, CultureInfo.InvariantCulture) == 0);
        }

        private static String[] ParseMultivalueHeader(String s) {
            int l = (s != null) ? s.Length : 0;
            if (l == 0)
                return null;

            // collect comma-separated values into list

            ArrayList values = new ArrayList();
            int i = 0;

            while (i < l) {
                // find next ,
                int ci = s.IndexOf(',', i);
                if (ci < 0)
                    ci = l;

                // append corresponding server value
                values.Add(s.Substring(i, ci-i));

                // move to next
                i = ci+1;

                // skip leading space
                if (i < l && s[i] == ' ')
                    i++;
            }

            // return list as array of strings

            int n = values.Count;
            if (n == 0)
                return null;

            String[] strings = new String[n];
            values.CopyTo(0, strings, 0, n);
            return strings;
        }

        //
        // Query string collection support
        //

        private void FillInQueryStringCollection() {
            // try from raw bytes when available (better for globalization)

            byte[] rawQueryString = this.QueryStringBytes;

            if (rawQueryString != null) {
                if (rawQueryString.Length != 0) 
                    _queryString.FillFromEncodedBytes(rawQueryString, ContentEncoding);
            }
            else
                _queryString.FillFromString(this.QueryStringText, true, ContentEncoding);
        }

        //
        // Form collection support
        //

        private void FillInFormCollection() {
            if (_wr == null)
                return;

            if (!_wr.HasEntityBody())
                return;

            String contentType = this.ContentType;
            if (contentType == null)
                return;

            if (StringStartsWithAnotherIgnoreCase(contentType, "application/x-www-form-urlencoded")) {
                // regular urlencoded form

                byte[] formBytes = GetEntireRawContent();

                if (formBytes != null) {
                    try {
                        _form.FillFromEncodedBytes(formBytes, ContentEncoding);
                    }
                    catch (Exception e) {
                        // could be thrown because of malformed data
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_urlencoded_form_data), e);
                    }
                }
            }
            else if (StringStartsWithAnotherIgnoreCase(contentType, "multipart/form-data")) {
                // multipart form

                MultipartContentElement[] elements = GetMultipartContent();

                if (elements != null) {
                    for (int i = 0; i < elements.Length; i++) {
                        if (elements[i].IsFormItem)
                            _form.Add(elements[i].Name, elements[i].GetAsString(ContentEncoding));
                    }
                }
            }
        }

        //
        // Headers collection support
        //

        private void FillInHeadersCollection() {
            if (_wr == null)
                return;

            // known headers

            for (int i = 0; i < HttpWorkerRequest.RequestHeaderMaximum; i++) {
                String h = _wr.GetKnownRequestHeader(i);

                if (h != null && h.Length > 0) {
                    String name = HttpWorkerRequest.GetKnownRequestHeaderName(i);
                    _headers.Add(name, h);
                }
            }

            // unknown headers

            String[][] hh = _wr.GetUnknownRequestHeaders();

            if (hh != null) {
                for (int i = 0; i < hh.Length; i++)
                    _headers.Add(hh[i][0], hh[i][1]);
            }
        }

        //
        // Server variables collection support
        //

        private static String ServerVariableNameFromHeader(String header) {
            return("HTTP_" + header.ToUpper(CultureInfo.InvariantCulture).Replace('-', '_'));
        }

        private String CombineAllHeaders(bool asRaw) {
            if (_wr == null)
                return String.Empty;

            StringBuilder sb = new StringBuilder(256);

            // known headers

            for (int i = 0; i < HttpWorkerRequest.RequestHeaderMaximum; i++) {
                String h = _wr.GetKnownRequestHeader(i);

                if (h != null && h.Length > 0) {
                    String name = HttpWorkerRequest.GetKnownRequestHeaderName(i);

                    if (name != null) {
                        if (!asRaw)
                            name = ServerVariableNameFromHeader(name);

                        sb.Append(name);
                        sb.Append(asRaw ? ": " : ":");  // for ASP compat don't add space
                        sb.Append(h);
                        sb.Append("\r\n");
                    }
                }
            }

            // unknown headers

            String[][] hh = _wr.GetUnknownRequestHeaders();

            if (hh != null) {
                for (int i = 0; i < hh.Length; i++) {
                    String name = hh[i][0];

                    if (!asRaw)
                        name = ServerVariableNameFromHeader(name);

                    sb.Append(name);
                    sb.Append(asRaw ? ": " : ":");  // for ASP compat don't add space
                    sb.Append(hh[i][1]);
                    sb.Append("\r\n");
                }
            }

            return sb.ToString();
        }

        // callback to calculate dynamic server variable
        internal String CalcDynamicServerVariable(DynamicServerVariable var) {
            String value = null;

            switch (var) {
                case DynamicServerVariable.AUTH_TYPE:
                    if (_context.User != null && _context.User.Identity.IsAuthenticated)
                        value = _context.User.Identity.AuthenticationType;
                    else
                        value = String.Empty;
                    break;
                case DynamicServerVariable.AUTH_USER:
                    if (_context.User != null && _context.User.Identity.IsAuthenticated)
                        value = _context.User.Identity.Name;
                    else
                        value = String.Empty;
                    break;
                case DynamicServerVariable.PATH_INFO:
                    value = this.Path;
                    break;
                case DynamicServerVariable.PATH_TRANSLATED:
                    value = this.PhysicalPathInternal;
                    break;
                case DynamicServerVariable.QUERY_STRING:
                    value = this.QueryStringText;
                    break;
                case DynamicServerVariable.SCRIPT_NAME:
                    value = this.FilePath;
                    break;
            }

            return value;
        }

        private void AddServerVariableToCollection(String name, DynamicServerVariable var) {
            // dynamic server var
            _serverVariables.AddDynamic(name, var);
        }

        private void AddServerVariableToCollection(String name, String value) {
            if (value == null)
                value = String.Empty;
            // static server var
            _serverVariables.AddStatic(name, value);
        }

        private void AddServerVariableToCollection(String name) {
            // static server var from worker request
            _serverVariables.AddStatic(name, _wr.GetServerVariable(name));
        }

        internal void FillInServerVariablesCollection() {
            if (_wr == null)
                return;

            //  Add from hardcoded list

            AddServerVariableToCollection("ALL_HTTP",           CombineAllHeaders(false));
            AddServerVariableToCollection("ALL_RAW",            CombineAllHeaders(true));

            AddServerVariableToCollection("APPL_MD_PATH");

            AddServerVariableToCollection("APPL_PHYSICAL_PATH", _wr.GetAppPathTranslated());

            AddServerVariableToCollection("AUTH_TYPE",          DynamicServerVariable.AUTH_TYPE);
            AddServerVariableToCollection("AUTH_USER",          DynamicServerVariable.AUTH_USER);

            AddServerVariableToCollection("AUTH_PASSWORD");

            AddServerVariableToCollection("LOGON_USER");
            AddServerVariableToCollection("REMOTE_USER",        DynamicServerVariable.AUTH_USER);

            AddServerVariableToCollection("CERT_COOKIE");
            AddServerVariableToCollection("CERT_FLAGS");
            AddServerVariableToCollection("CERT_ISSUER");
            AddServerVariableToCollection("CERT_KEYSIZE");
            AddServerVariableToCollection("CERT_SECRETKEYSIZE");
            AddServerVariableToCollection("CERT_SERIALNUMBER");
            AddServerVariableToCollection("CERT_SERVER_ISSUER");
            AddServerVariableToCollection("CERT_SERVER_SUBJECT");
            AddServerVariableToCollection("CERT_SUBJECT");

            String clString = _wr.GetKnownRequestHeader(HttpWorkerRequest.HeaderContentLength);
            AddServerVariableToCollection("CONTENT_LENGTH",     (clString != null) ? clString : "0");

            AddServerVariableToCollection("CONTENT_TYPE",       this.ContentType);

            AddServerVariableToCollection("GATEWAY_INTERFACE");

            AddServerVariableToCollection("HTTPS");
            AddServerVariableToCollection("HTTPS_KEYSIZE");
            AddServerVariableToCollection("HTTPS_SECRETKEYSIZE");
            AddServerVariableToCollection("HTTPS_SERVER_ISSUER");
            AddServerVariableToCollection("HTTPS_SERVER_SUBJECT");

            AddServerVariableToCollection("INSTANCE_ID");
            AddServerVariableToCollection("INSTANCE_META_PATH");

            AddServerVariableToCollection("LOCAL_ADDR",         _wr.GetLocalAddress());

            AddServerVariableToCollection("PATH_INFO",          DynamicServerVariable.PATH_INFO);
            AddServerVariableToCollection("PATH_TRANSLATED",    DynamicServerVariable.PATH_TRANSLATED);

            AddServerVariableToCollection("QUERY_STRING",       DynamicServerVariable.QUERY_STRING);

            AddServerVariableToCollection("REMOTE_ADDR",        this.UserHostAddress);
            AddServerVariableToCollection("REMOTE_HOST",        this.UserHostName);

            AddServerVariableToCollection("REMOTE_PORT");

            AddServerVariableToCollection("REQUEST_METHOD",     this.HttpMethod);

            AddServerVariableToCollection("SCRIPT_NAME",        DynamicServerVariable.SCRIPT_NAME);

            AddServerVariableToCollection("SERVER_NAME",        _wr.GetServerName());
            AddServerVariableToCollection("SERVER_PORT",        (_wr.GetLocalPort()).ToString(NumberFormatInfo.InvariantInfo));

            AddServerVariableToCollection("SERVER_PORT_SECURE", _wr.IsSecure() ? "1" : "0");

            AddServerVariableToCollection("SERVER_PROTOCOL",    _wr.GetHttpVersion());
            AddServerVariableToCollection("SERVER_SOFTWARE");

            AddServerVariableToCollection("URL",                DynamicServerVariable.SCRIPT_NAME);

            // Add all headers in HTTP_XXX format

            for (int i = 0; i < HttpWorkerRequest.RequestHeaderMaximum; i++) {
                String h = _wr.GetKnownRequestHeader(i);
                if (h != null && h.Length > 0)
                    AddServerVariableToCollection(ServerVariableNameFromHeader(HttpWorkerRequest.GetKnownRequestHeaderName(i)), h);
            }

            String[][] hh = _wr.GetUnknownRequestHeaders();

            if (hh != null) {
                for (int i = 0; i < hh.Length; i++)
                    AddServerVariableToCollection(ServerVariableNameFromHeader(hh[i][0]), hh[i][1]); 
            }
        }

        //
        // Cookies collection support
        //

        private static HttpCookie CreateCookieFromString(String s) {
            HttpCookie c = new HttpCookie();

            int l = (s != null) ? s.Length : 0;
            int i = 0;
            int ai, ei;
            bool firstValue = true;
            int numValues = 1;

            // Format: cookiename[=key1=val2&key2=val2&...]

            while (i < l) {
                //  find next &
                ai = s.IndexOf('&', i);
                if (ai < 0)
                    ai = l;

                // first value might contain cookie name before =
                if (firstValue) {
                    ei = s.IndexOf('=', i);

                    if (ei >= 0 && ei < ai) {
                        c.Name = s.Substring(i, ei-i);
                        i = ei+1;
                    }
                    else if (ai == l) {
                        // the whole cookie is just a name
                        c.Name = s;
                        break;
                    }

                    firstValue = false;
                }

                // find '='
                ei = s.IndexOf('=', i);

                if (ei < 0 && ai == l && numValues == 0) {
                    // simple cookie with simple value
                    c.Value = s.Substring(i, l-i);
                }
                else if (ei >= 0 && ei < ai) {
                    // key=value
                    c.Values.Add(s.Substring(i, ei-i), s.Substring(ei+1, ai-ei-1));
                    numValues++;
                }
                else {
                    // value without key
                    c.Values.Add(null, s.Substring(i, ai-i));
                    numValues++;
                }

                i = ai+1;
            }

            return c;
        }

        private void FillInCookiesCollection() {
            if (_wr == null)
                return;

            String s = _wr.GetKnownRequestHeader(HttpWorkerRequest.HeaderCookie);

            // Parse the cookie server variable.
            // Format: c1=k1=v1&k2=v2; c2=... 

            int l = (s != null) ? s.Length : 0;
            int i = 0;
            int j;
            char ch;

            HttpCookie lastCookie = null;

            while (i < l) {
                // find next ';' (don't look to ',' as per 91884)
                j = i;
                while (j < l) {
                    ch = s[j];
                    if (ch == ';')
                        break;
                    j++;
                }

                // create cookie form string
                String cookieString = s.Substring(i, j-i).Trim();
                i = j+1; // next cookie start

                if (cookieString.Length == 0)
                    continue;

                HttpCookie cookie = CreateCookieFromString(cookieString);

                // some cookies starting with '$' are really attributes of the last cookie
                if (lastCookie != null) {
                    String name = cookie.Name;

                    // add known attribute to the last cookie (if any)
                    if (name != null && name.Length > 0 && name[0] == '$') {
                        if (String.Compare(name, "$Path", true, CultureInfo.InvariantCulture) == 0)
                            lastCookie.Path = cookie.Value;
                        else if (String.Compare(name, "$Domain", true, CultureInfo.InvariantCulture) == 0)
                            lastCookie.Domain = cookie.Value;

                        continue;
                    }
                }

                // regular cookie
                _cookies.AddCookie(cookie, true);
                lastCookie = cookie;

                // goto next cookie
            }

            // Append response cookies

            if (Response != null) {
                HttpCookieCollection responseCookies = Response.Cookies;

                // REVIEW: use indexed access to cookie collection (when available)
                if (responseCookies.Count > 0) {
                
                    HttpCookie[] rcookies = new HttpCookie[responseCookies.Count];
                    responseCookies.CopyTo(rcookies, 0);
                    
                    for (int iCookie = 0; iCookie < rcookies.Length; iCookie++)
                        _cookies.AddCookie(rcookies[iCookie], true);
                }
            }
        }

        //
        // Params collection support
        //

        private void FillInParamsCollection() {
            _params.Add(this.QueryString);
            _params.Add(this.Form);
            _params.Add(this.Cookies);
            _params.Add(this.ServerVariables);
        }

        //
        // Files collection support
        //

        private void FillInFilesCollection() {
            if (_wr == null)
                return;

            if (!StringStartsWithAnotherIgnoreCase(ContentType, "multipart/form-data"))
                return;

            MultipartContentElement[] elements = GetMultipartContent();
            if (elements == null)
                return;

            for (int i = 0; i < elements.Length; i++) {
                if (elements[i].IsFile)
                    _files.AddFile(elements[i].Name, elements[i].GetAsPostedFile());
            }
        }

        //
        // Reading posted content ...
        //

        /*
         * Get attribute off header value
         */
        private static String GetAttributeFromHeader(String headerValue, String attrName) {
            if (headerValue == null)
                return null;

            int l = headerValue.Length;
            int k = attrName.Length;

            // find properly separated attribute name
            int i = 1; // start searching from 1

            while (i < l) {
                i = CultureInfo.InvariantCulture.CompareInfo.IndexOf(headerValue, attrName, i, CompareOptions.IgnoreCase);
                if (i < 0)
                    break;
                if (i+k >= l)
                    break;

                char chPrev = headerValue[i-1];
                char chNext = headerValue[i+k];
                if ((chPrev == ';' || Char.IsWhiteSpace(chPrev)) && (chNext == '=' || Char.IsWhiteSpace(chNext)))
                    break;

                i += k;
            }

            if (i < 0 || i >= l)
                return null;

            // skip to '=' and the following whitespaces
            i += k;
            while (i < l && Char.IsWhiteSpace(headerValue[i]))
                i++;
            if (i >= l || headerValue[i] != '=')
                return null;
            i++;
            while (i < l && Char.IsWhiteSpace(headerValue[i]))
                i++;
            if (i >= l)
                return null;

            // parse the value
            String attrValue = null;

            int j;

            if (i < l && headerValue[i] == '"') {
                if (i == l-1)
                    return null;
                j = headerValue.IndexOf('"', i+1);
                if (j < 0 || j == i+1)
                    return null;

                attrValue = headerValue.Substring(i+1, j-i-1).Trim();
            }
            else {
                for (j = i; j < l; j++) {
                    if (headerValue[j] == ' ')
                        break;
                }

                if (j == i)
                    return null;

                attrValue = headerValue.Substring(i, j-i).Trim();
            }

            return attrValue;
        }

        /*
         * In case content-type header contains encoding it should override the config
         */
        private Encoding GetEncodingFromHeaders() {
            if (!_wr.HasEntityBody())
                return null;

            String contentType = this.ContentType;
            if (contentType == null)
                return null;

            String charSet = GetAttributeFromHeader(contentType, "charset");
            if (charSet == null)
                return null;

            Encoding encoding = null;

            try {
                encoding = Encoding.GetEncoding(charSet);
            }
            catch (Exception) {
                // bad encoding string throws an exception that needs to be consumed
            }

            return encoding;
        }

        /*
         * Read entire raw content as byte array
         */
        private byte[] GetEntireRawContent() {
            if (_wr == null)
                return null;

            if (_rawContent != null)
                return _rawContent;

            // enforce the limit

            HttpRuntimeConfig cfg = (HttpRuntimeConfig)_context.GetConfig("system.web/httpRuntime");
            int limit = (cfg != null) ? cfg.MaxRequestLength : HttpRuntimeConfig.DefaultMaxRequestLength;
            if (ContentLength > limit) {
                Response.CloseConnectionAfterError();
                throw new HttpException(400, HttpRuntime.FormatResourceString(SR.Max_request_length_exceeded));
            }

            // read the preloaded content

            byte[] rawContent = _wr.GetPreloadedEntityBody();

            if (rawContent == null)
                rawContent = new byte[0];

            // read the remaing content

            if (!_wr.IsEntireEntityBodyIsPreloaded()) {
                int remainingBytes = (ContentLength > 0) ? ContentLength - rawContent.Length : Int32.MaxValue;

                const int bufferSize = 64*1024;
                ArrayList buffers = new ArrayList();
                int numBuffersRead = 0;
                int numBytesRead = 0;

                while (remainingBytes > 0) {
                    byte[] buf = new byte[bufferSize];
                    int bytesToRead = buf.Length;
                    if (bytesToRead > remainingBytes)
                        bytesToRead = remainingBytes;

                    int bytesRead = _wr.ReadEntityBody(buf, bytesToRead);
                    if (bytesRead <= 0)
                        break;

                    remainingBytes -= bytesRead;

                    buffers.Add(bytesRead);
                    buffers.Add(buf);

                    numBuffersRead++;
                    numBytesRead += bytesRead;

                    if (numBytesRead > limit)
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Max_request_length_exceeded));
                }

                if (numBytesRead > 0) {
                    int oldSize = rawContent.Length;
                    byte[] newContent = new byte[oldSize + numBytesRead];
                    if (oldSize > 0)
                        System.Array.Copy(rawContent, 0, newContent, 0, oldSize);

                    int offset = oldSize;

                    for (int i = 0; i < numBuffersRead; i++) {
                        int    size = (int)buffers[2*i];
                        byte[] buf  = (byte[])buffers[2*i+1];

                        System.Array.Copy(buf, 0, newContent, offset, size);
                        offset += size;
                    }

                    rawContent = newContent;
                }
            }

            // filter content

            if (_installedFilter != null) {
                if (rawContent != null && rawContent.Length > 0) {
                    try {
                        try {
                            _filterSource.SetContent(rawContent);
                            int bufferSize = (int)(_installedFilter.Length - _installedFilter.Position);
                            rawContent = new byte[bufferSize];
                            _installedFilter.Read(rawContent, 0 , rawContent.Length);
                        }
                        finally {
                            _filterSource.SetContent(null);
                        }
                    }
                    catch { // Protect against exception filters
                        throw;
                    }
                }
            }

            _rawContent = rawContent;
            return _rawContent;
        }

        /*
         * Get multipart posted content as array of elements
         */
        private MultipartContentElement[] GetMultipartContent() {
            // already parsed
            if (_multipartContentElements != null)
                return _multipartContentElements;

            // check the boundary
            byte[] boundary = GetMultipartBoundary();
            if (boundary == null)
                return new MultipartContentElement[0];

            // read the content if not read already
            byte[] content = GetEntireRawContent();
            if (content == null)
                return new MultipartContentElement[0];

            // do the parsing
            _multipartContentElements = HttpMultipartContentTemplateParser.Parse(content, content.Length, boundary, ContentEncoding);
            return _multipartContentElements;
        }

        /*
         * Get boundary for the posted multipart content as byte array
         */

        private byte[] GetMultipartBoundary() {
            // extract boundary value
            String b = GetAttributeFromHeader(ContentType, "boundary");
            if (b == null)
                return null;

            // prepend with "--" and convert to byte array
            b = "--" + b;
            return Encoding.ASCII.GetBytes(b.ToCharArray());
        }

        //
        // Request cookies sometimes are populated from Response
        // Here are helper methods to do that.
        //

        /*
         * Add response cookie to request collection (can override existing)
         */
        internal void AddResponseCookie(HttpCookie cookie) {
            // cookies collection

            if (_cookies != null)
                _cookies.AddCookie(cookie, true);

            // cookies also go to parameters collection

            if (_params != null) {
                _params.MakeReadWrite();
                _params.Add(cookie.Name, cookie.Value);
                _params.MakeReadOnly();
            }
        }

        /*
         * Clear any cookies response might've added
         */
        internal void ResetCookies() {
            // cookies collection

            if (_cookies != null) {
                _cookies.Reset();
                FillInCookiesCollection();
            }

            // cookies also go to parameters collection

            if (_params != null) {
                _params.MakeReadWrite();
                _params.Reset();
                FillInParamsCollection();
                _params.MakeReadOnly();
            }
        }

        /*
         * Http method (verb) associated with the current request
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.HttpMethod"]/*' />
        /// <devdoc>
        ///    <para>Indicates the HTTP data transfer method used by client (GET, POST). This property is read-only.</para>
        /// </devdoc>
        public String HttpMethod {
            get {
                // Directly from worker request
                if (_httpMethod == null) {
                    Debug.Assert(_wr != null);
                    _httpMethod = _wr.GetHttpVerbName();
                }

                return _httpMethod;
            }
        }

        /*
         * RequestType default to verb, but can be changed
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.RequestType"]/*' />
        /// <devdoc>
        ///    Indicates the HTTP data transfer method used by client
        ///    (GET, POST).
        /// </devdoc>
        public String RequestType {
            get {
                return(_requestType != null) ? _requestType : this.HttpMethod;
            }

            set {
                _requestType = value;
            }
        }

        /*
          * Content-type of the content posted with the current request
          */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.ContentType"]/*' />
        /// <devdoc>
        ///    <para>Indicates the MIME content type of incoming request. This property is read-only.</para>
        /// </devdoc>
        public String ContentType {
            get {
                if (_contentType == null) {
                    if (_wr != null)
                        _contentType = _wr.GetKnownRequestHeader(HttpWorkerRequest.HeaderContentType);

                    if (_contentType == null)
                        _contentType = String.Empty;
                }

                return _contentType;
            }

            set {
                _contentType = value;
            }
        }


        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.ContentLength"]/*' />
        /// <devdoc>
        ///    <para>Indicates the content length of incoming request. This property is read-only.</para>
        /// </devdoc>
        public int ContentLength {
            get {
                if (_contentLength == -1) {
                    if (_wr != null) {
                        String s = _wr.GetKnownRequestHeader(HttpWorkerRequest.HeaderContentLength);

                        if (s != null) {
                            try {
                                _contentLength = Int32.Parse(s);
                            }
                            catch {
                            }
                        }
                    }
                }

                return (_contentLength >= 0) ? _contentLength : 0;
            }
        }

        /*
         * Encoding to read posted text content
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.ContentEncoding"]/*' />
        /// <devdoc>
        ///    <para>Indicates the character set of data supplied by client. This property is read-only.</para>
        /// </devdoc>
        public Encoding ContentEncoding {
            get {
                if (_encoding == null) {
                    _encoding = GetEncodingFromHeaders();

                    if (_encoding == null) {
                        GlobalizationConfig globConfig = (GlobalizationConfig)_context.GetConfig("system.web/globalization");
                        if (globConfig != null)
                            _encoding = globConfig.RequestEncoding;
                        else
                            _encoding = Encoding.Default;
                    }
                }

                return _encoding;
            }

            set {
                _encoding = value;
            }
        }

        /*
         * Parsed Accept header as array of strings
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.AcceptTypes"]/*' />
        /// <devdoc>
        ///    <para>Returns a string array of client-supported MIME accept types. This property is read-only.</para>
        /// </devdoc>
        public String[] AcceptTypes {
            get {
                if (_acceptTypes == null) {
                    if (_wr != null)
                        _acceptTypes = ParseMultivalueHeader(_wr.GetKnownRequestHeader(HttpWorkerRequest.HeaderAccept));
                }

                return _acceptTypes;
            }
        }

        /*
         * Is the request authenticationed?
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.IsAuthenticated"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Indicates whether the HTTP connection is authenticated.</para>
        /// </devdoc>
        public bool IsAuthenticated {
            get {
                return(_context.User != null && _context.User.Identity != null && _context.User.Identity.IsAuthenticated);
            }
        }

        /*
         * Is using HTTPS?
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.IsSecureConnection"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the HTTP connection is secure (that is, HTTPS). This property is read-only.</para>
        /// </devdoc>
        public bool IsSecureConnection {
            get {
                if (_wr != null)
                    return _wr.IsSecure();
                else
                    return false;
            }
        }


        /*
         * Virtual path corresponding to the requested Url
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.Path"]/*' />
        /// <devdoc>
        ///    <para>Indicates the virtual path of
        ///       the current
        ///       request. This property is read-only.</para>
        /// </devdoc>
        public String Path {
            get {
                if (_path == null) {
                    // Directly from worker request

                    Debug.Assert(_wr != null);
                    _path = _wr.GetUriPath();
                }

                return _path;
            }
        }

        internal String PathWithQueryString {
            get {
                String qs = QueryStringText;
                return (qs != null && qs.Length > 0) ? (Path + "?" + qs) : Path;
            }
        }

        /*
         * File path corresponding to the requested Url
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.FilePath"]/*' />
        /// <devdoc>
        ///    <para>Indicates the virtual path of the current request. This property is read-only.</para>
        /// </devdoc>
        public String FilePath {
            get {
                if (_filePath != null)
                    return _filePath;

                if (!_computePathInfo) {
                    // Directly from worker request

                    Debug.Assert(_wr != null);
                    _filePath = _wr.GetFilePath();
                }
                else if (_context != null) {
                    // From config
                    //
                    //          RAID#93378
                    //          Config system relies on FilePath for lookups so we should not
                    //          be calling it while _filePath is null or it will lead to
                    //          infinite recursion.
                    //
                    //          It is safe to set _filePath to Path as longer path would still
                    //          yield correct configuration, just a little slower.

                    _filePath = Path;

                    int filePathLen = _context.GetCompleteConfig().Path.Length;

                    // case could be wrong in config (_path has the correct case)

                    if (Path.Length == filePathLen)
                        _filePath = Path;
                    else
                        _filePath = Path.Substring(0, filePathLen);
                }

                return _filePath;
            }
        }

        /*
         * Normally the same as FilePath.  The difference is that when doing a
         * Server.Execute, FilePath doesn't change, while this changes to the
         * currently executing virtual path
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.CurrentExecutionFilePath"]/*' />
        public string CurrentExecutionFilePath {
            get {
                if (_currentExecutionFilePath != null)
                    return _currentExecutionFilePath;

                return FilePath;
            }
        }

        internal string SwitchCurrentExecutionFilePath(string path) {
            string oldPath = _currentExecutionFilePath;
            _currentExecutionFilePath = path;
            return oldPath;
        }

        /*
         * Path-info corresponding to the requested Url
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.PathInfo"]/*' />
        /// <devdoc>
        ///    <para>Indicates additional path information for a resource with a URL extension. i.e. for 
        ///       the URL
        ///       /virdir/page.html/tail, the PathInfo value is /tail. This property is
        ///       read-only.</para>
        /// </devdoc>
        public String PathInfo {
            get {
                if (_pathInfo != null)
                    return _pathInfo;

                if (!_computePathInfo) {
                    // Directly from worker request

                    Debug.Assert(_wr != null);
                    _pathInfo = _wr.GetPathInfo();
                }

                if (_pathInfo == null && _context != null) {
                    String path = Path;
                    String filePath = FilePath;

                    if (filePath == null)
                        _pathInfo = path;
                    else if (path == null || path.Length <= filePath.Length)
                        _pathInfo = String.Empty;
                    else
                        _pathInfo = path.Substring(filePath.Length, path.Length - filePath.Length);
                }

                return _pathInfo;
            }
        }


        /*
         * Physical path corresponding to the requested Url
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.PhysicalPath"]/*' />
        /// <devdoc>
        ///    <para>Gets the physical file system path corresponding
        ///       to
        ///       the requested URL. This property is read-only.</para>
        /// </devdoc>
        public String PhysicalPath {
            get {
                String path = PhysicalPathInternal;
                InternalSecurityPermissions.PathDiscovery(path).Demand();
                return path;
            }
        }

        internal String PhysicalPathInternal {
            get {
                if (_pathTranslated == null) {
                    if (!_computePathInfo) {
                        // Directly from worker request
                        Debug.Assert(_wr != null);
                        _pathTranslated = _wr.GetFilePathTranslated();
                    }
                    
                    if (_pathTranslated == null && _wr != null) {
                        // Compute after rewrite
                        _pathTranslated = _wr.MapPath(FilePath);
                    }
                }
                
                return _pathTranslated;
            }
        }

        /*
         * Virtual path to the application root
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.ApplicationPath"]/*' />
        /// <devdoc>
        ///    <para>Gets the
        ///       virtual path to the currently executing server application.</para>
        /// </devdoc>
        public String ApplicationPath {
            get {
                if (_wr != null)
                    return _wr.GetAppPath();
                else
                    return null;
            }
        }

        /*
         * Physical path to the application root
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.PhysicalApplicationPath"]/*' />
        /// <devdoc>
        ///    <para>Gets the physical
        ///       file system path of currently executing server application.</para>
        /// </devdoc>
        public String PhysicalApplicationPath {
            get {
                InternalSecurityPermissions.AppPathDiscovery.Demand();

                if (_wr != null)
                    return _wr.GetAppPathTranslated();
                else
                    return null;
            }
        }

        /*
         * Virtual path of the current request's Url stripped of the filename
         */
        internal String BaseDir {
            get {
                if (_baseVirtualDir == null) {
                    // virtual path before the last '/'
                    String p = FilePath;

                    _baseVirtualDir = UrlPath.GetDirectory(p);
                }

                return _baseVirtualDir;
            }
        }

        /*
         * User agent string
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.UserAgent"]/*' />
        /// <devdoc>
        ///    <para>Gets the client
        ///       browser's raw User Agent String.</para>
        /// </devdoc>
        public String UserAgent {
            get {
                if (_wr != null)
                    return _wr.GetKnownRequestHeader(HttpWorkerRequest.HeaderUserAgent);
                else
                    return null;
            }
        }

        /*
         * Accepted user languages
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.UserLanguages"]/*' />
        /// <devdoc>
        ///    <para>Gets a
        ///       sorted array of client language preferences.</para>
        /// </devdoc>
        public String[] UserLanguages {
            get {
                if (_userLanguages == null) {
                    if (_wr != null)
                        _userLanguages = ParseMultivalueHeader(_wr.GetKnownRequestHeader(HttpWorkerRequest.HeaderAcceptLanguage));
                }

                return _userLanguages;
            }
        }

        /*
         * Browser caps
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.Browser"]/*' />
        /// <devdoc>
        ///    <para>Provides information about incoming client's browser
        ///       capabilities.</para>
        /// </devdoc>
        public HttpBrowserCapabilities Browser {
            get {
                if (! s_browserCapsEvaled) {
                    lock (s_browserLock) {
                        if (! s_browserCapsEvaled) {
                            HttpCapabilitiesBase.GetConfigCapabilities("system.web/browserCaps", this);
                        }
                        s_browserCapsEvaled = true;
                    }
                }
                    
                if (_browsercaps == null) {
                    _browsercaps = (HttpBrowserCapabilities) HttpCapabilitiesBase.GetConfigCapabilities("system.web/browserCaps", this);

                    if (_browsercaps == null) {
                        _browsercaps = new HttpBrowserCapabilities();
                    }
                }

                return _browsercaps;
            }

            set {
                _browsercaps = value;
            }
        }

        /*
         * Client's host name
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.UserHostName"]/*' />
        /// <devdoc>
        ///    <para>Gets the
        ///       DNS name of remote client.</para>
        /// </devdoc>
        public String UserHostName {
            get {
                String s = (_wr != null) ? _wr.GetRemoteName() : null;
                if (s == null || s.Length == 0)
                    s = UserHostAddress;
                return s;
            }
        }

        /*
         * Client's host address
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.UserHostAddress"]/*' />
        /// <devdoc>
        ///    <para>Gets the
        ///       IP host address of remote client.</para>
        /// </devdoc>
        public String UserHostAddress {
            get {
                if (_wr != null)
                    return _wr.GetRemoteAddress();
                else
                    return null;
            }
        }

        internal String LocalAddress {
            get {
                if (_wr != null)
                    return _wr.GetLocalAddress();
                else
                    return null;
            }
        }

        /*
         * The current request's RAW Url (as supplied by worker request)
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.RawUrl"]/*' />
        /// <devdoc>
        ///    <para>Gets the current request's raw URL.</para>
        /// </devdoc>
        public String RawUrl {
            get {
                String url;

                if (_wr != null) {
                    url = _wr.GetRawUrl();
                }
                else {
                    String p = this.Path;
                    String qs = this.QueryStringText;

                    if (qs != null && qs.Length > 0)
                        url = p + "?" + qs;
                    else
                        url = p;
                }

                return url;
            }
        }

        /*
         * The current request's Url
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.Url"]/*' />
        /// <devdoc>
        ///    <para>Gets Information regarding URL of current request.</para>
        /// </devdoc>
        public Uri Url {
            get {
                if (_url == null && _wr != null) {
                    string q = QueryStringText;
                    if (q != null && q.Length > 0)
                        q = "?" + q;

                    String serverName = _wr.GetServerName();
                    if (serverName.IndexOf(':') >= 0 && serverName[0] != '[')
                        serverName = "[" + serverName + "]"; // IPv6

                    _url = new Uri(_wr.GetProtocol() + "://" + serverName + ":" + _wr.GetLocalPort() + Path + q);
                }

                return _url;
            }
        }

        /*
         * Url of the Http referrer
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.UrlReferrer"]/*' />
        /// <devdoc>
        ///    <para>Gets information regarding the URL of the client's
        ///       previous request that linked to the current URL.</para>
        /// </devdoc>
        public Uri UrlReferrer {
            get {
                if (_referrer == null) {
                    if (_wr != null) {
                        String r = _wr.GetKnownRequestHeader(HttpWorkerRequest.HeaderReferer);

                        if (r != null && r.Length > 0) {
                            try {
                                if (r.IndexOf("://") >= 0)
                                    _referrer = new Uri(r);
                                 else
                                    _referrer = new Uri(this.Url, r);
                            }
                            catch (HttpException) {
                                // malformed referrer shouldn't crash the request
                                _referrer = null;
                            }
                        }
                    }
                }

                return _referrer;
            }
        }

        // special case for perf in output cache module
        internal String IfModifiedSince {
            get {
                if (_wr == null)
                    return null;
                return _wr.GetKnownRequestHeader(HttpWorkerRequest.HeaderIfModifiedSince);
            }
        }

        // special case for perf in output cache module
        internal String IfNoneMatch {
            get {
                if (_wr == null)
                    return null;
                return _wr.GetKnownRequestHeader(HttpWorkerRequest.HeaderIfNoneMatch);
            }
        }

        /*
         * Params collection - combination of query string, form, server vars
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.Params"]/*' />
        /// <devdoc>
        ///    <para>Gets a
        ///       combined collection of QueryString+Form+ ServerVariable+Cookies.</para>
        /// </devdoc>
        public NameValueCollection Params {
            get {
                InternalSecurityPermissions.AspNetHostingPermissionLevelLow.Demand();

                if (_params == null) {
                    _params = new HttpValueCollection();
                    FillInParamsCollection();
                    _params.MakeReadOnly();
                }

                return _params;
            }
        }

        /*
         * Default property that goes through the collections
         *      QueryString, Form, Cookies, ClientCertificate and ServerVariables
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Default property that indexes through the collections: QueryString,
        ///       Form, Cookies, ClientCertificate and ServerVariables.
        ///    </para>
        /// </devdoc>
        public String this[String key]
        {
            get { 
                String s;

                s = QueryString[key];
                if (s != null)
                    return s;

                s = Form[key];
                if (s != null)
                    return s;

                HttpCookie c = Cookies[key];
                if (c != null)
                    return c.Value;

                s = ServerVariables[key];
                if (s != null)
                    return s;

                return null;
            }
        }

        /*
         * Query string as String (private)
         */
        internal String QueryStringText {
            get {
                if (_queryStringText == null) {
                    if (_wr != null) {
                        // if raw bytes available use them
                        byte[] rawQueryString = this.QueryStringBytes;

                        if (rawQueryString != null) {
                            if (rawQueryString.Length > 0)
                                _queryStringText = ContentEncoding.GetString(rawQueryString);
                            else
                                _queryStringText = String.Empty;
                        }
                        else {
                            _queryStringText = _wr.GetQueryString();
                        }
                    }

                    if (_queryStringText == null)
                        _queryStringText = String.Empty;
                }

                return _queryStringText;
            }

            set { 
                // override the query string
                _queryStringText = value;
                _queryStringOverriden = true;

                if (_queryString != null) {
                    _queryString.MakeReadWrite();
                    _queryString.Reset();
                    FillInQueryStringCollection();
                    _queryString.MakeReadOnly();
                }
            }
        }

        /*
         * Query string as byte[] (private) -- for parsing
         */
        internal byte[] QueryStringBytes {
            get {
                if (_queryStringOverriden)
                    return null;

                if (_queryStringBytes == null) {
                    if (_wr != null)
                        _queryStringBytes = _wr.GetQueryStringRawBytes();
                }

                return _queryStringBytes;
            }
        }

        /*
         * Query string collection
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.QueryString"]/*' />
        /// <devdoc>
        ///    <para>Gets the collection of QueryString variables.</para>
        /// </devdoc>
        public NameValueCollection QueryString {
            get {
                if (_queryString == null) {
                    _queryString = new HttpValueCollection();

                    if (_wr != null)
                        FillInQueryStringCollection();

                    _queryString.MakeReadOnly();
                }

                if (_flags[needToValidateQueryString]) {
                    _flags[needToValidateQueryString] = false;
                    ValidateNameValueCollection(_queryString, "Request.QueryString");
                }

                return _queryString;
            }
        }

        /*
         * Form collection
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.Form"]/*' />
        /// <devdoc>
        ///    <para>Gets a
        ///       collection of Form variables.</para>
        /// </devdoc>
        public NameValueCollection Form {
            get {
                if (_form == null) {
                    _form = new HttpValueCollection();

                    if (_wr != null)
                        FillInFormCollection();

                    _form.MakeReadOnly();
                }

                if (_flags[needToValidateForm]) {
                    _flags[needToValidateForm] = false;
                    ValidateNameValueCollection(_form, "Request.Form");
                }

                return _form;
            }
        }

        internal HttpValueCollection SwitchForm(HttpValueCollection form) {
            HttpValueCollection oldForm = _form;
            _form = form;
            return oldForm;
        }

        /*
         * Headers collection
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.Headers"]/*' />
        /// <devdoc>
        ///    <para>Gets a collection of HTTP headers.</para>
        /// </devdoc>
        public NameValueCollection Headers {
            get {
                if (_headers == null) {
                    _headers = new HttpValueCollection();

                    if (_wr != null)
                        FillInHeadersCollection();

                    _headers.MakeReadOnly();
                }

                return _headers;
            }
        }

        /*
         * Server vars collection
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.ServerVariables"]/*' />
        /// <devdoc>
        ///    <para>Gets a collection of web server variables.</para>
        /// </devdoc>
        public NameValueCollection ServerVariables {
            get {
                InternalSecurityPermissions.AspNetHostingPermissionLevelLow.Demand();

                if (_serverVariables == null) {
                    _serverVariables = new HttpServerVarsCollection(this);

                    /* ---- Population deferred to speed up single server var lookup case
                    if (_wr != null)
                        FillInServerVariablesCollection();
                    ---- */

                    _serverVariables.MakeReadOnly();
                }

                return _serverVariables;
            }
        }

        /*
         * Cookie collection associated with current request
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.Cookies"]/*' />
        /// <devdoc>
        ///    <para>Gets a collection of client's cookie variables.</para>
        /// </devdoc>
        public HttpCookieCollection Cookies {
            get {
                if (_cookies == null) {
                    _cookies = new HttpCookieCollection(null, false);

                    if (_wr != null)
                        FillInCookiesCollection();
                }

                if (_flags[needToValidateCookies]) {
                    _flags[needToValidateCookies] = false;
                    ValidateCookieCollection(_cookies);
                }

                return _cookies;
            }
        }

        /*
         * File collection associated with current request
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.Files"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       the collection of client-uploaded files (Multipart MIME format).</para>
        /// </devdoc>
        public HttpFileCollection Files {
            get {
                if (_files == null) {
                    _files = new HttpFileCollection();

                    if (_wr != null)
                        FillInFilesCollection();
                }

                return _files;
            }
        }

        /*
         * Stream to read raw content
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.InputStream"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides access to the raw contents of the incoming HTTP entity
        ///       body.
        ///    </para>
        /// </devdoc>
        public Stream InputStream {
            get {
                if (_inputStream == null) {
                    byte[] rawContent = null;

                    if (_wr != null)
                        rawContent = GetEntireRawContent();

                    if (rawContent != null) {
                        _inputStream = new HttpInputStream(
                                                          rawContent,
                                                          0,
                                                          rawContent.Length
                                                          );
                    }
                    else {
                        _inputStream = new HttpInputStream(null, 0, 0);
                    }
                }

                return _inputStream;
            }
        }

        /*
         * ASP classic compat
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.TotalBytes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the number of bytes in the current input stream.
        ///    </para>
        /// </devdoc>
        public int TotalBytes {
            get {
                Stream s = InputStream;
                return(s != null) ? (int)s.Length : 0;
            }
        }

        /*
         * ASP classic compat
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.BinaryRead"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Performs a binary read of a specified number of bytes from the current input
        ///       stream.
        ///    </para>
        /// </devdoc>
        public byte[] BinaryRead(int count) {
            if (count < 0 || count > TotalBytes)
                throw new ArgumentOutOfRangeException("count");

            if (count == 0)
                return new byte[0];

            byte[] buffer = new byte[count];
            int c = InputStream.Read(buffer, 0, count);

            if (c != count) {
                byte[] b2 = new byte[c];
                if (c > 0)
                    Array.Copy(buffer, b2, c);
                buffer = b2;
            }

            return buffer;
        }

        /*
         * Filtering of the input
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.Filter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a filter to use when reading the current input stream.
        ///    </para>
        /// </devdoc>
        public Stream Filter {
            get {
                if (_installedFilter != null)
                    return _installedFilter;

                if (_filterSource == null)
                    _filterSource = new HttpInputStreamFilterSource();

                return _filterSource;
            }

            set {
                if (_filterSource == null)  // have to use the source -- null means source wasn't ever asked for
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_request_filter));

                _installedFilter = value;
            }
        }


        /*
         * Client Certificate
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.ClientCertificate"]/*' />
        /// <devdoc>
        ///    <para>Gets information on the current request's client security certificate.</para>
        /// </devdoc>
        public HttpClientCertificate ClientCertificate {
            get {
                if (_clientCertificate == null) {
                    InternalSecurityPermissions.AppPathDiscovery.Assert();
                    _clientCertificate = new HttpClientCertificate(_context);
                }
                return _clientCertificate;
            }
        }

        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.ValidateInput"]/*' />
        /// <devdoc>
        ///    <para>Validate that the input from the browser is safe.</para>
        /// </devdoc>
        public void ValidateInput() {
            // This is to prevent some CSS (cross site scripting) attacks (ASURT 122278)

            _flags[needToValidateQueryString] = true;
            _flags[needToValidateForm] = true;
            _flags[needToValidateCookies] = true;

            // REVIEW: How about headers ans server variables?
        }

        private void ValidateString(string s, string valueName, string collectionName) {

            int matchIndex=0;
            if (CrossSiteScriptingValidation.IsDangerousString(s, out matchIndex)) {
                // Display only the piece of the string that caused the problem, padded by on each side
                string detectedString = valueName + "=\"";
                int startIndex = matchIndex - 10;
                if (startIndex <= 0) {
                    startIndex = 0;
                }
                else {
                    // Start with "..." to show that this is not the beginning
                    detectedString += "...";
                }
                int endIndex = matchIndex + 20;
                if (endIndex >= s.Length) {
                    endIndex = s.Length;
                    detectedString += s.Substring(startIndex, endIndex-startIndex) + "\"";
                }
                else {
                    detectedString += s.Substring(startIndex, endIndex-startIndex) + "...\"";
                }
                throw new HttpRequestValidationException(HttpRuntime.FormatResourceString(SR.Dangerous_input_detected,
                    collectionName, detectedString));
            }
        }

        private void ValidateNameValueCollection(NameValueCollection nvc, string collectionName) {
            int c = nvc.Count;

            for (int i = 0; i < c; i++) {
                String key = nvc.GetKey(i);
            
                // Skip the view state as an optimization
                // REVIEW: it's a bit ugly to have this dependency on Page here
                if (key == System.Web.UI.Page.viewStateID) continue;

                String val = nvc.Get(i);
                
                if (val != null && val.Length > 0)
                    ValidateString(val, key, collectionName);
            }
        }

        private void ValidateCookieCollection(HttpCookieCollection cc) {
            int c = cc.Count;

            for (int i = 0; i < c; i++) {
                String key = cc.GetKey(i);
                String val = cc.Get(i).Value;

                if (val != null && val.Length > 0)
                    ValidateString(val, key, "Request.Cookies");
            }
        }

        /*
         * Get coordinates of the clicked image send as name.x=&name.y=
         * in the form or in the query string
         * @param imageFieldName name of the image field
         * @return x,y as int[2] or null if not found
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.MapImageCoordinates"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Maps an incoming image field form parameter into appropriate x/y
        ///       coordinate values.
        ///    </para>
        /// </devdoc>
        public int[] MapImageCoordinates(String imageFieldName) {
            // Select collection where to look according to verb

            NameValueCollection c = null;

            String verb = this.HttpMethod;

            if (verb.Equals("GET") || verb.Equals("HEAD"))
                c = this.QueryString;
            else if (verb.Equals("POST"))
                c = this.Form;
            else
                return null;

            // Look for .x and .y values in the collection

            int[] ret = null;

            try {
                String x = c[imageFieldName + ".x"];
                String y = c[imageFieldName + ".y"];

                if (x != null && y != null)
                    ret = (new int[] { Int32.Parse(x), Int32.Parse(y)});
            }
            catch (Exception) {
                // eat parsing exceptions
            }

            return ret;
        }


        /*
         * Save contents of request into a file
         * @param filename where to save
         * @param includeHeaders flag to request inclusion of Http headers
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.SaveAs"]/*' />
        /// <devdoc>
        ///    <para>Saves an HTTP request to disk.</para>
        /// </devdoc>
        public void SaveAs(String filename, bool includeHeaders) {
            FileStream f = new FileStream(filename, FileMode.Create);

            try {
                // headers

                if (includeHeaders) {
                    TextWriter w = new StreamWriter(f);

                    w.Write(this.HttpMethod + " " + this.Path);

                    String qs = this.QueryStringText;
                    if (qs != null && qs.Length > 0)
                        w.Write("?" + qs);

                    if (_wr != null) {
                        // real request -- add protocol
                        w.Write(" " + _wr.GetHttpVersion() + "\r\n");

                        // headers
                        w.Write(CombineAllHeaders(true));
                    }
                    else {
                        // manufactured request
                        w.Write("\r\n");
                    }

                    w.Write("\r\n");
                    w.Flush();
                }

                // entity body

                HttpInputStream s = (HttpInputStream)this.InputStream;
                if (s.DataLength > 0)
                    f.Write(s.Data, s.DataOffset, s.DataLength);

                f.Flush();
            }
            finally {
                f.Close();
            }
        }

        /*
         * Map virtual path to physical path relative to current request
         * @param virtualPath virtual path (absolute or relative)
         * @return physical path
         */
        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.MapPath"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Maps the given virtual path to a physical path.
        ///    </para>
        /// </devdoc>
        public String MapPath(String virtualPath) {
            return MapPath(virtualPath, BaseDir, true/*allowCrossAppMapping*/);
        }

        /// <include file='doc\HttpRequest.uex' path='docs/doc[@for="HttpRequest.MapPath1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Maps the given virtual path to a physical path.
        ///    </para>
        /// </devdoc>
        public String MapPath(string virtualPath, string baseVirtualDir, bool allowCrossAppMapping) {
            if (_wr == null)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_map_path_without_context));

            if (virtualPath != null)
                virtualPath = virtualPath.Trim();

            // treat null and "" as "."

            if (virtualPath == null || virtualPath.Length == 0)
                virtualPath = ".";

            // disable physical paths: UNC shares and C:

            if (virtualPath.StartsWith("\\\\") || virtualPath.IndexOf(':') >= 0)
                throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Invalid_path_for_mappath, virtualPath));

            // first, virtualPath should always be using '/'s:

            virtualPath = virtualPath.Replace('\\', '/');

            // If the vpath is not rooted, combine it with the base
            if (!UrlPath.IsRooted(virtualPath)) {
                if (baseVirtualDir == null || baseVirtualDir.Length == 0)
                    baseVirtualDir = BaseDir;
                virtualPath = UrlPath.Combine(baseVirtualDir, virtualPath);
            }
            else {
                virtualPath = UrlPath.Reduce(virtualPath);
            }

            if (!allowCrossAppMapping && !HttpRuntime.IsPathWithinAppRoot(virtualPath))
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cross_app_not_allowed, virtualPath));

            string realPath = _wr.MapPath(virtualPath);
            InternalSecurityPermissions.PathDiscovery(realPath).Demand();
            return realPath;
        }

        internal void InternalRewritePath(String newPath, String newQueryString) {
            // clear things that depend on path

            _pathTranslated = null;
            _baseVirtualDir = null;
            _pathInfo = null;
            _filePath = null;
            _url = null;

            // grab new path (and possibly new query string)

            _path = newPath;

            if (newQueryString != null)
                this.QueryStringText = newQueryString;

            // set a flag so we compute things that depend on path by hand

            _computePathInfo = true;
        }    

        internal void InternalRewritePath(String newFilePath, String newPathInfo, String newQueryString) {
            // clear things that depend on path

            _pathTranslated = (_wr != null) ? _wr.MapPath(newFilePath) : null;
            _baseVirtualDir = null;
            _pathInfo = newPathInfo;
            _filePath = newFilePath;
            _url = null;
            _path = newFilePath + newPathInfo;

            if (newQueryString != null)
                this.QueryStringText = newQueryString;

            // no need to calculate any paths

            _computePathInfo = false;
        }    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ihttpasynchandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="IHttpAsyncHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Asynchronous Http request handler interface
 * 
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web {

    /// <include file='doc\IHttpAsyncHandler.uex' path='docs/doc[@for="IHttpAsyncHandler"]/*' />
    /// <devdoc>
    ///    <para>When implemented by a class, defines the contract that Http Async Handler objects must
    ///       implement.</para>
    /// </devdoc>
    public interface IHttpAsyncHandler : IHttpHandler {
        /// <include file='doc\IHttpAsyncHandler.uex' path='docs/doc[@for="IHttpAsyncHandler.BeginProcessRequest"]/*' />
        /// <devdoc>
        ///    <para>Registers handler for async notification.</para>
        /// </devdoc>
        IAsyncResult BeginProcessRequest(HttpContext context, AsyncCallback cb, Object extraData);
        /// <include file='doc\IHttpAsyncHandler.uex' path='docs/doc[@for="IHttpAsyncHandler.EndProcessRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        void EndProcessRequest(IAsyncResult result);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ihttphandlerfactory.cs ===
//------------------------------------------------------------------------------
// <copyright file="IHttpHandlerFactory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Handler factory interface
 */
namespace System.Web {
    /*
     * Handler factory -- gets Handler by requestType,path,file
     */
    /// <include file='doc\IHttpHandlerFactory.uex' path='docs/doc[@for="IHttpHandlerFactory"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Defines the contract that factories must implement to dynamically
    ///       create IHttpHandler instances.
    ///    </para>
    /// </devdoc>
    public interface IHttpHandlerFactory {
        /// <include file='doc\IHttpHandlerFactory.uex' path='docs/doc[@for="IHttpHandlerFactory.GetHandler"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns an instance of an IHttpHandler class.
        ///    </para>
        /// </devdoc>
        IHttpHandler GetHandler(HttpContext context, String requestType, String url, String pathTranslated);
        /// <include file='doc\IHttpHandlerFactory.uex' path='docs/doc[@for="IHttpHandlerFactory.ReleaseHandler"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Enables a factory to recycle or re-use an existing handler
        ///       instance.
        ///    </para>
        /// </devdoc>
        void ReleaseHandler(IHttpHandler handler);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ihttpmodule.cs ===
//------------------------------------------------------------------------------
// <copyright file="IHttpModule.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * IHttpModule interface
 * 
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Web 
{
using System;
    
/// <include file='doc\IHttpModule.uex' path='docs/doc[@for="IHttpModule"]/*' />
/// <devdoc>
///    <para>Provides module initialization and tear-down events to the inheriting class.</para>
/// </devdoc>
public interface IHttpModule
{
    /// <include file='doc\IHttpModule.uex' path='docs/doc[@for="IHttpModule.Init"]/*' />
    /// <devdoc>
    ///    <para>Invoked by ASP.NET to enable a module to set itself up to handle
    ///       requests.</para>
    /// </devdoc>
    void Init(HttpApplication context);

    /// <include file='doc\IHttpModule.uex' path='docs/doc[@for="IHttpModule.Dispose"]/*' />
    /// <devdoc>
    ///    <para>Invoked by ASP.NET to enable a module to perform any final cleanup work prior to tear-down.</para>
    /// </devdoc>
    void Dispose();

}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ihttpmappath.cs ===
//------------------------------------------------------------------------------
// <copyright file="IHttpMapPath.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   IHttpMapPath.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web {
    using System.Text;
    using System.Runtime.InteropServices;
    using System.IO;
    
    /*
     * IHttpMapPath
     *
     * Encapsulates all the operations that currently require hitting
     * the filesystem.
     */
    /// <include file='doc\IHttpMapPath.uex' path='docs/doc[@for="IHttpMapPath"]/*' />
    /// <devdoc>
    ///    <para>Provides the inheriting class with operations that facilitate interacting 
    ///       with the file system.</para>
    /// </devdoc>
    internal interface IHttpMapPath {
        /// <include file='doc\IHttpMapPath.uex' path='docs/doc[@for="IHttpMapPath.MapPath"]/*' />
        /// <devdoc>
        ///    <para>Provides the inheriting class with a method to find a file system path 
        ///       given another path.</para>
        /// </devdoc>
        /*
         * Source
         *
         * given a path, returns the file for config as well
         * as the parent path (if any), and adds any dependencies.
         */
        String MapPath(String path);
        /// <include file='doc\IHttpMapPath.uex' path='docs/doc[@for="IHttpMapPath.MachineConfigPath"]/*' />
        /// <devdoc>
        ///    <para>Provides the inheriting class with a method to find the file system path 
        ///       to the configuration file.</para>
        /// </devdoc>
        String MachineConfigPath { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\intsecurity.cs ===
//------------------------------------------------------------------------------
// <copyright file="IntSecurity.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   IntSecurity.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web {
    using System.Web;
    using System.Web.Util;
    using System.Security;
    using System.Security.Permissions;

    internal class InternalSecurityPermissions {

        private static IStackWalk   _unrestricted;
        private static IStackWalk   _unmanagedCode;
        private static IStackWalk   _sensitiveInformation;
        private static IStackWalk   _controlPrincipal;
        private static IStackWalk   _controlEvidence;
        private static IStackWalk   _reflection;
        private static IStackWalk   _appPathDiscovery;
        private static IStackWalk   _controlThread;
        private static IStackWalk   _levelMinimal;
        private static IStackWalk   _levelLow;
        private static IStackWalk   _levelMedium;
        private static IStackWalk   _levelHigh;
        private static IStackWalk   _levelUnrestricted;

        internal InternalSecurityPermissions() {
        }

        //
        // Static permissions as properties, created on demand
        //

        internal static IStackWalk Unrestricted {
            get {
                if (_unrestricted == null)
                    _unrestricted = new PermissionSet(PermissionState.Unrestricted);

                Debug.Trace("Permissions", "Unrestricted Set");
                return _unrestricted;
            }
        }

        internal static IStackWalk UnmanagedCode {
            get {
                if (_unmanagedCode == null)
                    _unmanagedCode = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);

                Debug.Trace("Permissions", "UnmanagedCode");
                return _unmanagedCode;
            }
        }

        internal static IStackWalk SensitiveInformation {
            get {
                if (_sensitiveInformation == null)
                    _sensitiveInformation = new EnvironmentPermission(PermissionState.Unrestricted);

                Debug.Trace("Permissions", "SensitiveInformation");
                return _sensitiveInformation;
            }
        }

        internal static IStackWalk ControlPrincipal {
            get {
                if (_controlPrincipal == null)
                    _controlPrincipal = new SecurityPermission(SecurityPermissionFlag.ControlPrincipal);

                Debug.Trace("Permissions", "ControlPrincipal");
                return _controlPrincipal;
            }
        }

        internal static IStackWalk ControlEvidence {
            get {
                if (_controlEvidence == null)
                    _controlEvidence = new SecurityPermission(SecurityPermissionFlag.ControlEvidence);

                Debug.Trace("Permissions", "ControlEvidence");
                return _controlEvidence;
            }
        }

        internal static IStackWalk Reflection {
            get {
                if (_reflection == null)
                    _reflection = new ReflectionPermission(ReflectionPermissionFlag.TypeInformation | ReflectionPermissionFlag.MemberAccess);

                Debug.Trace("Permissions", "Reflection");
                return _reflection;
            }
        }

        internal static IStackWalk AppPathDiscovery {
            get {
                if (_appPathDiscovery == null)
                    _appPathDiscovery = new FileIOPermission(FileIOPermissionAccess.PathDiscovery, HttpRuntime.AppDomainAppPathInternal);

                Debug.Trace("Permissions", "AppPathDiscovery");
                return _appPathDiscovery;
            }
        }

        internal static IStackWalk ControlThread {
            get {
                if (_controlThread == null)
                    _controlThread = new SecurityPermission(SecurityPermissionFlag.ControlThread);

                Debug.Trace("Permissions", "ControlThread");
                return _controlThread;
            }
        }

        internal static IStackWalk AspNetHostingPermissionLevelMinimal {
            get {
                if (_levelMinimal == null)
                    _levelMinimal = new AspNetHostingPermission(AspNetHostingPermissionLevel.Minimal);

                Debug.Trace("Permissions", "AspNetHostingPermissionLevelMinimal");
                return _levelMinimal;
            }
        }


        internal static IStackWalk AspNetHostingPermissionLevelLow {
            get {
                if (_levelLow == null)
                    _levelLow = new AspNetHostingPermission(AspNetHostingPermissionLevel.Low);

                Debug.Trace("Permissions", "AspNetHostingPermissionLevelLow");
                return _levelLow;
            }
        }


        internal static IStackWalk AspNetHostingPermissionLevelMedium {
            get {
                if (_levelMedium == null)
                    _levelMedium = new AspNetHostingPermission(AspNetHostingPermissionLevel.Medium);

                Debug.Trace("Permissions", "AspNetHostingPermissionLevelMedium");
                return _levelMedium;
            }
        }


        internal static IStackWalk AspNetHostingPermissionLevelHigh {
            get {
                if (_levelHigh == null)
                    _levelHigh = new AspNetHostingPermission(AspNetHostingPermissionLevel.High);

                Debug.Trace("Permissions", "AspNetHostingPermissionLevelHigh");
                return _levelHigh;
            }
        }


        internal static IStackWalk AspNetHostingPermissionLevelUnrestricted {
            get {
                if (_levelUnrestricted == null)
                    _levelUnrestricted = new AspNetHostingPermission(AspNetHostingPermissionLevel.Unrestricted);

                Debug.Trace("Permissions", "AspNetHostingPermissionLevelUnrestricted");
                return _levelUnrestricted;
            }
        }


        // Parameterized permissions

        internal static IStackWalk FileReadAccess(String filename) {
            Debug.Trace("Permissions", "FileReadAccess(" + filename + ")");
            return new FileIOPermission(FileIOPermissionAccess.Read, filename);
        }

        internal static IStackWalk PathDiscovery(String path) {
            Debug.Trace("Permissions", "PathDiscovery(" + path + ")");
            return new FileIOPermission(FileIOPermissionAccess.PathDiscovery, path);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ihttphandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="IHttpHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Synchronous Http request handler interface
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web {
    

    /// <include file='doc\IHttpHandler.uex' path='docs/doc[@for="IHttpHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Defines the contract that developers must implement to
    ///       synchronously process HTTP web requests. Developers
    ///       implement the ProcessRequest method to provide custom URL execution.
    ///    </para>
    /// </devdoc>
    public interface IHttpHandler {
        /// <include file='doc\IHttpHandler.uex' path='docs/doc[@for="IHttpHandler.ProcessRequest"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Drives web processing execution.
        ///    </para>
        /// </devdoc>
        void ProcessRequest(HttpContext context);   
        /// <include file='doc\IHttpHandler.uex' path='docs/doc[@for="IHttpHandler.IsReusable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Allows an IHTTPHandler instance to indicate at the end of a
        ///       request whether it can be recycled and used for another request.
        ///    </para>
        /// </devdoc>
        bool IsReusable { get; }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\makefile.inc ===
$(O)\names.cs : ..\names.cspp $(XSPBASEDIR)\inc\names.h

$(TARGETPATH)\genpolicy.pl : ..\genpolicy.plpp $(DNAROOT)\public\tools\inc\private\version\product_version.h 
        $(ECHO_PROCESSING_CMD) $@
#echo the preprocessor command to build.log        
        @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP ..\genpolicy.plpp
<<$(KEEPFILES)
#run the preprocessor        
        @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /C /Tc ..\genpolicy.plpp > $@
$(CPPXX: =
)
<<$(KEEPFILES)

$(TARGETPATH)\$(ASPNET_NAME_PREFIX_NO_SUFFIX).config : ..\aspnet.config $(TARGETPATH)\genpolicy.pl
        $(ECHO_PROCESSING_CMD) $@      
        $(PERL) -p $(TARGETPATH)\genpolicy.pl ..\aspnet.config > $@

$(TARGETPATH)\SmartNav.js : ..\UI\WebControls\RuntimeScripts\SmartNav.js
        $(PERL) -n ..\StripComments.pl ..\UI\WebControls\RuntimeScripts\SmartNav.js > $@

$(TARGETPATH)\SmartNav.htm : ..\UI\WebControls\RuntimeScripts\SmartNav.htm
        copy $** $@

$(TARGETPATH)\SmartNavIE5.js : ..\UI\WebControls\RuntimeScripts\SmartNavIE5.js
        $(PERL) -n ..\StripComments.pl ..\UI\WebControls\RuntimeScripts\SmartNavIE5.js > $@

$(TARGETPATH)\WebUIValidation.js : ..\UI\WebControls\RuntimeScripts\WebUIValidation.js
        $(PERL) -n ..\StripComments.pl ..\UI\WebControls\RuntimeScripts\WebUIValidation.js > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\mimemapping.cs ===
//------------------------------------------------------------------------------
// <copyright file="MimeMapping.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*++
        MimeMapping : This module maps document extensions to Content Mime Type.
        Copyright (c) 1999 Microsoft Corporation
--*/

using System.Collections;
using System.Globalization;

namespace System.Web {
    internal class MimeMapping {
        static private Hashtable _extensionToMimeMappingTable = new Hashtable(190);

        private MimeMapping() {
        }

        static private void AddMimeMapping(String extension, String MimeType) {
            _extensionToMimeMappingTable.Add(extension, MimeType);    
        }

        // ************************************************************************

        internal /*public*/ static String GetMimeMapping(String FileName) {
            String  contentType = null;

            int     extpos = FileName.LastIndexOf('.');

            if ( (0 < extpos) && (extpos > FileName.LastIndexOf('\\')) ) {
                //
                // There is a file extension
                //

                String  ext = (FileName.Substring(extpos)).ToLower(CultureInfo.InvariantCulture);
                contentType = (String)_extensionToMimeMappingTable[ext];
            }

            if ( null == contentType)
                contentType = (String)_extensionToMimeMappingTable[".*"];

            return contentType;
        }

        // ************************************************************************

        static MimeMapping() {
            //
            // Populate the mime table. This list is the one used by IIS.
            //

            AddMimeMapping(".323",      "text/h323");

            AddMimeMapping(".asx",      "video/x-ms-asf");
            AddMimeMapping(".acx",      "application/internet-property-stream");
            AddMimeMapping(".ai",       "application/postscript");
            AddMimeMapping(".aif",      "audio/x-aiff");
            AddMimeMapping(".aiff",     "audio/aiff");
            AddMimeMapping(".axs",      "application/olescript");
            AddMimeMapping(".aifc",     "audio/aiff");
            AddMimeMapping(".asr",      "video/x-ms-asf");
            AddMimeMapping(".avi",      "video/x-msvideo");
            AddMimeMapping(".asf",      "video/x-ms-asf");
            AddMimeMapping(".au",       "audio/basic");

            AddMimeMapping(".bin",      "application/octet-stream");
            AddMimeMapping(".bas",      "text/plain");
            AddMimeMapping(".bcpio",    "application/x-bcpio");
            AddMimeMapping(".bmp",      "image/bmp");

            AddMimeMapping(".cdf",      "application/x-cdf");
            AddMimeMapping(".cat",      "application/vndms-pkiseccat");
            AddMimeMapping(".crt",      "application/x-x509-ca-cert");
            AddMimeMapping(".c",        "text/plain");
            AddMimeMapping(".css",      "text/css");
            AddMimeMapping(".cer",      "application/x-x509-ca-cert");
            AddMimeMapping(".crl",      "application/pkix-crl");
            AddMimeMapping(".cmx",      "image/x-cmx");
            AddMimeMapping(".csh",      "application/x-csh");
            AddMimeMapping(".cod",      "image/cis-cod");
            AddMimeMapping(".cpio",     "application/x-cpio");
            AddMimeMapping(".clp",      "application/x-msclip");
            AddMimeMapping(".crd",      "application/x-mscardfile");

            AddMimeMapping(".dll",      "application/x-msdownload");
            AddMimeMapping(".dot",      "application/msword");
            AddMimeMapping(".doc",      "application/msword");
            AddMimeMapping(".dvi",      "application/x-dvi");
            AddMimeMapping(".dir",      "application/x-director");
            AddMimeMapping(".dxr",      "application/x-director");
            AddMimeMapping(".der",      "application/x-x509-ca-cert");
            AddMimeMapping(".dib",      "image/bmp");
            AddMimeMapping(".dcr",      "application/x-director");        
            AddMimeMapping(".disco",     "text/xml");

            AddMimeMapping(".exe",      "application/octet-stream");
            AddMimeMapping(".etx",      "text/x-setext");
            AddMimeMapping(".evy",      "application/envoy");
            AddMimeMapping(".eml",      "message/rfc822");
            AddMimeMapping(".eps",      "application/postscript");        

            AddMimeMapping(".flr",      "x-world/x-vrml");
            AddMimeMapping(".fif",      "application/fractals");        

            AddMimeMapping(".gtar",     "application/x-gtar");
            AddMimeMapping(".gif",      "image/gif");
            AddMimeMapping(".gz" ,      "application/x-gzip");        

            AddMimeMapping(".hta",      "application/hta");
            AddMimeMapping(".htc",      "text/x-component");
            AddMimeMapping(".htt",      "text/webviewhtml");
            AddMimeMapping(".h"  ,      "text/plain");
            AddMimeMapping(".hdf",      "application/x-hdf");
            AddMimeMapping(".hlp",      "application/winhlp");
            AddMimeMapping(".html",     "text/html");
            AddMimeMapping(".htm",      "text/html");
            AddMimeMapping(".hqx",      "application/mac-binhex40");

            AddMimeMapping(".isp",      "application/x-internet-signup");
            AddMimeMapping(".iii",      "application/x-iphone");
            AddMimeMapping(".ief",      "image/ief");
            AddMimeMapping(".ivf",      "video/x-ivf");
            AddMimeMapping(".ins",      "application/x-internet-signup");
            AddMimeMapping(".ico",      "image/x-icon");

            AddMimeMapping(".jpg",      "image/jpeg");
            AddMimeMapping(".jfif",     "image/pjpeg");
            AddMimeMapping(".jpe",      "image/jpeg");
            AddMimeMapping(".jpeg",     "image/jpeg");
            AddMimeMapping(".js",       "application/x-javascript");

            AddMimeMapping(".lsx",      "video/x-la-asf");
            AddMimeMapping(".latex",    "application/x-latex");
            AddMimeMapping(".lsf",      "video/x-la-asf");

            AddMimeMapping(".mhtml",    "message/rfc822");
            AddMimeMapping(".mny",      "application/x-msmoney");
            AddMimeMapping(".mht",      "message/rfc822");
            AddMimeMapping(".mid",      "audio/mid");
            AddMimeMapping(".mpv2",     "video/mpeg"); 
            AddMimeMapping(".man",      "application/x-troff-man");
            AddMimeMapping(".mvb",      "application/x-msmediaview");
            AddMimeMapping(".mpeg",     "video/mpeg");
            AddMimeMapping(".m3u",      "audio/x-mpegurl");
            AddMimeMapping(".mdb",      "application/x-msaccess");
            AddMimeMapping(".mpp",      "application/vnd.ms-project");
            AddMimeMapping(".m1v",      "video/mpeg");
            AddMimeMapping(".mpa",      "video/mpeg");
            AddMimeMapping(".me",       "application/x-troff-me");
            AddMimeMapping(".m13",      "application/x-msmediaview");
            AddMimeMapping(".movie",    "video/x-sgi-movie");
            AddMimeMapping(".m14",      "application/x-msmediaview");
            AddMimeMapping(".mpe",      "video/mpeg");
            AddMimeMapping(".mp2",      "video/mpeg");
            AddMimeMapping(".mov",      "video/quicktime");
            AddMimeMapping(".mp3",      "audio/mpeg");
            AddMimeMapping(".mpg",      "video/mpeg");
            AddMimeMapping(".ms",       "application/x-troff-ms");

            AddMimeMapping(".nc",       "application/x-netcdf");
            AddMimeMapping(".nws",      "message/rfc822");

            AddMimeMapping(".oda",      "application/oda");
            AddMimeMapping(".ods",      "application/oleobject");

            AddMimeMapping(".pmc",      "application/x-perfmon");
            AddMimeMapping(".p7r",      "application/x-pkcs7-certreqresp");
            AddMimeMapping(".p7b",      "application/x-pkcs7-certificates");
            AddMimeMapping(".p7s",      "application/pkcs7-signature");
            AddMimeMapping(".pmw",      "application/x-perfmon");
            AddMimeMapping(".ps",       "application/postscript");
            AddMimeMapping(".p7c",      "application/pkcs7-mime");
            AddMimeMapping(".pbm",      "image/x-portable-bitmap");
            AddMimeMapping(".ppm",      "image/x-portable-pixmap");
            AddMimeMapping(".pub",      "application/x-mspublisher");
            AddMimeMapping(".pnm",      "image/x-portable-anymap");
            AddMimeMapping(".pml",      "application/x-perfmon");
            AddMimeMapping(".p10",      "application/pkcs10");
            AddMimeMapping(".pfx",      "application/x-pkcs12");
            AddMimeMapping(".p12",      "application/x-pkcs12");
            AddMimeMapping(".pdf",      "application/pdf");        
            AddMimeMapping(".pps",      "application/vnd.ms-powerpoint");
            AddMimeMapping(".p7m",      "application/pkcs7-mime");
            AddMimeMapping(".pko",      "application/vndms-pkipko");
            AddMimeMapping(".ppt",      "application/vnd.ms-powerpoint");
            AddMimeMapping(".pmr",      "application/x-perfmon");
            AddMimeMapping(".pma",      "application/x-perfmon");
            AddMimeMapping(".pot",      "application/vnd.ms-powerpoint");
            AddMimeMapping(".prf",      "application/pics-rules");
            AddMimeMapping(".pgm",      "image/x-portable-graymap");

            AddMimeMapping(".qt" ,      "video/quicktime");

            AddMimeMapping(".ra" ,      "audio/x-pn-realaudio");
            AddMimeMapping(".rgb",      "image/x-rgb");
            AddMimeMapping(".ram",      "audio/x-pn-realaudio");
            AddMimeMapping(".rmi",      "audio/mid");
            AddMimeMapping(".ras",      "image/x-cmu-raster");
            AddMimeMapping(".roff",     "application/x-troff");
            AddMimeMapping(".rtf",      "application/rtf");
            AddMimeMapping(".rtx",      "text/richtext");

            AddMimeMapping(".sv4crc",   "application/x-sv4crc");
            AddMimeMapping(".spc",      "application/x-pkcs7-certificates");
            AddMimeMapping(".setreg",   "application/set-registration-initiation");
            AddMimeMapping(".snd",      "audio/basic");
            AddMimeMapping(".stl",      "application/vndms-pkistl");
            AddMimeMapping(".setpay",   "application/set-payment-initiation");
            AddMimeMapping(".stm",      "text/html");
            AddMimeMapping(".shar",     "application/x-shar");
            AddMimeMapping(".sh",       "application/x-sh");
            AddMimeMapping(".sit",      "application/x-stuffit");
            AddMimeMapping(".spl",      "application/futuresplash");
            AddMimeMapping(".sct",      "text/scriptlet");
            AddMimeMapping(".scd",      "application/x-msschedule");
            AddMimeMapping(".sst",      "application/vndms-pkicertstore");
            AddMimeMapping(".src",      "application/x-wais-source");
            AddMimeMapping(".sv4cpio",  "application/x-sv4cpio");

            AddMimeMapping(".tex",      "application/x-tex");
            AddMimeMapping(".tgz",      "application/x-compressed");
            AddMimeMapping(".t",        "application/x-troff");
            AddMimeMapping(".tar",      "application/x-tar");
            AddMimeMapping(".tr",       "application/x-troff");
            AddMimeMapping(".tif",      "image/tiff");
            AddMimeMapping(".txt",      "text/plain");
            AddMimeMapping(".texinfo",  "application/x-texinfo");
            AddMimeMapping(".trm",      "application/x-msterminal");
            AddMimeMapping(".tiff",     "image/tiff");
            AddMimeMapping(".tcl",      "application/x-tcl");
            AddMimeMapping(".texi",     "application/x-texinfo");
            AddMimeMapping(".tsv",      "text/tab-separated-values");

            AddMimeMapping(".ustar",    "application/x-ustar");
            AddMimeMapping(".uls",      "text/iuls");

            AddMimeMapping(".vcf",      "text/x-vcard");

            AddMimeMapping(".wps",      "application/vnd.ms-works");
            AddMimeMapping(".wav",      "audio/wav");
            AddMimeMapping(".wrz",      "x-world/x-vrml");
            AddMimeMapping(".wri",      "application/x-mswrite");
            AddMimeMapping(".wks",      "application/vnd.ms-works");
            AddMimeMapping(".wmf",      "application/x-msmetafile");
            AddMimeMapping(".wcm",      "application/vnd.ms-works");
            AddMimeMapping(".wrl",      "x-world/x-vrml");
            AddMimeMapping(".wdb",      "application/vnd.ms-works");
            AddMimeMapping(".wsdl",     "text/xml");


            AddMimeMapping(".xml",      "text/xml");
            AddMimeMapping(".xlm",      "application/vnd.ms-excel");
            AddMimeMapping(".xaf",      "x-world/x-vrml");
            AddMimeMapping(".xla",      "application/vnd.ms-excel");
            AddMimeMapping(".xls",      "application/vnd.ms-excel");
            AddMimeMapping(".xof",      "x-world/x-vrml");
            AddMimeMapping(".xlt",      "application/vnd.ms-excel");
            AddMimeMapping(".xlc",      "application/vnd.ms-excel");
            AddMimeMapping(".xsl",      "text/xml");
            AddMimeMapping(".xbm",      "image/x-xbitmap");
            AddMimeMapping(".xlw",      "application/vnd.ms-excel");
            AddMimeMapping(".xpm",      "image/x-xpixmap");
            AddMimeMapping(".xwd",      "image/x-xwindowdump");
            AddMimeMapping(".xsd",      "text/xml");

            AddMimeMapping(".z",        "application/x-compress");
            AddMimeMapping(".zip",      "application/x-zip-compressed");        

            AddMimeMapping(".*",        "application/octet-stream");
        }
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\httpruntime.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpRuntime.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * The ASP.NET runtime services
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web {
    using System.Text;
    using System.Threading;
    using System.Data;
    using System.IO;
    using System.Collections;
    using System.Configuration;
    using System.Globalization;
    using System.Reflection;
    using System.Resources;
    using System.Security;
    using System.Security.Permissions;
    using System.Security.Policy;
    using System.Web;
    using System.Web.UI;
    using System.Web.Util;
    using System.Web.Configuration;
    using System.Web.Caching;
    using System.Web.Security;
    using System.Runtime.Remoting.Messaging;
    using Microsoft.Win32;
    using System.Security.Cryptography;


    /// <include file='doc\HttpRuntime.uex' path='docs/doc[@for="HttpRuntime"]/*' />
    /// <devdoc>
    ///    <para>Provides a set of ASP.NET runtime services.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class HttpRuntime {

        private const string codegenDirName = "Temporary ASP.NET Files";

        private static HttpRuntime _theRuntime;   // single instance of the class
        internal  static byte []    s_autogenKeys = new byte[88];

        static HttpRuntime() {

            AddAppDomainTraceMessage("*HttpRuntime::cctor");

            // Skip initialization when running in designer (ASURT 74814)
            if (!DesignTimeParseData.InDesigner)
                Initialize();

            _theRuntime = new HttpRuntime();

            // Skip initialization when running in designer (ASURT 74814)
            if (!DesignTimeParseData.InDesigner)
                _theRuntime.Init();

            AddAppDomainTraceMessage("HttpRuntime::cctor*");
        }

        /// <include file='doc\HttpRuntime.uex' path='docs/doc[@for="HttpRuntime.HttpRuntime"]/*' />
        public HttpRuntime() {
            InternalSecurityPermissions.UnmanagedCode.Demand();
        }

        //
        // static initialization to get hooked up to the unmanaged code
        // get installation directory, etc.
        //

        private static bool s_initialized = false;
        private static String s_installDirectory;
        private static bool s_isapiLoaded = false;

        private static void Initialize() {
            if (s_initialized) {
                // already initialized
                return;
            }

            bool   isapiLoaded = false;
            String installDir  = null;

            // Check if ISAPI is pre-loaded
            //    and get the install directory from there

            String preloadedIsapi = VersionInfo.GetLoadedModuleFileName(ModName.ISAPI_FULL_NAME);

            if (preloadedIsapi != null) {
                //Debug.Trace("Initialization", "1: " + preloadedIsapi + " pre-loaded");
                installDir = preloadedIsapi.Substring(0, preloadedIsapi.LastIndexOf('\\'));
                isapiLoaded = true;
            }

            // Get install directory from the registry: HKLM\Software\Microsoft\ASP.NET\<version>\Path.
            // Use the Major, Minor, and Build number from System.Web.dll and try to find a match.
            // It's impossible for the Path key to vary solely on QFE number, so it's safe to ignore.

            if (installDir == null || installDir.Length == 0) {
              RegistryKey regKey1 = null;
              RegistryKey regKey2 = null;
              try {

                string ver = VersionInfo.SystemWebVersion;
                regKey1 = Registry.LocalMachine.OpenSubKey("Software\\Microsoft\\ASP.NET\\");

                if (regKey1 != null) {
                  string[] subKeys = regKey1.GetSubKeyNames();

                  if (subKeys != null) {
                    string majorMinorBuild = ver.Substring(0, VersionInfo.SystemWebVersion.LastIndexOf('.'));

                    for(int i = 0; i < subKeys.Length; i++) {

                      if (subKeys[i] != null && subKeys[i].StartsWith(majorMinorBuild)) {
                        regKey2 = Registry.LocalMachine.OpenSubKey("Software\\Microsoft\\ASP.NET\\" + subKeys[i]);

                        if (regKey2 != null) {
                          installDir = (String)regKey2.GetValue("Path");
                          regKey2.Close();
                          break;
                        }
                        
                      }
                      
                    }
                    
                  }
                  
                }
              }
              catch {
                installDir = null;
              }
              finally {
                if (regKey1 != null) {
                  regKey1.Close();
                }
                if (regKey2 != null) {
                  regKey2.Close();
                }
              }
            }



            // Fallback - assume install directory is where system.web is

            if (installDir == null || installDir.Length == 0) {
                string p = typeof(HttpRuntime).Module.FullyQualifiedName;
                installDir = p.Substring(0, p.LastIndexOf('\\'));
                //Debug.Trace("Initialization", "3: Fallback, using '" + installDir + "' as install directory");
            }

            // Load ISAPI if not loaded already

            if (!isapiLoaded) {
                String fullPath = installDir + "\\" + ModName.ISAPI_FULL_NAME;
                
                if (UnsafeNativeMethods.LoadLibrary(fullPath) == IntPtr.Zero) {
                    //Debug.Trace("Initialization", "Failed to load " + fullPath);
                }
                else {
                    isapiLoaded = true;
                    //Debug.Trace("Initialization", "4: Loaded " + fullPath);
                }
            }

            // Init ISAPI

            if (isapiLoaded) {
                UnsafeNativeMethods.InitializeLibrary();
            }

            // done
            //Debug.Trace("Initialization", "Install directory is " + installDir);

            s_installDirectory = installDir;
            s_isapiLoaded = isapiLoaded;
            s_initialized = true;

            AddAppDomainTraceMessage("Initialize");
        }


        //
        // Runtime services
        //

        private NamedPermissionSet      _namedPermissionSet;
        private FileChangesMonitor      _fcm;
        private CacheInternal           _cache;
        private bool                    _isOnUNCShare;
        private Profiler                _profiler;
        private RequestTimeoutManager   _timeoutManager;
        private RequestQueue            _requestQueue;

        //
        // Counters
        //

        private bool _beforeFirstRequest = true;
        private DateTime _firstRequestStartTime;
        private bool _firstRequestCompleted;
        private bool _userForcedShutdown;
        private bool _configInited;
        private int  _activeRequestCount;
        private bool _someBatchCompilationStarted;
        private bool _shutdownInProgress;
        private String _shutDownStack;
        private String _shutDownMessage;
        private DateTime _lastShutdownAttemptTime;

        //
        // Callbacks
        //

        private AsyncCallback _handlerCompletionCallback;
        private HttpWorkerRequest.EndOfSendNotification _asyncEndOfSendCallback;
        private WaitCallback _appDomainUnloadallback;

        //
        // Initialization error (to be reported on subsequent requests)
        //

        private Exception _initializationError;
        private Timer     _appDomainShutdownTimer = null;

        //
        // App domain related
        //

        private String _codegenDir;
        private String _appDomainAppId;
        private String _appDomainAppPath;
        private String _appDomainAppVPath;
        private String _appDomainId;

        //
        // Resource manager
        //

        private ResourceManager _resourceManager;

        //
        // Debugging support
        //

        private bool _debuggingEnabled = false;
        private bool _vsDebugAttach = false;
        
        /////////////////////////////////////////////////////////////////////////

        /*
         * Context-less initialization (on app domain creation)
         */
        private void Init() {
            _initializationError = null;

            try {
                if (Environment.OSVersion.Platform != PlatformID.Win32NT)
                    throw new PlatformNotSupportedException(SR.GetString(SR.RequiresNT));

                _fcm            = new FileChangesMonitor();
                _cache          = CacheInternal.Create();
                _profiler       = new Profiler();
                _timeoutManager = new RequestTimeoutManager();

                _handlerCompletionCallback = new AsyncCallback(this.OnHandlerCompletion);
                _asyncEndOfSendCallback = new HttpWorkerRequest.EndOfSendNotification(this.EndOfSendCallback);
                _appDomainUnloadallback = new WaitCallback(this.ReleaseResourcesAndUnloadAppDomain);


                // appdomain values
                if (GetAppDomainString(".appDomain") != null) {
                    _appDomainAppId     = GetAppDomainString(".appId");
                    _appDomainAppPath   = GetAppDomainString(".appPath");
                    _appDomainAppVPath  = GetAppDomainString(".appVPath");
                    _appDomainId        = GetAppDomainString(".domainId");

                    _isOnUNCShare = _appDomainAppPath.StartsWith("\\\\");

                    // init perf counters for this appdomain
                    PerfCounters.Open(_appDomainAppId);

                    // count in the request we are executing currently
                    // but have not counted in yet
                    PerfCounters.IncrementCounter(AppPerfCounter.REQUESTS_TOTAL);
                }
            }
            catch (Exception e) {
                // remember static initalization error
                _initializationError = e;
                StartAppDomainShutdownTimer();
            }
        }

        private void AppDomainShutdownTimerCallback(Object state) {
            ShutdownAppDomain("Initialization Error");
        }

        private void StartAppDomainShutdownTimer() {
            if (_appDomainShutdownTimer == null) {
                lock (this) {
                    if (_appDomainShutdownTimer == null) {
                        _appDomainShutdownTimer = new Timer(
                            new TimerCallback(this.AppDomainShutdownTimerCallback), 
                            null, 
                            10 * 1000, 
                            0);
                    }
                }
            }
        }

        private void EnsureAccessToApplicationDirectory() {
            if (!FileUtil.DirectoryAccessible(_appDomainAppPath))
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Access_denied_to_app_dir, _appDomainAppPath));
        }

        private void StartMonitoringDirectoryRenamesAndBinDirectory() {
            _fcm.StartMonitoringDirectoryRenamesAndBinDirectory(AppDomainAppPathInternal, new FileChangeEventHandler(this.OnCriticalDirectoryChange));
        }

        private void InitFusion() {

            AppDomain appDomain = Thread.GetDomain();

            CompilationConfiguration compConfig =  (CompilationConfiguration)HttpContext.GetAppConfig(
                CompilationConfiguration.sectionName);

            string codegenBase;

            string simpleAppName = System.Web.Hosting.AppDomainFactory.ConstructSimpleAppName(
                AppDomainAppVirtualPath);

            string tempDirectory;
            if (compConfig != null && compConfig.TempDirectory != null) {
                tempDirectory = compConfig.TempDirectory;
            }
            else {
                tempDirectory = s_installDirectory + "\\" + codegenDirName;
            }

            codegenBase = Path.Combine(tempDirectory, simpleAppName);

            appDomain.SetDynamicBase(codegenBase);

            _codegenDir = Thread.GetDomain().DynamicDirectory;

            // If there is a double backslash in the string, get rid of it (ASURT 122191)
            // Make sure to skip the first char, to avoid breaking the UNC case
            string appDomainAppPath = _appDomainAppPath;
            if (appDomainAppPath.IndexOf(@"\\", 1) >= 1) {
                appDomainAppPath = appDomainAppPath[0] + appDomainAppPath.Substring(1).Replace(@"\\", @"\");
            }

            // enable shadow-copying from bin
            appDomain.SetShadowCopyPath(appDomainAppPath + "bin");

            // Get rid of the last part of the directory (the app name), since it will
            // be re-appended.
            string parentDir = Directory.GetParent(_codegenDir).FullName;
            appDomain.SetCachePath(parentDir);
        }

        private void InitRequestQueue() {
            HttpRuntimeConfig runtimeConfig = (HttpRuntimeConfig)HttpContext.GetAppConfig("system.web/httpRuntime");

            if (runtimeConfig != null) {
                _requestQueue = new RequestQueue(
                        runtimeConfig.MinFreeThreads,
                        runtimeConfig.MinLocalRequestFreeThreads,
                        runtimeConfig.AppRequestQueueLimit);
            }
            else {
                _requestQueue = new RequestQueue(
                        HttpRuntimeConfig.DefaultMinFreeThreads,
                        HttpRuntimeConfig.DefaultMinLocalRequestFreeThreads,
                        HttpRuntimeConfig.DefaultAppRequestQueueLimit);
            }
        }

        private void InitTrace(HttpContext context) {
            TraceConfig traceConfig = (TraceConfig) HttpContext.GetAppConfig("system.web/trace");

            if (traceConfig != null) {
                Profile.RequestsToProfile = traceConfig.RequestLimit;
                Profile.PageOutput = traceConfig.PageOutput;
                Profile.OutputMode = traceConfig.OutputMode;
                Profile.LocalOnly = traceConfig.LocalOnly;
                Profile.IsEnabled = traceConfig.IsEnabled;
                Profile.Reset();

                // the first request's context is created before InitTrace, so 
                // we need to set this manually. (ASURT 93730)
                context.TraceIsEnabled = traceConfig.IsEnabled;
            }
        }

        private void InitDebuggingSupport() {
            CompilationConfiguration compConfig = 
            (CompilationConfiguration)HttpContext.GetAppConfig(CompilationConfiguration.sectionName);

            if (compConfig == null)
                _debuggingEnabled = false;
            else
                _debuggingEnabled = compConfig.DebuggingEnabled;
        }

        /*
         * Pre-load all the bin assemblies if we're impersonated.  This way, if user code
         * calls Assembly.Load while impersonated, the assembly will already be loaded, and
         * we won't fail due to lack of permissions on the codegen dir (see ASURT 114486)
         */
        private void PreloadAssembliesFromBin(HttpContext context) {
            bool appClientImpersonationEnabled = false;

            if (!_isOnUNCShare) {
                // if not on UNC share check if config has impersonation enabled (without userName)
                IdentityConfig c = (IdentityConfig)HttpContext.GetAppConfig("system.web/identity");
                if (c != null && c.EnableImpersonation && c.ImpersonateToken == IntPtr.Zero)
                    appClientImpersonationEnabled = true;
            }

            if (!appClientImpersonationEnabled)
                return;

            // Get the path to the bin directory
            string binPath = HttpRuntime.BinDirectoryInternal;

            if (!FileUtil.DirectoryExists(binPath))
                return;

            // If the codegen directory is out of date, make sure we wipe it out *before*
            // loading the assemblies.  Otherwise, we end up trying to wipe out the assemblies
            // we just shadow copied, which causes all kind of problems (ASURT 144568)
            System.Web.Compilation.PreservedAssemblyEntry.EnsureFirstTimeInit(context);

            DirectoryInfo binPathDirectory = new DirectoryInfo(binPath);
            FileInfo[] binDlls = binPathDirectory.GetFiles("*.dll");

            // Pre-load all the assemblies, ignoring all exceptions
            foreach (FileInfo fi in binDlls) {
                try { Assembly.LoadFrom(fi.FullName); } catch { }
            }
        }

        private void SetThreadPoolLimits(HttpContext context) {
            ProcessModelConfig pmConfig = (ProcessModelConfig)context.GetMachineConfig(ProcessModelConfigurationHandler.sectionName);

            if (pmConfig != null && pmConfig.MaxWorkerThreads > 0 && pmConfig.MaxIoThreads > 0) {
                // check if the current limits are ok
                int workerMax, ioMax;
                ThreadPool.GetMaxThreads(out workerMax, out ioMax);

                // only set if different
                if (pmConfig.MaxWorkerThreads != workerMax || pmConfig.MaxIoThreads != ioMax) {
                    Debug.Trace("ThreadPool", "SetThreadLimit: from " + workerMax + "," + ioMax + " to " + pmConfig.MaxWorkerThreads + "," + pmConfig.MaxIoThreads);
                    UnsafeNativeMethods.SetClrThreadPoolLimits(pmConfig.MaxWorkerThreads, pmConfig.MaxIoThreads, true);
                }
            }
            if (pmConfig != null && (pmConfig.MinWorkerThreads > 0 || pmConfig.MinIoThreads > 0)){ 
                int currentMinWorkerThreads, currentMinIoThreads; 
                ThreadPool.GetMinThreads(out currentMinWorkerThreads, out currentMinIoThreads);
               
                int newMinWorkerThreads = pmConfig.MinWorkerThreads > 0 ? pmConfig.MinWorkerThreads : currentMinWorkerThreads;
                int newMinIoThreads = pmConfig.MinIoThreads > 0 ? pmConfig.MinIoThreads : currentMinIoThreads;

                if (newMinWorkerThreads > 0 && newMinIoThreads > 0 
                    && (newMinWorkerThreads != currentMinWorkerThreads || newMinIoThreads != currentMinIoThreads))
                    ThreadPool.SetMinThreads(newMinWorkerThreads, newMinIoThreads);
            }
        }

        private void InitializeHealthMonitoring(HttpContext context) {
            ProcessModelConfig pmConfig = (ProcessModelConfig)context.GetMachineConfig(ProcessModelConfigurationHandler.sectionName);
            int deadLockInterval = (pmConfig != null) ? pmConfig.ResponseDeadlockInterval : 0;
            Debug.Trace("HealthMonitor", "Initalizing: ResponseDeadlockInterval=" + deadLockInterval);
            UnsafeNativeMethods.InitializeHealthMonitor(deadLockInterval);
        }

        internal static void InitConfiguration(HttpContext context) {

            if (!_theRuntime._configInited) {
                _theRuntime._configInited = true;
                HttpConfigurationSystemBase.EnsureInit();

                HttpConfigurationSystem.Init(context); // first-request init

                // whenever possible report errors in the user's culture (from machine.config)
                // Note: this thread's culture is saved/restored during FirstRequestInit, so this is safe
                // see ASURT 81655

                Exception globalizationError;
                GlobalizationConfig globConfig;
                try { 
                    globConfig = (GlobalizationConfig)HttpContext.GetAppConfig("system.web/globalization");
                } catch (Exception e) {
                    globalizationError = e;
                    globConfig = (GlobalizationConfig)context.GetAppLKGConfig("system.web/globalization");
                }
                if (globConfig != null) {
                    if (globConfig.Culture != null)
                        Thread.CurrentThread.CurrentCulture = globConfig.Culture;

                    if (globConfig.UICulture != null)
                        Thread.CurrentThread.CurrentUICulture = globConfig.UICulture;
                }

                // check for errors in <processModel> section
                HttpContext.GetAppConfig(ProcessModelConfigurationHandler.sectionName);
            }
        }

        private static void SetAutogenKeys(HttpContext context) {
            byte []                  bKeysRandom     = new byte[s_autogenKeys.Length];
            byte []                  bKeysStored     = new byte[s_autogenKeys.Length];
            bool                     fGetStoredKeys  = false;
            RNGCryptoServiceProvider randgen         = new RNGCryptoServiceProvider();

            // Gernerate random keys
            randgen.GetBytes(bKeysRandom);

            // Get stored keys via ISAPIWorkerRequest object
            if (context.WorkerRequest is System.Web.Hosting.ISAPIWorkerRequest)
                fGetStoredKeys = (context.CallISAPI(UnsafeNativeMethods.CallISAPIFunc.GetAutogenKeys, bKeysRandom, bKeysStored) == 1);
            
            // If getting stored keys via WorkerRequest object failed, get it directly
            if (!fGetStoredKeys)
                fGetStoredKeys = (UnsafeNativeMethods.EcbCallISAPI((IntPtr) 0, UnsafeNativeMethods.CallISAPIFunc.GetAutogenKeys,
                                                                   bKeysRandom, bKeysRandom.Length, bKeysStored, bKeysStored.Length) == 1);
            
            // If we managed to get stored keys, copy them in; else use random keys
            if (fGetStoredKeys)
                Buffer.BlockCopy(bKeysStored, 0,  s_autogenKeys, 0, s_autogenKeys.Length);
            else
                Buffer.BlockCopy(bKeysRandom, 0,  s_autogenKeys, 0, s_autogenKeys.Length);                            
        }


        /*
         * Initialization on first request (context available)
         */
        private void FirstRequestInit(HttpContext context) {
            bool cacheInitializationError = false;
            Exception initializationError = null;

            if (_initializationError == null && _appDomainId != null) {
                try {
                    using (new HttpContextWrapper(context)) {
                        // when application is on UNC share the code below must
                        // be run while impersonating the token given by IIS
                        context.Impersonation.Start(true, true);

                        try {
                            // Is this necessary?  See InitConfiguration
                            CultureInfo savedCulture = Thread.CurrentThread.CurrentCulture;
                            CultureInfo savedUICulture = Thread.CurrentThread.CurrentUICulture;

                            try {
                                // Throw an exception about lack of access to app directory early on
                                EnsureAccessToApplicationDirectory();

                                // Monitor renames to directories we are watching, and notifications on the bin directory
                                StartMonitoringDirectoryRenamesAndBinDirectory();

                                // Cache any errors that might occur below
                                // (can't cache errors above as there is no change notifications working)
                                cacheInitializationError = true;

                                SetAutogenKeys(context);

                                // Ensure config system is initialized
                                InitConfiguration(context); // be sure config system is set

                                // Adjust thread pool limits if needed
                                SetThreadPoolLimits(context);

                                // Initialize health monitoring
                                InitializeHealthMonitoring(context);

                                // Configure fusion to use directories set in the app config
                                InitFusion();

                                // Init request queue (after reading config)
                                InitRequestQueue();

                                // Set code access policy on the app domain
                                SetTrustLevel();

                                // Init debugging
                                InitDebuggingSupport();

                                // configure the profiler according to config
                                InitTrace(context);

                                // Remove read and browse access of the bin directory
                                SetBinAccess(context);

                                // Preload all assemblies from bin (only if required).  ASURT 114486
                                PreloadAssembliesFromBin(context);
                            }
                            finally {
                                Thread.CurrentThread.CurrentUICulture = savedUICulture;
                                Thread.CurrentThread.CurrentCulture = savedCulture;
                            }
                        }
                        finally {
                            // revert after impersonation
                            context.Impersonation.Stop();
                        }
                    }
                }
                catch (ConfigurationException e) {
                    initializationError = e;
                }
                catch (Exception e) {
                    // remember second-phase initialization error
                    initializationError = new HttpException(HttpRuntime.FormatResourceString(SR.XSP_init_error), e);
                }
            }

            if (_initializationError != null) {
                // throw cached exception
                throw _initializationError;
            }
            else if (initializationError != null) {
                // cache when appropriate
                if (cacheInitializationError) {
                    _initializationError = initializationError;
                    StartAppDomainShutdownTimer();
                }

                // throw new exception
                throw initializationError;
            }

            AddAppDomainTraceMessage("FirstRequestInit");
        }

        /*
         * Process one request
         */
        private void ProcessRequestInternal(HttpWorkerRequest wr) {
            // Construct the Context on HttpWorkerRequest, hook everything together
            HttpContext context = new HttpContext(wr, false /* initResponseWriter */);
            wr.SetEndOfSendNotification(_asyncEndOfSendCallback, context);

            // Count active requests
            Interlocked.Increment(ref _activeRequestCount);

            try {
                // First request initialization

                if (_beforeFirstRequest) {
                    lock(this) {
                        if (_beforeFirstRequest) {
                            _firstRequestStartTime = DateTime.UtcNow;
                            FirstRequestInit(context);
                            _beforeFirstRequest = false;
                        }
                    }
                }

                // when application is on UNC share the code below must
                // be run while impersonating the token given by IIS (ASURT 80607)
                context.Impersonation.Start(true /*forGlobalCode*/, false /*throwOnError*/);

                try {
                    // Init response writer (after we have config in first request init)
                    context.Response.InitResponseWriter();
                }
                finally {
                    // revert after impersonation
                    context.Impersonation.Stop();
                }

                // Get application instance
                IHttpHandler app = HttpApplicationFactory.GetApplicationInstance(context);

                if (app == null)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Unable_create_app_object));

                // Process the request

                if (app is IHttpAsyncHandler) {
                    // asynchronous handler
                    IHttpAsyncHandler asyncHandler = (IHttpAsyncHandler)app;
                    context.AsyncAppHandler = asyncHandler;
                    asyncHandler.BeginProcessRequest(context, _handlerCompletionCallback, context);
                }
                else {
                    // synchronous handler
                    app.ProcessRequest(context);
                    FinishRequest(context.WorkerRequest, context, null);
                }
            }
            catch (Exception e) {
                context.Response.InitResponseWriter();
                FinishRequest(wr, context, e);
            }
        }

        private void RejectRequestInternal(HttpWorkerRequest wr) {
            // Construct the Context on HttpWorkerRequest, hook everything together
            HttpContext context = new HttpContext(wr, false /* initResponseWriter */);
            wr.SetEndOfSendNotification(_asyncEndOfSendCallback, context);

            // Count active requests
            Interlocked.Increment(ref _activeRequestCount);

            PerfCounters.IncrementGlobalCounter(GlobalPerfCounter.REQUESTS_REJECTED);

            try {
                throw new HttpException(503, HttpRuntime.FormatResourceString(SR.Server_too_busy));
            }
            catch (Exception e) {
                context.Response.InitResponseWriter();
                FinishRequest(wr, context, e);
            }
        }


        /*
         * Finish processing request, sync or async
         */
        private void FinishRequest(HttpWorkerRequest wr, HttpContext context, Exception e) {


            // Flush in case of no error
            if (e == null) {
                // Set the Request Execution time perf counter
                TimeSpan elapsed = DateTime.UtcNow.Subtract(context.UtcTimestamp);
                long milli = elapsed.Ticks / TimeSpan.TicksPerMillisecond;

                if (milli > Int32.MaxValue)
                    milli = Int32.MaxValue;
                
                PerfCounters.SetGlobalCounter(GlobalPerfCounter.REQUEST_EXECUTION_TIME, (int) milli);
                
                // impersonate around PreSendHeaders / PreSendContent
                context.Impersonation.Start(false /*forGlobalCode*/, false /*throwOnError*/);

                try {
                    // this sends the actual content in most cases
                    context.Response.FinalFlushAtTheEndOfRequestProcessing();
                }
                catch (Exception eFlush) {
                    e = eFlush;
                }
                finally {
                    // revert after impersonation
                    context.Impersonation.Stop();
                }
            }

            // Report error if any
            if (e != null) {
                using (new HttpContextWrapper(context)) {

                    // when application is on UNC share the code below must
                    // be run while impersonating the token given by IIS
                    context.Impersonation.Start(true /*forGlobalCode*/, false /*throwOnError*/);

                    try {
                        try {
                            // try to report error in a way that could possibly throw (a config exception)
                            context.Response.ReportRuntimeError(e, true /*canThrow*/);
                        }
                        catch (Exception eReport) {
                            // report the config error in a way that would not throw
                            context.Response.ReportRuntimeError(eReport, false /*canThrow*/);
                        }

                        context.Response.FinalFlushAtTheEndOfRequestProcessing();
                    }
                    catch {
                    }
                    finally {
                        // revert after impersonation
                        context.Impersonation.Stop();
                    }
                }
            }

            // Remember that first request is done
            if (!_firstRequestCompleted)
                _firstRequestCompleted = true;

            // Check status code and increment proper counter
            // If it's an error status code (i.e. 400 or higher), increment the proper perf counters
            int statusCode = context.Response.StatusCode;
            if (400 <= statusCode) {
                PerfCounters.IncrementCounter(AppPerfCounter.REQUESTS_FAILED);
                switch (statusCode) {
                    case 401: // Not authorized
                        PerfCounters.IncrementCounter(AppPerfCounter.REQUESTS_NOT_AUTHORIZED);
                        break;
                    case 404: // Not found
                    case 414: // Not found
                        PerfCounters.IncrementCounter(AppPerfCounter.REQUESTS_NOT_FOUND);
                        break;
                }
            }
            else {  
                // If status code is not in the 400-599 range (i.e. 200-299 success or 300-399 redirection),
                // count it as a successful request.
                PerfCounters.IncrementCounter(AppPerfCounter.REQUESTS_SUCCEDED);
            }
            
            // Fire the BeforeDoneWithSession event, which allows whoever registered
            // for it to do any processing that needs to be done before the end of the 
            // request (for example, calls do MapPath that require a valid ECB).
            if (context.HasBeforeDoneWithSessionHandlers) {
                try {
                    // the following could be a long call
                    context.OnBeforeDoneWithSession(EventArgs.Empty);
                }
                catch {
                }
                finally {
                    // to make the Flush that follows really final
                    context.ClearBeforeDoneWithSessionHandlers();
                }

                // impersonate around PreSendHeaders / PreSendContent
                context.Impersonation.Start(false /*forGlobalCode*/, false /*throwOnError*/);

                try {
                    // Flush again to Finish the request for good
                    context.Response.FinalFlushAtTheEndOfRequestProcessing();
                }
                catch {
                }
                finally {
                    // revert after impersonation
                    context.Impersonation.Stop();
                }
            }

            wr.EndOfRequest();

            // Count active requests
            Interlocked.Decrement(ref _activeRequestCount);


            // Schedule more work if some requests are queued
            if (_requestQueue != null)
                _requestQueue.ScheduleMoreWorkIfNeeded();
        }

        //
        // Make sure shutdown happens only once
        //

        private bool InitiateShutdownOnce() {
            if (_shutdownInProgress)
                return false;

            lock(this) {
                if (_shutdownInProgress)
                    return false;
                _shutdownInProgress = true;
            }

            return true;
        }

        //
        // Shutdown this and restart new app domain
        //

        private void ReleaseResourcesAndUnloadAppDomain(Object state /*not used*/) {
            Debug.Trace("AppDomainFactory", "ReleaseResourcesAndUnloadAppDomain, Id=" + _appDomainAppId);

            try {
                PerfCounters.IncrementGlobalCounter(GlobalPerfCounter.APPLICATION_RESTARTS);
            }
            catch {
            }

            // Release all resources
            try {
                Dispose();
            }
            catch {
            }

            Thread.Sleep(250);

            AddAppDomainTraceMessage("before Unload");

            try {
                AppDomain.Unload(Thread.GetDomain());
            }
            catch (Exception e) {
                Debug.Trace("AppDomainFactory", "AppDomain.Unload exception: " + e + "; Id=" + _appDomainAppId);
                AddAppDomainTraceMessage("Unload Exception: " + e);
                throw;
            }
        }

        private void WaitForRequestsToFinish(int waitTimeoutMs) {
            DateTime waitLimit = DateTime.UtcNow.AddMilliseconds(waitTimeoutMs);

            for (;;) {
                if (_activeRequestCount == 0 && (_requestQueue == null || _requestQueue.IsEmpty))
                    break;

                Thread.Sleep(250);

                // only apply timeout if a managed debugger is not attached
                if (!System.Diagnostics.Debugger.IsAttached && DateTime.UtcNow > waitLimit) {
                    break; // give it up
                }
            }
        }

        /*
         * Cleanup of all unmananged state
         */
        private void Dispose() {
            int drainTimeoutSec = HttpRuntimeConfig.DefaultShutdownTimeout;
            try {
                HttpRuntimeConfig runtimeConfig = (HttpRuntimeConfig)HttpContext.GetAppConfig("system.web/httpRuntime");
                if (runtimeConfig != null)
                    drainTimeoutSec = runtimeConfig.ShutdownTimeout;
            }
            catch {
            }
 
            // before aborting compilation give time to drain (new requests are no longer coming at this point)
            WaitForRequestsToFinish((drainTimeoutSec*1000)/2);

            // abort batch compilation threads
            if (_someBatchCompilationStarted) {
                try {
                    System.Web.Compilation.PreservedAssemblyEntry.AbortBackgroundBatchCompilations();
                }
                catch {
                }
            }

            // give it some more time to drain
            WaitForRequestsToFinish((drainTimeoutSec*1000)/3);

            // reject remaining queued requests
            if (_requestQueue != null)
                _requestQueue.Drain();

            // give it a little more time to drain
            WaitForRequestsToFinish((drainTimeoutSec*1000)/6);

           
            // wait for pending async io to complete,  prior to aborting requests
            System.Web.Hosting.ISAPIWorkerRequestInProcForIIS6.WaitForPendingAsyncIo();

            // kill all remaining requests (and the timeout timer)
            _timeoutManager.Stop();

            // give it a little more time to drain
            WaitForRequestsToFinish((drainTimeoutSec*1000)/6);

            // double check for pending async io
            System.Web.Hosting.ISAPIWorkerRequestInProcForIIS6.WaitForPendingAsyncIo();


            // cleanup cache (this ends all sessions)
            _cache.Dispose();

            // app on end, cleanup app instances
            HttpApplicationFactory.EndApplication();  // call app_onEnd

            // stop file changes monitor
            _fcm.Stop();

            PerfCounters.Close();
        }

        /*
         * Completion of asynchronous application
         */
        private void OnHandlerCompletion(IAsyncResult ar) {
            HttpContext context = (HttpContext)ar.AsyncState;

            try {
                context.AsyncAppHandler.EndProcessRequest(ar);
            }
            catch (Exception e) {
                context.AddError(e);
            }
            finally {
                // no longer keep AsyncAppHandler poiting to the application
                // is only needed to call EndProcessRequest
                context.AsyncAppHandler = null;
            }

            FinishRequest(context.WorkerRequest, context, context.Error);
        }

        /*
         * Notification from worker request that it is done writing from buffer
         * so that the buffers can be recycled
         */
        private void EndOfSendCallback(HttpWorkerRequest wr, Object arg) {
            HttpContext context = (HttpContext)arg;
            context.Request.Dispose();
            context.Response.Dispose();
        }

        /*
         * Notification when something in the bin directory changed
         */
        private void OnCriticalDirectoryChange(Object sender, FileChangeEvent e) {
            // shutdown the app domain
            Debug.Trace("AppDomainFactory", "Shutting down appdomain because of bin dir change or directory rename");
            ShutdownAppDomain();
        }

        /**
         * Coalesce file change notifications to minimize sharing violations and AppDomain restarts (ASURT 147492)
         */

        private void CoalesceNotifications() {
            int waitChangeNotification = HttpRuntimeConfig.DefaultWaitChangeNotification;
            int maxWaitChangeNotification = HttpRuntimeConfig.DefaultMaxWaitChangeNotification;
            try {
                HttpRuntimeConfig config = (HttpRuntimeConfig)HttpContext.GetAppConfig("system.web/httpRuntime");
                if (config != null) {
                    waitChangeNotification = config.WaitChangeNotification;
                    maxWaitChangeNotification = config.MaxWaitChangeNotification;
                }
            }
            catch {
            }
            
            if (waitChangeNotification == 0 || maxWaitChangeNotification == 0)
                return;
            
            DateTime maxWait = DateTime.UtcNow.AddSeconds(maxWaitChangeNotification);
            // Coalesce file change notifications
            try {
                while (DateTime.UtcNow < maxWait) {
                    if (DateTime.UtcNow > LastShutdownAttemptTime.AddSeconds(waitChangeNotification))
                        break;

                    Thread.Sleep(250);
                }
            }
            catch { 
            }
        }
        

        /*
         * Shutdown the current app domain
         */
        internal static void ShutdownAppDomain(String message) {
            if (message != null)
                SetShutdownMessage(message);
            ShutdownAppDomain();
        }



        private static void ShutdownAppDomain() {
            // Ignore notifications during the processing of the first request (ASURT 100335)
            if (!_theRuntime._firstRequestCompleted && !_theRuntime._userForcedShutdown) {
                // check the timeout (don't disable notifications forever
                int delayTimeoutSec = HttpRuntimeConfig.DefaultDelayNotificationTimeout;
                try {
                    HttpRuntimeConfig runtimeConfig = (HttpRuntimeConfig)HttpContext.GetAppConfig("system.web/httpRuntime");
                    if (runtimeConfig != null)
                        delayTimeoutSec = runtimeConfig.DelayNotificationTimeout;
                }
                catch {
                }

                if (DateTime.UtcNow < _theRuntime._firstRequestStartTime.AddSeconds(delayTimeoutSec)) {
                    Debug.Trace("AppDomainFactory", "ShutdownAppDomain IGNORED (1st request is not done yet), Id = " + AppDomainAppIdInternal);
                    return;
                }
            }

            // Update last time ShutdownAppDomain was called
            _theRuntime.LastShutdownAttemptTime = DateTime.UtcNow;
            
            // Make sure we don't go through shutdown logic many times
            if (!_theRuntime.InitiateShutdownOnce())
                return;

            _theRuntime.CoalesceNotifications();

            Debug.Trace("AppDomainFactory", "ShutdownAppDomain, Id = " + AppDomainAppIdInternal + ", ShutdownInProgress=" + ShutdownInProgress);

            // Tell unmanaged code not to dispatch requests to this app domain
            try {
                if (_theRuntime._appDomainAppId != null ) {
                    UnsafeNativeMethods.AppDomainRestart(_theRuntime._appDomainAppId);
                }

                AddAppDomainTraceMessage("AppDomainRestart");
            }
            catch {
            }

            // Instrument to be able to see what's causing a shutdown
            _theRuntime._shutDownStack = Environment.StackTrace;

            // unload app domain from another CLR thread
            ThreadPool.QueueUserWorkItem(_theRuntime._appDomainUnloadallback);
        }

        /*
         * Notification when app-level Config changed
         */
        internal static void OnConfigChange(Object sender, FileChangeEvent e) {
            Debug.Trace("AppDomainFactory", "Shutting down appdomain because of config change");
            ShutdownAppDomain("CONFIG change");
        }

        // Intrumentation to remember the overwhelming file change
        internal static void SetShutdownMessage(String message) {
            if (_theRuntime._shutDownMessage == null)
                _theRuntime._shutDownMessage = message;
            else
                _theRuntime._shutDownMessage += "\r\n" + message;
        }

        /*
         * Access to resource strings
         */
        private String GetResourceStringFromResourceManager(String key) {
            if (_resourceManager == null) {
                lock (this) {
                    if (_resourceManager == null) {
                        _resourceManager = new ResourceManager("System.Web", typeof(HttpRuntime).Module.Assembly);
                    }
                }
            }

            return _resourceManager.GetString(key, null);
        }

        //
        // public static APIs
        //

        /*
         * Process one request
         */
        /// <include file='doc\HttpRuntime.uex' path='docs/doc[@for="HttpRuntime.ProcessRequest"]/*' />
        /// <devdoc>
        ///    <para><SPAN>The method that drives 
        ///       all ASP.NET web processing execution.</SPAN></para>
        /// </devdoc>
        public static void ProcessRequest(HttpWorkerRequest wr) {
            InternalSecurityPermissions.AspNetHostingPermissionLevelMedium.Demand();

            if (wr == null)
                throw new ArgumentNullException("custom");

            RequestQueue rq = _theRuntime._requestQueue;

            if (rq != null)  // could be null before first request
                wr = rq.GetRequestToExecute(wr);

            if (wr != null) {
                CalculateWaitTimeAndUpdatePerfCounter(wr);
                ProcessRequestNow(wr);
            }
        }

        private static void CalculateWaitTimeAndUpdatePerfCounter(HttpWorkerRequest wr) {
            DateTime begin = wr.GetStartTime();

            TimeSpan elapsed = DateTime.UtcNow.Subtract(begin);
            long milli = elapsed.Ticks / TimeSpan.TicksPerMillisecond;

            if (milli > Int32.MaxValue)
                milli = Int32.MaxValue;

            PerfCounters.SetGlobalCounter(GlobalPerfCounter.REQUEST_WAIT_TIME, (int) milli);
        }

        internal static void ProcessRequestNow(HttpWorkerRequest wr) {
            _theRuntime.ProcessRequestInternal(wr);
        }

        internal static void RejectRequestNow(HttpWorkerRequest wr) {
            _theRuntime.RejectRequestInternal(wr);
        }

        /// <include file='doc\HttpRuntime.uex' path='docs/doc[@for="HttpRuntime.Close"]/*' />
        /// <devdoc>
        ///       <para>Removes all items from the cache and shuts down the runtime.</para>
        ///    </devdoc>
        public static void Close() {
            InternalSecurityPermissions.UnmanagedCode.Demand();
            Debug.Trace("AppDomainFactory", "HttpRuntime.Close, ShutdownInProgress=" + ShutdownInProgress);
            if (_theRuntime.InitiateShutdownOnce())
                _theRuntime.Dispose();
        }

        /// <include file='doc\HttpRuntime.uex' path='docs/doc[@for="HttpRuntime.UnloadAppDomain"]/*' />
        /// <devdoc>
        ///       <para>Unloads the current app domain.</para>
        ///    </devdoc>
        public static void UnloadAppDomain() {
            InternalSecurityPermissions.UnmanagedCode.Demand();

            _theRuntime._userForcedShutdown = true;
            ShutdownAppDomain("User code called UnloadAppDomain");
        }

        private DateTime LastShutdownAttemptTime {
            get {
                DateTime dt;
                lock (this) {
                    dt = _lastShutdownAttemptTime;
                }
                return dt;
            }
            set {
                lock (this) {
                    _lastShutdownAttemptTime = value;
                }
            }
        }

        internal static Profiler Profile {
            get {  
                return _theRuntime._profiler; 
            }
        }

        internal static NamedPermissionSet NamedPermissionSet { 
            get { return _theRuntime._namedPermissionSet; }
        }

        internal static bool IsFullTrust {
            get { return (_theRuntime._namedPermissionSet == null); }
        }

        /*
         * Check that the current trust level allows access to a path.  Throw is it doesn't,
         */
        internal static void CheckFilePermission(string path) {
            if (!HasFilePermission(path)) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Access_denied_to_path, GetSafePath(path)));
            }
        }

        internal static bool HasFilePermission(string path) {
            // If we don't have a NamedPermissionSet, we're in full trust
            if (NamedPermissionSet == null)
                return true;

            bool fAccess = false;

            // Check that the user has permission to the path
            IPermission allowedPermission = NamedPermissionSet.GetPermission(typeof(FileIOPermission));
            if (allowedPermission != null) {
                IPermission askedPermission = null;
                try {
                    askedPermission = new FileIOPermission(FileIOPermissionAccess.Read, path);
                }
                catch {
                    // This could happen if the path is not absolute
                    return false;
                }
                fAccess = askedPermission.IsSubsetOf(allowedPermission);
            }

            return fAccess;
        }

        internal static bool HasPathDiscoveryPermission(string path) {
            // If we don't have a NamedPermissionSet, we're in full trust
            if (NamedPermissionSet == null)
                return true;

            bool fAccess = false;

            // Check that the user has permission to the path
            IPermission allowedPermission = NamedPermissionSet.GetPermission(typeof(FileIOPermission));
            if (allowedPermission != null) {
                IPermission askedPermission = new FileIOPermission(FileIOPermissionAccess.PathDiscovery, path);
                fAccess = askedPermission.IsSubsetOf(allowedPermission);
            }

            return fAccess;
        }

        internal static bool HasAppPathDiscoveryPermission() {
            return HasPathDiscoveryPermission(HttpRuntime.AppDomainAppPathInternal);
        }

        internal static string GetSafePath(string path) {
            if (path == null || path.Length == 0)
                return path;

            try {
                if (HasPathDiscoveryPermission(path)) // could throw on bad filenames
                    return path;
            }
            catch {
            }

            return Path.GetFileName(path);
        }

        /*
         * Check that the current trust level allows Unmanaged access 
         */
        internal static bool HasUnmanagedPermission() {

            // If we don't have a NamedPermissionSet, we're in full trust
            if (NamedPermissionSet == null)
                return true;

            SecurityPermission securityPermission = (SecurityPermission)NamedPermissionSet.GetPermission(
                typeof(SecurityPermission));
            if (securityPermission == null)
                return false;

            return (securityPermission.Flags & SecurityPermissionFlag.UnmanagedCode) != 0;
        }

        internal static bool HasAspNetHostingPermission(AspNetHostingPermissionLevel level) {
            // If we don't have a NamedPermissionSet, we're in full trust
            if (NamedPermissionSet == null)
                return true;

            AspNetHostingPermission permission = (AspNetHostingPermission)NamedPermissionSet.GetPermission(
                typeof(AspNetHostingPermission));
            if (permission == null)
                return false;

            return (permission.Level >= level);
        }

        internal static void CheckAspNetHostingPermission(AspNetHostingPermissionLevel level, String errorMessageId) {
            if (!HasAspNetHostingPermission(level)) {
                throw new HttpException(HttpRuntime.FormatResourceString(errorMessageId));
            }
        }

        internal static FileChangesMonitor FileChangesMonitor { 
            get { return _theRuntime._fcm;} 
        }

        internal static RequestTimeoutManager RequestTimeoutManager {
            get { return _theRuntime._timeoutManager;}
        }

        internal static bool VSDebugAttach {
            get { return _theRuntime._vsDebugAttach; }
            set { _theRuntime._vsDebugAttach = value; }
        }

        /// <include file='doc\HttpRuntime.uex' path='docs/doc[@for="HttpRuntime.Cache"]/*' />
        /// <devdoc>
        ///    <para>Provides access to the cache.</para>
        /// </devdoc>
        public static Cache Cache {
            get { return _theRuntime._cache.CachePublic;} 
        }

        internal static CacheInternal CacheInternal {
            get { return _theRuntime._cache;} 
        }

        /// <include file='doc\HttpRuntime.uex' path='docs/doc[@for="HttpRuntime.AspInstallDirectory"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string AspInstallDirectory {
            get { 
                String path = AspInstallDirectoryInternal;
                InternalSecurityPermissions.PathDiscovery(path).Demand();
                return path;
            }
        }

        internal static string AspInstallDirectoryInternal {
            get { return s_installDirectory; }
        }


        /// <include file='doc\HttpRuntime.uex' path='docs/doc[@for="HttpRuntime.ClrInstallDirectory"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string ClrInstallDirectory {
            get {
                String path = ClrInstallDirectoryInternal;
                InternalSecurityPermissions.PathDiscovery(path).Demand();
                return path;
            }
        }

        internal static string ClrInstallDirectoryInternal {
            get { return HttpConfigurationSystemBase.MsCorLibDirectory; }
        }


        /// <include file='doc\HttpRuntime.uex' path='docs/doc[@for="HttpRuntime.ConfigurationDirectory"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string MachineConfigurationDirectory {
            get {
                String path = MachineConfigurationDirectoryInternal;
                InternalSecurityPermissions.PathDiscovery(path).Demand();
                return path;
            }
        }

        internal static string MachineConfigurationDirectoryInternal {
            get { return HttpConfigurationSystemBase.MachineConfigurationDirectory; }
        }

        internal static bool IsIsapiLoaded {
            get { return s_isapiLoaded; }
        }

        //
        // Access to resource strings
        //

        private static String GetResourceString(String key) {
            String s = _theRuntime.GetResourceStringFromResourceManager(key);

            if (s == null) {
                Debug.Trace("Resources", "Resource string not found for '" + key + "'.");
            }

            return s;
        }

        internal static String FormatResourceString(String key) {
            return GetResourceString(key);
        }

        internal static String FormatResourceString(String key, String arg0) {
            String fmt = GetResourceString(key);
            return(fmt != null) ? String.Format(fmt, arg0) : null;
        }

        internal static String FormatResourceString(String key, String arg0, String arg1) {
            String fmt = GetResourceString(key);
            return(fmt != null) ? String.Format(fmt, arg0, arg1) : null;
        }

        internal static String FormatResourceString(String key, String arg0, String arg1, String arg2) {
            String fmt = GetResourceString(key);
            return(fmt != null) ? String.Format(fmt, arg0, arg1, arg2) : null;
        }

        internal static String FormatResourceString(String key, String[] args) {
            String fmt = GetResourceString(key);
            return(fmt != null) ? String.Format(fmt, args) : null;
        }

        //
        //  Static app domain related properties
        //

        /// <include file='doc\HttpRuntime.uex' path='docs/doc[@for="HttpRuntime.CodegenDir"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static String CodegenDir {
            get {
                String path = CodegenDirInternal;
                InternalSecurityPermissions.PathDiscovery(path).Demand();
                return path; 
            }
        }

        internal static string CodegenDirInternal {
            get { return _theRuntime._codegenDir; }
        }


        /// <include file='doc\HttpRuntime.uex' path='docs/doc[@for="HttpRuntime.AppDomainAppId"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static String AppDomainAppId {
            get {
                InternalSecurityPermissions.AspNetHostingPermissionLevelHigh.Demand();
                return AppDomainAppIdInternal;
            }
        }

        internal static string AppDomainAppIdInternal {
            get { return _theRuntime._appDomainAppId; }
        }


        /// <include file='doc\HttpRuntime.uex' path='docs/doc[@for="HttpRuntime.AppDomainAppPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static String AppDomainAppPath {
            get {
                InternalSecurityPermissions.AppPathDiscovery.Demand();
                return AppDomainAppPathInternal;
            }
        }

        internal static string AppDomainAppPathInternal {
            get { return _theRuntime._appDomainAppPath; }
        }


        /// <include file='doc\HttpRuntime.uex' path='docs/doc[@for="HttpRuntime.AppDomainAppVirtualPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static String AppDomainAppVirtualPath {
            get {
                return _theRuntime._appDomainAppVPath;
            }
        }

        internal static bool IsPathWithinAppRoot(String path) {
            if (AppDomainIdInternal == null)
                return true;    // app domain not initialized

            string appPath = AppDomainAppVirtualPath;
            int appPathLen = appPath.Length;

            if (path.Length < appPathLen)
                return false;
            else if (String.Compare(path, 0, appPath, 0, appPathLen, true, CultureInfo.InvariantCulture) != 0)
                return false;
            else if (appPathLen > 1 && path.Length > appPathLen && path[appPathLen] != '/')
                return false;
            else
                return true;
        }

        /// <include file='doc\HttpRuntime.uex' path='docs/doc[@for="HttpRuntime.AppDomainId"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static String AppDomainId {
            get { 
                InternalSecurityPermissions.AspNetHostingPermissionLevelHigh.Demand();
                return AppDomainIdInternal;
            }
        }

        internal static string AppDomainIdInternal {
            get { return _theRuntime._appDomainId; }
        }


        /// <include file='doc\HttpRuntime.uex' path='docs/doc[@for="HttpRuntime.BinDirectory"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static String BinDirectory {
            get {
                String path = BinDirectoryInternal;
                InternalSecurityPermissions.PathDiscovery(path).Demand();
                return path; 
            }
        }

        internal static string BinDirectoryInternal {
            get { return _theRuntime._appDomainAppPath + "bin\\"; }
        }


        /// <include file='doc\HttpRuntime.uex' path='docs/doc[@for="HttpRuntime.IsOnUNCShare"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static bool IsOnUNCShare {
            get { 
                InternalSecurityPermissions.AspNetHostingPermissionLevelLow.Demand();
                return IsOnUNCShareInternal;
            }
        }

        internal static bool IsOnUNCShareInternal {
            get { return _theRuntime._isOnUNCShare; }
        }


        //
        //  Static helper to retrieve app domain values
        //

        private static String GetAppDomainString(String key) {
            Object x = Thread.GetDomain().GetData(key);

            if (x != null && x is String)
                return(String)x;
            else
                return null;
        }

        private static void AddAppDomainTraceMessage(String message) {
            const String appDomainTraceKey = "ASP.NET Domain Trace";
            AppDomain d = Thread.GetDomain();
            String m = d.GetData(appDomainTraceKey) as String;
            d.SetData(appDomainTraceKey, (m != null) ? m + " ... " + message : message);
        }


        //
        //  Flags
        //

        internal static bool DebuggingEnabled {
            get { return _theRuntime._debuggingEnabled;}
        }

        internal static bool ConfigInited {
            get { return _theRuntime._configInited; }
        }

        internal static bool ShutdownInProgress {
            get { return _theRuntime._shutdownInProgress; }
        }

        internal static void NotifyThatSomeBatchCompilationStarted() {
            _theRuntime._someBatchCompilationStarted = true;
        }

        private void SetTrustLevel() {
            CodeAccessSecurityValues tConfig  = (CodeAccessSecurityValues) HttpContext.GetAppConfig("system.web/trust");
            SecurityPolicyConfig     config   = (SecurityPolicyConfig)     HttpContext.GetAppConfig("system.web/securityPolicy");
            
            if (tConfig == null || tConfig.level == null)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Config_section_not_present, "trust"));
            if (config == null)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Config_section_not_present, "securityPolicy"));

            if (tConfig.level == "Full")
                return;

            String file = (String)config.PolicyFiles[tConfig.level];

            if (file == null || !FileUtil.FileExists(file)) {
                if (CustomErrors.GetSettings(HttpContext.Current).CustomErrorsEnabled(HttpContext.Current.Request))
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Unable_to_get_policy_file_2));
                else
                    throw new ConfigurationException(HttpRuntime.FormatResourceString(SR.Unable_to_get_policy_file, tConfig.level),
                        tConfig.filename, tConfig.lineNumber);
            }
            
            PolicyLevel policyLevel = CreatePolicyLevel(file, AppDomainAppPathInternal, CodegenDirInternal, tConfig.url);
            Debug.Trace("internal", "Calling SetAppDomainPolicy: " + policyLevel.ToString());
            AppDomain.CurrentDomain.SetAppDomainPolicy(policyLevel);
            _namedPermissionSet = policyLevel.GetNamedPermissionSet("ASP.Net");

            _fcm.StartMonitoringFile(file, new FileChangeEventHandler(this.OnSecurityPolicyFileChange));            
        }

        private static PolicyLevel CreatePolicyLevel( String configFile, String appDir, String binDir, String strOriginUrl) {
            // Read in the config file to a string.
            FileStream    file         = new FileStream( configFile, FileMode.Open, FileAccess.Read );
            StreamReader  reader       = new StreamReader( file, Encoding.UTF8 );
            String        strFileData  = reader.ReadToEnd();

            reader.Close();
            if (appDir.Length > 3 && appDir.EndsWith("\\"))
                appDir = appDir.Substring(0, appDir.Length - 1);
            if (binDir.Length > 3 && binDir.EndsWith("\\"))
                binDir = binDir.Substring(0, binDir.Length - 1);

            strFileData = strFileData.Replace("$AppDir$", appDir);
            strFileData = strFileData.Replace("$AppDirUrl$", MakeFileUrl(appDir));
            strFileData = strFileData.Replace("$CodeGen$", MakeFileUrl(binDir));
            if (strOriginUrl != null)
                strFileData = strFileData.Replace("$OriginHost$", strOriginUrl);
            strFileData = strFileData.Replace("$Gac$", MakeFileUrl(GetGacLocation()));
            return SecurityManager.LoadPolicyLevelFromString( strFileData, PolicyLevelType.AppDomain );
        }

        /*
         * Notification when something in the code-access security policy file changed 
         */
        private void OnSecurityPolicyFileChange(Object sender, FileChangeEvent e) {
            // shutdown the app domain
            Debug.Trace("AppDomainFactory", "Shutting down appdomain because code-access security policy file changed");
            ShutdownAppDomain("Change in code-access security policy file");
        }

        private static String MakeFileUrl(String path) {
            Uri uri = new Uri(path);
            return uri.ToString();
        }

        private static String GetGacLocation() {

            StringBuilder buf   = new StringBuilder(262);
            int           iSize = 260;

            if (UnsafeNativeMethods.GetCachePath(2, buf, ref iSize) >= 0)
            {
                return buf.ToString();
            }
            Microsoft.Win32.RegistryKey rLocal = Microsoft.Win32.Registry.LocalMachine.OpenSubKey("Software\\Microsoft\\Fusion");
            if (rLocal != null) {
                Object oTemp = rLocal.GetValue("CacheLocation");
                if (oTemp != null && oTemp is string)
                    return (String) oTemp;
            }
            String sWinDir = System.Environment.GetEnvironmentVariable("windir");
            if (sWinDir == null || sWinDir.Length < 1)
                return "Directory not found";
            if (!sWinDir.EndsWith("\\"))
                sWinDir += "\\";
            return sWinDir + "assembly";
        }
            

        /*
         * Remove from metabase all read/write/browse permission of the "bin" directory
         *
         */
        private void SetBinAccess(HttpContext context) {
            byte[]  bufin;
            byte[]  bufout = new byte[1];   // Just to keep EcbCallISAPI happy
            String  path;
            int     ret;

            HttpWorkerRequest wr = context.WorkerRequest;

            Debug.Assert(AppDomainAppIdInternal != null);

            // Don't do it if we are not running on IIS
            if (wr == null || !(wr is System.Web.Hosting.ISAPIWorkerRequest)) {
                return;
            }

            // No need to set access right if the bin directory doesn't exist
            if (!FileUtil.DirectoryExists(BinDirectoryInternal)) {
                return;
            }

            // SetBinAccessIIS expects a null terminating wide string.
            path = AppDomainAppIdInternal + "\0";

            bufin = System.Text.Encoding.Unicode.GetBytes(path);
            ret = context.CallISAPI(UnsafeNativeMethods.CallISAPIFunc.SetBinAccess, bufin, bufout);

            if (ret != 1) {
                // Cannot pass back any HR from inetinfo.exe because CSyncPipeManager::GetDataFromIIS
                // does not support passing back any value when there is an error.
                Debug.Trace("SetBinAccess", "Cannot set bin access for '" + AppDomainAppIdInternal + "'.");
            }
        }

        //
        // Helper to create instances (public vs. internal/private ctors, see 89781)
        //

        internal static Object CreateNonPublicInstance(Type type) {
            return CreateNonPublicInstance(type, null);
        }

        internal static Object CreateNonPublicInstance(Type type, Object[] args) {
            return Activator.CreateInstance(
                type,
                BindingFlags.Instance|BindingFlags.NonPublic|BindingFlags.Public|BindingFlags.CreateInstance,
                null,
                args,
                null);
        }

        internal static Object CreatePublicInstance(Type type) {
            return Activator.CreateInstance(type);
        }

        internal static Object CreatePublicInstance(Type type, Object[] args) {
            return Activator.CreateInstance(type, args);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\multipartcontentparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="MultipartContentParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Multipart content parser.
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web {
    using System.Text;

    using System.Collections;
    using System.Globalization;

    /*
     * Element of the multipart content
     */
    internal class MultipartContentElement {
        private String _name;
        private String _filename;
        private String _contentType;
        private byte[] _data;
        private int _offset;
        private int _length;

        internal MultipartContentElement(String name, String filename, String contentType, byte[] data, int offset, int length) {
            _name = name;
            _filename = filename;
            _contentType = contentType;
            _data = data;
            _offset = offset;
            _length = length;
        }

        internal virtual bool IsFile {
            get { return(_filename != null);} 
        }

        internal virtual bool IsFormItem {
            get { return(_filename == null);} 
        }

        internal virtual String Name { 
            get { return _name;} 
        }

        internal virtual HttpPostedFile GetAsPostedFile() {
            return new HttpPostedFile(
                                     _filename, 
                                     _contentType, 
                                     new HttpInputStream(_data, _offset, _length));
        }

        internal virtual String GetAsString(Encoding encoding) {
            if (_length > 0)
                return encoding.GetString(_data, _offset, _length);
            else
                return "";
        }
    }

    /*
     * Multipart content parser. Split content into elements.
     */
    internal class HttpMultipartContentTemplateParser {
        private byte[] _data;
        private int _length;

        private int _pos;
        private ArrayList _elements = new ArrayList();

        // currently parsed line
        private int _lineStart = -1;
        private int _lineLength = -1;

        // last boundary has extra --
        internal bool _lastBoundaryFound;

        // part separator
        private byte[] _boundary;

        // current header values
        private String _partName;
        private String _partFilename;
        private String _partContentType;

        // current part's content data
        private int _partDataStart = -1;
        private int _partDataLength = -1;

        // encoding
        private Encoding _encoding;


        internal HttpMultipartContentTemplateParser(byte[] data, int length, byte[] boundary, Encoding encoding) {
            _data = data;
            _length = length;
            _boundary = boundary;
            _encoding = encoding;
        }

        private bool AtEndOfData() {
            return(_pos >= _length || _lastBoundaryFound);
        }

        private bool GetNextLine() {
            int i = _pos;

            _lineStart = -1;

            while (i < _length) {
                if (_data[i] == 10) { // '\n'
                    _lineStart = _pos;
                    _lineLength = i - _pos;
                    _pos = i+1;

                    // ignore \r
                    if (_lineLength > 0 && _data[i-1] == 13)
                        _lineLength--;

                    // line found
                    break;
                }

                if (++i == _length) {
                    // last line doesn't end with \n
                    _lineStart = _pos;
                    _lineLength = i - _pos;
                    _pos = _length;
                }
            }

            return(_lineStart >= 0);
        }

        private String ExractValueFromContentDispositionHeader(String l, int pos, String name) {
            String pattern = name + "=\"";
            int i1 = CultureInfo.InvariantCulture.CompareInfo.IndexOf(l, pattern, pos, CompareOptions.IgnoreCase);

            if (i1 < 0)
                return null;
            i1 += pattern.Length;

            int i2 = l.IndexOf('"', i1);
            if (i2 < 0)
                return null;
            if (i2 == i1)
                return "";

            return l.Substring(i1, i2-i1);
        }

        private void ParsePartHeaders() {
            _partName = null;
            _partFilename = null;
            _partContentType = null;

            while (GetNextLine()) {
                if (_lineLength == 0)
                    break;  // empty line signals end of headers

                // get line as String
                String line = _encoding.GetString(_data, _lineStart, _lineLength);

                // parse into header and value
                int ic = line.IndexOf(':');
                if (ic < 0)
                    continue;   // not a header

                // remeber header
                String header = line.Substring(0, ic);

                if (String.Compare(header, "Content-Disposition", true, CultureInfo.InvariantCulture) == 0) {
                    // parse name and filename
                    _partName     = ExractValueFromContentDispositionHeader(line, ic+1, "name");
                    _partFilename = ExractValueFromContentDispositionHeader(line, ic+1, "filename");
                }
                else if (String.Compare(header, "Content-Type", true, CultureInfo.InvariantCulture) == 0) {
                    _partContentType = line.Substring(ic+1).Trim();
                }
            }
        }

        private bool AtBoundaryLine() {
            // check for either regular or last boundary line length

            int len = _boundary.Length;

            if (_lineLength != len && _lineLength != len+2)
                return false;

            // match with boundary

            for (int i = 0; i < len; i++) {
                if (_data[_lineStart+i] != _boundary[i])
                    return false;
            }

            // regular boundary line?

            if (_lineLength == len)
                return true;

            // last boundary line? (has to end with "--")

            if (_data[_lineStart+len] != 45 || _data[_lineStart+len+1] != 45)
                return false;

            _lastBoundaryFound = true; // remember that it is last
            return true;
        }

        private void ParsePartData() {
            _partDataStart = _pos;
            _partDataLength = -1;

            while (GetNextLine()) {
                if (AtBoundaryLine()) {
                    // calc length: adjust to exclude [\r]\n before the separator
                    int iEnd = _lineStart - 1;
                    if (_data[iEnd] == 10)   // \n
                        iEnd--;
                    if (_data[iEnd] == 13)   // \r
                        iEnd--;

                    _partDataLength = iEnd - _partDataStart + 1;
                    break;
                }
            }
        }

        private void ParseIntoElementList() {
            //
            // Skip until first boundary
            //

            while (GetNextLine()) {
                if (AtBoundaryLine())
                    break;
            }

            if (AtEndOfData())
                return;

            //
            // Parse the parts
            //

            do {
                // Parse current part's headers

                ParsePartHeaders();

                if (AtEndOfData())
                    break;          // cannot stop after headers

                // Parse current part's data

                ParsePartData();

                if (_partDataLength == -1)
                    break;          // ending boundary not found

                // Remember the current part (if named)

                if (_partName != null) {
                    _elements.Add(new MultipartContentElement(
                                                             _partName, 
                                                             _partFilename,
                                                             _partContentType, 
                                                             _data,
                                                             _partDataStart, 
                                                             _partDataLength));
                }
            }
            while (!AtEndOfData());
        }

        /*
         * Static method to do the parsing
         */
        internal static MultipartContentElement[] Parse(byte[] data, int length, byte[] boundary, Encoding encoding) {
            HttpMultipartContentTemplateParser parser = new HttpMultipartContentTemplateParser(data, length, boundary, encoding);
            parser.ParseIntoElementList();

            int n = parser._elements.Count;
            MultipartContentElement[] elements = new MultipartContentElement[n];

            for (int i = 0; i < n; i++)
                elements[i] = (MultipartContentElement)parser._elements[i];

            return elements;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\perfcounters.cs ===
//------------------------------------------------------------------------------
// <copyright file="PerfCounters.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * PerfCounters class
 */
namespace System.Web {

    using System.Web.Util;
    using System.Threading;

    internal sealed class PerfCounters {
        private static IntPtr _instance;
        private static IntPtr _global;
        private static int _numCalls = -1;
        private static bool _goingAway = false;

        private PerfCounters () {}

        internal /*public*/ static void Open(String AppName) {
            try {
                // Don't activate perf counters is ISAPI isn't loaded
                if (! HttpRuntime.IsIsapiLoaded) 
                    return;

                // If perf counters has been initialized once already, return
                if ((! _goingAway) && (_numCalls >= 0))
                    return;

                _global = UnsafeNativeMethods.PerfOpenGlobalCounters();

                if (AppName != null) {
                    _instance = UnsafeNativeMethods.PerfOpenAppCounters(AppName);
                }

                // Set this guy to zero so that we allow access to the interlocked methods
                _numCalls = 0;
            }
            catch (Exception e) {
                Debug.Trace("Perfcounters", "Exception: " + e.StackTrace);
            }
        }

        internal /*public*/ static void Close() {
            _goingAway = true;
            GoingOut();
        }

        private static void Cleanup()
        {
            try {
                if (_global != (IntPtr)0) {
                    _global = (IntPtr)0;
                }

                if (_instance != (IntPtr)0) {
                    UnsafeNativeMethods.PerfCloseAppCounters(_instance);
                    _instance = (IntPtr)0;
                }
            }
            catch (Exception e) {
                Debug.Trace("Perfcounters", "Exception: " + e.StackTrace);
            }
        }

        private static bool GoingIn()
        {
            int n;
            while (true) {
                n = _numCalls;
                if (n < 0 || _goingAway) 
                    return false;

                if (Interlocked.CompareExchange(ref _numCalls, n + 1, n) == n)
                    break;
            }

            return true;
        }

        private static void GoingOut()
        {
            if (Interlocked.Decrement(ref _numCalls) < 0)
                Cleanup();
        }

        // Make sure the Isapi is loaded before attempting to call into it (ASURT 98531)

        internal /*public*/ static void IncrementCounter(AppPerfCounter counter) {
            if (GoingIn()) {
                try {
                    UnsafeNativeMethods.PerfIncrementCounter(_instance, (int) counter);
                }
                finally {
                    GoingOut();
                }
            }
        }

        internal /*public*/ static void DecrementCounter(AppPerfCounter counter) {
            if (GoingIn()) {
                try {
                    UnsafeNativeMethods.PerfDecrementCounter(_instance, (int) counter);
                }
                finally {
                    GoingOut();
                }
            }
        }

        internal /*public*/ static void IncrementCounterEx(AppPerfCounter counter, int delta) {
            if (GoingIn()) {
                try {
                    UnsafeNativeMethods.PerfIncrementCounterEx(_instance, (int) counter, delta);
                }
                finally {
                    GoingOut();
                }
            }
        }

        internal /*public*/ static void SetCounter(AppPerfCounter counter, int value) {
            if (GoingIn()) {
                try {
                    UnsafeNativeMethods.PerfSetCounter(_instance, (int) counter, value);
                }
                finally {
                    GoingOut();
                }
            }
        }

        // It's important that this be debug only. We don't want production
        // code to access shared memory that another process could corrupt.
#if DBG
        internal /*public*/ static int GetCounter(AppPerfCounter counter) {
            return UnsafeNativeMethods.PerfGetCounter(_instance, (int) counter);
        }
#endif

        internal /*public*/ static void IncrementGlobalCounter(GlobalPerfCounter counter) {
            if (GoingIn()) {
                try {
                    UnsafeNativeMethods.PerfIncrementCounter(_global, (int) counter);
                }
                finally {
                    GoingOut();
                }
            }
        }

        internal /*public*/ static void DecrementGlobalCounter(GlobalPerfCounter counter) {
            if (GoingIn()) {
                try {
                    UnsafeNativeMethods.PerfDecrementCounter(_global, (int) counter);
                }
                finally {
                    GoingOut();
                }
            }
        }

        internal /*public*/ static void IncrementGlobalCounterEx(GlobalPerfCounter counter, int delta) {
            if (GoingIn()) {
                try {
                    UnsafeNativeMethods.PerfIncrementCounterEx(_global, (int) counter, delta);
                }
                finally {
                    GoingOut();
                }
            }
        }

        internal /*public*/ static void SetGlobalCounter(GlobalPerfCounter counter, int value) {
            if (GoingIn()) {
                try {
                    UnsafeNativeMethods.PerfSetCounter(_global, (int) counter, value);
                }
                finally {
                    GoingOut();
                }
            }
        }
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\outputcachemodule.cs ===
//------------------------------------------------------------------------------
// <copyright file="OutputCacheModule.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Output cache module
 */
namespace System.Web.Caching {
    using System.Text;
    using System.Threading;
    using System.Collections;
    using System.Globalization;
    using System.Security.Cryptography;
    using System.Web;
    using System.Web.Caching;
    using System.Web.Util;
    using System.Collections.Specialized;
    using System.Web.Configuration;

    /*
     * Holds header and param names that this cached item varies by.
     */
    internal class CachedVary {
        internal readonly string[]  _headers;
        internal readonly string[]  _params;
        internal readonly string    _varyByCustom;
        internal readonly bool      _varyByAllParams;

        internal CachedVary(string[] headers, string[] parameters, bool varyByAllParams, string varyByCustom) {
            _headers = headers;
            _params = parameters;
            _varyByAllParams = varyByAllParams;
            _varyByCustom = varyByCustom;
        }

        bool StringEquals(string a, string b) {
            if ((a == null) != (b == null)) {
                return false;
            }

            return (a == null || a == b);
        }

        bool StringArrayEquals(string[] a, string [] b) {
            if ((a == null) != (b == null)) {
                return false;
            }

            if (a == null) {
                return true;
            }

            int n = a.Length;
            if (n != b.Length) {
                return false;
            }

            for (int i = 0; i < n; i++) {
                if (a[i] != b[i]) {
                    return false;
                }
            }

            return true;
        }

        public override bool Equals (Object obj) {
          if (!(obj is CachedVary)) {
            return false;
          }

          CachedVary cv = (CachedVary) obj;

          return    _varyByAllParams == cv._varyByAllParams         &&
                    StringEquals(_varyByCustom, cv._varyByCustom)    &&
                    StringArrayEquals(_headers, cv._headers)        &&
                    StringArrayEquals(_params, cv._params);          
                    

        }

        public override int GetHashCode () {
            return base.GetHashCode();
        }
    }

    /*
     * Holds the cached response.
     */
    internal class CachedRawResponse {
        /*
         * Fields to store an actual response.
         */
        internal readonly HttpRawResponse           _rawResponse;
        internal readonly HttpCachePolicySettings   _settings;
        internal readonly CachedVary                _cachedVary;

        internal CachedRawResponse(
                  HttpRawResponse         rawResponse,
                  HttpCachePolicySettings settings,
                  CachedVary              cachedVary) {

            _rawResponse = rawResponse;
            _settings = settings;
            _cachedVary = cachedVary;
        }
    }

    class OutputCacheItemRemoved {

        internal OutputCacheItemRemoved() {}

        internal void CacheItemRemovedCallback(string key, object value, CacheItemRemovedReason reason) {
            Debug.Trace("OutputCacheItemRemoved", "reason=" + reason + "; key=" + key);
            PerfCounters.DecrementCounter(AppPerfCounter.OUTPUT_CACHE_ENTRIES);
            PerfCounters.IncrementCounter(AppPerfCounter.OUTPUT_CACHE_TURNOVER_RATE);
        }
    }

    enum CacheRequestMethod {
        Invalid = 0, Head, Get, Post
    }

    // 
    //  OutputCacheModule real implementation for premium SKUs
    //

    sealed class  OutputCacheModule : IHttpModule {
        const int                   MAX_POST_KEY_LENGTH = 15000;
        const string                NULL_VARYBY_VALUE = "+null+";
        const string                ERROR_VARYBY_VALUE = "+error+";
        internal const string       TAG_OUTPUTCACHE = "OutputCache";

        static readonly char[]          s_fieldSeparators;
        static readonly byte[]          s_hashModifier;
        static CacheItemRemovedCallback s_cacheItemRemovedCallback;

        string              _key;
        bool                _recordedCacheMiss;
        CacheRequestMethod  _method;

        static OutputCacheModule() {
            s_fieldSeparators = new char[] {',', ' '};
            s_cacheItemRemovedCallback = new CacheItemRemovedCallback((new OutputCacheItemRemoved()).CacheItemRemovedCallback);

            s_hashModifier = new byte [16];
            RandomNumberGenerator randgen = new RNGCryptoServiceProvider();
            randgen.GetBytes(s_hashModifier);
        }

        internal OutputCacheModule() {
        }

        internal static string CreateOutputCachedItemKey(
                string              path, 
                CacheRequestMethod  method, 
                HttpContext         context,
                CachedVary          cachedVary) {

            StringBuilder       sb;
            int                 i, j, n;
            string              name, value;
            string[]            a;
            byte[]              buf, hash;
            HttpRequest         request;
            NameValueCollection col;
            int                 contentLength;

            if (method == CacheRequestMethod.Post) {
                sb = new StringBuilder("System.Web.Http.HttpRawResponse\nM=3\n");
            }
            else {
                sb = new StringBuilder("System.Web.Http.HttpRawResponse\nM=2\n");
            }

            sb.Append(CultureInfo.InvariantCulture.TextInfo.ToLower(path));

            /* key for cached vary item has additional information */
            if (cachedVary != null) {
                request = context.Request;

                /* params part */
                for (j = 0; j <= 2; j++) {
                    switch (j) {
                        case 0:
                            sb.Append("\nVH");
                            a = cachedVary._headers;
                            col = request.ServerVariables;
                            break;

                        case 1:
                            sb.Append("\nVPQ");
                            a = cachedVary._params;
                            col = request.QueryString;
                            break;

                        case 2:
                        default:
                            sb.Append("\nVPF");
                            a = cachedVary._params;
                            col = request.Form;
                            if (method != CacheRequestMethod.Post) {
                                col = null;
                            }

                            break;
                    }

                    if (col == null) {
                        continue;
                    }

                    /* handle all params case (VaryByParams[*] = true) */
                    if (a == null && cachedVary._varyByAllParams && j != 0) {
                        a = col.AllKeys;
                        for (i = a.Length - 1; i >= 0; i--) {
                            if (a[i] != null)
                                a[i] = CultureInfo.InvariantCulture.TextInfo.ToLower(a[i]);
                        }

                        Array.Sort(a, InvariantComparer.Default);
                    }

                    if (a != null) {
                        for (i = 0, n = a.Length; i < n; i++) {
                            name = a[i];
                            value = col[name];
                            if (value == null) {
                                value = NULL_VARYBY_VALUE;
                            }

                            sb.Append("\tPN:");
                            sb.Append(name);
                            sb.Append("\tPV:");
                            sb.Append(value);
                        }
                    }
                }

                /* custom string part */
                sb.Append("\nVC");
                if (cachedVary._varyByCustom != null) {
                    sb.Append("\tCN:");
                    sb.Append(cachedVary._varyByCustom);
                    sb.Append("\tCV:");

                    try {
                        value = context.ApplicationInstance.GetVaryByCustomString(
                                context, cachedVary._varyByCustom);
                        if (value == null) {
                            value = NULL_VARYBY_VALUE;
                        }
                    }
                    catch (Exception e) {
                        value = ERROR_VARYBY_VALUE;
                        HttpApplicationFactory.RaiseError(e);
                    }

                    sb.Append(value);
                }

                /* 
                 * if VaryByParms=*, and method is not a form, then 
                 * use a cryptographically strong hash of the data as
                 * part of the key.
                 */
                sb.Append("\nVPD");
                if (    method == CacheRequestMethod.Post && 
                        cachedVary._varyByAllParams && 
                        request.Form.Count == 0) {

                    contentLength = request.ContentLength;
                    if (contentLength > MAX_POST_KEY_LENGTH || contentLength < 0) {
                        return null;
                    }

                    if (contentLength > 0) {
                        buf = ((HttpInputStream)request.InputStream).Data;
                        if (buf == null) {
                            return null;
                        }

                        hash = MachineKey.HashData(buf, s_hashModifier, 0, buf.Length);
                        value = Convert.ToBase64String(hash);
                        sb.Append(value);
                    }
                }

                sb.Append("\nEOV");
            }

            return sb.ToString();
        }

        /*
         * Return a key to lookup a cached response. The key contains 
         * the path and optionally, vary parameters, vary headers, custom strings,
         * and form posted data.
         */
        string CreateOutputCachedItemKey(HttpContext context, CachedVary cachedVary) {
            return CreateOutputCachedItemKey(context.Request.Path, _method, context, cachedVary);
        }

        /*
         * Record a cache miss to the perf counters.
         */
        void RecordCacheMiss() {
            if (!_recordedCacheMiss) {
                PerfCounters.IncrementCounter(AppPerfCounter.OUTPUT_CACHE_RATIO_BASE);
                PerfCounters.IncrementCounter(AppPerfCounter.OUTPUT_CACHE_MISSES);
                _recordedCacheMiss = true;
            }
        }

        /// <include file='doc\OutputCacheModule.uex' path='docs/doc[@for="OutputCacheModule.Init"]/*' />
        /// <devdoc>
        ///    <para>Initializes the output cache for an application.</para>
        /// </devdoc>
        void IHttpModule.Init(HttpApplication app) {
            app.ResolveRequestCache += new EventHandler(this.OnEnter);
            app.UpdateRequestCache += new EventHandler(this.OnLeave);
        }

        /// <include file='doc\OutputCacheModule.uex' path='docs/doc[@for="OutputCacheModule.Dispose"]/*' />
        /// <devdoc>
        ///    <para>Disposes of items from the output cache.</para>
        /// </devdoc>
        void IHttpModule.Dispose() {
        }

        /*
         * Try to find this request in the cache. If so, return it. Otherwise,
         * store the cache key for use on Leave.
         */
        /// <include file='doc\OutputCacheModule.uex' path='docs/doc[@for="OutputCacheModule.OnEnter"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='Enter'/> 
        /// event, which searches the output cache for an item to satisfy the HTTP request. </para>
        /// </devdoc>
        internal /*public*/ void OnEnter(Object source, EventArgs eventArgs) {
            HttpApplication             app;
            HttpContext                 context;
            string                      key;
            HttpRequest                 request; 
            HttpResponse                response; 
            Object                      item;
            CachedRawResponse           cachedRawResponse;            
            HttpCachePolicySettings     settings;
            int                         i, n;                      
            bool                        sendBody;                  
            HttpValidationStatus        validationStatus, validationStatusFinal;                     
            ValidationCallbackInfo      callbackInfo;
            string                      ifModifiedSinceHeader;
            DateTime                    utcIfModifiedSince;
            string                      etag;
            string[]                    etags;
            int                         send304;
            string                      cacheControl;
            string[]                    cacheDirectives = null;
            string                      pragma;
            string[]                    pragmaDirectives = null;
            string                      directive;
            int                         maxage;
            int                         minfresh;
            int                         age;
            int                         fresh;
            bool                        hasValidationPolicy;    
            CachedVary                  cachedVary;
            CacheInternal               cacheInternal;

            Debug.Trace("OutputCacheModuleEnter", "Beginning OutputCacheModule::Enter");

            app = (HttpApplication)source;
            context = app.Context;
            request = context.Request;
            response = context.Response;
            _key = null;
            _recordedCacheMiss = false;
            _method = CacheRequestMethod.Invalid;

            /*
             * Check if the request can be resolved for this method.
             */
            switch (request.HttpMethod) {
                case "HEAD":
                    _method = CacheRequestMethod.Head;
                    break;

                case "GET":
                    _method = CacheRequestMethod.Get;
                    break;

                case "POST":
                    _method = CacheRequestMethod.Post;
                    break;

                default:
                    Debug.Trace("OutputCacheModuleEnter", "Output cache miss, Http method not GET, POST, or HEAD" +
                                "\nReturning from OutputCacheModule::Enter");
    
                    return;
            }

            /*
             * Create a lookup key. Remember the key for use inside Leave()
             */
            _key = key = CreateOutputCachedItemKey(context, null);
            Debug.Assert(_key != null, "_key != null");

            /*
             *  Lookup the cached item.
             */
            cacheInternal = HttpRuntime.CacheInternal;
            item = cacheInternal.Get(key);
            if (item == null) {
                Debug.Trace("OutputCacheModuleEnter", "Output cache miss, item not found.\n\tkey=" + key +
                            "\nReturning from OutputCacheModule::Enter");

                return;
            }

            cachedVary = item as CachedVary;
            if (cachedVary != null) {
                /*
                 * This cached output has a Vary policy. Create a new key based 
                 * on the vary headers in cachedRawResponse and try again.
                 */
                Debug.Trace("OutputCacheModuleEnter", "Output cache found CachedVary, \n\tkey=" + key);
                key = CreateOutputCachedItemKey(context, cachedVary);
                if (key == null) {
                    Debug.Trace("OutputCacheModuleEnter", "Output cache miss, key could not be created for vary-by item." + 
                                    "\nReturning from OutputCacheModule::Enter");

                    return;
                }

                item = cacheInternal.Get(key);
                if (item == null) {
                    Debug.Trace("OutputCacheModuleEnter", "Output cache miss, item not found.\n\tkey=" + key +
                                "\nReturning from OutputCacheModule::Enter");
    
                    return;
                }
            }

            Debug.Assert(item.GetType() == typeof(CachedRawResponse), "item.GetType() == typeof(CachedRawResponse)");
            cachedRawResponse = (CachedRawResponse) item;
            settings = cachedRawResponse._settings;
            if (cachedVary == null && !settings.IgnoreParams) {
                /*
                 * This cached output has no vary policy, so make sure it doesn't have a query string or form post.
                 */
                if (_method == CacheRequestMethod.Post) {
                    Debug.Trace("OutputCacheModuleEnter", "Output cache item found but method is POST and no VaryByParam specified." +
                                "\n\tkey=" + key +
                                "\nReturning from OutputCacheModule::Enter");
                    RecordCacheMiss();
                    return;
                }
                
                string queryStringText = request.QueryStringText;
                if (queryStringText != null && queryStringText.Length > 0) {
                    Debug.Trace("OutputCacheModuleEnter", "Output cache item found but contains a querystring and no VaryByParam specified." +
                                "\n\tkey=" + key +
                                "\nReturning from OutputCacheModule::Enter");
                    RecordCacheMiss();
                    return;
                }
            }

            hasValidationPolicy = settings.HasValidationPolicy();

            /*
             * Determine whether the client can accept a cached copy, and
             * get values of other cache control directives.
             * 
             * We do this after lookup so we don't have to crack the headers
             * if the item is not found. Cracking the headers is expensive.
             */
            if (!hasValidationPolicy) {
                cacheControl = request.Headers["Cache-Control"];
                if (cacheControl != null) {
                    cacheDirectives = cacheControl.Split(s_fieldSeparators);
                    for (i = 0; i < cacheDirectives.Length; i++) {
                        directive = cacheDirectives[i];
                        if (directive == "no-cache") {
                            Debug.Trace("OutputCacheModuleEnter", 
                                        "Skipping lookup because of Cache-Control: no-cache directive." + 
                                        "\nReturning from OutputCacheModule::Enter");

                            RecordCacheMiss();
                            return;
                        }

                        if (directive.StartsWith("max-age=")) {
                            try {
                                maxage = Convert.ToInt32(directive.Substring(8));
                            }
                            catch {
                                maxage = -1;
                            }

                            if (maxage >= 0) {
                                age = (int) ((context.UtcTimestamp.Ticks - settings.UtcTimestampCreated.Ticks) / TimeSpan.TicksPerSecond);
                                if (age >= maxage) {
                                    Debug.Trace("OutputCacheModuleEnter", 
                                                "Not returning found item due to Cache-Control: max-age directive." + 
                                                "\nReturning from OutputCacheModule::Enter");

                                    RecordCacheMiss();
                                    return;
                                }
                            }
                        }
                        else if (directive.StartsWith("min-fresh=")) {
                            try {
                                minfresh = Convert.ToInt32(directive.Substring(10));
                            }
                            catch {
                                minfresh = -1;
                            }

                            if (minfresh >= 0 && settings.IsExpiresSet && !settings.SlidingExpiration) {
                                fresh = (int) ((settings.UtcExpires.Ticks - context.UtcTimestamp.Ticks) / TimeSpan.TicksPerSecond);
                                if (fresh < minfresh) {
                                    Debug.Trace("OutputCacheModuleEnter", 
                                                "Not returning found item due to Cache-Control: min-fresh directive." + 
                                                "\nReturning from OutputCacheModule::Enter");

                                    RecordCacheMiss();
                                    return;
                                }
                            }
                        }
                    }
                }

                pragma = request.Headers["Pragma"];
                if (pragma != null) {
                    pragmaDirectives = pragma.Split(s_fieldSeparators);
                    for (i = 0; i < pragmaDirectives.Length; i++) {
                        if (pragmaDirectives[i] == "no-cache") {
                            Debug.Trace("OutputCacheModuleEnter", 
                                        "Skipping lookup because of Pragma: no-cache directive." + 
                                        "\nReturning from OutputCacheModule::Enter");

                            RecordCacheMiss();
                            return;
                        }
                    }
                }
            }
            else if (settings.ValidationCallbackInfo != null) {
                /*
                 * Check if the item is still valid.
                 */
                validationStatus = HttpValidationStatus.Valid;
                validationStatusFinal = validationStatus;
                for (i = 0, n = settings.ValidationCallbackInfo.Length; i < n; i++) {
                    callbackInfo = settings.ValidationCallbackInfo[i];
                    try {
                        callbackInfo.handler(context, callbackInfo.data, ref validationStatus);
                    }
                    catch (Exception e) {
                        validationStatus = HttpValidationStatus.Invalid;
                        HttpApplicationFactory.RaiseError(e);
                    }

                    switch (validationStatus) {
                        case HttpValidationStatus.Invalid:
                            Debug.Trace("OutputCacheModuleEnter", "Output cache item found but callback invalidated it." +
                                        "\n\tkey=" + key +
                                        "\nReturning from OutputCacheModule::Enter");

                            cacheInternal.Remove(key);                                
                            RecordCacheMiss();
                            return;

                        case HttpValidationStatus.IgnoreThisRequest:
                            validationStatusFinal = HttpValidationStatus.IgnoreThisRequest;
                            break;

                        case HttpValidationStatus.Valid:
                            break;

                        default:
                            Debug.Trace("OutputCacheModuleEnter", "Invalid validation status, ignoring it, status=" + validationStatus + 
                                        "\n\tkey=" + key);

                            validationStatus = validationStatusFinal;
			    break;
                    }

                }

                if (validationStatusFinal == HttpValidationStatus.IgnoreThisRequest) {
                    Debug.Trace("OutputCacheModuleEnter", "Output cache item found but callback status is IgnoreThisRequest." +
                                "\n\tkey=" + key +
                                "\nReturning from OutputCacheModule::Enter");


                    RecordCacheMiss();
                    return;
                }

                Debug.Assert(validationStatusFinal == HttpValidationStatus.Valid, 
                             "validationStatusFinal == HttpValidationStatus.Valid");
            }

            /*
             * Try to satisfy a conditional request. The cached response
             * must satisfy all conditions that are present.
             * 
             * We can only satisfy a conditional request if the response
             * is buffered and has no substitution blocks.
             * 
             * N.B. RFC 2616 says conditional requests only occur 
             * with the GET method, but we try to satisfy other
             * verbs (HEAD, POST) as well.
             */
            send304 = -1;

            if (response.IsBuffered() && !cachedRawResponse._rawResponse.HasSubstBlocks) {
                /* Check "If-Modified-Since" header */
                ifModifiedSinceHeader = request.IfModifiedSince;
                if (ifModifiedSinceHeader != null) {
                    send304 = 0;
                    try {
                        utcIfModifiedSince = HttpDate.UtcParse(ifModifiedSinceHeader);
                        if (    settings.IsLastModifiedSet && 
                                settings.UtcLastModified <= utcIfModifiedSince &&
                                utcIfModifiedSince <= context.UtcTimestamp) {

                            send304 = 1;
                        }
                    }
                    catch {
                        Debug.Trace("OutputCacheModuleEnter", "Ignore If-Modified-Since header, invalid format: " + ifModifiedSinceHeader);
                    }
                }

                /* Check "If-None-Match" header */
                if (send304 != 0) {
                    etag = request.IfNoneMatch;
                    if (etag != null) {
                        send304 = 0;
                        etags = etag.Split(s_fieldSeparators);
                        for (i = 0, n = etags.Length; i < n; i++) {
                            if (i == 0 && etags[i].Equals("*")) {
                                send304 = 1;
                                break;
                            }

                            if (etags[i].Equals(settings.ETag)) {
                                send304 = 1;
                                break;
                            }
                        }
                    }
                }
            }

            if (send304 == 1) {
                /*
                 * Send 304 Not Modified
                 */
                Debug.Trace("OutputCacheModuleEnter", "Output cache hit & conditional request satisfied, status=304." + 
                            "\n\tkey=" + key + 
                            "\nReturning from OutputCacheModule::Enter");

                response.ClearAll();
                response.StatusCode = 304;
            }
            else {
                /*
                 * Send the full response.
                 */
#if DBG
                if (send304 == -1) {
                    Debug.Trace("OutputCacheModuleEnter", "Output cache hit.\n\tkey=" + key +
                                "\nReturning from OutputCacheModule::Enter");

                }
                else {
                    Debug.Trace("OutputCacheModuleEnter", "Output cache hit but conditional request not satisfied.\n\tkey=" + key +
                                "\nReturning from OutputCacheModule::Enter");
                }
#endif

                sendBody = (_method != CacheRequestMethod.Head);

                // UseSnapshot calls ClearAll
                response.UseSnapshot(cachedRawResponse._rawResponse, sendBody);
            }

            response.Cache.ResetFromHttpCachePolicySettings(settings, context.UtcTimestamp);

            PerfCounters.IncrementCounter(AppPerfCounter.OUTPUT_CACHE_RATIO_BASE);
            PerfCounters.IncrementCounter(AppPerfCounter.OUTPUT_CACHE_HITS);

            _key = null;
            _recordedCacheMiss = false;
            _method = CacheRequestMethod.Invalid;

            app.CompleteRequest();
        }


        /*
         * If the item is cacheable, add it to the cache.
         */
        /// <include file='doc\OutputCacheModule.uex' path='docs/doc[@for="OutputCacheModule.OnLeave"]/*' />
        /// <devdoc>
        /// <para>Raises the <see langword='Leave'/> event, which causes any cacheable items to 
        ///    be put into the output cache.</para>
        /// </devdoc>
        internal /*public*/ void OnLeave(Object source, EventArgs eventArgs) {
            HttpApplication         app;
            HttpContext             context;
            bool                    cacheable;
            CachedRawResponse       cachedRawResponse;
            CachedVary              cachedVary;
            CachedVary              cachedVaryInCache;
            HttpCachePolicy         cache;
            HttpCachePolicySettings settings;
            CacheDependency         dependency;
            CacheDependency         dependencyVary;
            string                  keyRawResponse;                
            string[]                varyByHeaders;
            string[]                varyByParams;
            bool                    varyByAllParams;
            HttpRequest             request;                        
            HttpResponse            response;                       
            DateTime                utcTimestamp;
            TimeSpan                slidingDelta;                   
            HttpRawResponse         httpRawResponse;
            int                     i, n;
            DateTime                utcExpires;
            bool                    cacheAuthorizedPage;
            CacheInternal           cacheInternal;

            Debug.Trace("OutputCacheModuleLeave", "Beginning OutputCacheModule::Leave");

            app = (HttpApplication)source;
            context = app.Context;
            request = context.Request;
            response = context.Response;
            cache = response.Cache;

#if DBG
            string  reason = null;
#endif
            /*
             * Determine whether the response is cacheable.
             */
            cacheable = false;
            do {

                if (!cache.IsModified()) {
#if DBG
                    reason = "CachePolicy was not modified from non-caching default.";
#endif
                    break;
                }

                if (_key == null) {
#if DBG
                    reason = "no key was created for Request in Enter method.";
#endif
                    break;
                }

                if (response.StatusCode != 200) {
#if DBG
                    reason = "response.StatusCode != 200.";
#endif
                    break;
                }

                if (_method == CacheRequestMethod.Head) {
#if DBG
                    reason = "the cache cannot cache responses to HEAD requests.";
#endif
                    break;
                }

                if (!response.IsBuffered()) {
#if DBG
                    reason = "the response is not buffered.";
#endif
                    break;
                }

                /*
                 * Change a response with HttpCacheability.Public to HttpCacheability.Private
                 * if it requires authorization, and allow it to be cached.
                 *
                 * Note that setting Cacheability to ServerAndPrivate would accomplish
                 * the same thing without needing the "cacheAuthorizedPage" variable,
                 * but in RTM we did not have ServerAndPrivate, and setting that value
                 * would change the behavior.
                 */
                cacheAuthorizedPage = false;
                if (    cache.GetCacheability() == HttpCacheability.Public &&
                        context.RequestRequiresAuthorization()) {

                    cache.SetCacheability(HttpCacheability.Private);
                    cacheAuthorizedPage = true;
                }

                if (    cache.GetCacheability() != HttpCacheability.Public &&
                        cache.GetCacheability() != HttpCacheability.ServerAndPrivate && 
                        cache.GetCacheability() != HttpCacheability.ServerAndNoCache && 
                        !cacheAuthorizedPage) {
#if DBG
                    reason = "CachePolicy.Cacheability is not Public, ServerAndPrivate, or ServerAndNoCache.";
#endif
                    break;
                }

                if (cache.GetNoServerCaching()) {
#if DBG
                    reason = "CachePolicy.NoServerCaching is set.";
#endif
                    break;
                }

                if (!cache.HasExpirationPolicy() && !cache.HasValidationPolicy()) {
#if DBG
                    reason = "CachePolicy has no expiration policy or validation policy.";
#endif
                    break;
                }

                if (cache.VaryByHeaders.GetVaryByUnspecifiedParameters()) {
#if DBG
                    reason = "CachePolicy.Vary.VaryByUnspecifiedParameters was called.";
#endif
                    break;
                }

                if (!cache.VaryByParams.AcceptsParams() && (_method == CacheRequestMethod.Post || request.QueryStringText != String.Empty)) {
#if DBG
                    reason = "the cache cannot cache responses to POSTs or GETs with query strings unless Cache.VaryByParams is modified.";
#endif
                    break;
                }

                cacheable = true;
            } while (false);
            
            /*
             * Add response to cache.
             */
            if (!cacheable) {
#if DBG
                Debug.Assert(reason != null, "reason != null");
                Debug.Trace("OutputCacheModuleLeave", "Item is not output cacheable because " + reason + 
                            "\n\tUrl=" + request.Url.ToString() + 
                            "\nReturning from OutputCacheModule::Leave");
#endif

                return;
            }

            RecordCacheMiss();

            settings = cache.GetCurrentSettings(response);

            /* Determine the size of the sliding expiration.*/
            utcTimestamp = context.UtcTimestamp;
            utcExpires = DateTime.MaxValue;
            if (settings.SlidingExpiration) {
                slidingDelta = settings.SlidingDelta;
                utcExpires = Cache.NoAbsoluteExpiration;
            }
            else {
                slidingDelta = Cache.NoSlidingExpiration;
                if (settings.IsMaxAgeSet) {
                    utcExpires = utcTimestamp + settings.MaxAge;
                }
                else if (settings.IsExpiresSet) {
                    utcExpires = settings.UtcExpires;
                }
            }

            varyByHeaders = settings.VaryByHeaders;
            if (settings.IgnoreParams) {
                varyByParams = null;
            }
            else {
                varyByParams = settings.VaryByParams;
            }

            cacheInternal = HttpRuntime.CacheInternal;

            if (varyByHeaders == null && varyByParams == null && settings.VaryByCustom == null) {
                /*
                 * This is not a varyBy item.
                 */
                keyRawResponse = _key;
                cachedVary = null;
                dependencyVary = null;
            }
            else {
                /*
                 * There is a vary in the cache policy. We handle this
                 * by adding another item to the cache which contains
                 * a list of the vary headers. A request for the item
                 * without the vary headers in the key will return this 
                 * item. From the headers another key can be constructed
                 * to lookup the item with the raw response.
                 */
                if (varyByHeaders != null) {
                    for (i = 0, n = varyByHeaders.Length; i < n; i++) {
                        varyByHeaders[i] = "HTTP_" + CultureInfo.InvariantCulture.TextInfo.ToUpper(
                                varyByHeaders[i].Replace('-', '_'));
                    }
                }

                varyByAllParams = false;
                if (varyByParams != null) {
                    varyByAllParams = (varyByParams.Length == 1 && varyByParams[0] == "*");
                    if (varyByAllParams) {
                        varyByParams = null;
                    }
                    else {
                        for (i = 0, n = varyByParams.Length; i < n; i++) {
                            varyByParams[i] = CultureInfo.InvariantCulture.TextInfo.ToLower(varyByParams[i]);
                        }
                    }
                }

                cachedVary = new CachedVary(varyByHeaders, varyByParams, varyByAllParams, settings.VaryByCustom);
                keyRawResponse = CreateOutputCachedItemKey(context, cachedVary);
                if (keyRawResponse == null) {
                    Debug.Trace("OutputCacheModuleLeave", "Couldn't add non-cacheable post.\n\tkey=" + _key);
                    return;
                }

                // it is possible that the user code calculating custom vary-by
                // string would Flush making the response non-cacheable. Check fo it here.
                if (!response.IsBuffered()) {
                    Debug.Trace("OutputCacheModuleLeave", "Response.Flush() inside GetVaryByCustomString\n\tkey=" + _key);
                    return;
                }

                /*
                 * Add the CachedVary item so that a request will know
                 * which headers are needed to issue another request.
                 * 
                 * Use the Add method so that we guarantee we only use
                 * a single CachedVary and don't overwrite existing ones.
                 */
                cachedVaryInCache = (CachedVary) cacheInternal.UtcAdd(
                        _key, cachedVary, null, Cache.NoAbsoluteExpiration, Cache.NoSlidingExpiration,
                        CacheItemPriority.Default, null);

                if (cachedVaryInCache != null) {
                    if (cachedVary.Equals(cachedVaryInCache)) {
                        cachedVary = cachedVaryInCache;
                    }
                    else {
                        Debug.Trace("OutputCacheModuleLeave", "CachedVary definition changed, new CachedVary inserted into cache.\n\tkey=" + _key);
                        cacheInternal.UtcInsert(_key, cachedVary);
                    }
                }
#if DBG
                else {
                    Debug.Trace("OutputCacheModuleLeave", "Added CachedVary to cache.\n\tkey=" + _key);
                }
#endif

                dependencyVary = new CacheDependency(false, null, new string[1] {_key});
            }

            Debug.Trace("OutputCacheModuleLeave", "Adding response to cache.\n\tkey=" + keyRawResponse +
                        "\nReturning from OutputCacheModule::Leave");

            dependency = response.GetCacheDependency(dependencyVary);

            /*
             * Create the response object to be sent on cache hits.
             */
            httpRawResponse = response.GetSnapshot();
            cachedRawResponse = new CachedRawResponse(httpRawResponse, settings, cachedVary);
            Debug.Trace("OutputCacheModuleLeave", "utcExpires=" + utcExpires + "expires=" + DateTimeUtil.ConvertToLocalTime(utcExpires));
            cacheInternal.UtcInsert(
                    keyRawResponse, cachedRawResponse, dependency, utcExpires,
                    slidingDelta, CacheItemPriority.Normal, s_cacheItemRemovedCallback);

            PerfCounters.IncrementCounter(AppPerfCounter.OUTPUT_CACHE_ENTRIES);
            PerfCounters.IncrementCounter(AppPerfCounter.OUTPUT_CACHE_TURNOVER_RATE);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\processmodelinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProcessModelInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * ProcessInfo class
 */
namespace System.Web {
    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Security.Permissions;

    /// <include file='doc\ProcessModelInfo.uex' path='docs/doc[@for="ProcessModelInfo"]/*' />
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ProcessModelInfo {
        /// <include file='doc\ProcessModelInfo.uex' path='docs/doc[@for="ProcessModelInfo.GetCurrentProcessInfo"]/*' />
        static public ProcessInfo    GetCurrentProcessInfo() {
            InternalSecurityPermissions.AspNetHostingPermissionLevelHigh.Demand();

            HttpContext context = HttpContext.Current;
            if (context == null || context.WorkerRequest == null || 
                !(context.WorkerRequest is System.Web.Hosting.ISAPIWorkerRequestOutOfProc))
            {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Process_information_not_available));                
            }

            int     dwReqExecuted = 0;
            int     dwReqExecuting = 0;
            long    tmCreateTime = 0;
            int     pid = 0;
            int     mem = 0;

            int iRet = UnsafeNativeMethods.PMGetCurrentProcessInfo (
                    ref dwReqExecuted, ref dwReqExecuting, ref mem, 
                    ref tmCreateTime, ref pid);

            if (iRet < 0)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Process_information_not_available));

            DateTime startTime = DateTime.FromFileTime(tmCreateTime);
            TimeSpan age = DateTime.Now.Subtract(startTime);

            return new ProcessInfo(startTime, age, pid, dwReqExecuted, 
                                   ProcessStatus.Alive, ProcessShutdownReason.None, mem);
        }

        /// <include file='doc\ProcessModelInfo.uex' path='docs/doc[@for="ProcessModelInfo.GetHistory"]/*' />
        static public ProcessInfo[]  GetHistory(int numRecords) {
            InternalSecurityPermissions.AspNetHostingPermissionLevelHigh.Demand();

            HttpContext context = HttpContext.Current;
            if (context == null || context.WorkerRequest == null || 
                !(context.WorkerRequest is System.Web.Hosting.ISAPIWorkerRequestOutOfProc))
            {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Process_information_not_available));                
            }

            if (numRecords < 1)
                return null;

            int [] dwPID   = new int [numRecords];
            int [] dwExed  = new int [numRecords];
            int [] dwExei  = new int [numRecords];
            int [] dwPend  = new int [numRecords];
            int [] dwReas  = new int [numRecords];
            long [] tmCrea = new long [numRecords];
            long [] tmDeat = new long [numRecords];
            int []  mem    = new int [numRecords];

            int iRows = UnsafeNativeMethods.PMGetHistoryTable (numRecords, dwPID, dwExed, dwPend, dwExei, dwReas, mem, tmCrea, tmDeat);
            if (iRows < 0)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Process_information_not_available));

            ProcessInfo[] ret = new ProcessInfo[iRows];
            for (int iter=0; iter<iRows; iter++) {

                DateTime startTime = DateTime.FromFileTime(tmCrea[iter]);
                TimeSpan age       = DateTime.Now.Subtract(startTime);

                ProcessStatus          status = ProcessStatus.Alive;
                ProcessShutdownReason  rea    = ProcessShutdownReason.None;

                if (dwReas[iter] != 0) {
                    if (tmDeat[iter] > 0)
                        age = DateTime.FromFileTime(tmDeat[iter]).Subtract(startTime);

                    if ((dwReas[iter] & 0x0004) != 0)
                        status = ProcessStatus.Terminated;
                    else if ((dwReas[iter] & 0x0002) != 0)
                        status = ProcessStatus.ShutDown;
                    else
                        status = ProcessStatus.ShuttingDown;
                    
                    if ((0x0040 & dwReas[iter]) != 0)
                        rea = ProcessShutdownReason.IdleTimeout;
                    else if ((0x0080 & dwReas[iter]) != 0)
                        rea = ProcessShutdownReason.RequestsLimit;
                    else if ((0x0100 & dwReas[iter]) != 0)
                        rea = ProcessShutdownReason.RequestQueueLimit;
                    else if ((0x0020 & dwReas[iter]) != 0)
                        rea = ProcessShutdownReason.Timeout;
                    else if ((0x0200 & dwReas[iter]) != 0)
                        rea = ProcessShutdownReason.MemoryLimitExceeded;
                    else if ((0x0400 & dwReas[iter]) != 0)
                        rea = ProcessShutdownReason.PingFailed;
                    else if ((0x0800 & dwReas[iter]) != 0)
                        rea = ProcessShutdownReason.DeadlockSuspected;
                    else
                        rea = ProcessShutdownReason.Unexpected;
                }

                ret[iter] = new ProcessInfo(startTime, age, dwPID[iter], dwExed[iter], status, rea, mem[iter]);
            }

            return ret;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\processinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProcessInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * ProcessInfo class
 */
namespace System.Web {
    using System.Threading;
    using System.Security.Permissions;

    /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessStatus"]/*' />
    /// <devdoc>
    ///    <para>Provides enumerated values representing status of a process.</para>
    /// </devdoc>
    public enum ProcessStatus {
        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessStatus.Alive"]/*' />
        /// <devdoc>
        ///    <para>Specifies that the process is running.</para>
        /// </devdoc>
        Alive         = 1,
        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessStatus.ShuttingDown"]/*' />
        /// <devdoc>
        ///    <para>Specifies that the process has begun shutting down.</para>
        /// </devdoc>
        ShuttingDown  = 2,
        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessStatus.ShutDown"]/*' />
        /// <devdoc>
        ///    <para>Specifies the the process has been shut down.</para>
        /// </devdoc>
        ShutDown      = 3,
        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessStatus.Terminated"]/*' />
        /// <devdoc>
        ///    <para>Specifies that the process has been terminated.</para>
        /// </devdoc>
        Terminated    = 4
    }
    
    /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessShutdownReason"]/*' />
    /// <devdoc>
    ///    <para>Provides enumerated values representing the reason a process has shut 
    ///       down.</para>
    /// </devdoc>
    public enum ProcessShutdownReason {
        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessShutdownReason.None"]/*' />
        /// <devdoc>
        ///    <para>Specifies that the process has not been shut down.</para>
        /// </devdoc>
        None                = 0,           // alive
        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessShutdownReason.Unexpected"]/*' />
        /// <devdoc>
        ///    <para>Specifies that the process has been shut down unexpectedly.</para>
        /// </devdoc>
        Unexpected          = 1,
        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessShutdownReason.RequestsLimit"]/*' />
        /// <devdoc>
        ///    <para>Specifies that the process request exceeded the limit on number of 
        ///       processes.</para>
        /// </devdoc>
        RequestsLimit       = 2,
        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessShutdownReason.RequestQueueLimit"]/*' />
        /// <devdoc>
        ///    <para>Specifies that the process request exceeded the limit on number of 
        ///       processes in que.</para>
        /// </devdoc>
        RequestQueueLimit   = 3,
        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessShutdownReason.Timeout"]/*' />
        /// <devdoc>
        ///    <para>Specifies that the process timed out.</para>
        /// </devdoc>
        Timeout             = 4,
        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessShutdownReason.IdleTimeout"]/*' />
        /// <devdoc>
        ///    <para>Specifies that the process exceeded the limit on process idle time.</para>
        /// </devdoc>
        IdleTimeout         = 5,
        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessShutdownReason.MemoryLimitExceeded"]/*' />
        /// <devdoc>
        ///    <para>Specifies that the process exceeded the limit of memory available per process.</para>
        /// </devdoc>
        MemoryLimitExceeded = 6,
        
        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessShutdownReason.PingFailed"]/*' />
        PingFailed = 7,

        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessShutdownReason.DeadlockSuspected"]/*' />
        DeadlockSuspected = 8
    }    

    /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessInfo"]/*' />
    /// <devdoc>
    ///    <para>Provides information on processes.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ProcessInfo {
        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessInfo.StartTime"]/*' />
        /// <devdoc>
        ///    <para>Indicates the time a process was started.</para>
        /// </devdoc>
        public DateTime               StartTime { get { return _StartTime;}}
        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessInfo.Age"]/*' />
        /// <devdoc>
        ///    <para>Indicates the length of time the process has been running.</para>
        /// </devdoc>
        public TimeSpan               Age { get { return _Age;}}
        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessInfo.ProcessID"]/*' />
        /// <devdoc>
        ///    <para>Indicates the process id of the process.</para>
        /// </devdoc>
        public int                    ProcessID { get { return _ProcessID;}}
        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessInfo.RequestCount"]/*' />
        public int                    RequestCount { get { return _RequestCount;}}
        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessInfo.Status"]/*' />
        /// <devdoc>
        ///    <para>Indicates the current status of the process.</para>
        /// </devdoc>
        public ProcessStatus          Status { get { return _Status;}}
        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessInfo.ShutdownReason"]/*' />
        /// <devdoc>
        ///    <para>Indicates the reason the process shut down.</para>
        /// </devdoc>
        public ProcessShutdownReason  ShutdownReason { get { return _ShutdownReason;}}
        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessInfo.PeakMemoryUsed"]/*' />
        /// <devdoc>
        ///    <para>Indicates the maximum amount of memory the process has used.</para>
        /// </devdoc>
        public int                    PeakMemoryUsed { get { return _PeakMemoryUsed;}}

        private DateTime               _StartTime;
        private TimeSpan               _Age;
        private int                    _ProcessID;
        private int                    _RequestCount;
        private ProcessStatus          _Status;
        private ProcessShutdownReason  _ShutdownReason;
        private int                    _PeakMemoryUsed;

        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessInfo.SetAll"]/*' />
        /// <devdoc>
        ///    <para>Sets internal information indicating the status of the process.</para>
        /// </devdoc>
        public void SetAll (DateTime startTime, TimeSpan age, int processID, int requestCount, ProcessStatus status, 
                            ProcessShutdownReason  shutdownReason, int peakMemoryUsed) {
            _StartTime = startTime;
            _Age = age;
            _ProcessID = processID;
            _RequestCount = requestCount;
            _Status = status;
            _ShutdownReason = shutdownReason;
            _PeakMemoryUsed = peakMemoryUsed;
        }

        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessInfo.ProcessInfo"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see langword='ProcessInfo'/> class and sets internal information 
        ///    indicating the status of the process.</para>
        /// </devdoc>
        public ProcessInfo (DateTime startTime, TimeSpan age, int processID, int requestCount, ProcessStatus status, 
                            ProcessShutdownReason  shutdownReason, int peakMemoryUsed) {
            _StartTime = startTime;
            _Age = age;
            _ProcessID = processID;
            _RequestCount = requestCount;
            _Status = status;
            _ShutdownReason = shutdownReason;
            _PeakMemoryUsed = peakMemoryUsed;
        }

        /// <include file='doc\ProcessInfo.uex' path='docs/doc[@for="ProcessInfo.ProcessInfo1"]/*' />
        public ProcessInfo() {
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\nativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web {
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;
    using System.Web.Util;
    using System.Web.Hosting;

    // delegate used as argument to Ecb async IO
    delegate void EcbAsyncIONotification(IntPtr ecb, int context, int cb, int error);

    [System.Runtime.InteropServices.ComVisible(false)]
    internal sealed class NativeMethods {
        /*
         * ASPNET_ISAPI.DLL
         */
        private NativeMethods() {}

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\requesttimeoutmanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="RequestTimeoutManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Request timeout manager -- implements the request timeout mechanism
 */
namespace System.Web {
    using System.Threading;
    using System.Collections;
    using System.Web.Util;

    internal class RequestTimeoutManager {
        private int                 _requestCount;
        private DoubleLinkList[]    _lists;           // partitioned to avoid contention
        private int                 _currentList;
        private int                 _inProgressLock;  // only 1 thread can be cancelling
        private readonly TimeSpan   _timerPeriod = new TimeSpan(0, 0, 15); // 15 second init precision
        private Timer               _timer;

        internal RequestTimeoutManager() {
            // initialize request lists

            _requestCount = 0;

            _lists = new DoubleLinkList[13];
            for (int i = 0; i < _lists.Length; i++)
                _lists[i] = new DoubleLinkList();
            _currentList = 0;

            // init lock

            _inProgressLock = 0;

            // create the timer

#if DBG
            if (!Debug.IsTagPresent("Timer") || Debug.IsTagEnabled("Timer"))
#endif
            {
                _timer = new Timer(new TimerCallback(this.TimerCompletionCallback), null, _timerPeriod, _timerPeriod);
            }

        }

        internal void Stop() {
            // stop the timer

            if (_timer != null) {
                ((IDisposable)_timer).Dispose();
                _timer = null;
            }

            while (_inProgressLock != 0)
                Thread.Sleep(0);

            // cancel all cancelable requests

            if (_requestCount > 0)
                CancelTimedOutRequests(DateTime.UtcNow.AddYears(1)); // future date
        }

        private void TimerCompletionCallback(Object state) {
            if (_requestCount > 0)
                CancelTimedOutRequests(DateTime.UtcNow);
        }

        private void CancelTimedOutRequests(DateTime now) {

            // only one thread can be doing it

            if (Interlocked.CompareExchange(ref _inProgressLock, 1, 0) != 0)
                return;

            // collect them all into a separate list with minimal locking

            ArrayList entries = new ArrayList(_requestCount); // size can change
            DoubleLinkListEnumerator en;

            for (int i = 0; i < _lists.Length; i++) {
                lock (_lists[i]) {
                    en = _lists[i].GetEnumerator();

                    while (en.MoveNext())
                        entries.Add(en.GetDoubleLink());

                    en = null;
                }
            }

            // walk through the collected list to timeout what's needed

            int n = entries.Count;

            for (int i = 0; i < n; i++)
                ((RequestTimeoutEntry)entries[i]).TimeoutIfNeeded(now);

            // this thread is done -- unlock

            Interlocked.Exchange(ref _inProgressLock, 0);
        }

        internal void Add(HttpContext context) {
            // create new entry

            RequestTimeoutEntry entry = new RequestTimeoutEntry(context);

            // add it to the list

            int i = _currentList++;
            if (i >= _lists.Length) {
                i = 0;
                _currentList = 0;
            }

            entry.AddToList(_lists[i]);
            Interlocked.Increment(ref _requestCount);

            // update HttpContext
            context.TimeoutLink = entry;
        }

        internal void Remove(HttpContext context) {
            RequestTimeoutEntry entry = (RequestTimeoutEntry)context.TimeoutLink;

            // remove from the list
            if (entry != null) {
                entry.RemoveFromList();
                Interlocked.Decrement(ref _requestCount);
            }

            // update HttpContext
            context.TimeoutLink = null;
        }

        private class RequestTimeoutEntry : DoubleLink {
            private  HttpContext    _context;   // the request
            private  Thread         _thread;    // thread on which the request is running
            private  DoubleLinkList _list;

            internal RequestTimeoutEntry(HttpContext context) {
                _context = context;
                _context.EnsureTimeout(); // to avoid race getting config later (ASURT 127388)
                _thread = Thread.CurrentThread;
            }

            internal void AddToList(DoubleLinkList list) {
                lock(list) {
                    list.InsertTail(this);
                    _list = list;
                }
            }

            internal void RemoveFromList() {
                if (_list != null) {
                    lock(_list) {
                        Remove();
                        _list = null;
                    }
                }
            }

            internal void TimeoutIfNeeded(DateTime now) {
                if (_context.MustTimeout(now)) {
                    RemoveFromList();
                    _thread.Abort(new HttpApplication.CancelModuleException(true));
                }
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\requestqueue.cs ===
//------------------------------------------------------------------------------
// <copyright file="RequestQueue.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//
// Request Queue
//      queues up the requests to avoid thread pool starvation,
//      making sure that there are always available threads to process requests
//

namespace System.Web {
    using System.Threading;
    using System.Collections;
    using System.Web.Util;

    internal class RequestQueue {
        // configuration params
        private int _minExternFreeThreads;
        private int _minLocalFreeThreads;
        private int _queueLimit;

        // two queues -- one for local requests, one for external
        private Queue _localQueue = new Queue();
        private Queue _externQueue = new Queue();

        // total count
        private int _count;

        // work items queued to pick up new work
        private WaitCallback _workItemCallback;
        private int _workItemCount;
        private const int _workItemLimit = 2;
        private bool _draining;

        // timer to drain the queue
        private readonly TimeSpan   _timerPeriod = new TimeSpan(0, 0, 10); // 10 seconds
        private Timer               _timer;


        // helpers
        private static bool IsLocal(HttpWorkerRequest wr) {
            String remoteAddress = wr.GetRemoteAddress();

            // check if localhost
            if (remoteAddress == "127.0.0.1" || remoteAddress == "::1")
                return true;

            // if unknown, assume not local
            if (remoteAddress == null || remoteAddress.Length == 0)
                return false;

            // compare with local address
            if (remoteAddress == wr.GetLocalAddress())
                return true;

            return false;
        }

        private void QueueRequest(HttpWorkerRequest wr, bool isLocal) {
            lock (this) {
                if (isLocal)
                    _localQueue.Enqueue(wr);
                else 
                    _externQueue.Enqueue(wr);

                _count++;
            }
            PerfCounters.IncrementGlobalCounter(GlobalPerfCounter.REQUESTS_QUEUED);
            PerfCounters.IncrementCounter(AppPerfCounter.REQUESTS_IN_APPLICATION_QUEUE);
        }

        private HttpWorkerRequest DequeueRequest(bool localOnly) {
            Object wr = null;

            if (_count > 0) {
                lock (this) {
                    if (_localQueue.Count > 0) {
                        wr = _localQueue.Dequeue();
                        _count--;
                    }
                    else if (!localOnly && _externQueue.Count > 0) {
                        wr = _externQueue.Dequeue();
                        _count--;
                    }
                }
                if (wr != null) {
                    PerfCounters.DecrementGlobalCounter(GlobalPerfCounter.REQUESTS_QUEUED);
                    PerfCounters.DecrementCounter(AppPerfCounter.REQUESTS_IN_APPLICATION_QUEUE);
                }
            }

            return (HttpWorkerRequest)wr;
        }

        // ctor
        internal RequestQueue(int minExternFreeThreads, int minLocalFreeThreads, int queueLimit) {
            _minExternFreeThreads = minExternFreeThreads;
            _minLocalFreeThreads = minLocalFreeThreads;
            _queueLimit = queueLimit;
            
            _workItemCallback = new WaitCallback(this.WorkItemCallback);

            _timer = new Timer(new TimerCallback(this.TimerCompletionCallback), null, _timerPeriod, _timerPeriod);
        }

        // method called from HttpRuntime for incoming requests
        internal HttpWorkerRequest GetRequestToExecute(HttpWorkerRequest wr) {
            int workerThreads, ioThreads;
            ThreadPool.GetAvailableThreads(out workerThreads, out ioThreads);
            int freeThreads = (ioThreads > workerThreads) ? workerThreads : ioThreads;

            // fast path when there are threads available and nothing queued
            if (freeThreads >= _minExternFreeThreads && _count == 0)
                return wr;

            bool isLocal = IsLocal(wr);

            // fast path when there are threads for local requests available and nothing queued
            if (isLocal && freeThreads >= _minLocalFreeThreads && _count == 0)
                return wr;

            // reject if queue limit exceeded
            if (_count >= _queueLimit) {
                HttpRuntime.RejectRequestNow(wr);
                return null;
            }

            // can't execute the current request on the current thread -- need to queue
            QueueRequest(wr, isLocal);

            // maybe can execute a request previously queued
            if (freeThreads >= _minExternFreeThreads) {
                wr = DequeueRequest(false); // enough threads to process even external requests
            }
            else if (freeThreads >= _minLocalFreeThreads) {
                wr = DequeueRequest(true);  // enough threads to process only local requests
            }
            else {
                wr = null;                  // not enough threads -> do nothing on this thread
                ScheduleMoreWorkIfNeeded(); // try to schedule to worker thread
            }

            return wr;
        }

        // method called from HttpRuntime at the end of request
        internal void ScheduleMoreWorkIfNeeded() {
            // too late for more work if draining
            if (_draining)
                return;

            // is queue empty?
            if (_count == 0)
                return;

            // already scheduled enough work items
            if (_workItemCount >= _workItemLimit)
                return;

            // enough worker threads?
            int workerThreads, ioThreads;
            ThreadPool.GetAvailableThreads(out workerThreads, out ioThreads);
            if (workerThreads < _minLocalFreeThreads)
                return;

            // queue the work item
            Interlocked.Increment(ref _workItemCount);
            ThreadPool.QueueUserWorkItem(_workItemCallback);
        }

        // is empty property
        internal bool IsEmpty {
            get { return (_count == 0); }
        }

        // method called to pick up more work
        private void WorkItemCallback(Object state) {
            Interlocked.Decrement(ref _workItemCount);

            // too late for more work if draining
            if (_draining)
                return;

            // is queue empty?
            if (_count == 0)
                return;

            int workerThreads, ioThreads;
            ThreadPool.GetAvailableThreads(out workerThreads, out ioThreads);

            // not enough worker threads to do anything
            if (workerThreads < _minLocalFreeThreads)
                return;

            // pick up request from the queue
            HttpWorkerRequest wr = DequeueRequest(workerThreads < _minExternFreeThreads);
            if (wr == null)
                return;

            // let another work item through before processing the request
            ScheduleMoreWorkIfNeeded();

            // call the runtime to process request
            HttpRuntime.ProcessRequestNow(wr);
        }

        // periodic timer to pick up more work
        private void TimerCompletionCallback(Object state) {
            ScheduleMoreWorkIfNeeded();
        }

        // reject all requests
        internal void Drain() {
            // set flag before killing timer to shorten the code path
            // in the callback after the timer is disposed
            _draining = true;

            // stop the timer
            if (_timer != null) {
                ((IDisposable)_timer).Dispose();
                _timer = null;
            }

            // wait for all work items to finish
            while (_workItemCount > 0)
                Thread.Sleep(100);

            // is queue empty?
            if (_count == 0)
                return;

            // reject the remaining requests
            for (;;) {
                HttpWorkerRequest wr = DequeueRequest(false);
                if (wr == null)
                    break;
                HttpRuntime.RejectRequestNow(wr);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\safenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="SafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web {
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [
    System.Runtime.InteropServices.ComVisible(false), 
    System.Security.SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal sealed class SafeNativeMethods {
        
        private SafeNativeMethods() {}

        [DllImport(ModName.KERNEL32_FULL_NAME)]
        internal /*public*/ extern static int GetCurrentProcessId();

        [DllImport(ModName.KERNEL32_FULL_NAME)]
        internal /*public*/ extern static int GetCurrentThreadId();

        [DllImport(ModName.KERNEL32_FULL_NAME)]
        internal static extern bool QueryPerformanceCounter( [System.Runtime.InteropServices.Out, In] ref long lpPerformanceCount);

        [DllImport(ModName.KERNEL32_FULL_NAME)]
        internal static extern bool QueryPerformanceFrequency( [System.Runtime.InteropServices.Out, In] ref long lpFrequency);                     

        [DllImport(ModName.KERNEL32_FULL_NAME, CharSet=CharSet.Unicode)]
        internal static extern void OutputDebugString(String message);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal static extern int CurProcInitialize();

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal static extern int CurProcGetReading();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\unsafenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnsafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web {
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;
    using System.Web.Util;
    using System.Web.Hosting;

    [
    System.Runtime.InteropServices.ComVisible(false), 
    System.Security.SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal sealed class UnsafeNativeMethods {
        static internal readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);

        private UnsafeNativeMethods() {}

        /*
         * ADVAPI32.dll
         */
        [DllImport(ModName.ADVAPI32_FULL_NAME)]
        internal /*public*/ static extern int SetThreadToken(IntPtr threadref, IntPtr token);

        [DllImport(ModName.ADVAPI32_FULL_NAME)]
        internal /*public*/ static extern int RevertToSelf();

        public const int TOKEN_ALL_ACCESS   = 0x000f01ff;
        public const int TOKEN_EXECUTE      = 0x00020000;
        public const int TOKEN_READ         = 0x00020008;
        public const int TOKEN_IMPERSONATE  = 0x00000004;

        public const int ERROR_NO_TOKEN = 1008;

        [DllImport(ModName.ADVAPI32_FULL_NAME, SetLastError=true)]
        internal /*public*/ static extern int OpenThreadToken(IntPtr thread, int access, bool openAsSelf, ref IntPtr hToken);

        /*
         * ASPNET_STATE.EXE
         */

        [DllImport(ModName.STATE_FULL_NAME)]
        internal /*public*/ static extern void STWNDCloseConnection(IntPtr tracker);

        [DllImport(ModName.STATE_FULL_NAME)]
        internal /*public*/ static extern void STWNDDeleteStateItem(IntPtr stateItem);

        [DllImport(ModName.STATE_FULL_NAME)]
        internal /*public*/ static extern void STWNDEndOfRequest(IntPtr tracker);

        [DllImport(ModName.STATE_FULL_NAME, CharSet=CharSet.Ansi, BestFitMapping=false)]
        internal /*public*/ static extern void STWNDGetLocalAddress(IntPtr tracker, StringBuilder buf);

        [DllImport(ModName.STATE_FULL_NAME)]
        internal /*public*/ static extern int STWNDGetLocalPort(IntPtr tracker);

        [DllImport(ModName.STATE_FULL_NAME, CharSet=CharSet.Ansi, BestFitMapping=false)]
        internal /*public*/ static extern void STWNDGetRemoteAddress(IntPtr tracker, StringBuilder buf);

        [DllImport(ModName.STATE_FULL_NAME)]
        internal /*public*/ static extern int STWNDGetRemotePort(IntPtr tracker);


        [DllImport(ModName.STATE_FULL_NAME)]
        internal /*public*/ static extern bool STWNDIsClientConnected(IntPtr tracker);

        [DllImport(ModName.STATE_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern void STWNDSendResponse(IntPtr tracker, StringBuilder status, int statusLength,
                                                    StringBuilder headers, int headersLength, IntPtr unmanagedState);

        /*
         * KERNEL32.DLL
         */
        internal const int FILE_ATTRIBUTE_READONLY             = 0x00000001;
        internal const int FILE_ATTRIBUTE_HIDDEN               = 0x00000002;
        internal const int FILE_ATTRIBUTE_SYSTEM               = 0x00000004;
        internal const int FILE_ATTRIBUTE_DIRECTORY            = 0x00000010;
        internal const int FILE_ATTRIBUTE_ARCHIVE              = 0x00000020;
        internal const int FILE_ATTRIBUTE_DEVICE               = 0x00000040;
        internal const int FILE_ATTRIBUTE_NORMAL               = 0x00000080;
        internal const int FILE_ATTRIBUTE_TEMPORARY            = 0x00000100;
        internal const int FILE_ATTRIBUTE_SPARSE_FILE          = 0x00000200;
        internal const int FILE_ATTRIBUTE_REPARSE_POINT        = 0x00000400;
        internal const int FILE_ATTRIBUTE_COMPRESSED           = 0x00000800;
        internal const int FILE_ATTRIBUTE_OFFLINE              = 0x00001000;
        internal const int FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  = 0x00002000;
        internal const int FILE_ATTRIBUTE_ENCRYPTED            = 0x00004000;

        // Win32 Structs in N/Direct style
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
        internal struct WIN32_FIND_DATA {
            internal uint dwFileAttributes;
            // ftCreationTime was a by-value FILETIME structure
            internal uint ftCreationTime_dwLowDateTime ;
            internal uint ftCreationTime_dwHighDateTime;
            // ftLastAccessTime was a by-value FILETIME structure
            internal uint ftLastAccessTime_dwLowDateTime;
            internal uint ftLastAccessTime_dwHighDateTime;
            // ftLastWriteTime was a by-value FILETIME structure
            internal uint ftLastWriteTime_dwLowDateTime;
            internal uint ftLastWriteTime_dwHighDateTime;
            internal uint nFileSizeHigh;
            internal uint nFileSizeLow;
            internal uint dwReserved0;
            internal uint dwReserved1;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=260)]
            internal string   cFileName;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=14)]
            internal string   cAlternateFileName;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct WIN32_FILE_ATTRIBUTE_DATA {
            internal int fileAttributes;
            internal uint ftCreationTimeLow;
            internal uint ftCreationTimeHigh;
            internal uint ftLastAccessTimeLow;
            internal uint ftLastAccessTimeHigh;
            internal uint ftLastWriteTimeLow;
            internal uint ftLastWriteTimeHigh;
            internal int fileSizeHigh;
            internal int fileSizeLow;
        }


        [DllImport(ModName.KERNEL32_FULL_NAME, SetLastError=true)]
        internal static extern bool CloseHandle(IntPtr handle);

        [DllImport(ModName.KERNEL32_FULL_NAME, SetLastError=true)]
        internal /*public*/ static extern bool FindClose(IntPtr hndFindFile);
    
        [DllImport(ModName.KERNEL32_FULL_NAME, SetLastError=true, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern IntPtr FindFirstFile(
                    string pFileName, out WIN32_FIND_DATA pFindFileData);

        [DllImport(ModName.KERNEL32_FULL_NAME, SetLastError=true, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern bool FindNextFile(
                    IntPtr hndFindFile, out WIN32_FIND_DATA pFindFileData);

        internal const int GetFileExInfoStandard = 0;

        [DllImport(ModName.KERNEL32_FULL_NAME, SetLastError=true, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern bool GetFileAttributesEx(string name, int fileInfoLevel, out WIN32_FILE_ATTRIBUTE_DATA data);

        [DllImport(ModName.KERNEL32_FULL_NAME)]
        internal /*public*/ extern static int GetProcessAffinityMask(
                IntPtr handle, 
                out IntPtr processAffinityMask,
                out IntPtr systemAffinityMask);

        [DllImport(ModName.KERNEL32_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ extern static int GetComputerName(StringBuilder nameBuffer, ref int bufferSize);

        [DllImport(ModName.KERNEL32_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ extern static int GetModuleFileName(IntPtr module, StringBuilder filename, int size);

        [DllImport(ModName.KERNEL32_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ extern static IntPtr GetModuleHandle(string moduleName);

        [StructLayout(LayoutKind.Sequential, Pack=1)]
        public struct SYSTEM_INFO {
            public ushort wProcessorArchitecture;
            public ushort wReserved;
            public uint dwPageSize;
            public IntPtr lpMinimumApplicationAddress;
            public IntPtr lpMaximumApplicationAddress;
            public IntPtr dwActiveProcessorMask;
            public uint dwNumberOfProcessors;
            public uint dwProcessorType;
            public uint dwAllocationGranularity;
            public ushort wProcessorLevel;
            public ushort wProcessorRevision;
        };

        [DllImport(ModName.KERNEL32_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern void GetSystemInfo(out SYSTEM_INFO si);

        [DllImport(ModName.KERNEL32_FULL_NAME, CharSet=CharSet.Unicode, SetLastError=true)]
        internal /*public*/ static extern IntPtr LoadLibrary(string libFilename);

        [DllImport(ModName.KERNEL32_FULL_NAME, CharSet=CharSet.Unicode, SetLastError=true)]
        internal /*public*/ static extern IntPtr FindResource(IntPtr hModule, IntPtr lpName, IntPtr lpType);

        [DllImport(ModName.KERNEL32_FULL_NAME, CharSet=CharSet.Unicode, SetLastError=true)]
        internal /*public*/ static extern int SizeofResource(IntPtr hModule, IntPtr hResInfo);

        [DllImport(ModName.KERNEL32_FULL_NAME, CharSet=CharSet.Unicode, SetLastError=true)]
        internal /*public*/ static extern IntPtr LoadResource(IntPtr hModule, IntPtr hResInfo);

        [DllImport(ModName.KERNEL32_FULL_NAME, CharSet=CharSet.Unicode, SetLastError=true)]
        internal /*public*/ static extern IntPtr LockResource(IntPtr hResData);

        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
        internal struct MEMORYSTATUSEX {
            internal int dwLength;
            internal int dwMemoryLoad;
            internal long ullTotalPhys;
            internal long ullAvailPhys;
            internal long ullTotalPageFile;
            internal long ullAvailPageFile;
            internal long ullTotalVirtual;
            internal long ullAvailVirtual;
            internal long ullAvailExtendedVirtual;

            internal /*public*/ void Init() {
                dwLength = Marshal.SizeOf(typeof(UnsafeNativeMethods.MEMORYSTATUSEX));
            }
        }

        [DllImport(ModName.KERNEL32_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ extern static int GlobalMemoryStatusEx(ref MEMORYSTATUSEX memoryStatusEx);

        [StructLayout(LayoutKind.Sequential)]
        internal class OSVERSIONINFOEX {
            internal Int32 dwOSVersionInfoSize = Marshal.SizeOf(typeof(OSVERSIONINFOEX));
            internal Int32 dwMajorVersion = 0;
            internal Int32 dwMinorVersion = 0;
            internal Int32 dwBuildNumber = 0;
            internal Int32 dwPlatformId = 0;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst=128)]
            internal string szCSDVersion = null;
            internal Int16 wServicePackMajor = 0;
            internal Int16 wServicePackMinor = 0;
            internal Int16 wSuiteMask = 0;
            internal byte wProductType = 0;
            internal byte wReserved = 0;

            internal OSVERSIONINFOEX() {}
        }

        [DllImport(ModName.KERNEL32_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern bool GetVersionEx([In, Out] OSVERSIONINFOEX ver);

        [DllImport(ModName.KERNEL32_FULL_NAME)]
        internal /*public*/ static extern IntPtr GetCurrentThread();

        /*
         * ASPNET_ISAPI.DLL
         */
        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode, BestFitMapping=false)]
        internal /*public*/ static extern void AppDomainRestart(string appId);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int AspCompatProcessRequest(AspCompatCallback callback, [MarshalAs(UnmanagedType.Interface)] Object context);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int AspCompatOnPageStart([MarshalAs(UnmanagedType.Interface)] Object obj);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int AspCompatIsApartmentComponent([MarshalAs(UnmanagedType.Interface)] Object obj);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int AttachDebugger(string clsId, string sessId, IntPtr userToken);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int CookieAuthParseTicket (byte []         pData,
                                                        int             iDataLen,
                                                        StringBuilder   szName,
                                                        int             iNameLen,
                                                        StringBuilder   szData,
                                                        int             iUserDataLen,
                                                        StringBuilder   szPath,
                                                        int             iPathLen,
                                                        byte []         pBytes,
                                                        long []         pDates);


        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int CookieAuthConstructTicket (byte []         pData,
                                                            int             iDataLen,
                                                            string          szName,
                                                            string          szData,
                                                            string          szPath,
                                                            byte []         pBytes,
                                                            long []         pDates);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern IntPtr CreateUserToken(string name, string password, int fImpersonationToken, StringBuilder strError, int iErrorSize);

#if DBG
        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Ansi, BestFitMapping=false)]
        internal /*public*/ static extern bool DBGNDAssert(string message, string stacktrace);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern bool DBGNDIsTagEnabled(string tag);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern bool DBGNDIsTagPresent(string tag);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern bool DBGNDTrace(string tag, string message);
#endif

        internal const uint FILE_NOTIFY_CHANGE_FILE_NAME    = 0x00000001;
        internal const uint FILE_NOTIFY_CHANGE_DIR_NAME     = 0x00000002;
        internal const uint FILE_NOTIFY_CHANGE_ATTRIBUTES   = 0x00000004;
        internal const uint FILE_NOTIFY_CHANGE_SIZE         = 0x00000008;
        internal const uint FILE_NOTIFY_CHANGE_LAST_WRITE   = 0x00000010;
        internal const uint FILE_NOTIFY_CHANGE_LAST_ACCESS  = 0x00000020;
        internal const uint FILE_NOTIFY_CHANGE_CREATION     = 0x00000040;
        internal const uint FILE_NOTIFY_CHANGE_SECURITY     = 0x00000100;

        internal const uint RDCW_FILTER_FILE_AND_DIR_CHANGES =
             FILE_NOTIFY_CHANGE_FILE_NAME |
             FILE_NOTIFY_CHANGE_DIR_NAME |
             FILE_NOTIFY_CHANGE_CREATION |
             FILE_NOTIFY_CHANGE_SIZE |
             FILE_NOTIFY_CHANGE_LAST_WRITE |
             FILE_NOTIFY_CHANGE_ATTRIBUTES |
             FILE_NOTIFY_CHANGE_SECURITY;


        internal const uint RDCW_FILTER_FILE_CHANGES =
             FILE_NOTIFY_CHANGE_FILE_NAME |
             FILE_NOTIFY_CHANGE_CREATION |
             FILE_NOTIFY_CHANGE_SIZE |
             FILE_NOTIFY_CHANGE_LAST_WRITE |
             FILE_NOTIFY_CHANGE_ATTRIBUTES |
             FILE_NOTIFY_CHANGE_SECURITY;

        internal const uint RDCW_FILTER_DIR_RENAMES = FILE_NOTIFY_CHANGE_DIR_NAME;

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern void DirMonClose(HandleRef dirMon);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int DirMonOpen(string dir, bool watchSubtree, uint notifyFilter, NativeFileChangeNotification callback, out IntPtr pCompletion);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int EcbGetBasics(IntPtr pECB, byte[] buffer, int size, int[] contentInfo);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int EcbGetBasicsContentInfo(IntPtr pECB, int[] contentInfo);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int EcbGetClientCertificate(IntPtr pECB, byte[] buffer, int size, int [] pInts, long [] pDates);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Ansi, BestFitMapping=false)]
        internal /*public*/ static extern int EcbGetServerVariable(IntPtr pECB, string name, byte[] buffer, int size);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Ansi, BestFitMapping=false)]
        internal /*public*/ static extern int EcbGetQueryString(IntPtr pECB, int encode, StringBuilder buffer, int size);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Ansi, BestFitMapping=false)]
        internal /*public*/ static extern int EcbGetUnicodeServerVariable(IntPtr pECB, string name, IntPtr buffer, int size);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int EcbGetVersion(IntPtr pECB);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int EcbGetQueryStringRawBytes(IntPtr pECB, byte[] buffer, int size);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int EcbGetPreloadedPostedContent(IntPtr pECB, byte[] bytes, int bufferSize);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int EcbGetAdditionalPostedContent(IntPtr pECB, byte[] bytes, int bufferSize);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int EcbWriteHeaders(IntPtr pECB, byte[] status, byte[] headers, int keepConnected);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int EcbWriteBytes(IntPtr pECB, IntPtr bytes, int size);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int EcbWriteBytesAsync(IntPtr pECB, IntPtr bufferAddress, int size, EcbAsyncIONotification callback, IntPtr context);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int EcbFlushCore(IntPtr    pECB,
                                              byte[]    status, 
                                              byte[]    header, 
                                              int       keepConnected,
                                              int       totalBodySize,
                                              int       numBodyFragments,
                                              IntPtr[]  bodyFragments,
                                              int[]     bodyFragmentLengths,
                                              int       doneWithSession,
                                              int       finalStatus,
                                              int       kernelCache,
                                              int       async,
                                              ISAPIAsyncCompletionCallback asyncCompletionCallback);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int EcbIsClientConnected(IntPtr pECB);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int EcbCloseConnection(IntPtr pECB);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Ansi, BestFitMapping=false)]
        internal /*public*/ static extern int EcbMapUrlToPath(IntPtr pECB, string url, byte[] buffer, int size);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode, BestFitMapping=false)]
        internal /*public*/ static extern int EcbMapUrlToPathUnicode(IntPtr pECB, String url, StringBuilder buffer, int size);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern IntPtr EcbGetImpersonationToken(IntPtr pECB, IntPtr processHandle);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern IntPtr EcbGetVirtualPathToken(IntPtr pECB, IntPtr processHandle);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Ansi, BestFitMapping=false)]
        internal /*public*/ static extern int EcbAppendLogParameter(IntPtr pECB, string logParam);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int EcbGetAllServerVarsCore(IntPtr pECB, byte[] buffer, int size);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal static extern void InvalidateKernelCache(string key);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern void FreeFileSecurityDescriptor(HandleRef hSecDesc);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern IntPtr GetFileSecurityDescriptor(string strFile);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int GetProcessMemoryInformation(uint pid, out uint privatePageCount, out uint peakPagefileUsage, int fNonBlocking);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal static extern int GetW3WPMemoryLimitInKB();
        
        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int SetGCLastCalledTime(out int pfCall) ;


        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern void SetClrThreadPoolLimits(int maxWorkerThreads, int maxIoThreads, bool setNowAndDontAdjustForCpuCount);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern void InitializeLibrary();

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern void InitializeHealthMonitor(int deadlockIntervalSeconds);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int IsAccessToFileAllowed(HandleRef hSecurityDesc, IntPtr iThreadToken, int iAccess);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern void UpdateLastActivityTimeForHealthMonitor();

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode, BestFitMapping=false)]
        internal /*public*/ static extern int GetCredentialFromRegistry(String strRegKey, StringBuilder buffer, int size);

        /////////////////////////////////////////////////////////////////////////////
        // List of functions supported by PMCallISAPI
        //
        // ATTENTION!!
        // If you change this list, make sure it is in sync with the
        // CallISAPIFunc enum in ecbdirect.h
        //
        internal enum CallISAPIFunc : int {
            GetSiteServerComment = 1,
            SetBinAccess = 2,
            CreateTempDir = 3,
            GetAutogenKeys = 4,
            GenerateToken  = 5
        };

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int EcbCallISAPI(IntPtr pECB, UnsafeNativeMethods.CallISAPIFunc iFunction, byte[] bufferIn, int sizeIn, byte[] bufferOut, int sizeOut);

        /////////////////////////////////////////////////////////////////////////////
        // Passport Auth
        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern  int PassportVersion();
        
        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int PassportCreateHttpRaw(
                string      szRequestLine, 
                string      szHeaders,
                int         fSecure,
                StringBuilder szBufOut,
                int         dwRetBufSize,
                ref IntPtr  passportManager);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int PassportContinueStartPageHTTPRaw(
                IntPtr      pManager,                                                                  
                byte []     postedData,
                int         iPostedDataLen,
                StringBuilder szBufOut,
                int         dwRetBufSize,
                byte []     bufContent,
                ref uint    iBufContentSize);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern  int    PassportTicket(
                IntPtr pManager,
                string     szAttr,
                out object  pReturn);
    
        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern  int    PassportGetCurrentConfig(
                IntPtr pManager,
                string     szAttr,
                out object   pReturn);
    

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern  int    PassportLogoutURL(
            IntPtr pManager,
            string     szReturnURL,
            string     szCOBrandArgs,
            int         iLangID,
            string     strDomain,
            int         iUseSecureAuth,
            StringBuilder      szAuthVal,
            int         iAuthValSize);
    
        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern  int       PassportGetOption(
            IntPtr pManager,
            string     szOption,
            out Object   vOut);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern  int    PassportSetOption(
            IntPtr pManager,
            string     szOption,
            Object     vOut);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern  int    PassportGetLoginChallenge(
                IntPtr pManager,
                string     szRetURL,
                int         iTimeWindow,
                int        fForceLogin,
                string     szCOBrandArgs,
                int         iLangID,
                string     strNameSpace,
                int         iKPP,
                int         iUseSecureAuth,
                object     vExtraParams,
                StringBuilder      szOut,
                int         iOutSize);
    
        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern  int    PassportHexPUID(
                IntPtr pManager,
                StringBuilder      szOut,
                int         iOutSize);
                                                      

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int PassportCreate     (string              szQueryStrT, 
                                                       string              szQueryStrP,
                                                       string              szAuthCookie,
                                                       string              szProfCookie,
                                                       string              szProfCCookie,
                                                       StringBuilder       szAuthCookieRet,
                                                       StringBuilder       szProfCookieRet,
                                                       int                 iRetBufSize,
                                                        ref IntPtr passportManager);


        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int PassportAuthURL (
                IntPtr              iPassport,
                string              szReturnURL,
                int                 iTimeWindow,
                int                 fForceLogin,
                string              szCOBrandArgs,
                int                 iLangID,
                string              strNameSpace,
                int                 iKPP,
                int                 iUseSecureAuth,
                StringBuilder       szAuthVal,
                int                 iAuthValSize);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int PassportAuthURL2 (
                IntPtr              iPassport,
                string              szReturnURL,
                int                 iTimeWindow,
                int                 fForceLogin,
                string              szCOBrandArgs,
                int                 iLangID,
                string              strNameSpace,
                int                 iKPP,
                int                 iUseSecureAuth,
                StringBuilder       szAuthVal,
                int                 iAuthValSize);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int   PassportCommit(
                IntPtr              iPassport,
                StringBuilder       szAuthVal,
                int                 iAuthValSize);


        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int   PassportGetError(IntPtr iPassport);


        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int   PassportDomainFromMemberName (
                IntPtr             iPassport,
                string             szDomain, 
                StringBuilder      szMember,
                int                iMemberSize);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int   PassportGetFromNetworkServer (IntPtr iPassport);


        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int   PassportGetDomainAttribute   (
                IntPtr        iPassport,
                string        szAttributeName,
                int           iLCID,    
                string        szDomain,
                StringBuilder szValue,
                int           iValueSize);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int   PassportHasProfile            (
                IntPtr      iPassport,
                string      szProfile);


        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int   PassportHasFlag            (
                IntPtr      iPassport,
                int         iFlagMask);


        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int   PassportHasConsent            (
                IntPtr      iPassport,
                int         iFullConsent,
                int         iNeedBirthdate);


        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int   PassportGetHasSavedPassword   (IntPtr      iPassport);


        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int   PassportHasTicket             (IntPtr      iPassport);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int   PassportIsAuthenticated       (
            IntPtr      iPassport,
            int         iTimeWindow,
            int         fForceLogin,
            int         iUseSecureAuth);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int   PassportLogoTag               (
                IntPtr        iPassport,
                string        szRetURL,
                int           iTimeWindow,
                int           fForceLogin,
                string        szCOBrandArgs,
                int           iLangID,
                int           fSecure,
                string        strNameSpace,
                int           iKPP,
                int           iUseSecureAuth,
                StringBuilder szValue,
                int           iValueSize);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int   PassportLogoTag2              (
                IntPtr        iPassport,
                string        szRetURL,
                int           iTimeWindow,
                int           fForceLogin,
                string        szCOBrandArgs,
                int           iLangID,
                int           fSecure,
                string        strNameSpace,
                int           iKPP,
                int           iUseSecureAuth,
                StringBuilder szValue,
                int           iValueSize);


        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int   PassportPutProfileString      (
                IntPtr     iPassport,
                string     szProfile,
                string     szValue);


        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int   PassportGetProfile            (
                IntPtr     iPassport,
                string     szProfile,
                out Object rOut);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int   PassportPutProfile(
                IntPtr     iPassport,
                string     szProfile,
                Object     oValue);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int   PassportGetTicketAge(IntPtr   iPassport);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int   PassportGetTimeSinceSignIn(IntPtr iPassport);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern void   PassportDestroy(IntPtr iPassport);    

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int   PassportCrypt(
                int            iFunctionID,
                string         szSrc,
                StringBuilder  szDest,
                int            iDestLength);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int   PassportCryptPut(
                int            iFunctionID,
                string         szSrc);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int   PassportCryptIsValid();

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int PostThreadPoolWorkItem(WorkItemCallback callback);

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern IntPtr InstrumentedMutexCreate(string name);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern void InstrumentedMutexDelete(HandleRef mutex);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int InstrumentedMutexGetLock(HandleRef mutex, int timeout);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int InstrumentedMutexReleaseLock(HandleRef mutex);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern void InstrumentedMutexSetState(HandleRef mutex, int state);


        /*
         * ASPNET_WP.EXE
         */

        [DllImport(ModName.WP_FULL_NAME, EntryPoint="PMGetHistoryTable")]
        internal /*public*/ static extern int PMGetHistoryTable (int       iRows,
                                                    int []   dwPIDArr, 
                                                    int []   dwReqExecuted, 
                                                    int []   dwReqPending, 
                                                    int []   dwReqExecuting, 
                                                    int []   dwReasonForDeath, 
                                                    int []   dwPeakMemoryUsed, 
                                                    long [] tmCreateTime,
                                                    long [] tmDeathTime);


        [DllImport(ModName.WP_FULL_NAME, EntryPoint="PMGetCurrentProcessInfo")]
        internal /*public*/ static extern int PMGetCurrentProcessInfo (ref int dwReqExecuted, 
                                                          ref int dwReqExecuting, 
                                                          ref int dwPeakMemoryUsed, 
                                                          ref long tmCreateTime, 
                                                          ref int pid);


        [DllImport(ModName.WP_FULL_NAME, EntryPoint="PMGetMemoryLimitInMB")]
        internal /*public*/ static extern int PMGetMemoryLimitInMB ();

        [DllImport(ModName.WP_FULL_NAME, EntryPoint="PMGetBasics")]
        internal /*public*/ static extern int PMGetBasics(IntPtr pMsg, byte[] buffer, int size, int[] contentInfo);

        [DllImport(ModName.WP_FULL_NAME)]
        internal /*public*/ static extern int PMGetClientCertificate(IntPtr pMsg, byte[] buffer, int size, int [] pInts, long [] pDates);

        [DllImport(ModName.WP_FULL_NAME)]
        internal /*public*/ static extern long PMGetStartTimeStamp(IntPtr pMsg);

        [DllImport(ModName.WP_FULL_NAME, EntryPoint="PMGetAllServerVariables")]
        internal /*public*/ static extern int PMGetAllServerVariables(IntPtr pMsg, byte[] buffer, int size);

        [DllImport(ModName.WP_FULL_NAME, EntryPoint="PMGetQueryString", CharSet=CharSet.Ansi, BestFitMapping=false)]
        internal /*public*/ static extern int PMGetQueryString(IntPtr pMsg, int encode, StringBuilder buffer, int size);

        [DllImport(ModName.WP_FULL_NAME, EntryPoint="PMGetQueryStringRawBytes")]
        internal /*public*/ static extern int PMGetQueryStringRawBytes(IntPtr pMsg, byte[] buffer, int size);

        [DllImport(ModName.WP_FULL_NAME, EntryPoint="PMGetPreloadedPostedContent")]
        internal /*public*/ static extern int PMGetPreloadedPostedContent(IntPtr pMsg, byte[] bytes, int bufferSize);

        [DllImport(ModName.WP_FULL_NAME, EntryPoint="PMGetAdditionalPostedContent")]
        internal /*public*/ static extern int PMGetAdditionalPostedContent(IntPtr pMsg, byte[] bytes, int bufferSize);

        [DllImport(ModName.WP_FULL_NAME, EntryPoint="PMEmptyResponse")]
        internal /*public*/ static extern int PMEmptyResponse(IntPtr pMsg);

        [DllImport(ModName.WP_FULL_NAME, EntryPoint="PMIsClientConnected")]
        internal /*public*/ static extern int PMIsClientConnected(IntPtr pMsg);

        [DllImport(ModName.WP_FULL_NAME, EntryPoint="PMCloseConnection")]
        internal /*public*/ static extern int PMCloseConnection(IntPtr pMsg);

        [DllImport(ModName.WP_FULL_NAME, EntryPoint="PMMapUrlToPath", CharSet=CharSet.Ansi, BestFitMapping=false)]
        internal /*public*/ static extern int PMMapUrlToPath(IntPtr pMsg, string url, byte[] buffer, int size);

        [DllImport(ModName.WP_FULL_NAME, EntryPoint="PMGetImpersonationToken")]
        internal /*public*/ static extern IntPtr PMGetImpersonationToken(IntPtr pMsg);

        [DllImport(ModName.WP_FULL_NAME, EntryPoint="PMGetVirtualPathToken")]
        internal /*public*/ static extern IntPtr PMGetVirtualPathToken(IntPtr pMsg);

        [DllImport(ModName.WP_FULL_NAME, EntryPoint="PMAppendLogParameter", CharSet=CharSet.Ansi, BestFitMapping=false)]
        internal /*public*/ static extern int PMAppendLogParameter(IntPtr pMsg, string logParam);

        [DllImport(ModName.WP_FULL_NAME, EntryPoint="PMFlushCore")]
        internal /*public*/ static extern int PMFlushCore(IntPtr  pMsg,
                                             byte[]     status, 
                                             byte[]     header, 
                                             int        keepConnected,
                                             int        totalBodySize,
                                             int        bodyFragmentsOffset,
                                             int        numBodyFragments,
                                             IntPtr[]   bodyFragments,
                                             int[]      bodyFragmentLengths,
                                             int        doneWithSession,
                                             int        finalStatus);

        [DllImport(ModName.WP_FULL_NAME)]
        internal /*public*/ static extern int PMCallISAPI(IntPtr pECB, UnsafeNativeMethods.CallISAPIFunc iFunction, byte[] bufferIn, int sizeIn, byte[] bufferOut, int sizeOut);

        // perf counters support

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern IntPtr PerfOpenGlobalCounters();

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern IntPtr PerfOpenAppCounters(string AppName);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern void PerfCloseAppCounters(IntPtr pCounters);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern void PerfIncrementCounter(IntPtr pCounters, int number);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern void PerfDecrementCounter(IntPtr pCounters, int number);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern void PerfIncrementCounterEx(IntPtr pCounters, int number, int increment);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern void PerfSetCounter(IntPtr pCounters, int number, int increment);

#if DBG
        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int PerfGetCounter(IntPtr pCounters, int number);
#endif

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Unicode)]
        internal /*public*/ static extern int SessionNDConnectToService(string server);

        [StructLayout(LayoutKind.Sequential)]
        internal struct SessionNDMakeRequestResults {
            internal IntPtr         socket;
            internal int            httpStatus;
            internal int            timeout;
            internal int            contentLength;
            internal IntPtr         content;    
            internal int            lockCookie;
            internal long           lockDate;
            internal int            lockAge;
        };


        internal enum StateProtocolVerb {
            GET = 1,
            PUT = 2,
            DELETE = 3,
            HEAD = 4,
        };

        internal enum StateProtocolExclusive {
            NONE = 0,
            ACQUIRE = 1,
            RELEASE = 2,
        };

        [DllImport(ModName.ISAPI_FULL_NAME, CharSet=CharSet.Ansi, BestFitMapping=false)]
        internal /*public*/ static extern int SessionNDMakeRequest(
                HandleRef               socket,    
                string                  server,
                int                     port,
                int                     networkTimeout,
                StateProtocolVerb       verb,      
                string                  uri,       
                StateProtocolExclusive  exclusive,
                int                     timeout,
                int                     lockCookie, 
                byte[]                  body,       
                int                     cb,         
                out SessionNDMakeRequestResults results);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern void SessionNDGetBody(HandleRef id, byte[] body, int cb);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern void SessionNDCloseConnection(HandleRef socket);

        [DllImport(ModName.ISAPI_FULL_NAME)]
        internal /*public*/ static extern int TransactManagedCallback(TransactedExecCallback callback, int mode);

        [DllImport(ModName.ISAPI_FULL_NAME, SetLastError=true)]
        internal /*public*/ static extern bool IsValidResource(IntPtr hModule, IntPtr ip, int size);


        /*
         * Fusion.dll
         */
        [DllImport(ModName.FUSION_FULL_NAME, CharSet=CharSet.Unicode)]
        internal static extern int GetCachePath(int dwCacheFlags, StringBuilder pwzCachePath, ref int pcchPath); 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\sources.inc ===
!include $(DNAROOT)\src\xsp\place.inc

TARGETNAME=System.Web
TARGETPATH=$(O)
TARGETTYPE=NOTARGET
COMPLUSTYPE=DLL

!if "$(ASPNET_PRODUCT)" == "redist"
SYNCHRONIZE_BLOCK=1
!endif

ALLOW_PARTIALTRUSTCALLS=1

CSHARP_ALLOW_UNSAFE=1

#COOLC_DEFINES=/define:DCR91814
#COOLC_DEFINES=/define:DAVIDEBB_TEST

COMPLUSIMPORTS=$(URTTARGET)\System.dll                          \
               $(URTTARGET)\System.Drawing.dll                  \
               $(URTTARGET)\System.Data.dll                     \
               $(URTTARGET)\System.EnterpriseServices.dll       \
               $(URTTARGET)\System.Xml.dll                      \
               $(URTTARGET)\$(ALT_PROJECT_TARGET)\System.Web.RegularExpressions.dll   \


CLIENTFILES=                                                    \
        $(TARGETPATH)\WebUIValidation.js                        \
        $(TARGETPATH)\SmartNav.js                               \
        $(TARGETPATH)\SmartNav.htm                              \
        $(TARGETPATH)\SmartNavIE5.js                            \

CONFIGFILE=$(TARGETPATH)\aspnet.config                          \
        ..\aspnet.config.rtm

NTTARGETFILES=$(CONFIGFILE)

MISCFILES=                                                      \
        ..\State\InstallSqlState.sql                            \
        ..\State\UninstallSqlState.sql                          \
        ..\State\InstallPersistSqlState.sql                     \
        ..\State\UninstallPersistSqlState.sql                   \
        ..\misc\env.aspx                                        \
        $(CONFIGFILE)                                           \
        $(CLIENTFILES)

SOURCES=..\$(TARGETNAME).rc

SECURITY_LEVEL=SYSTEM_COMPONENT

RESGEN_SOURCE=..\$(TARGETNAME).txt      
RESGEN_CLASS=System.Web.SR

PUBLISH_SOURCES=1

CSHARP_SOURCES=                                                      \
        $(XSPBASEDIR)\inc\$(ASPNET_PRODUCT)\$(O)\PerfCounterEnum.cs  \
        $(O)\Names.cs                                                \
        ..\NativeMethods.cs                                          \
        ..\UnsafeNativeMethods.cs                                    \
        ..\SafeNativeMethods.cs                                      \
        ..\BufferAllocator.cs                                        \
        ..\CrossSiteScriptingValidation.cs                           \
        ..\CustomErrors.cs                                           \
        ..\ErrorFormatter.cs                                         \
        ..\FileChangesMonitor.cs                                     \
        ..\HttpApplication.cs                                        \
        ..\HttpApplicationFactory.cs                                 \
        ..\HttpApplicationState.cs                                   \
        ..\HttpAsyncResult.cs                                        \
        ..\HttpBrowserCapabilities.cs                                \
        ..\HttpCacheParams.cs                                        \
        ..\HttpCachePolicy.cs                                        \
        ..\HttpCacheVary.cs                                          \
        ..\HttpClientCertificate.cs                                  \
        ..\HttpContext.cs                                            \
        ..\HttpCookie.cs                                             \
        ..\HttpCookieCollection.cs                                   \
        ..\HttpDebugHandler.cs                                       \
        ..\HttpDictionary.cs                                         \
        ..\HttpException.cs                                          \
        ..\HttpFileCollection.cs                                     \
        ..\HttpInputStream.cs                                        \
        ..\HttpModuleCollection.cs                                   \
        ..\HttpNotFoundHandler.cs                                    \
        ..\HttpPostedFile.cs                                         \
        ..\HttpRawResponse.cs                                        \
        ..\HttpRequest.cs                                            \
        ..\HttpResponse.cs                                           \
        ..\HttpResponseHeader.cs                                     \
        ..\HttpRuntime.cs                                            \
        ..\HttpStaticObjectsCollection.cs                            \
        ..\HttpServerUtility.cs                                      \
        ..\HttpServerVarsCollection.cs                               \
        ..\HttpValueCollection.cs                                    \
        ..\HttpWriter.cs                                             \
        ..\IHttpAsyncHandler.cs                                      \
        ..\IHttpHandler.cs                                           \
        ..\IHttpHandlerFactory.cs                                    \
        ..\IHttpMapPath.cs                                           \
        ..\IHttpModule.cs                                            \
        ..\IntSecurity.cs                                            \
        ..\MimeMapping.cs                                            \
        ..\MultipartContentParser.cs                                 \
        ..\OutputCacheModule.cs                                      \
        ..\PerfCounters.cs                                           \
        ..\ProcessInfo.cs                                            \
        ..\ProcessModelInfo.cs                                       \
        ..\RequestQueue.cs                                           \
        ..\RequestTimeoutManager.cs                                  \
##        ..\RewriteLine.cs                                          \
##        ..\RewriteModule.cs                                        \
##        ..\RewriteRule.cs                                          \
##        ..\RewriteRuleParser.cs                                    \
##        ..\RewriteState.cs                                         \
##        ..\RewriteStep.cs                                          \
        ..\StaticFileHandler.cs                                      \
        ..\StringResourceManager.cs                                  \
        ..\WebCategoryAttribute.cs                                   \
        ..\WebSysDescriptionAttribute.cs                             \
        ..\WorkerRequest.cs                                          \
                                                                     \
        ..\Cache\Cache.cs                                            \
        ..\Cache\CacheDependency.cs                                  \
        ..\Cache\CacheEntry.cs                                       \
        ..\Cache\CacheExpires.cs                                     \
        ..\Cache\CacheMemory.cs                                      \
        ..\Cache\CacheUsage.cs                                       \
                                                                     \
        ..\Configuration\AuthenticationConfig.cs                     \
        ..\Configuration\AuthorizationConfig.cs                      \
        ..\Configuration\ClientTargetSectionHandler.cs               \
        ..\Configuration\ContextlessMapPath.cs                       \
        ..\Configuration\GlobalizationConfigurationHandler.cs        \
        ..\Configuration\HandlerBase.cs                              \
        ..\Configuration\HandlerFactoryCache.cs                      \
        ..\Configuration\HandlerFactoryWrapper.cs                    \
        ..\Configuration\HandlerMap.cs                               \
        ..\Configuration\HandlerMapping.cs                           \
        ..\Configuration\HandlerMappingMemo.cs                       \
        ..\Configuration\HandlerWithFactory.cs                       \
        ..\Configuration\HttpCapabilitiesBase.cs                     \
        ..\Configuration\HttpCapabilitiesEvaluator.cs                \
        ..\Configuration\HttpCapabilitiesSectionHandler.cs           \
        ..\Configuration\HttpConfigurationContext.cs                 \
        ..\Configuration\HttpConfigurationRecord.cs                  \
        ..\Configuration\HttpConfigurationSystem.cs                  \
        ..\Configuration\HttpConfigurationSystemBase.cs              \
        ..\Configuration\HttpHandlersSectionHandler.cs               \
        ..\Configuration\HttpModulesConfiguration.cs                 \
        ..\Configuration\HttpModulesConfigurationHandler.cs          \
        ..\Configuration\HttpRuntimeConfigurationHandler.cs          \
        ..\Configuration\IdentityConfig.cs                           \
        ..\Configuration\MachineKeyConfig.cs                         \
        ..\Configuration\ModulesEntry.cs                             \
        ..\Configuration\ProcessModelConfigurationHandler.cs         \
        ..\Configuration\SectionRecord.cs                            \
        ..\Configuration\SecurityPolicyConfig.cs                     \
        ..\Configuration\TraceConfigurationHandler.cs                \
        ..\Configuration\WebControlsSectionHandler.cs                \
                                                                     \
        ..\Hosting\AppDomainFactory.cs                               \
        ..\Hosting\ApplicationHost.cs                                \
        ..\Hosting\ISAPIRuntime.cs                                   \
        ..\Hosting\ISAPIWorkerRequest.cs                             \
        ..\Hosting\SimpleWorkerRequest.cs                            \
                                                                     \
        ..\Handlers\BatchHandler.cs                                  \
        ..\Handlers\TraceHandler.cs                                  \
        ..\Handlers\TraceHandlerErrorFormatter.cs                    \
                                                                     \
        ..\Security\BackStopAuthenticationModule.cs                  \
        ..\Security\CodeAccessSecurityHandler.cs                     \
        ..\Security\FileAuthorizationModule.cs                       \
        ..\Security\FormsAuthenticationEventArgs.cs                  \
        ..\Security\FormsAuthenticationEventHandler.cs               \
        ..\Security\FormsAuthenticationModule.cs                     \
        ..\Security\FormsAuthentication.cs                           \
        ..\Security\FormsAuthenticationTicket.cs                     \
        ..\Security\FormsIdentity.cs                                 \
        ..\Security\GenericAuthenticationEventArgs.cs                \
        ..\Security\GenericAuthenticationEventHandler.cs             \
        ..\Security\PassportAuthenticationModule.cs                  \
        ..\Security\PassportAuthenticationEventArgs.cs               \
        ..\Security\PassportAuthenticationEventHandler.cs            \
        ..\Security\PassportIdentity.cs                              \
        ..\Security\UrlAuthorizationModule.cs                        \
        ..\Security\WindowsAuthenticationEventArgs.cs                \
        ..\Security\WindowsAuthenticationEventHandler.cs             \
        ..\Security\WindowsAuthenticationModule.cs                   \
                                                                     \
        ..\State\InProcStateClientManager.cs                         \
        ..\State\IReadOnlySessionState.cs                            \
        ..\State\IRequiresSessionState.cs                            \
        ..\State\OutOfProcStateClientManager.cs                      \
        ..\State\SessionDictionary.cs                                \
        ..\State\SessionState.cs                                     \
        ..\State\SessionStateModule.cs                               \
        ..\State\SqlStateClientManager.cs                            \
        ..\State\StateClientManager.cs                               \
        ..\State\StateRuntime.cs                                     \
        ..\State\StateWorkerRequest.cs                               \
                                                                     \
        ..\UI\ApplicationFileParser.cs                               \
        ..\UI\AttributeCollection.cs                                 \
        ..\UI\BaseParser.cs                                          \
        ..\UI\BatchParser.cs                                         \
        ..\UI\CodeBlockBuilder.cs                                    \
        ..\UI\CollectionBuilder.cs                                   \
        ..\UI\CompilationConfiguration.cs                            \
        ..\UI\Control.cs                                             \
        ..\UI\ControlBuilder.cs                                      \
        ..\UI\ControlBuilderAttribute.cs                             \
        ..\UI\ControlCollection.cs                                   \
        ..\UI\ControlState.cs                                        \
        ..\UI\CssStyleCollection.cs                                  \
        ..\UI\DataBinder.cs                                          \
        ..\UI\DataBinding.cs                                         \
        ..\UI\DataBindingCollection.cs                               \
        ..\UI\DataBindingHandlerAttribute.cs                         \
        ..\UI\DataBoundLiteralControl.cs                             \
        ..\UI\DataSourceHelper.cs                                    \
        ..\UI\DesignTimeParseData.cs                                 \
        ..\UI\DesignTimeTemplateParser.cs                            \
        ..\UI\ConstructorNeedsTagAttribute.cs                        \
        ..\UI\EmptyControlCollection.cs                              \
        ..\UI\HtmlControlPersistable.cs                              \
        ..\UI\HtmlForm.cs                                            \
        ..\UI\HTMLTagNameToTypeMapper.cs                             \
        ..\UI\TagPrefixAttribute.cs                                  \
        ..\UI\HTMLTextWriter.cs                                      \
        ..\UI\HTMLTextWriterTag.cs                                   \
        ..\UI\HTMLTextWriterAttribute.cs                             \
        ..\UI\HTMLTextWriterStyle.cs                                 \
        ..\UI\Html32TextWriter.cs                                    \
        ..\UI\IAttributeAccessor.cs                                  \
        ..\UI\IDataBindingsAccessor.cs                               \
        ..\UI\ImageClickEventArgs.cs                                 \
        ..\UI\ImageClickEventHandler.cs                              \
        ..\UI\INamingContainer.cs                                    \
        ..\UI\IParserAccessor.cs                                     \
        ..\UI\IPostBackDataHandler.cs                                \
        ..\UI\IPostBackEventHandler.cs                               \
        ..\UI\IStateManager.cs                                       \
        ..\UI\ITemplate.cs                                           \
        ..\UI\IUserControlDesignerAccessor.cs                        \
        ..\UI\IValidator.cs                                          \
        ..\UI\LiteralControl.cs                                      \
        ..\UI\LOSFormatter.cs                                        \
        ..\UI\LosWriter.cs                                        \
        ..\UI\ObjectConverter.cs                                     \
        ..\UI\ObjectTag.cs                                           \
        ..\UI\Page.cs                                                \
        ..\UI\PageParser.cs                                          \
        ..\UI\PageHandlerFactory.cs                                  \
        ..\UI\PagesConfiguration.cs                                  \
        ..\UI\PartialCachingAttribute.cs                             \
        ..\UI\PartialCachingControl.cs                               \
        ..\UI\ParseChildrenAsPropertiesAttribute.cs                  \
        ..\UI\PersistChildrenAttribute.cs                            \
        ..\UI\PersistenceMode.cs                                     \
        ..\UI\PersistenceTypeAttribute.cs                            \
        ..\UI\PropertyConverter.cs                                   \
        ..\UI\PropertyMapper.cs                                      \
        ..\UI\PropertySetter.cs                                      \
        ..\UI\RootBuilder.cs                                         \
        ..\UI\SimpleHandlerFactory.cs                                \
        ..\UI\SimpleWebHandlerParser.cs                              \
        ..\UI\StateBag.cs                                            \
        ..\UI\StateItem.cs                                           \
        ..\UI\TagNameToTypeMapper.cs                                 \
        ..\UI\TemplateBuilder.cs                                     \
        ..\UI\TemplateControl.cs                                     \
        ..\UI\TemplateControlParser.cs                               \
        ..\UI\TemplateParser.cs                                      \
        ..\UI\ToolboxDataAttribute.cs                                \
        ..\UI\TraceContext.cs                                        \
        ..\UI\TraceModeEnum.cs                                       \
        ..\UI\TrivialPage.cs                                         \
        ..\UI\UserControl.cs                                         \
        ..\UI\UserControlParser.cs                                   \
        ..\UI\Util.cs                                                \
        ..\UI\ValidationPropertyAttribute.cs                         \
        ..\UI\ValidatorCollection.cs                                 \
                                                                     \
        ..\Compilation\ApplicationFileCompiler.cs                    \
        ..\Compilation\BaseCompiler.cs                               \
        ..\Compilation\BatchDOMCompilation.cs                        \
        ..\Compilation\CodeDOMUtility.cs                             \
        ..\Compilation\CompilationLock.cs                            \
        ..\Compilation\PageCompiler.cs                               \
        ..\Compilation\PreservedAssemblyEntry.cs                     \
        ..\Compilation\SourceCompiler.cs                             \
        ..\Compilation\TemplateControlCompiler.cs                    \
        ..\Compilation\UserControlCompiler.cs                        \
                                                                     \
        ..\UI\HtmlControls\HtmlAnchor.cs                             \
        ..\UI\HtmlControls\HtmlButton.cs                             \
        ..\UI\HtmlControls\HtmlContainerControl.cs                   \
        ..\UI\HtmlControls\HtmlControl.cs                            \
        ..\UI\HtmlControls\HtmlGenericControl.cs                     \
        ..\UI\HtmlControls\HtmlImage.cs                              \
        ..\UI\HtmlControls\HtmlInputButton.cs                        \
        ..\UI\HtmlControls\HtmlInputCheckBox.cs                      \
        ..\UI\HtmlControls\HtmlInputControl.cs                       \
        ..\UI\HtmlControls\HtmlInputFile.cs                          \
        ..\UI\HtmlControls\HtmlInputHidden.cs                        \
        ..\UI\HtmlControls\HtmlInputImage.cs                         \
        ..\UI\HtmlControls\HtmlInputRadioButton.cs                   \
        ..\UI\HtmlControls\HtmlInputText.cs                          \
        ..\UI\HtmlControls\HtmlSelect.cs                             \
        ..\UI\HtmlControls\HtmlTable.cs                              \
        ..\UI\HtmlControls\HtmlTableCell.cs                          \
        ..\UI\HtmlControls\HtmlTableCellCollection.cs                \
        ..\UI\HtmlControls\HtmlTableRow.cs                           \
        ..\UI\HtmlControls\HtmlTableRowCollection.cs                 \
        ..\UI\HtmlControls\HtmlTextArea.cs                           \
                                                                     \
        ..\UI\WebControls\AdCreatedEventArgs.cs                      \
        ..\UI\WebControls\AdCreatedEventHandler.cs                   \
        ..\UI\WebControls\AdRotator.cs                               \
        ..\UI\WebControls\AssemblyAttributes.cs                      \
        ..\UI\WebControls\BaseCompareValidator.cs                    \
        ..\UI\WebControls\BaseDataList.cs                            \
        ..\UI\WebControls\BaseValidator.cs                           \
        ..\UI\WebControls\BorderStyle.cs                             \
        ..\UI\WebControls\BoundColumn.cs                             \
        ..\UI\WebControls\Button.cs                                  \
        ..\UI\WebControls\ButtonColumn.cs                            \
        ..\UI\WebControls\ButtonColumnType.cs                        \
        ..\UI\WebControls\Calendar.cs                                \
        ..\UI\WebControls\CalendarDay.cs                             \
        ..\UI\WebControls\CalendarSelectionMode.cs                   \
        ..\UI\WebControls\CheckBox.cs                                \
        ..\UI\WebControls\CheckBoxList.cs                            \
        ..\UI\WebControls\Column.cs                                  \
        ..\UI\WebControls\ColumnCollection.cs                        \
        ..\UI\WebControls\CommandEventArgs.cs                        \
        ..\UI\WebControls\CommandEventHandler.cs                     \
        ..\UI\WebControls\CompareValidator.cs                        \
        ..\UI\WebControls\CustomValidator.cs                         \
        ..\UI\WebControls\DataGrid.cs                                \
        ..\UI\WebControls\DataGridCommandEventArgs.cs                \
        ..\UI\WebControls\DataGridCommandEventHandler.cs             \
        ..\UI\WebControls\DataGridItem.cs                            \
        ..\UI\WebControls\DataGridItemCollection.cs                  \
        ..\UI\WebControls\DataGridItemEventArgs.cs                   \
        ..\UI\WebControls\DataGridItemEventHandler.cs                \
        ..\UI\WebControls\DataGridLinkButton.cs                      \
        ..\UI\WebControls\DataGridPageChangedEventArgs.cs            \
        ..\UI\WebControls\DataGridPageChangedEventHandler.cs         \
        ..\UI\WebControls\DataGridPagerStyle.cs                      \
        ..\UI\WebControls\DataGridSortCommandEventArgs.cs            \
        ..\UI\WebControls\DataGridSortCommandEventHandler.cs         \
        ..\UI\WebControls\DataGridTable.cs                           \
        ..\UI\WebControls\DataKeyCollection.cs                       \
        ..\UI\WebControls\DataList.cs                                \
        ..\UI\WebControls\DataListCommandEventArgs.cs                \
        ..\UI\WebControls\DataListCommandEventHandler.cs             \
        ..\UI\WebControls\DataListItem.cs                            \
        ..\UI\WebControls\DataListItemCollection.cs                  \
        ..\UI\WebControls\DataListItemEventArgs.cs                   \
        ..\UI\WebControls\DataListItemEventHandler.cs                \
        ..\UI\WebControls\DayRenderEvent.cs                          \
        ..\UI\WebControls\DayRenderEventHandler.cs                   \
        ..\UI\WebControls\DayNameFormat.cs                           \
        ..\UI\WebControls\DropDownList.cs                            \
        ..\UI\WebControls\DummyDataSource.cs                         \
        ..\UI\WebControls\EditCommandColumn.cs                       \
        ..\UI\WebControls\FirstDayOfWeek.cs                          \
        ..\UI\WebControls\FontNamesConverter.cs                      \
        ..\UI\WebControls\FontInfo.cs                                \
        ..\UI\WebControls\FontSize.cs                                \
        ..\UI\WebControls\FontUnit.cs                                \
        ..\UI\WebControls\FontUnitConverter.cs                       \
        ..\UI\WebControls\GridLines.cs                               \
        ..\UI\WebControls\HorizontalAlign.cs                         \
        ..\UI\WebControls\HorizontalAlignConverter.cs                \
        ..\UI\WebControls\HyperLink.cs                               \
        ..\UI\WebControls\HyperLinkColumn.cs                         \
        ..\UI\WebControls\Image.cs                                   \
        ..\UI\WebControls\ImageAlign.cs                              \
        ..\UI\WebControls\ImageButton.cs                             \
        ..\UI\WebControls\IRepeatInfoUser.cs                         \
        ..\UI\WebControls\Label.cs                                   \
        ..\UI\WebControls\LinkButton.cs                              \
        ..\UI\WebControls\Listbox.cs                                 \
        ..\UI\WebControls\ListControl.cs                             \
        ..\UI\WebControls\ListItem.cs                                \
        ..\UI\WebControls\ListItemCollection.cs                      \
        ..\UI\WebControls\ListItemType.cs                            \
        ..\UI\WebControls\ListSelectionMode.cs                       \
        ..\UI\WebControls\Literal.cs                                 \
        ..\UI\WebControls\MonthChangedEventArgs.cs                   \
        ..\UI\WebControls\MonthChangedEventHandler.cs                \
        ..\UI\WebControls\NextPrevFormat.cs                          \
        ..\UI\WebControls\PagedDataSource.cs                         \
        ..\UI\WebControls\PagerMode.cs                               \
        ..\UI\WebControls\PagerPosition.cs                           \
        ..\UI\WebControls\Panel.cs                                   \
        ..\UI\WebControls\PlaceHolder.cs                             \
        ..\UI\WebControls\RadioButton.cs                             \
        ..\UI\WebControls\RadioButtonList.cs                         \
        ..\UI\WebControls\RangeValidator.cs                          \
        ..\UI\WebControls\RegularExpressionValidator.cs              \
        ..\UI\WebControls\RepeatDirection.cs                         \
        ..\UI\WebControls\Repeater.cs                                \
        ..\UI\WebControls\RepeaterCommandEventArgs.cs                \
        ..\UI\WebControls\RepeaterCommandEventHandler.cs             \
        ..\UI\WebControls\RepeaterItem.cs                            \
        ..\UI\WebControls\RepeaterItemCollection.cs                  \
        ..\UI\WebControls\RepeaterItemEventArgs.cs                   \
        ..\UI\WebControls\RepeaterItemEventHandler.cs                \
        ..\UI\WebControls\RepeatInfo.cs                              \
        ..\UI\WebControls\RepeatLayout.cs                            \
        ..\UI\WebControls\RequiredFieldValidator.cs                  \
        ..\UI\WebControls\SelectedDatesCollection.cs                 \
        ..\UI\WebControls\ServerValidateEventArgs.cs                 \
        ..\UI\WebControls\ServerValidateEventHandler.cs              \
        ..\UI\WebControls\Style.cs                                   \
        ..\UI\WebControls\Table.cs                                   \
        ..\UI\WebControls\TableCell.cs                               \
        ..\UI\WebControls\TableCellCollection.cs                     \
        ..\UI\WebControls\TableHeaderCell.cs                         \
        ..\UI\WebControls\TableItemStyle.cs                          \
        ..\UI\WebControls\TableRow.cs                                \
        ..\UI\WebControls\TableRowCollection.cs                      \
        ..\UI\WebControls\TableStyle.cs                              \
        ..\UI\WebControls\TargetConverter.cs                         \
        ..\UI\WebControls\TemplateColumn.cs                          \
        ..\UI\WebControls\TextAlign.cs                               \
        ..\UI\WebControls\TextBox.cs                                 \
        ..\UI\WebControls\TextBoxMode.cs                             \
        ..\UI\WebControls\TitleFormat.cs                             \
        ..\UI\WebControls\Unit.cs                                    \
        ..\UI\WebControls\UnitConverter.cs                           \
        ..\UI\WebControls\UnitType.cs                                \
        ..\UI\WebControls\ValidatedControlConverter.cs               \
        ..\UI\WebControls\ValidationCompareOperator.cs               \
        ..\UI\WebControls\ValidationDataType.cs                      \
        ..\UI\WebControls\ValidationSummary.cs                       \
        ..\UI\WebControls\ValidationSummaryDisplayMode.cs            \
        ..\UI\WebControls\ValidatorDisplay.cs                        \
        ..\UI\WebControls\VerticalAlign.cs                           \
        ..\UI\WebControls\VerticalAlignConverter.cs                  \
        ..\UI\WebControls\WebColorConverter.cs                       \
        ..\UI\WebControls\WebControl.cs                              \
        ..\UI\WebControls\Xml.cs                                     \
                                                                     \
        ..\Util\AltSerialization.cs                                  \
        ..\Util\ArglessEventHandlerProxy.cs                          \
        ..\Util\AspCompat.cs                                         \
        ..\Util\CodePageUtils.cs                                     \
        ..\Util\Counter.cs                                           \
        ..\Util\DateTimeUtil.cs                                      \
        ..\Util\Debug.cs                                             \
        ..\Util\DoubleLink.cs                                        \
        ..\Util\DoubleLinkList.cs                                    \
        ..\Util\DoubleLinkListEnumerator.cs                          \
        ..\Util\hresults.cs                                          \
        ..\Util\Msec.cs                                              \
        ..\Util\ParseHttpDate.cs                                     \
        ..\Util\Profiler.cs                                          \
        ..\Util\ReadWriteObjectLock.cs                               \
        ..\Util\ReadWriteSpinLock.cs                                 \
        ..\Util\ResourcePool.cs                                      \
        ..\Util\Sec.cs                                               \
        ..\Util\SmtpMail.cs                                          \
        ..\Util\SortedDoubleLinkList.cs                              \
        ..\Util\SymbolEqualComparer.cs                               \
        ..\Util\SymbolHashCodeProvider.cs                            \
        ..\Util\SimpleBitVector32.cs                                 \
        ..\Util\SystemInfo.cs                                        \
        ..\Util\Transactions.cs                                      \
        ..\Util\UrlPath.cs                                           \
        ..\Util\VersionInfo.cs                                       \
        ..\Util\Wildcard.cs                                          \
        ..\Util\WorkItem.cs                                          \
        $(DNAROOT)\src\misc\InvariantComparer.cs                     \


RESOURCE_FILES=..\Resources\System\Web\UI\WebControls\AdRotator.bmp,System.Web.UI.WebControls.AdRotator.bmp                                    \
               ..\Resources\System\Web\UI\WebControls\Button.bmp,System.Web.UI.WebControls.Button.bmp                                          \
               ..\Resources\System\Web\UI\WebControls\Calendar.bmp,System.Web.UI.WebControls.Calendar.bmp                                      \
               ..\Resources\System\Web\UI\WebControls\CheckBox.bmp,System.Web.UI.WebControls.CheckBox.bmp                                      \
               ..\Resources\System\Web\UI\WebControls\CheckBoxList.bmp,System.Web.UI.WebControls.CheckBoxList.bmp                              \
               ..\Resources\System\Web\UI\WebControls\CompareValidator.bmp,System.Web.UI.WebControls.CompareValidator.bmp                      \
               ..\Resources\System\Web\UI\WebControls\CustomValidator.bmp,System.Web.UI.WebControls.CustomValidator.bmp                        \
               ..\Resources\System\Web\UI\WebControls\DataGrid.bmp,System.Web.UI.WebControls.DataGrid.bmp                                      \
               ..\Resources\System\Web\UI\WebControls\DataList.bmp,System.Web.UI.WebControls.DataList.bmp                                      \
               ..\Resources\System\Web\UI\WebControls\DropDownList.bmp,System.Web.UI.WebControls.DropDownList.bmp                              \
               ..\Resources\System\Web\UI\WebControls\HyperLink.bmp,System.Web.UI.WebControls.HyperLink.bmp                                    \
               ..\Resources\System\Web\UI\WebControls\Image.bmp,System.Web.UI.WebControls.Image.bmp                                            \
               ..\Resources\System\Web\UI\WebControls\ImageButton.bmp,System.Web.UI.WebControls.ImageButton.bmp                                \
               ..\Resources\System\Web\UI\WebControls\Label.bmp,System.Web.UI.WebControls.Label.bmp                                            \
               ..\Resources\System\Web\UI\WebControls\LinkButton.bmp,System.Web.UI.WebControls.LinkButton.bmp                                  \
               ..\Resources\System\Web\UI\WebControls\ListBox.bmp,System.Web.UI.WebControls.ListBox.bmp                                        \
               ..\Resources\System\Web\UI\WebControls\Literal.bmp,System.Web.UI.WebControls.Literal.bmp                                        \
               ..\Resources\System\Web\UI\WebControls\PlaceHolder.bmp,System.Web.UI.WebControls.PlaceHolder.bmp                                \
               ..\Resources\System\Web\UI\WebControls\Panel.bmp,System.Web.UI.WebControls.Panel.bmp                                            \
               ..\Resources\System\Web\UI\WebControls\RadioButton.bmp,System.Web.UI.WebControls.RadioButton.bmp                                \
               ..\Resources\System\Web\UI\WebControls\RadioButtonList.bmp,System.Web.UI.WebControls.RadioButtonList.bmp                        \
               ..\Resources\System\Web\UI\WebControls\RangeValidator.bmp,System.Web.UI.WebControls.RangeValidator.bmp                          \
               ..\Resources\System\Web\UI\WebControls\Repeater.bmp,System.Web.UI.WebControls.Repeater.bmp                                      \
               ..\Resources\System\Web\UI\WebControls\RegularExpressionValidator.bmp,System.Web.UI.WebControls.RegularExpressionValidator.bmp  \
               ..\Resources\System\Web\UI\WebControls\RequiredFieldValidator.bmp,System.Web.UI.WebControls.RequiredFieldValidator.bmp          \
               ..\Resources\System\Web\UI\WebControls\Table.bmp,System.Web.UI.WebControls.Table.bmp                                            \
               ..\Resources\System\Web\UI\WebControls\TextBox.bmp,System.Web.UI.WebControls.TextBox.bmp                                        \
               ..\Resources\System\Web\UI\WebControls\ValidationSummary.bmp,System.Web.UI.WebControls.ValidationSummary.bmp                    \
               ..\Resources\System\Web\UI\WebControls\Xml.bmp,System.Web.UI.WebControls.Xml.bmp                                                \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\staticfilehandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="StaticFileHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Static File Handler
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web {
    using System;
    using System.Text;
    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.IO;
    using Microsoft.Win32;
    using System.Collections;
    using System.Web.Util;    
    using System.Globalization;
    
    internal class HttpStatus {
        internal const int Unauthorized            =   401;
        internal const int Forbidden               =   403;
        internal const int NotFound                =   404;

        internal HttpStatus() {}
    }

    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////

    internal class StaticFileHandler : IHttpHandler {
        private const int   DEFAULT_CACHE_THRESHOLD = 256*1024;
        private const int   ERROR_ACCESS_DENIED     = 5;

        internal StaticFileHandler() {
        }
        
        private void CacheValidateHandler(
                                         HttpContext context,
                                         Object data,
                                         ref HttpValidationStatus validationStatus ) {
            if ( context.Request.Headers[ "Range" ] != null ||
                 context.Request.RequestType.Equals( "(GETSOURCE)" ) ||
                 context.Request.RequestType.Equals( "(HEADSOURCE)" ) ) {
                validationStatus = HttpValidationStatus.IgnoreThisRequest;
            }
        }


        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        public void ProcessRequest( HttpContext context ) {
            FileInfo                file;
            HttpRequest         request = context.Request;
            HttpResponse        response = context.Response;
            string              FileName = request.PhysicalPath;

            Util.Debug.Trace( "GET", "Path = " + request.Path );        
            Util.Debug.Trace( "GET", "File Name = " + FileName );

            //
            // Check whether the file exists
            //

            if ( !FileUtil.FileExists( FileName )) {
                throw new HttpException( HttpStatus.NotFound, 
                                         HttpRuntime.FormatResourceString(SR.File_does_not_exist) );
            }

            try {
                file  = new FileInfo( FileName );
            }
            catch ( IOException ioEx) {
                if (!HttpRuntime.HasFilePermission(FileName))
                    throw new HttpException( HttpStatus.NotFound, 
                                             HttpRuntime.FormatResourceString(SR.Error_trying_to_enumerate_files));
                else
                    throw new HttpException( HttpStatus.NotFound, 
                                             HttpRuntime.FormatResourceString(SR.Error_trying_to_enumerate_files), 
                                             ioEx );
            }
            catch ( SecurityException  secEx) {
                if (!HttpRuntime.HasFilePermission(FileName))
                    throw new HttpException( HttpStatus.Unauthorized,
                                             HttpRuntime.FormatResourceString(SR.File_enumerator_access_denied));
                else
                    throw new HttpException( HttpStatus.Unauthorized,
                                             HttpRuntime.FormatResourceString(SR.File_enumerator_access_denied),
                                             secEx );
            }

            //
            // To be consistent with IIS, we won't serve out hidden files
            //

            if ( ( ((int) file.Attributes) & ((int) FileAttributes.Hidden) ) != 0 ) {
                throw new HttpException( HttpStatus.NotFound,
                                         HttpRuntime.FormatResourceString(SR.File_is_hidden) );
            }

            //
            // To prevent the trailing dot problem, error out all file names with trailing dot.
            //

            if ( FileName[ FileName.Length - 1 ] == '.' ) {
                throw new HttpException( HttpStatus.NotFound,
                                         HttpRuntime.FormatResourceString(SR.File_does_not_exist) );
            }

            //
            // If the file is a directory, then it must not have a slash in
            // end of it (if it does have a slash suffix, then the config file
            // mappings are missing and we will just return 403.  Otherwise, 
            // we will redirect the client to the URL with this slash.
            //

            if ( ( ((int) file.Attributes) & ((int)FileAttributes.Directory) ) != 0 ) {
                if ( request.Path.EndsWith( "/" ) ) {
                    // 
                    // Just return 403
                    //               

                    throw new HttpException( HttpStatus.Forbidden,
                                             HttpRuntime.FormatResourceString(SR.Missing_star_mapping) );
                }
                else {
                    //
                    // Redirect to a slash suffixed URL which will be 
                    // handled by the */ handler mapper
                    //
                    response.Redirect( request.Path + "/" );
                }
            }
            else {
                DateTime                lastModified;
                string                  strETag;

                //
                // Determine Last Modified Time.  We might need it soon 
                // if we encounter a Range: and If-Range header
                //

                lastModified =   new DateTime( file.LastWriteTime.Year,
                                               file.LastWriteTime.Month,
                                               file.LastWriteTime.Day,
                                               file.LastWriteTime.Hour,
                                               file.LastWriteTime.Minute,
                                               file.LastWriteTime.Second,
                                               0 );
                //
                // Generate ETag
                //

                strETag = GenerateETag( context, lastModified );

                //
                // OK.  Send the static file out either
                // entirely or send out the requested ranges
                //

                try {
                    BuildFileItemResponse( context, 
                                           FileName, 
                                           file.Length,
                                           lastModified,
                                           strETag );
                }
                catch ( Exception e ) {
                    //
                    // Check for ERROR_ACCESS_DENIED and set the HTTP 
                    // status such that the auth modules do their thing
                    //

                    if ((e is ExternalException) && IsSecurityError( ((ExternalException) e).ErrorCode) ) {
                        throw new HttpException( HttpStatus.Unauthorized, 
                                                 HttpRuntime.FormatResourceString(SR.Resource_access_forbidden) );
                    }
                }

                context.Response.Cache.SetLastModified( lastModified );

                context.Response.Cache.SetETag( strETag ); 

                //
                // We will always set Cache-Control to public
                //

                context.Response.Cache.SetCacheability( HttpCacheability.Public );
            }
        }

        void BuildFileItemResponse( HttpContext context, 
                                    string fileName, 
                                    long fileSize,
                                    DateTime lastModifiedTime,
                                    string strETag ) {
            HttpRequest     request = context.Request;
            HttpResponse    response = context.Response;
            bool            fCache = false;
            string          strRange;
            int             cbCacheThreshold = DEFAULT_CACHE_THRESHOLD;
            bool            fIsRangeRequest = false;

            //
            // Get the Range: header if it exists
            //

            strRange = request.Headers[ "Range" ];
            if ( strRange != null ) {
                if ( strRange.ToLower(CultureInfo.InvariantCulture).StartsWith( "bytes" ) ) {
                    fIsRangeRequest = true;
                }
            }

            //
            // Give the range code a first crack at sending the ranges.  If
            // the Range: header is syntactically invalid, then we will fall
            // thru as if the Range: header was not present.
            //

            if ( fIsRangeRequest && 
                 !SendEntireEntity( context, 
                                    strETag,
                                    lastModifiedTime ) ) {
                // At this point we know that based on "If-Range"
                // (if provided) we may not send the entire entity.

#if  SUPPORT_HTTP_RANGE_REQUESTS
                if ( RangeSupport.ProcessRangeRequest( context,
                                                       strRange,
                                                       fileName,
                                                       fileSize ) ) {
                    //
                    // If ProcessRangeRequest() returned true, then it
                    // handled the range somehow (either sending it back
                    // with a 206 or sent a 416
                    //

                    response.Cache.SetNoServerCaching();

                    return;
                }
#endif                
                //
                // Fall thru.  The request is now cacheable again
                //
            }

            if ( fileSize <= cbCacheThreshold &&
                 !request.RequestType.Equals( "(GETSOURCE)" ) && 
                 !request.RequestType.Equals( "(HEADSOURCE)" ) ) {
                fCache = true;
            }

            //
            // Ask ASP to open the file contents and cache them
            // (hence the second parameter to WriteFile())
            //

            response.WriteFile( fileName, fCache );

            //
            // Specify content type. Use extension to do the mapping
            //

            response.ContentType = MimeMapping.GetMimeMapping( fileName );

            //
            // Static file handler supports byte ranges (duh)
            //

            response.AppendHeader( "Accept-Ranges", "bytes" );

            //
            // If we are caching, the instruct the ASP output cache to 
            // to cache the result.  
            //

            if ( fCache ) {
                //
                // Set a validation handler to check to avoid serving from
                // ASP.NET output cache when Range or Translate:f
                // 


                response.Cache.AddValidationCallback(
                                                    new HttpCacheValidateHandler( this.CacheValidateHandler ),
                                                    null );

                //
                //
                // We want to flush cache entry when static file has changed
                //

                response.AddFileDependency( fileName );

                //
                // Set an expires in the future.
                //

                response.Cache.SetExpires( DateTime.Now.AddDays( 1 ) ); 
            }
        }


        public bool IsReusable {
            get { return true; }
        }

        internal /*public*/ static string GenerateETag( HttpContext context, DateTime lastModTime ) {
            long                    appDomainFileTime;
            long                    lastModFileTime;
            StringBuilder           strETag = new StringBuilder();

            //
            // For now, we will produce an incredibly lame ETag which
            // will be invalidated when:
            // a) The static file has changes (that's ok)
            // b) When an apppool starts
            //
            appDomainFileTime = DateTime.Now.ToFileTime();

            //
            // Get 64-bit FILETIME stamps
            //

            lastModFileTime = lastModTime.ToFileTime();

            //
            // ETag is "<hexified last mod>:<hexified create app>"
            //

            strETag.Append( "\"" );
            strETag.Append( (lastModFileTime).ToString("X8") );
            strETag.Append( ":" );
            strETag.Append( (appDomainFileTime).ToString("X8") );
            strETag.Append( "\"" ); 

            //
            // Is this a strong ETag.  Do what IIS does to determine this. 
            // Compare the last modified time to now and if it earlier by
            // more than 3 seconds, then it is strong.Equals( strIfRange ) )
            //

            if ( !( ( DateTime.Now.ToFileTime() - lastModFileTime ) > 30000000 ) ) {
                //
                // Weak ETag
                //

                return "W/" + strETag.ToString();
            }
            else {
                //
                // Stron ETag.  Leave as is
                //

                return strETag.ToString();
            }
        }            

        internal /*public*/ static bool SendEntireEntity( HttpContext context,
                                             string strETag,
                                             DateTime lastModifiedTime ) {
            string                  strIfRange;
            bool                    fEntireEntity = false;

            //
            // The only way we would not send the range (and instead send
            // the entire entity) is if the If-Range header did not hold
            //

            //
            // NOTE:  This routine is called by range handling code which 
            //        would have first verified that there is indeed a 
            //        Range: header in the request.
            //

            strIfRange = context.Request.Headers[ "If-Range" ];
            if ( strIfRange == null ) {
                return false;
            }
            else {
                //
                // Is this an ETag or a Date?
                // -- entity-tags are quoted strings, HTTP-dates are not
                //

                if ( strIfRange[ 0 ] == '"' ) {
                    //
                    // ETag
                    //

                    if ( !CompareETags( strIfRange, strETag ) ) {
                        fEntireEntity = true;
                    }
                }
                else {
                    //
                    // Date
                    //

                    try {
                        DateTime            dt = DateTime.Parse(strIfRange);                        
                        int  iDateCompare = DateTime.Compare( lastModifiedTime, dt);
                        if ( iDateCompare == 1 ) {
                            fEntireEntity = true;
                        }
                    }
                    catch (Exception) {
                        fEntireEntity = true;
                    }
                }
            }

            return fEntireEntity;
        }

        internal /*public*/ static bool IsSecurityError( int ErrorCode ) {
            return(ErrorCode == ERROR_ACCESS_DENIED);
        }

        private static bool CompareETags( string strETag1,
                                          string strETag2 ) {
            bool                fMatch = false;

            if ( strETag1.Equals( "*" ) || strETag2.Equals( "*" ) ) {
                fMatch = true;
                goto Finished;
            }

            if ( strETag1.StartsWith( "W/" ) ) {
                strETag1 = strETag1.Substring( 2 );
            }

            if ( strETag2.StartsWith( "W/" ) ) {
                strETag2 = strETag2.Substring( 2 );
            }

            fMatch = strETag2.Equals( strETag1 );

            Finished:
            return fMatch;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\stringresourcemanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="StringResourceManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web {

using System;
using System.Collections;
using System.Text;
using System.IO;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;
using Debug=System.Web.Util.Debug;

internal class StringResourceManager {

    internal const int RESOURCE_TYPE = 0xEBB;
    internal const int RESOURCE_ID = 101;

    private StringResourceManager() {
    }

    internal unsafe static string ResourceToString(IntPtr pv, int offset, int size) {
        return new String((sbyte *)pv, offset, size, Encoding.UTF8);
    }

    internal unsafe static void CopyResource(IntPtr src, int srcOffset, byte[] dest, int destOffset, int size) {
        // REVIEW: Is there a cleaner (even if unsafe) way to copy (wrt 64-bit)
        System.Runtime.InteropServices.Marshal.Copy(new IntPtr(src.ToInt64()+srcOffset), dest, destOffset, size);
    }

    internal static SafeStringResource ReadSafeStringResource(Type t) {
        // Module.FullyQualifiedName was changed to check for FileIOPermission regardless of the name being an existing file or not.
        // we need to Assert in order to succeed the Demand() (ASURT 121603)
        (InternalSecurityPermissions.PathDiscovery(HttpRuntime.CodegenDirInternal)).Assert();

        string dllPath = t.Module.FullyQualifiedName;

        IntPtr hModule = UnsafeNativeMethods.GetModuleHandle(dllPath);
        if (hModule == (IntPtr)0) {
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Resource_problem,
                "GetModuleHandle", HttpException.HResultFromLastError(Marshal.GetLastWin32Error()).ToString()));
        }

        IntPtr hrsrc = UnsafeNativeMethods.FindResource(hModule, (IntPtr)RESOURCE_ID, (IntPtr)RESOURCE_TYPE);
        if (hrsrc == (IntPtr)0) {
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Resource_problem,
                "FindResource", HttpException.HResultFromLastError(Marshal.GetLastWin32Error()).ToString()));
        }

        int resSize = UnsafeNativeMethods.SizeofResource(hModule, hrsrc);

        IntPtr hglob = UnsafeNativeMethods.LoadResource(hModule, hrsrc);
        if (hglob == (IntPtr)0) {
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Resource_problem,
                "LoadResource", HttpException.HResultFromLastError(Marshal.GetLastWin32Error()).ToString()));
        }

        IntPtr pv = UnsafeNativeMethods.LockResource(hglob);
        if (pv == (IntPtr)0) {
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Resource_problem,
                "LockResource", HttpException.HResultFromLastError(Marshal.GetLastWin32Error()).ToString()));
        }

        // Make sure the end of the resource lies within the module.  this can be an issue
        // if the resource has been hacked with an invalid length (ASURT 145040)
        if (!UnsafeNativeMethods.IsValidResource(hModule, pv, resSize)) {
            throw new InvalidOperationException();
        }

        return new SafeStringResource(pv, resSize);
    }
}

internal class StringResourceBuilder {
    private ArrayList _literalStrings = null;
    private int _offset = 0;

    internal StringResourceBuilder() {
    }

    internal void AddString(string s, out int offset, out int size, out bool fAsciiOnly) {

        if (_literalStrings == null)
            _literalStrings = new ArrayList();

        _literalStrings.Add(s);

        // Compute the UTF8 length of the string
        size = Encoding.UTF8.GetByteCount(s);

        // Check if the string contains only 7-bit ascii characters
        fAsciiOnly = (size == s.Length);

        offset = _offset;

        // Update the offset in the literal string memory block
        _offset += size;
    }

    internal bool HasStrings {
        get { return _literalStrings != null; }
    }

    internal int MaxResourceOffset {
        get { return _offset; }
    }

    internal void CreateResourceFile(string resFileName) {

        using (Stream strm = new FileStream(resFileName, FileMode.Create)) {
            Encoding encoding = Encoding.UTF8;

            BinaryWriter writer = new BinaryWriter(strm, encoding);

            writer.Write(0x00000000);
            writer.Write(0x00000020);
            writer.Write(0x0000FFFF);
            writer.Write(0x0000FFFF);
            writer.Write(0x00000000);
            writer.Write(0x00000000);
            writer.Write(0x00000000);
            writer.Write(0x00000000);

            // Resource size
            writer.Write(_offset);

            // Resource header size
            writer.Write(0x00000020);

            // Type
            writer.Write(StringResourceManager.RESOURCE_TYPE << 16 | 0xFFFF);

            // Resource ID
            writer.Write(StringResourceManager.RESOURCE_ID << 16 | 0xFFFF);

            writer.Write(0x00000000);
            writer.Write(0x00000000);
            writer.Write(0x00000000);
            writer.Write(0x00000000);

            #if DEBUG
            long startPos = strm.Position;
            #endif

            foreach (string s in _literalStrings) {
                byte[] data = encoding.GetBytes(s);
                writer.Write(data);
            }

            // Make sure the stream has the size we expect
            #if DEBUG
            Debug.Assert(strm.Position-startPos == _offset, "strm.Position-startPos == _offset");
            #endif
        }
    }

}

// Used to wrap an IntPtr in a way that it can safely be handed out to
// untrusted code (ASURT 73586)
internal class SafeStringResource {

    private IntPtr _stringResourcePointer;
    private int _resourceSize;

    internal SafeStringResource(IntPtr stringResourcePointer, int resourceSize) {
        _stringResourcePointer = stringResourcePointer;
        _resourceSize = resourceSize;
    }

    internal IntPtr StringResourcePointer { get { return _stringResourcePointer; } }
    internal int ResourceSize { get { return _resourceSize; } }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\webcategoryattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebCategoryAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Web {

    using System;
    using System.ComponentModel;   
    using System.Diagnostics;

    /// <include file='doc\WebCategoryAttribute.uex' path='docs/doc[@for="WebCategoryAttribute"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       CategoryAttribute that can access ASP.NET localized strings.
    ///    </para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    internal sealed class WebCategoryAttribute : CategoryAttribute {

        /// <include file='doc\WebCategoryAttribute.uex' path='docs/doc[@for="WebCategoryAttribute.WebCategoryAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.CategoryAttribute'/> class.
        ///    </para>
        /// </devdoc>
        internal WebCategoryAttribute(string category) : base(category) {
        }

        /// <include file='doc\WebCategoryAttribute.uex' path='docs/doc[@for="WebCategoryAttribute.GetLocalizedString"]/*' />
        /// <devdoc>
        ///     This method is called the first time the category property
        ///     is accessed.  It provides a way to lookup a localized string for
        ///     the given category.  Classes may override this to add their
        ///     own localized names to categories.  If a localized string is
        ///     available for the given value, the method should return it.
        ///     Otherwise, it should return null.
        /// </devdoc>
        protected override string GetLocalizedString(string value) {
            string localizedValue = base.GetLocalizedString(value);
            if (localizedValue == null) {
                localizedValue = (string)SR.GetString("Category_" + value);
            }
            // This attribute is internal, and we should never have a missing resource string.
            //
            Debug.Assert(localizedValue != null, "All WebForms category attributes should have localized strings.  Category '" + value + "' not found.");
            return localizedValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\websysdescriptionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebSysDescriptionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Web {


    using System;
    using System.ComponentModel;   

    /// <include file='doc\WebSysDescriptionAttribute.uex' path='docs/doc[@for="WebSysDescriptionAttribute"]/*' />
    /// <devdoc>
    ///     DescriptionAttribute marks a property, event, or extender with a
    ///     description. Visual designers can display this description when referencing
    ///     the member.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    internal class WebSysDescriptionAttribute : DescriptionAttribute {

        private bool replaced;

        /// <include file='doc\WebSysDescriptionAttribute.uex' path='docs/doc[@for="WebSysDescriptionAttribute.WebSysDescriptionAttribute"]/*' />
        /// <devdoc>
        ///    <para>Constructs a new sys description.</para>
        /// </devdoc>
        internal WebSysDescriptionAttribute(string description) : base(description) {
        }

        /// <include file='doc\WebSysDescriptionAttribute.uex' path='docs/doc[@for="WebSysDescriptionAttribute.Description"]/*' />
        /// <devdoc>
        ///    <para>Retrieves the description text.</para>
        /// </devdoc>
        public override string Description {
            get {
                if (!replaced) {
                    replaced = true;
                    DescriptionValue = SR.GetString(base.Description);                
                }
                return base.Description;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\cache\cache.cs ===
//------------------------------------------------------------------------------
// <copyright file="cache.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Cache class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Caching {
    using System.Collections;
    using System.Collections.Specialized;
    using System.Configuration;
    using System.Runtime.InteropServices;
    using System.Threading;
    using System.Web.Util;
    using System.Web;
    using Microsoft.Win32;
    using System.Security.Permissions;
    using System.Globalization;

    /// <include file='doc\Cache.uex' path='docs/doc[@for="CacheItemRemovedCallback"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see langword='onRemoveCallback'/> 
    /// event of a System.Web.Caching.Cache instance.</para>
    /// </devdoc>
    public delegate void CacheItemRemovedCallback(
            string key, object value, CacheItemRemovedReason reason);
    
    /// <include file='doc\Cache.uex' path='docs/doc[@for="CacheItemPriority"]/*' />
    /// <devdoc>
    /// <para> Specifies the relative priority of items stored in the System.Web.Caching.Cache. When the Web 
    ///    server runs low on memory, the Cache selectively purges items to free system
    ///    memory. Items with higher priorities are less likely to be removed from the
    ///    cache when the server is under load. Web
    ///    applications can use these
    ///    values to prioritize cached items relative to one another. The default is
    ///    normal.</para>
    /// </devdoc>
    public enum CacheItemPriority {
        /// <include file='doc\Cache.uex' path='docs/doc[@for="CacheItemPriority.Low"]/*' />
        /// <devdoc>
        ///    <para> The cahce items with this priority level will be the first 
        ///       to be removed when the server frees system memory by deleting items from the
        ///       cache.</para>
        /// </devdoc>
        Low = 1, 
        /// <include file='doc\Cache.uex' path='docs/doc[@for="CacheItemPriority.BelowNormal"]/*' />
        /// <devdoc>
        ///    <para> The cache items with this priority level 
        ///       are in the second group to be removed when the server frees system memory by
        ///       deleting items from the cache. </para>
        /// </devdoc>
        BelowNormal, 
        /// <include file='doc\Cache.uex' path='docs/doc[@for="CacheItemPriority.Normal"]/*' />
        /// <devdoc>
        ///    <para> The cache items with this priority level are in 
        ///       the third group to be removed when the server frees system memory by deleting items from the cache. This is the default. </para>
        /// </devdoc>
        Normal, 
        /// <include file='doc\Cache.uex' path='docs/doc[@for="CacheItemPriority.AboveNormal"]/*' />
        /// <devdoc>
        ///    <para> The cache items with this priority level are in the 
        ///       fourth group to be removed when the server frees system memory by deleting items from the
        ///       cache. </para>
        /// </devdoc>
        AboveNormal, 
        /// <include file='doc\Cache.uex' path='docs/doc[@for="CacheItemPriority.High"]/*' />
        /// <devdoc>
        ///    <para>The cache items with this priority level are in the fifth group to be removed 
        ///       when the server frees system memory by deleting items from the cache. </para>
        /// </devdoc>
        High, 
        /// <include file='doc\Cache.uex' path='docs/doc[@for="CacheItemPriority.NotRemovable"]/*' />
        /// <devdoc>
        ///    <para>The cache items with this priority level will not be removed when the server 
        ///       frees system memory by deleting items from the cache. </para>
        /// </devdoc>
        NotRemovable, 
        /// <include file='doc\Cache.uex' path='docs/doc[@for="CacheItemPriority.Default"]/*' />
        /// <devdoc>
        ///    <para>The default value is Normal.</para>
        /// </devdoc>
        Default = Normal
    }
    
    /// <include file='doc\Cache.uex' path='docs/doc[@for="CacheItemRemovedReason"]/*' />
    /// <devdoc>
    ///    <para>Specifies the reason that a cached item was removed.</para>
    /// </devdoc>
    public enum CacheItemRemovedReason {
        /// <include file='doc\Cache.uex' path='docs/doc[@for="CacheItemRemovedReason.Removed"]/*' />
        /// <devdoc>
        /// <para>The item was removed from the cache by the 'System.Web.Caching.Cache.Remove' method, or by an System.Web.Caching.Cache.Insert method call specifying the same key.</para>
        /// </devdoc>
        Removed = 1, 
        /// <include file='doc\Cache.uex' path='docs/doc[@for="CacheItemRemovedReason.Expired"]/*' />
        /// <devdoc>
        ///    <para>The item was removed from the cache because it expired. </para>
        /// </devdoc>
        Expired,
        /// <include file='doc\Cache.uex' path='docs/doc[@for="CacheItemRemovedReason.Underused"]/*' />
        /// <devdoc>
        ///    <para>The item was removed from the cache because the value in the hitInterval 
        ///       parameter was not met, or because the system removed it to free memory.</para>
        /// </devdoc>
        Underused, 
        /// <include file='doc\Cache.uex' path='docs/doc[@for="CacheItemRemovedReason.DependencyChanged"]/*' />
        /// <devdoc>
        ///    <para>The item was removed from the cache because a file or key dependency was 
        ///       changed.</para>
        /// </devdoc>
        DependencyChanged
    }
    
    enum CacheGetOptions {
        None                = 0, 
        ReturnCacheEntry    = 0x1,
    }
    
    /// <include file='doc\Cache.uex' path='docs/doc[@for="Cache"]/*' />
    /// <devdoc>
    ///    <para>Implements the cache for a Web application. There is only one instance of 
    ///       this class per application domain, and it remains valid only as long as the
    ///       application domain remains active. Information about an instance of this class
    ///       is available through the <see langword='Cache'/> property of the System.Web.HttpContext.</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class Cache : IEnumerable {
        /// <include file='doc\Cache.uex' path='docs/doc[@for="Cache.NoAbsoluteExpiration"]/*' />
        /// <devdoc>
        ///    <para>Sets the absolute expiration policy to, in essence, 
        ///       never. When set, this field is equal to the the System.DateTime.MaxValue , which is a constant
        ///       representing the largest possible <see langword='DateTime'/> value. The maximum date and
        ///       time value is equivilant to "12/31/9999 11:59:59 PM". This field is read-only.</para>
        /// </devdoc>
        public static readonly DateTime NoAbsoluteExpiration = DateTime.MaxValue;
    
        /// <include file='doc\Cache.uex' path='docs/doc[@for="Cache.NoSlidingExpiration"]/*' />
        /// <devdoc>
        ///    <para>Sets the amount of time for sliding cache expirations to 
        ///       zero. When set, this field is equal to the System.TimeSpan.Zero field, which is a constant value of
        ///       zero. This field is read-only.</para>
        /// </devdoc>
        public static readonly TimeSpan NoSlidingExpiration = TimeSpan.Zero;
    
        CacheInternal   _cacheInternal;

        /// <include file='doc\Cache.uex' path='docs/doc[@for="Cache.Cache"]/*' />
        /// <internalonly/> 
        /// <devdoc>
        ///    <para>This constructor is for internal use only, and was accidentally made public - do not use.</para>
        /// </devdoc>
        public Cache() {
            InternalSecurityPermissions.UnmanagedCode.Demand();
        }
    
        internal void SetCacheInternal(CacheInternal cacheInternal) {
            _cacheInternal = cacheInternal;
        }
    
        /// <include file='doc\Cache.uex' path='docs/doc[@for="Cache.Count"]/*' />
        /// <devdoc>
        ///    <para>Gets the number of items stored in the cache. This value can be useful when 
        ///       monitoring your application's performance or when using the ASP.NET tracing
        ///       functionality.</para>
        /// </devdoc>
        public int Count {
            get {
                return _cacheInternal.PublicCount;
            }
        }
    
        /// <include file='doc\Cache.uex' path='docs/doc[@for="Cache.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator() {
            return ((IEnumerable)_cacheInternal).GetEnumerator();
        }
    
        /// <include file='doc\Cache.uex' path='docs/doc[@for="Cache.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>Returns a dictionary enumerator used for iterating through the key/value 
        ///       pairs contained in the cache. Items can be added to or removed from the cache
        ///       while this method is enumerating through the cache items.</para>
        /// </devdoc>
        public IDictionaryEnumerator GetEnumerator() {
            return _cacheInternal.GetEnumerator();
        }
    
        /// <include file='doc\Cache.uex' path='docs/doc[@for="Cache.this"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets an item in the cache.</para>
        /// </devdoc>
        public object this[string key] {
            get {
                return Get(key);
            }
    
            set {
                Insert(key, value);
            }
        }
    
        /// <include file='doc\Cache.uex' path='docs/doc[@for="Cache.Get"]/*' />
        /// <devdoc>
        ///    <para>Retrieves an item from the cache.</para>
        /// </devdoc>
        public object Get(string key) {
            return _cacheInternal.DoGet(true, key, CacheGetOptions.None);
        }
    
        internal object Get(string key, CacheGetOptions getOptions) {
            return _cacheInternal.DoGet(true, key, getOptions);
        }
    
        /// <include file='doc\Cache.uex' path='docs/doc[@for="Cache.Insert"]/*' />
        /// <devdoc>
        ///    <para>Inserts an item into the Cache with default values.</para>
        /// </devdoc>
        public void Insert(string key, object value) {
            _cacheInternal.DoInsert(   
                        true, 
                        key, 
                        value,                          
                        null,                           
                        NoAbsoluteExpiration,              
                        NoSlidingExpiration,                  
                        CacheItemPriority.Default,       
                        null,                           
                        true);
        }
    
        /// <include file='doc\Cache.uex' path='docs/doc[@for="Cache.Insert1"]/*' />
        /// <devdoc>
        /// <para>Inserts an object into the System.Web.Caching.Cache that has file or key 
        ///    dependencies.</para>
        /// </devdoc>
        public void Insert(string key, object value, CacheDependency dependencies) {
            _cacheInternal.DoInsert(   
                        true,
                        key, 
                        value,                          
                        dependencies,                           
                        NoAbsoluteExpiration,              
                        NoSlidingExpiration,                  
                        CacheItemPriority.Default,       
                        null,                           
                        true);
        }
    
        /// <include file='doc\Cache.uex' path='docs/doc[@for="Cache.Insert2"]/*' />
        /// <devdoc>
        /// <para>Inserts an object into the System.Web.Caching.Cache that has file or key dependencies and 
        ///    expires at the value set in the <paramref name="absoluteExpiration"/> parameter.</para>
        /// </devdoc>
        public void Insert(string key, object value, CacheDependency dependencies, DateTime absoluteExpiration, TimeSpan slidingExpiration) {
            DateTime utcAbsoluteExpiration = DateTimeUtil.ConvertToUniversalTime(absoluteExpiration);
            _cacheInternal.DoInsert(   
                        true,                          
                        key, 
                        value,                          
                        dependencies,                           
                        utcAbsoluteExpiration,              
                        slidingExpiration,                  
                        CacheItemPriority.Default,       
                        null,                           
                        true);                         
        }
    
        /// <include file='doc\Cache.uex' path='docs/doc[@for="Cache.Insert3"]/*' />
        public void Insert(
                string key, 
                object value, 
                CacheDependency dependencies, 
                DateTime absoluteExpiration, 
                TimeSpan slidingExpiration,
                CacheItemPriority priority,
                CacheItemRemovedCallback onRemoveCallback) {

            DateTime utcAbsoluteExpiration = DateTimeUtil.ConvertToUniversalTime(absoluteExpiration);
            _cacheInternal.DoInsert(   
                        true,                          
                        key, 
                        value,                          
                        dependencies,                           
                        utcAbsoluteExpiration,              
                        slidingExpiration,                  
                        priority,       
                        onRemoveCallback,                           
                        true);                         
        }
    
        /// <include file='doc\Cache.uex' path='docs/doc[@for="Cache.Add"]/*' />
        public object Add(
                string key, 
                object value, 
                CacheDependency dependencies, 
                DateTime absoluteExpiration, 
                TimeSpan slidingExpiration,
                CacheItemPriority priority,
                CacheItemRemovedCallback onRemoveCallback) {

            DateTime utcAbsoluteExpiration = DateTimeUtil.ConvertToUniversalTime(absoluteExpiration);
            return _cacheInternal.DoInsert(   
                        true,
                        key, 
                        value,                          
                        dependencies,                           
                        utcAbsoluteExpiration,              
                        slidingExpiration,                  
                        priority,       
                        onRemoveCallback,                           
                        false);
        }
                
        /// <include file='doc\Cache.uex' path='docs/doc[@for="Cache.Remove"]/*' />
        /// <devdoc>
        ///    <para>Removes the specified item from the cache. </para>
        /// </devdoc>
        public object Remove(string key) {
            CacheKey cacheKey = new CacheKey(key, true);
            return _cacheInternal.DoRemove(cacheKey, CacheItemRemovedReason.Removed);
        }
    }
    

    abstract class CacheInternal : IEnumerable, IDisposable {
        const int   MEMORYSTATUS_UPDATE_INTERVAL = 1 * Msec.ONE_SECOND;

        Cache                       _cachePublic;
        protected CacheMemoryStats  _cacheMemoryStats;
        object                      _timerMemoryStats;
        int                         _inMemoryStatsUpdate;

        // virtual methods requiring implementation
        internal abstract int PublicCount   {get;}

        internal abstract IDictionaryEnumerator CreateEnumerator();

        internal abstract CacheEntry UpdateCache(
                CacheKey                cacheKey,
                CacheEntry              newEntry, 
                bool                    replace, 
                CacheItemRemovedReason  removedReason,
                out object              valueOld);

        internal abstract void ReviewMemoryStats();

        // common implementation
        static internal CacheInternal Create() {
            CacheInternal       cacheInternal;
            Cache               cachePublic;
            CacheMemoryStats    cacheMemoryStats;
            int                 numSubCaches = 0;
             
#if USE_CONFIG
            String ver = VersionInfo.SystemWebVersion;
            RegistryKey regKey = Registry.LocalMachine.OpenSubKey("Software\\Microsoft\\ASP.NET\\" + ver);
            if (regKey != null) {
                numSubCaches = (int) regKey.GetValue("numSubCaches", 0);
                regKey.Close();
            }
#endif

            if (numSubCaches == 0) {
                uint numCPUs = (uint) SystemInfo.GetNumProcessCPUs();

                // the number of subcaches is the minimal power of 2 greater
                // than or equal to the number of cpus
                numSubCaches = 1;
                numCPUs -= 1;
                while (numCPUs > 0) {
                    numSubCaches <<= 1;
                    numCPUs >>= 1;
                }
            }

            cachePublic = new Cache();
            cacheMemoryStats = new CacheMemoryStats();
            if (numSubCaches == 1) {
                cacheInternal = new CacheSingle(cachePublic, cacheMemoryStats, null, 0);
            }
            else {
                cacheInternal = new CacheMultiple(cachePublic, cacheMemoryStats, numSubCaches);
            }

            cachePublic.SetCacheInternal(cacheInternal);
            cacheInternal.StartCacheMemoryTimers();

            return cacheInternal;
        }

        protected CacheInternal(Cache cachePublic, CacheMemoryStats cacheMemoryStats) {
            _cachePublic = cachePublic;
            _cacheMemoryStats = cacheMemoryStats;
        }

        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                Timer timer = (Timer) _timerMemoryStats;
                if (    timer != null && 
                        Interlocked.Exchange(ref _timerMemoryStats, null) != null) {

                    timer.Dispose();
                    Debug.Trace("CacheDispose", "_timerMemoryStats disposed");
                }
            }
        }

        public void Dispose() {
            Dispose(true);
            // no destructor, don't need it.
            // System.GC.SuppressFinalize(this);
        }

        internal Cache CachePublic {
            get {return _cachePublic;}
        }
    
        internal CacheMemoryStats CacheMemoryStats {
            get {return _cacheMemoryStats;}
        }
    
        IEnumerator IEnumerable.GetEnumerator() {
            return CreateEnumerator();
        }
        
        public IDictionaryEnumerator GetEnumerator() {
            return CreateEnumerator();
        }
        
        internal /*public*/ object this[string key] {
            get {
                return Get(key);
            }
    
            set {
                UtcInsert(key, value);
            }
        }
    
        internal /*public*/ object Get(string key) {
            return DoGet(false, key, CacheGetOptions.None);
        }
    
        internal object Get(string key, CacheGetOptions getOptions) {
            return DoGet(false, key, getOptions);
        }

        internal object DoGet(bool isPublic, string key, CacheGetOptions getOptions) {
            CacheEntry  entry;
            CacheKey    cacheKey;
            object      dummy;

            cacheKey = new CacheKey(key, isPublic);
            entry = UpdateCache(cacheKey, null, false, CacheItemRemovedReason.Removed, out dummy);
            if (entry != null) {
                if ((getOptions & CacheGetOptions.ReturnCacheEntry) != 0) {
                    return entry;
                }
                else {
                    return entry.Value;
                }
            }
            else {
                return null;
            }
        }
    
        internal /*public*/ void UtcInsert(string key, object value) {
            DoInsert(false,
                     key, 
                     value,                          
                     null,                           
                     Cache.NoAbsoluteExpiration,
                     Cache.NoSlidingExpiration,
                     CacheItemPriority.Default,       
                     null,                           
                     true);
                        
        }
    
        internal /*public*/ void UtcInsert(string key, object value, CacheDependency dependencies) {
            DoInsert(false,
                     key, 
                     value,                          
                     dependencies,                            
                     Cache.NoAbsoluteExpiration,
                     Cache.NoSlidingExpiration,
                     CacheItemPriority.Default,       
                     null,                           
                     true);
        }
    
        internal /*public*/ void UtcInsert(
                string key, 
                object value, 
                CacheDependency dependencies, 
                DateTime utcAbsoluteExpiration, 
                TimeSpan slidingExpiration) {

            DoInsert(false,
                     key, 
                     value,                          
                     dependencies,                            
                     utcAbsoluteExpiration,
                     slidingExpiration,
                     CacheItemPriority.Default,       
                     null,                           
                     true);
        }
    
        internal /*public*/ void UtcInsert(
                string key, 
                object value, 
                CacheDependency dependencies, 
                DateTime utcAbsoluteExpiration, 
                TimeSpan slidingExpiration,
                CacheItemPriority priority,
                CacheItemRemovedCallback onRemoveCallback) {

            DoInsert(false,
                     key, 
                     value,                          
                     dependencies, 
                     utcAbsoluteExpiration, 
                     slidingExpiration,
                     priority, 
                     onRemoveCallback,
                     true);
        }

        internal /*public*/ object UtcAdd(
                string key, 
                object value, 
                CacheDependency dependencies, 
                DateTime utcAbsoluteExpiration, 
                TimeSpan slidingExpiration,
                CacheItemPriority priority,
                CacheItemRemovedCallback onRemoveCallback) {

            return DoInsert(
                        false,
                        key, 
                        value, 
                        dependencies, 
                        utcAbsoluteExpiration, 
                        slidingExpiration, 
                        priority, 
                        onRemoveCallback, 
                        false);

        }
                
        internal object DoInsert(
                bool isPublic,
                string key, 
                object value, 
                CacheDependency dependencies, 
                DateTime utcAbsoluteExpiration, 
                TimeSpan slidingExpiration,
                CacheItemPriority priority,
                CacheItemRemovedCallback onRemoveCallback,
                bool replace) {


            /*
             * If we throw an exception, prevent a leak by a naive user who 
             * writes the following:
             * 
             *     Cache.Insert(key, value, new CacheDependency(file));
             */
            using (dependencies) {
                CacheEntry      entry;
                object          dummy;

                entry = new CacheEntry(
                        key,
                        value,
                        dependencies,
                        onRemoveCallback,
                        utcAbsoluteExpiration,              
                        slidingExpiration,
                        priority,
                        isPublic);

                entry = UpdateCache(entry, entry, replace, CacheItemRemovedReason.Removed, out dummy);

                /*
                 * N.B. A set can fail if two or more threads set the same key 
                 * at the same time.
                 */
#if DBG
                if (replace) {
                    string yesno = (entry != null) ? "succeeded" : "failed";
                    Debug.Trace("CacheAPIInsert", "Cache.Insert " + yesno + ": " + key.ToString());
                }
                else {
                    if (entry == null) {
                        Debug.Trace("CacheAPIAdd", "Cache.Add added new item: " + key.ToString());
                    } 
                    else {
                        Debug.Trace("CacheAPIAdd", "Cache.Add returned existing item: " + key.ToString());
                    }
                }
#endif

                if (entry != null) {
                    return entry.Value;
                }
                else {
                    return null;
                }
            }
        }
    
        internal /*public*/ object Remove(string key) {
            CacheKey cacheKey = new CacheKey(key, false);
            return DoRemove(cacheKey, CacheItemRemovedReason.Removed);
        }
    
        internal object Remove(string key, CacheItemRemovedReason reason)  {
            CacheKey cacheKey = new CacheKey(key, false);
            return DoRemove(cacheKey, reason);
        }

        internal object Remove(CacheKey cacheKey, CacheItemRemovedReason reason)  {
            return DoRemove(cacheKey, reason);
        }

        /*
         * Remove an item from the cache, with a specific reason.
         * This is package access so only the cache can specify
         * a reason other than REMOVED.
         * 
         * @param key The key for the item.
         * @exception ArgumentException
         */
        internal object DoRemove(CacheKey cacheKey, CacheItemRemovedReason reason)  {
            object      valueOld;

            UpdateCache(cacheKey, null, true, reason, out valueOld);
    
#if DBG
            if (valueOld != null) {
                Debug.Trace("CacheAPIRemove", "Cache.Remove succeeded, reason=" + reason + ": " + cacheKey);
            }
            else {
                Debug.Trace("CacheAPIRemove", "Cache.Remove failed, reason=" + reason + ": " + cacheKey);
            }
#endif

            return valueOld;
        }

        void StartCacheMemoryTimers() {

#if DBG
            if (!Debug.IsTagPresent("Timer") || Debug.IsTagEnabled("Timer"))
#endif
            {
                _timerMemoryStats = new Timer(new TimerCallback(this.MemoryStatusTimerCallback), null, MEMORYSTATUS_UPDATE_INTERVAL, MEMORYSTATUS_UPDATE_INTERVAL);
            }
        }

        void MemoryStatusTimerCallback(object state) {
            if (Interlocked.CompareExchange(ref _inMemoryStatsUpdate, 1, 0) != 0)
                return;

            try {
                _cacheMemoryStats.Update();
                ReviewMemoryStats();
            }
            finally {
                Interlocked.Exchange(ref _inMemoryStatsUpdate, 0);
            }
        }
    }

    sealed class CacheComparer : IComparer {
        static CacheComparer    s_comparerInstance;

        static internal CacheComparer GetInstance() {
            if (s_comparerInstance == null) {
                s_comparerInstance = new CacheComparer();
            }

            return s_comparerInstance;
        }
        
        private CacheComparer() {
        }

        // Compares two objects. An implementation of this method must return a
        // value less than zero if x is less than y, zero if x is equal to y, or a
        // value greater than zero if x is greater than y.
        int IComparer.Compare(Object x, Object y) {
            CacheKey  a, b;

            Debug.Assert(x != null && x is CacheKey);
            Debug.Assert(y != null && y is CacheKey);

            a = (CacheKey) x;
            b = (CacheKey) y;

            int result = String.Compare(a.Key, b.Key, false, CultureInfo.InvariantCulture);
            if (result == 0) {
                if (a.IsPublic) {
                    result = b.IsPublic ? 0 : 1;
                }
                else {
                    result = b.IsPublic ? -1 : 0;
                }
            }

            return result;
        }
    }

    sealed class CacheHashCodeProvider : IHashCodeProvider {
        static CacheHashCodeProvider    s_hashCodeProviderInstance;

        static internal CacheHashCodeProvider GetInstance() {
            if (s_hashCodeProviderInstance == null) {
                s_hashCodeProviderInstance = new CacheHashCodeProvider();
            }

            return s_hashCodeProviderInstance;
        }
        
        private CacheHashCodeProvider() {
        }

        // Interfaces are not serializable
        // Returns a hash code for the given object.
        //
        int IHashCodeProvider.GetHashCode(Object obj) {
            Debug.Assert(obj != null && obj is CacheKey);
            
            CacheKey cacheKey = (CacheKey) obj;

            return cacheKey.Key.GetHashCode();
        }
    }

    /*
     * The cache.
     */
    sealed class CacheSingle : CacheInternal {
        // cache stats
        static readonly TimeSpan    MIN_TRIM_DELTA = new TimeSpan(0, 0, 5);
        static readonly TimeSpan    TRIM_TIMEOUT = new TimeSpan(0, 5, 0);
        const int                   MAX_COUNT = Int32.MaxValue / 2; 
        const int                   MIN_COUNT = 50;                 
        const int                   MAX_INIT = 1000;                
        const int                   MAX_OVERLOAD_COUNT = 50;        

        Hashtable           _entries;           /* lookup table of entries */ 
        CacheExpires        _expires;           /* expires tables */          
        CacheUsage          _usage;             /* usage tables */            
        object              _lock;              /* read/write synchronization for _entries */
        int                 _disposed;          /* disposed */
        int                 _totalCount;        /* count of total entries */        
        int                 _publicCount;       /* count of public entries */        
        DateTime            _utcDateLastCollected;           /* the time we last collected */
        DateTime            _utcDateLastCollectedHiPressure; /* the time we last collected while under high pressure */
        int                 _maxCount;          /* cache maximum count */
        int                 _maxCountOverload;  /* count at which an add triggers a trim */
        int                 _inTrim;            /* allow one trim request at a time */
        DateTime            _utcInTrimLockDate; /* time when trim was locked */
        WorkItemCallback    _trimCallback;      /* delegate for trim callback */
        int                 _iSubCache;
        CacheMultiple       _cacheMultiple;

        /*
         * Constructs a new Cache.
         */
        internal CacheSingle(Cache cachePublic, CacheMemoryStats cacheMemoryStats, CacheMultiple cacheMultiple, int iSubCache) : base(cachePublic, cacheMemoryStats) {
            _cacheMultiple = cacheMultiple;
            _iSubCache = iSubCache;
            _entries = new Hashtable(CacheHashCodeProvider.GetInstance(), CacheComparer.GetInstance());
            _expires = new CacheExpires(this);
            _usage = new CacheUsage(this);
            _lock = new object();
            _maxCount = MAX_INIT;
            _maxCountOverload = _maxCount + MAX_OVERLOAD_COUNT;
            _trimCallback = new WorkItemCallback(this.Trim);
        }
    
        /*
         * Dispose the cache.
         */
        protected override void Dispose(bool disposing) {
            if (disposing) {
                if (Interlocked.Exchange(ref _disposed, 1) == 0) {
                    // keep reference to expires and usage, so that
                    // subsequent operations continue to 
                    // work. Expires::Dispose and Usage::Dispose simply discontinues
                    // their timers
                    if (_expires != null) {
                        _expires.Dispose();
                    }

                    if (_usage != null) {
                        _usage.Dispose();
                    }

                    // close all items
                    CacheEntry[] entries = null;

                    Monitor.Enter(_lock);
                    try {
                        entries = new CacheEntry[_entries.Count];
                        int i = 0;
                        foreach (DictionaryEntry d in _entries) {
                            entries[i++] = (CacheEntry) d.Value;
                        }
                    }
                    finally {
                        Monitor.Exit(_lock);
                    }

                    foreach (CacheEntry entry in entries) {
                        Remove(entry, CacheItemRemovedReason.Removed);
                    }

                    Debug.Trace("CacheDispose", "Cache disposed");
                }
            }

            base.Dispose(disposing);
        }
    
        internal override int PublicCount {
            get {return _publicCount;}
        }
    
        internal override IDictionaryEnumerator CreateEnumerator() {
            Hashtable h = new Hashtable(_publicCount);

            Monitor.Enter(_lock);
            try {
                foreach (DictionaryEntry d in _entries) {
                    CacheEntry entry = (CacheEntry) d.Value;

                    // note that ASP.NET does not use this enumerator internally,
                    // so we just choose public items.
                    if (entry.IsPublic && entry.State == CacheEntry.EntryState.AddedToCache) {
                        h[entry.Key] = entry.Value;
                    }
                }
            }
            finally {
                Monitor.Exit(_lock);
            }

            return h.GetEnumerator();
        }

        /*
         * Performs all operations on the cache, with the 
         * exception of Clear. The arguments indicate the type of operation:
         * 
         * @param key The key of the object.
         * @param newItem The new entry to be added to the cache.
         * @param replace Whether or not newEntry should replace an existing object in the cache.
         * @return The item requested. May be null.
         */
        internal override CacheEntry UpdateCache(
                CacheKey                cacheKey,
                CacheEntry              newEntry, 
                bool                    replace, 
                CacheItemRemovedReason  removedReason,
                out object              valueOld)
        {
            CacheEntry              entry = null;
            CacheEntry              oldEntry = null; 
            bool                    expired = false;                         
            DateTime                utcNow;
            CacheDependency         newEntryDependency = null;
            bool                    isGet, isAdd;
            bool                    removeExpired = false;
            bool                    updateExpires = false;
            DateTime                utcNewExpires = DateTime.MinValue;
            CacheEntry.EntryState   entryState = CacheEntry.EntryState.NotInCache;

            valueOld = null;
            isGet = !replace && newEntry == null;
            isAdd = !replace && newEntry != null;

            /*
             * Perform update of cache data structures in a series to 
             * avoid overlapping locks.
             * 
             * First, update the hashtable. The hashtable is the place
             * that guarantees what is in or out of the cache.
             * 
             * Loop here to remove expired items in a Get or Add, where 
             * we can't otherwise delete an item.
             */
            for (;;) {
                if (removeExpired) {
                    Debug.Trace("CacheUpdate", "Removing expired item found in Get: " + cacheKey);
                    UpdateCache(cacheKey, null, true, CacheItemRemovedReason.Expired, out valueOld);
                    removeExpired = false;
                }

                entry = null;
                utcNow = DateTime.UtcNow;

                if (!isGet) {
                    Monitor.Enter(_lock);
                }
                try {
                    entry = (CacheEntry) _entries[cacheKey];
                    Debug.Trace("CacheUpdate", "Entry " + ((entry != null) ? "found" : "not found") + "in hashtable: " + cacheKey);

                    if (entry != null) {
                        entryState = entry.State;

                        // If isGet == true, we are not hold any lock and so entryState can be anything
                        Debug.Assert(
                            isGet ||
                            entryState == CacheEntry.EntryState.AddingToCache ||
                            entryState == CacheEntry.EntryState.AddedToCache,
                            "entryState == CacheEntry.EntryState.AddingToCache || entryState == CacheEntry.EntryState.AddedToCache");

                        expired = entry.UtcExpires < utcNow;
                        if (expired) {
                            if (isGet) {
                                /*
                                 * If the expired item is Added to the cache, remove it now before
                                 * its expiration timer fires up to a minute in the future.
                                 * Otherwise, just return null to indicate the item is not available.
                                 */
                                if (entryState == CacheEntry.EntryState.AddedToCache) {
                                    removeExpired = true;
                                    continue;
                                }

                                entry = null;
                            }
                            else {
                                /*
                                 * If it's a call to Add, replace the item
                                 * when it has expired.
                                 */
                                replace = true;

                                /*
                                 * Change the removed reason.
                                 */
                                removedReason = CacheItemRemovedReason.Expired;
                            }
                        }
                        else {
                            updateExpires = (entry.SlidingExpiration > TimeSpan.Zero);
                        }
                    }

                    /*
                     * Avoid running unnecessary code in a Get request by this simple test:
                     */
                    if (!isGet) {
                        /*
                         * Remove an item from the hashtable.
                         */
                        if (replace && entry != null) {
                            bool doRemove = (entryState != CacheEntry.EntryState.AddingToCache);
                            if (doRemove) {
                                oldEntry = entry;
                                
                                oldEntry.State = CacheEntry.EntryState.RemovingFromCache;

                                _entries.Remove(oldEntry);   
                                Debug.Trace("CacheUpdate", "Entry removed from hashtable: " + cacheKey);
                            }
                            else {
                                /*
                                 * If we're removing and couldn't remove the old item
                                 * because its state was AddingToCache, return null
                                 * to indicate failure.
                                 */
                                if (newEntry == null) {
                                    Debug.Trace("CacheUpdate", "Removal from hashtable failed: " + cacheKey);
                                    entry = null;
                                }
                            }
                        }

                        /*
                         * Add an item to the hashtable.
                         */
                        if (newEntry != null) {
                            bool doAdd = true;

                            /* non-definitive check */
                            newEntryDependency = newEntry.Dependency;
                            if (newEntryDependency != null) {
                                doAdd = !newEntryDependency.HasChanged;
#if DBG
                                if (!doAdd) {
                                    Debug.Trace("CacheUpdate", "Insertion into hashtable failed because dependency changed: " + cacheKey);
                                }
#endif
                            }

                            if (doAdd && entry != null) {
                                doAdd = (oldEntry != null);
#if DBG
                                if (!doAdd) {
                                    Debug.Trace("CacheUpdate", "Insertion into hashtable failed because old entry was not removed: " + cacheKey);
                                }
#endif
                            }

                            if (doAdd) {
                                newEntry.State = CacheEntry.EntryState.AddingToCache;
                                _entries.Add(newEntry, newEntry);

                                /* 
                                 * If this is an Add operation, be sure to return null 
                                 * in the case where the entry had expired and we set
                                 * replace = true.
                                 * 
                                 */
                                if (isAdd) {
                                    Debug.Assert(entry == null || expired, "entry == null || expired");
                                    entry = null;
                                }

                                Debug.Trace("CacheUpdate", "Entry added to hashtable: " + cacheKey);
                            }
                            else {
                                newEntry = null;

                                /*
                                 * If we're inserting and we can't add because the old
                                 * entry could not be removed, indicate failure
                                 * by returning null.
                                 */
                                if (replace) {
                                    Debug.Trace("CacheUpdate", "Insertion into hashtable failed: " + cacheKey);
                                    entry = null;
                                }
                            }
                        } 
                    }

                    break;
                }
                finally {
                    if (!isGet) {
                        Monitor.Exit(_lock);
                    }
                }
            }
        
            /*
             * Since we want Get to be fast, check here for a get without 
             * alteration to cache.
             */
            if (isGet) {
                if (entry != null) {
                    if (updateExpires) {
                        utcNewExpires = utcNow + entry.SlidingExpiration;
                        if (utcNewExpires - entry.UtcExpires >= CacheExpires.MIN_UPDATE_DELTA) {
                            _expires.UtcUpdate(entry, utcNewExpires);
                        }
                    }

                    UtcUpdateUsageRecursive(entry, utcNow);
                }

                if (cacheKey.IsPublic) {
                    PerfCounters.IncrementCounter(AppPerfCounter.API_CACHE_RATIO_BASE);
                    if (entry != null) {
                        PerfCounters.IncrementCounter(AppPerfCounter.API_CACHE_HITS);
                    }
                    else {
                        PerfCounters.IncrementCounter(AppPerfCounter.API_CACHE_MISSES);
                    }
                }

                PerfCounters.IncrementCounter(AppPerfCounter.TOTAL_CACHE_RATIO_BASE);
                if (entry != null) {
                    PerfCounters.IncrementCounter(AppPerfCounter.TOTAL_CACHE_HITS);
                }
                else {
                    PerfCounters.IncrementCounter(AppPerfCounter.TOTAL_CACHE_MISSES);
                }

#if DBG
                if (entry != null) {
                    Debug.Trace("CacheUpdate", "Cache hit: " + cacheKey);
                }
                else {
                    Debug.Trace("CacheUpdate", "Cache miss: " + cacheKey);
                }
#endif

            }
            else {
                int totalDelta = 0;
                int publicDelta = 0;
                int totalTurnover = 0;
                int publicTurnover = 0;

                if (oldEntry != null) {
                    if (oldEntry.InExpires()) {
                        _expires.Remove(oldEntry);
                    }

                    if (oldEntry.InUsage()) {
                        _usage.Remove(oldEntry);
                    }
    
                    if (oldEntry.State == CacheEntry.EntryState.RemovingFromCache) {
                        oldEntry.State = CacheEntry.EntryState.RemovedFromCache;

                        valueOld = oldEntry.Value;
                        oldEntry.Close(removedReason);

                        totalDelta--;
                        totalTurnover++;
                        if (oldEntry.IsPublic) {
                            publicDelta--;
                            publicTurnover++;
                        }
                    }

#if DBG
                    Debug.Trace("CacheUpdate", "Entry removed from cache, reason=" + removedReason + ": " + (CacheKey) oldEntry);
#endif
                }
    
                if (newEntry != null) {
                    Debug.Assert(!newEntry.InExpires());
                    Debug.Assert(!newEntry.InUsage());

                    if (newEntry.HasExpiration()) {
                        _expires.Add(newEntry);
                    }

                    if (newEntry.HasUsage() && (
                                // Don't bother to set usage if it's going to expire very soon
                                !newEntry.HasExpiration() || 
                                newEntry.SlidingExpiration > TimeSpan.Zero || 
                                newEntry.UtcExpires - utcNow >= CacheUsage.MIN_LIFETIME_FOR_USAGE)) {

                        _usage.Add(newEntry);
                    }
    
                    newEntry.State = CacheEntry.EntryState.AddedToCache;

                    Debug.Trace("CacheUpdate", "Entry added to cache: " + (CacheKey)newEntry);

                    totalDelta++;
                    totalTurnover++;
                    if (newEntry.IsPublic) {
                        publicDelta++;
                        publicTurnover++;
                    }

                    // listen to change events
                    newEntry.MonitorDependencyChanges();

                    /*
                     * NB: We have to check for dependency changes after we add the item
                     * to cache, because otherwise we may not remove it if it changes 
                     * between the time we check for a dependency change and the time
                     * we set the AddedToCache bit. The worst that will happen is that
                     * a get can occur on an item that has changed, but that can happen
                     * anyway. The important thing is that we always remove an item that
                     * has changed.
                     */
                    if (newEntryDependency != null && newEntryDependency.HasChanged) {
                        Remove(newEntry, CacheItemRemovedReason.DependencyChanged);
                    }
                }

                // update counts and counters
                if (totalDelta == 1) {
                    Interlocked.Increment(ref _totalCount);
                    PerfCounters.IncrementCounter(AppPerfCounter.TOTAL_CACHE_ENTRIES);

                    //ScheduleTrimIfNeeded(false);
                }
                else if (totalDelta == -1) {
                    Interlocked.Decrement(ref _totalCount);
                    PerfCounters.DecrementCounter(AppPerfCounter.TOTAL_CACHE_ENTRIES);
                }

                if (publicDelta == 1) {
                    Interlocked.Increment(ref _publicCount);
                    PerfCounters.IncrementCounter(AppPerfCounter.API_CACHE_ENTRIES);
                }
                else if (publicDelta == -1) {
                    Interlocked.Decrement(ref _publicCount);
                    PerfCounters.DecrementCounter(AppPerfCounter.API_CACHE_ENTRIES);
                }

                if (totalTurnover > 0) {
                    PerfCounters.IncrementCounterEx(AppPerfCounter.TOTAL_CACHE_TURNOVER_RATE, totalTurnover);
                }

                if (publicTurnover > 0) {
                    PerfCounters.IncrementCounterEx(AppPerfCounter.API_CACHE_TURNOVER_RATE, publicTurnover);
                }
            }

            return entry;
        }

        void UtcUpdateUsageRecursive(CacheEntry entry, DateTime utcNow) {
            CacheDependency dependency;
            CacheEntry[]    entries;

            // Don't update if the last update is less than 1 sec away.  This way we'll
            // avoid over updating the usage in the scenario where a cache makes several
            // update requests.
            if (utcNow - entry.UtcLastUsageUpdate > CacheUsage.CORRELATED_REQUEST_TIMEOUT) {
                entry.UtcLastUsageUpdate = utcNow;
                if (entry.InUsage()) {
                    CacheSingle cacheSingle;
                    if (_cacheMultiple == null) {
                        cacheSingle = this;
                    }
                    else {
                        cacheSingle = _cacheMultiple.GetCacheSingle(entry.Key.GetHashCode());
                    }

                    cacheSingle._usage.Update(entry);
                }

                dependency = entry.Dependency;
                if (dependency != null) {
                    entries = dependency.CacheEntries;
                    if (entries != null) {
                        foreach (CacheEntry dependent in entries) {
                            UtcUpdateUsageRecursive(dependent, utcNow);
                        }
                    }
                }
            }
        }

        internal override void ReviewMemoryStats() {
            int pressureLast = _cacheMemoryStats.PressureLast;
            int pressureAvg = _cacheMemoryStats.PressureAvg;
            int pressureHigh =  _cacheMemoryStats.PressureHigh;
            int pressureLow =  _cacheMemoryStats.PressureLow;
            int pressureMiddle =  _cacheMemoryStats.PressureMiddle;

            if (pressureLast > pressureHigh) {
                GcCollect();
            }
            
            if (UtcGrabTrimLock(DateTime.UtcNow)) {
                int newMaxCount = _maxCount;
                int count = _totalCount;
                int minCount = Math.Min(count, _maxCount);

                if (pressureLast > pressureHigh) {
                    if (pressureAvg > pressureHigh) {
                        newMaxCount = Math.Min(count / 2, _maxCount);
                    }
                    else {
                        newMaxCount = Math.Min((2 * count) / 3, _maxCount);
                    }
                }
                else if (pressureLast > pressureMiddle) {
                    if (pressureLast > pressureAvg) {
                        int rate = (pressureLast - pressureAvg) * 100 / pressureAvg;
                        
                        if (rate >= 5) {
                            newMaxCount = Math.Min((95 * count) / 100, _maxCount);
                        } 
                        else if (rate >= 2) {
                            newMaxCount = Math.Min((97 * count) / 100, _maxCount);
                        } 
                        else if (pressureAvg > pressureMiddle) {
                            newMaxCount = Math.Min(count, _maxCount);
                        }
                    }
                }
                else if (pressureLast > pressureLow) {
                    if (pressureAvg < pressureMiddle) {
                        int maxPressure = Math.Max(pressureAvg, pressureLast);
                        newMaxCount = minCount + (((pressureMiddle - maxPressure) * minCount) / 3) / 100;
                    }
                }
                else {
                    if (pressureAvg < pressureLow && count > (4 * _maxCount) / 5) {
                        newMaxCount = (6 * count) / 5;
                    }
                }

                newMaxCount = Math.Max(newMaxCount, MIN_COUNT);
                newMaxCount = Math.Min(newMaxCount, MAX_COUNT);

                if (newMaxCount != _maxCount) {
                    _maxCount = newMaxCount;
                    _maxCountOverload = _maxCount + MAX_OVERLOAD_COUNT;
                }

#if DBG
                if (HttpRuntime.AppDomainAppIdInternal != null && HttpRuntime.AppDomainAppIdInternal.Length > 0) {
                    Debug.Trace("CacheMemoryUpdate", "Cache " + _iSubCache + ": _maxCount=" + _maxCount + ",_maxCountOverload=" + _maxCountOverload + ",_totalCount=" + _totalCount);
                }
#endif

                ReleaseTrimLock();
            }

            ScheduleTrimIfNeeded(true);
        }


        internal void GcCollect() {
            int     fCallGcCollect = 0;
            int     hr;

            hr = UnsafeNativeMethods.SetGCLastCalledTime(out fCallGcCollect);
            if (hr == 0 && fCallGcCollect != 0) {
#if DBG                
                long memBefore = GC.GetTotalMemory(false) / (1024*1024);
                DateTime utcNow1 = DateTime.UtcNow;
                int pressureLast = _cacheMemoryStats.PressureLast;
                int pressureAvg = _cacheMemoryStats.PressureAvg;
                int pressureHigh =  _cacheMemoryStats.PressureHigh;
                int pressureLow =  _cacheMemoryStats.PressureLow;
                int pressureMiddle =  _cacheMemoryStats.PressureMiddle;
#endif
                GC.Collect();
#if DBG                
                Debug.Trace("InternalGcCollect", "GC.Collect() called; time = " + DateTime.UtcNow.ToLocalTime() +
                    "; Total duration = " + (DateTime.UtcNow - utcNow1));
                Debug.Trace("InternalGcCollect", "Memory pressure: last=" + pressureLast + ",avg=" + pressureAvg + ",high=" + pressureHigh + ",low=" + pressureLow + ",middle=" + pressureMiddle + "; Now is " + DateTime.UtcNow.ToLocalTime());

                GC.WaitForPendingFinalizers();
                long memAfter = GC.GetTotalMemory(false) / (1024*1024);
                Debug.Trace("InternalGcCollect", "Memory shrinked by " + (memBefore - memAfter) * 100 / memBefore + " %;"
                    + " Before = " + memBefore + "; After = " + memAfter);
#endif
            }
        }


        void ScheduleTrimIfNeeded(bool force) {
            if (_totalCount <= _maxCount)
                return;

            bool    highPressure = _cacheMemoryStats.PressureLast > _cacheMemoryStats.PressureHigh;

            if (force || _totalCount > _maxCountOverload) {
                DateTime utcNow = DateTime.UtcNow;
                DateTime utcDateToCompare = highPressure ? 
                            _utcDateLastCollectedHiPressure : 
                            _utcDateLastCollected;
                                    
                if (    utcNow - utcDateToCompare > MIN_TRIM_DELTA
                        && UtcGrabTrimLock(utcNow)) {

                    utcDateToCompare = highPressure ? 
                                    _utcDateLastCollectedHiPressure : 
                                    _utcDateLastCollected;
                                    
                    if (    _totalCount > _maxCount &&
                            utcNow - utcDateToCompare > MIN_TRIM_DELTA) {

#if DBG
                        if (highPressure) {
                            int pressureLast = _cacheMemoryStats.PressureLast;
                            int pressureAvg = _cacheMemoryStats.PressureAvg;
                            int pressureHigh =  _cacheMemoryStats.PressureHigh;
                            int pressureLow =  _cacheMemoryStats.PressureLow;
                            int pressureMiddle =  _cacheMemoryStats.PressureMiddle;
                            Debug.Trace("CacheMemoryUpdateHighPressure", "Cache " + _iSubCache + ": _maxCount=" + _maxCount + ",_maxCountOverload=" + _maxCountOverload + ",_totalCount=" + _totalCount);
                            Debug.Trace("CacheMemoryUpdateHighPressure", "Memory pressure: last=" + pressureLast + ",avg=" + pressureAvg + ",high=" + pressureHigh + ",low=" + pressureLow + ",middle=" + pressureMiddle + "; Now is " + DateTime.UtcNow.ToLocalTime());
                        }
#endif                  

                        if (highPressure) {
                            _utcDateLastCollectedHiPressure = DateTime.UtcNow;
                        }
                        else {
                            _utcDateLastCollected = DateTime.UtcNow;
                        }
                        
                        WorkItem.PostInternal(_trimCallback);
                    }
                    else {
                        ReleaseTrimLock();
                    }
                }
            }
        }

        bool UtcGrabTrimLock(DateTime utcNow) {
            if (_inTrim == 1 && utcNow - _utcInTrimLockDate > TRIM_TIMEOUT) {
                // reset if timed out
                Interlocked.Exchange(ref _inTrim, 0);
            }

            if (Interlocked.CompareExchange(ref _inTrim, 1, 0) == 0) {
                _utcInTrimLockDate = utcNow;
                return true;
            }

            return false;
        }

        void ReleaseTrimLock() {
            Interlocked.Exchange(ref _inTrim, 0);
        }

        void Trim() {
            Debug.Assert(_inTrim == 1, "_inTrim == 1");
            int toFlush = _totalCount - _maxCount;
            if (toFlush > 0) {
                Debug.Trace("CacheMemoryTrim", "Trimming " +  toFlush + " from cache");
                int flushed = _usage.FlushUnderUsedItems(toFlush);
                Debug.Trace("CacheMemoryTrim", "Trim completed, flushed " + flushed + " from cache");
            }

            ReleaseTrimLock();

        }
    }

    class CacheMultiple : CacheInternal {
        int             _disposed;
        CacheSingle[]   _caches;
        int             _cacheIndexMask;

        internal CacheMultiple(Cache cachePublic, CacheMemoryStats cacheMemoryStats, int numSingleCaches) : base(cachePublic, cacheMemoryStats) {
            Debug.Assert(numSingleCaches > 1, "numSingleCaches is not greater than 1");
            Debug.Assert((numSingleCaches & (numSingleCaches - 1)) == 0, "numSingleCaches is not a power of 2");
            _cacheIndexMask = numSingleCaches - 1;
            _caches = new CacheSingle[numSingleCaches];
            for (int i = 0; i < numSingleCaches; i++) {
                _caches[i] = new CacheSingle(cachePublic, cacheMemoryStats, this, i);
            }
        }

        protected override void Dispose(bool disposing) {
            if (disposing) {
                if (Interlocked.Exchange(ref _disposed, 1) == 0) {
                    foreach (CacheSingle cacheSingle in _caches) {
                        cacheSingle.Dispose();
                    }
                }
            }

            base.Dispose(disposing);
        }

        internal override int PublicCount {
            get {
                int count = 0;
                foreach (CacheSingle cacheSingle in _caches) {
                    count += cacheSingle.PublicCount;
                }

                return count;
            }
        }
    
        internal override IDictionaryEnumerator CreateEnumerator() {
            IDictionaryEnumerator[] enumerators = new IDictionaryEnumerator[_caches.Length];
            for (int i = 0, c = _caches.Length; i < c; i++) {
                enumerators[i] = _caches[i].CreateEnumerator();
            }

            return new AggregateEnumerator(enumerators);
        }


        internal CacheSingle GetCacheSingle(int hashCode) {
            Debug.Assert(_caches != null && _caches.Length != 0);

            int index = (hashCode & _cacheIndexMask);
            return _caches[index];
        }

        internal override CacheEntry UpdateCache(
                CacheKey cacheKey,
                CacheEntry newEntry, 
                bool replace, 
                CacheItemRemovedReason removedReason, 
                out object valueOld) {

            int hashCode = cacheKey.Key.GetHashCode();
            CacheSingle cacheSingle = GetCacheSingle(hashCode);
            return cacheSingle.UpdateCache(cacheKey, newEntry, replace, removedReason, out valueOld);
        }

        internal override void ReviewMemoryStats() {
            foreach (CacheSingle cacheSingle in _caches) {
                cacheSingle.ReviewMemoryStats();
            }
        }
    }

    class AggregateEnumerator : IDictionaryEnumerator {
        IDictionaryEnumerator []    _enumerators; 
        int                         _iCurrent;

        internal AggregateEnumerator(IDictionaryEnumerator [] enumerators) {
            _enumerators = enumerators;
        }

        public bool MoveNext() {
            bool more;

            for (;;) {
                more = _enumerators[_iCurrent].MoveNext();
                if (more)
                    break;

                if (_iCurrent == _enumerators.Length - 1)
                    break;

                _iCurrent++;
            }

            return more;
        }

        public void Reset() {
            for (int i = 0; i <= _iCurrent; i++) {
                _enumerators[i].Reset();
            }

            _iCurrent = 0;
        }

        public Object Current {
            get {
                return _enumerators[_iCurrent].Current;
            }
        }

        public Object Key {
            get {
                return _enumerators[_iCurrent].Key;
            }
        }

        public Object Value {
            get {
                return _enumerators[_iCurrent].Value;
            }
        }

    	public DictionaryEntry Entry {
            get {
                return _enumerators[_iCurrent].Entry;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\cache\cacheentry.cs ===
//------------------------------------------------------------------------------
// <copyright file="CacheEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * CacheEntry
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

namespace System.Web.Caching {
    using System.Text;
    using System.Threading;

    using System.Web;
    using System.Web.Util;
    using System.Collections;

    internal class CacheKey {
        protected const byte BitPublic = 0x20;

        protected string    _key;   /* key to the item */
        protected byte      _bits;  /* cache lifetime state and public property */

        internal CacheKey(String key, bool isPublic) {
            if (key == null) {
                throw new ArgumentNullException("key");
            }
    
            _key = key;
            if (isPublic) {
                _bits = BitPublic;
            }
        }

        internal String Key {
            get {return _key;}
        }

        internal bool IsPublic {
            get { return (_bits & BitPublic) != 0; }
        }

#if DBG
        public override string ToString() {
            return (IsPublic ? "P:" : "I:") + _key;
        }
#endif
    }

    /*
     * An entry in the cache.
     * Overhead is 68 bytes + object header.
     */
    internal sealed class CacheEntry : CacheKey {
        static readonly DateTime    NoAbsoluteExpiration = DateTime.MaxValue;
        static readonly TimeSpan    NoSlidingExpiration = TimeSpan.Zero;
        const CacheItemPriority     CacheItemPriorityMin = CacheItemPriority.Low;
        const CacheItemPriority     CacheItemPriorityMax = CacheItemPriority.NotRemovable;
        static readonly TimeSpan    OneYear = new TimeSpan(365, 0, 0, 0);


        internal enum EntryState : byte {
            NotInCache         = 0x00,  // Created but not in hashtable
            AddingToCache      = 0x01,  // In hashtable only
            AddedToCache       = 0x02,  // In hashtable + expires + usage
            RemovingFromCache  = 0x04,  // Removed from hashtable only
            RemovedFromCache   = 0x08,  // Removed from hashtable & expires & usage
            Closed             = 0x10, 
        }

        const byte EntryStateMask   = 0x1f;
//        protected const byte BitPublic = 0x20;

        // item
        object                      _value;                 /* value */
        DateTime                    _utcCreated;            /* creation date */


        // expiration
        DateTime                    _utcExpires;            /* when this item expires */
        TimeSpan                    _slidingExpiration;     /* expiration interval */
        byte                        _expiresBucket;         /* index of the expiration list (bucket) */
        internal int                _expiresIndex;          /* index into the expiration list */

        // usage
        byte                        _usageBucket;           /* index of the usage list (== priority-1) */
        int                         _usageIndex;            /* index into the usage list */
        DateTime                    _utcLastUpdate;         /* time we last updated usage */

        // dependencies
        CacheDependency             _dependency;            /* dependencies this item has */
        object                      _onRemovedTargets;      /* targets of OnRemove notification */
        ReadWriteSpinLock           _lockTargets;           /* lock for targets */

        
            
        /*
         * ctor.
         */

        internal CacheEntry(
                   String                   key, 
                   Object                   value, 
                   CacheDependency          dependency,
                   CacheItemRemovedCallback onRemovedHandler,
                   DateTime                 utcAbsoluteExpiration,              
                   TimeSpan                 slidingExpiration,      
                   CacheItemPriority        priority,
                   bool                     isPublic) : 

                base(key, isPublic) {

            if (value == null) {
                throw new ArgumentNullException("value");
            }

            if (slidingExpiration < TimeSpan.Zero || OneYear < slidingExpiration) {
                throw new ArgumentOutOfRangeException("slidingExpiration");
            }

            if (utcAbsoluteExpiration != Cache.NoAbsoluteExpiration && slidingExpiration != Cache.NoSlidingExpiration) {
                throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Invalid_expiration_combination));
            }

            if (priority < CacheItemPriorityMin || CacheItemPriorityMax < priority) {
                throw new ArgumentOutOfRangeException("priority");
            }

            _value = value;
            _dependency = dependency;
            _onRemovedTargets = onRemovedHandler;

            _utcCreated = DateTime.UtcNow;
            _slidingExpiration = slidingExpiration;
            if (_slidingExpiration > TimeSpan.Zero) {
                _utcExpires = _utcCreated + _slidingExpiration;
            }
            else {
                _utcExpires = utcAbsoluteExpiration;
            } 

            _expiresIndex = -1;
            _expiresBucket = 0xff;

            _usageIndex = -1;
            if (priority == CacheItemPriority.NotRemovable) {
                _usageBucket = 0xff;
            }
            else {
                _usageBucket = (byte) (priority - 1);
            }
        }

        internal Object Value {
            get {return _value;}
        }

        internal DateTime UtcCreated {
            get {return _utcCreated;}
        }

        internal EntryState State {
            get { return (EntryState) (_bits & EntryStateMask); }
            set { _bits = (byte) (((uint) _bits & ~(uint)EntryStateMask) | (uint) value); }
        }

        internal DateTime UtcExpires {
            get {return _utcExpires;}
            set {_utcExpires = value;}
        }

        internal TimeSpan SlidingExpiration {
            get {return _slidingExpiration;}
        }

        internal byte ExpiresBucket {
            get {return _expiresBucket;}
            set {_expiresBucket = value;}
        }

        internal int ExpiresIndex {
            get {return _expiresIndex;}
            set {_expiresIndex = value;}
        }

        internal bool HasExpiration() {
            return _utcExpires < DateTime.MaxValue;
        }

        internal bool InExpires() {
            return _expiresIndex != -1;
        }

        internal byte UsageBucket {
            get {return _usageBucket;}
            set {_usageBucket = value;}
        }

        internal int UsageIndex {
            get {return _usageIndex;}
            set {_usageIndex = value;}
        }

        internal DateTime UtcLastUsageUpdate {
            get {return _utcLastUpdate;}
            set {_utcLastUpdate = value;}
        }

        internal bool HasUsage() {
            return _usageBucket != 0xff;
        }

        internal bool InUsage() {
            return _usageIndex != -1;
        }

        internal CacheDependency Dependency {
            get {return _dependency;}
        }

        internal void MonitorDependencyChanges() {
            // need to protect against the item being closed
            CacheDependency dependency = _dependency;
            if (dependency != null && State == EntryState.AddedToCache) {
                if (!dependency.Use()) {
                    throw new InvalidOperationException(SR.Cache_dependency_used_more_that_once);
                }

                dependency.AddCacheEntryNotify(this);
            }
        }

        /*
         * The entry has changed, so remove ourselves from the cache.
         */
        internal void OnChanged(Object sender, EventArgs e) {
            if (State == EntryState.AddedToCache) {
                HttpRuntime.CacheInternal.Remove(this, CacheItemRemovedReason.DependencyChanged);
            }
        }

        /*
         * Helper to call the on-remove callback
         */

        private void CallCacheItemRemovedCallback(CacheItemRemovedCallback callback, CacheItemRemovedReason reason) {
            if (IsPublic) {
                try {
                    // for public need to impersonate if called outside of request context
                    HttpContext.ImpersonationData impersonation = null;
                    if (HttpContext.Current == null) {
                        impersonation = HttpContext.GetAppLevelImpersonation();
                        impersonation.Start(true /*forGlobalCode*/, false /*throwOnError*/);
                    }

                    try {
                        callback(_key, _value, reason);
                    }
                    finally {
                        if (impersonation != null)
                            impersonation.Stop();
                    }
                }
                catch (Exception e) {
                    // for public need to report application error
                    HttpApplicationFactory.RaiseError(e);
                }
            }
            else {
                // for private items just make the call and eat any exceptions
                try {
                    callback(_key, _value, reason);
                }
                catch {
                }
            }
        }

        /*
         * Close the item to complete its removal from cache.
         * 
         * @param reason The reason the item is removed.
         */
        internal void Close(CacheItemRemovedReason reason) {
            Debug.Assert(State == EntryState.RemovedFromCache, "State == EntryState.RemovedFromCache");
            State = EntryState.Closed;

            object      onRemovedTargets = null;
            object[]    targets = null;

            _lockTargets.AcquireWriterLock();
            try {
                if (_onRemovedTargets != null) {
                    onRemovedTargets = _onRemovedTargets;
                    if (onRemovedTargets is Hashtable) {
                        ICollection col = ((Hashtable) onRemovedTargets).Keys;
                        targets = new object[col.Count];
                        col.CopyTo(targets, 0);
                    }
                }
            }
            finally {
                _lockTargets.ReleaseWriterLock();
            }

            if (onRemovedTargets != null) {
                if (targets != null) {
                    foreach (object target in targets) {
                        if (target is CacheDependency) {
                            ((CacheDependency)target).ItemRemoved();
                        }
                        else {
                            CallCacheItemRemovedCallback((CacheItemRemovedCallback) target, reason);
                        }
                    }
                }
                else if (onRemovedTargets is CacheItemRemovedCallback) {
                    CallCacheItemRemovedCallback((CacheItemRemovedCallback) onRemovedTargets, reason);
                }
                else {
                    ((CacheDependency) onRemovedTargets).ItemRemoved();
                }
            }

            if (_dependency != null) {
                _dependency.DisposeInternal();
            }
        }

#if DBG
        internal /*public*/ string DebugDescription(string indent) {
            StringBuilder sb = new StringBuilder();
            String      nlindent = "\n" + indent + "    ";

            sb.Append(indent + "CacheItem");
            sb.Append(nlindent); sb.Append("_key=");        sb.Append(_key);
            sb.Append(nlindent); sb.Append("_value=");      sb.Append(Debug.GetDescription(_value, indent));
            sb.Append(nlindent); sb.Append("_utcExpires="); sb.Append(DateTimeUtil.ConvertToLocalTime(_utcExpires));
            sb.Append(nlindent); sb.Append("_bits=0x");     sb.Append(((int)_bits).ToString("x"));
            sb.Append("\n");

            return sb.ToString();
        }
#endif

        internal void AddCacheDependencyNotify(CacheDependency dependency) {
            _lockTargets.AcquireWriterLock();
            try {
                if (_onRemovedTargets == null) {
                    _onRemovedTargets = dependency;
                }
                else if (_onRemovedTargets is Hashtable) {
                    Hashtable h = (Hashtable) _onRemovedTargets;
                    h[dependency] = dependency;
                }
                else {
                    Hashtable h = new Hashtable(2);
                    h[_onRemovedTargets] = _onRemovedTargets;
                    h[dependency] = dependency;
                    _onRemovedTargets = h;
                }
            }
            finally {
                _lockTargets.ReleaseWriterLock();
            }
            
        }

        internal void RemoveCacheDependencyNotify(CacheDependency dependency) {
            _lockTargets.AcquireWriterLock();
            try {
                if (_onRemovedTargets != null) {
                    if (_onRemovedTargets == dependency) {
                        _onRemovedTargets = null;
                    }
                    else {
                        // We assume the dependency must exist, so we don't need
                        // to test for a cast.
                        Hashtable h = (Hashtable) _onRemovedTargets;
                        h.Remove(dependency);
                        if (h.Count == 0) {
                            _onRemovedTargets = null;
                        }
                    }
                }
            }
            finally {
                _lockTargets.ReleaseWriterLock();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\cache\cachedependency.cs ===
//------------------------------------------------------------------------------
// <copyright file="CacheDependency.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * CacheDependency.cs
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */


namespace System.Web.Caching {
    using System.Collections;
    using System.IO;
    using System.Threading;
    using System.Web.Util;
    using System.Security.Permissions;

    /// <include file='doc\CacheDependency.uex' path='docs/doc[@for="CacheDependency"]/*' />
    /// <devdoc>
    /// <para>The <see langword='CacheDependency'/> class tracks cache dependencies, which can be files, 
    ///    directories, or keys to other objects in the System.Web.Cache.Cache. When an object of this class
    ///    is constructed, it immediately begins monitoring objects on which it is
    ///    dependent for changes. This avoids losing the changes made between the time the
    ///    object to cache is created and the time it is inserted into the
    /// <see langword='Cache'/>.</para>
    /// </devdoc>

    // Overhead is 24 bytes + object header
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class CacheDependency : IDisposable {
        object                     _filenames;             /* List of files to monitor for changes */
        object                     _entries;               /* List of cache entries we are dependent on */
        CacheEntry                 _entryNotify;           /* Associated CacheEntry to notify when a change occurs */
        int                        _bits;                  /* status bits for ready, used, changed, disposed  */
        DateTime                   _utcInitTime;           /* Time monitoring started, to ignore notifications from the past */ 

        static readonly string[]        s_stringsEmpty;
        static readonly CacheEntry[]    s_entriesEmpty;
        static readonly CacheDependency s_dependencyEmpty;

        const int READY     = 0x01;
        const int USED      = 0x02;
        const int CHANGED   = 0x04;
        const int DISPOSED  = 0x08;
        const int SENSITIVE = 0x10;

        static CacheDependency() {
            s_stringsEmpty = new string[0];
            s_entriesEmpty = new CacheEntry[0];
            s_dependencyEmpty = new CacheDependency();
        }

        private CacheDependency() {
        }

        /// <include file='doc\CacheDependency.uex' path='docs/doc[@for="CacheDependency.CacheDependency"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the System.Web.Cache.CacheDependency class. The new instance 
        ///    monitors a file or directory for changes.</para>
        /// </devdoc>
        public CacheDependency(string filename) :
            this (filename, DateTime.MaxValue) {
        }
            
        /// <include file='doc\CacheDependency.uex' path='docs/doc[@for="CacheDependency.CacheDependency3"]/*' />
        public CacheDependency(string filename, DateTime start) {
            if (filename == null) {
                return;
            }

            DateTime utcStart = DateTimeUtil.ConvertToUniversalTime(start);
            string[] filenames = new string[1] {filename};
            Init(true, false, filenames, null, null, utcStart);

        }

        /// <include file='doc\CacheDependency.uex' path='docs/doc[@for="CacheDependency.CacheDependency1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the System.Web.Cache.CacheDependency class. The new instance monitors an array 
        ///    files or directories for changes.</para>
        /// </devdoc>
        public CacheDependency(string[] filenames) {
            Init(true, false, filenames, null, null, DateTime.MaxValue);
        }

        /// <include file='doc\CacheDependency.uex' path='docs/doc[@for="CacheDependency.CacheDependency4"]/*' />
        public CacheDependency(string[] filenames, DateTime start) {
            DateTime utcStart = DateTimeUtil.ConvertToUniversalTime(start);
            Init(true, false, filenames, null, null, utcStart);
        }

        /// <include file='doc\CacheDependency.uex' path='docs/doc[@for="CacheDependency.CacheDependency2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the System.Web.Cache.CacheDependency class. The new instance monitors an 
        ///    array files, directories, and cache keys for changes.</para>
        /// </devdoc>
        public CacheDependency(string[] filenames, string[] cachekeys) {
            Init(true, false, filenames, cachekeys, null, DateTime.MaxValue);
        }

        /// <include file='doc\CacheDependency.uex' path='docs/doc[@for="CacheDependency.CacheDependency5"]/*' />
        public CacheDependency(string[] filenames, string[] cachekeys, DateTime start) {
            DateTime utcStart = DateTimeUtil.ConvertToUniversalTime(start);
            Init(true, false, filenames, cachekeys, null, utcStart);
        }

        /// <include file='doc\CacheDependency.uex' path='docs/doc[@for="CacheDependency.CacheDependency6"]/*' />
        public CacheDependency(string[] filenames, string[] cachekeys, CacheDependency dependency) {
            Init(true, false, filenames, cachekeys, dependency, DateTime.MaxValue);
        }

        /// <include file='doc\CacheDependency.uex' path='docs/doc[@for="CacheDependency.CacheDependency7"]/*' />
        public CacheDependency(string[] filenames, string[] cachekeys, CacheDependency dependency, DateTime start) {
            DateTime utcStart = DateTimeUtil.ConvertToUniversalTime(start);
            Init(true, false, filenames, cachekeys, dependency, utcStart);
        }

        internal CacheDependency(bool isSensitive, string filename) :
            this(isSensitive, filename, DateTime.MaxValue) {
        }
            
        internal CacheDependency(bool isSensitive, string filename, DateTime utcStart) {
            if (filename == null) {
                return;
            }

            string[] filenames = new string[1] {filename};
            Init(false, isSensitive, filenames, null, null, utcStart);

        }

        internal CacheDependency(bool isSensitive, string[] filenames) {
            Init(false, isSensitive, filenames, null, null, DateTime.MaxValue);
        }

        internal CacheDependency(bool isSensitive, string[] filenames, DateTime utcStart) {
            Init(false, isSensitive, filenames, null, null, utcStart);
        }

        internal CacheDependency(bool isSensitive, string[] filenames, string[] cachekeys) {
            Init(false, isSensitive, filenames, cachekeys, null, DateTime.MaxValue);
        }

        internal CacheDependency(bool isSensitive, string[] filenames, string[] cachekeys, DateTime utcStart) {
            Init(false, isSensitive, filenames, cachekeys, null, utcStart);
        }

        internal CacheDependency(bool isSensitive, string[] filenames, string[] cachekeys, CacheDependency dependency) {
            Init(false, isSensitive, filenames, cachekeys, dependency, DateTime.MaxValue);
        }

        internal CacheDependency(bool isSensitive, string[] filenames, string[] cachekeys, CacheDependency dependency, DateTime utcStart) {
            Init(false, isSensitive, filenames, cachekeys, dependency, utcStart);
        }

        void Init(bool isPublic, bool isSensitive, string[] filenamesArg, string[] cachekeysArg, CacheDependency dependency, DateTime utcStart) {
            string[]        depFilenames = s_stringsEmpty;
            CacheEntry[]    depEntries = s_entriesEmpty;
            string []       filenames, cachekeys;
            CacheInternal   cacheInternal;

            Debug.Assert(_bits == 0, "_bits == 0");
            if (isSensitive) {
                _bits = SENSITIVE;
            }

            if (filenamesArg != null) {
                filenames = (string []) filenamesArg.Clone();
            }
            else {
                filenames = null;
            }

            if (cachekeysArg != null) {
                cachekeys = (string []) cachekeysArg.Clone();
            }
            else {
                cachekeys = null;
            }

            _utcInitTime = DateTime.UtcNow;

            try {
                if (filenames != null) {
                    foreach (string f in filenames) {
                        if (f == null) {
                            throw new ArgumentNullException("filenames");
                        }

                        if (isPublic) {
                            InternalSecurityPermissions.PathDiscovery(f).Demand();
                        }
                    }
                }
                else {
                    filenames = s_stringsEmpty;
                }

                if (cachekeys != null) {
                    foreach (string k in cachekeys) {
                        if (k == null) {
                            throw new ArgumentNullException("cachekeys");
                        }
                    }
                }
                else {
                    cachekeys = s_stringsEmpty;
                }

                if (dependency != null) {
                    if ((dependency._bits & CHANGED) != 0) {
                        SetBit(CHANGED);
                        return;
                    }

                    if (dependency._filenames != null) {
                        if (dependency._filenames is string) {
                            depFilenames = new string[1] {(string) dependency._filenames};
                        }
                        else {
                            depFilenames = (string[]) (dependency._filenames);
                        }
                    }

                    if (dependency._entries != null) {
                        if (dependency._entries is CacheEntry) {
                            depEntries = new CacheEntry[1] {(CacheEntry) (dependency._entries)};
                        }
                        else {
                            depEntries = (CacheEntry[]) (dependency._entries);
                        }
                    }
                }
                else {
                    dependency = s_dependencyEmpty;
                }

                int lenMyFilenames = depFilenames.Length + filenames.Length;
                if (lenMyFilenames > 0) {
                    string[] myFilenames = new string[lenMyFilenames];
                    FileChangeEventHandler handler = new FileChangeEventHandler(this.FileChange);
                    FileChangesMonitor fmon = HttpRuntime.FileChangesMonitor;
                    int i = 0;
                    foreach (string f in depFilenames) {
                        fmon.StartMonitoringPath(f, handler);
                        myFilenames[i++] = f;
                    }

                    foreach (string f in filenames) {
                        DateTime utcLastWrite = fmon.StartMonitoringPath(f, handler);
                        myFilenames[i++] = f;

                        if (utcStart < DateTime.MaxValue) {
                            Debug.Trace("CacheDependencyInit", "file=" + f + "; utcStart=" + utcStart + "; utcLastWrite=" + utcLastWrite);
                            if (utcLastWrite >= utcStart) {
                                Debug.Trace("CacheDependencyInit", "changes occurred since start time for file " + f);
                                SetBit(CHANGED);
                                break;
                            }
                        }
                    }

                    if (myFilenames.Length == 1) {
                        _filenames = myFilenames[0];
                    }
                    else {
                        _filenames = myFilenames;
                    }
                }

                int lenMyEntries = depEntries.Length + cachekeys.Length;
                if (lenMyEntries > 0 && (_bits & CHANGED) == 0) {
                    CacheEntry[] myEntries = new CacheEntry[lenMyEntries];
                    int i = 0;
                    foreach (CacheEntry entry in depEntries) {
                        entry.AddCacheDependencyNotify(this);
                        myEntries[i++] = entry;
                    }

                    cacheInternal = HttpRuntime.CacheInternal;
                    foreach (string k in cachekeys) {
                        CacheEntry entry = (CacheEntry) cacheInternal.DoGet(isPublic, k, CacheGetOptions.ReturnCacheEntry);
                        if (entry != null) {
                            entry.AddCacheDependencyNotify(this);
                            myEntries[i++] = entry;
                            if (    entry.State != CacheEntry.EntryState.AddedToCache || 
                                    entry.UtcCreated > utcStart) {

#if DBG
                                if (entry.State != CacheEntry.EntryState.AddedToCache) {
                                    Debug.Trace("CacheDependencyInit", "Entry is not in cache, considered changed:" + k);
                                }
                                else {
                                    Debug.Trace("CacheDependencyInit", "Changes occurred to entry since start time:" + k);
                                }
#endif

                                SetBit(CHANGED);
                                break;
                            }
                        }
                        else {
                            Debug.Trace("CacheDependencyInit", "Cache item not found to create dependency on:" + k);
                            SetBit(CHANGED);
                            break;
                        }
                    }

                    if (myEntries.Length == 1) {
                        _entries = myEntries[0];
                    }
                    else {
                        _entries = myEntries;
                    }
                }

                SetBit(READY);
                if ((_bits & CHANGED) != 0 || (dependency._bits & CHANGED) != 0) {
                    SetBit(CHANGED);
                    DisposeInternal();
                }
            }
            catch {
                DisposeInternal();
                throw;
            }
        }

        /// <include file='doc\CacheDependency.uex' path='docs/doc[@for="CacheDependency.Dispose"]/*' />
        public void Dispose() {
            if (Use()) {
                DisposeInternal();
            }
        }

        /*
         * Shutdown all dependency monitoring and firing of OnChanged notification.
         */
        internal void DisposeInternal() {
            if (SetBit(DISPOSED)) {
                if (_filenames != null) {
                    FileChangesMonitor fmon = HttpRuntime.FileChangesMonitor;

                    string oneFilename = _filenames as string;
                    if (oneFilename != null) {
                        fmon.StopMonitoringPath(oneFilename, this);
                    }
                    else {
                        string[] filenames = (string[]) _filenames;
                        foreach (string filename in filenames) {
                            // ensure that we handle partially contructed
                            // objects by checking filename for null
                            if (filename != null) {
                                fmon.StopMonitoringPath(filename, this);
                            }
                        }
                    }
                }

                if (_entries != null) {
                    CacheEntry oneEntry = _entries as CacheEntry;
                    if (oneEntry != null) {
                        oneEntry.RemoveCacheDependencyNotify(this);
                    }
                    else {
                        CacheEntry[] entries = (CacheEntry[]) _entries;
                        foreach (CacheEntry entry in entries) {
                            // ensure that we handle partially contructed
                            // objects by checking entry for null
                            if (entry != null) {
                                entry.RemoveCacheDependencyNotify(this);
                            }
                        }
                    }
                }

                _entryNotify = null;
            }
        }

        // allow the first user to declare ownership
        internal bool Use() {
            return SetBit(USED);
        }

        /*
         * Has a dependency changed?
         */
        /// <include file='doc\CacheDependency.uex' path='docs/doc[@for="CacheDependency.HasChanged"]/*' />
        public bool HasChanged {
            get {return (_bits & CHANGED) != 0;}
        }

        /*
         * Add/remove an OnChanged notification.
         */
        internal void AddCacheEntryNotify(CacheEntry entry) {
            Debug.Assert(_entryNotify == null, "_entryNotify == null");
            if ((_bits & DISPOSED) == 0) {
                _entryNotify = entry;
            }
        }

        internal CacheEntry[] CacheEntries {
            get {
                if (_entries == null) {
                    return null;
                }

                CacheEntry oneEntry = _entries as CacheEntry;
                if (oneEntry != null) {
                    return new CacheEntry[1] {oneEntry};
                }

                return (CacheEntry[]) _entries;
            }
        }

        /*
         * This object has changed, so fire the OnChanged event.
         * We only allow this event to be fired once.
         */
        void OnChanged(Object sender, EventArgs e) {
            if (SetBit(CHANGED)) {
                CacheEntry entry = _entryNotify;
                if (entry != null && (_bits & DISPOSED) == 0) {
                    entry.OnChanged(sender, e);
                }

                if ((_bits & READY) != 0) {
                    DisposeInternal();
                }
            }
        }

        /*
         * A cache entry has changed.
         */
        internal void ItemRemoved() {
            OnChanged(this, EventArgs.Empty);
        }

        /*
         * FileChange is called when a file we are monitoring has changed.
         */
        void FileChange(Object sender, FileChangeEvent e) {
            // Ignore notifications of events occured in the past, before we started monitoring. 
            // This is to avoid the race with a delayed change notification about the file that
            // the user code just changed before creating the dependency:
            //    1)  User writes to the file
            //    2)  User creates dependency
            //    3)  Change notification comes and needs to be ignored if the timestamp
            //            of the file last access time is earlier than dependency creation time.
            //
            // However, if the cache dependency is marked as sensitive, the above check won't be
            // done.

            Debug.Trace("CacheDependencyFileChange", "FileChange file=" + e.FileName + ";Action=" + e.Action);
            if ( (_bits & SENSITIVE) == 0 && 
                 (e.Action == FileAction.Modified || e.Action == FileAction.Added)) {
                // only check within some window
                const int raceWindowSeconds = 5;

                if (DateTime.UtcNow <= _utcInitTime.AddSeconds(raceWindowSeconds)) {
                    int                 hr;
                    FileAttributesData  fa;
                    
                    hr = FileAttributesData.GetFileAttributes(e.FileName, out fa);
                    if (    hr == HResults.S_OK && 
                            (fa.FileAttributes & UnsafeNativeMethods.FILE_ATTRIBUTE_DIRECTORY) == 0 &&
                            fa.UtcLastAccessTime >= fa.UtcLastWriteTime && // on FAT LastAccessTime is wrong
                            fa.UtcLastAccessTime <= _utcInitTime) {

                        Debug.Trace("CacheDependencyFileChange", "FileChange ignored; fi.LastAccessTime = " + 
                                fa.UtcLastAccessTime.ToLocalTime() + "; fi.LastWriteTime = " + fa.UtcLastWriteTime.ToLocalTime() + 
                                "; _utcInitTime = " + _utcInitTime.ToLocalTime());

                        return; // ignore this notification
                    }
                }
            }

            OnChanged(sender, e);
        }

        bool SetBit(int bit) {
            if ((_bits & bit) != 0)
                return false;

            for (;;) {
                int bits = _bits;
                int result = Interlocked.CompareExchange(ref _bits, bits | bit, bits);
                if (result == bits)
                    return true;

                if ((result & bit) != 0)
                    return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\cache\cacheexpires.cs ===
//------------------------------------------------------------------------------
// <copyright file="CacheExpires.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Caching {
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Threading;
    using System.Web;
    using System.Web.Util;
    using System.Collections;

    
    // overhead is 12 bytes
    [StructLayout(LayoutKind.Explicit)]
    struct ExpiresEntry {
        [FieldOffset(0)]
        internal DateTime    utcExpires;    // expires

        [FieldOffset(0)]
        internal int         next;          // free list

        [FieldOffset(8)]
        internal CacheEntry  cacheEntry;    // cache entry
    }

    sealed class ExpiresBucket {
        const int               MIN_ENTRIES=8;      // must be power of 2.
        readonly CacheExpires   _cacheExpires;

        ReadWriteSpinLock   _lock;
        readonly byte       _bucket;
        ExpiresEntry[]      _entries;
        int                 _freeHead;              // head of list of free slots in _entries, using ref1.next
        int                 _freeTail;              // tail of list of free slots in _entries, using ref1.next
        int                 _cInUse;                // cout of items in use
        int                 _cFree;                 // count of free items
        int                 _cFreeLast;             // count of free items in second half


        internal ExpiresBucket(CacheExpires cacheExpires, byte bucket) {
            _cacheExpires = cacheExpires;
            _bucket = bucket;
            _freeHead = -1;
            _freeTail = -1;

            Debug.Validate("CacheValidateExpires", this);
        }

        int Size {
            get {
                int size;

                if (_entries != null) {
                    size = _entries.Length;
                }
                else {
                    size = 0;
                }

                return size;
            }
        }

        void Expand() {
            Debug.Assert(_freeHead == -1, "_freeHead == -1");
            Debug.Assert(_freeTail == -1, "_freeTail == -1");
            Debug.Assert(_cFree == 0, "_cFree == 0");
            Debug.Assert(_cFreeLast == 0, "_cFreeLast == 0");

            // allocate new buffer
            int oldSize = Size;
            int newSize = Math.Max(oldSize * 2, MIN_ENTRIES);

            ExpiresEntry[] entries = new ExpiresEntry[newSize];

            // copy old contents
            int i, c;
            c = oldSize;
            for (i = 0; i < c; i++) {
                entries[i] = _entries[i];
            }

            // init free list
            i = oldSize;
            c = newSize - oldSize - 1;
            while (c-- > 0) {
                entries[i].next = i + 1;
                i++;
            }

            entries[i].next = -1;

            _freeHead = oldSize;
            _freeTail = i;
            _cFreeLast = newSize / 2;
            _cFree = newSize - oldSize;

            _entries = entries;
        }

        internal void AddCacheEntry(CacheEntry cacheEntry) {
            _lock.AcquireWriterLock();
            try {
                if ((cacheEntry.State & (CacheEntry.EntryState.AddedToCache | CacheEntry.EntryState.AddingToCache)) != 0) {
                    if (_freeHead == -1) {
                        Expand();
                    }
    
                    // use the next free item
                    Debug.Assert(_freeHead != -1, "_freeHead != -1");
                    int index = _freeHead;
                    _freeHead = _entries[index].next;
                    if (_freeHead == -1) {
                        _freeTail = -1;
                    }

                    _cFree--;
                    if (index >= _entries.Length / 2) {
                        _cFreeLast--;
                    }

                    // update expires entry
                    _entries[index].cacheEntry = cacheEntry;
                    _entries[index].utcExpires = cacheEntry.UtcExpires;

                    // update count
                    _cInUse++;

                    // update the cache item
                    cacheEntry.ExpiresIndex = index;
                    cacheEntry.ExpiresBucket = _bucket;

#if DBG 
                    {
                        Debug.Trace("CacheExpiresAdd", 
                                    "Added item=" + cacheEntry.Key + 
                                    ",_bucket=" + _bucket + 
                                    ",_index=" + index + 
                                    ",now=" + DateTime.UtcNow.ToLocalTime() + 
                                    ",expires=" + DateTimeUtil.ConvertToLocalTime(cacheEntry.UtcExpires));
        
                        Debug.Validate("CacheValidateExpires", this);
                        Debug.Dump("CacheExpiresAdd", this);
                    }
#endif
                }

            }
            finally {
                _lock.ReleaseWriterLock();
            }
        }

        void RemoveEntryAtIndex(CacheEntry cacheEntry, int index) {
            Debug.Assert(cacheEntry == _entries[index].cacheEntry, "cacheEntry == _entries[index].cacheEntry");

            int length = _entries.Length;
            int lengthdiv2 = length / 2;
            Debug.Assert((lengthdiv2 & 0x1) == 0, "(lengthdiv2 & 0x1) == 0");

            // update the cache entry
            cacheEntry.ExpiresIndex = -1;
            cacheEntry.ExpiresBucket = 0xff;

            // update the expires entry
            _entries[index].cacheEntry = null;
            _entries[index].utcExpires = DateTime.MinValue;

            // add index to free list
            // if entry is in first half, add to head, else add to tail
            if (_freeHead == -1) {
                _freeHead = _freeTail = index;
                _entries[index].next = -1;
            }
            else if (index < lengthdiv2) {
                _entries[index].next = _freeHead;
                _freeHead = index;
            }
            else {
                _entries[_freeTail].next = index;
                _entries[index].next = -1;
                _freeTail = index;
            }

            // update counts
            _cInUse--;
            _cFree++;
            if (index >= lengthdiv2) {
                _cFreeLast++;
            }

            // check whether we should realloc _entries
            // only realloc if 2nd half is empty
            Debug.Assert(_cFreeLast <= lengthdiv2);
            if (_cInUse == 0) {
                _entries = null;
                _freeHead = -1;
                _freeTail = -1;
                _cFree = 0;
                _cFreeLast = 0;
            }
            else if (    _cFreeLast == lengthdiv2 && 
                    _cInUse * 2 <= lengthdiv2 &&
                    MIN_ENTRIES <= lengthdiv2) {

                int newSize = lengthdiv2;
                Debug.Assert(_freeHead >= 0 && _freeHead < newSize, "_freeHead >= 0 && _freeHead < newSize");

                // alloc and copy to new array
                ExpiresEntry[] entries = new ExpiresEntry[newSize];
                _freeHead = -1;
                _freeTail = -1;
                _cFree = 0;

                // copy the two halves, and count _cFreeLast during the second half
                int i = 0, c = 0;
                for (int halves = 1; halves <= 2; halves++) {
                    _cFreeLast = 0;
                    c += newSize / 2;
                    for (; i < c; i++) {
                        entries[i] = _entries[i];
                        if (entries[i].cacheEntry == null) {
                            _cFree++;
                            _cFreeLast++;
                            // update the free list
                            if (_freeHead == -1) {
                                _freeHead = i;
                            }
                            else {
                                entries[_freeTail].next = i;
                            }

                            _freeTail = i;
                        }
                    }
                }

                Debug.Assert(_freeHead != -1, "_freeHead should not be -1");
                Debug.Assert(_freeTail != -1, "_freeTail should not be -1");

                // terminate the free list
                entries[_freeTail].next = -1;

#if DBG
                for (; i < length; i++) {
                    Debug.Assert(_entries[i].cacheEntry == null, "_entries[i].cacheEntry == null");
                }
#endif

                _entries = entries;

                Debug.Trace("CacheExpiresContract", "Contracted from " + length + " to newSize");
            }
        }

        internal void RemoveCacheEntry(CacheEntry cacheEntry) {
            _lock.AcquireWriterLock();
            try {
                int index = cacheEntry.ExpiresIndex;
                if (cacheEntry.ExpiresBucket == _bucket && index >= 0) {
                    RemoveEntryAtIndex(cacheEntry, index);

                    Debug.Trace("CacheExpiresRemove", 
                                "Removed item=" + cacheEntry.Key + 
                                ",_bucket=" + _bucket + 
                                ",_index=" + index + 
                                ",now=" + DateTime.UtcNow.ToLocalTime() + 
                                ",expires=" + DateTimeUtil.ConvertToLocalTime(cacheEntry.UtcExpires));


                    Debug.Validate("CacheValidateExpires", this);
                    Debug.Dump("CacheExpiresRemove", this);
                }
            }
            finally {
                _lock.ReleaseWriterLock();
            }
        }

        internal void UtcUpdateCacheEntry(CacheEntry cacheEntry, DateTime utcExpires) {
            _lock.AcquireReaderLock();
            try {
                int index = cacheEntry.ExpiresIndex;
                if (cacheEntry.ExpiresBucket == _bucket && index >= 0) {
                    Debug.Assert(cacheEntry == _entries[index].cacheEntry);

                    // update expires entry
                    _entries[index].utcExpires = utcExpires;

                    // update the cache entry
                    cacheEntry.UtcExpires = utcExpires;

                    Debug.Validate("CacheValidateExpires", this);
                    Debug.Trace("CacheExpiresUpdate", "Updated item " + cacheEntry.Key + " in bucket " + _bucket);
                }
            }
            finally {
                _lock.ReleaseReaderLock();
            }
        }

        internal void FlushExpiredItems() {
            Debug.Trace("CacheExpiresFlush", 
                        "Flushing expired items, bucket=" + _bucket + 
                        ",now=" + DateTime.UtcNow.ToLocalTime());

            ArrayList   entriesToRemove = new ArrayList();
            DateTime    utcNow = DateTime.UtcNow;

            _lock.AcquireWriterLock();
            try {
                if (_entries == null)
                    return;

                // create list of expired items
                int c = _cInUse;
                for (int i = 0; c > 0; i++) {
                    CacheEntry cacheEntry = _entries[i].cacheEntry;
                    if (cacheEntry != null) {
                        c--;
                        if (_entries[i].utcExpires <= utcNow) {
                            entriesToRemove.Add(cacheEntry);
                            RemoveEntryAtIndex(cacheEntry, i);
                        }
                    }
                }

                Debug.Validate("CacheValidateExpires", this);
            }
            finally {
                _lock.ReleaseWriterLock();
            }

            // remove expired items from cache
            CacheInternal cacheInternal = _cacheExpires.CacheInternal;
            foreach (CacheEntry cacheEntry in entriesToRemove) {
                Debug.Trace("CacheExpiresFlush", "Flushed item " + cacheEntry.Key + " from bucket " + _bucket);
                cacheInternal.Remove(cacheEntry, CacheItemRemovedReason.Expired);
            }
        }

#if DBG
        internal /*public*/ void DebugValidate() {
            int cInUse = 0;
            int cFree = 0;
            int cFreeLast = 0;
            int size = Size;

            Debug.CheckValid(-1 <= _freeHead && _freeHead <= size, "-1 <= _freeHead && _freeHead <= size");
            Debug.CheckValid(-1 <= _freeTail && _freeTail <= size, "-1 <= _freeTail && _freeTail <= size");

            for (int i = 0; i < size; i++) {
                if (_entries[i].cacheEntry != null) {
                    cInUse++;

                    Debug.CheckValid(_entries[i].cacheEntry.ExpiresIndex == i,
                            "_entries[i].cacheEntry.ExpiresIndex != i" + 
                            ",_entries[i].cacheEntry.ExpiresIndex=" + _entries[i].cacheEntry.ExpiresIndex + 
                            ",i=" + i);

                    Debug.CheckValid(_entries[i].cacheEntry.ExpiresBucket == _bucket,
                            "_entries[i].cacheEntry.ExpiresBucket != _bucket" + 
                            ",_entries[i].cacheEntry.ExpiresBucket=" + _entries[i].cacheEntry.ExpiresBucket + 
                            ",_bucket=" + _bucket);
                }
                else {
                    cFree++;
                    if (i >= size / 2) {
                        cFreeLast++;
                    }

                    Debug.CheckValid((_entries[i].utcExpires.Ticks >> 32) == 0,
                            "(_entries[i].utcExpires >> 32) != 0" + 
                            ",_entries[i].utcExpires=" + DateTimeUtil.ConvertToLocalTime(_entries[i].utcExpires));

                    Debug.CheckValid(-1 <= _entries[i].next && _entries[i].next < size, "-1 <= _entries[i].next && _entries[i].next < size");
                }
            }

            Debug.CheckValid(cFree == _cFree, "cFree == _cFree");
            Debug.CheckValid(cFreeLast == _cFreeLast, "cFreeLast == _cFreeLast");
            Debug.CheckValid(cInUse == _cInUse, "cInUse == _cInUse");
            Debug.CheckValid(cFree + cInUse == size, "cFree + cInUse == size");
            Debug.CheckValid(_cFree >= _cFreeLast, "_cFree >= _cFreeLast");
            Debug.CheckValid(_cFreeLast <= size / 2, "_cFreeLast <= size / 2");

            // check the free list
            int next;
            for (   cFree = 0, next = _freeHead;
                    next != -1;
                    cFree++, next = _entries[next].next) {

                if (cFree > _cFree) {
                    Debug.CheckValid(false, "_entries free list is corrupt, may contain a cycle");
                }
            }
                 
            Debug.CheckValid(cFree == _cFree, "cFree == _cFree");
            if (_freeTail != -1) {
                Debug.CheckValid(_entries[_freeTail].next == -1, "_entries[_freeTail].next == -1");
            }
        }

        internal /*public*/ string DebugDescription(string indent) {
            int             i;
            StringBuilder   sb = new StringBuilder();
            string          i2 = indent + "    ";
            int             size;

            size = Size;
            sb.Append(indent + "_bucket=" + _bucket + ",size=" + size + 
                      ",_cInUse=" + _cInUse + 
                      ",_cFree=" + _cFree + 
                      ",_cFreeLast=" + _cFreeLast + 
                      ",_freeHead=" + _freeHead + 
                      ",_freeTail=" + _freeTail + "\n");

            for (i = 0; i < size; i++) {
                if (_entries[i].cacheEntry != null) {
                    sb.Append(i2 + i + ": expires=" + DateTimeUtil.ConvertToLocalTime(_entries[i].utcExpires) + ",cacheEntry=" + _entries[i].cacheEntry.Key + "\n");
                }
                else {
                    sb.Append(i2 + i + ": next=" + _entries[i].next + "\n");
                }
            }

            return sb.ToString();
        }
#endif
    }

    
    /*
     * Provides an expiration service for entries in the cache.
     * Items with expiration times are placed into a configurable
     * number of buckets. Each minute a bucket is examined for 
     * expired items.
     */
    sealed class CacheExpires {
        internal static readonly TimeSpan MIN_UPDATE_DELTA = new TimeSpan(0, 0, 1);

        const int                   NUMBUCKETS = 60;
        static readonly TimeSpan    SLACK = new TimeSpan(0, 0, 5);
        static readonly TimeSpan[]  _bucketTsFromCycleStart;
        static readonly TimeSpan    _tsPerCycle;
        static readonly TimeSpan    _tsPerBucket;

        readonly CacheInternal      _cacheInternal;
        readonly ExpiresBucket[]    _buckets;
        Timer                       _timer;
        int                         _iFlush;
        ReadWriteSpinLock           _lock;

        unsafe static CacheExpires() {
            Debug.Assert(NUMBUCKETS < Byte.MaxValue);

            _tsPerBucket = new TimeSpan(0, 1, 0);
            _tsPerCycle = new TimeSpan(NUMBUCKETS * _tsPerBucket.Ticks);
            _bucketTsFromCycleStart = new TimeSpan[NUMBUCKETS];

            fixed (TimeSpan * pBucketsFixed = _bucketTsFromCycleStart) {
                TimeSpan * pBucket = pBucketsFixed;
                TimeSpan ts = TimeSpan.Zero;
                int c = NUMBUCKETS;
                while (c-- > 0) {
                    *pBucket = ts;
                    ts += _tsPerBucket;
                    pBucket++;
                }
            }
        }

        internal CacheExpires(CacheInternal cacheInternal) {
            _cacheInternal = cacheInternal;
            _buckets = new ExpiresBucket[NUMBUCKETS];
            for (byte b = 0; b < _buckets.Length; b++) {
                _buckets[b] = new ExpiresBucket(this, b);
            }

            DateTime utcNow = DateTime.UtcNow;
            TimeSpan due = _tsPerBucket - (new TimeSpan(utcNow.Ticks % _tsPerBucket.Ticks));
            DateTime utcFire = utcNow + due;
            _iFlush = (int) (((utcFire.Ticks % _tsPerCycle.Ticks) / _tsPerBucket.Ticks) % NUMBUCKETS);
#if DBG
            if (!Debug.IsTagPresent("Timer") || Debug.IsTagEnabled("Timer")) 
#endif
            {
                _timer = new Timer(new TimerCallback(this.TimerCallback), null, due.Ticks / TimeSpan.TicksPerMillisecond, Msec.ONE_MINUTE);
            }
        }

        int UtcCalcExpiresBucket(DateTime utcDate) {
            // give some slack so we are sure that items added just before
            // a timer fires are collected
            utcDate += SLACK;

            long    ticksFromCycleStart = utcDate.Ticks % _tsPerCycle.Ticks;
            int     bucket = (int) (((ticksFromCycleStart / _tsPerBucket.Ticks) + 1) % NUMBUCKETS);

            return bucket;
        }

        void TimerCallback(object state) {
            int bucket;
            _lock.AcquireWriterLock();
            try {
                bucket = _iFlush;
                _iFlush = (_iFlush + 1) % NUMBUCKETS;
            }
            finally {
                _lock.ReleaseWriterLock();
            }

            _buckets[bucket].FlushExpiredItems();
            Debug.Dump("CacheExpiresFlush", this);
        }

        internal void Dispose() {
            if (_timer != null) {
                _timer.Dispose();
                _timer = null;
                Debug.Trace("CacheDispose", "CacheExpires timer disposed");
            }
        }

        internal CacheInternal CacheInternal {
            get {
                return _cacheInternal;
            }
        }

        /*
         * Adds an entry to the expires list.
         * 
         * @param entry The cache entry to add.
         */
        internal void Add(CacheEntry cacheEntry) {
            DateTime utcNow = DateTime.UtcNow;
            if (utcNow > cacheEntry.UtcExpires) {
                cacheEntry.UtcExpires = utcNow;
            }

            int bucket = UtcCalcExpiresBucket(cacheEntry.UtcExpires);
            _buckets[bucket].AddCacheEntry(cacheEntry);
        }

        /*
         * Removes an entry from the expires list.
         * 
         * @param entry The cache entry to remove.
         */
        internal void Remove(CacheEntry cacheEntry) {
            byte bucket = cacheEntry.ExpiresBucket;
            if (bucket != 0xff) {
                _buckets[bucket].RemoveCacheEntry(cacheEntry);
            }
        }

        /*
         * Updates an entry.
         * 
         */
        internal void UtcUpdate(CacheEntry cacheEntry, DateTime utcNewExpires) {
            int oldBucket = cacheEntry.ExpiresBucket;
            int newBucket = UtcCalcExpiresBucket(utcNewExpires);
            
            if (oldBucket != newBucket) {
                Debug.Trace("CacheExpiresUpdate", 
                            "Updating item " + cacheEntry.Key + " from bucket " + oldBucket + " to new bucket " + newBucket);

                if (oldBucket != 0xff) {
                    _buckets[oldBucket].RemoveCacheEntry(cacheEntry);
                    cacheEntry.UtcExpires = utcNewExpires;
                    _buckets[newBucket].AddCacheEntry(cacheEntry);
                }
            } else {
                if (oldBucket != 0xff) {
                    _buckets[oldBucket].UtcUpdateCacheEntry(cacheEntry, utcNewExpires);
                }
            }
        }


#if DBG
        internal /*public*/ void DebugValidate() {
            int i;

            for (i = 0; i < _buckets.Length; i++) {
                _buckets[i].DebugValidate();
            }
        }

        internal /*public*/ string DebugDescription(string indent) {
            int             i;
            StringBuilder   sb = new StringBuilder();
            string          i2 = indent + "    ";

            sb.Append(indent);
            sb.Append("Cache expires\n");

            for (i = 0; i < _buckets.Length; i++) {
                sb.Append(_buckets[i].DebugDescription(i2));
            }

            return sb.ToString();
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\cache\cacheusage.cs ===
//------------------------------------------------------------------------------
// <copyright file="CacheUsage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Caching {
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Threading;
    using System.Web;
    using System.Web.Util;
    using System.Collections;

    // An entry in the list. If the ptr is non-negative, it points to ref1,
    // else it points to ref2
    struct ListEntry {
        internal int next;
        internal int prev;
    }

    // Overhead is 36 bytes
    struct UsageEntry {
        internal CacheEntry cacheEntry;     // cacheEntry

        // ref1.next is overloaded to be list of free entries when not in use
        internal ListEntry  ref1;           // ref1
        internal ListEntry  ref2;           // ref2 
        internal DateTime   utcDate;        // date usage state changed
                                            //    0: free
                                            //    +: inUse
    }

    sealed class UsageBucket {
        const int           MIN_ENTRIES = 8;        // must be a power of 2

        CacheUsage          _cacheUsage;            // parent usage object.
        byte                _bucket;                // priority of this bucket

        internal UsageEntry[] _entries;             // array of usage information that remains at fixed index
        int                 _freeHead;              // head of list of free slots in _entries, using ref1.next
        int                 _freeTail;              // tail of list of free slots in _entries, using ref1.next
        int                 _cFree;                 // count of free items
        int                 _cFreeLast;             // count of free items in second half
        int                 _cInUse;                // count of items in use

        internal UsageBucket(CacheUsage cacheUsage, byte bucket) {
            _cacheUsage = cacheUsage;
            _bucket = bucket;

            _entries = new UsageEntry[1];
            _freeHead = -1;
            _freeTail = -1;
        }

        void ExpandEntries() {
            Debug.Assert(_freeHead == -1, "_freeHead == -1");
            Debug.Assert(_freeTail == -1, "_freeTail == -1");
            Debug.Assert(_cFree == 0, "_cFree == 0");
            Debug.Assert(_cFreeLast == 0, "_cFreeLast == 0");

            // allocate new array
            int oldSize = _entries.Length;
            int newSize = Math.Max(oldSize * 2, MIN_ENTRIES);
            UsageEntry[] entries = new UsageEntry[newSize];
            
            // copy old contents
            int i;
            for (i = 0; i < oldSize; i++) {
                entries[i] = _entries[i];
            }

            // init free list
            int c = newSize - oldSize - 1;
            while (c-- > 0) {
                entries[i].ref1.next = i + 1;
                i++;
            }

            entries[i].ref1.next = -1;

            _freeHead = oldSize;
            _freeTail = i;

            // replace
            _cFreeLast = newSize / 2;
            _cFree = newSize - oldSize;
            _entries = entries;
            
            Debug.Trace("CacheUsageExpand", "Expanded from " + oldSize + " to newSize");
        }

        internal void AddCacheEntry(CacheEntry cacheEntry) {
            lock (this) {
                if (cacheEntry.State != CacheEntry.EntryState.AddingToCache)
                    return;

                // reserve room for additions
                if (_freeHead == -1) {
                    ExpandEntries();
                }

                Debug.Assert(_freeHead != -1, "_freeHead != -1");
                Debug.Assert(_freeTail != -1, "_freeTail != -1");

                // add index
                int index = _freeHead;
                _freeHead = _entries[index].ref1.next;

#if DBG
                Debug.Assert(_entries[index].utcDate == DateTime.MinValue, "_entries[index].utcDate == DateTime.MinValue");
                Debug.Assert(_entries[index].cacheEntry == null, "_entries[index].cacheEntry == null");

                Debug.Assert(_freeHead != index, "_freeHead != index");
                if (_freeHead != -1) {
                    Debug.Assert(_entries[_freeHead].utcDate == DateTime.MinValue, "_entries[_freeHead].utcDate == DateTime.MinValue");
                    Debug.Assert(_entries[_freeHead].cacheEntry == null, "_entries[_freeHead].cacheEntry == null");
                }
#endif

                if (_freeHead == -1) {
                    _freeTail = -1;
                }

                _cFree--;
                if (index >= _entries.Length / 2) {
                    _cFreeLast--;
                }

                // update the cache entry.
                cacheEntry.UsageIndex = index;

                // initialize index
                _entries[index].cacheEntry = cacheEntry;
                _entries[index].utcDate = DateTime.UtcNow;

                // add to end of list
                int lastRef = _entries[0].ref1.prev;
                Debug.Assert(lastRef <= 0, "lastRef <= 0");
                _entries[index].ref1.prev = lastRef;
                _entries[index].ref1.next = -index;
                _entries[index].ref2.prev = index;
                _entries[index].ref2.next = 0;
                
                if (lastRef == 0) {
                    _entries[0].ref1.next = index;
                }
                else {
                    _entries[-lastRef].ref2.next = index;
                }

                _entries[0].ref1.prev = -index;

                _cInUse++;

                Debug.Trace("CacheUsageAdd", 
                            "Added item=" + cacheEntry.Key + 
                            ",_bucket=" + _bucket + 
                            ",_index=" + index);

                Debug.Validate("CacheValidateUsage", this);
                Debug.Dump("CacheUsageAdd", this);
            }
        }

        void RemoveEntryAtIndex(CacheEntry cacheEntry, int index) {
            int prev, next;
            int length = _entries.Length;
            int lengthdiv2 = length / 2;

            Debug.Assert(cacheEntry == _entries[index].cacheEntry, "cacheEntry == _entries[index].cacheEntry");
            Debug.Assert((lengthdiv2 & 0x1) == 0, "(lengthdiv2 & 0x1) == 0");
            Debug.Assert(index > 0);

            // update the cache entry
            cacheEntry.UsageIndex = -1;

            // update fields
            Debug.Assert(_entries[index].utcDate != DateTime.MinValue, "_entries[index].utcDate != DateTime.MinValue");
            _cInUse--;

            _entries[index].utcDate = DateTime.MinValue;
            _entries[index].cacheEntry = null;

            // remove ref1 from list
            prev = _entries[index].ref1.prev;
            next = _entries[index].ref1.next;
            if (prev >= 0) {
                Debug.Assert(_entries[prev].ref1.next == index, "_entries[prev].ref1.next == index");
                _entries[prev].ref1.next = next;
            }
            else {
                Debug.Assert(_entries[-prev].ref2.next == index, "_entries[-prev].ref2.next == index");
                _entries[-prev].ref2.next = next;
            }

            if (next >= 0) {
                Debug.Assert(_entries[next].ref1.prev == index, "_entries[next].ref1.prev == index");
                _entries[next].ref1.prev = prev;
            }
            else {
                Debug.Assert(_entries[-next].ref2.prev == index, "_entries[-next].ref2.prev");
                _entries[-next].ref2.prev = prev;
            }

            // remove ref2 from list
            prev = _entries[index].ref2.prev;
            next = _entries[index].ref2.next;
            if (prev >= 0) {
                Debug.Assert(_entries[prev].ref1.next == -index, "_entries[prev].ref1.next == -index");
                _entries[prev].ref1.next = next;
            }
            else {
                Debug.Assert(_entries[-prev].ref2.next == -index, "_entries[-prev].ref2.next == -index");
                _entries[-prev].ref2.next = next;
            }

            if (next >= 0) {
                Debug.Assert(_entries[next].ref1.prev == -index, "_entries[next].ref1.prev == -index");
                _entries[next].ref1.prev = prev;
            }
            else {
                Debug.Assert(_entries[-next].ref2.prev == -index, "_entries[-next].ref2.prev == -index");
                _entries[-next].ref2.prev = prev;
            }

            Debug.Assert(_freeHead == -1 || (_entries[_freeHead].cacheEntry == null && _entries[_freeHead].utcDate == DateTime.MinValue), 
                        "_freeHead == -1 || (_entries[_freeHead].cacheEntry == null && _entries[_freeHead].utcDate == DateTime.MinValue)");

            Debug.Assert(_freeTail == -1 || (_entries[_freeTail].cacheEntry == null && _entries[_freeTail].utcDate == DateTime.MinValue), 
                        "_freeTail == -1 || (_entries[_freeTail].cacheEntry == null && _entries[_freeTail].utcDate == DateTime.MinValue)");

            Debug.Assert(_entries[index].cacheEntry == null && _entries[index].utcDate == DateTime.MinValue, 
                        "_entries[index].cacheEntry == null && _entries[index].utcDate == DateTime.MinValue");

            // add index to free list
            // if entry is in first half, add to head, else add to tail
            if (_freeHead == -1) {
                Debug.Assert(_freeTail == -1, "_freeTail == -1");
                _freeHead = _freeTail = index;
                _entries[index].ref1.next = -1;
            }
            else if (index < lengthdiv2) {
                Debug.Assert(_freeTail != -1, "_freeTail != -1");
                _entries[index].ref1.next = _freeHead;
                _freeHead = index;
            }
            else {
                Debug.Assert(_freeTail != -1, "_freeTail != -1");
                Debug.Assert(_entries[_freeTail].ref1.next == -1, "_entries[_freeTail].ref1.next == -1");
                _entries[_freeTail].ref1.next = index;
                _entries[index].ref1.next = -1;
                _freeTail = index;
            }

            _cFree++;
            if (index >= lengthdiv2) {
                _cFreeLast++;
            }

            // check whether we should realloc _entries
            // only realloc if 2nd half is empty
            Debug.Assert(_cFreeLast <= lengthdiv2);

            if (    _cFreeLast == lengthdiv2 && 
                    _cInUse * 2 <= lengthdiv2 &&
                    MIN_ENTRIES <= lengthdiv2) {

                int newSize = lengthdiv2;
                Debug.Assert(_freeHead >= 0 && _freeHead < newSize, "_freeHead >= 0 && _freeHead < newSize");

                // alloc and copy to new array
                UsageEntry[] entries = new UsageEntry[newSize];

                _freeHead = -1;
                _freeTail = -1;
                _cFree = 0;

                // copy the two halves, and count _cFreeLast during the second half
                // don't count entry at index 0 as free
                entries[0] = _entries[0];
                int i = 1, c = 0;
                for (int halves = 1; halves <= 2; halves++) {
                    _cFreeLast = 0;
                    c += newSize / 2;
                    for (; i < c; i++) {
                        entries[i] = _entries[i];
                        if (entries[i].utcDate == DateTime.MinValue) {
                            _cFree++;
                            _cFreeLast++;

                            // update free list
                            if (_freeHead == -1) {
                                _freeHead = i;
                            }
                            else {
                                entries[_freeTail].ref1.next = i;
                            }
                            
                            _freeTail = i;
                        }
                    }
                }

                Debug.Assert(_freeHead != -1, "_freeHead should not be -1");
                Debug.Assert(_freeTail != -1, "_freeTail should not be -1");

                // terminate free list
                entries[_freeTail].ref1.next = -1;

//#if DBG
//                for (; i < length; i++) {
//                    Debug.Assert(_entries[i].utcDate == 0, "_entries[i].utcDate == 0");
//                }
//#endif

                _entries = entries;

                Debug.Trace("CacheUsageContract", "Contracted from " + length + " to newSize");
            }
        }

        internal void RemoveCacheEntry(CacheEntry cacheEntry) {
            lock (this) {
                int index = cacheEntry.UsageIndex;
                if (index < 0)
                    return;

                Debug.Assert(index > 0);
                RemoveEntryAtIndex(cacheEntry, index);

                Debug.Trace("CacheUsageRemove", 
                            "Removed item=" + cacheEntry.Key + 
                            ",_bucket=" + _bucket + 
                            ",_index=" + index);

                Debug.Validate("CacheValidateUsage", this);
                Debug.Dump("CacheValidateUsage", this);
            }
        }

        internal void UpdateCacheEntry(CacheEntry cacheEntry) {
            lock (this) {
                int index = cacheEntry.UsageIndex;
                if (index < 0)
                    return;

                Debug.Assert(index > 0);
                Debug.Assert(cacheEntry == _entries[index].cacheEntry, "cacheEntry == _entries[index].cacheEntry");

                // remove ref2 from list
                int prev = _entries[index].ref2.prev;
                int next = _entries[index].ref2.next;
                if (prev >= 0) {
                    Debug.Assert(_entries[prev].ref1.next == -index, "_entries[prev].ref1.next == -index");
                    _entries[prev].ref1.next = next;
                }
                else {
                    Debug.Assert(_entries[-prev].ref2.next == -index, "_entries[-prev].ref2.next == -index");
                    _entries[-prev].ref2.next = next;
                }

                if (next >= 0) {
                    Debug.Assert(_entries[next].ref1.prev == -index, "_entries[next].ref1.prev == -index");
                    _entries[next].ref1.prev = prev;
                }
                else {
                    Debug.Assert(_entries[-next].ref2.prev == -index, "_entries[-next].ref2.prev == -index");
                    _entries[-next].ref2.prev = prev;
                }

                // move ref1 to ref2
                _entries[index].ref2 = _entries[index].ref1;
                prev = _entries[index].ref2.prev;
                next = _entries[index].ref2.next;
                if (prev >= 0) {
                    Debug.Assert(_entries[prev].ref1.next == index, "_entries[prev].ref1.next == index");
                    _entries[prev].ref1.next = -index;
                }
                else {
                    Debug.Assert(_entries[-prev].ref2.next == index, "_entries[-prev].ref2.next == index");
                    _entries[-prev].ref2.next = -index;
                }

                if (next >= 0) {
                    Debug.Assert(_entries[next].ref1.prev == index, "_entries[next].ref1.prev == index");
                    _entries[next].ref1.prev = -index;
                }
                else {
                    Debug.Assert(_entries[-next].ref2.prev == index, "_entries[-next].ref2.prev == index");
                    _entries[-next].ref2.prev = -index;
                }

                // put ref1 at head of list
                int firstRef = _entries[0].ref1.next;
                Debug.Assert(firstRef >= 0 || firstRef == -index, "firstRef >= 0 || firstRef == -index");
                _entries[index].ref1.prev = 0;
                _entries[index].ref1.next = firstRef;
                _entries[0].ref1.next = index;
                if (firstRef >= 0) {
                    _entries[firstRef].ref1.prev = index;
                }
                else {
                    _entries[index].ref2.prev = index;
                }

                Debug.Trace("CacheUsageUpdate", 
                            "Updated item=" + cacheEntry.Key + 
                            ",_bucket=" + _bucket + 
                            ",_index=" + index);

                Debug.Validate("CacheValidateUsage", this);
                Debug.Dump("CacheUsageUpdate", this);
            }
        }

        internal int FlushUnderUsedItems(int maxFlush) {
            if (_cInUse == 0)
                return 0;

            Debug.Assert(maxFlush > 0, "maxFlush is not greater than 0, instead is " + maxFlush);

            int flushed = 0;
            ArrayList entriesToRemove = new ArrayList();
            DateTime utcNow = DateTime.UtcNow;
            int prev, prevNext;
            DateTime utcDate;
            int index;

            lock (this) {
                // walk the list backwards, removing items
                for (   prev = _entries[0].ref1.prev; 
                        prev != 0 && flushed < maxFlush && _cInUse > 0;
                        prev = prevNext) {

                    // set prevNext before possibly freeing an item
                    prevNext = _entries[-prev].ref2.prev;
                    while (prevNext > 0) {
                        Debug.Assert(prevNext != 0, "prevNext != 0");
                        prevNext = _entries[prevNext].ref1.prev;
                    }

                    // look only at ref2 items
                    Debug.Assert(prev < 0, "prev < 0");
                    index = -prev;
                    utcDate = _entries[index].utcDate;
                    Debug.Assert(utcDate != DateTime.MinValue, "utcDate != DateTime.MinValue");

                    if (utcNow - utcDate > CacheUsage.NEWADD_INTERVAL) {
                        CacheEntry cacheEntry = _entries[index].cacheEntry;
                        Debug.Trace("CacheUsageFlushUnderUsedItem", "Flushing underused items, item=" + cacheEntry.Key + ", bucket=" + _bucket);

                        entriesToRemove.Add(cacheEntry);
                        flushed++;
                    }

                    Debug.Assert(-_entries.Length < prevNext && prevNext < _entries.Length, "-_entries.Length < prevNext && prevNext < _entries.Length");
                }

                Debug.Validate("CacheValidateUsage", this);
                Debug.Dump("CacheUsageFlush", this);
            }
            
            CacheInternal cacheInternal = _cacheUsage.CacheInternal;
            foreach (CacheEntry cacheEntry in entriesToRemove) {
                cacheInternal.Remove(cacheEntry, CacheItemRemovedReason.Underused);
            }

            Debug.Trace("CacheUsageFlushUnderUsedTotal", "Removed " + entriesToRemove.Count + 
                        " underused items; Time=" + DateTime.UtcNow.ToLocalTime());

            return flushed;
        }

#if DBG
        internal /*public*/ void DebugValidate() {
            int cFree = 0;               
            int cFreeLast = 0;               
            int cInUse = 0;              

            Debug.CheckValid(-1 <= _freeHead && _freeHead <= _entries.Length, "-1 <= _freeHead && _freeHead <= _entries.Length");
            Debug.CheckValid(-1 <= _freeTail && _freeTail <= _entries.Length, "-1 <= _freeTail && _freeTail <= _entries.Length");

            Debug.CheckValid(_entries[0].utcDate == DateTime.MinValue, "_entries[0].utcDate == DateTime.MinValue");
            Debug.CheckValid(_entries[0].cacheEntry == null, "_entries[0].cacheEntry == null");
            Debug.CheckValid(_entries[0].ref1.next >= 0, "_entries[0].ref1.next >= 0");
            Debug.CheckValid(_entries[0].ref1.prev <= 0, "_entries[0].ref1.next <= 0");
            Debug.CheckValid(_entries[0].ref2.next == 0, "_entries[0].ref2.next == 0");
            Debug.CheckValid(_entries[0].ref2.prev == 0, "_entries[0].ref2.prev == 0");

            // check counts
            for (int i = 1; i < _entries.Length; i++) {
                DateTime utcDate = _entries[i].utcDate;

                if (utcDate == DateTime.MinValue) {
                    Debug.CheckValid(_entries[i].cacheEntry == null, "_entries[i].cacheEntry == null");
                    Debug.CheckValid(-1 <= _entries[i].ref1.next && _entries[i].ref1.next < _entries.Length,
                                    "-1 <= _entries[i].ref1.next && _entries[i].ref1.next < _entries.Length");

                    cFree++;
                    if (i >= _entries.Length / 2) {
                        cFreeLast++;
                    }
                }
                else {
                    Debug.CheckValid(_entries[i].cacheEntry != null, "_entries[i].cacheEntry != null");
                    Debug.CheckValid(_entries[i].cacheEntry.UsageIndex == i, "_entries[i].cacheEntry.UsageIndex == i");
                    Debug.CheckValid(_entries[i].cacheEntry.UsageBucket == _bucket, "_entries[i].cacheEntry.UsageBucket == _bucket");
                    Debug.CheckValid(-_entries.Length < _entries[i].ref1.next && _entries[i].ref1.next < _entries.Length,
                                    "-_entries.Length < _entries[i].ref1.next && _entries[i].ref1.next < _entries.Length");

                    Debug.CheckValid(-_entries.Length < _entries[i].ref1.prev && _entries[i].ref1.prev < _entries.Length,
                                    "-_entries.Length < _entries[i].ref1.prev && _entries[i].ref1.prev < _entries.Length");

                    Debug.CheckValid(-_entries.Length < _entries[i].ref2.next && _entries[i].ref2.next < _entries.Length,
                                    "-_entries.Length < _entries[i].ref2.next && _entries[i].ref2.next < _entries.Length");

                    Debug.CheckValid(-_entries.Length < _entries[i].ref2.prev && _entries[i].ref2.prev < _entries.Length,
                                    "-_entries.Length < _entries[i].ref2.prev && _entries[i].ref2.prev < _entries.Length");

                    cInUse++;
                }
            }

            Debug.CheckValid(cFree == _cFree, "cFree == _cFree");
            Debug.CheckValid(cFreeLast == _cFreeLast, "cFreeLast == _cFreeLast");
            Debug.CheckValid(cInUse == _cInUse, "cInUse == _cInUse");
            Debug.CheckValid(cFree + cInUse == _entries.Length - 1, "cFree + cInUse == _entries.Length - 1");
            Debug.CheckValid(_cFree >= _cFreeLast, "_cFree >= _cFreeLast");
            Debug.CheckValid(_cFreeLast <= _entries.Length / 2, "_cFreeLast <= _entries.Length / 2");

            // check the free list
            int next;
            for (   cFree = 0, next = _freeHead;
                    next != -1;
                    cFree++, next = _entries[next].ref1.next) {

                if (cFree > _cFree) {
                    Debug.CheckValid(false, "_entries free list is corrupt, may contain a cycle");
                }
            }
                 
            Debug.CheckValid(cFree == _cFree, "cFree == _cFree");
            if (_freeTail != -1) {
                Debug.CheckValid(_entries[_freeTail].ref1.next == -1, "_entries[_freeTail].ref1.next == -1");
            }

            // walk list forwards
            int cRefs = 0;
            int last = 0;
            next = _entries[0].ref1.next;
            while (next != 0) {
                cRefs++;
                Debug.CheckValid(cRefs <= 2 * _cInUse, "cRefs <= _inUse");

                if (next >= 0) {
                    Debug.CheckValid(_entries[next].utcDate != DateTime.MinValue, "_entries[next].utcDate != DateTime.MinValue");
                    Debug.CheckValid(_entries[next].ref1.prev == last, "_entries[next].ref1.prev == last");
                    last = next;
                    next = _entries[next].ref1.next;
                }
                else {
                    Debug.CheckValid(_entries[-next].utcDate != DateTime.MinValue, "_entries[-next].utcDate != DateTime.MinValue");
                    Debug.CheckValid(_entries[-next].ref2.prev == last, "_entries[-next].ref2.prev == last");
                    last = next;
                    next = _entries[-next].ref2.next;
                }
            }

            Debug.CheckValid(cRefs == 2 * _cInUse, "cRefs == 2 * _cInUse");

            // walk list backwards
            cRefs = 0;
            int prev = _entries[0].ref1.prev;
            last = 0;
            while (prev != 0) {
                cRefs++;
                Debug.CheckValid(cRefs <= 2 * _cInUse, "cRefs <= _inUse");

                if (prev >= 0) {
                    Debug.CheckValid(_entries[prev].utcDate != DateTime.MinValue, "_entries[prev].utcDate != DateTime.MinValue");
                    Debug.CheckValid(_entries[prev].ref1.next == last, "_entries[prev].ref1.next == last");
                    last = prev;
                    prev = _entries[prev].ref1.prev;
                }
                else {
                    Debug.CheckValid(_entries[-prev].utcDate != DateTime.MinValue, "_entries[-prev].utcDate != DateTime.MinValue");
                    Debug.CheckValid(_entries[-prev].ref2.next == last, "_entries[-prev].ref2.next == last");
                    last = prev;
                    prev = _entries[-prev].ref2.prev;
                }
            }

            Debug.CheckValid(cRefs == 2 * _cInUse, "cRefs == 2 * _cInUse");

        }

        internal /*public*/ string DebugDescription(string indent) {
            int             i;
            StringBuilder   sb = new StringBuilder();
            string          i2 = indent + "    ";

            sb.Append(indent + 
                      "_bucket=" + _bucket + 
                      ",_freeHead=" + _freeHead + 
                      ",_freeTail=" + _freeTail +
                      ",_cFree=" + _cFree + 
                      ",_cFreeLast=" + _cFreeLast + 
                      ",_cInUse=" + _cInUse + "\n");

            sb.Append(indent + "Entries:\n");
            for (i = 1; i < _entries.Length; i++) {
                string key;
                if (_entries[i].cacheEntry != null) {
                    key = _entries[i].cacheEntry.Key;
                }
                else {
                    key = "(null)";
                }

                sb.Append(i2 + i + ": cacheEntry=" + key + 
                        ",utcDate=" + _entries[i].utcDate +
                        ",ref1.next=" + _entries[i].ref1.next + ",ref1.prev=" + _entries[i].ref1.prev + 
                        ",ref2.next=" + _entries[i].ref2.next + ",ref2.prev=" + _entries[i].ref2.prev + 
                        "\n");
            }

            sb.Append(indent + "Refs list, in order:\n");

            int next = _entries[0].ref1.next;
            while (next != 0) {
                if (next >= 0) {
                    sb.Append(i2 + next + " (1): " + _entries[next].cacheEntry.Key + "\n");
                    next = _entries[next].ref1.next;
                }
                else {
                    sb.Append(i2 + -next + " (2): " + _entries[-next].cacheEntry.Key + "\n");
                    next = _entries[-next].ref2.next;
                }
            }

            return sb.ToString();
        }
#endif
    }

    class CacheUsage {
        internal static readonly TimeSpan   NEWADD_INTERVAL = new TimeSpan(0, 0, 15);
        internal static readonly TimeSpan   CORRELATED_REQUEST_TIMEOUT = new TimeSpan(0, 0, 1);
        internal static readonly TimeSpan   MIN_LIFETIME_FOR_USAGE =  NEWADD_INTERVAL;
        const byte                          NUMBUCKETS = (byte) (CacheItemPriority.High);

        readonly CacheInternal          _cacheInternal;
        internal readonly UsageBucket[] _buckets;

        internal CacheUsage(CacheInternal cacheInternal) {
            Debug.Assert((int) CacheItemPriority.Low == 1, "(int) CacheItemPriority.Low == 1");

            _cacheInternal = cacheInternal;
            _buckets = new UsageBucket[NUMBUCKETS];
            for (byte b = 0; b < _buckets.Length; b++) {
                _buckets[b] = new UsageBucket(this, b);
            }
        }

        internal void Dispose() {
        }

        internal CacheInternal CacheInternal {
            get {
                return _cacheInternal;
            }
        }

        internal void Add(CacheEntry cacheEntry) {
            byte bucket = cacheEntry.UsageBucket;
            Debug.Assert(bucket != 0xff, "bucket != 0xff");
            _buckets[bucket].AddCacheEntry(cacheEntry);
        }

        internal void Remove(CacheEntry cacheEntry) {
            byte bucket = cacheEntry.UsageBucket;
            if (bucket != 0xff) {
                _buckets[bucket].RemoveCacheEntry(cacheEntry);
            }
        }

        internal void Update(CacheEntry cacheEntry) {
            byte bucket = cacheEntry.UsageBucket;
            if (bucket != 0xff) {
                _buckets[bucket].UpdateCacheEntry(cacheEntry);
            }
        }

        internal int FlushUnderUsedItems(int toFlush) {
            int         flushed = 0;

            foreach (UsageBucket usageBucket in _buckets) {
                int flushedOne = usageBucket.FlushUnderUsedItems(toFlush - flushed);
                flushed += flushedOne;
                if (flushed >= toFlush)
                    break;
            }

            return flushed;
        }

#if DBG
        internal /*public*/ void DebugValidate() {
            foreach (UsageBucket usageBucket in _buckets) {
                usageBucket.DebugValidate();
            }
        }

        internal /*public*/ string DebugDescription(string indent) {
            StringBuilder   sb = new StringBuilder();
            string          i2 = indent + "    ";

            sb.Append(indent);
            sb.Append("Cache Usage\n");

            foreach (UsageBucket usageBucket in _buckets) {
                sb.Append(usageBucket.DebugDescription(i2));
            }

            return sb.ToString();
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\workerrequest.cs ===
//------------------------------------------------------------------------------
// <copyright file="WorkerRequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :

        HttpWorkerRequest.cs

   Abstract:

        This module defines the base worker class used by ASP.NET Managed
        code for request processing.
 
--*/

namespace System.Web {
    using System.Text;

    using System.Collections;
    using System.Collections.Specialized;
    using System.Runtime.InteropServices;
    using System.Web.Configuration;
    using System.Web.Util;
    using System.Security.Permissions;

    //
    // ****************************************************************************
    //

    /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest"]/*' />
    /// <devdoc>
    ///    <para>This abstract class defines the base worker methods and enumerations used by ASP.NET managed code for request processing.</para>
    /// </devdoc>
    [ComVisible(false)]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public abstract class HttpWorkerRequest : IHttpMapPath {
        private DateTime _startTime;

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HttpWorkerRequest"]/*' />
        public HttpWorkerRequest()
        {
            _startTime = DateTime.UtcNow;
        }

        // ************************************************************************

        //
        // Indexed Headers. All headers that are defined by HTTP/1.1. These 
        // values are used as offsets into arrays and as token values.
        //  
        // IMPORTANT : Notice request + response values overlap. Make sure you 
        // know which type of header array you are indexing.
        //

        //
        // general-headers [section 4.5]
        //

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderCacheControl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderCacheControl          = 0;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderConnection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderConnection            = 1;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderDate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderDate                  = 2;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderKeepAlive"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderKeepAlive             = 3;   // not in rfc
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderPragma"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderPragma                = 4;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderTrailer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderTrailer               = 5;     
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderTransferEncoding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderTransferEncoding      = 6;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderUpgrade"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderUpgrade               = 7;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderVia"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderVia                   = 8;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderWarning"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderWarning               = 9;

        //
        // entity-headers  [section 7.1]
        //

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderAllow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderAllow                 = 10;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderContentLength"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderContentLength         = 11;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderContentType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderContentType           = 12;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderContentEncoding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderContentEncoding       = 13;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderContentLanguage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderContentLanguage       = 14;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderContentLocation"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderContentLocation       = 15;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderContentMd5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderContentMd5            = 16;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderContentRange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderContentRange          = 17;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderExpires"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderExpires               = 18;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderLastModified"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderLastModified          = 19;

        //
        // request-headers [section 5.3]
        //

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderAccept"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderAccept                = 20;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderAcceptCharset"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderAcceptCharset         = 21;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderAcceptEncoding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderAcceptEncoding        = 22;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderAcceptLanguage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderAcceptLanguage        = 23;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderAuthorization"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderAuthorization         = 24;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderCookie"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderCookie                = 25;   // not in rfc
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderExpect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderExpect                = 26;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderFrom"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderFrom                  = 27;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderHost"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderHost                  = 28;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderIfMatch"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderIfMatch               = 29;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderIfModifiedSince"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderIfModifiedSince       = 30;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderIfNoneMatch"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderIfNoneMatch           = 31;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderIfRange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderIfRange               = 32;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderIfUnmodifiedSince"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderIfUnmodifiedSince     = 33;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderMaxForwards"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderMaxForwards           = 34;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderProxyAuthorization"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderProxyAuthorization    = 35;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderReferer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderReferer               = 36;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderRange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderRange                 = 37;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderTe"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderTe                    = 38;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderUserAgent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderUserAgent             = 39;

        //
        // Request headers end here
        //

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.RequestHeaderMaximum"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int RequestHeaderMaximum        = 40;

        //
        // response-headers [section 6.2]
        //

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderAcceptRanges"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderAcceptRanges          = 20;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderAge"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderAge                   = 21;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderEtag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderEtag                  = 22;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderLocation"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderLocation              = 23;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderProxyAuthenticate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderProxyAuthenticate     = 24;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderRetryAfter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderRetryAfter            = 25;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderServer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderServer                = 26;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderSetCookie"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderSetCookie             = 27;   // not in rfc
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderVary"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderVary                  = 28;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeaderWwwAuthenticate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int HeaderWwwAuthenticate       = 29;

        //
        // Response headers end here
        //

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.ResponseHeaderMaximum"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const int ResponseHeaderMaximum       = 30;

        // ************************************************************************

        //
        // Request reasons
        //

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.ReasonResponseCacheMiss"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        /// <internalonly/>
        public const int ReasonResponseCacheMiss     = 0;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.ReasonFileHandleCacheMiss"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        /// <internalonly/>
        public const int ReasonFileHandleCacheMiss   = 1;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.ReasonCachePolicy"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        /// <internalonly/>
        public const int ReasonCachePolicy           = 2;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.ReasonCacheSecurity"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        /// <internalonly/>
        public const int ReasonCacheSecurity         = 3;
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.ReasonClientDisconnect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        /// <internalonly/>
        public const int ReasonClientDisconnect      = 4;

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.ReasonDefault"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        /// <internalonly/>
        public const int ReasonDefault               = ReasonResponseCacheMiss;


        // ************************************************************************

        //
        // Access to request related members
        //

        // required members

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetUriPath"]/*' />
        /// <devdoc>
        ///    <para> Returns the physical path to the requested Uri.</para>
        /// </devdoc>
        public abstract String  GetUriPath();           // "/foo/page.aspx/tail"
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetQueryString"]/*' />
        /// <devdoc>
        ///    <para>Provides Access to the specified member of the request header.</para>
        /// </devdoc>
        public abstract String  GetQueryString();       // "param=bar"
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetRawUrl"]/*' />
        /// <devdoc>
        ///    <para>Provides Access to the specified member of the request header.</para>
        /// </devdoc>
        public abstract String  GetRawUrl();            // "/foo/page.aspx/tail?param=bar"
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetHttpVerbName"]/*' />
        /// <devdoc>
        ///    <para>Provides Access to the specified member of the request header.</para>
        /// </devdoc>
        public abstract String  GetHttpVerbName();      // "GET" 
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetHttpVersion"]/*' />
        /// <devdoc>
        ///    <para>Provides Access to the specified member of the request header.</para>
        /// </devdoc>
        public abstract String  GetHttpVersion();       // "HTTP/1.1"

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetRemoteAddress"]/*' />
        /// <devdoc>
        ///    <para>Provides Access to the specified member of the request header.</para>
        /// </devdoc>
        public abstract String  GetRemoteAddress();     // client's ip address
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetRemotePort"]/*' />
        /// <devdoc>
        ///    <para>Provides Access to the specified member of the request header.</para>
        /// </devdoc>
        public abstract int     GetRemotePort();        // client's port
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetLocalAddress"]/*' />
        /// <devdoc>
        ///    <para>Provides Access to the specified member of the request header.</para>
        /// </devdoc>
        public abstract String  GetLocalAddress();      // server's ip address
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetLocalPort"]/*' />
        /// <devdoc>
        ///    <para>Provides Access to the specified member of the request header.</para>
        /// </devdoc>
        public abstract int     GetLocalPort();         // server's port

        // optional members with defaults supplied

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetQueryStringRawBytes"]/*' />
        /// <devdoc>
        ///    <para>When overriden in a derived class, returns the response query string as an array of bytes.</para>
        /// </devdoc>
        public virtual byte[] GetQueryStringRawBytes() {
            // access to raw qs for i18n
            return null;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetRemoteName"]/*' />
        /// <devdoc>
        ///    <para>When overriden in a derived class, returns the client computer's name.</para>
        /// </devdoc>
        public virtual String GetRemoteName() {
            // client's name
            return GetRemoteAddress();
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetServerName"]/*' />
        /// <devdoc>
        ///    <para>When overriden in a derived class, returns the name of the local server.</para>
        /// </devdoc>
        public virtual String GetServerName() {
            // server's name
            return GetLocalAddress();
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetConnectionID"]/*' />
        /// <devdoc>
        ///    <para>When overriden in a derived class, returns the ID of the current connection.</para>
        /// </devdoc>
        /// <internalonly/>
        public virtual long GetConnectionID() {
            // connection id
            return 0;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetUrlContextID"]/*' />
        /// <devdoc>
        ///    <para>When overriden in a derived class, returns the context ID of the current connection.</para>
        /// </devdoc>
        /// <internalonly/>
        public virtual long GetUrlContextID() {
            // UL APPID
            return 0; 
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetAppPoolID"]/*' />
        /// <devdoc>
        ///    <para>When overriden in a derived class, returns the application pool ID for the current URL.</para>
        /// </devdoc>
        /// <internalonly/>
        public virtual String GetAppPoolID() {
            // UL Application pool id
            return null; 
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetRequestReason"]/*' />
        /// <devdoc>
        ///    <para>When overriden in a derived class, returns the reason for the request.</para>
        /// </devdoc>
        /// <internalonly/>
        public virtual int GetRequestReason() {
            // constants Reason... above
            return ReasonDefault; 
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetUserToken"]/*' />
        /// <devdoc>
        ///    <para>When overriden in a derived class, returns the client's impersonation token.</para>
        /// </devdoc>
        public virtual IntPtr GetUserToken() {
            // impersonation token
            return (IntPtr) 0;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetVirtualPathToken"]/*' />
        /// <internalonly/>
        public virtual IntPtr GetVirtualPathToken() {
            // impersonation token
            return (IntPtr) 0;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.IsSecure"]/*' />
        /// <devdoc>
        ///    <para>When overriden in a derived class, returns a value indicating whether the connection is secure (using SSL).</para>
        /// </devdoc>
        public virtual bool IsSecure() {
            // is over ssl?
            return false;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetProtocol"]/*' />
        /// <devdoc>
        ///    <para>When overriden in a derived class, returns the HTTP protocol (HTTP or HTTPS).</para>
        /// </devdoc>
        public virtual String GetProtocol() {
            return IsSecure() ?  "https" : "http";
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetFilePath"]/*' />
        /// <devdoc>
        ///    <para>When overriden in a derived class, returns the physical path to the requested Uri.</para>
        /// </devdoc>
        public virtual String GetFilePath() {
            // "/foo/page.aspx"
            return GetUriPath();
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetFilePathTranslated"]/*' />
        /// <devdoc>
        ///    <para>When overriden in a derived class, returns the translated file path to the requested Uri (from virtual path to 
        ///       UNC path, ie "/foo/page.aspx" to "c:\dir\page.aspx") </para>
        /// </devdoc>
        public virtual String GetFilePathTranslated() {
            // "c:\dir\page.aspx"
            return null;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetPathInfo"]/*' />
        /// <devdoc>
        ///    <para>When overriden in a derived class, returns additional 
        ///       path information for a resource with a URL extension. i.e. for the URL
        ///       /virdir/page.html/tail, the PathInfo value is /tail. </para>
        /// </devdoc>
        public virtual String GetPathInfo() {
            // "/tail"
            return "";
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetAppPath"]/*' />
        /// <devdoc>
        ///    <para>When overriden in a derived class, returns the virtual path to the 
        ///       currently executing server application.</para>
        /// </devdoc>
        public virtual String GetAppPath() {
            // "/foo"
            return null;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetAppPathTranslated"]/*' />
        /// <devdoc>
        ///    <para>When overriden in a derived class, returns the UNC-translated path to 
        ///       the currently executing server application.</para>
        /// </devdoc>
        public virtual String GetAppPathTranslated() {
            // "c:\dir"
            return null;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetPreloadedEntityBody"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual byte[] GetPreloadedEntityBody() {
            return null;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.IsEntireEntityBodyIsPreloaded"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool IsEntireEntityBodyIsPreloaded() {
            return false;
        }

        //
        // Virtual methods to read the incoming request
        //

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.ReadEntityBody"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual int ReadEntityBody(byte[] buffer, int size) {
            return 0;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetKnownRequestHeader"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual String GetKnownRequestHeader(int index) {
            return null;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetUnknownRequestHeader"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual String GetUnknownRequestHeader(String name) {
            return null;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetUnknownRequestHeaders"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [CLSCompliant(false)]
        public virtual String[][] GetUnknownRequestHeaders() {
            return null;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetServerVariable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual String GetServerVariable(String name) {
            return null;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetBytesRead"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        /// <internalonly/>
        public virtual long GetBytesRead() {
            return 0;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetStartTime"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        /// <internalonly/>
        internal virtual DateTime GetStartTime() {
            return _startTime;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.MapPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual String MapPath(String virtualPath) {
            return null;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.MachineConfigPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual String MachineConfigPath {
            get {
                return null;
            }
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.MachineInstallDirectory"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual String MachineInstallDirectory {
            get {
                return null;
            }
        }

        //
        // Abstract methods to write the response
        //

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.SendStatus"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract void SendStatus(int statusCode, String statusDescription);

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.SendKnownResponseHeader"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract void SendKnownResponseHeader(int index, String value);

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.SendUnknownResponseHeader"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract void SendUnknownResponseHeader(String name, String value);

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.SendResponseFromMemory"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract void SendResponseFromMemory(byte[] data, int length);

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.SendResponseFromMemory2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void SendResponseFromMemory(IntPtr data, int length) {
            if (length > 0) {
                InternalSecurityPermissions.UnmanagedCode.Demand();
                // derived classes could have an efficient implementation
                byte[] bytes = new byte[length];
                StringResourceManager.CopyResource(data, 0, bytes, 0, length);
                SendResponseFromMemory(bytes, length);
            }
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.SendResponseFromFile"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract void SendResponseFromFile(String filename, long offset, long length);

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.SendResponseFromFile1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract void SendResponseFromFile(IntPtr handle, long offset, long length);

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.FlushResponse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract void FlushResponse(bool finalFlush);

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.EndOfRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract void EndOfRequest();

        //
        // Virtual helper methods
        //

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.EndOfSendNotification"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public delegate void EndOfSendNotification(HttpWorkerRequest wr, Object extraData);

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.SetEndOfSendNotification"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void SetEndOfSendNotification(EndOfSendNotification callback, Object extraData) {
            // firing the callback helps with buffer recycling
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.SendCalculatedContentLength"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void SendCalculatedContentLength(int contentLength) {
            // oportunity to add Content-Length header if not added by user
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HeadersSent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool HeadersSent() {
            return true;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.IsClientConnected"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool IsClientConnected() {
            return true;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.CloseConnection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void CloseConnection() {
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetClientCertificate"]/*' />
        /// <devdoc>
        ///    <para>Defines the base worker class used by ASP.NET Managed code for request 
        ///       processing.</para>
        /// </devdoc>
        /// <internalonly/>
        public virtual byte [] GetClientCertificate() {
            return new byte[0];
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetClientCertificateValidFrom"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        /// <internalonly/>
        public virtual DateTime GetClientCertificateValidFrom() {
            return DateTime.Now;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetClientCertificateValidUntil"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        /// <internalonly/>
        public virtual DateTime GetClientCertificateValidUntil() {
            return DateTime.Now;
        }

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetClientCertificateBinaryIssuer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        /// <internalonly/>
        public virtual byte [] GetClientCertificateBinaryIssuer() {
            return new byte[0];
        }
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetClientCertificateEncoding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        /// <internalonly/>
        public virtual int GetClientCertificateEncoding() {
            return 0;
        }
        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetClientCertificatePublicKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        /// <internalonly/>
        public virtual byte[] GetClientCertificatePublicKey() {
            return new byte[0];
        }

        // ************************************************************************

        //
        // criteria to find out if there is posted data
        //

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.HasEntityBody"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool HasEntityBody() {
            //
            // content length != 0 -> assume has content
            //

            String contentLength = GetKnownRequestHeader(HeaderContentLength);
            if (contentLength != null && !contentLength.Equals("0"))
                return true;

            //
            // any content encoding -> assume has content
            //

            if (GetKnownRequestHeader(HeaderTransferEncoding) != null)
                return true;

            //
            // preloaded -> has it
            //

            if (GetPreloadedEntityBody() != null)
                return true;

            //
            // no posted data but everything preloaded -> no content
            //

            if (IsEntireEntityBodyIsPreloaded())
                return false;

            return false;
        }

        // ************************************************************************

        //
        // Default values for Http status description strings
        //

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetStatusDescription"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static String GetStatusDescription(int code) {
            if (code >= 100 && code < 600) {
                int i = code / 100;
                int j = code % 100;

                if (j < s_HTTPStatusDescriptions[i].Length)
                    return s_HTTPStatusDescriptions[i][j];
            }

            return "";
        }

        // Tables of status strings (first index is code/100, 2nd code%100)

        private static readonly String[][] s_HTTPStatusDescriptions = new String[][]
        {
            null,

            new String[]
            { 
                /* 100 */"Continue",
                /* 101 */ "Switching Protocols",
                /* 102 */ "Processing"
            },

            new String[]
            { 
                /* 200 */"OK",
                /* 201 */ "Created",
                /* 202 */ "Accepted",
                /* 203 */ "Non-Authoritative Information",
                /* 204 */ "No Content",
                /* 205 */ "Reset Content",
                /* 206 */ "Partial Content",
                /* 207 */ "Multi-Status"
            },

            new String[]
            { 
                /* 300 */"Multiple Choices",
                /* 301 */ "Moved Permanently",
                /* 302 */ "Found",
                /* 303 */ "See Other",
                /* 304 */ "Not Modified",
                /* 305 */ "Use Proxy",
                /* 306 */ "",
                /* 307 */ "Temporary Redirect"
            },

            new String[]
            { 
                /* 400 */"Bad Request",
                /* 401 */ "Unauthorized",
                /* 402 */ "Payment Required",
                /* 403 */ "Forbidden",
                /* 404 */ "Not Found",
                /* 405 */ "Method Not Allowed",
                /* 406 */ "Not Acceptable",
                /* 407 */ "Proxy Authentication Required",
                /* 408 */ "Request Timeout",
                /* 409 */ "Conflict",
                /* 410 */ "Gone",
                /* 411 */ "Length Required",
                /* 412 */ "Precondition Failed",
                /* 413 */ "Request Entity Too Large",
                /* 414 */ "Request-Uri Too Long",
                /* 415 */ "Unsupported Media Type",
                /* 416 */ "Requested Range Not Satisfiable",
                /* 417 */ "Expectation Failed",
                /* 418 */ "",
                /* 419 */ "",
                /* 420 */ "",
                /* 421 */ "",
                /* 422 */ "Unprocessable Entity",
                /* 423 */ "Locked",
                /* 424 */ "Failed Dependency"
            },

            new String[]
            { 
                /* 500 */"Internal Server Error",
                /* 501 */ "Not Implemented",
                /* 502 */ "Bad Gateway",
                /* 503 */ "Service Unavailable",
                /* 504 */ "Gateway Timeout",
                /* 505 */ "Http Version Not Supported",
                /* 506 */ "",
                /* 507 */ "Insufficient Storage"
            }
        };

        // ************************************************************************

        //
        // Header index to string conversions
        //

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetKnownRequestHeaderIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static int GetKnownRequestHeaderIndex(String header) {
            Object intObj = s_requestHeadersLoookupTable[header];

            if (intObj != null)
                return(Int32)intObj;
            else
                return -1;
        }

        // ************************************************************************

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetKnownRequestHeaderName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static String GetKnownRequestHeaderName(int index) {
            return s_requestHeaderNames[index];
        }

        // ************************************************************************

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetKnownResponseHeaderIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static int GetKnownResponseHeaderIndex(String header) {
            Object intObj = s_responseHeadersLoookupTable[header];

            if (intObj != null)
                return(Int32)intObj;
            else
                return -1;
        }

        // ************************************************************************

        /// <include file='doc\WorkerRequest.uex' path='docs/doc[@for="HttpWorkerRequest.GetKnownResponseHeaderName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static String GetKnownResponseHeaderName(int index) {
            return s_responseHeaderNames[index];
        }

        // ************************************************************************


        //
        // Implemenation -- lookup tables for header names
        //

        static private String[] s_requestHeaderNames  = new String[RequestHeaderMaximum];
        static private String[] s_responseHeaderNames = new String[ResponseHeaderMaximum];
        static private Hashtable s_requestHeadersLoookupTable  = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);
        static private Hashtable s_responseHeadersLoookupTable = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);

        // ************************************************************************

        static private void DefineHeader(bool isRequest, 
                                         bool isResponse, 
                                         int index, 
                                         String name) {
            Int32  i32 = new Int32();
            if (isRequest) {
                i32 = index;
                s_requestHeaderNames[index] = name;
                s_requestHeadersLoookupTable.Add(name, i32);
            }

            if (isResponse) {
                i32 = index;
                s_responseHeaderNames[index] = name;
                s_responseHeadersLoookupTable.Add(name, i32);
            }
        }

        // ************************************************************************

        static HttpWorkerRequest() {
            //
            // common headers
            //

            DefineHeader(true,  true,  HeaderCacheControl,        "Cache-Control");
            DefineHeader(true,  true,  HeaderConnection,          "Connection");
            DefineHeader(true,  true,  HeaderDate,                "Date");
            DefineHeader(true,  true,  HeaderKeepAlive,           "Keep-Alive");
            DefineHeader(true,  true,  HeaderPragma,              "Pragma");
            DefineHeader(true,  true,  HeaderTrailer,             "Trailer");
            DefineHeader(true,  true,  HeaderTransferEncoding,    "Transfer-Encoding");
            DefineHeader(true,  true,  HeaderUpgrade,             "Upgrade");
            DefineHeader(true,  true,  HeaderVia,                 "Via");
            DefineHeader(true,  true,  HeaderWarning,             "Warning");
            DefineHeader(true,  true,  HeaderAllow,               "Allow");
            DefineHeader(true,  true,  HeaderContentLength,       "Content-Length");
            DefineHeader(true,  true,  HeaderContentType,         "Content-Type");
            DefineHeader(true,  true,  HeaderContentEncoding,     "Content-Encoding");
            DefineHeader(true,  true,  HeaderContentLanguage,     "Content-Language");
            DefineHeader(true,  true,  HeaderContentLocation,     "Content-Location");
            DefineHeader(true,  true,  HeaderContentMd5,          "Content-MD5");
            DefineHeader(true,  true,  HeaderContentRange,        "Content-Range");
            DefineHeader(true,  true,  HeaderExpires,             "Expires");
            DefineHeader(true,  true,  HeaderLastModified,        "Last-Modified");

            //
            // request only headers
            //

            DefineHeader(true,  false, HeaderAccept,              "Accept");
            DefineHeader(true,  false, HeaderAcceptCharset,       "Accept-Charset");
            DefineHeader(true,  false, HeaderAcceptEncoding,      "Accept-Encoding");
            DefineHeader(true,  false, HeaderAcceptLanguage,      "Accept-Language");
            DefineHeader(true,  false, HeaderAuthorization,       "Authorization");
            DefineHeader(true,  false, HeaderCookie,              "Cookie");
            DefineHeader(true,  false, HeaderExpect,              "Expect");
            DefineHeader(true,  false, HeaderFrom,                "From");
            DefineHeader(true,  false, HeaderHost,                "Host");
            DefineHeader(true,  false, HeaderIfMatch,             "If-Match");
            DefineHeader(true,  false, HeaderIfModifiedSince,     "If-Modified-Since");
            DefineHeader(true,  false, HeaderIfNoneMatch,         "If-None-Match");
            DefineHeader(true,  false, HeaderIfRange,             "If-Range");
            DefineHeader(true,  false, HeaderIfUnmodifiedSince,   "If-Unmodified-Since");
            DefineHeader(true,  false, HeaderMaxForwards,         "Max-Forwards");
            DefineHeader(true,  false, HeaderProxyAuthorization,  "Proxy-Authorization");
            DefineHeader(true,  false, HeaderReferer,             "Referer");
            DefineHeader(true,  false, HeaderRange,               "Range");
            DefineHeader(true,  false, HeaderTe,                  "TE");
            DefineHeader(true,  false, HeaderUserAgent,           "User-Agent");

            //
            // response only headers
            //

            DefineHeader(false, true,  HeaderAcceptRanges,        "Accept-Ranges");
            DefineHeader(false, true,  HeaderAge,                 "Age");
            DefineHeader(false, true,  HeaderEtag,                "ETag");
            DefineHeader(false, true,  HeaderLocation,            "Location");
            DefineHeader(false, true,  HeaderProxyAuthenticate,   "Proxy-Authenticate");
            DefineHeader(false, true,  HeaderRetryAfter,          "Retry-After");
            DefineHeader(false, true,  HeaderServer,              "Server");
            DefineHeader(false, true,  HeaderSetCookie,           "Set-Cookie");
            DefineHeader(false, true,  HeaderVary,                "Vary");
            DefineHeader(false, true,  HeaderWwwAuthenticate,     "WWW-Authenticate");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\compilation\applicationfilecompiler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ApplicationFileCompiler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Compilation {

using System;
using System.Web.UI;

internal class ApplicationFileCompiler : BaseCompiler {

    protected ApplicationFileParser _appParser;

    internal /*public*/ static Type CompileApplicationFileType(ApplicationFileParser appParser) {
        ApplicationFileCompiler compiler = new ApplicationFileCompiler(appParser);

        return compiler.GetCompiledType();
    }

    internal ApplicationFileCompiler(ApplicationFileParser appParser) : base(appParser) {
        _appParser = appParser;
    }

    // Make the appinstance properties public (ASURT 63253)
    protected override bool FPublicPageObjectProperties { get { return true; } }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\cache\cachememory.cs ===
//------------------------------------------------------------------------------
// <copyright file="CacheMemory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Caching {
    using System.Runtime.InteropServices;
    using System.Web.Util;
    using System.Web;

    class CacheMemoryStats {
        const int       MEGABYTE_SHIFT = 20;
        const long      MEGABYTE = 1 << MEGABYTE_SHIFT; // 1048576
        const int       KILOBYTE_SHIFT = 10;
        const long      KILOBYTE = 1 << KILOBYTE_SHIFT; // 1024
        const int       HISTORY_COUNT = 10;

        const long      GC_BREATHING_ROOM = 50 * MEGABYTE;

        const long      MIN_FREE_PHYSICAL_MEMORY = GC_BREATHING_ROOM + (20 * MEGABYTE);
        const long      MAX_FREE_PHYSICAL_MEMORY = GC_BREATHING_ROOM + (60 * MEGABYTE);
        const long      MIN_FREE_PRIVATE_BYTES   = GC_BREATHING_ROOM + (40 * MEGABYTE);
        const long      MAX_FREE_PRIVATE_BYTES   = GC_BREATHING_ROOM + (80 * MEGABYTE);

        // floor for ratios on low memory machines

        /*
         * MIN_PHYSICAL_MEMORY_CONFIGURATION:   Assumed min. physical memory of a server machine
         * MIN_PHYSICAL_MEMORY_HIGH_PRESSURE:   Max % of physical memory we allow on such a machine
         * MIN_PHYSICAL_MEMORY_LOW_PRESSURE:    Min % of physical memory we want to maintain on such a machine
         */
        const long      MIN_PHYSICAL_MEMORY_CONFIGURATION = 128 * MEGABYTE;
        const int       MIN_PHYSICAL_MEMORY_HIGH_PRESSURE = (int) (((MIN_PHYSICAL_MEMORY_CONFIGURATION - MIN_FREE_PHYSICAL_MEMORY) * 100) / MIN_PHYSICAL_MEMORY_CONFIGURATION);
        const int       MIN_PHYSICAL_MEMORY_LOW_PRESSURE =  (int) (((MIN_PHYSICAL_MEMORY_CONFIGURATION - MAX_FREE_PHYSICAL_MEMORY) * 100) / MIN_PHYSICAL_MEMORY_CONFIGURATION);

        /*
         * MIN_PRIVATE_BYTES_CONFIGURATION:     Max private bytes based on 128MB and a 60% setting in machine.config
         * MIN_PRIVATE_BYTES_HIGH_PRESSURE:     Max % of private bytes (based on priv bytes limit) before recycle happens
         * MIN_PRIVATE_BYTES_LOW_PRESSURE:      Min % of private bytes  (based on priv bytes limit) we want to maintain on such a machine
         */
        const long      MIN_PRIVATE_BYTES_CONFIGURATION = 76 * MEGABYTE;
        const int       MIN_PRIVATE_BYTES_HIGH_PRESSURE =   (int) (((48 * MEGABYTE) * 100) / MIN_PRIVATE_BYTES_CONFIGURATION);
        const int       MIN_PRIVATE_BYTES_LOW_PRESSURE =    (int) (((32 * MEGABYTE) * 100) / MIN_PRIVATE_BYTES_CONFIGURATION);

        const int       PRIVATE_BYTES_CAP = 80;
        const int       PRIVATE_LOW_PRESSURE_RATIO = 95;

        readonly long   _totalMemory;
        readonly uint   _pid;
        readonly long   _memoryLimit;   // Max process private bytes before the process got recycled

        readonly int    _pressureHigh;
        readonly int    _pressureLow;
        readonly int    _pressureMiddle; 

        int             _i0;             
        int[]           _pressureHist;    
        int             _pressureTotal;   
        int             _pressureAvg;     

        internal CacheMemoryStats() {
            // global memory information
            UnsafeNativeMethods.MEMORYSTATUSEX  memoryStatusEx = new UnsafeNativeMethods.MEMORYSTATUSEX();
            memoryStatusEx.Init();
            if (UnsafeNativeMethods.GlobalMemoryStatusEx(ref memoryStatusEx) == 0)
                return;
            
            _totalMemory = Math.Min(memoryStatusEx.ullTotalPhys, memoryStatusEx.ullTotalVirtual);

            // More actual physical memory on this machine means bigger _pressureHigh and _pressureLow
            _pressureHigh = (int) (Math.Max(MIN_PHYSICAL_MEMORY_HIGH_PRESSURE, (_totalMemory - MIN_FREE_PHYSICAL_MEMORY) * 100 / _totalMemory));
            _pressureLow =  (int) (Math.Max(MIN_PHYSICAL_MEMORY_LOW_PRESSURE,  (_totalMemory - MAX_FREE_PHYSICAL_MEMORY) * 100 / _totalMemory));

            // per-process information
            if (UnsafeNativeMethods.GetModuleHandle(ModName.WP_FULL_NAME) != IntPtr.Zero) {
                _memoryLimit = UnsafeNativeMethods.PMGetMemoryLimitInMB() << MEGABYTE_SHIFT;
            }
            else if (UnsafeNativeMethods.GetModuleHandle(ModName.W3WP_FULL_NAME) != IntPtr.Zero) {
                _memoryLimit = UnsafeNativeMethods.GetW3WPMemoryLimitInKB() << KILOBYTE_SHIFT;
            }

            if (_memoryLimit != 0) {
                _pid = (uint) SafeNativeMethods.GetCurrentProcessId();
                // More actual physical memory on this machine means bigger privateBytesPressureHigh and privateBytesPressureLow
                int privateBytesPressureHigh = (int) (Math.Max(MIN_PRIVATE_BYTES_HIGH_PRESSURE, (_memoryLimit - MIN_FREE_PRIVATE_BYTES) * 100 / _memoryLimit));
                int privateBytesPressureLow =  (int) (Math.Max(MIN_PRIVATE_BYTES_LOW_PRESSURE, (_memoryLimit - MAX_FREE_PRIVATE_BYTES) * 100 / _memoryLimit));

                privateBytesPressureHigh = (int) (Math.Min(PRIVATE_BYTES_CAP, privateBytesPressureHigh));
                if (privateBytesPressureLow > privateBytesPressureHigh) {
                    privateBytesPressureLow = privateBytesPressureHigh * PRIVATE_LOW_PRESSURE_RATIO / 100;
                }
                    
                _pressureHigh = Math.Min(_pressureHigh, privateBytesPressureHigh);
                _pressureLow = Math.Min(_pressureLow, privateBytesPressureLow);
            }

            Debug.Assert(_pressureHigh > 0, "_pressureHigh > 0");
            Debug.Assert(_pressureLow > 0, "_pressureLow > 0");

            _pressureMiddle = (_pressureLow + _pressureHigh) / 2;

            // init history
            int pressure = GetCurrentPressure();

            _pressureHist = new int[HISTORY_COUNT];
            for (int i = 0; i < HISTORY_COUNT; i++) {
                _pressureHist[i] = pressure;
                _pressureTotal +=  pressure;
            }

            _pressureAvg = pressure;
        }

        internal void Update() {
            int pressure = GetCurrentPressure();

            _i0 = (_i0 + 1) % HISTORY_COUNT;

            _pressureTotal -= _pressureHist[_i0];
            _pressureTotal += pressure;
            _pressureHist[_i0] = pressure;
            _pressureAvg = _pressureTotal / HISTORY_COUNT; 

#if DBG
            if (HttpRuntime.AppDomainAppIdInternal != null && HttpRuntime.AppDomainAppIdInternal.Length > 0) {
                Debug.Trace("CacheMemoryUpdate", "Memory pressure: last=" + pressure + ",avg=" + _pressureAvg + ",high=" + _pressureHigh + ",low=" + _pressureLow + ",middle=" + _pressureMiddle + "; Now is " + DateTime.UtcNow.ToLocalTime());
            }
#endif
        }

        int GetCurrentPressure() {
            UnsafeNativeMethods.MEMORYSTATUSEX  memoryStatusEx = new UnsafeNativeMethods.MEMORYSTATUSEX();
            memoryStatusEx.Init();
            if (UnsafeNativeMethods.GlobalMemoryStatusEx(ref memoryStatusEx) == 0)
                return 0;
            
            // scale down the ratio if the gc is taking less than 1/4 of the physical memory
            long gcSize =  System.GC.GetTotalMemory(false);
            int gcLoad = (int) ((100 * gcSize) / _totalMemory);
            gcLoad = Math.Min(4 * gcLoad, 100);
            int pressure = (gcLoad * memoryStatusEx.dwMemoryLoad) / 100;
        
            if (_memoryLimit != 0) {
                int   hr;
                uint  privatePageCount = 0;
                uint  dummy;
                long  privateBytes;

                hr = UnsafeNativeMethods.GetProcessMemoryInformation(_pid, out privatePageCount, out dummy, 1);
                if (hr == 0) {
                    privateBytes = (long)privatePageCount << MEGABYTE_SHIFT;
                    int privateBytePressure = (int) ((privateBytes * 100 / _memoryLimit));
                    pressure = Math.Max(pressure, privateBytePressure);
                }
            }

            return pressure;
        }

        internal int PressureLast {
            get {
                return _pressureHist[_i0];
            }
        }

        internal int PressureAvg {
            get {
                return _pressureAvg;
            }
        }

        internal int PressureHigh {
            get { return _pressureHigh; } 
        }

        internal int PressureLow {
            get { return _pressureLow; } 
        }

        internal int PressureMiddle {
            get { return _pressureMiddle; } 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\compilation\basecompiler.cs ===
//------------------------------------------------------------------------------
// <copyright file="BaseCompiler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Compilation {

using System.Text;
using System.Runtime.Serialization.Formatters;
using System.ComponentModel;
using System;
using System.Collections;
using System.Reflection;
using System.IO;
using System.Web.Caching;
using System.Web.Util;
using System.Web.UI;
using System.Web.SessionState;
using System.Diagnostics;
using System.CodeDom;
using System.CodeDom.Compiler;
using Util = System.Web.UI.Util;
using Debug=System.Web.Util.Debug;


internal abstract class BaseCompiler {

    protected ICodeGenerator _generator;
    private CodeCompileUnit _sourceData;
    private CodeNamespace _sourceDataNamespace;
    protected CodeTypeDeclaration _sourceDataClass;
    private CompilerParameters _compilParams;
    private bool _fBatchMode;

    protected StringResourceBuilder _stringResourceBuilder;

    // The constructors
    protected CodeConstructor _ctor;

    protected CodeTypeReferenceExpression _classTypeExpr;

    private const string tempClassName = "DynamicClass";
    private const string defaultNamespace = "ASP";
    protected const string intializedFieldName = "__initialized";


    // Namespaces we always import when compiling
    private static string[] _defaultNamespaces = new string[] {
        "System",
        "System.Collections",
        "System.Collections.Specialized",
        "System.Configuration",
        "System.Text",
        "System.Text.RegularExpressions",
        "System.Web",
        "System.Web.Caching",
        "System.Web.SessionState",
        "System.Web.Security",
        "System.Web.UI",
        "System.Web.UI.WebControls",
        "System.Web.UI.HtmlControls",
    };

    private TemplateParser _parser;
    TemplateParser Parser { get { return _parser; } }

    protected Type _baseClassType;
#if DBG
    private bool _addedDebugComment;
#endif

#if DBG
    protected void AppendDebugComment(CodeStatementCollection statements) {
        if (!_addedDebugComment) {
            _addedDebugComment = true;
            StringBuilder debugComment = new StringBuilder();

            debugComment.Append("\r\n");
            debugComment.Append("** DEBUG INFORMATION **");
            debugComment.Append("\r\n");

            statements.Add(new CodeCommentStatement(debugComment.ToString()));
        }
    }
#endif

    internal /*public*/ void GenerateCodeModelForBatch(ICodeGenerator generator, StringResourceBuilder stringResourceBuilder) {

        _fBatchMode = true;
        _generator = generator;
        _stringResourceBuilder = stringResourceBuilder;

        // Build the data tree that needs to be compiled
        BuildSourceDataTree();
    }

    internal /*public*/ CodeCompileUnit GetCodeModel() {
        return _sourceData;
    }

    internal /*public*/ CompilerParameters CompilParams { get { return _compilParams; } }

    internal /*public*/ string GetInputFile() {
        return Parser.InputFile;
    }

    internal /*public*/ string GetTypeName() {
        return _sourceDataNamespace.Name + "." + _sourceDataClass.Name;
    }

    /*
     * Set some fields that are needed for code generation
     */
    internal BaseCompiler(TemplateParser parser) {
        _parser = parser;

        _baseClassType = Parser.BaseType;
        Debug.Assert(_baseClassType != null);
    }

    internal CompilerInfo CompilerInfo {
        get { return Parser.CompilerInfo; }
    }

    /// <include file='doc\BaseCompiler.uex' path='docs/doc[@for="BaseCompiler.GetCompiledType"]/*' />
    /// <devdoc>
    ///     
    /// </devdoc>
    protected Type GetCompiledType() {
        // Instantiate an ICompiler based on the language
        CodeDomProvider codeProvider = (CodeDomProvider) HttpRuntime.CreatePublicInstance(
            CompilerInfo.CompilerType);
        ICodeCompiler compiler = codeProvider.CreateCompiler();
        _generator = codeProvider.CreateGenerator();

        _stringResourceBuilder = new StringResourceBuilder();

        // Build the data tree that needs to be compiled
        BuildSourceDataTree();

        // Create the resource file if needed
        if (_stringResourceBuilder.HasStrings) {
            string resFileName = _compilParams.TempFiles.AddExtension("res");
            _stringResourceBuilder.CreateResourceFile(resFileName);
            CompilParams.Win32Resource = resFileName;
        }

        // Compile into an assembly
        CompilerResults results;
        try {
            results = codeProvider.CreateCompiler().CompileAssemblyFromDom(_compilParams, _sourceData);
        }
        catch (Exception e) {
            throw new HttpUnhandledException(HttpRuntime.FormatResourceString(SR.CompilationUnhandledException, codeProvider.GetType().FullName), e);
        }

        string fullTypeName = _sourceDataNamespace.Name + "." + _sourceDataClass.Name;

        ThrowIfCompilerErrors(results, codeProvider, _sourceData, null, null);

        // After the compilation, update the list of assembly dependencies to be what
        // the assembly actually needs.
        Parser.AssemblyDependencies = Util.GetReferencedAssembliesHashtable(
            results.CompiledAssembly);

        // Get the type from the assembly
        return results.CompiledAssembly.GetType(fullTypeName, true /*throwOnFail*/);
    }

    internal static void GenerateCompilerParameters(CompilerParameters compilParams) {

        // Set the temporary files collection in the CompilerParameters structure
        compilParams.TempFiles = new TempFileCollection(HttpRuntime.CodegenDirInternal);
        compilParams.TempFiles.KeepFiles = compilParams.IncludeDebugInformation;
    }

    internal static void ThrowIfCompilerErrors(CompilerResults results, CodeDomProvider codeProvider, 
        CodeCompileUnit sourceData, string sourceFile, string sourceString) {

        if (results.NativeCompilerReturnValue != 0 || results.Errors.HasErrors) {

            if (sourceData != null && codeProvider != null) {
                StringWriter sw = new StringWriter();
                codeProvider.CreateGenerator().GenerateCodeFromCompileUnit(sourceData, sw, null);
                throw new HttpCompileException(results, sw.ToString());
            }
            else if (sourceFile != null) {
                throw new HttpCompileException(results, Util.StringFromFile(sourceFile));
            }
            else {
                throw new HttpCompileException(results, sourceString);
            }
        }
    }

    /// <include file='doc\BaseCompiler.uex' path='docs/doc[@for="BaseCompiler.GetGeneratedClassName"]/*' />
    /// <devdoc>
    ///     Create a name for the generated class
    /// </devdoc>
    private string GetGeneratedClassName() {
        string className;

        // If the user specified the class name, just use that
        if (Parser.GeneratedClassName != null)
            return Parser.GeneratedClassName;

        // If we know the input file name, use it to generate the class name
        if (Parser.InputFile != null) {

            // Make sure we have the file name's correct case (ASURT 59179)
            className = Util.CheckExistsAndGetCorrectCaseFileName(Parser.InputFile);

            Debug.Assert(className != null);

            // Get rid of the path
            className = Path.GetFileName(className);

            // Change invalid chars to underscores
            className = Util.MakeValidTypeNameFromString(className);
        }
        else {
            // Otherwise, use a default name
            className = tempClassName;
        }

        return className;
    }

    internal static bool IsAspNetNamespace(string ns) {
        return (ns == defaultNamespace || ns == "_"+defaultNamespace);
    }

    /// <include file='doc\BaseCompiler.uex' path='docs/doc[@for="BaseCompiler.BuildSourceDataTree"]/*' />
    /// <devdoc>
    ///     
    /// </devdoc>
    private void BuildSourceDataTree() {

        _compilParams = Parser.CompilParams;

        GenerateCompilerParameters(_compilParams);

        _sourceData = new CodeCompileUnit();
        _sourceData.UserData["AllowLateBound"] = !Parser.FStrict;
        _sourceData.UserData["RequireVariableDeclaration"] = Parser.FExplicit;

        // Modify the namespace in batch mode, to avoid conflicts when things get
        // recompiled later in non-batched mode (ASURT 54063)
        string ns;
        if (_fBatchMode)
            ns = "_" + defaultNamespace;
        else
            ns = defaultNamespace;

        _sourceDataNamespace = new CodeNamespace(ns);
        _sourceData.Namespaces.Add(_sourceDataNamespace);

        _sourceDataClass = new CodeTypeDeclaration(GetGeneratedClassName());
        _sourceDataClass.BaseTypes.Add(new CodeTypeReference(_baseClassType.FullName));
        _sourceDataNamespace.Types.Add(_sourceDataClass);

        // Add metadata attributes to the class
        GenerateClassAttributes();

        // CONSIDER : ChrisAn, 5/9/00 - There should be a section in config
        //          : that fixes this, for beta we will hard code it...
        //
        if (CompilerInfo.CompilerType == typeof(Microsoft.VisualBasic.VBCodeProvider))
            _sourceDataNamespace.Imports.Add(new CodeNamespaceImport("Microsoft.VisualBasic"));

        // Add all the default namespaces
        int count = _defaultNamespaces.Length;
        for (int i=0; i<count; i++) {
            _sourceDataNamespace.Imports.Add(new CodeNamespaceImport(_defaultNamespaces[i]));
        }

        // Add all the namespaces
        if (Parser.NamespaceEntries != null) {
            foreach (NamespaceEntry entry in Parser.NamespaceEntries) {
                // Create a line pragma if available    
                CodeLinePragma linePragma;
                if (entry.SourceFileName != null) {
                    linePragma = CreateCodeLinePragma(entry.SourceFileName, entry.Line);
                }
                else {
                    linePragma = null;
                }

                CodeNamespaceImport nsi = new CodeNamespaceImport(entry.Namespace);
                nsi.LinePragma = linePragma;

                _sourceDataNamespace.Imports.Add(nsi);
            }
        }

        // Add all the assemblies
        if (Parser.AssemblyDependencies != null) {
            foreach (Assembly assembly in Parser.AssemblyDependencies.Keys) {
                // some code generators need the assembly names at generation time as well
                // as compile time, so inject them into both.
                string assemblyName = Util.GetAssemblyCodeBase(assembly);
                _compilParams.ReferencedAssemblies.Add(assemblyName);
                _sourceData.ReferencedAssemblies.Add(assemblyName);
            }
        }

        // Since this is needed in several places, store it in a member variable
        _classTypeExpr = new CodeTypeReferenceExpression(_sourceDataNamespace.Name + "." + _sourceDataClass.Name);

        // Add the implemented interfaces
        GenerateInterfaces();

        // Build various properties, fields, methods
        BuildMiscClassMembers();

        // Build the default constructors
        _ctor = new CodeConstructor();
        _sourceDataClass.Members.Add(_ctor);
        BuildDefaultConstructor();
    }

    /*
     * Add metadata attributes to the class
     */
    protected virtual void GenerateClassAttributes() {
        // If this is a debuggable page, generate a
        // CompilerGlobalScopeAttribute attribute (ASURT 33027)
        if (CompilParams.IncludeDebugInformation) {
            CodeAttributeDeclaration attribDecl = new CodeAttributeDeclaration(
                "System.Runtime.CompilerServices.CompilerGlobalScopeAttribute");
            _sourceDataClass.CustomAttributes.Add(attribDecl);
        }
    }

    /*
     * Generate the list of implemented interfaces
     */
    protected virtual void GenerateInterfaces() {
        if (Parser.ImplementedInterfaces != null) {
            foreach (Type t in Parser.ImplementedInterfaces) {
                _sourceDataClass.BaseTypes.Add(new CodeTypeReference(t.FullName));
            }
        }
    }

    /*
     * Build first-time intialization statements
     */
    protected virtual void BuildInitStatements(CodeStatementCollection trueStatements, CodeStatementCollection topLevelStatements) {
    }


    /*
     * Build the default constructor
     */
    protected virtual void BuildDefaultConstructor() {

        _ctor.Attributes &= ~MemberAttributes.AccessMask;
        _ctor.Attributes |= MemberAttributes.Public;

        // private static bool __initialized;
        CodeMemberField initializedField = new CodeMemberField(typeof(bool), intializedFieldName);
        initializedField.Attributes |= MemberAttributes.Static;
        initializedField.InitExpression = new CodePrimitiveExpression(false);
        _sourceDataClass.Members.Add(initializedField);


        // if (__intialized == false)
        CodeConditionStatement initializedCondition = new CodeConditionStatement();
        initializedCondition.Condition = new CodeBinaryOperatorExpression(
                                                new CodeFieldReferenceExpression(
                                                    _classTypeExpr, 
                                                    intializedFieldName), 
                                                CodeBinaryOperatorType.ValueEquality, 
                                                new CodePrimitiveExpression(false));

        this.BuildInitStatements(initializedCondition.TrueStatements, _ctor.Statements);

        initializedCondition.TrueStatements.Add(new CodeAssignStatement(
                                                    new CodeFieldReferenceExpression(
                                                        _classTypeExpr, 
                                                        intializedFieldName), 
                                                    new CodePrimitiveExpression(true)));

        // i.e. __intialized = true;
        _ctor.Statements.Add(initializedCondition);
    }

    /*
     * Build various properties, fields, methods
     */
    protected virtual void BuildMiscClassMembers() {

        // Build the injected properties from the global.asax <object> tags
        BuildApplicationObjectProperties();
        BuildSessionObjectProperties();

        // Build the injected properties for objects scoped to the page
        BuildPageObjectProperties();

        // Add all the script blocks
        foreach (ScriptBlockData script in Parser.ScriptList) {
            CodeSnippetTypeMember literal = new CodeSnippetTypeMember(script.Script);
            literal.LinePragma = CreateCodeLinePragma(script.SourceFileName, script.Line); 
            _sourceDataClass.Members.Add(literal);
        }
    }

    /*
     * Helper method used to build the properties of injected
     * global.asax properties.  These look like:
     *   PropType __propName;
     *   protected PropType propName
     *   {
     *       get
     *       {
     *           if (__propName == null)
     *               __propName = [some expression];
     *
     *           return __propName;
     *       }
     *   }
     */
    private void BuildInjectedGetPropertyMethod(string propName, 
                                                string propType,
                                                CodeExpression propertyInitExpression,
                                                bool fPublicProp) {

        string fieldName = "cached" + propName;

        CodeExpression fieldAccess = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), fieldName);

        // Add a private field for the object
        _sourceDataClass.Members.Add(new CodeMemberField(propType, fieldName));


        CodeMemberProperty prop = new CodeMemberProperty();
        if (fPublicProp) {
            prop.Attributes &= ~MemberAttributes.AccessMask;
            prop.Attributes |= MemberAttributes.Public;
        }
        prop.Name = propName;
        prop.Type = new CodeTypeReference(propType);


        CodeConditionStatement ifStmt = new CodeConditionStatement();
        ifStmt.Condition = new CodeBinaryOperatorExpression(fieldAccess, CodeBinaryOperatorType.IdentityEquality, new CodePrimitiveExpression(null));
        ifStmt.TrueStatements.Add(new CodeAssignStatement(fieldAccess, propertyInitExpression));

        prop.GetStatements.Add(ifStmt);
        prop.GetStatements.Add(new CodeMethodReturnStatement(fieldAccess));

        _sourceDataClass.Members.Add(prop);
    }

    /*
     * Helper method for building application and session scope injected
     * properties.  If useApplicationState, build application properties, otherwise
     * build session properties.
     */
    private void BuildObjectPropertiesHelper(IDictionary objects, bool useApplicationState) {

        IDictionaryEnumerator en = objects.GetEnumerator();
        while (en.MoveNext()) {
            HttpStaticObjectsEntry entry = (HttpStaticObjectsEntry)en.Value;

            // e.g. (PropType)Session.StaticObjects["PropName"]

            // Use the appropriate collection
            CodePropertyReferenceExpression stateObj = new CodePropertyReferenceExpression(new CodePropertyReferenceExpression(new CodeThisReferenceExpression(),
                                                                                                                               useApplicationState ? "Application" : "Session"),
                                                                                           "StaticObjects");

            CodeMethodInvokeExpression getObject = new CodeMethodInvokeExpression(stateObj, "GetObject");
            getObject.Parameters.Add(new CodePrimitiveExpression(entry.Name));


            Type declaredType = entry.DeclaredType;
            Debug.Assert(!Util.IsLateBoundComClassicType(declaredType));

            if (useApplicationState) {
                // for application state use property that does caching in a member
                BuildInjectedGetPropertyMethod(entry.Name, declaredType.FullName,
                                               new CodeCastExpression(declaredType.FullName, getObject),
                                               false /*fPublicProp*/);
            }
            else {
                // for session state use lookup every time, as one application instance deals with many sessions
                CodeMemberProperty prop = new CodeMemberProperty();
                prop.Name = entry.Name;
                prop.Type = new CodeTypeReference(declaredType.FullName);
                prop.GetStatements.Add(new CodeMethodReturnStatement(new CodeCastExpression(declaredType.FullName, getObject)));
                _sourceDataClass.Members.Add(prop);
            }
        }
    }

    /*
     * Build the injected properties from the global.asax <object> tags
     * declared with scope=application
     */
    private void BuildApplicationObjectProperties() {
        if (Parser.ApplicationObjects != null)
            BuildObjectPropertiesHelper(Parser.ApplicationObjects.Objects, true);
    }

    /*
     * Build the injected properties from the global.asax <object> tags
     * declared with scope=session
     */
    private void BuildSessionObjectProperties() {
        if (Parser.SessionObjects != null)
            BuildObjectPropertiesHelper(Parser.SessionObjects.Objects, false);
    }

    protected virtual bool FPublicPageObjectProperties { get { return false; } }

    /*
     * Build the injected properties from the global.asax <object> tags
     * declared with scope=appinstance, or the aspx/ascx tags with scope=page.
     */
    private void BuildPageObjectProperties() {
        if (Parser.PageObjectList == null) return;

        foreach (ObjectTagBuilder obj in Parser.PageObjectList) {
            
            CodeExpression propertyInitExpression;

            if (obj.Progid != null) {
                // If we are dealing with a COM classic object that hasn't been tlbreg'ed,
                // we need to call HttpServerUtility.CreateObject(progid) to create it
                CodeMethodInvokeExpression createObjectCall = new CodeMethodInvokeExpression();

                createObjectCall.Method.TargetObject = new CodePropertyReferenceExpression(
                    new CodeThisReferenceExpression(), "Server");
                createObjectCall.Method.MethodName = "CreateObject";
                createObjectCall.Parameters.Add(new CodePrimitiveExpression(obj.Progid));

                propertyInitExpression = createObjectCall;
            }
            else if (obj.Clsid != null) {
                // Same as previous case, but with a clsid instead of a progId
                CodeMethodInvokeExpression createObjectCall = new CodeMethodInvokeExpression();
                createObjectCall.Method.TargetObject = new CodePropertyReferenceExpression(
                    new CodeThisReferenceExpression(), "Server");
                createObjectCall.Method.MethodName = "CreateObjectFromClsid";
                createObjectCall.Parameters.Add(new CodePrimitiveExpression(obj.Clsid));

                propertyInitExpression = createObjectCall;
            }
            else {
                propertyInitExpression = new CodeObjectCreateExpression(obj.ObjectType.FullName);
            }

            BuildInjectedGetPropertyMethod(obj.ID, obj.DeclaredType.FullName,
                propertyInitExpression, FPublicPageObjectProperties);
        }
    }

    protected CodeLinePragma CreateCodeLinePragma(string sourceFile, int lineNumber) {

        // Return null if we're not supposed to generate line pragmas
        if (!Parser.FLinePragmas)
            return null;

        if (sourceFile == null)
            return null;

        return new CodeLinePragma(sourceFile, lineNumber);
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\compilation\compilationlock.cs ===
//------------------------------------------------------------------------------
// <copyright file="CompilationLock.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Compilation {

using System;
using System.Threading;
using System.Globalization;
using System.Security.Principal;
using System.Web.Util;
using System.Web.Configuration;
using System.Runtime.InteropServices;

internal sealed class CompilationMutex : IDisposable {

    private String  _name;
    private String  _comment;
    private HandleRef   _mutexHandle;

    // Lock Status is used to drain out all worker threads out of Mutex ownership on
    // app domain shutdown: -1 locked for good, 0 unlocked, N locked by a worker thread(s)
    private int     _lockStatus;  
    private bool    _draining;

    internal CompilationMutex(bool initialOwner, String name, String comment) {

        // Append the machine key's hash code to the mutex name to prevent hijacking (ASURT 123013)
        int hashCode = MachineKey.ValidationKeyHashCode;
        name += "-" + hashCode.ToString("x");

        _mutexHandle = new HandleRef(this, UnsafeNativeMethods.InstrumentedMutexCreate(name));

        if (_mutexHandle.Handle == IntPtr.Zero)
            throw new InvalidOperationException(HttpRuntime.FormatResourceString(SR.CompilationMutex_Create));

        _name = name;
        _comment = comment;
        Debug.Trace("Mutex", "Created Mutex " + MutexDebugName);
    }

    internal CompilationMutex(bool initialOwner, String name) : this(initialOwner, name, null) {
    }

    ~CompilationMutex() {
        Close();
    }

    void IDisposable.Dispose() {
        Close();
        System.GC.SuppressFinalize(this);
    }

    internal /*public*/ void Close() {
        if (_mutexHandle.Handle != IntPtr.Zero) {
            UnsafeNativeMethods.InstrumentedMutexDelete(_mutexHandle);
            _mutexHandle = new HandleRef(this, IntPtr.Zero);
        }
    }

    internal /*public*/ void WaitOne() {
        if (_mutexHandle.Handle == IntPtr.Zero)
            throw new InvalidOperationException(HttpRuntime.FormatResourceString(SR.CompilationMutex_Null));

        // check the lock status
        for (;;) {
            int lockStatus = _lockStatus;

            if (lockStatus == -1 || _draining)
                throw new InvalidOperationException(HttpRuntime.FormatResourceString(SR.CompilationMutex_Drained));

            if (Interlocked.CompareExchange(ref _lockStatus, lockStatus+1, lockStatus) == lockStatus)
                break; // got the lock
        }

        Debug.Trace("Mutex", "Waiting for mutex " + MutexDebugName);

        if (UnsafeNativeMethods.InstrumentedMutexGetLock(_mutexHandle, -1) == -1) {
            // failed to get the lock
            Interlocked.Decrement(ref _lockStatus);
            throw new InvalidOperationException(HttpRuntime.FormatResourceString(SR.CompilationMutex_Failed));
        }

        Debug.Trace("Mutex", "Got mutex " + MutexDebugName);
    }

    internal /*public*/ void ReleaseMutex() {
        if (_mutexHandle.Handle == IntPtr.Zero)
            throw new InvalidOperationException(HttpRuntime.FormatResourceString(SR.CompilationMutex_Null));

        Debug.Trace("Mutex", "Releasing mutex " + MutexDebugName);
    
        if (UnsafeNativeMethods.InstrumentedMutexReleaseLock(_mutexHandle) != 0)
            Interlocked.Decrement(ref _lockStatus);
    }

    internal /*public*/ void DrainMutex() {
        // keep trying to set _lockStatus to -1 if it is 0
        Debug.Trace("Mutex", "Starting draining mutex " + MutexDebugName);

        _draining = true;

        for (;;) {
            if (_lockStatus == -1)
                break;
            if (Interlocked.CompareExchange(ref _lockStatus, -1, 0) == 0)
                break; // got it

            Thread.Sleep(100);
        }

        Debug.Trace("Mutex", "Completed drained mutex " + MutexDebugName);
    }

    internal /*public*/ void SetState(int state) {
        if (_mutexHandle.Handle != IntPtr.Zero)
            UnsafeNativeMethods.InstrumentedMutexSetState(_mutexHandle, state);
    }

    private String MutexDebugName {
        get {
#if DBG
            return (_comment != null) ? _name + "(" + _comment + ")" : _name;
#else
            return _name;
#endif
        }
    }
}

internal class CompilationLock {

    private static CompilationMutex _mutex;

    static CompilationLock() {

        // Create the mutex (or just get it if another process created it).
        // Make the mutex unique per application
        int hashCode = ("CompilationLock" + HttpRuntime.AppDomainAppIdInternal).GetHashCode();

        _mutex = new CompilationMutex(
                        false, 
                        "CL" + hashCode.ToString("x"), 
                        "CompilationLock for " + HttpRuntime.AppDomainAppVirtualPath);
    }

    internal CompilationLock() {
    }

    internal static void GetLock() {
        _mutex.WaitOne();
    }

    internal static void ReleaseLock() {
        _mutex.ReleaseMutex();
    }

    internal static void DrainMutex() {
        _mutex.DrainMutex();
    }

    internal static void SetMutexState(int state) {
        _mutex.SetState(state);
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\compilation\batchdomcompilation.cs ===
//------------------------------------------------------------------------------
// <copyright file="BatchDOMCompilation.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Compilation {
using System;
using System.IO;
using System.Collections;
using System.Collections.Specialized;
using System.Reflection;
using System.Text;
using System.Web.Util;
using System.Web.UI;
using HttpException = System.Web.HttpException;
using Debug=System.Web.Util.Debug;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Globalization;


internal class BatchCompilationEntry {
    private TemplateControlCompiler _compiler;
    private TemplateParser _templateParser;
    private bool _fUserControl; // true for UserControl. false for Page
    private Assembly _assembly;
    private CompilerInfo _compilerInfo;
    private string _generatedSourceFile;
    private string _virtualPath;
    private string _pageFilename;
    private string _typeName;
    private Hashtable _fileDependencies;
    private Hashtable _assemblyDependencies;

    internal BatchCompilationEntry(string virtualPath, string filename, HttpContext context) {
        _virtualPath = virtualPath;
        string extension = Path.GetExtension(filename);

        if (string.Compare(extension, ".aspx", true, CultureInfo.InvariantCulture) == 0) {
            _templateParser = new PageParser();
        }
        else if (string.Compare(extension, ".ascx", true, CultureInfo.InvariantCulture) == 0) {
            _templateParser = new UserControlParser();
            _fUserControl = true;
        }
        else {
            Debug.Assert(false, "Unexpected extension");
        }

        _templateParser.InputFile = filename;
        _templateParser.Context = context;
        _templateParser.CurrentVirtualPath = virtualPath;
    }

    internal String VirtualPath {
        get { return _virtualPath; }
    }

    internal String PageFilename {
        get { return _pageFilename; }
    }

    internal String GeneratedSourceFile {
        get { return _generatedSourceFile; }
        set { _generatedSourceFile = value; }
    }

    internal Type TypeObject {
        get { return _assembly.GetType(GetTypeName(), true /*throwOnFail*/); }
    }

    // The list of assemblies that the compiled DLL is dependent on
    internal Hashtable AssemblyDependencies {
        get { return _assemblyDependencies; }
    }

    internal Hashtable FileDependencies {
        get { return _fileDependencies; }
    }

    /*
     * Do one phase of sourcefiledata generation based on language requirements
     */
     
    internal void BuildCodeModel(ICodeGenerator generator, StringResourceBuilder stringResourceBuilder) {
        _compiler.GenerateCodeModelForBatch(generator, stringResourceBuilder);
    }

    internal /*public*/ CodeCompileUnit GetCodeModel() {
        return _compiler.GetCodeModel();
    }

    internal /*public*/ void SetTargetAssembly(Assembly assembly) {
        _assembly = assembly;
    }

    /*
     * Do all of the language-independent work
     */
    internal void Precompile() {
        _templateParser.Parse();

        _compilerInfo = _templateParser.CompilerInfo;
        _pageFilename = _templateParser.InputFile;
        _assemblyDependencies = _templateParser.AssemblyDependencies;

        // Set the file dependencies in the templateParser
        string[] sourceDependencies = new string[_templateParser.SourceDependencies.Count];
        _templateParser.SourceDependencies.Keys.CopyTo(sourceDependencies, 0);
        _templateParser._fileDependencies = sourceDependencies;

        if (_fUserControl)
            _compiler = new UserControlCompiler((UserControlParser)_templateParser);
        else
            _compiler = new PageCompiler((PageParser)_templateParser);
    }

    internal void PostSourceCodeGeneration() {
        _typeName = _compiler.GetTypeName();
        _fileDependencies = _templateParser.SourceDependencies;
        _compiler = null;
        _templateParser = null;
    }

    internal void PostCompilation() {
        // Release some things that are no longer needed
        _fileDependencies = null;
        _assemblyDependencies = null;
        _generatedSourceFile = null;
    }

    /*
     * Extract compiler type from precompiled information
     */
    internal CompilerInfo CompilerInfo {
        get { return _compilerInfo; }
    }

    internal bool IsTrivialPage() {
        return !_templateParser.FRequiresCompilation;
    }
    
    internal bool IsDebugPage() {
        return _templateParser.DebuggingEnabled;
    }
    
    internal string GetTypeName() {
        return _typeName;
    }
}


class CodeDomBatchManager {

    // Used to keep track of batching exceptions per directory
    private static Hashtable _batchErrors = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);
    internal static Hashtable BatchErrors { get { return _batchErrors; } }

    internal CodeDomBatchManager() {
    }

    private static void AddFileSet(string virtualDir, DirectoryInfo filesDirectory,
        string searchString, BatchTemplateParser btp) {

        FileInfo[] files = filesDirectory.GetFiles(searchString);

        for (int index = 0; index < files.Length; ++ index) {
            FileInfo file = files[index];
            if ((file.Attributes & FileAttributes.Directory) != 0)
                continue;

            // Set the virtual path of the current file in the parser
            string currentVirtualPath = UrlPath.Combine(virtualDir, file.Name);
            btp.CurrentVirtualPath = currentVirtualPath;

            Debug.Trace("Batching", "CodeDomBatching file " + file.Name + " (" + currentVirtualPath + ")");
            btp.AddSource(file.FullName);
        }
    }

    internal /*public*/ static void BatchCompile(string virtualDir, HttpContext context) {

        string prevConfigPath = context.ConfigPath;

        try {
            try {
                // Set the config path to the virtual path that we're batching
                Debug.Trace("Batching", "Setting ConfigPath to " + virtualDir);
                context.ConfigPath = virtualDir;

                BatchCompileInternal(virtualDir, context);
            }
            catch (Exception e) {
                // Save the exception
                _batchErrors[virtualDir] = e;
                throw;
            }
            finally {
                // Restore the config path to its previous value
                Debug.Trace("Batching", "Restoring ConfigPath to " + prevConfigPath);
                context.ConfigPath = prevConfigPath;
            }
        }
        catch { throw; }    // Prevent Exception Filter Security Issue (ASURT 122825)
    }

    private static void BatchCompileInternal(string virtualDir, HttpContext context) {

        string directory = context.Request.MapPath(virtualDir);

        // Prescan all files in the current directory to see inter-file dependencies
        DirectoryInfo filesDirectory = new DirectoryInfo(directory);
        BatchTemplateParser btp = new BatchTemplateParser(context);

        AddFileSet(virtualDir, filesDirectory, "*.aspx", btp);
        AddFileSet(virtualDir, filesDirectory, "*.ascx", btp);

        // Based on dependencies, split into phases

        SourceReference[][] sources = BatchDependencyWalker.Split(btp.GetSourceReferences());
        btp = null;

        // Tell the server that we're still running to make sure it doesn't kill us (ASURT 96452)
        context.SendEmptyResponse();

#if DBG
        for (int i = 0; i < sources.Length; i++) {
            SourceReference[] bucket = sources[i];
            Debug.Trace("Batching", "");
            Debug.Trace("Batching", "Bucket " + i + " contains " + bucket.Length + " files");

            for (int j = 0; j < bucket.Length; j++)
                Debug.Trace("Batching", bucket[j].Filename);
        }
#endif

        // Batch compile each phase separately

        for (int i = 0; i < sources.Length; i++) {
            SourceReference[] batch = sources[i];
            ArrayList list = new ArrayList();

            // cons up the TemplateParserParameters

            for (int j = 0; j < batch.Length; j++) {
                string filename = batch[j].Filename;
                string virtualPath = UrlPath.Combine(virtualDir,
                    Path.GetFileName(filename));
                list.Add(new BatchCompilationEntry(virtualPath, filename, context));
            }

            // Now batch compile them

            if (list.Count > 0)
                BatchCompile(list, context, virtualDir);
        }
    }

    // List of pages with the same language
    internal class PagesWithSameCompilerInfo {

        // Max size allowed for all the generated source files in this bucket
        private int _maxBatchGeneratedFileSize;

        // Max number of pages per batched compilation
        private int _maxBatchSize;

        // Current total size of all the generated source files in this bucket
        private long _currentFileLength;

        // Provider for the language used
        private CodeDomProvider _codeProvider;
        internal CodeDomProvider CodeProvider { get { return _codeProvider; } }

        private ArrayList _pages;
        internal ArrayList Pages { get { return _pages; } }

        internal int PageCount { get { return _pages.Count; } }

        // The StringResourceBuilder shared by the pages
        internal StringResourceBuilder _stringResourceBuilder = new StringResourceBuilder();

        internal PagesWithSameCompilerInfo(Type compilerType, int maxBatchGeneratedFileSize,
            int maxBatchSize) {
            _maxBatchGeneratedFileSize = maxBatchGeneratedFileSize;
            _maxBatchSize = maxBatchSize;
            _codeProvider = (CodeDomProvider) Activator.CreateInstance(compilerType);
        }

        internal void AddPage(BatchCompilationEntry e) {
            if (_pages == null)
                _pages = new ArrayList();
            _pages.Add(e);

            FileInfo file = new FileInfo(e.GeneratedSourceFile);
            _currentFileLength += file.Length;
        }

        internal bool IsBucketFull {
            get {
                return (_currentFileLength >= _maxBatchGeneratedFileSize) ||
                    (PageCount >= _maxBatchSize);
            }
        }
    }

    private static void BatchCompile(ArrayList inputList, HttpContext context, string virtualDir) {

        Exception errorException = null;

        // Used to create temporary source files
        TempFileCollection tempFiles = new TempFileCollection(HttpRuntime.CodegenDirInternal);

        // Counter to name generated files uniquely
        int fileCount = 0;

        int maxBatchGeneratedFileSize = CompilationConfiguration.GetMaxBatchGeneratedFileSize(context);
        int maxBatchSize = CompilationConfiguration.GetMaxBatchSize(context);

        Hashtable languageBuckets = new Hashtable();

        // Go through all the files that need to be compiled
        foreach (BatchCompilationEntry currentPage in inputList) {

            // precompile, and skip pages that fail to precompile
            try {
                currentPage.Precompile();
            }
            catch (Exception e) {
                // remember the first exception
                if (errorException == null)
                    errorException = e;

                Debug.Trace("Batching", "Skipping " + currentPage.PageFilename + " due to parse error ("
                    + e.Message + ")");

                continue;
            }

            // Skip trivial pages and pages that have the debug flag
            if (currentPage.IsTrivialPage() || currentPage.IsDebugPage())
                continue;

            // Determine what language bucket it belongs to based on the CompilerInfo
            CompilerInfo compInfo = currentPage.CompilerInfo;
            PagesWithSameCompilerInfo pwsci = (PagesWithSameCompilerInfo)languageBuckets[compInfo];
            if (pwsci == null) {
                pwsci = new PagesWithSameCompilerInfo(currentPage.CompilerInfo.CompilerType,
                    maxBatchGeneratedFileSize * 1024, maxBatchSize);
                languageBuckets[compInfo] = pwsci;
            }

            ICodeGenerator generator = pwsci.CodeProvider.CreateGenerator();

            // Build the CodeDOM tree for the page
            currentPage.BuildCodeModel(generator, pwsci._stringResourceBuilder);
            CodeCompileUnit compileUnit = currentPage.GetCodeModel();

            // Generate a temporary source file from the CodeDOM tree
            string filename = tempFiles.AddExtension(
                (fileCount++) + "." + pwsci.CodeProvider.FileExtension, true /*keepFiles*/);
            Stream temp = new FileStream(filename, FileMode.Create, FileAccess.Write, FileShare.Read);
            try {
                StreamWriter sw = new StreamWriter(temp, Encoding.UTF8);
                generator.GenerateCodeFromCompileUnit(compileUnit, sw, null /*CodeGeneratorOptions*/);
                sw.Flush();
                sw.Close();
            }
            finally {
                temp.Close();
            }

            currentPage.GeneratedSourceFile = filename;

            // This releases a number of things that are no longer needed after this point
            currentPage.PostSourceCodeGeneration();

            // Add it to the language bucket
            pwsci.AddPage(currentPage);

            // If the bucket is full, compile all its pages and get rid of it
            if (pwsci.IsBucketFull) {
                try {
                    BasicBatchCompilation(context, compInfo.Clone(), pwsci);

                    // Tell the server that we're still running to make sure it doesn't kill us (ASURT 96452)
                    context.SendEmptyResponse();
                }
                catch (Exception e) {
                    // remember the first exception
                    if (errorException == null)
                        errorException = e;
                }
                languageBuckets.Remove(compInfo);
            }
        }

        // Compile whatever is left in all the buckets
        for (IDictionaryEnumerator de = (IDictionaryEnumerator)languageBuckets.GetEnumerator(); de.MoveNext(); ) {

            try {
                BasicBatchCompilation(context, ((CompilerInfo)de.Key).Clone(),
                    (PagesWithSameCompilerInfo)de.Value);
            }
            catch (Exception e) {
                // remember the first exception
                if (errorException == null)
                    errorException = e;
            }
        }

        // If there was an error, rethrow it
        if (errorException != null)
            throw new HttpException(null, errorException);
    }

    private static void BasicBatchCompilation(HttpContext context,
        CompilerInfo compInfo, PagesWithSameCompilerInfo pwsci) {

        ICodeCompiler compiler = pwsci.CodeProvider.CreateCompiler(); 

        Debug.Trace("Batching", "Compiling " + pwsci.PageCount + " pages");

        CompilerParameters compilParams = compInfo.CompilParams;

        compilParams.TempFiles = new TempFileCollection(HttpRuntime.CodegenDirInternal);

        // Create the resource file (shared by all the pages in the bucket)
        if (pwsci._stringResourceBuilder.HasStrings) {
            string resFileName = compilParams.TempFiles.AddExtension("res");
            pwsci._stringResourceBuilder.CreateResourceFile(resFileName);
            compilParams.Win32Resource = resFileName;
        }

        // Never generate debug code when we're batching
        compilParams.TempFiles.KeepFiles = false;
        compilParams.IncludeDebugInformation = false;

        // Compute a table of all the assemblies used by all the pages in the
        // bucket, removing duplicates
        Hashtable allAssemblies = new Hashtable();

        // Place all the generated source file names in an array
        string[] files = new string[pwsci.PageCount];
        int fileCount=0;
        foreach (BatchCompilationEntry e in pwsci.Pages) {

            Debug.Assert(FileUtil.FileExists(e.GeneratedSourceFile), e.GeneratedSourceFile + " is missing!");

            files[fileCount++] = e.GeneratedSourceFile;

            // Add all the assemblies
            if (e.AssemblyDependencies != null) {
                foreach (Assembly assembly in e.AssemblyDependencies.Keys) {
                    string assemblyName = Util.GetAssemblyCodeBase(assembly);
                    allAssemblies[assemblyName] = null;
                }
            }
        }
        Debug.Assert(fileCount == pwsci.PageCount, "fileCount == pwsci.PageCount");

        // Now, add all the (non-duplicate) assemblies to the compilParams
        foreach (string aname in allAssemblies.Keys)
            compilParams.ReferencedAssemblies.Add(aname);

        // Compile them all together into an assembly
        CompilerResults results;
        try {
            results = compiler.CompileAssemblyFromFileBatch(compilParams, files);
        }
        catch (Exception e) {
            Debug.Trace("Batching", "Compilation failed!  " + e.Message);
            throw new HttpUnhandledException(HttpRuntime.FormatResourceString(SR.CompilationUnhandledException, pwsci.CodeProvider.GetType().FullName), e);
        }
        finally {
            // Delete all the generated source files
            for (int i = 0; i < fileCount; i++)
                File.Delete(files[i]);
        }

        BaseCompiler.ThrowIfCompilerErrors(results, pwsci.CodeProvider, null, null, null);

        // Note the assembly that everything ended up in
        foreach (BatchCompilationEntry e in pwsci.Pages) {
            e.SetTargetAssembly(results.CompiledAssembly);
            CacheResults(context, e);

            // Do some cleanup
            e.PostCompilation();
        }
    }

    private static void CacheResults(HttpContext context, BatchCompilationEntry pce) {
        PreservedAssemblyEntry entry = new PreservedAssemblyEntry(context,
            pce.VirtualPath,
            false /*fApplicationFile*/, null /*assembly*/, pce.TypeObject, pce.FileDependencies);

        entry.SaveDataToFile(true /*fBatched*/);
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\compilation\sourcecompiler.cs ===
//------------------------------------------------------------------------------
// <copyright file="SourceCompiler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Compilation {
using System;
using System.Collections;
using System.Reflection;
using System.IO;
using System.Web.Caching;
using System.Web.Util;
using System.Web.UI;
using System.CodeDom;
using System.CodeDom.Compiler;
using Util = System.Web.UI.Util;
using Debug=System.Web.Util.Debug;

internal class SourceCompiler {

    private HttpContext _context;
    private CacheInternal _cache;
    private string _cacheKey;
    private string _virtualPath;
    private string _physicalPath;
    private string _sourceString;
    private string _typeName;
    private CodeLinePragma _linePragma;
    private IDictionary _assemblies;
    private Type _compilerType;
    private CompilerParameters _compilParams;
    private bool _typeNotFoundInAssembly;
    private DateTime _utcStart;
    private Hashtable _sourceDependencies;


    internal /*public*/ static Assembly GetAssemblyFromSourceFile(HttpContext context,
        string virtualPath, IDictionary assemblies, Type compilerType,
        CompilerParameters compilParams) {

        SourceCompiler sourceCompiler = new SourceCompiler(context, virtualPath);

        // First, see if it's cached
        Assembly a = sourceCompiler.GetAssemblyFromCache();
        if (a != null)
            return a;

        try {
            //CompilationLock.GetLock();

            // Try the cache again
            a = sourceCompiler.GetAssemblyFromCache();
            if (a != null)
                return a;

            return sourceCompiler.CompileSourceFileIntoAssembly(assemblies,
                compilerType, compilParams);
        }
        finally {
            //CompilationLock.ReleaseLock();
        }
    }

    internal /*public*/ SourceCompiler(HttpContext context, string virtualPath) {

        _context = context;
        if (virtualPath == null)
            _virtualPath = context.Request.FilePath;
        else
            _virtualPath = virtualPath;

        _cache = System.Web.HttpRuntime.CacheInternal;
        _cacheKey = "System.Web.Compilation.SourceCompiler:" + _virtualPath;
    }

    /*
     * Try to get a cached Assembly
     */
    internal /*public*/ Assembly GetAssemblyFromCache() {

        SourceCompilerCachedEntry scce = GetCachedEntry();
        if (scce == null)
            return null;

        return scce._assembly;
    }

    /*
     * Try to get a cached Type
     */
    internal /*public*/ Type GetTypeFromCache() {

        SourceCompilerCachedEntry scce = GetCachedEntry();
        if (scce == null)
            return null;

        return scce._type;
    }

    internal bool TypeNotFoundInAssembly {
        get { return _typeNotFoundInAssembly; }
    }

    private SourceCompilerCachedEntry GetCachedEntry() {

        // First, try to get it from the in-memory cache
        SourceCompilerCachedEntry scce = (SourceCompilerCachedEntry) _cache.Get(_cacheKey);
        if (scce != null) {
            Debug.Trace("Template", "Compiled source code found in cache (" + _virtualPath + "," + scce._assembly.GetName().Name + ")");
            return scce;
        }

        Debug.Trace("Template", "Compiled source code not found in cache (" + _virtualPath + ")");

        _physicalPath = _context.Request.MapPath(_virtualPath);

        // Before going further, make sure the file at least exists (ASURT 76995)
        Stream str = File.OpenRead(_physicalPath);
        str.Close();

        // Try to get it from the preserved assembly cache
        PreservedAssemblyEntry entry = PreservedAssemblyEntry.GetPreservedAssemblyEntry(
            _context, _virtualPath, false /*fApplicationFile*/);

        // If it's not there, fail
        if (entry == null)
            return null;


        // We found it.  Cache it in-memory

        _utcStart = DateTime.UtcNow;
        
        scce = new SourceCompilerCachedEntry();
        scce._assembly = entry.Assembly;
        scce._type = entry.ObjectType;

        CacheEntryToMemory(scce);

        // Return it
        return scce;
    }

    internal void CacheType(Type t, DateTime utcStart) {
        SourceCompilerCachedEntry scce = new SourceCompilerCachedEntry();
        scce._type = t;
        scce._assembly = t.Assembly;
        _utcStart = utcStart;
        CacheEntryToMemory(scce);
    }

    private void CacheEntryToMemory(SourceCompilerCachedEntry scce) {
        Debug.Assert(_utcStart != DateTime.MinValue);

        // Always add the main compiled file itself as a source dependency
        AddSourceDependency(_physicalPath);

        // Get an array of source file dependencies
        string[] sourceDependencies = Util.StringArrayFromHashtable(_sourceDependencies);

        _cache.UtcInsert(_cacheKey, scce, new CacheDependency(false, sourceDependencies, _utcStart),
            Cache.NoAbsoluteExpiration, Cache.NoSlidingExpiration,
            CacheItemPriority.NotRemovable, null);

        Debug.Trace("Template", "Caching source code (" + _virtualPath + "," + scce._assembly.GetName().Name + ")");
    }

    private void CacheEntryToDisk(SourceCompilerCachedEntry scce) {

        // Always add the main compiled file itself as a source dependency
        AddSourceDependency(_physicalPath);

        PreservedAssemblyEntry entry = new PreservedAssemblyEntry(_context,
            _virtualPath, false /*fApplicationFile*/, scce._assembly,
            scce._type, _sourceDependencies);

        entry.SaveDataToFile(false /*fBatched*/);
    }

    /*
     * Create an assembly from a source file, using the specified compilerType.
     * Return the compiled assembly.
     */
    internal /*public*/ Assembly CompileSourceFileIntoAssembly(IDictionary assemblies,
        Type compilerType, CompilerParameters compilParams) {

        _assemblies = assemblies;
        _compilerType = compilerType;
        _compilParams = compilParams;

        SourceCompilerCachedEntry scce = CompileAndCache();

        return scce._assembly;
    }

    /*
     * Create an assembly from a source string, using the specified compilerType.
     * Return the compiled type.
     */
    internal /*public*/ Type CompileSourceStringIntoType(string sourceString,
        string typeName, CodeLinePragma linePragma,
        IDictionary assemblies, Type compilerType, CompilerParameters compilParams) {

        _sourceString = sourceString;
        _typeName = typeName;
        _linePragma = linePragma;
        _assemblies = assemblies;
        _compilerType = compilerType;
        _compilParams = compilParams;

        SourceCompilerCachedEntry scce = CompileAndCache();

        return scce._type;
    }

    private SourceCompilerCachedEntry CompileAndCache() {

        BaseCompiler.GenerateCompilerParameters(_compilParams);

        // Get the set of config assemblies for our context
        IDictionary configAssemblies = CompilationConfiguration.GetAssembliesFromContext(_context);

        if (_assemblies == null)
            _assemblies = new Hashtable();

        // Add all the assemblies from the config object to the hashtable
        // This guarantees uniqueness
        if (configAssemblies != null) {
            foreach (Assembly asm in configAssemblies.Values)
                _assemblies[asm] = null;
        }

        // And the assembly of the application object (global.asax)
        _assemblies[HttpApplicationFactory.ApplicationType.Assembly] = null;

        // Now add all the passed in assemblies to the compilParams
        foreach (Assembly asm in _assemblies.Keys)
            _compilParams.ReferencedAssemblies.Add(Util.GetAssemblyCodeBase(asm));

        // Instantiate the Compiler
        CodeDomProvider codeProvider = (CodeDomProvider) HttpRuntime.CreatePublicInstance(_compilerType);
        ICodeCompiler compiler = codeProvider.CreateCompiler();
        CompilerResults results;

        // Compile the source file or string into an assembly

        try {
            _utcStart = DateTime.UtcNow;

            // If we have a source file, read it as a string and compile it.  This way,
            // the compiler never needs to read the original file, avoiding permission
            // issues (see ASURT 112718)
            if (_sourceString == null) {
                _sourceString = Util.StringFromFile(_physicalPath, _context);

                // Put in some context so that the file can be debugged.
                _linePragma = new CodeLinePragma(_physicalPath, 1);
            }

            CodeSnippetCompileUnit snippetCompileUnit = new CodeSnippetCompileUnit(_sourceString);
            snippetCompileUnit.LinePragma = _linePragma;
            results = compiler.CompileAssemblyFromDom(_compilParams, snippetCompileUnit);
        }
        catch (Exception e) {
            throw new HttpUnhandledException(HttpRuntime.FormatResourceString(SR.CompilationUnhandledException, codeProvider.GetType().FullName), e);
        }

        BaseCompiler.ThrowIfCompilerErrors(results, codeProvider,
            null, _physicalPath, _sourceString);

        SourceCompilerCachedEntry scce = new SourceCompilerCachedEntry();

        // Load the assembly
        scce._assembly = results.CompiledAssembly;

        // If we have a type name, load the type from the assembly
        if (_typeName != null) {
            scce._type = scce._assembly.GetType(_typeName);

            // If the type could not be loaded, delete the assembly and rethrow
            if (scce._type == null) {
                PreservedAssemblyEntry.RemoveOutOfDateAssembly(scce._assembly.GetName().Name);

                // Remember why we failed
                _typeNotFoundInAssembly = true;

                throw new HttpException(
                    HttpRuntime.FormatResourceString(SR.Could_not_create_type, _typeName));
            }
        }

        CacheEntryToDisk(scce);
        CacheEntryToMemory(scce);

        return scce;
    }

    /*
     * Add a file as a dependency for the DLL we're building
     */
    internal void AddSourceDependency(string fileName) {
        if (_sourceDependencies == null)
            _sourceDependencies = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);

        _sourceDependencies[fileName] = fileName;
    }


    class SourceCompilerCachedEntry {
        internal Assembly _assembly;
        internal Type _type;
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\compilation\pagecompiler.cs ===
//------------------------------------------------------------------------------
// <copyright file="PageCompiler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Compilation {

using System.Text;
using System.Runtime.Serialization.Formatters;
using System.ComponentModel;
using System;
using System.Collections;
using System.Reflection;
using System.IO;
using System.Web.Util;
using System.Web.UI;
using System.Web.SessionState;
using System.CodeDom;
using System.EnterpriseServices;
using Util = System.Web.UI.Util;
using Debug=System.Web.Util.Debug;

internal class PageCompiler : TemplateControlCompiler {

    private PageParser _pageParser;
    PageParser Parser { get { return _pageParser; } }

    private const string fileDependenciesName = "__fileDependencies";
    private const string dependenciesLocalName = "dependencies";

    internal /*public*/ static Type CompilePageType(PageParser pageParser) {
        PageCompiler compiler = new PageCompiler(pageParser);

        return compiler.GetCompiledType();
    }

    internal PageCompiler(PageParser pageParser) : base(pageParser) {
        _pageParser = pageParser;
    }

    /*
     * Generate the list of implemented interfaces
     */
    protected override void GenerateInterfaces() {

        base.GenerateInterfaces();

        if (Parser.FRequiresSessionState) {
            _sourceDataClass.BaseTypes.Add(new CodeTypeReference(typeof(IRequiresSessionState)));
        }
        if (Parser.FReadOnlySessionState) {
            _sourceDataClass.BaseTypes.Add(new CodeTypeReference(typeof(IReadOnlySessionState)));
        }
        if (Parser.AspCompatMode) {
            _sourceDataClass.BaseTypes.Add(new CodeTypeReference(typeof(IHttpAsyncHandler)));
        }

    }

    /*
     * Build first-time intialization statements
     */
    protected override void BuildInitStatements(CodeStatementCollection trueStatements, CodeStatementCollection topLevelStatements) {

        base.BuildInitStatements(trueStatements, topLevelStatements);

        CodeMemberField fileDependencies = new CodeMemberField(typeof(ArrayList), fileDependenciesName);
        fileDependencies.Attributes |= MemberAttributes.Static;
        _sourceDataClass.Members.Add(fileDependencies);

        // Note: it may look like this local variable declaraiton is redundant. However it is necessary
        // to make this init code re-entrant safe. This way, even if two threads enter the contructor
        // at the same time, they will not add multiple dependencies.

        // e.g. ArrayList dependencies;
        CodeVariableDeclarationStatement dependencies = new CodeVariableDeclarationStatement();
        dependencies.Type = new CodeTypeReference(typeof(ArrayList));
        dependencies.Name = dependenciesLocalName;
        topLevelStatements.Insert(0, dependencies);

        // e.g. dependencies = new System.Collections.ArrayList();
        CodeAssignStatement assignDependencies = new CodeAssignStatement();
        assignDependencies.Left = new CodeVariableReferenceExpression(dependenciesLocalName);
        assignDependencies.Right = new CodeObjectCreateExpression(typeof(ArrayList));
        // Note: it is important to add all local variables at the top level for CodeDom Subset compliance.
        trueStatements.Add(assignDependencies);

        Debug.Assert(Parser.FileDependencies != null);
        if (Parser.FileDependencies != null) {
            int count = Parser.FileDependencies.Length;
            for (int i=0; i<count; i++) {
                // depdendencies.Add("...");
                CodeMethodInvokeExpression addFileDep = new CodeMethodInvokeExpression();
                addFileDep.Method.TargetObject = new CodeVariableReferenceExpression(dependenciesLocalName);
                addFileDep.Method.MethodName = "Add";
                addFileDep.Parameters.Add(new CodePrimitiveExpression((string)Parser.FileDependencies[i]));
                trueStatements.Add(new CodeExpressionStatement(addFileDep));
            }
        }

        // e.g. __fileDependencies = dependencies;
        CodeAssignStatement initFile = new CodeAssignStatement();
        initFile.Left = new CodeFieldReferenceExpression(_classTypeExpr,
                                                         fileDependenciesName);
        initFile.Right = new CodeVariableReferenceExpression(dependenciesLocalName);

#if DBG
        AppendDebugComment(trueStatements);
#endif
        trueStatements.Add(initFile);
    }

    /*
     * Build the default constructor
     */
    protected override void BuildDefaultConstructor() {

        base.BuildDefaultConstructor();

        if (Parser.ErrorPage != null) {

            CodeAssignStatement errorPageInit = new CodeAssignStatement();
            errorPageInit.Left = new CodePropertyReferenceExpression(new CodeThisReferenceExpression(),
                                                                     "ErrorPage");
            errorPageInit.Right = new CodePrimitiveExpression((string)Parser.ErrorPage);
#if DBG
            AppendDebugComment(_ctor.Statements);
#endif
            _ctor.Statements.Add(errorPageInit);
        }

        if (Parser.ClientTarget != null && Parser.ClientTarget.Length > 0) {

            CodeAssignStatement clientTargetInit = new CodeAssignStatement();
            clientTargetInit.Left = new CodePropertyReferenceExpression(new CodeThisReferenceExpression(),
                                                                        "ClientTarget");
            clientTargetInit.Right = new CodePrimitiveExpression(Parser.ClientTarget);
            _ctor.Statements.Add(clientTargetInit);
        }

        if (CompilParams.IncludeDebugInformation) {
            // If in debug mode, set the timeout to some huge value (ASURT 49427)
            //      Server.ScriptTimeout = 30000000;
            CodeAssignStatement setScriptTimeout = new CodeAssignStatement();
            setScriptTimeout.Left = new CodePropertyReferenceExpression(
                new CodePropertyReferenceExpression(
                    new CodeThisReferenceExpression(), "Server"),
                "ScriptTimeout");
            setScriptTimeout.Right = new CodePrimitiveExpression(30000000);
            _ctor.Statements.Add(setScriptTimeout);

        }

        if (Parser.TransactionMode != 0 /*TransactionOption.Disabled*/) {
            _ctor.Statements.Add(new CodeAssignStatement(
                new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "TransactionMode"),
                new CodePrimitiveExpression(Parser.TransactionMode)));
        }

        if (Parser.AspCompatMode) {
            _ctor.Statements.Add(new CodeAssignStatement(
                new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "AspCompatMode"),
                new CodePrimitiveExpression(Parser.AspCompatMode)));
        }
    }

    /*
     * Build various properties, fields, methods
     */
    protected override void BuildMiscClassMembers() {
        base.BuildMiscClassMembers();

        BuildGetTypeHashCodeMethod();

        if (Parser.AspCompatMode)
            BuildAspCompatMethods();
    }

    /*
     * Build the data tree for the GetTypeHashCode method
     */
    private void BuildGetTypeHashCodeMethod() {

        CodeMemberMethod method = new CodeMemberMethod();
        method.Name = "GetTypeHashCode";
        method.ReturnType = new CodeTypeReference(typeof(int));
        method.Attributes &= ~MemberAttributes.AccessMask;
        method.Attributes &= ~MemberAttributes.ScopeMask;
        method.Attributes |= MemberAttributes.Override | MemberAttributes.Public;

        _sourceDataClass.Members.Add(method);

#if DBG
        AppendDebugComment(method.Statements);
#endif
        method.Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(Parser.TypeHashCode)));
    }

    /*
     * Build the contents of the FrameworkInitialize method
     */
    protected override void BuildFrameworkInitializeMethodContents(CodeMemberMethod method) {

        base.BuildFrameworkInitializeMethodContents(method);

        method.Statements.Add(new CodeAssignStatement(
            new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "FileDependencies"),
            new CodeFieldReferenceExpression(_classTypeExpr, fileDependenciesName)));

        if (!Parser.FBuffer) {
            method.Statements.Add(new CodeAssignStatement(
                new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "Buffer"),
                new CodePrimitiveExpression(false)));
        }

        if (Parser.Duration != 0 || Parser.OutputCacheLocation == OutputCacheLocation.None) {
            CodeMethodInvokeExpression call = new CodeMethodInvokeExpression();
            call.Method.TargetObject = new CodeThisReferenceExpression();
            call.Method.MethodName = "InitOutputCache";
            call.Parameters.Add(new CodePrimitiveExpression(Parser.Duration));
            call.Parameters.Add(new CodePrimitiveExpression(Parser.VaryByHeader));
            call.Parameters.Add(new CodePrimitiveExpression(Parser.VaryByCustom));
            call.Parameters.Add(new CodeFieldReferenceExpression(
                new CodeTypeReferenceExpression(
                    typeof(OutputCacheLocation).FullName), Parser.OutputCacheLocation.ToString()));
            call.Parameters.Add(new CodePrimitiveExpression(Parser.VaryByParams));
            method.Statements.Add(call);
        }

        if (Parser.ContentType != null) {
            method.Statements.Add(new CodeAssignStatement(
                new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "ContentType"),
                new CodePrimitiveExpression(Parser.ContentType)));
        }

        if (Parser.CodePage != 0) {
            method.Statements.Add(new CodeAssignStatement(
                new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "CodePage"),
                new CodePrimitiveExpression(Parser.CodePage)));
        }
        else if (Parser.ResponseEncoding != null) {
            method.Statements.Add(new CodeAssignStatement(
                new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "ResponseEncoding"),
                new CodePrimitiveExpression(Parser.ResponseEncoding)));
        }

        if (Parser.Culture != null) {
            method.Statements.Add(new CodeAssignStatement(
                new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "Culture"),
                new CodePrimitiveExpression(Parser.Culture)));
        }
        else if (Parser.Lcid != 0) {
            method.Statements.Add(new CodeAssignStatement(
                new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "LCID"),
                new CodePrimitiveExpression(Parser.Lcid)));
        }

        if (Parser.UICulture != null) {
            method.Statements.Add(new CodeAssignStatement(
                new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "UICulture"),
                new CodePrimitiveExpression(Parser.UICulture)));
        }

        if (Parser.TraceEnabled != TraceEnable.Default) {
            method.Statements.Add(new CodeAssignStatement(
                new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "TraceEnabled"),
                new CodePrimitiveExpression(Parser.TraceEnabled == TraceEnable.Enable)));
        }

        if (Parser.TraceMode != TraceMode.Default) {
            method.Statements.Add(new CodeAssignStatement(
                new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "TraceModeValue"),
                new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(TraceMode)), Parser.TraceMode.ToString())));
        }

        if (Parser.EnableViewStateMac) {
            method.Statements.Add(new CodeAssignStatement(
                new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "EnableViewStateMac"),
                new CodePrimitiveExpression(true)));
        }

        if (Parser.SmartNavigation) {
            method.Statements.Add(new CodeAssignStatement(
                new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "SmartNavigation"),
                new CodePrimitiveExpression(true)));
        }

        if (Parser.ValidateRequest) {
            // e.g. Request.ValidateInput();
            CodeMethodInvokeExpression invokeExpr = new CodeMethodInvokeExpression();
            invokeExpr.Method.TargetObject = new CodePropertyReferenceExpression(
                new CodeThisReferenceExpression(), "Request");
            invokeExpr.Method.MethodName = "ValidateInput";
            method.Statements.Add(new CodeExpressionStatement(invokeExpr));
        }
    }

    /*
     * Build the data tree for the AspCompat implementation for IHttpAsyncHandler:
     */
    private void BuildAspCompatMethods() {
        CodeMemberMethod method;
        CodeMethodInvokeExpression call;

        //  public IAsyncResult BeginProcessRequest(HttpContext context, Async'back cb, Object extraData) {
        //      IAsyncResult ar;
        //      ar = this.AspCompatBeginProcessRequest(context, cb, extraData);
        //      return ar;
        //  }

        method = new CodeMemberMethod();
        method.Name = "BeginProcessRequest";
        method.Attributes &= ~MemberAttributes.AccessMask;
        method.Attributes &= ~MemberAttributes.ScopeMask;
        method.Attributes |= MemberAttributes.Public;
        method.ImplementationTypes.Add(new CodeTypeReference(typeof(IHttpAsyncHandler)));
        method.Parameters.Add(new CodeParameterDeclarationExpression(typeof(HttpContext).FullName,   "context"));
        method.Parameters.Add(new CodeParameterDeclarationExpression(typeof(AsyncCallback).FullName, "cb"));
        method.Parameters.Add(new CodeParameterDeclarationExpression(typeof(Object).FullName,        "data"));
        method.ReturnType = new CodeTypeReference(typeof(IAsyncResult));

        CodeMethodInvokeExpression invokeExpr = new CodeMethodInvokeExpression();
        invokeExpr.Method.TargetObject = new CodeThisReferenceExpression();
        invokeExpr.Method.MethodName = "AspCompatBeginProcessRequest";
        invokeExpr.Parameters.Add(new CodeArgumentReferenceExpression("context"));
        invokeExpr.Parameters.Add(new CodeArgumentReferenceExpression("cb"));
        invokeExpr.Parameters.Add(new CodeArgumentReferenceExpression("data"));

        method.Statements.Add(new CodeMethodReturnStatement(invokeExpr));

        _sourceDataClass.Members.Add(method);

        //  public void EndProcessRequest(IAsyncResult ar) {
        //      this.AspCompatEndProcessRequest(ar);
        //  }

        method = new CodeMemberMethod();
        method.Name = "EndProcessRequest";
        method.Attributes &= ~MemberAttributes.AccessMask;
        method.Attributes &= ~MemberAttributes.ScopeMask;
        method.Attributes |= MemberAttributes.Public;
        method.ImplementationTypes.Add(typeof(IHttpAsyncHandler));
        method.Parameters.Add(new CodeParameterDeclarationExpression(typeof(IAsyncResult).FullName, "ar"));

        call = new CodeMethodInvokeExpression();
        call.Method.TargetObject = new CodeThisReferenceExpression();
        call.Method.MethodName = "AspCompatEndProcessRequest";
        call.Parameters.Add(new CodeArgumentReferenceExpression("ar"));
        method.Statements.Add(call);

        _sourceDataClass.Members.Add(method);
    }
    
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\compilation\codedomutility.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeDOMUtility.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Compilation {

using System.Text;
using System.Runtime.Serialization.Formatters;
using System.ComponentModel;
using System.ComponentModel.Design.Serialization;
using System;
using System.Collections;
using System.Reflection;
using System.IO;
using System.Globalization;
using System.Web.Util;
using System.Web.UI;
using System.Web.Configuration;
using System.Diagnostics;
using Debug = System.Diagnostics.Debug;
using System.CodeDom;
using System.CodeDom.Compiler;
using Util = System.Web.UI.Util;

internal class CodeDomUtility {

    internal static BooleanSwitch WebFormsCompilation = new BooleanSwitch("WebFormsCompilation", "Outputs information about the WebForms compilation of ASPX templates");

    internal CodeDomUtility() {
    }

    internal /*public*/ static CodeExpression GenerateExpressionForValue(PropertyInfo propertyInfo, object value, Type valueType) {
#if DEBUG
        if (WebFormsCompilation.Enabled) {
            Debug.WriteLine("GenerateExpressionForValue() {");
            Debug.Indent();
        }
#endif // DEBUG
        CodeExpression rightExpr = null;

        if (valueType == null) {
            throw new ArgumentNullException("valueType");
        }

        PropertyDescriptor pd = null;
        if (propertyInfo != null) {
            pd = TypeDescriptor.GetProperties(propertyInfo.ReflectedType)[propertyInfo.Name];
        }

        if (valueType == typeof(string) && value is string) {
            if (WebFormsCompilation.Enabled) Debug.WriteLine("simple string");
            rightExpr = new CodePrimitiveExpression((string)value);
        }
        else if (valueType.IsPrimitive) {
            if (WebFormsCompilation.Enabled) Debug.WriteLine("primitive");
            rightExpr = new CodePrimitiveExpression(value);
        }
        else if (valueType.IsArray) {
            if (WebFormsCompilation.Enabled) Debug.WriteLine("array");
            Array array = (Array)value;
            CodeArrayCreateExpression exp = new CodeArrayCreateExpression();
            exp.CreateType = new CodeTypeReference(valueType.GetElementType());
            if (array != null) {
                foreach (object o in array) {
                    exp.Initializers.Add(GenerateExpressionForValue(null, o, valueType.GetElementType()));
                }
            }
            rightExpr = exp;
        }
        else {
            if (WebFormsCompilation.Enabled) Debug.WriteLine("other");
            TypeConverter converter = null;
            if (pd != null) {
                converter = pd.Converter;
            }
            else {
                converter = TypeDescriptor.GetConverter(valueType);
            }

            bool added = false;

            if (converter != null) {
                InstanceDescriptor desc = null;
                
                if (converter.CanConvertTo(typeof(InstanceDescriptor))) {
                    desc = (InstanceDescriptor)converter.ConvertTo(value, typeof(InstanceDescriptor));
                }
                if (desc != null) {
                    if (WebFormsCompilation.Enabled) Debug.WriteLine("has converter with instance descriptor");

                    // static field ref...
                    //
                    if (desc.MemberInfo is FieldInfo) {
                        if (WebFormsCompilation.Enabled) Debug.WriteLine("persistinfo is a field ref");
                        CodeFieldReferenceExpression fieldRef = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(desc.MemberInfo.DeclaringType.FullName), desc.MemberInfo.Name);
                        rightExpr = fieldRef;
                        added = true;
                    }
                    // static property ref
                    else if (desc.MemberInfo is PropertyInfo) {
                        if (WebFormsCompilation.Enabled) Debug.WriteLine("persistinfo is a property ref");
                        CodePropertyReferenceExpression propRef = new CodePropertyReferenceExpression(new CodeTypeReferenceExpression(desc.MemberInfo.DeclaringType.FullName), desc.MemberInfo.Name);
                        rightExpr = propRef;
                        added = true;
                    }

                    // static method invoke
                    //
                    else {
                        object[] args = new object[desc.Arguments.Count];
                        desc.Arguments.CopyTo(args, 0);
                        CodeExpression[] expressions = new CodeExpression[args.Length];
                        
                        if (desc.MemberInfo is MethodInfo) {
                            MethodInfo mi = (MethodInfo)desc.MemberInfo;
                            ParameterInfo[] parameters = mi.GetParameters();
                            
                            for(int i = 0; i < args.Length; i++) {
                                expressions[i] = GenerateExpressionForValue(null, args[i], parameters[i].ParameterType);
                            }
                            
                            if (WebFormsCompilation.Enabled) Debug.WriteLine("persistinfo is a method invoke");
                            CodeMethodInvokeExpression methCall = new CodeMethodInvokeExpression(new CodeTypeReferenceExpression(desc.MemberInfo.DeclaringType.FullName), desc.MemberInfo.Name);
                            foreach (CodeExpression e in expressions) {
                                methCall.Parameters.Add(e);
                            }
                            rightExpr = methCall;
                            added = true;
                        }
                        else if (desc.MemberInfo is ConstructorInfo) {
                            ConstructorInfo ci = (ConstructorInfo)desc.MemberInfo;
                            ParameterInfo[] parameters = ci.GetParameters();
                            
                            for(int i = 0; i < args.Length; i++) {
                                expressions[i] = GenerateExpressionForValue(null, args[i], parameters[i].ParameterType);
                            }
                        
                            if (WebFormsCompilation.Enabled) Debug.WriteLine("persistinfo is a constructor call");
                            CodeObjectCreateExpression objectCreate = new CodeObjectCreateExpression(desc.MemberInfo.DeclaringType.FullName);
                            foreach (CodeExpression e in expressions) {
                                objectCreate.Parameters.Add(e);
                            }
                            rightExpr = objectCreate;
                            added = true;
                        }
                    }
                }
            }

            if (!added) {
#if DEBUG
                if (WebFormsCompilation.Enabled) {
                    Debug.WriteLine("unabled to determine type, attempting Parse");
                    Debug.Indent();
                    Debug.WriteLine("value.GetType  == " + value.GetType().FullName);
                    Debug.WriteLine("value.ToString == " + value.ToString());
                    Debug.WriteLine("valueType      == " + valueType.FullName);
                    if (propertyInfo != null) {
                        Debug.WriteLine("propertyInfo   == " + propertyInfo.ReflectedType.FullName + "." + propertyInfo.Name + " : " + propertyInfo.PropertyType.FullName);
                    }
                    else {
                        Debug.WriteLine("propertyInfo   == (null)");
                    }

                    Debug.Unindent();
                }
#endif // DEBUG


                // Not a known type: try calling Parse

                // If possible, pass it an InvariantCulture (ASURT 79412)
                if (valueType.GetMethod("Parse", new Type[] {typeof(string), typeof(CultureInfo)}) != null) {
                    CodeMethodInvokeExpression methCall = new CodeMethodInvokeExpression(new CodeTypeReferenceExpression(valueType.FullName), "Parse");

                    // Convert the object to a string.
                    // If we have a type converter, use it to convert to a string in a culture
                    // invariant way (ASURT 87094)
                    string s;
                    if (converter != null) {
                        s = converter.ConvertToInvariantString(value);
                    }
                    else {
                        s = value.ToString();
                    }

                    methCall.Parameters.Add(new CodePrimitiveExpression(s));
                    methCall.Parameters.Add(new CodePropertyReferenceExpression(new CodeTypeReferenceExpression(typeof(CultureInfo)), "InvariantCulture"));
                    rightExpr = methCall;

                }
                else if (valueType.GetMethod("Parse", new Type[] {typeof(string)}) != null) {
                    // Otherwise, settle for passing just the string
                    CodeMethodInvokeExpression methCall = new CodeMethodInvokeExpression(new CodeTypeReferenceExpression(valueType.FullName), "Parse");
                    methCall.Parameters.Add(new CodePrimitiveExpression(value.ToString()));
                    rightExpr = methCall;

                }
                else {
                    throw new HttpException(SR.GetString(SR.CantGenPropertySet, propertyInfo.Name, valueType.FullName));
                }
            }
        }

#if DEBUG
        if (WebFormsCompilation.Enabled) {
            Debug.Unindent();
            Debug.WriteLine("}");
        }
#endif // DEBUG
        return rightExpr;
    }

}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\compilation\usercontrolcompiler.cs ===
//------------------------------------------------------------------------------
// <copyright file="UserControlCompiler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Compilation {

using System;
using System.CodeDom;
using System.Web.UI;

internal class UserControlCompiler : TemplateControlCompiler {

    protected UserControlParser _ucParser;
    UserControlParser Parser { get { return _ucParser; } }

    internal /*public*/ static Type CompileUserControlType(UserControlParser ucParser) {
        UserControlCompiler compiler = new UserControlCompiler(ucParser);

        return compiler.GetCompiledType();
    }

    internal UserControlCompiler(UserControlParser ucParser) : base(ucParser) {
        _ucParser = ucParser;
    }

    /*
     * Add metadata attributes to the class
     */
    protected override void GenerateClassAttributes() {

        base.GenerateClassAttributes();

        // If the user control has an OutputCache directive, generate
        // an attribute with the information about it.
        if (Parser.Duration > 0) {
            CodeAttributeDeclaration attribDecl = new CodeAttributeDeclaration(
                "System.Web.UI.PartialCachingAttribute");
            CodeAttributeArgument attribArg = new CodeAttributeArgument(
                new CodePrimitiveExpression(Parser.Duration));
            attribDecl.Arguments.Add(attribArg);
            attribArg = new CodeAttributeArgument(new CodePrimitiveExpression(Parser.VaryByParams));
            attribDecl.Arguments.Add(attribArg);
            attribArg = new CodeAttributeArgument(new CodePrimitiveExpression(Parser.VaryByControls));
            attribDecl.Arguments.Add(attribArg);
            attribArg = new CodeAttributeArgument(new CodePrimitiveExpression(Parser.VaryByCustom));
            attribDecl.Arguments.Add(attribArg);
            attribArg = new CodeAttributeArgument(new CodePrimitiveExpression(Parser.FSharedPartialCaching));
            attribDecl.Arguments.Add(attribArg);

            _sourceDataClass.CustomAttributes.Add(attribDecl);
        }
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\compilation\preservedassemblyentry.cs ===
//------------------------------------------------------------------------------
// <copyright file="PreservedAssemblyEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Web.Compilation {
using System;
using System.IO;
using System.Collections;
using System.Collections.Specialized;
using System.Reflection;
using System.Globalization;
using System.Threading;
using System.Text;
using System.Web.Util;
using System.Web.UI;
using System.Web;
using Debug=System.Web.Util.Debug;
using System.Xml;
using XmlUtil = System.Web.Configuration.HandlerBase;
using System.Runtime.Remoting.Messaging;

/*
 * Code to handle the preservation of compiled assemblies across appdomain restarts (ASURT 35547)
 */
internal class PreservedAssemblyEntry {
    private static bool _fDidFirstTimeInit;
    private static int _numTopLevelConfigFiles;

    private static ArrayList _backgroundBatchCompilations = new ArrayList();

    private static int s_recompilations;
    private static int s_maxRecompilations;

    // Mutex to protect access to the preservation files
    private static CompilationMutex _mutex;

    private HttpContext _context;
    private string _virtualPath;
    private bool _fApplicationFile; // Are we dealing with global.asax
    private Assembly _assembly; // The compiled assembly
    private Type _type; // The compiled type object
    private Hashtable _sourceDependencies;
    private Hashtable _assemblyDependencies;


    static PreservedAssemblyEntry() {

        // Make the mutex unique per application
        int hashCode = ("PreservedAssemblyEntry" + HttpRuntime.AppDomainAppIdInternal).GetHashCode();

        _mutex = new CompilationMutex(
                        false, 
                        "PAE" + hashCode.ToString("x"), 
                        "PreservedAssemblyEntry lock for " + HttpRuntime.AppDomainAppVirtualPath);
    }

    private static void GetLock() {
        Debug.Trace("PreservedAssemblyEntry", "Waiting for lock: " + HttpRuntime.AppDomainAppIdInternal);
        _mutex.WaitOne();
        Debug.Trace("PreservedAssemblyEntry", "Got lock: " + HttpRuntime.AppDomainAppIdInternal);
    }

    private static void ReleaseLock() {
        Debug.Trace("PreservedAssemblyEntry", "Releasing lock: " + HttpRuntime.AppDomainAppIdInternal);
        _mutex.ReleaseMutex();
    }

    internal static void EnsureFirstTimeInit(HttpContext context) {

        // Only do this once
        if (_fDidFirstTimeInit) return;

        try {
            GetLock();

            if (_fDidFirstTimeInit) return;

            DoFirstTimeInit(context);
            _fDidFirstTimeInit = true;
        }
        finally {
            ReleaseLock();
        }
    }

    /*
     * Perform initialization work that should only be done once (per app domain).
     */
    private static void DoFirstTimeInit(HttpContext context) {

        // Find out how many recompilations we allow before restarting the appdomain
        s_maxRecompilations = CompilationConfiguration.GetRecompilationsBeforeAppRestarts(context);

        // Create the temp files directory if it's not already there
        string tempFilePath = HttpRuntime.CodegenDirInternal;
        if (!FileUtil.DirectoryExists(tempFilePath)) {
            try {
                Directory.CreateDirectory(tempFilePath);
            }
            catch (IOException e) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Failed_to_create_temp_dir, HttpRuntime.GetSafePath(tempFilePath)), e);
            }
        }

        long specialFilesCombinedHash = ReadPreservedSpecialFilesCombinedHash();
        Debug.Trace("PreservedAssemblyEntry", "specialFilesCombinedHash=" + specialFilesCombinedHash);

        // Delete all the non essential files left over in the codegen dir, unless
        // specialFilesCombinedHash is 0, in which case we delete *everything* further down
        if (specialFilesCombinedHash != 0)
            RemoveOldTempFiles();

        // Use a DateTimeCombiner object to handle the time stamps of all the 'special'
        // files that all compilations depend on:
        // - The config files (excluding the ones from subdirectories)
        // - global.asax
        // - System.Web.dll (in case there is a newer version of ASP.NET)

        DateTimeCombiner specialFilesDateTimeCombiner = new DateTimeCombiner();

        // Add a check for the app's physical path, in case it changes (ASURT 12975)
        specialFilesDateTimeCombiner.AddObject(context.Request.PhysicalApplicationPath);

        // Process the config files. Note that this only includes the top level ones,
        // namely the machine one, and the one in the root of the app.  The others are
        // handled as regular dependencies.
        string appPath = context.Request.ApplicationPath;
        string[] configFiles = context.GetConfigurationDependencies(appPath);
        _numTopLevelConfigFiles = configFiles.Length;
        for (int i=0; i<_numTopLevelConfigFiles; i++)
            specialFilesDateTimeCombiner.AddFile(configFiles[i]);

        // Process global.asax
        string appFileName = HttpApplicationFactory.GetApplicationFile(context);
        specialFilesDateTimeCombiner.AddFile(appFileName);

        // Process System.Web.dll
        string aspBinaryFileName = typeof(HttpRuntime).Module.FullyQualifiedName;
        specialFilesDateTimeCombiner.AddFile(aspBinaryFileName);

        // If they don't match, cleanup everything and write the new hash file
        if (specialFilesDateTimeCombiner.CombinedHash != specialFilesCombinedHash) {
            Debug.Trace("PreservedAssemblyEntry", "EnsureFirstTimeInit: hash codes don't match.  Old=" +
                specialFilesCombinedHash + " New=" + specialFilesDateTimeCombiner.CombinedHash);
            RemoveAllCodeGenFiles();
            WritePreservedSpecialFilesCombinedHash(specialFilesDateTimeCombiner.CombinedHash);
        }
        else {
            Debug.Trace("PreservedAssemblyEntry", "PreservedAssemblyEntry: the special files are up to date");
        }
    }

    private static string GetSpecialFilesCombinedHashFileName() {
        return HttpRuntime.CodegenDirInternal + "\\hash.web";
    }

    /*
     * Return the combined hash that was preserved to file.  Return 0 if not valid.
     */
    private static long ReadPreservedSpecialFilesCombinedHash() {

        string fileName = GetSpecialFilesCombinedHashFileName();

        if (!FileUtil.FileExists(fileName))
            return 0;

        try {
            string s = Util.StringFromFile(fileName);
            return Int64.Parse(s, NumberStyles.AllowHexSpecifier);
        }
        catch {
            // If anything went wrong (file not found, or bad format), return 0
            return 0;
        }
    }

    /*
     * Preserve the combined hash of the special files to a file.
     */
    private static void WritePreservedSpecialFilesCombinedHash(long hash) {

        Debug.Assert(hash != 0, "WritePreservedSpecialFilesCombinedHash: hash != 0");
        StreamWriter writer = null;

        try {
            writer = new StreamWriter(GetSpecialFilesCombinedHashFileName(),
                false, Encoding.UTF8);
            writer.Write(hash.ToString("x"));
        }
        finally {
            if (writer != null)
                writer.Close();
        }
    }

    // Init method called by the BatchHandler
    internal static void BatchHandlerInit(HttpContext context) {

        EnsureFirstTimeInit(context);
        AlreadyBatched(context.Request.BaseDir);
    }

    internal static PreservedAssemblyEntry GetPreservedAssemblyEntry(HttpContext context,
        string virtualPath, bool fApplicationFile) {

        Debug.Trace("PreservedAssemblyEntry", "Checking for " + virtualPath);

        EnsureFirstTimeInit(context);

        string baseVirtualDir = UrlPath.GetDirectory(virtualPath);

        // No batching for global.asax
        if (!fApplicationFile)
            BatchCompileDirectory(context, baseVirtualDir);

        PreservedAssemblyEntry entry = new PreservedAssemblyEntry(context,
            virtualPath, fApplicationFile);

        // Try to load the entry.  It must exist, and be up to date
        if (!entry.LoadDataFromFile(fApplicationFile))
            return null;

        return entry;
    }

    internal static void AbortBackgroundBatchCompilations() {
        Debug.Trace("PreservedAssemblyEntry", "AbortBackgroundBatchCompilations: " + _backgroundBatchCompilations.Count + " threads to abort");

        // drain the preservation and compilation mutexes to make sure they are not owned while
        // the threads are aborted
        _mutex.DrainMutex();
        CompilationLock.DrainMutex();

        lock (_backgroundBatchCompilations) {
            foreach (BackgroundBatchCompiler bbc in _backgroundBatchCompilations)
                bbc.Abort();
        }
    }

    internal static void AddBackgroundBatchCompilation(BackgroundBatchCompiler bbc) {
        lock (_backgroundBatchCompilations) {
            _backgroundBatchCompilations.Add(bbc);
        }
    }

    internal static void RemoveBackgroundBatchCompilation(BackgroundBatchCompiler bbc) {
        lock (_backgroundBatchCompilations) {
            try {
                _backgroundBatchCompilations.Remove(bbc);
            }
            catch {
                Debug.Assert(false, "RemoveBackgroundBatchCompilation failed");
            }
        }
    }

    /*
     * Try batching the directory if not done yet.
     */
    private static bool BatchCompileDirectory(HttpContext context, string baseVirtualDir) {

        // Don't do it if batching is disabled
        if (!CompilationConfiguration.IsBatchingEnabled(context))
            return false;

        if (AlreadyBatched(baseVirtualDir))
            return false;

        Debug.Trace("PreservedAssemblyEntry", "Need to batch compile " + baseVirtualDir);

        // If we're already in a batch compilation tread, no need to start another one
        if (BackgroundBatchCompiler.IsBatchCompilationThread()) {
            Debug.Trace("PreservedAssemblyEntry", "Already in batch compilation thread. No need to start a new one.");
            CodeDomBatchManager.BatchCompile(baseVirtualDir, context);
            return true;
        }

        // Notify HttpRuntime so that it might need to abort compilation on shutdown
        HttpRuntime.NotifyThatSomeBatchCompilationStarted();

        ManualResetEvent batchEvent = new ManualResetEvent(false);

        // Pass it a Clone of the context, since it's not thread safe.  Mostly, this is important
        // for the ConfigPath (ASURT 82744)
        BackgroundBatchCompiler bbc = new BackgroundBatchCompiler(context.Clone(), baseVirtualDir, batchEvent);

        // Start the batch processing
        try {
            ThreadPool.QueueUserWorkItem(bbc.BatchCallback);
        }
        catch {
            return false;
        }

        // Register for BeforeDoneWithSession event
        context.BeforeDoneWithSession += new EventHandler(bbc.BeforeDoneWithSessionHandler);

        // Wait a certain time for it to complete
        int timeout = 1000 * CompilationConfiguration.GetBatchTimeout(context);

        Debug.Trace("PreservedAssemblyEntry", "Waiting for " + timeout + " ms");

        if (batchEvent.WaitOne(timeout, false)) {
            Debug.Trace("PreservedAssemblyEntry", "The background thread is done for " + baseVirtualDir + " (Success=" + bbc.Success + ")");
            return bbc.Success;
        }

        // It didn't have time to complete.  Let it run in the background.
        Debug.Trace("PreservedAssemblyEntry", "The background thread is still going for " + baseVirtualDir);

        // Add it to the list of background compilations, in case it needs to be aborted
        AddBackgroundBatchCompilation(bbc);
        bbc.WasAddedToBackgroundThreadsList = true;

        return false;
    }

    internal class BackgroundBatchCompiler {

        // name of the slot in call context
        private const String CallContextBatchCompilerSlotName = "BatchCompiler";

        private HttpContext _context;
        private string _baseVirtualDir;
        private Thread _thread;
        private ManualResetEvent _event;
        private WaitCallback _batchCallback;
        private bool _wasAddedToBackgroundThreadsList;

        private bool _success;
        internal bool Success { get { return _success; } }

        internal WaitCallback BatchCallback { get { return _batchCallback; } }

        internal bool WasAddedToBackgroundThreadsList {
            get { return _wasAddedToBackgroundThreadsList; }
            set { _wasAddedToBackgroundThreadsList = value; }
        }

        internal BackgroundBatchCompiler(HttpContext context, string baseVirtualDir, ManualResetEvent batchEvent) {
            _context = context;
            _baseVirtualDir = baseVirtualDir;
            _batchCallback = new WaitCallback(this.BatchCompileDirectory);
            _event = batchEvent;
        }

        internal void BeforeDoneWithSessionHandler(Object sender, EventArgs args) {
            // Wait for the batch compilation to complete
            _event.WaitOne();
        }

        internal void Abort() {
            if (_thread != null)
                _thread.Abort();
        }

        internal void BatchCompileDirectory(Object unused) {
            _thread = Thread.CurrentThread;

            try {
                using (new HttpContextWrapper(_context)) {
                    // Set some thread data to remember that this is a batch compilation thread
                    CallContext.SetData(CallContextBatchCompilerSlotName, this);

                    // Do the impersonation
                    _context.Impersonation.Start(true /*forGlobalCode*/, false /*throwOnError*/);

                    Debug.Trace("PreservedAssemblyEntry", "Starting batch compilation of directory " + _baseVirtualDir);
                    try {
                        CodeDomBatchManager.BatchCompile(_baseVirtualDir, _context);
                    }
            
                    // eat exceptions and fail batch compilation silently
        #if DBG
                    catch (Exception e) {
                        if (e is ThreadAbortException)
                            Debug.Trace("PreservedAssemblyEntry", "Batch compilation of directory " + _baseVirtualDir + " was aborted.");
                        else
                            Debug.Trace("PreservedAssemblyEntry", "Batch compilation of directory " + _baseVirtualDir + " failed.");

                        Util.DumpExceptionStack(e);
                        return;
                    }
        #else
                    catch (Exception) {
                        return;
                    }
        #endif

                    finally {
                        _context.Impersonation.Stop();

                        CallContext.SetData(CallContextBatchCompilerSlotName, null);

                        if (WasAddedToBackgroundThreadsList)
                            PreservedAssemblyEntry.RemoveBackgroundBatchCompilation(this);
                    }
                }

                // Batching was performed successfully
                Debug.Trace("PreservedAssemblyEntry", "Batch compilation of directory " + _baseVirtualDir + " was successful.");
                _success = true;
            }
            catch (ThreadAbortException) {
                // to consume thread abort exception (so that the thread pool doesn't know)
                Thread.ResetAbort();
            }
            catch { throw; }    // Prevent Exception Filter Security Issue (ASURT 122826)
            finally {
                _thread = null;
                _event.Set();
            }
        }

        internal static bool IsBatchCompilationThread() {
            // Check if the current thread is a batch compilation thread
            return (CallContext.GetData(CallContextBatchCompilerSlotName) != null);
        }
    }

    /*
     * Only attempt batching once per directory
     */
    private static Hashtable _alreadyBatched = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);

    private static bool AlreadyBatched(string virtualPath) {

        // First, do the fast in memory check

        if (_alreadyBatched.ContainsKey(virtualPath))
            return true;

        _alreadyBatched[virtualPath] = null;

        // Then try to see if the marker file exists, and create it if it doesn't

        string markerFileName = HttpRuntime.CodegenDirInternal + "\\" +
            GetHashStringFromPath(virtualPath) + ".web";

        if (FileUtil.FileExists(markerFileName))
            return true;

        Stream stm = File.Create(markerFileName);
        stm.Close();

        return false;
    }

    private PreservedAssemblyEntry(HttpContext context, string virtualPath, bool fApplicationFile) {
        _context = context;
        _virtualPath = virtualPath;
        _fApplicationFile = fApplicationFile;
    }

    internal PreservedAssemblyEntry(HttpContext context, string virtualPath, bool fApplicationFile,
        Assembly assembly, Type type, Hashtable sourceDependencies) {

        _context = context;
        _virtualPath = virtualPath;
        _fApplicationFile = fApplicationFile;
        if (assembly != null)
            _assembly = assembly;
        else
            _assembly = type.Module.Assembly;
        _type = type;
        _sourceDependencies = sourceDependencies;

        _assemblyDependencies = Util.GetReferencedAssembliesHashtable(_assembly);

        // If any of the assemblies we depend on are in the bin directory,
        // add a file dependency for them.

        string binDir = HttpRuntime.BinDirectoryInternal;
        foreach (Assembly a in AssemblyDependencies.Keys) {
            string assemblyFilePath = Util.FilePathFromFileUrl(a.EscapedCodeBase);
            if (assemblyFilePath.StartsWith(binDir))
                _sourceDependencies[assemblyFilePath] = assemblyFilePath;
        }

        // If there are some web.config files other than the global ones, depend on them

        string baseVirtualDir = UrlPath.GetDirectory(virtualPath);
        string[] configFiles = context.GetConfigurationDependencies(baseVirtualDir);

        Debug.Assert(configFiles.Length >= _numTopLevelConfigFiles, "configFiles.Length >= _numTopLevelConfigFiles");

        for (int i=0; i<configFiles.Length-_numTopLevelConfigFiles; i++)
            _sourceDependencies[configFiles[i]] = configFiles[i];
    }

    internal Hashtable SourceDependencies { get { return _sourceDependencies; } }
    internal Hashtable AssemblyDependencies { get { return _assemblyDependencies; } }
    internal Assembly Assembly { get { return _assembly; } }
    internal Type ObjectType { get { return _type; } }

    private string GetAssemblyName() {
        return _assembly.GetName().Name;
    }

    private string TypeName {
        get {
            return _type.FullName;
        }
    }

    private bool LoadDataFromFile(bool fApplicationFile) {
        try {
            GetLock();
            return LoadDataFromFileInternal(fApplicationFile);
        }
        finally {
            ReleaseLock();
        }
    }

    /*
     * Format of the data file (by example):
     *
     * <preserve assem="gen591" type="ASP.tstinclude1_aspx" hash="9b66879f">
     *     <filedep name="C:\MISC\samples\tstinclude1.aspx" />
     *     <filedep name="C:\MISC\samples\foo\foo.inc" />
     *     <filedep name="C:\MISC\samples\foo\code.txt" />
     *     <filedep name="C:\MISC\samples\foo\tstinclude2.ascx" />
     *     <filedep name="C:\MISC\samples\foo\bar\tstinclude3.ascx" />
     *     <assemdep name="gen590" />
     * </preserve>
     */
    private bool LoadDataFromFileInternal(bool fApplicationFile) {

        string dataFile = GetPreservedDataFileName();

        // Try to open the data file
        if (!FileUtil.FileExists(dataFile)) {
            Debug.Trace("PreservedAssemblyEntry", "Can't find preservation file " + dataFile);
            return false;
        }

        Debug.Trace("PreservedAssemblyEntry", "Found preservation file " + dataFile);

        XmlDocument doc = new XmlDocument();

        try {
            doc.Load(dataFile);
        }
        catch (Exception) {
            Debug.Assert(false, "Preservation file " + dataFile + " is malformed.  Deleting it...");
            File.Delete(dataFile);
            return false;
        }

        // Check the top-level <preserve assem="assemblyFile" type="typename">
        XmlNode root = doc.DocumentElement;
        Debug.Assert(root != null && root.Name == "preserve", "root != null && root.Name == \"preserve\"");
        if (root == null || root.Name != "preserve")
            return false;

        string assemblyName = XmlUtil.RemoveAttribute(root, "assem");
        string typeName = XmlUtil.RemoveAttribute(root, "type");
        string hashString = XmlUtil.RemoveAttribute(root, "hash");

        Debug.Assert(assemblyName != null && hashString != null,
            "assemblyName != null && hashString != null");
        if (assemblyName == null || hashString == null)
            return false;

        // Was it compiled as part of a batch?
        bool fBatched = Util.IsTrueString(XmlUtil.RemoveAttribute(root, "batch"));

        // ctracy 00.09.27: Verify no unrecognized attributes (all valid ones have been removed)
        Debug.Assert(root.Attributes.Count == 0);

        _sourceDependencies = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);

        IEnumerator childEnumerator = root.ChildNodes.GetEnumerator();
        while (childEnumerator.MoveNext()) {
            XmlNode fileDepNode = (XmlNode)childEnumerator.Current;
            if (fileDepNode.NodeType != XmlNodeType.Element)
                continue;

            if (!fileDepNode.Name.Equals("filedep"))
                break;

            string fileName = XmlUtil.RemoveAttribute(fileDepNode, "name");

            Debug.Assert(fileName != null, "fileName != null");

            // ctracy 00.09.27: verify no unrecognized attributes
            Debug.Assert(fileDepNode.Attributes.Count == 0); 

            if (fileName == null)
                return false;

            _sourceDependencies[fileName] = fileName;
        }

        // Parse the hash string as an hex int
        long hash = Int64.Parse(hashString, NumberStyles.AllowHexSpecifier);

        // Check if all the dependencies are up to date
        if (GetDependenciesCombinedHash() != hash) {
            Debug.Trace("PreservedAssemblyEntry", "Dependencies are not up to date");

            // Delete the out-of-date assembly, unless it was the result of batch
            // compilation, in which case other pages may still need it.
            if (!fBatched)
                RemoveOutOfDateAssembly(assemblyName);

            // If it's the application file that's out of date, clean up all
            // the codegen files (ASURT 73190)
            if (fApplicationFile)
                RemoveAllCodeGenFiles();

            // Cycle the appdomain after a certain number of recompilations
            // have been done (ASURT 44945)
            if (UnsafeNativeMethods.GetModuleHandle(assemblyName) != (IntPtr)0) {
                if (++s_recompilations == s_maxRecompilations) {
                    HttpRuntime.ShutdownAppDomain("Recompilation limit of " + s_maxRecompilations + " reached");
                }
            }

            return false;
        }

        Debug.Trace("PreservedAssemblyEntry", "Dependencies are up to date");

        // Try to load the assembly
        try {
            _assembly = Assembly.Load(assemblyName);
        }
        catch {
            Debug.Assert(false, "Failed to load assembly " + assemblyName);
            File.Delete(dataFile);
            RemoveOutOfDateAssembly(assemblyName);
            return false;
        }

        // Get the assembly dependencies
        try {
            _assemblyDependencies = Util.GetReferencedAssembliesHashtable(_assembly);
        }
        catch (Exception e) {
            Debug.Assert(false, "Failed to load dependent assemblies for " + assemblyName +
                " (" + e.Message + ")");
            File.Delete(dataFile);
            RemoveOutOfDateAssembly(assemblyName);
            return false;
        }

        // If we don't have a type name, we're done
        if (typeName == null)
            return true;

        // Load the type
        _type = _assembly.GetType(typeName);
        Debug.Assert(_type != null, "Failed to load type " + assemblyName + " " + typeName);
        return (_type != null);
    }

    internal void SaveDataToFile(bool fBatched) {
        try {
            GetLock();
            SaveDataToFileInternal(fBatched);
        }
        finally {
            ReleaseLock();
        }
    }

    // fBatched is true when the page was compiled as part of a batch
    private void SaveDataToFileInternal(bool fBatched) {
        string dataFile = GetPreservedDataFileName();

        StreamWriter sw = null;

        try {
            sw = new StreamWriter(dataFile, false, Encoding.UTF8);

            // <preserve assem="assemblyFile">
            sw.Write("<preserve assem=" + Util.QuoteXMLValue(GetAssemblyName()));
            if (_type != null)
                sw.Write(" type=" + Util.QuoteXMLValue(TypeName));
            sw.Write(" hash=" + Util.QuoteXMLValue(GetDependenciesCombinedHash().ToString("x")));
            if (fBatched)
                sw.Write(" batch=\"true\"");
            sw.WriteLine(">");

            // Write all the source dependencies
            if (SourceDependencies != null) {
                foreach (string src in SourceDependencies.Keys) {
                    sw.WriteLine("    <filedep name=" + Util.QuoteXMLValue(src) + " />");
                }
            }

            sw.WriteLine("</preserve>");

            sw.Close();

            // Increment compiled pages counter
            PerfCounters.IncrementCounter(AppPerfCounter.COMPILATIONS);
        }
        catch (Exception) {

            // If an exception occurs during the writing of the xml file, clean it up
            if (sw != null) {
                sw.Close();

                File.Delete(dataFile);
            }

            throw;
        }
    }

    private long GetDependenciesCombinedHash() {
        DateTimeCombiner dateTimeCombiner = new DateTimeCombiner();

        // Sort the source dependencies to make the hash code predictable
        ArrayList sortedSourceDependencies = new ArrayList(SourceDependencies.Keys);
        sortedSourceDependencies.Sort(InvariantComparer.Default);

        foreach (string sourceDependency in sortedSourceDependencies)
            dateTimeCombiner.AddFile(sourceDependency);

        return dateTimeCombiner.CombinedHash;
    }

    private static string GetHashStringFromPath(string path) {
        return (path.ToLower(CultureInfo.InvariantCulture).GetHashCode()).ToString("x");
    }

    /*
     * Return the name of the preservation data file
     */
    private string GetPreservedDataFileName() {
        string name = Path.GetFileName(_virtualPath);

        // For global.asax, no need to make it unique per directory
        if (_fApplicationFile)
            return HttpRuntime.CodegenDirInternal + "\\" + name + ".xml";

        // Since the same file names can appear in different directories, make the data
        // file name unique by using the hash code of the directory
        return HttpRuntime.CodegenDirInternal + "\\" + name + "." +
            GetHashStringFromPath(UrlPath.GetDirectory(_virtualPath)) + ".xml";
    }

    /*
     * Delete an assembly that is out of date, as well as the associated files
     */
    internal static void RemoveOutOfDateAssembly(string assemblyName) {

        DirectoryInfo directory = new DirectoryInfo(HttpRuntime.CodegenDirInternal);

        FileInfo[] files = directory.GetFiles(assemblyName + ".*");
        foreach (FileInfo f in files) {
            try {
                // First, just try to delete the file
                f.Delete();
            }
            catch (Exception) {

                try {
                    // If the delete failed, rename it to ".delete", so it'll get
                    // cleaned up next time by RemoveOldTempFiles()
                    // Don't do that if it already has the delete extension
                    if (f.Extension != ".delete")
                        f.MoveTo(f.FullName + ".delete");
                }
                catch (Exception) {
                    // Ignore all exceptions
                    Debug.Assert(false, "Cannot delete " + f.Name + " from " + directory);
                }
            }
        }
    }

    /*
     * Delete all temporary files from the codegen directory (e.g. source files, ...)
     */
    private static void RemoveOldTempFiles() {
        Debug.Trace("PreservedAssemblyEntry", "Deleting old temporary files from " + HttpRuntime.CodegenDirInternal);

        string codegen = HttpRuntime.CodegenDirInternal + "\\";

        UnsafeNativeMethods.WIN32_FIND_DATA wfd;
        IntPtr hFindFile = UnsafeNativeMethods.FindFirstFile(codegen + "*.*", out wfd);

        // No files: do nothing
        if (hFindFile == new IntPtr(-1))
            return;

        try {
            // Go through all the files in the codegen dir. We use the Win32 native API's
            // directly for perf and memory usage reason (ASURT 97791)
            for (bool more=true; more; more=UnsafeNativeMethods.FindNextFile(hFindFile, out wfd)) {

                // Skip directories
                if ((wfd.dwFileAttributes & UnsafeNativeMethods.FILE_ATTRIBUTE_DIRECTORY) != 0)
                    continue;

                // If it has a known extension, skip it
                string ext = Path.GetExtension(wfd.cFileName); 
                if (ext == ".dll" || ext == ".pdb" || ext == ".web" || ext == ".xml")
                    continue;

                // Don't delete the temp file if it's named after a dll that's still around
                // since it could still be useful for debugging.
                // Note that we can't use GetFileNameWithoutExtension here because
                // some of the files are named 5hvoxl6v.0.cs, and it would return
                // 5hvoxl6v.0 instead of just 5hvoxl6v
                int periodIndex = wfd.cFileName.IndexOf('.');
                if (periodIndex > 0) {
                    string baseName = wfd.cFileName.Substring(0, periodIndex);

                    if (FileUtil.FileExists(codegen + baseName + ".dll"))
                        continue;
                }

                try {
                    File.Delete(codegen + wfd.cFileName);
                }
                catch { } // Ignore all exceptions
            }
        }
        finally {
            UnsafeNativeMethods.FindClose(hFindFile);
        }
    }

    /*
     * Delete all the files in the codegen directory
     */
    private static void RemoveAllCodeGenFiles() {
        string tempFilePath = HttpRuntime.CodegenDirInternal;
        Debug.Trace("PreservedAssemblyEntry", "Deleting all files from " + tempFilePath);

        // Remove all directories recursively

        try {
            Directory.Delete(tempFilePath, true /*recursive*/);
            Directory.CreateDirectory(tempFilePath);
        }
        catch (Exception) {
            // Ignore all exceptions
        }

        // Allow batching to happen again
        _alreadyBatched.Clear();
    }
}

/*
 * Class used to combine several DateTimes into a single int
 */
internal class DateTimeCombiner : HashCodeCombiner {

    internal DateTimeCombiner() {
    }

    internal void AddDateTime(DateTime dt) {
        Debug.Trace("DateTimeCombiner", "Ticks: " + dt.Ticks.ToString("x"));
        Debug.Trace("DateTimeCombiner", "Hashcode: " + dt.GetHashCode().ToString("x"));
        AddObject(dt);
    }

    private void AddFileSize(long fileSize) {
        Debug.Trace("DateTimeCombiner", "file size: " + fileSize.ToString("x"));
        Debug.Trace("DateTimeCombiner", "Hashcode: " + fileSize.GetHashCode().ToString("x"));
        AddObject(fileSize);
    }

    internal void AddFile(string fileName) {
        Debug.Trace("DateTimeCombiner", "AddFile: " + fileName);
        if (!FileUtil.FileExists(fileName)) {
            Debug.Trace("DateTimeCombiner", "Could not find target " + fileName);
            return;
        }

        FileInfo file = new FileInfo(fileName);
        AddDateTime(file.CreationTime);
        AddDateTime(file.LastWriteTime);
        AddFileSize(file.Length);
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\compilation\templatecontrolcompiler.cs ===
//------------------------------------------------------------------------------
// <copyright file="TemplateControlCompiler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Compilation {

using System;
using System.Collections;
using System.Reflection;
using System.ComponentModel;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Globalization;
using System.Web.UI;
using Debug=System.Web.Util.Debug;


internal abstract class TemplateControlCompiler : BaseCompiler {

    private const string stringResourcePointerName = "__stringResource";

    private TemplateControlParser _tcParser;
    TemplateControlParser Parser { get { return _tcParser; } }

    private int _controlCount;

    // Minimum literal string length for it to be placed in the resource
    private const int minLongLiteralStringLength = 256;

    private const string buildMethodPrefix = "__BuildControl";
    private const string literalMemoryBlockName = "__literals";
    private const string renderMethodParameterName = "__output";

    internal TemplateControlCompiler(TemplateControlParser tcParser) : base(tcParser) {
        _tcParser = tcParser;
    }

    /*
     * Build the default constructor
     */
    protected override void BuildInitStatements(CodeStatementCollection trueStatements, CodeStatementCollection topLevelStatements) {

        base.BuildInitStatements(trueStatements, topLevelStatements);

        if (_stringResourceBuilder.HasStrings) {
            // e.g. private Object __stringResource;
            CodeMemberField stringResourcePointer = new CodeMemberField(typeof(Object).FullName, stringResourcePointerName);
            stringResourcePointer.Attributes |= MemberAttributes.Static;
            _sourceDataClass.Members.Add(stringResourcePointer);

            // e.g. __stringResource = Page.ReadStringResource(typeof(__GeneratedType));
            CodeAssignStatement readResource = new CodeAssignStatement();
            readResource.Left = new CodeFieldReferenceExpression(_classTypeExpr,
                                                             stringResourcePointerName);
            CodeMethodInvokeExpression methCallExpression = new CodeMethodInvokeExpression();
            methCallExpression.Method.TargetObject = new CodeTypeReferenceExpression(typeof(TemplateControl));
            methCallExpression.Method.MethodName = "ReadStringResource";
            methCallExpression.Parameters.Add(new CodeTypeOfExpression(_classTypeExpr.Type));
            readResource.Right = methCallExpression;
            trueStatements.Add(readResource);

        }
    }

    /*
     * Build various properties, fields, methods
     */
    protected override void BuildMiscClassMembers() {
        base.BuildMiscClassMembers();

        // Build the automatic event hookup code
        BuildAutomaticEventHookup();

        // Build the ApplicationInstance property
        BuildApplicationInstanceProperty();

        // Build the SourceDir property
        BuildSourceDirProperty();

        BuildSourceDataTreeFromBuilder(Parser.RootBuilder,
            false /*fInTemplate*/, null /*pse*/);

        BuildFrameworkInitializeMethod();
    }

    /*
     * Build the data tree for the FrameworkInitialize method
     */
    private void BuildFrameworkInitializeMethod() {

        CodeMemberMethod method = new CodeMemberMethod();
        method.Attributes &= ~MemberAttributes.AccessMask;
        method.Attributes &= ~MemberAttributes.ScopeMask;
        method.Attributes |= MemberAttributes.Override | MemberAttributes.Family;
        method.Name = "FrameworkInitialize";

        BuildFrameworkInitializeMethodContents(method);

        _sourceDataClass.Members.Add(method);
    }

    /*
     * Build the contents of the FrameworkInitialize method
     */
    protected virtual void BuildFrameworkInitializeMethodContents(CodeMemberMethod method) {

        if (!Parser.FEnableViewState) {
            method.Statements.Add(new CodeAssignStatement(
                new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "EnableViewState"),
                new CodePrimitiveExpression(false)));
        }

        // No strings: don't do anything
        if (_stringResourceBuilder.HasStrings) {

            // e.g. SetStringResourcePointer(__stringResource, 567);
            CodeMethodInvokeExpression methCallExpression = new CodeMethodInvokeExpression(
                null, "SetStringResourcePointer");
            methCallExpression.Parameters.Add(new CodeFieldReferenceExpression(
                _classTypeExpr, stringResourcePointerName));
            methCallExpression.Parameters.Add(new CodePrimitiveExpression(
                _stringResourceBuilder.MaxResourceOffset));
            method.Statements.Add(new CodeExpressionStatement(methCallExpression));
        }

        CodeMethodInvokeExpression call = new CodeMethodInvokeExpression();
        call.Method.TargetObject = new CodeThisReferenceExpression();
        call.Method.MethodName = "__BuildControlTree";
        call.Parameters.Add(new CodeThisReferenceExpression());
        method.Statements.Add(new CodeExpressionStatement(call));
    }

    /*
     * Build the automatic event hookup code
     */
    private void BuildAutomaticEventHookup() {

        CodeMemberProperty prop;

        // If FAutoEventWireup is off, just generate a SupportAutoEvents prop that
        // returns false.
        if (!Parser.FAutoEventWireup) {
            prop = new CodeMemberProperty();
            prop.Attributes &= ~MemberAttributes.AccessMask;
            prop.Attributes &= ~MemberAttributes.ScopeMask;
            prop.Attributes |= MemberAttributes.Override | MemberAttributes.Family;
            prop.Name = "SupportAutoEvents";
            prop.Type = new CodeTypeReference(typeof(bool));
            prop.GetStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(false)));
            _sourceDataClass.Members.Add(prop);
            return;
        }

        // e.g. private static int __autoHandlers;
        CodeMemberField autoHandlers = new CodeMemberField(typeof(int).FullName, "__autoHandlers");
        autoHandlers.Attributes |= MemberAttributes.Static;
        _sourceDataClass.Members.Add(autoHandlers);

        // Expose __autoHandlers through a virtual prop so that the code in
        // the Page class can access it
        prop = new CodeMemberProperty();
        prop.Attributes &= ~MemberAttributes.AccessMask;
        prop.Attributes &= ~MemberAttributes.ScopeMask;
        prop.Attributes |= MemberAttributes.Override | MemberAttributes.Family;
        prop.Name = "AutoHandlers";
        prop.Type = new CodeTypeReference(typeof(int));
        prop.GetStatements.Add(new CodeMethodReturnStatement(new CodeFieldReferenceExpression(_classTypeExpr,
                                                                                              "__autoHandlers")));
        prop.SetStatements.Add(new CodeAssignStatement(
                                                      new CodeFieldReferenceExpression(_classTypeExpr, "__autoHandlers"),
                                                      new CodePropertySetValueReferenceExpression()));
        _sourceDataClass.Members.Add(prop);
    }

    /*
     * Build the ApplicationInstance property
     */
    private void BuildApplicationInstanceProperty() {

        CodeMemberProperty prop;

        Type appType = HttpApplicationFactory.ApplicationType;
        
        prop = new CodeMemberProperty();
        prop.Attributes &= ~MemberAttributes.AccessMask;
        prop.Attributes &= ~MemberAttributes.ScopeMask;
        prop.Attributes |= MemberAttributes.Final | MemberAttributes.Family;
        prop.Name = "ApplicationInstance";
        prop.Type = new CodeTypeReference(appType);

        CodePropertyReferenceExpression propRef = new CodePropertyReferenceExpression(
            new CodeThisReferenceExpression(), "Context");
        propRef = new CodePropertyReferenceExpression(propRef, "ApplicationInstance");
        
        prop.GetStatements.Add(new CodeMethodReturnStatement(new CodeCastExpression(
            appType.FullName, propRef)));
        _sourceDataClass.Members.Add(prop);
    }

    /*
     * Build the SourceDir property
     */
    private void BuildSourceDirProperty() {

        CodeMemberProperty prop = new CodeMemberProperty();
        prop.Attributes &= ~MemberAttributes.AccessMask;
        prop.Attributes &= ~MemberAttributes.ScopeMask;
        prop.Attributes |= MemberAttributes.Override | MemberAttributes.Public;
        prop.Name = "TemplateSourceDirectory";
        prop.Type = new CodeTypeReference(typeof(string));

        prop.GetStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(
            Parser.BaseVirtualDir)));
        _sourceDataClass.Members.Add(prop);
    }

    private void BuildSourceDataTreeFromBuilder(ControlBuilder builder,
                                                bool fInTemplate, 
                                                PropertySetterEntry pse) {

        // Don't do anything for Code blocks
        if (builder is CodeBlockBuilder)
            return;

        // Is the current builder for a template?
        bool fTemplate = (builder is TemplateBuilder);

        bool fGeneratedID = false;

        // For the control name in the compiled code, we use the
        // ID if one is available (but don't use the ID inside a template)
        // Otherwise, we generate a unique name.
        if (builder.ID == null || fInTemplate) {
            // Increase the control count to generate unique ID's
            _controlCount++;

            builder.ID = "__control" + _controlCount.ToString(NumberFormatInfo.InvariantInfo);
            fGeneratedID = true;
        }

        // Process the children
        if (builder.SubBuilders != null) {
            foreach (object child in builder.SubBuilders) {
                if (child is ControlBuilder) {
                    BuildSourceDataTreeFromBuilder((ControlBuilder)child, fInTemplate, null);
                }
            }
        }

        // Process the templates
        if (builder.TemplatesSetter != null) {
            foreach (PropertySetterEntry pseSub in builder.TemplatesSetter._entries) {
                BuildSourceDataTreeFromBuilder(pseSub._builder, true, pseSub);
            }
        }

        // Process the complex attributes
        if (builder.ComplexAttributeSetter != null) {
            foreach (PropertySetterEntry pseSub in builder.ComplexAttributeSetter._entries) {
                BuildSourceDataTreeFromBuilder(pseSub._builder, fInTemplate, pseSub);
            }
        }

        // Build a field declaration for the control (unless it's a template)
        if (!fTemplate)
            BuildFieldDeclaration(builder, fGeneratedID);

        // Build a Build method for the control
        BuildBuildMethod(builder, fTemplate, pse);

        // Build a Render method for the control, unless it has no code
        if (builder.HasAspCode) {
            BuildRenderMethod(builder, fTemplate);
        }

        // Build a property binding method for the control
        BuildPropertyBindingMethod(builder);
    }

    /*
     * Build the member field's declaration for a control
     */
    private void BuildFieldDeclaration(ControlBuilder builder, bool fGeneratedID) {

        // If we're using a non-default base class
        if (_baseClassType != null) {
            // Check if it has a non-private field or property that has a name that
            // matches the id of the control.

            Type memberType = Util.GetNonPrivateFieldType(_baseClassType, builder.ID);

            // Couldn't find a field, try a property (ASURT 45039)
            // REVIEW: should be VB only
            if (memberType == null)
                memberType = Util.GetNonPrivatePropertyType(_baseClassType, builder.ID);

            if (memberType != null) {
                if (!memberType.IsAssignableFrom(builder.ControlType)) {
                    throw new HttpParseException(HttpRuntime.FormatResourceString(SR.Base_class_field_with_type_different_from_type_of_control,
                        builder.ID, memberType.FullName, builder.ControlType.FullName), null,
                        builder.SourceFileName, null, builder.Line);
                }

                // Don't build the declaration, since the base
                // class already declares it
                return;
            }
        }

        // Add the field.  Make it protected if the ID was declared, and private if it was generated
        CodeMemberField field = new CodeMemberField(builder.ControlType.FullName, builder.ID);
        field.Attributes &= ~MemberAttributes.AccessMask;
        if (fGeneratedID)
            field.Attributes |= MemberAttributes.Private;
        else
            field.Attributes |= MemberAttributes.Family;
        field.LinePragma = CreateCodeLinePragma(builder.SourceFileName, builder.Line);
        _sourceDataClass.Members.Add(field);
    }

    private string GetMethodNameForBuilder(string prefix, ControlBuilder builder, bool derivedBuildMethod) {
        if (derivedBuildMethod) {
            if (builder is RootBuilder) {
                return prefix + "DerivedTree";
            }
            else {
                return prefix + "Derived" + builder.ID;
            }
        }
        else {
            if (builder is RootBuilder) {
                return prefix + "Tree";
            }
            else {
                return prefix + builder.ID;
            }
        }
    }

    private string GetCtrlTypeForBuilder(ControlBuilder builder, bool fTemplate) {
        if (fTemplate) {
            return typeof(Control).FullName;
        }
        else {
            return builder.ControlType.FullName;
        }
    }

    /*
     * Build the data tree for a control's build method
     */
    private void BuildBuildMethod(ControlBuilder builder, bool fTemplate, PropertySetterEntry pse) {

        CodeExpressionStatement methCallStatement;
        CodeMethodInvokeExpression methCallExpression;
        CodeObjectCreateExpression newExpr;
        string methodName = GetMethodNameForBuilder(buildMethodPrefix, builder, false);
        string ctrlTypeName = GetCtrlTypeForBuilder(builder, fTemplate);
        bool fStandardControl = false;
        bool gotParserVariable = false;
        bool fControlFieldDeclared = false;

        // Same linePragma in the entire build method
        CodeLinePragma linePragma = CreateCodeLinePragma(builder.SourceFileName, builder.Line);

        // These are used in a number of places
        CodeFieldReferenceExpression ctrlNameExpr = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), builder.ID);
        CodeExpression ctrlRefExpr;

        CodeMemberMethod method = new CodeMemberMethod();
        method.Name = methodName;
        method.Attributes = MemberAttributes.Private | MemberAttributes.Final;

        _sourceDataClass.Members.Add(method);

        // If it's for a template or a r/o complex prop, pass a parameter of the control's type
        if (fTemplate || (pse != null && pse._fReadOnlyProp)) {
            method.Parameters.Add(new CodeParameterDeclarationExpression(ctrlTypeName, "__ctrl"));
            ctrlRefExpr = new CodeArgumentReferenceExpression("__ctrl");
        }

        // It's neither a template nor a r/o prop
        else {

            // If it's a standard control, return it from the method
            if (typeof(Control).IsAssignableFrom(builder.ControlType)) {
                fStandardControl = true;
                method.ReturnType = new CodeTypeReference(typeof(Control));
            }

            newExpr = new CodeObjectCreateExpression(builder.ControlType.FullName);

            // If it has a ConstructorNeedsTagAttribute, it needs a tag name
            ConstructorNeedsTagAttribute cnta = (ConstructorNeedsTagAttribute)
                                                TypeDescriptor.GetAttributes(builder.ControlType)[typeof(ConstructorNeedsTagAttribute)];

            if (cnta != null && cnta.NeedsTag) {
                newExpr.Parameters.Add(new CodePrimitiveExpression(builder.TagName));
            }

            // If it's for a DataBoundLiteralControl, pass it the number of
            // entries in the constructor
            DataBoundLiteralControlBuilder dataBoundBuilder = builder as DataBoundLiteralControlBuilder;
            if (dataBoundBuilder != null) {
                newExpr.Parameters.Add(new CodePrimitiveExpression(
                    dataBoundBuilder.GetStaticLiteralsCount()));
                newExpr.Parameters.Add(new CodePrimitiveExpression(
                    dataBoundBuilder.GetDataBoundLiteralCount()));
            }

            // e.g. {{controlTypeName}} __ctrl;
            method.Statements.Add(new CodeVariableDeclarationStatement(builder.ControlType.FullName, "__ctrl"));
            ctrlRefExpr = new CodeVariableReferenceExpression("__ctrl");

            // e.g. __ctrl = new {{controlTypeName}}();
            CodeAssignStatement setCtl = new CodeAssignStatement(ctrlRefExpr, newExpr);
            setCtl.LinePragma = linePragma;
            method.Statements.Add(setCtl);

            // e.g. {{controlName}} = __ctrl;
            CodeAssignStatement underscoreCtlSet = new CodeAssignStatement(ctrlNameExpr, ctrlRefExpr);
            method.Statements.Add(underscoreCtlSet);
            fControlFieldDeclared = true;
        }

        // Is this BuilderData for a declarative control?  If so initialize it (75330)
        // Only do this is the control field has been declared (i.e. not with templates)
        if (typeof(UserControl).IsAssignableFrom(builder.ControlType) && fControlFieldDeclared) {
            // e.g. {{controlName}}.InitializeAsUserControl(Context, Page);
            methCallExpression = new CodeMethodInvokeExpression(ctrlNameExpr, "InitializeAsUserControl");
            methCallExpression.Parameters.Add(new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "Page"));
            methCallStatement = new CodeExpressionStatement(methCallExpression);
            methCallStatement.LinePragma = linePragma;
            method.Statements.Add(methCallStatement);
        }

        // Process the simple attributes
        if (builder.SimpleAttributeSetter != null &&
            builder.SimpleAttributeSetter._entries != null) {

            foreach (PropertySetterEntry pseSub in builder.SimpleAttributeSetter._entries) {

                // If we don't have a type, use IAttributeAccessor.SetAttribute
                if (pseSub._propType == null) {
                    // e.g. ((IAttributeAccessor)__ctrl).SetAttribute("{{_name}}", "{{_value}}");
                    methCallExpression = new CodeMethodInvokeExpression(new CodeCastExpression(typeof(IAttributeAccessor), ctrlRefExpr),
                                                                      "SetAttribute");

                    methCallExpression.Parameters.Add(new CodePrimitiveExpression(pseSub._name));
                    methCallExpression.Parameters.Add(new CodePrimitiveExpression(pseSub._value));
                    methCallStatement = new CodeExpressionStatement(methCallExpression);
                    methCallStatement.LinePragma = linePragma;
                    method.Statements.Add(methCallStatement);
                }
                else {
                    CodeExpression leftExpr, rightExpr = null;

                    // The left side of the assignment is always the same, so
                    // precalculate it
                    // e.g. __ctrl.{{_name}}
                    if (pseSub._propInfo != null) {
                        // The name may contain several '.' separated properties, so we
                        // need to make sure we build the CodeDOM accordingly (ASURT 91875)
                        string[] parts = pseSub._name.Split('.');
                        leftExpr = ctrlRefExpr;
                        foreach (string part in parts)
                            leftExpr = new CodePropertyReferenceExpression(leftExpr, part);
                    }
                    else {
                        // In case of a field, there should only be one (unlike properties)
                        Debug.Assert(pseSub._name.IndexOf('.') < 0, "pseSub._name.IndexOf('.') < 0");
                        leftExpr = new CodeFieldReferenceExpression(ctrlRefExpr, pseSub._name);
                    }

                    if (pseSub._propType == typeof(string)) {
                        rightExpr = CodeDomUtility.GenerateExpressionForValue(pseSub._propInfo, pseSub._value, pseSub._propType);
                    }
                    else {
                        rightExpr = CodeDomUtility.GenerateExpressionForValue(pseSub._propInfo, pseSub._propValue, pseSub._propType);
                    }

                    // Now that we have both side, add the assignment
                    CodeAssignStatement setStatment = new CodeAssignStatement(leftExpr, rightExpr);
                    setStatment.LinePragma = linePragma;
                    method.Statements.Add(setStatment);
                }
            }
        }

        // Process the templates
        if (builder.TemplatesSetter != null) {
            foreach (PropertySetterEntry pseSub in builder.TemplatesSetter._entries) {
                // e.g. __ctrl.{{templateName}} = new CompiledTemplateBuilder(
                // e.g.     new BuildTemplateMethod(this.__BuildControl {{controlName}}));
                CodeDelegateCreateExpression newDelegate = new CodeDelegateCreateExpression();
                newDelegate.DelegateType = new CodeTypeReference(typeof(BuildTemplateMethod));
                newDelegate.TargetObject = new CodeThisReferenceExpression();
                newDelegate.MethodName = buildMethodPrefix + pseSub._builder.ID;

                newExpr = new CodeObjectCreateExpression(typeof(CompiledTemplateBuilder).FullName);
                newExpr.Parameters.Add(newDelegate);

                CodeAssignStatement set = new CodeAssignStatement();
                if (pseSub._propInfo != null) {
                    set.Left = new CodePropertyReferenceExpression(ctrlRefExpr, pseSub._name);
                }
                else {
                    set.Left = new CodeFieldReferenceExpression(ctrlRefExpr, pseSub._name);
                }
                set.Right = newExpr;
                set.LinePragma = CreateCodeLinePragma(pseSub._builder.SourceFileName, pseSub._builder.Line);
                method.Statements.Add(set);
            }
        }

        if (builder is DataBoundLiteralControlBuilder) {

            // If it's a DataBoundLiteralControl, build it by calling SetStaticString
            // on all the static literal strings.
            int i = -1;
            foreach (object child in builder.SubBuilders) {
                i++;

                // Ignore it if it's null
                if (child == null)
                    continue;

                // Only deal with the strings here, which have even index
                if (i % 2 == 1) {
                    Debug.Assert(child is CodeBlockBuilder, "child is CodeBlockBuilder");
                    continue;
                }

                string s = (string) child;

                // e.g. __ctrl.SetStaticString(3, "literal string");
                methCallExpression = new CodeMethodInvokeExpression(ctrlRefExpr, "SetStaticString");
                methCallExpression.Parameters.Add(new CodePrimitiveExpression(i/2));
                methCallExpression.Parameters.Add(new CodePrimitiveExpression(s));
                method.Statements.Add(new CodeExpressionStatement(methCallExpression));
            }
        }
        // Process the children
        else if (builder.SubBuilders != null) {

            foreach (object child in builder.SubBuilders) {

                if (child is ControlBuilder && !(child is CodeBlockBuilder)) {
                    ControlBuilder ctrlBuilder = (ControlBuilder) child;

                    PartialCachingAttribute cacheAttrib = (PartialCachingAttribute)
                        TypeDescriptor.GetAttributes(ctrlBuilder.ControlType)[typeof(PartialCachingAttribute)];

                    // e.g. __BuildControl__control6();
                    methCallExpression = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(),
                                                                      buildMethodPrefix + ctrlBuilder.ID);
                    methCallStatement = new CodeExpressionStatement(methCallExpression);
                    methCallStatement.LinePragma = linePragma;

                    if (cacheAttrib == null) {
                        // If there is no caching on the control, just create it and add it

                        // e.g. __BuildControl__control6();
                        method.Statements.Add(methCallStatement);

                        // e.g. __parser.AddParsedSubObject({{controlName}});
                        BuildAddParsedSubObjectStatement(
                            method.Statements,
                            new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), ctrlBuilder.ID),
                            linePragma,
                            ctrlRefExpr,
                            ref gotParserVariable);
                    }
                    else {
                        // The control's output is getting cached.  Call
                        // StaticPartialCachingControl.BuildCachedControl to do the work.

                        // e.g. StaticPartialCachingControl.BuildCachedControl(__ctrl, Request, "e4192e6d-cbe0-4df5-b516-682c10415590", __pca, new System.Web.UI.BuildMethod(this.__BuildControlt1));
                        CodeMethodInvokeExpression call = new CodeMethodInvokeExpression();
                        call.Method.TargetObject = new CodeTypeReferenceExpression(typeof(System.Web.UI.StaticPartialCachingControl));
                        call.Method.MethodName = "BuildCachedControl";
                        call.Parameters.Add(ctrlRefExpr);
                        call.Parameters.Add(new CodePrimitiveExpression(ctrlBuilder.ID));

                        // If the caching is shared, use the type of the control as the key
                        // otherwise, generate a guid
                        if (cacheAttrib.Shared) {
                            call.Parameters.Add(new CodePrimitiveExpression(
                                ctrlBuilder.ControlType.GetHashCode().ToString()));
                        }
                        else
                            call.Parameters.Add(new CodePrimitiveExpression(Guid.NewGuid().ToString()));
                        call.Parameters.Add(new CodePrimitiveExpression(cacheAttrib.Duration));
                        call.Parameters.Add(new CodePrimitiveExpression(cacheAttrib.VaryByParams));
                        call.Parameters.Add(new CodePrimitiveExpression(cacheAttrib.VaryByControls));
                        call.Parameters.Add(new CodePrimitiveExpression(cacheAttrib.VaryByCustom));
                        CodeDelegateCreateExpression newDelegate = new CodeDelegateCreateExpression();
                        newDelegate.DelegateType = new CodeTypeReference(typeof(BuildMethod));
                        newDelegate.TargetObject = new CodeThisReferenceExpression();
                        newDelegate.MethodName = buildMethodPrefix + ctrlBuilder.ID;
                        call.Parameters.Add(newDelegate);
                        method.Statements.Add(new CodeExpressionStatement(call));
                    }

                }
                else if (child is string && !builder.HasAspCode) {

                    string s = (string) child;
                    CodeExpression expr;

                    if (!UseResourceLiteralString(s)) {
                        // e.g. ((IParserAccessor)__ctrl).AddParsedSubObject(new LiteralControl({{@QuoteCString(text)}}));
                        newExpr = new CodeObjectCreateExpression(typeof(LiteralControl).FullName);
                        newExpr.Parameters.Add(new CodePrimitiveExpression(s));
                        expr = newExpr;
                    }
                    else {
                        // Add the string to the resource builder, and get back its offset/size
                        int offset, size;
                        bool fAsciiOnly;
                        _stringResourceBuilder.AddString(s, out offset, out size, out fAsciiOnly);

                        methCallExpression = new CodeMethodInvokeExpression();
                        methCallExpression.Method.TargetObject = new CodeThisReferenceExpression();
                        methCallExpression.Method.MethodName = "CreateResourceBasedLiteralControl";
                        methCallExpression.Parameters.Add(new CodePrimitiveExpression(offset));
                        methCallExpression.Parameters.Add(new CodePrimitiveExpression(size));
                        methCallExpression.Parameters.Add(new CodePrimitiveExpression(fAsciiOnly));
                        expr = methCallExpression;
                    }

                    BuildAddParsedSubObjectStatement(method.Statements, expr, linePragma, ctrlRefExpr, ref gotParserVariable);
                }
            }
        }

        // Process the complex attributes
        if (builder.ComplexAttributeSetter != null) {

            foreach (PropertySetterEntry pseSub in builder.ComplexAttributeSetter._entries) {

                if (pseSub._fReadOnlyProp) {
                    // If it's a readonly prop, pass it as a parameter to the
                    // build method.
                    // e.g. __BuildControl {{controlName}}(__ctrl.{{pse._name}});
                    methCallExpression = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(),
                                                                      buildMethodPrefix + pseSub._builder.ID);
                    methCallExpression.Parameters.Add(new CodePropertyReferenceExpression(ctrlRefExpr, pseSub._name));
                    methCallStatement = new CodeExpressionStatement(methCallExpression);
                    methCallStatement.LinePragma = linePragma;
                    method.Statements.Add(methCallStatement);
                }
                else {
                    // e.g. __BuildControl {{controlName}}();
                    methCallExpression = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(),
                                                                      buildMethodPrefix + pseSub._builder.ID);
                    methCallStatement = new CodeExpressionStatement(methCallExpression);
                    methCallStatement.LinePragma = linePragma;
                    method.Statements.Add(methCallStatement);

                    if (pseSub._fItemProp) {
                        // e.g. __ctrl.Add({{controlName}});
                        methCallExpression = new CodeMethodInvokeExpression(ctrlRefExpr, "Add");
                        methCallStatement = new CodeExpressionStatement(methCallExpression);
                        methCallStatement.LinePragma = linePragma;
                        method.Statements.Add(methCallStatement);
                        methCallExpression.Parameters.Add(new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), pseSub._builder.ID));
                    }
                    else {
                        // e.g. __ctrl.{{pse._name}} = {{controlName}};
                        CodeAssignStatement set = new CodeAssignStatement();
                        set.Left = new CodePropertyReferenceExpression(ctrlRefExpr, pseSub._name);
                        set.Right = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(),
                                                                     pseSub._builder.ID);
                        set.LinePragma = linePragma;
                        method.Statements.Add(set);
                    }
                }
            }
        }

        // If there are bound properties, hook up the binding method
        if (builder.BoundAttributeSetter != null || (builder is DataBoundLiteralControlBuilder)) {

            // __ctrl.DataBinding += new EventHandler(this.{{bindingMethod}})
            CodeDelegateCreateExpression newDelegate = new CodeDelegateCreateExpression();
            CodeAttachEventStatement attachEvent = new CodeAttachEventStatement(ctrlRefExpr, "DataBinding", newDelegate);
            attachEvent.LinePragma = linePragma;
            newDelegate.DelegateType = new CodeTypeReference(typeof(EventHandler));
            newDelegate.TargetObject = new CodeThisReferenceExpression();
            newDelegate.MethodName = BindingMethodName(builder);
            method.Statements.Add(attachEvent);
        }

        // If there is any ASP code, set the render method delegate
        if (builder.HasAspCode) {

            // e.g. __ctrl.SetRenderMethodDelegate(new RenderMethod(this.__Render {{controlName}}));
            CodeDelegateCreateExpression newDelegate = new CodeDelegateCreateExpression();
            newDelegate.DelegateType = new CodeTypeReference(typeof(RenderMethod));
            newDelegate.TargetObject = new CodeThisReferenceExpression();
            newDelegate.MethodName = "__Render" + builder.ID;

            methCallExpression = new CodeMethodInvokeExpression(ctrlRefExpr, "SetRenderMethodDelegate");
            methCallExpression.Parameters.Add(newDelegate);
            methCallStatement = new CodeExpressionStatement(methCallExpression);
            method.Statements.Add(methCallStatement);
        }

        // Process the events
        if (builder.SimpleAttributeSetter != null &&
            builder.SimpleAttributeSetter._events != null &&
            builder.SimpleAttributeSetter._events.Count != 0) {

            foreach (PropertySetterEventEntry eventEntry in builder.SimpleAttributeSetter._events) {

                // Attach the event.  Detach it first to avoid duplicates (see ASURT 42603),
                // but only if there is codebehind
                // REVIEW: does this really work?  Even if the handler was already added,
                // the EventHandler object will be different and the remove will do nothing...

                // e.g. __ctrl.ServerClick -= new System.EventHandler(this.buttonClicked);
                // e.g. __ctrl.ServerClick += new System.EventHandler(this.buttonClicked);
                CodeDelegateCreateExpression newDelegate = new CodeDelegateCreateExpression();
                newDelegate.DelegateType = new CodeTypeReference(eventEntry._handlerType.FullName);
                newDelegate.TargetObject = new CodeThisReferenceExpression();
                newDelegate.MethodName = eventEntry._handlerMethodName;

                if (Parser.HasCodeBehind) {
                    CodeRemoveEventStatement detachEvent = new CodeRemoveEventStatement(ctrlRefExpr, eventEntry._eventName, newDelegate);
                    detachEvent.LinePragma = linePragma;
                    method.Statements.Add(detachEvent);
                }

                CodeAttachEventStatement attachEvent = new CodeAttachEventStatement(ctrlRefExpr, eventEntry._eventName, newDelegate);
                attachEvent.LinePragma = linePragma;
                method.Statements.Add(attachEvent);
            }
        }

        // If it's for s standard control, return it
        if (fStandardControl)
            method.Statements.Add(new CodeMethodReturnStatement(ctrlRefExpr));
    }

    private static void BuildAddParsedSubObjectStatement(
                CodeStatementCollection statements, CodeExpression ctrlToAdd, CodeLinePragma linePragma, CodeExpression ctrlRefExpr, ref bool gotParserVariable) {

        if (!gotParserVariable) {
            // e.g. IParserAccessor __parser = ((IParserAccessor)__ctrl);
            CodeVariableDeclarationStatement parserDeclaration = new CodeVariableDeclarationStatement();
            parserDeclaration.Name = "__parser";
            parserDeclaration.Type = new CodeTypeReference(typeof(IParserAccessor));
            parserDeclaration.InitExpression = new CodeCastExpression(
                                                    typeof(IParserAccessor), 
                                                    ctrlRefExpr);
            statements.Add(parserDeclaration);
            gotParserVariable = true;
        }

        // e.g. __parser.AddParsedSubObject({{controlName}});
        CodeMethodInvokeExpression methCallExpression = new CodeMethodInvokeExpression(
                new CodeVariableReferenceExpression("__parser"), "AddParsedSubObject");
        methCallExpression.Parameters.Add(ctrlToAdd);
        CodeExpressionStatement methCallStatement = new CodeExpressionStatement(methCallExpression);
        methCallStatement.LinePragma = linePragma;

        statements.Add(methCallStatement);
    }

    /*
     * Return the name of a databinding method
     */
    private string BindingMethodName(ControlBuilder builder) {
        return "__DataBind" + builder.ID;
    }

    /*
     * Build the data tree for a control's databinding method
     */
    private void BuildPropertyBindingMethod(ControlBuilder builder) {
        // No bound properties: nothing to do
        if (builder.BoundAttributeSetter == null && !(builder is DataBoundLiteralControlBuilder))
            return;

        // Get the name of the databinding method
        string methodName = BindingMethodName(builder);

        // Same linePragma in the entire method
        CodeLinePragma linePragma = CreateCodeLinePragma(builder.SourceFileName, builder.Line);


        CodeMemberMethod method = new CodeMemberMethod();
        method.Name = methodName;
        method.Attributes &= ~MemberAttributes.AccessMask;
        method.Attributes |= MemberAttributes.Public;

        _sourceDataClass.Members.Add(method);

        method.Parameters.Add(new CodeParameterDeclarationExpression(typeof(object).FullName, "sender"));
        method.Parameters.Add(new CodeParameterDeclarationExpression(typeof(EventArgs).FullName, "e"));

        // {{controlType}} target;
        CodeVariableDeclarationStatement targetDecl = new CodeVariableDeclarationStatement(builder.ControlType.FullName, "target");
        Type namingContainerType = builder.NamingContainerType;
        CodeVariableDeclarationStatement containerDecl = new CodeVariableDeclarationStatement(namingContainerType.FullName, "Container");

        method.Statements.Add(containerDecl);
        method.Statements.Add(targetDecl);

        // target = ({{controlType}}) sender;
        CodeAssignStatement setTarget = new CodeAssignStatement(new CodeVariableReferenceExpression(targetDecl.Name),
                                                                new CodeCastExpression(builder.ControlType.FullName,
                                                                                       new CodeArgumentReferenceExpression("sender")));
        setTarget.LinePragma = linePragma;
        method.Statements.Add(setTarget);

        // {{containerType}} Container = ({{containerType}}) target.NamingContainer;
        CodeAssignStatement setContainer = new CodeAssignStatement(new CodeVariableReferenceExpression(containerDecl.Name),
                                                                   new CodeCastExpression(namingContainerType.FullName,
                                                                                          new CodePropertyReferenceExpression(new CodeVariableReferenceExpression("target"), 
                                                                                                                              "BindingContainer")));
        setContainer.LinePragma = linePragma;
        method.Statements.Add(setContainer);

        if (builder is DataBoundLiteralControlBuilder) {

            // If it's a DataBoundLiteralControl, call SetDataBoundString for each
            // of the databinding exporessions
            int i = -1;
            foreach (object child in builder.SubBuilders) {
                i++;

                // Ignore it if it's null
                if (child == null)
                    continue;

                // Only deal with the databinding expressions here, which have odd index
                if (i % 2 == 0) {
                    Debug.Assert(child is string, "child is string");
                    continue;
                }

                CodeBlockBuilder codeBlock = (CodeBlockBuilder) child;
                Debug.Assert(codeBlock.BlockType == CodeBlockType.DataBinding);

                // e.g. target.SetDataBoundString(3, System.Convert.ToString({{codeExpr}}));
                CodeMethodInvokeExpression convertExpr = new CodeMethodInvokeExpression();
                convertExpr.Method.TargetObject = new CodeTypeReferenceExpression(typeof(System.Convert));
                convertExpr.Method.MethodName = "ToString";
                convertExpr.Parameters.Add(new CodeSnippetExpression(codeBlock.Content.Trim()));

                CodeMethodInvokeExpression methCallExpression = new CodeMethodInvokeExpression(
                    new CodeVariableReferenceExpression("target"), "SetDataBoundString");
                methCallExpression.Parameters.Add(new CodePrimitiveExpression(i/2));
                methCallExpression.Parameters.Add(convertExpr);

                CodeStatement setDataBoundStringCall = new CodeExpressionStatement(methCallExpression);
                setDataBoundStringCall.LinePragma = CreateCodeLinePragma(codeBlock.SourceFileName, codeBlock.Line);
                method.Statements.Add(setDataBoundStringCall);
            }

            return;
        }

        foreach (PropertySetterEntry pseSub in builder.BoundAttributeSetter._entries) {

            // If we don't have a type, use IAttributeAccessor.SetAttribute
            if (pseSub._propType == null) {
                // ((IAttributeAccessor)target).SetAttribute({{codeExpr}}.ToString());

                CodeMethodInvokeExpression methodInvoke = new CodeMethodInvokeExpression();
                CodeExpressionStatement setAttributeCall = new CodeExpressionStatement(methodInvoke);

                methodInvoke.Method.TargetObject = new CodeCastExpression(typeof(IAttributeAccessor).FullName, new CodeVariableReferenceExpression(targetDecl.Name));
                methodInvoke.Method.MethodName = "SetAttribute";
                methodInvoke.Parameters.Add(new CodePrimitiveExpression(pseSub._name));
                CodeMethodInvokeExpression invokeExpr = new CodeMethodInvokeExpression();
                invokeExpr.Method.TargetObject = new CodeTypeReferenceExpression(typeof(System.Convert));
                invokeExpr.Method.MethodName = "ToString";
                invokeExpr.Parameters.Add(new CodeSnippetExpression(pseSub._value));
                methodInvoke.Parameters.Add(invokeExpr);

                setAttributeCall.LinePragma = linePragma;
                method.Statements.Add(setAttributeCall);
            }
            else {
                // Per ASURT 26785, we generate a call to System.Convert.ToString() instead of casting
                // if the type of the property is string.  This works better because
                // System.Convert.ToString(17) works, while (string)17 doesn't.
                CodeExpression expr = new CodeSnippetExpression(pseSub._value.Trim());
                CodeExpression rightSide;

                if (pseSub._propType == typeof(string)) {
                    // target.{{propName}} = System.Convert.ToString({{codeExpr}});
                    CodeMethodInvokeExpression invokeExpr = new CodeMethodInvokeExpression();
                    invokeExpr.Method.TargetObject = new CodeTypeReferenceExpression(typeof(System.Convert));
                    invokeExpr.Method.MethodName = "ToString";
                    invokeExpr.Parameters.Add(expr);
                    rightSide = invokeExpr;
                }
                else {
                    // target.{{propName}} = ({{propType}}) {{codeExpr}};
                    rightSide = new CodeCastExpression(pseSub._propType.FullName, expr);
                }

                CodeAssignStatement setProp = new CodeAssignStatement(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(targetDecl.Name),
                                                                                                          pseSub._name),
                                                                      rightSide);
                setProp.LinePragma = linePragma;
                method.Statements.Add(setProp);
            }
        }
    }

    /*
     * Build the data tree for a control's render method
     */
    private void BuildRenderMethod(ControlBuilder builder, bool fTemplate) {

        CodeMemberMethod method = new CodeMemberMethod();
        method.Attributes = MemberAttributes.Private | MemberAttributes.Final;
        method.Name = "__Render" + builder.ID;

        method.Parameters.Add(new CodeParameterDeclarationExpression(typeof(HtmlTextWriter), renderMethodParameterName));
        method.Parameters.Add(new CodeParameterDeclarationExpression(typeof(Control), "parameterContainer"));

        _sourceDataClass.Members.Add(method);

        // Process the children if any
        if (builder.SubBuilders != null) {
            IEnumerator en = builder.SubBuilders.GetEnumerator();

            // Index that the control will have in its parent's Controls
            // collection.
            // REVIEW: this is to fix ASURT 8579.  The fix is kind of risky,
            // because it assumes that every call to AddParsedSubObject
            // will result in an object being added to the Controls
            // collection.
            int controlIndex = 0;

            for (int i=0; en.MoveNext(); i++) {
                object child = en.Current;

                CodeLinePragma linePragma = null;

                if (child is ControlBuilder) {
                    linePragma = CreateCodeLinePragma(((ControlBuilder)child).SourceFileName,
                                                    ((ControlBuilder)child).Line);
                }

                if (child is string) {
                    AddOutputWriteStringStatement(method.Statements, (string)child);
                }
                else if (child is CodeBlockBuilder) {
                    CodeBlockBuilder codeBlockBuilder = (CodeBlockBuilder)child;

                    if (codeBlockBuilder.BlockType == CodeBlockType.Expression) {
                        // It's a <%= ... %> block
                        AddOutputWriteStatement(method.Statements,
                                                new CodeSnippetExpression(codeBlockBuilder.Content),
                                                linePragma);
                    }
                    else {
                        // It's a <% ... %> block
                        Debug.Assert(codeBlockBuilder.BlockType == CodeBlockType.Code);
                        CodeSnippetStatement lit = new CodeSnippetStatement(codeBlockBuilder.Content);
                        lit.LinePragma = linePragma;
                        method.Statements.Add(lit);
                    }
                }
                else if (child is ControlBuilder) {

                    // parameterContainer.Controls['controlIndex++'].RenderControl(output)
                    CodeMethodInvokeExpression methodInvoke = new CodeMethodInvokeExpression();
                    CodeExpressionStatement methodCall = new CodeExpressionStatement(methodInvoke);
                    methodInvoke.Method.TargetObject = new CodeIndexerExpression(new CodePropertyReferenceExpression(new CodeArgumentReferenceExpression("parameterContainer"), 
                                                                                                                         "Controls"), 
                                                                                     new CodeExpression[] {
                                                                                         new CodePrimitiveExpression(controlIndex++),
                                                                                     });
                    methodInvoke.Method.MethodName = "RenderControl";
                    methodCall.LinePragma = linePragma;
                    methodInvoke.Parameters.Add(new CodeArgumentReferenceExpression(renderMethodParameterName));
                    method.Statements.Add(methodCall);
                }
            }
        }
    }

    private bool UseResourceLiteralString(string s) {

        // If the string is long enough, and the compiler supports it, use a UTF8 resource
        // string for performance
        return (s.Length >= minLongLiteralStringLength && _generator.Supports(GeneratorSupport.Win32Resources));
    }

    private void AddOutputWriteStringStatement(CodeStatementCollection methodStatements, 
                                 String s) {

        if (!UseResourceLiteralString(s)) {
            AddOutputWriteStatement(methodStatements, new CodePrimitiveExpression(s), null);
            return;
        }

        // Add the string to the resource builder, and get back its offset/size
        int offset, size;
        bool fAsciiOnly;
        _stringResourceBuilder.AddString(s, out offset, out size, out fAsciiOnly);

        // e.g. WriteUTF8ResourceString(output, 314, 20);
        CodeMethodInvokeExpression methodInvoke = new CodeMethodInvokeExpression();
        CodeExpressionStatement call = new CodeExpressionStatement(methodInvoke);            
        methodInvoke.Method.TargetObject = new CodeThisReferenceExpression();
        methodInvoke.Method.MethodName = "WriteUTF8ResourceString";
        methodInvoke.Parameters.Add(new CodeArgumentReferenceExpression(renderMethodParameterName));
        methodInvoke.Parameters.Add(new CodePrimitiveExpression(offset));
        methodInvoke.Parameters.Add(new CodePrimitiveExpression(size));
        methodInvoke.Parameters.Add(new CodePrimitiveExpression(fAsciiOnly));
        methodStatements.Add(call);
    }

    /// <include file='doc\TemplateControlCompiler.uex' path='docs/doc[@for="TemplateControlCompiler.AddOutputWriteStatement"]/*' />
    /// <devdoc>
    ///     Append an output.Write() statement to a Render method
    /// </devdoc>
    void AddOutputWriteStatement(CodeStatementCollection methodStatements, 
                                 CodeExpression expr,
                                 CodeLinePragma linePragma) {

        CodeMethodInvokeExpression methodInvoke = new CodeMethodInvokeExpression();
        CodeExpressionStatement call = new CodeExpressionStatement(methodInvoke);            
        methodInvoke.Method.TargetObject = new CodeArgumentReferenceExpression(renderMethodParameterName);
        methodInvoke.Method.MethodName = "Write";
        if (linePragma != null)
            call.LinePragma = linePragma;

        methodInvoke.Parameters.Add(expr);
        methodStatements.Add(call);
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\authorizationconfig.cs ===
//------------------------------------------------------------------------------
// <copyright file="AuthorizationConfig.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * AuthorizationConfigHandler class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Configuration {
    using System.Runtime.Serialization;
    using System.Web.Util;
    using System.Collections;
    using System.IO;
    using System.Security.Principal;
    using System.Xml;
    using System.Security.Cryptography;
    using System.Configuration;
    using System.Globalization;
    

    internal class AuthorizationConfigHandler : IConfigurationSectionHandler {
        internal AuthorizationConfigHandler() {
        }

        public virtual object Create(Object parent, Object configContextObj, XmlNode section) {
            // if called through client config don't even load HttpRuntime
            if (!HandlerBase.IsServerConfiguration(configContextObj))
                return null;
            
            return new AuthorizationConfig((AuthorizationConfig) parent, section);
        }
    }

    internal class AuthorizationConfig {
        private                  ArrayList  _AllRules;
        private  const String     _strAllowTag     = "allow";
        private  const String     _strDenyTag      = "deny";
        private  const String     _strRolesTag     = "roles";
        private  const String     _strVerbTag      = "verbs";
        private  const String     _strUsersTag     = "users";
        static private  readonly char[]     _strComma        = new char[] {','};

        //////////////////////////////////////////////////////////////////////
        // CTor
        internal AuthorizationConfig(AuthorizationConfig parent, XmlNode node) {
            Debug.Trace("security", "AuthorizationConfigSettings ctor");            
            if (parent != null)
                _AllRules = (ArrayList) parent._AllRules.Clone();
            else
                _AllRules = new ArrayList();
            HandlerBase.CheckForUnrecognizedAttributes(node);
            ArrayList rules = new ArrayList();

            foreach (XmlNode child in node.ChildNodes) {
                ////////////////////////////////////////////////////////////
                // Step 1: For each child (Allow / Deny Tag)
                if (child.NodeType != XmlNodeType.Element)
                    continue;

                bool      allow         = false;
                bool      fRolesPresent = false;
                bool      fUsersPresent = false;
                String [] verbs         = null;
                String [] users         = null;
                String [] roles         = null;
                String [] temp          = null;
                XmlNode attribute;

                ////////////////////////////////////////////////////////////
                // Step 3: Make sure we have an allow or deny tag
                allow = (child.Name == _strAllowTag);
                if (allow == false && (child.Name == _strDenyTag) == false) {
                    throw new ConfigurationException(
                                                    HttpRuntime.FormatResourceString(SR.Auth_rule_must_have_allow_or_deny),
                                                    child);
                }


                ////////////////////////////////////////////////////////////
                // Step 4: Get the list of verbs
                attribute = child.Attributes.RemoveNamedItem(_strVerbTag);
                if (attribute != null) {
                    temp = attribute.Value.ToLower(CultureInfo.InvariantCulture).Split(_strComma);
                    verbs = TrimStrings(temp);
                }

                ////////////////////////////////////////////////////////////
                // Step 5: Get the list of users
                attribute = child.Attributes.RemoveNamedItem(_strUsersTag);

                if (attribute != null && attribute.Value.Length > 0) {
                    ////////////////////////////////////////////////////////////
                    // Step 5a: If the users tag is present and not empty, then
                    //          construct an array of user names (string array)
                    fUsersPresent = true;
                    temp  = attribute.Value.ToLower(CultureInfo.InvariantCulture).Split(_strComma);
                    users = TrimStrings(temp);


                    ////////////////////////////////////////////////////////////
                    // Step 5b: Make sure that no user name has the char ? or *
                    //          embeded in it
                    if (users != null && users.Length > 0) {
                        // For each user name
                        int iNumUsers = users.Length;
                        for (int iter=0; iter<iNumUsers; iter++) {
                            if (users[iter].Length > 1) { // If length is > 1
                                if (users[iter].IndexOf('*') >= 0) // Contains '*'
                                    throw new ConfigurationException(HttpRuntime.FormatResourceString(SR.Auth_rule_names_cant_contain_char, "*"), 
                                                                     attribute);

                                if (users[iter].IndexOf('?') >= 0)  // Contains '?'
                                    throw new ConfigurationException(HttpRuntime.FormatResourceString(SR.Auth_rule_names_cant_contain_char, "?"), 
                                                                     attribute);
                            }
                        }
                    }
                }

                ////////////////////////////////////////////////////////////
                // Step 6: Get the list of roles
                attribute = child.Attributes.RemoveNamedItem(_strRolesTag);
                if (attribute != null && attribute.Value.Length > 0) {
                    ////////////////////////////////////////////////////////////
                    // Step 6a: If the roles tag is present and not empty, then
                    //          construct an array of role names (string array)
                    fRolesPresent = true;
                    temp  = attribute.Value.Split(_strComma);
                    roles = TrimStrings(temp);

                    ////////////////////////////////////////////////////////////
                    // Step 6b: Make sure that no user name has the char ? or *
                    //          embeded in it
                    if (roles != null && roles.Length > 0) {
                        // For each role name
                        int iNumRoles = roles.Length;

                        for (int iter=0; iter<iNumRoles; iter++) {
                            if (roles[iter].Length > 0) {  // If length is > 1
                                int foundIndex = roles[iter].IndexOfAny(new char [] {'*', '?'});
                                if (foundIndex >= 0) {
                                    throw new ConfigurationException(
                                                    HttpRuntime.FormatResourceString(SR.Auth_rule_names_cant_contain_char, roles[iter][foundIndex].ToString()), 
                                                    attribute);
                                }
                            }
                        }
                    }
                }


                ////////////////////////////////////////////////////////////
                // Step 7: Make sure that either the "roles" tag or the "users"
                //         tag was present
                if (!fRolesPresent && !fUsersPresent) {
                    throw new ConfigurationException(
                                    HttpRuntime.FormatResourceString(SR.Auth_rule_must_specify_users_andor_roles),
                                    child);
                }

                ////////////////////////////////////////////////////////////
                // Step 8: Make sure that there were no unrecognized properties
                HandlerBase.CheckForUnrecognizedAttributes(child);

                ////////////////////////////////////////////////////////////
                // Step 8b: Move back to the current auth rule node
                // ctracy 00.09.26: no longer necessary after migration to .NET XML DOM
                //cursor.MoveToParent(); 

                ////////////////////////////////////////////////////////////
                // Step 9: Add the rule to our list
                rules.Add(new AuthorizationConfigRule(allow, verbs, users, roles));
            }

            _AllRules.InsertRange(0, rules);
            Debug.Trace("security", "AuthorizationConfigSettings:: ReadSettings counts:" + _AllRules.Count + " rules " + rules.Count);
        }



        //////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////
        // METHOD TO DETERMINE IF a purticular user is allowed or not
        internal bool IsUserAllowed(IPrincipal user, String verb) {
            if (user == null)
                return false;


            Debug.Trace("security", "AuthorizationConfigSettings::IsUserAllowed " + user.Identity.Name + user.Identity.IsAuthenticated);

            // Go down the list permissions and check each one
            int iCount = _AllRules.Count;
            Debug.Trace("security", "AuthorizationConfigSettings::IsUserAllowed iCout " + iCount);
            for (int iter=0; iter<iCount; iter++) {
                int iResult = ((AuthorizationConfigRule) _AllRules[iter]).IsUserAllowed(user, verb);
                if (iResult != 0) {
                    Debug.Trace("security", "AuthorizationConfigSettings::IsUserAllowed " + iResult);
                    return(iResult > 0);
                }
            }
            return false;
        }

        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        // Trim every string in the array
        private String [] TrimStrings(String [] strIn) {
            if (strIn == null || strIn.Length < 1)
                return null;

            String [] strOut = new String[strIn.Length];

            for (int iter=0; iter<strIn.Length; iter++)
                strOut[iter] = strIn[iter].Trim();

            return strOut;
        }
    }

    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////

    internal class AuthorizationConfigRule {
        private  const String     _strAnonUserTag  = "?";
        private  const String     _strAllUsersTag  = "*";

        private bool        Allow;
        private String []  Verbs;
        private String []  Roles;
        private String []  Users;

        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        internal AuthorizationConfigRule(bool allow, 
                                         String [] verbs, 
                                         String [] users, 
                                         String [] roles) {
            Allow = allow;
            Verbs = verbs;
            Users = users;
            Roles = roles;
        }

        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        // 0 => Don't know, 1 => Yes, -1 => No
        internal int IsUserAllowed(IPrincipal user, String verb) {
            int iAllow = 0;

            if (FindVerb(verb) == false)
                goto Cleanup;

            bool fIsAnonymous = (user.Identity.IsAuthenticated == false);
            if (FindUser(user.Identity.Name, fIsAnonymous) == true) { // Check if the user is specified
                iAllow = (Allow ? 1 : -1);
                goto Cleanup;
            }

            if (Roles != null) {
                // Check if the user is in any of the spcified Roles
                for (int iter=0; iter<Roles.Length; iter++)
                    if (user.IsInRole(Roles[iter])) {
                        iAllow = (Allow ? 1 : -1);
                        goto Cleanup;
                    }
            }

            Cleanup:
            return iAllow;
        }

        /////////////////////////////////////////////////////////////////////////
        private bool FindVerb(String verb) {
            if (Verbs == null || Verbs.Length == 0)
                return true;

            String strVerb = verb.ToLower(CultureInfo.InvariantCulture);

            for (int iter=0; iter<Verbs.Length; iter++)
                if (Verbs[iter].Equals(strVerb))
                    return true;

            return false;
        }


        /////////////////////////////////////////////////////////////////////////
        private bool FindUser(String user, bool fIsAnonymous) {
            if (Users == null || Users.Length == 0)
                return false;

            String strUser = user.ToLower(CultureInfo.InvariantCulture);
            for (int iter=0; iter<Users.Length; iter++) {
                if (fIsAnonymous == false && Users[iter].Equals(strUser))
                    return true;

                if (Users[iter].Equals(_strAllUsersTag))
                    return true;

                if (fIsAnonymous && Users[iter].Equals(_strAnonUserTag))
                    return true;
            }
            return false;
        }
    }

    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    internal class UrlAuthFailedErrorFormatter : ErrorFormatter {
        private static string _strErrorTextLocal;
        private static object _syncObjectLocal   = new object();
        private static string _strErrorTextRemote;
        private static object _syncObjectRemote  = new object();

        internal UrlAuthFailedErrorFormatter() {
        }

        internal /*public*/ static string GetErrorText() {
            HttpContext context = HttpContext.Current;
            if (CustomErrors.GetSettings(context).CustomErrorsEnabled(context.Request)) {
                if (_strErrorTextRemote != null)
                    return _strErrorTextRemote;
                
                lock(_syncObjectRemote) {
                    if (_strErrorTextRemote == null)
                        _strErrorTextRemote = (new UrlAuthFailedErrorFormatter()).GetHtmlErrorMessage(true);
                }

                return _strErrorTextRemote;          
            } 


            if (_strErrorTextLocal != null)
                return _strErrorTextLocal;
            
            lock(_syncObjectLocal) {
                if (_strErrorTextLocal == null)
                    _strErrorTextLocal = (new UrlAuthFailedErrorFormatter()).GetHtmlErrorMessage(false);
            }
            return _strErrorTextLocal;
        }

        protected override string ErrorTitle {
            get { return HttpRuntime.FormatResourceString(SR.Assess_Denied_Title);}
            // "Access Denied
        }

        protected override string Description {
            get {
                return HttpRuntime.FormatResourceString(SR.Assess_Denied_Description2); 
                //"An error occurred while accessing the resources required to serve this request. &nbsp; This typically happens when the web server is not configured to give you access to the requested URL.";
            }
        }

        protected override string MiscSectionTitle {
            get { 
                return HttpRuntime.FormatResourceString(SR.Assess_Denied_Section_Title2); 
                //return "Error message 401.2";
            }
        }

        protected override string MiscSectionContent {
            get {
                return HttpRuntime.FormatResourceString(SR.Assess_Denied_Misc_Content2);
                //return "Access denied due to the web server's configuration. Ask the web server's administrator for help.";
            }
        }

        protected override string ColoredSquareTitle {
            get { return null;}
        }

        protected override string ColoredSquareContent {
            get { return null;}
        }

        protected override bool ShowSourceFileInfo {
            get { return false;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\authenticationconfig.cs ===
//------------------------------------------------------------------------------
// <copyright file="AuthenticationConfig.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * AuthenticationConfigHandler class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Configuration {
    using System.Runtime.Serialization;
    using System.Web.Util;
    using System.Collections;
    using System.IO;
    using System.Security.Principal;
    using System.Xml;
    using System.Security.Cryptography;
    using System.Configuration;
    using System.Globalization;
    

    internal class AuthenticationConfigHandler : IConfigurationSectionHandler {
        internal AuthenticationConfigHandler(){
        }

        public virtual object Create(Object parent, Object configContextObj, XmlNode section) {

            // if called through client config don't even load HttpRuntime
            if (!HandlerBase.IsServerConfiguration(configContextObj))
                return null;
            
            HttpConfigurationContext configContext = configContextObj as HttpConfigurationContext;
            if (HandlerBase.IsPathAtAppLevel(configContext.VirtualPath) == PathLevel.BelowApp)
                throw new ConfigurationException(
                        HttpRuntime.FormatResourceString(SR.Cannot_specify_below_app_level, "Authentication"),
                        section);
            
            return new AuthenticationConfig((AuthenticationConfig) parent, section);
        }
    }

    /// <include file='doc\AuthenticationConfig.uex' path='docs/doc[@for="AuthenticationMode"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum AuthenticationMode {
        /// <include file='doc\AuthenticationConfig.uex' path='docs/doc[@for="AuthenticationMode.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None,
        /// <include file='doc\AuthenticationConfig.uex' path='docs/doc[@for="AuthenticationMode.Windows"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Windows,
        /// <include file='doc\AuthenticationConfig.uex' path='docs/doc[@for="AuthenticationMode.Passport"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Passport,
        /// <include file='doc\AuthenticationConfig.uex' path='docs/doc[@for="AuthenticationMode.Forms"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Forms
    }
    /// <include file='doc\AuthenticationConfig.uex' path='docs/doc[@for="FormsAuthPasswordFormat"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum FormsAuthPasswordFormat {
        /// <include file='doc\AuthenticationConfig.uex' path='docs/doc[@for="FormsAuthPasswordFormat.Clear"]/*' />
        Clear, 
        /// <include file='doc\AuthenticationConfig.uex' path='docs/doc[@for="FormsAuthPasswordFormat.SHA1"]/*' />
        SHA1, 
        /// <include file='doc\AuthenticationConfig.uex' path='docs/doc[@for="FormsAuthPasswordFormat.MD5"]/*' />
        MD5
    }

    /// <include file='doc\AuthenticationConfig.uex' path='docs/doc[@for="FormsProtectionEnum"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum FormsProtectionEnum {
        /// <include file='doc\AuthenticationConfig.uex' path='docs/doc[@for="FormsProtectionEnum.All"]/*' />
        All, 
        /// <include file='doc\AuthenticationConfig.uex' path='docs/doc[@for="FormsProtectionEnum.None"]/*' />
        None, 
        /// <include file='doc\AuthenticationConfig.uex' path='docs/doc[@for="FormsProtectionEnum.Encryption"]/*' />
        Encryption, 
        /// <include file='doc\AuthenticationConfig.uex' path='docs/doc[@for="FormsProtectionEnum.Validation"]/*' />
        Validation
    }

    internal class AuthenticationConfig {
        internal   AuthenticationMode       Mode             { get { return _Mode; }}
        internal   String                   CookieName       { get { return _CookieName; }}
        internal   String                   LoginUrl         { get { return _LoginUrl; }}
        internal   FormsAuthPasswordFormat  PasswordFormat   { get { return _PasswordFormat;}}
        internal   Hashtable                Credentials      { get { return _Credentials;}}
        internal   String                   PassportUrl      { get { return _PassportUrl; }}
        internal   FormsProtectionEnum      Protection       { get { return _Protection; }}
        internal   Int32                    Timeout          { get { return _Timeout; }}
        internal   String                   FormsCookiePath  { get { return _FormsCookiePath; }}
        internal   bool                     RequireSSL       { get { return _RequireSSL; }}
        internal   bool                     SlidingExpiration       { get { return _SlidingExpiration; }}

        private   AuthenticationMode       _Mode             = AuthenticationMode.Windows;
        private   String                   _CookieName       = ".ASPXAUTH";
        private   String                   _LoginUrl         = "login.aspx";
        private   FormsAuthPasswordFormat  _PasswordFormat   = FormsAuthPasswordFormat.SHA1;
        private   Hashtable                _Credentials;
        private   String                   _PassportUrl      = "internal";
        private   FormsProtectionEnum      _Protection       = FormsProtectionEnum.All;
        private   String                   _FormsCookiePath  = "/";
        internal  Int32                    _Timeout          = 30;
        private   bool                     _RequireSSL       = true;
        private   bool                     _SlidingExpiration       = true;

        internal AuthenticationConfig(AuthenticationConfig parent, XmlNode section) {
            if (parent != null) {
                _CookieName = parent.CookieName;
                _LoginUrl = parent.LoginUrl;
                _PasswordFormat = parent.PasswordFormat;
                _Credentials = (Hashtable) parent.Credentials.Clone();
                _Mode = parent.Mode;
                _PassportUrl = parent.PassportUrl;
                _Protection = parent.Protection;
                _FormsCookiePath = parent.FormsCookiePath;
                _Timeout = parent.Timeout;
                _RequireSSL = parent.RequireSSL;
                _SlidingExpiration = parent.SlidingExpiration;
            }
            else {
                _Credentials = new Hashtable();
            }

            ////////////////////////////////////////////////////////////
            // Step 1: Read the mode
            int iMode = 0;
            XmlNode attribute = HandlerBase.GetAndRemoveEnumAttribute(section, "mode", typeof(AuthenticationMode), ref iMode);
            if (attribute != null) {
                _Mode = (AuthenticationMode)iMode;
                if (_Mode == AuthenticationMode.Passport && UnsafeNativeMethods.PassportVersion() < 0)
                    throw new ConfigurationException(
                            HttpRuntime.FormatResourceString(SR.Passport_not_installed),
                            attribute);                                
            }
            HandlerBase.CheckForUnrecognizedAttributes(section);

            ////////////////////////////////////////////////////////////
            // Step 2: Read children nodes
            foreach (XmlNode child in section.ChildNodes) {

                if (child.NodeType != XmlNodeType.Element)
                    continue;
                
                if (child.Name == "forms") {
                    ReadFormsSettings(child);
                }
                else if (child.Name == "passport") {
                    attribute = child.Attributes.RemoveNamedItem("redirectUrl");
                    if (attribute != null) {
                        _PassportUrl = attribute.Value;
                        if (_PassportUrl.StartsWith("\\\\") || (_PassportUrl.Length > 1 && _PassportUrl[1] == ':')) {
                            throw new ConfigurationException(
                                    HttpRuntime.FormatResourceString(SR.Auth_bad_url),
                                    attribute);
                        }
                    }

                    HandlerBase.CheckForUnrecognizedAttributes(child);
                    HandlerBase.CheckForChildNodes(child);                    
                }
                else {
                    throw new ConfigurationException(
                            HttpRuntime.FormatResourceString(SR.Auth_unrecognized_tag, child.Name),
                            child);
                }
            
            }
        }
            
        internal static String GetCompleteLoginUrl(HttpContext context, String loginUrl) {
            if (loginUrl == null || loginUrl.Length == 0)
                return String.Empty;

            if (UrlPath.IsRelativeUrl(loginUrl))
                loginUrl = UrlPath.Combine(context.Request.ApplicationPath, loginUrl);

            return loginUrl;
        }

        internal static bool AccessingLoginPage(HttpContext context, String loginUrl) {
            if (loginUrl == null || loginUrl.Length == 0)
                return false;

            loginUrl = GetCompleteLoginUrl(context, loginUrl);
            if (loginUrl == null || loginUrl.Length == 0)
                return false;

            // Ignore query string
            int iqs = loginUrl.IndexOf('?');
            if (iqs >= 0)
                loginUrl = loginUrl.Substring(0, iqs);

            String requestPath = context.Request.Path;

            if (String.Compare(requestPath, loginUrl, true, CultureInfo.InvariantCulture) == 0)
                return true;

            // It could be that loginUrl in config was UrlEncoded (ASURT 98932)
            if (loginUrl.IndexOf('%') >= 0) {
                String decodedLoginUrl;
                // encoding is unknown try UTF-8 first, then request encoding

                decodedLoginUrl = HttpUtility.UrlDecode(loginUrl);
                if (String.Compare(requestPath, decodedLoginUrl, true, CultureInfo.InvariantCulture) == 0)
                    return true;

                decodedLoginUrl =  HttpUtility.UrlDecode(loginUrl, context.Request.ContentEncoding);
                if (String.Compare(requestPath, decodedLoginUrl, true, CultureInfo.InvariantCulture) == 0)
                    return true;
            }

            return false;
        }

        private void ReadFormsSettings(XmlNode node) {
            XmlNode tempAttr = HandlerBase.GetAndRemoveNonEmptyStringAttribute(node, "name", ref _CookieName);

            //Trace("FormsAuthConfigSettings::ReadSettings cookie name " + _CookieName);

            tempAttr = HandlerBase.GetAndRemoveNonEmptyStringAttribute(node, "loginUrl", ref _LoginUrl);
            if (tempAttr != null) {
                if (_LoginUrl.StartsWith("\\\\") || (_LoginUrl.Length > 1 && _LoginUrl[1] == ':')) {
                    throw new ConfigurationException(
                            HttpRuntime.FormatResourceString(SR.Auth_bad_url),
                            tempAttr);
                }
            }
            //Trace("FormsAuthConfigSettings::ReadSettings login url " + _LoginUrl);

            int iTemp = 0;
            tempAttr = HandlerBase.GetAndRemoveEnumAttribute(node, "protection", typeof(FormsProtectionEnum), ref iTemp);
            if (tempAttr != null) {
                _Protection = (FormsProtectionEnum)iTemp;
            }

            tempAttr = HandlerBase.GetAndRemovePositiveIntegerAttribute(node, "timeout", ref _Timeout);
            tempAttr = HandlerBase.GetAndRemoveNonEmptyStringAttribute(node, "path", ref _FormsCookiePath);
            HandlerBase.GetAndRemoveBooleanAttribute(node, "requireSSL", ref _RequireSSL);
            HandlerBase.GetAndRemoveBooleanAttribute(node, "slidingExpiration", ref _SlidingExpiration);
            HandlerBase.CheckForUnrecognizedAttributes(node);

            foreach (XmlNode child in node.ChildNodes) {
                if (child.NodeType != XmlNodeType.Element)
                    continue;

                if (child.Name != "credentials") {
                    HandlerBase.ThrowUnrecognizedElement(child);
                }

                tempAttr = HandlerBase.GetAndRemoveEnumAttribute(child, "passwordFormat", typeof(FormsAuthPasswordFormat), ref iTemp);
                if (tempAttr != null) {
                    _PasswordFormat = (FormsAuthPasswordFormat)iTemp;
                    //Trace("FormsAuthConfigSettings::ReadSettings password format " + strTemp);
                }
                
                HandlerBase.CheckForUnrecognizedAttributes(child);

                foreach (XmlNode child2 in child.ChildNodes) {
                    if (child2.NodeType != XmlNodeType.Element)
                        continue;

                    if (child2.Name != "user") {
                        HandlerBase.ThrowUnrecognizedElement(child2);
                    }

                    string strUser = null;
                    string strPass = null;
                    tempAttr = HandlerBase.GetAndRemoveRequiredStringAttribute(child2, "name", ref strUser);
                    HandlerBase.GetAndRemoveRequiredStringAttribute(child2, "password", ref strPass);
                    HandlerBase.CheckForUnrecognizedAttributes(child2);
                    HandlerBase.CheckForChildNodes(child2);                    

                    //Trace("FormsAuthConfigSettings::ReadSettings adding user " + strUser + " " + strPass);
                    strUser = strUser.ToLower(CultureInfo.InvariantCulture);
                    String strPassInTable = (String) _Credentials[strUser];
                    if (strPassInTable == null)
                        _Credentials.Add(strUser, strPass);
                    else {
                        if (String.Compare(strPassInTable, strPass, false, CultureInfo.InvariantCulture) != 0) {
                            throw new ConfigurationException(
                                    HttpRuntime.FormatResourceString(SR.User_Already_Specified, strUser), tempAttr);
                        }
                    } 
                } 
                
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\globalizationconfigurationhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="GlobalizationConfigurationHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Config related classes for HttpApplication
 */

namespace System.Web.Configuration {

    using System.Collections;
    using System.Configuration;
    using System.Globalization;
    using System.IO;
    using System.Text;
    using System.Web.Util;
    using System.Xml;

    /*
     * Globalization config object
     */

    internal class GlobalizationConfig {
        private CultureInfo _culture;
        private CultureInfo _uiCulture;
        private Encoding _fileEncoding;
        private Encoding _requestEncoding;
        private Encoding _responseEncoding;

        internal GlobalizationConfig(GlobalizationConfig parent) {
            if (parent != null) {
                _culture            = parent._culture;
                _uiCulture          = parent._uiCulture;
                _fileEncoding       = parent._fileEncoding;
                _requestEncoding    = parent._requestEncoding;
                _responseEncoding   = parent._responseEncoding;
            }
        }

        internal CultureInfo Culture {
            get { return _culture; }
        }

        internal CultureInfo UICulture {
            get { return _uiCulture; }
        }

        internal Encoding FileEncoding {
            get { return (_fileEncoding != null) ? _fileEncoding : Encoding.Default; }
        }

        internal Encoding RequestEncoding {
            get { return (_requestEncoding != null) ? _requestEncoding : Encoding.Default; }
        }

        internal Encoding ResponseEncoding {
            get { return (_responseEncoding != null) ? _responseEncoding : Encoding.Default; }
        }

        internal void LoadValuesFromConfigurationXml(XmlNode node) {

            // DO NOT SILENTLY IGNORE BOGUS XML IN THE SECTION!
            HandlerBase.CheckForChildNodes(node);

            foreach (XmlAttribute attribute in node.Attributes) {
                String name = attribute.Name;
                String text = attribute.Value;

                try {
                    if (name == "culture") {
                        if (text.Length == 0)
                            throw new ArgumentException();  // don't allow empty culture string

                        _culture = HttpServerUtility.CreateReadOnlyCultureInfo(text);
                    }
                    else if (name == "uiCulture") {
                        if (text.Length == 0)
                            throw new ArgumentException();  // don't allow empty culture string

                        _uiCulture = HttpServerUtility.CreateReadOnlyCultureInfo(text);
                    }
                    else if (name == "fileEncoding") {
                        _fileEncoding = Encoding.GetEncoding(text);
                    }
                    else if (name == "requestEncoding") {
                        _requestEncoding = Encoding.GetEncoding(text);
                    }
                    else if (name == "responseEncoding") {
                        _responseEncoding = Encoding.GetEncoding(text);
                    }
                    else {
                        throw new ConfigurationException(
                                    HttpRuntime.FormatResourceString(SR.Unknown_globalization_attr, name),
                                    attribute);
                    }
                }
                catch (ConfigurationException) {
                    throw;
                }
                catch (Exception e) {
                    throw new ConfigurationException(
                                HttpRuntime.FormatResourceString(SR.Invalid_value_for_globalization_attr, name),
                                e, attribute);
                }
            }
        }
    }

    /*
     * Config factory for globalization
     *
     * syntax:
     *
     *   <globalization
     *          culture="..."
     *          uiculture="..."
     *          fileencoding="..."
     *          requestEncoding="..."
     *          responseEncoding="..."
     *   />
     *
     * output:
     */
    /// <include file='doc\GlobalizationConfigurationHandler.uex' path='docs/doc[@for="GlobalizationConfigurationHandler"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    internal class GlobalizationConfigurationHandler : IConfigurationSectionHandler {

        internal GlobalizationConfigurationHandler() {
        }

        public virtual object Create(Object parent, Object configContextObj, XmlNode section) {
            // if called through client config don't even load HttpRuntime
            if (!HandlerBase.IsServerConfiguration(configContextObj))
                return null;
            
            GlobalizationConfig config = new GlobalizationConfig((GlobalizationConfig)parent);
            config.LoadValuesFromConfigurationXml(section);

            return config;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\clienttargetsectionhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ClientTargetSectionHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Configuration {
    using System.Collections;
    using System.Collections.Specialized;
    using System.Configuration;
    using System.Xml;

    // Config handler for the clienttarget section
    //    <clientTarget>
    //        <add alias="ie5" useragent="Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 4.0)" />
    //        <add alias="ie4" useragent="Mozilla/4.0 (compatible; MSIE 4.0; Windows NT 4.0)" />
    //        <add alias="uplevel" useragent="Mozilla/4.0 (compatible; MSIE 4.0; Windows NT 4.0)" />
    //        <add alias="downlevel" useragent="Unknown" />
    //    </clientTarget>
    /// <internalonly />
    /// <devdoc>
    /// </devdoc>
    sealed class ClientTargetSectionHandler : IConfigurationSectionHandler {

        internal ClientTargetSectionHandler() {
        }

        public object Create(object parent, object configContextObj, XmlNode section) {

            // if called through client config don't even load HttpRuntime
            if (!HandlerBase.IsServerConfiguration(configContextObj))
                return null;

            // unwrap the parent object
            NameValueCollection nvcParent = null;
            if (parent != null) {
                nvcParent = ((ClientTargetConfiguration)parent).Configuration;
            }

            // deleage the real work to NameValueSectionHandler
            ClientTargetNameValueHandler nvcHandler = new ClientTargetNameValueHandler();
            NameValueCollection nvcResult = (NameValueCollection)nvcHandler.Create(nvcParent, configContextObj, section);

            if (nvcResult == null) 
                return null;

            //
            // Return config data wrapped in an internal class, so 
            // semi-trusted code cannot leak configuration data.
            //
            ClientTargetConfiguration clientTargetResult = new ClientTargetConfiguration();
            clientTargetResult.Configuration = nvcResult;

            return clientTargetResult;
        }    
        
    }

    sealed class ClientTargetNameValueHandler : NameValueSectionHandler {
        internal ClientTargetNameValueHandler() {
        }
        /// <internalonly />
        /// <devdoc>
        /// </devdoc>
        protected override string KeyAttributeName 
        {
            get { return "alias";}
        }

        /// <internalonly />
        /// <devdoc>
        /// </devdoc>
        protected override string ValueAttributeName 
        {
            get { return "userAgent";}
        }
    }    
        

    //
    // Configuration Data Class 
    //
    // Note: config data cannot be public, see ASURT 113743
    //
    sealed class ClientTargetConfiguration {
        NameValueCollection _nvc;

        internal ClientTargetConfiguration() {
        }

        internal NameValueCollection Configuration {
            get {
                return _nvc;
            }
            set {
                _nvc = value;
            }
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\contextlessmappath.cs ===
//------------------------------------------------------------------------------
// <copyright file="ContextlessMapPath.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * config system: finds config files, loads config
 * factories, filters out relevant config file sections, and
 * feeds them to the factories to create config objects.
 */
namespace System.Web.Configuration {
    using Microsoft.Win32;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Configuration;
    using System.IO;
    using System.Threading;
    using System.Web.Caching;
    using System.Xml;
    using System.Web.Util;
    using CultureInfo = System.Globalization.CultureInfo;
    using Debug = System.Web.Util.Debug;
    using UrlPath = System.Web.Util.UrlPath;

    internal class ContextlessMapPath : IHttpMapPath {

        NameValueCollection map = new NameValueCollection();
        string machineConfigPath;
        string applicationPath;

        internal ContextlessMapPath() {
        }

        string IHttpMapPath.MapPath(string path) {
            return map[path];
        }

        string IHttpMapPath.MachineConfigPath { 
            get {
                return machineConfigPath;
            }
        }

        internal void SetMachineConfigPath(string value) {
            machineConfigPath = value;
        }

        internal void Add(string path, string mappedPath) {
            map.Add(path, mappedPath);
        }

        internal string ApplicationPath {
            get {
                return applicationPath;
            }
            set {
                applicationPath = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\handlerfactorycache.cs ===
//------------------------------------------------------------------------------
// <copyright file="HandlerFactoryCache.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Config related classes for HttpApplication
 */

namespace System.Web.Configuration {

    using System;

    /*
     * An object to cache a factory
     */
    internal class HandlerFactoryCache {
        private IHttpHandlerFactory _factory;

        internal HandlerFactoryCache(HandlerMapping mapping) {
            Object instance = mapping.Create();

            // make sure it is either handler or handler factory

            if (instance is IHttpHandler) {
                // create bogus factory around it
                _factory = new HandlerFactoryWrapper((IHttpHandler)instance, mapping.Type);
            }
            else if (instance is IHttpHandlerFactory) {
                _factory = (IHttpHandlerFactory)instance;
            }
            else {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Type_not_factory_or_handler, instance.GetType().FullName));
            }
        }

        internal IHttpHandlerFactory Factory {
            get {
                return _factory;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\handlerfactorywrapper.cs ===
//------------------------------------------------------------------------------
// <copyright file="HandlerFactoryWrapper.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Config related classes for HttpApplication
 */

namespace System.Web.Configuration {

    using System;
    using System.Web.Util;

    /*
     * Single instance handler factory
     */
    internal class HandlerFactoryWrapper : IHttpHandlerFactory {
        private IHttpHandler _handler;
        private Type _handlerType;

        internal HandlerFactoryWrapper(IHttpHandler handler, Type handlerType) {
            _handler = handler;
            _handlerType = handlerType;
        }

        public IHttpHandler GetHandler(HttpContext context, String requestType, String url, String pathTranslated) {
            if (_handler == null)
                _handler = (IHttpHandler)HttpRuntime.CreateNonPublicInstance(_handlerType);

            return _handler;
        }

        public void ReleaseHandler(IHttpHandler handler) {
            Debug.Assert(handler == _handler);

            if (!_handler.IsReusable)
                _handler = null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\handlermappingmemo.cs ===
//------------------------------------------------------------------------------
// <copyright file="HandlerMappingMemo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Config related classes for HttpApplication
 */

namespace System.Web.Configuration {

    using System;

    internal class HandlerMappingMemo {
        internal HandlerMappingMemo(HandlerMapping mapping, String verb) {
            _mapping = mapping;
            _verb = verb;
        }

        private HandlerMapping _mapping;
        private String _verb;

        internal /*public*/ bool IsMatch(String verb) {
            return _verb.Equals(verb);
        }

        internal /*public*/ HandlerMapping Mapping {
            get {
                return _mapping;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\handlerwithfactory.cs ===
//------------------------------------------------------------------------------
// <copyright file="HandlerWithFactory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Config related classes for HttpApplication
 */

namespace System.Web.Configuration {

    using System;

    /*
     * Factory / handler pair for recycling
     */
    internal class HandlerWithFactory {
        private IHttpHandler _handler;
        private IHttpHandlerFactory _factory;

        internal HandlerWithFactory(IHttpHandler handler, IHttpHandlerFactory factory) {
            _handler = handler;
            _factory = factory;
        }

        internal void Recycle() {
            _factory.ReleaseHandler(_handler);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\handlerbase.cs ===
//------------------------------------------------------------------------------
// <copyright file="HandlerBase.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * HandlerBase contains static helper functions for consistent XML parsing 
 * behavior and error messages.
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web.Configuration {

    using System.Collections;
    using System.Configuration;
    using System.Globalization;
    using System.Text;
    using System.Web.Util;
    using System.Xml;


    internal class HandlerBase {


        internal HandlerBase() {
        }

        //
        // XML Attribute Helpers
        //

        private static XmlNode GetAndRemoveAttribute(XmlNode node, string attrib, bool fRequired) {
            XmlNode a = node.Attributes.RemoveNamedItem(attrib);

            // If the attribute is required and was not present, throw
            if (fRequired && a == null) {
                throw new ConfigurationException(
                    HttpRuntime.FormatResourceString(SR.Missing_required_attribute, attrib, node.Name),
                    node);
            }

            return a;
        }

        private static XmlNode GetAndRemoveStringAttributeInternal(XmlNode node, string attrib, bool fRequired, ref string val) {
            XmlNode a = GetAndRemoveAttribute(node, attrib, fRequired);
            if (a != null)
                val = a.Value;

            return a;
        }

        internal static XmlNode GetAndRemoveStringAttribute(XmlNode node, string attrib, ref string val) {
            return GetAndRemoveStringAttributeInternal(node, attrib, false /*fRequired*/, ref val);
        }

        internal static XmlNode GetAndRemoveRequiredStringAttribute(XmlNode node, string attrib, ref string val) {
            return GetAndRemoveStringAttributeInternal(node, attrib, true /*fRequired*/, ref val);
        }

        internal static XmlNode GetAndRemoveNonEmptyStringAttribute(XmlNode node, string attrib, ref string val) {
            return GetAndRemoveNonEmptyStringAttributeInternal(node, attrib, false /*fRequired*/, ref val);
        }

        internal static XmlNode GetAndRemoveRequiredNonEmptyStringAttribute(XmlNode node, string attrib, ref string val) {
            return GetAndRemoveNonEmptyStringAttributeInternal(node, attrib, true /*fRequired*/, ref val);
        }

        private static XmlNode GetAndRemoveNonEmptyStringAttributeInternal(XmlNode node, string attrib, bool fRequired, ref string val) {
            XmlNode a = GetAndRemoveStringAttributeInternal(node, attrib, fRequired, ref val);
            if (a != null && val.Length == 0) {
                throw new ConfigurationException(
                    HttpRuntime.FormatResourceString(SR.Empty_attribute, attrib),
                    a);
            }

            return a;
        }

        // input.Xml cursor must be at a true/false XML attribute
        private static XmlNode GetAndRemoveBooleanAttributeInternal(XmlNode node, string attrib, bool fRequired, ref bool val) {
            XmlNode a = GetAndRemoveAttribute(node, attrib, fRequired);
            if (a != null) {
                if (a.Value == "true") {
                    val = true;
                }
                else if (a.Value == "false") {
                    val = false;
                }
                else {
                    throw new ConfigurationException(
                                    HttpRuntime.FormatResourceString(SR.Invalid_boolean_attribute, a.Name),
                                    a);
                }
            }

            return a;
        }

        internal static XmlNode GetAndRemoveBooleanAttribute(XmlNode node, string attrib, ref bool val) {
            return GetAndRemoveBooleanAttributeInternal(node, attrib, false /*fRequired*/, ref val);
        }

        internal static XmlNode GetAndRemoveRequiredBooleanAttribute(XmlNode node, string attrib, ref bool val) {
            return GetAndRemoveBooleanAttributeInternal(node, attrib, true /*fRequired*/, ref val);
        }

        private static XmlNode GetAndRemoveIntegerAttributeInternal(XmlNode node, string attrib, bool fRequired, ref int val) {
            XmlNode a = GetAndRemoveAttribute(node, attrib, fRequired);
            if (a != null) {
                if (a.Value.Trim() != a.Value) {
                    throw new ConfigurationException(
                        HttpRuntime.FormatResourceString(SR.Invalid_integer_attribute, a.Name),
                        a);
                }

                try {
                    val = int.Parse(a.Value, CultureInfo.InvariantCulture);
                }
                catch (Exception e) {
                    throw new ConfigurationException(
                        HttpRuntime.FormatResourceString(SR.Invalid_integer_attribute, a.Name),
                        e, a);
                }
            }

            return a;
        }

        internal static XmlNode GetAndRemoveIntegerAttribute(XmlNode node, string attrib, ref int val) {
            return GetAndRemoveIntegerAttributeInternal(node, attrib, false /*fRequired*/, ref val);
        }

        internal static XmlNode GetAndRemoveRequiredIntegerAttribute(XmlNode node, string attrib, ref int val) {
            return GetAndRemoveIntegerAttributeInternal(node, attrib, true /*fRequired*/, ref val);
        }

        private static XmlNode GetAndRemovePositiveAttributeInternal(XmlNode node, string attrib, bool fRequired, ref int val) {
            XmlNode a = GetAndRemoveIntegerAttributeInternal(node, attrib, fRequired, ref val);

            if (a != null && val <= 0) {
                throw new ConfigurationException(
                    HttpRuntime.FormatResourceString(SR.Invalid_positive_integer_attribute, attrib),
                    a);
            }

            return a;
        }

        internal static XmlNode GetAndRemovePositiveIntegerAttribute(XmlNode node, string attrib, ref int val) {
            return GetAndRemovePositiveAttributeInternal(node, attrib, false /*fRequired*/, ref val);
        }

        internal static XmlNode GetAndRemoveRequiredPositiveIntegerAttribute(XmlNode node, string attrib, ref int val) {
            return GetAndRemovePositiveAttributeInternal(node, attrib, true /*fRequired*/, ref val);
        }

        private static XmlNode GetAndRemoveNonNegativeAttributeInternal(XmlNode node, string attrib, bool fRequired, ref int val) {
            XmlNode a = GetAndRemoveIntegerAttributeInternal(node, attrib, fRequired, ref val);

            if (a != null && val < 0) {
                throw new ConfigurationException(
                    HttpRuntime.FormatResourceString(SR.Invalid_nonnegative_integer_attribute, attrib),
                    a);
            }

            return a;
        }

        internal static XmlNode GetAndRemoveNonNegativeIntegerAttribute(XmlNode node, string attrib, ref int val) {
            return GetAndRemoveNonNegativeAttributeInternal(node, attrib, false /*fRequired*/, ref val);
        }

        internal static XmlNode GetAndRemoveRequiredNonNegativeIntegerAttribute(XmlNode node, string attrib, ref int val) {
            return GetAndRemoveNonNegativeAttributeInternal(node, attrib, false /*fRequired*/, ref val);
        }

        private static XmlNode GetAndRemoveTypeAttributeInternal(XmlNode node, string attrib, bool fRequired, ref Type val) {
            XmlNode a = GetAndRemoveAttribute(node, attrib, fRequired);

            if (a != null) {
                try {
                    val = Type.GetType(a.Value, true /*throwOnError*/);
                }
                catch (Exception e) {
                    throw new ConfigurationException(
                        HttpRuntime.FormatResourceString(SR.Invalid_type_attribute, a.Name),
                        e, a);
                }
            }

            return a;
        }

        internal static XmlNode GetAndRemoveTypeAttribute(XmlNode node, string attrib, ref Type val) {
            return GetAndRemoveTypeAttributeInternal(node, attrib, false /*fRequired*/, ref val);
        }

        internal static XmlNode GetAndRemoveRequiredTypeAttribute(XmlNode node, string attrib, ref Type val) {
            return GetAndRemoveTypeAttributeInternal(node, attrib, true /*fRequired*/, ref val);
        }


        private static XmlNode GetAndRemoveEnumAttributeInternal(XmlNode node, string attrib, bool isRequired, Type enumType, ref int val) {
            XmlNode a = GetAndRemoveAttribute(node, attrib, isRequired);
            if (a != null) {
                // case sensitive
                if (Enum.IsDefined(enumType, a.Value)) {
                    val = (int)Enum.Parse(enumType, a.Value);
                }
                else {
                    // if not null and not defined throw error
                    string names = null;
                    foreach (string name in Enum.GetNames(enumType)) {
                        if (names == null)
                            names = name;
                        else
                            names += ", " + name;
                    }

                    throw new ConfigurationException(HttpRuntime.FormatResourceString(SR.Invalid_enum_attribute, attrib, names), a);
                }


                /* case insensitive
                try {
                    val = (int)Enum.Parse(enumType, a.Value, true);
                }
                catch (Exception) {
                    // if not null and not defined throw error
                    string names = null;
                    foreach (string name in Enum.GetNames(enumType)) {
                        if (names == null)
                            names = name;
                        else
                            names += ", " + name;
                    }

                    throw new ConfigurationException(HttpRuntime.FormatResourceString(SR.Invalid_enum_attribute, attrib, names), a);
                }
                */
            }
            return a;
        }

        internal static XmlNode GetAndRemoveEnumAttribute(XmlNode node, string attrib, Type enumType, ref int val) {
            return GetAndRemoveEnumAttributeInternal(node, attrib, false, enumType, ref val);
        }

        internal static XmlNode GetAndRemoveRequiredEnumAttribute(XmlNode node, string attrib, Type enumType, ref int val) {
            return GetAndRemoveEnumAttributeInternal(node, attrib, true, enumType, ref val);
        }

        private static XmlNode GetAndRemoveEnumAttributeInternal(XmlNode node, string attrib, bool isRequired, string [] values, ref int val) {
            XmlNode a = GetAndRemoveAttribute(node, attrib, isRequired);

            if (a == null)
                return null;
            for (int i = 0; i < values.Length; ++i) {
                if (values[i] == a.Value) { // case sensitive
                //if (string.Compare(values[i], a.Value, false, CultureInfo.InvariantCulture) == 0) { // ignore case
                    val = i;
                    return a;
                }
            }

            string names = null;
            foreach (string name in values) {
                if (names == null)
                    names = name;
                else
                    names += ", " + name;
            }
            throw new ConfigurationException(HttpRuntime.FormatResourceString(SR.Invalid_enum_attribute, attrib, names), a);
        }

        internal static XmlNode GetAndRemoveEnumAttribute(XmlNode node, string attrib, string [] values, ref int val) {
            return GetAndRemoveEnumAttributeInternal(node, attrib, false, values, ref val);
        }

        internal static void CheckForUnrecognizedAttributes(XmlNode node) {
            if (node.Attributes.Count != 0) {
                throw new ConfigurationException(
                                HttpRuntime.FormatResourceString(SR.Config_base_unrecognized_attribute, node.Attributes[0].Name),
                                node.Attributes[0]);
            }
        }

        // Throw an exception complaining that a line is duplicated (ASURT 93151)
        internal static void ThrowDuplicateLineException(XmlNode node) {
            throw new ConfigurationException(
                HttpRuntime.FormatResourceString(SR.Config_base_duplicate_line),
                node);
        }



        //
        // Obsolete XML Attribute Helpers
        //

        // if attribute not found return null
        internal static string RemoveAttribute(XmlNode node, string name) {

            XmlNode attribute = node.Attributes.RemoveNamedItem(name);

            if (attribute != null) {
                return attribute.Value;
            }

            return null;
        }

        // if attr not found throw standard message - "attribute x required"
        internal static string RemoveRequiredAttribute(XmlNode node, string name) {
            XmlNode attribute = node.Attributes.RemoveNamedItem(name);

            if (attribute == null) {
                throw new ConfigurationException(
                                HttpRuntime.FormatResourceString(SR.Config_base_required_attribute_missing, name),
                                node);                
            }

            if (attribute.Value == string.Empty) {
                throw new ConfigurationException(
                                HttpRuntime.FormatResourceString(SR.Config_base_required_attribute_empty, name),
                                node);                
            }

            return attribute.Value;
        }



        //
        // XML Element Helpers
        //

        internal static void CheckForNonElement(XmlNode node) {
            if (node.NodeType != XmlNodeType.Element) {
                throw new ConfigurationException(
                                HttpRuntime.FormatResourceString(SR.Config_base_elements_only),
                                node);                
            }
        }


        internal static bool IsIgnorableAlsoCheckForNonElement(XmlNode node) {
            if (node.NodeType == XmlNodeType.Comment || node.NodeType == XmlNodeType.Whitespace) {
                return true;
            }

            CheckForNonElement(node);

            return false;
        }


        internal static void CheckForChildNodes(XmlNode node) {
            if (node.HasChildNodes) {
                throw new ConfigurationException(
                                HttpRuntime.FormatResourceString(SR.Config_base_no_child_nodes),
                                node.FirstChild);                
            }
        }


        internal static void ThrowUnrecognizedElement(XmlNode node) {
            CheckBreakOnUnrecognizedElement();
            throw new ConfigurationException(
                            HttpRuntime.FormatResourceString(SR.Config_base_unrecognized_element),
                            node);
        }


        internal static void CheckAssignableType(XmlNode node, Type baseType, Type type) {
            if (!baseType.IsAssignableFrom(type)) {
                throw new ConfigurationException(
                                HttpRuntime.FormatResourceString(SR.Type_doesnt_inherit_from_type, type.FullName, baseType.FullName),
                                node);                
            }
        }

        internal static void CheckAssignableType(string filename, int lineNumber, Type baseType, Type type) {
            if (!baseType.IsAssignableFrom(type)) {
                throw new ConfigurationException(
                                HttpRuntime.FormatResourceString(SR.Type_doesnt_inherit_from_type, type.FullName, baseType.FullName),
                                filename, lineNumber);                
            }
        }

        // Section handlers can run in client mode through:
        //      ConfigurationSettings.GetConfig("sectionName")
        // See ASURT 123738
        internal static bool IsServerConfiguration(object context) {
            if (context == null)
                return false;

            if (context.GetType() == typeof(HttpConfigurationContext))
                return true;

            return false;
        }

        //
        // Http Intrinsics Helpers
        //
        
        internal static HttpRequest CurrentRequest {
            get {
                HttpContext current = HttpContext.Current;

                if (current == null)
                    return null;

                return current.Request;
            }
        }



        internal static PathLevel IsPathAtAppLevel(String path) {
            if (path == null)
                return PathLevel.MachineToApp;

            HttpRequest req = CurrentRequest;
            if (req == null)
                return PathLevel.MachineToApp;

            String apppath = req.ApplicationPath;
            if (apppath == null)
                return PathLevel.MachineToApp;

            if (path.Length == apppath.Length)
                return PathLevel.App;

            return (apppath.Length > path.Length) ? PathLevel.MachineToApp : PathLevel.BelowApp;
        }

        internal static int IndexOfCultureInvariant(string [] stringArray, string value) {
            for (int i = 0; i < stringArray.Length; ++i) {
                if (string.Compare(stringArray[i], value, false, CultureInfo.InvariantCulture) == 0) {
                    return i;
                }
            }

            return -1;
        }
            
        internal static string CombineStrings(string [] stringArray) { 
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < stringArray.Length; ++i) {
                sb.Append(stringArray[i]);
                if (i < stringArray.Length - 1) {
                    sb.Append(", ");
                }
            }

            return sb.ToString();
        }
        

        // help debug stress failure ASURT 140745
        // We need to capture the state of the XmlTextReader to 
        // debug why it is not reporting the contents of the 
        // configuration file correctly.
        static string s_firstErrorStack = null;
        internal static void CheckBreakOnUnrecognizedElement() {
            Debug.Trace("config_break", 
                "HandlerBase.CheckBreakOnUnrecognizedElement, thread" 
                + System.Threading.Thread.CurrentThread.GetHashCode().ToString());
            if (s_firstErrorStack == null) {
                s_firstErrorStack = System.Environment.StackTrace;
            }
            if (HttpConfigurationSystem.IsBreakOnUnrecognizedElement) {
                Debug.Break();
            }
        }
    
        
    }
    

    internal enum PathLevel {
        MachineToApp = 1,
        App = 0,
        BelowApp = -1
    }
    

    internal class LockedAttributeState {

        Hashtable _lockedAttributes;

        internal LockedAttributeState() : this(null) {}
        
        internal LockedAttributeState(LockedAttributeState original) {
            if (original == null) {
                _lockedAttributes = new Hashtable();
            }
            else {
                _lockedAttributes = (Hashtable)original._lockedAttributes.Clone();
            }
        }


        internal void CheckAndUpdate(XmlNode section, string [] lockableAttrList) {

            // verify the attributes at this level have not been locked
            CheckForLocked(section);


            string stringlockList = null;
            XmlNode attr = HandlerBase.GetAndRemoveStringAttribute(section, "lockAttributes", ref stringlockList);
            if (stringlockList == null) {
                return;
            }

            // comma-delimited list of attributes
            string [] attributesToLock = stringlockList.Split(new char [] {',', ';'});
            foreach (string s in attributesToLock) {

                string attributeToLock = s.Trim(' ');

                if (HandlerBase.IndexOfCultureInvariant(lockableAttrList, attributeToLock) == -1) {
                    throw new ConfigurationException(
                                    HttpRuntime.FormatResourceString(SR.Invalid_lockAttributes, attributeToLock, HandlerBase.CombineStrings(lockableAttrList)),
                                    attr);
                }

                _lockedAttributes[attributeToLock] = "";
            }

        }
        

        private void CheckForLocked(XmlNode sectionNode) {
            XmlElement sectionElement = (XmlElement) sectionNode;
            foreach (XmlAttribute attr in sectionElement.Attributes) {
                if (_lockedAttributes.Contains(attr.Name)) {

                    if (CanOverrideLockedAttribute(sectionElement, attr)) {
                        continue;
                    }

                    throw new ConfigurationException(
                                    HttpRuntime.FormatResourceString(SR.Config_section_attribute_locked, attr.Name), 
                                    attr);

                }
            }
        }

        // put in a hook to allow individual configuration sections to specialize behavior (allow safer settings when locked)
        protected virtual bool CanOverrideLockedAttribute(XmlElement el, XmlAttribute attr) {
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\handlermapping.cs ===
//------------------------------------------------------------------------------
// <copyright file="HandlerMapping.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Config related classes for HttpApplication
 */

namespace System.Web.Configuration {

    using System;
    using System.Web.Util;
    using System.Globalization;
    using System.Reflection;

    /*
     * Single mapping of request to class
     */
    internal class HandlerMapping {
        private Wildcard _requestType;
        private WildcardUrl _path;
        private Type _type;

        private String _typename;

        internal HandlerMapping(String requestType, String path, String typeName, bool defer) {
            // Remove all spaces from verbs before wildcard parsing.
            //   - We don't want get in "POST, GET" to be parsed into " GET".
            requestType = requestType.Replace(" ", ""); // replace all " " with "" in requestType

            _requestType = new Wildcard(requestType, false);    // case-sensitive wildcard
            _path = new WildcardUrl(path, true);                // case-insensitive URL wildcard

            // if validate="false" is marked on a handler, then the type isn't created until a request
            // is actually made that requires the handler. This (1) allows us to list handlers that
            // aren't present without throwing errors at init time and (2) speeds up init by avoiding
            // loading types until they are needed.

            if (defer) {
                _type = null;
                _typename = typeName;
            }
            else {
                _type = Type.GetType(typeName, true);

                if (!IsTypeHandlerOrFactory(_type))
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Type_not_factory_or_handler, typeName));

                if (!HttpRuntime.HasAspNetHostingPermission(AspNetHostingPermissionLevel.Unrestricted)) {
                    if (IsTypeFromAssemblyWithStrongName(_type) && !IsTypeFromAssemblyWithAPTCA(_type))
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Type_from_untrusted_assembly, typeName));
                }
            }
        }

        internal bool IsMatch(String verb, String path) {
            return(_path.IsSuffix(path) && _requestType.IsMatch(verb));
        }

        internal bool IsPattern(String verb, String path) {
            return(String.Compare(_path.Pattern, path, true, CultureInfo.InvariantCulture) == 0 &&
                   String.Compare(_requestType.Pattern, verb, true, CultureInfo.InvariantCulture) == 0);
        }

        internal Object Create() {
            // HACKHACK: for now, let uncreatable types through and error later (for .soap factory)
            // This design should change - developers will want to know immediately
            // when they misspell a type

            if (_type == null) {
                Type t = Type.GetType(_typename, true);

                // throw for bad types in deferred case
                if (!IsTypeHandlerOrFactory(t))
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Type_not_factory_or_handler, _typename));

                if (!HttpRuntime.HasAspNetHostingPermission(AspNetHostingPermissionLevel.Unrestricted)) {
                    if (!IsTypeFromAssemblyWithAPTCA(t) && IsTypeFromAssemblyWithStrongName(t))
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Type_from_untrusted_assembly, _typename));
                }

                _type = t;
            }

            return HttpRuntime.CreateNonPublicInstance(_type);
        }

        internal Type Type {
            get {
                return _type;
            }
        }

        internal String TypeName {
            get {
                return (_type != null) ? _type.FullName : _typename;
            }
        }

        internal String Verb {
            get {
                return _requestType.Pattern;
            }
        }

        internal String Path {
            get {
                return _path.Pattern;
            }
        }

        private static bool IsTypeHandlerOrFactory(Type t) {
            return typeof(IHttpHandler).IsAssignableFrom(t) 
                || typeof(IHttpHandlerFactory).IsAssignableFrom(t);
        }

        // REVIEW: this general purpose helper should be moved to HttpRuntime (or something similar)
        internal static bool IsTypeFromAssemblyWithAPTCA(Type t) {
            Object[] attrs = t.Assembly.GetCustomAttributes(
                typeof(System.Security.AllowPartiallyTrustedCallersAttribute), /*inherit*/ false);
            return (attrs != null && attrs.Length > 0);
        }

        // REVIEW: this general purpose helper should be moved to HttpRuntime (or something similar)
        internal static bool IsTypeFromAssemblyWithStrongName(Type t) {

            // Note: please revisit this assert if any code in this method is modified
            InternalSecurityPermissions.Unrestricted.Assert();

            // We use GetPublicKey() instead of looking at the Evidence to check if the assembly
            // has a strong name.  Looking at the evidence was a huge memory hit (ASURT 141175)
            AssemblyName aname = t.Assembly.GetName();
            byte[] publicKey = aname.GetPublicKey();
            return (publicKey.Length != 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\handlermap.cs ===
//------------------------------------------------------------------------------
// <copyright file="HandlerMap.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Config related classes for HttpApplication
 */

namespace System.Web.Configuration {

    using System;
    using System.Collections;

    /*
     * An object that maps verb, path -> handler/factory via wildcards
     */
    internal class HandlerMap {
        internal /*public*/ HandlerMap() {
            _phase = new ArrayList[2];
        }

        internal /*public*/ HandlerMap(HandlerMap parent) : this() {
            for (int phase = 0; phase < 2; phase++) {
                if (parent._phase[phase] != null)
                    _phase[phase] = new ArrayList(parent._phase[phase]);
            }
        }

        ArrayList[] _phase;
        ArrayList[] _group;

        internal /*public*/ void BeginGroup() {
            _group = new ArrayList[2];
        }

        internal /*public*/ void EndGroup() {
            for (int phase = 0; phase < 2; phase++) {
                if (_group[phase] != null) {
                    if (_phase[phase] == null)
                        _phase[phase] = new ArrayList();

                    _phase[phase].InsertRange(0, _group[phase]);
                }
            }

            _group = null;
        }

        internal /*public*/ void ClearAll() {
            for (int phase = 0; phase < 2; phase++) {
                ClearPhase(phase);
            }
        }

        internal /*public*/ void ClearPhase(int phase) {
            _phase[phase] = null;
            _group[phase] = null;
        }

        internal /*public*/ void Add(HandlerMapping mapping, int phase) {
            if (_group[phase] == null)
                _group[phase] = new ArrayList();

            _group[phase].Add(mapping);
        }

        internal /*public*/ HandlerMapping FindMapping(String requestType, String path) {
            for (int phase = 0; phase < 2; phase++) {
                ArrayList list = _phase[phase];

                if (list != null) {
                    int n = list.Count;

                    for (int i = 0; i < n; i++) {
                        HandlerMapping m = (HandlerMapping)list[i];

                        if (m.IsMatch(requestType, path))
                            return m;
                    }
                }
            }

            return null;
        }

        internal /*public*/ bool RemoveMapping(String requestType, String path) {
            bool found = false;

            for (int phase = 0; phase < 4; phase++) {
                ArrayList list;

                if (phase < 2)
                    list = _phase[phase];
                else
                    list = _group[phase - 2];

                if (list != null) {
                    int n = list.Count;

                    for (int i = 0; i < n; i++) {
                        HandlerMapping m = (HandlerMapping)list[i];

                        if (m.IsPattern(requestType, path)) {
                            // inefficient if there are many matches

                            list.RemoveAt(i);
                            i--;
                            n--;
                            found = true;
                        }
                    }
                }
            }

            return found;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\httpcapabilitiesbase.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpCapabilitiesBase.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Base class for browser capabilities object: just a read-only dictionary
 * holder that supports Init()
 *
 * CONSIDER: should this be the type that's exposed directly on HttpRequest?
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Configuration {

    using System.Collections;
    using System.Security.Permissions;

    /*
     * Abstract base class for Capabilities
     */
    /// <include file='doc\HttpCapabilitiesBase.uex' path='docs/doc[@for="HttpCapabilitiesBase"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HttpCapabilitiesBase {


        /// <include file='doc\HttpCapabilitiesBase.uex' path='docs/doc[@for="HttpCapabilitiesBase.GetConfigCapabilities"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static HttpCapabilitiesBase GetConfigCapabilities(string configKey, HttpRequest request) {
            HttpCapabilitiesEvaluator capsbuilder = (HttpCapabilitiesEvaluator)request.Context.GetConfig(configKey);

            if (capsbuilder == null) {
                return null;
            }
            else {
                return capsbuilder.Evaluate(request);
            }
        }

        /*
         * A Capabilities object is just a read-only dictionary
         */
        /// <include file='doc\HttpCapabilitiesBase.uex' path='docs/doc[@for="HttpCapabilitiesBase.this"]/*' />
        /// <devdoc>
        ///       <para>Allows access to individual dictionary values.</para>
        ///    </devdoc>
        public virtual String this[String key]
        {
            get {
                return(String)_items[key];
            }
        }

        /*
         * It provides an overridable Init method
         */
        /// <include file='doc\HttpCapabilitiesBase.uex' path='docs/doc[@for="HttpCapabilitiesBase.Init"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected virtual void Init() {
        }

        /*
         * The actual initializer sets up Item[] before calling Init()
         */
        internal void InitInternal(IDictionary dict) {
            if (_items != null)
                throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Caps_cannot_be_inited_twice));

            _items = dict;
            Init();
        }

        private IDictionary _items;
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\httpcapabilitiessectionhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpCapabilitiesSectionHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//
// ConfigureCapabilities is a parser CapabilitiesEvaluator objects;
// it's driven by the configuration system.
//
//

namespace System.Web.Configuration {

    using System.Collections;
    using System.Configuration;
    using System.IO;
    using System.Security;
    using System.Security.Permissions;
    using System.Text.RegularExpressions;
    using System.Web.Configuration;
    using System.Web.Util;
    using System.Xml;

    using Pair = System.Web.UI.Pair;

    //
    // ConfigureCapabilities is used to configure the CapabilitiesEvaluator object
    //
    internal class HttpCapabilitiesSectionHandler : IConfigurationSectionHandler {
        
        internal HttpCapabilitiesSectionHandler() {
        }
        

        class ParseState {
            internal string SectionName;
            internal HttpCapabilitiesEvaluator Evaluator;
            internal ArrayList RuleList = new ArrayList();
            internal ArrayList FileList = new ArrayList();
            internal bool IsExternalFile = false;
            
            internal ParseState() {}
        }
            

        //
        // As required by IConfigurationSectionHandler
        //
        public object Create(object parent, object configurationContext, XmlNode section) {
            // if called through client config don't even load HttpRuntime
            if (!HandlerBase.IsServerConfiguration(configurationContext))
                return null;

            ParseState parseState = new ParseState();
            parseState.SectionName = section.Name;

            // the rule is going to be the previous rule followed by a list containing the new rules
            parseState.Evaluator = new HttpCapabilitiesEvaluator((HttpCapabilitiesEvaluator)parent);
            ArrayList rulelist = new ArrayList();

            // check for random attributes
            
            HandlerBase.CheckForUnrecognizedAttributes(section);


            // iterate through XML section in order and apply the directives

            ArrayList sublist;

            sublist = RuleListFromElement(parseState, section, true);

            if (sublist.Count > 0) {
                parseState.RuleList.Add(new CapabilitiesSection(CapabilitiesRule.Filter, null, null, sublist));
            }

            if (parseState.FileList.Count > 0) {
                parseState.IsExternalFile = true;
                ResolveFiles(parseState, configurationContext);
            }
            
            // Add the new rules

            parseState.Evaluator.AddRuleList(parseState.RuleList);

            return parseState.Evaluator;
        }

        //
        // Create a rule from an element
        //
        static CapabilitiesRule RuleFromElement(ParseState parseState, XmlNode element) {
            int ruletype;
            DelayedRegex regex;
            CapabilitiesPattern pat;

            // grab tag name

            if (element.Name == "filter") {
                ruletype = CapabilitiesRule.Filter;
            }
            else if (element.Name=="case") {
                ruletype = CapabilitiesRule.Case;
            }
            else if (element.Name == "use") {
                HandlerBase.CheckForChildNodes(element);

                string var = HandlerBase.RemoveRequiredAttribute(element, "var");
                string strAs = HandlerBase.RemoveAttribute(element, "as");
                HandlerBase.CheckForUnrecognizedAttributes(element);

                if (strAs == null)
                    strAs = "";

                parseState.Evaluator.AddDependency(var);

                return new CapabilitiesUse(var, strAs);
            }
            else {
                throw new ConfigurationException(
                                                HttpRuntime.FormatResourceString(SR.Unknown_tag_in_caps_config, element.Name), 
                                                element);
            }

            // grab attributes
            String matchpat = HandlerBase.RemoveAttribute(element, "match");
            String testpat = HandlerBase.RemoveAttribute(element, "with");
            HandlerBase.CheckForUnrecognizedAttributes(element);

            if (matchpat == null) {
                if (testpat != null)
                    throw new ConfigurationException(HttpRuntime.FormatResourceString(SR.Cannot_specify_test_without_match), element);
                regex = null;
                pat = null;
            }
            else {
                try {
                    regex = new DelayedRegex(matchpat);
                }
                catch (Exception e) {
                    throw new ConfigurationException(e.Message, e, element);
                }

                if (testpat == null)
                    pat = CapabilitiesPattern.Default;
                else
                    pat = new CapabilitiesPattern(testpat);
            }

            // grab contents
            ArrayList subrules = RuleListFromElement(parseState, element, false);

            return new CapabilitiesSection(ruletype, regex, pat, subrules);
        }

        //
        // Create a rulelist from an element's children
        //
        static ArrayList RuleListFromElement(ParseState parseState, XmlNode node, bool top) {
            ArrayList result = new ArrayList();

            foreach (XmlNode child in node.ChildNodes) {
                switch (child.NodeType) {
                    case XmlNodeType.Text:
                    case XmlNodeType.CDATA:
                        top = false;
                        AppendLines(result, child.Value, node);
                        break;

                    case XmlNodeType.Element:
                        switch (child.Name) {
                            case "result":
                                if (top) {
                                    ProcessResult(parseState.Evaluator, child);
                                }
                                else {
                                    throw new ConfigurationException(
                                                    HttpRuntime.FormatResourceString(SR.Result_must_be_at_the_top_browser_section), 
                                                    child);
                                }
                                break;
                                
                            case "file": 
                                if (parseState.IsExternalFile) {
                                    throw new ConfigurationException(
                                                    HttpRuntime.FormatResourceString(SR.File_element_only_valid_in_config),
                                                    child);
                                }
                                ProcessFile(parseState.FileList, child);
                                break;

                            default: 
                                result.Add(RuleFromElement(parseState, child));
                                break;
                        }
                        top = false;
                        break;

                    case XmlNodeType.Comment:
                    case XmlNodeType.Whitespace:
                        break;

                    default:
                        HandlerBase.ThrowUnrecognizedElement(child);
                        break;
                }
            }

            return result;
        }


        //
        // Handle <file src=""/> elements
        //
        static void ProcessFile(ArrayList fileList, XmlNode node) {
            
            string filename = null;
            XmlNode attr = HandlerBase.GetAndRemoveRequiredStringAttribute(node, "src", ref filename);

            HandlerBase.CheckForUnrecognizedAttributes(node);
            HandlerBase.CheckForChildNodes(node);

            fileList.Add(new Pair(filename, attr));
        }


        //
        // Handle the <result> tag
        //
        static void ProcessResult(HttpCapabilitiesEvaluator capabilitiesEvaluator, XmlNode node) {

            bool inherit = true;
            HandlerBase.GetAndRemoveBooleanAttribute(node, "inherit", ref inherit);
            if (inherit == false) {
                capabilitiesEvaluator.ClearParent();
            }

            Type resultType = null;
            XmlNode attribute = HandlerBase.GetAndRemoveTypeAttribute(node, "type", ref resultType);
            if (attribute != null) {
                if (resultType.Equals(capabilitiesEvaluator._resultType) == false) {
                    // be sure the new type is assignable to the parent type
                    HandlerBase.CheckAssignableType(attribute, capabilitiesEvaluator._resultType, resultType);
                    capabilitiesEvaluator._resultType = resultType;
                }
            }

            int cacheTime = 0;
            attribute = HandlerBase.GetAndRemovePositiveIntegerAttribute(node, "cacheTime", ref cacheTime);
            if (attribute != null) {
                capabilitiesEvaluator.SetCacheTime(cacheTime);
            }

            HandlerBase.GetAndRemoveBooleanAttribute(node, "cache", ref capabilitiesEvaluator._useCache);

            HandlerBase.CheckForUnrecognizedAttributes(node);
            HandlerBase.CheckForChildNodes(node);

        }


        // 
        // ResolveFiles - parse files referenced with <file src="" />
        //
        static void ResolveFiles(ParseState parseState, object configurationContext) {

            //
            // 1) get the directory of the configuration file currently being parsed
            //

            HttpConfigurationContext httpConfigurationContext = (HttpConfigurationContext) configurationContext;
            string configurationDirectory = null;
            bool useAssert = false;

            //
            // Only assert to read cap files when parsing machine.config 
            // (allow device updates to work in restricted trust levels).
            //
            // Machine.config can be securely identified by the context being 
            // an HttpConfigurationContext with null path.
            //
            try {
                if (httpConfigurationContext.VirtualPath == null) {
                    useAssert = true;
                    // we need to assert here to get the file path from ConfigurationException
                    FileIOPermission fiop = new FileIOPermission(PermissionState.None);
                    fiop.AllFiles = FileIOPermissionAccess.PathDiscovery;
                    fiop.Assert();
                }
                
                Pair pair0 = (Pair)parseState.FileList[0];
                XmlNode srcAttribute = (XmlNode)pair0.Second;
                configurationDirectory = Path.GetDirectoryName(ConfigurationException.GetXmlNodeFilename(srcAttribute));
            }
            finally {
                if (useAssert) {
                    CodeAccessPermission.RevertAssert();
                }
            }

            //
            // 2) iterate through list of referenced files, builing rule lists for each
            //
            foreach (Pair pair in parseState.FileList) {
                string srcFilename = (string)pair.First;
                string fullFilename = Path.Combine(configurationDirectory, srcFilename);

                XmlNode section;
                try {
                    if (useAssert) {
                        InternalSecurityPermissions.FileReadAccess(fullFilename).Assert();
                    }

                    Exception fcmException = null;
                    
                    try {
                        HttpConfigurationSystem.AddFileDependency(fullFilename);
                    }
                    catch (Exception e) {
                        fcmException = e;
                    }

                    ConfigXmlDocument configDoc = new ConfigXmlDocument();
                    
                    try {
                        configDoc.Load(fullFilename);
                        section = configDoc.DocumentElement;
                    }
                    catch (Exception e) {
                        throw new ConfigurationException(HttpRuntime.FormatResourceString(SR.Error_loading_XML_file, fullFilename, e.Message), 
                                        e, (XmlNode)pair.Second);
                    }

                    if (fcmException != null)
                        throw fcmException;
                }
                finally {
                    if (useAssert) {
                        // Cannot apply next FileReadAccess PermissionSet unless 
                        // current set is explicitly reverted.  Also minimizes
                        // granted permissions.
                        CodeAccessPermission.RevertAssert();
                    }
                }
                
                if (section.Name != parseState.SectionName) {
                    throw new ConfigurationException(HttpRuntime.FormatResourceString(SR.Capability_file_root_element, parseState.SectionName), 
                                    section);
                }
                    
                HandlerBase.CheckForUnrecognizedAttributes(section);

                ArrayList sublist = RuleListFromElement(parseState, section, true);

                if (sublist.Count > 0) {
                    parseState.RuleList.Add(new CapabilitiesSection(CapabilitiesRule.Filter, null, null, sublist));
                }
            }
        }


        //
        // Some line counting
        //
        static int LineCount(String text, int offset, int newoffset) {
            int linecount = 0;

            if (newoffset < offset)
                throw new ArgumentException(HttpRuntime.FormatResourceString(SR.Cant_count_lines_backwards));

            while (offset < newoffset) {
                if (text[offset] == '\r' || (text[offset] == '\n' && (offset == 0 || text[offset - 1] != '\r')))
                    linecount++;
                offset++;
            }

            return linecount;
        }

        //
        // Regex dealing with a=b lines
        //
        static Regex lineRegex = new Regex
                                          (
                                          "\\G" +                                 // anchored
                                          "(?<var>\\w+)" +                        // variable name
                                          "\\s*=\\s*" +                           // equals sign
                                          "(?:" +
                                          "\"(?<pat>[^\"\r\n\\\\]*" +         // quoted pattern
                                          "(?:\\\\.[^\"\r\n\\\\]*)*)\"" +
                                          "|(?!\")(?<pat>\\S+)" +             // unquoted pattern
                                          ")" +
                                          "\\s*"                                  // trailing whitespace
                                          );

        static Regex wsRegex = new Regex("\\G\\s*");
        static Regex errRegex = new Regex("\\G\\S {0,8}");

        static void AppendLines(ArrayList setlist, String text, XmlNode node) {
            int lineNumber = ConfigurationException.GetXmlNodeLineNumber(node);
            int textpos;

            textpos = 0;

            for (;;) {
                Match match;

                if ((match = wsRegex.Match(text, textpos)).Success) {
                    lineNumber += LineCount(text, textpos, match.Index + match.Length);
                    textpos = match.Index + match.Length;
                }

                if (textpos == text.Length)
                    break;

                if ((match = lineRegex.Match(text, textpos)).Success) {
                    setlist.Add(new CapabilitiesAssignment(match.Groups["var"].Value,
                                                           new CapabilitiesPattern(match.Groups["pat"].Value)));

                    lineNumber += LineCount(text, textpos, match.Index + match.Length);
                    textpos = match.Index + match.Length;
                }
                else {
                    match = errRegex.Match(text, textpos);

                    throw new ConfigurationException(
                                    HttpRuntime.FormatResourceString(SR.Problem_reading_caps_config, match.ToString()), 
                                    ConfigurationException.GetXmlNodeFilename(node),
                                    lineNumber);
                }
            }
        }

    }

    internal class DelayedRegex {

        private String _regstring;
        private Regex _regex;

        internal DelayedRegex(String s) {
            _regex = null;
            _regstring = s;
        }

        internal Match Match(String s) {
            EnsureRegex();
            return _regex.Match(s);
        }

        internal int GroupNumberFromName(String name) {
            EnsureRegex();
            return _regex.GroupNumberFromName(name);
        } 

        internal void EnsureRegex() {
            string regstring = _regstring;
            if(_regex == null) {
                _regex = new Regex(regstring);
                //free original
                _regstring = null;
            }
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\httpcapabilitiesevaluator.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpCapabilitiesEvaluator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//
// HttpCapabilitiesEvaluator is a set of rules from a capabilities section 
// like <browserCaps>.  It takes an HttpRequest as input and produces
// an HttpCapabilities object (of a configurable subtype) as output.
//

namespace System.Web.Configuration {
    using System.Text;

    using System.Collections;
    using System.Collections.Specialized;
    using System.Web.Caching;
    using System.Text.RegularExpressions;
    using System.Threading;
    using System.Globalization;
    using System.Security;

    //
    // CapabilitiesEvaluator encapabilitiesulates a set of rules for deducing
    // a capabilities object from an HttpRequest
    //
    internal class HttpCapabilitiesEvaluator {

        internal CapabilitiesRule _rule;
        internal Hashtable _variables;
        internal Type _resultType;
        internal int _cachetime;
        internal string _cacheKeyPrefix;
        internal bool _useCache;

        private static int _idCounter;
        private const string _capabilitieskey = "System.Web.Configuration.CapabilitiesEvaluator";
        private static object _disableOptimisticCachingSingleton = new object();

        //
        // internal constructor; inherit from parent
        //
        internal HttpCapabilitiesEvaluator(HttpCapabilitiesEvaluator parent) {
            int id = Interlocked.Increment(ref _idCounter);
            // don't do id.ToString() on every request, do it here
            _cacheKeyPrefix = _capabilitieskey + id.ToString() + "\n";

            if (parent == null) {
                ClearParent();
            }
            else {
                _rule = parent._rule;

                if (parent._variables == null)
                    _variables = null;
                else
                    _variables = new Hashtable(parent._variables);

                _cachetime = parent._cachetime;
                _resultType = parent._resultType;
                _useCache = parent._useCache;
            }
        }

        //
        // remove inheritance for <result inherit="false" />
        //
        internal virtual void ClearParent() {
            _rule = null;
            _cachetime = 60000; // one minute default expiry
            _variables = new Hashtable();
            _resultType = typeof(HttpCapabilitiesBase);
            _useCache = true;
        }

        //
        // set <result cacheTime="ms" ... />
        //
        internal virtual void SetCacheTime(int ms) {
            _cachetime = ms;
        }

        //
        // add a dependency when we encounter a <use var="HTTP_ACCEPT_LANGUAGE" as="lang" />
        //
        internal virtual void AddDependency(String variable) {
            if (variable.Equals("HTTP_USER_AGENT"))
                variable = "";

            _variables[variable] = true;
        }

        //
        // sets the set of rules
        //
        internal virtual void AddRuleList(ArrayList rulelist) {
            if (rulelist.Count == 0)
                return;

            if (_rule != null)
                rulelist.Insert(0, _rule);

            _rule = new CapabilitiesSection(CapabilitiesRule.Filter, null, null, rulelist);
        }

        internal static string GetUserAgent(HttpRequest request) {
            if (request.ClientTarget.Length > 0) {
                
                // Lookup ClientTarget section in config.
                ClientTargetConfiguration clientTargetConfig = (ClientTargetConfiguration)request.Context.GetConfig("system.web/clientTarget");
                NameValueCollection clientTargetDictionary = null;
                if (clientTargetConfig != null) {
                     clientTargetDictionary = clientTargetConfig.Configuration;
                }
                
                if (clientTargetDictionary != null ) {
                    // Found it
                    // Try to map the alias
                    string useUserAgent = clientTargetDictionary[request.ClientTarget];
                    if (useUserAgent != null) {
                        return useUserAgent;
                    }
                }

                throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_client_target, request.ClientTarget));
            }

            // Protect against attacks with long User-Agent headers
            String userAgent = request.UserAgent;
            if (userAgent != null && userAgent.Length > 256)
                userAgent = String.Empty;
            return userAgent;
        }

        //
        // Actually computes the browser capabilities
        //
        internal virtual HttpCapabilitiesBase Evaluate(HttpRequest request) {

            HttpCapabilitiesBase result;
            CacheInternal cacheInternal = System.Web.HttpRuntime.CacheInternal;
            
            //
            // 1) grab UA and do optimistic cache lookup (if UA is in dependency list) 
            //
            string userAgent = null;
            string optimisticCacheKey = null;
            bool doFullCacheKeyLookup = false;

            if (_variables.Contains("")) {
                object optimisticCacheResult = null;

                if(_useCache) {
                    userAgent = GetUserAgent(request);
                    optimisticCacheKey = _cacheKeyPrefix + userAgent + "\n";
                    optimisticCacheResult = cacheInternal.Get(optimisticCacheKey);

                    // optimize for common case (desktop browser)
                    result = optimisticCacheResult as HttpCapabilitiesBase;
                    if (result != null) {
                        return result;
                    }
                }

                //
                // 1.1) optimistic cache entry could tell us to do full cache lookup
                // 
                if (optimisticCacheResult == _disableOptimisticCachingSingleton) {
                    doFullCacheKeyLookup = true;
                }
                else {
                    // cache it
                    // CONSIDER: respect _cachetime
                    result = EvaluateFinal(request, true);
                    string isMoblieDevice = result["isMobileDevice"];
                    if (isMoblieDevice == "false") {
                        if(_useCache) {
                            cacheInternal.UtcInsert(optimisticCacheKey, result);
                        }
                        return result;
                    }
                }
            }
                
            //
            // 2) either:
            //
            //      We've never seen the UA before (parse all headers to 
            //          determine if the new UA also carries modile device
            //          httpheaders).
            //
            //      It's a mobile UA (so parse all headers) and do full 
            //          cache lookup
            //
            //      UA isn't in dependency list (customer custom caps section)
            //
            IDictionaryEnumerator de = _variables.GetEnumerator();
            StringBuilder sb = new StringBuilder(_cacheKeyPrefix);

            InternalSecurityPermissions.AspNetHostingPermissionLevelLow.Assert();
            string fullCacheKey = null;
            if(_useCache) {
                while (de.MoveNext()) {
                    string key = (string)de.Key;
                    string value;

                    if (key.Length == 0) {
                    value = userAgent;
                    }
                    else {
                        value = request.ServerVariables[key];
                    }

                    if (value != null) {
                        sb.Append(value);
                    }    

                    sb.Append('\n');
                }

                fullCacheKey = sb.ToString();

                //
                // Only do full cache lookup if the optimistic cache 
                // result was _disableOptimisticCachingSingleton or 
                // if UserAgent wasn't in the cap var list.
                //
                if (userAgent == null || doFullCacheKeyLookup) {
                    result = (HttpCapabilitiesBase)cacheInternal.Get(fullCacheKey);

                    if (result != null)
                        return result;
                }    
            }

            result = EvaluateFinal(request, false);
            
            // cache it
            // CONSIDER: respect _cachetime
            if(_useCache) {
                cacheInternal.UtcInsert(fullCacheKey, result);
                cacheInternal.UtcInsert(optimisticCacheKey, _disableOptimisticCachingSingleton);
            }

            return result;
        }

        internal virtual HttpCapabilitiesBase EvaluateFinal(HttpRequest request, bool onlyEvaluateUserAgent) {
            // not in cache: calculate the result
            Hashtable values = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
            CapabilitiesState state = new CapabilitiesState(request, values);
            if (onlyEvaluateUserAgent) {
                state.EvaluateOnlyUserAgent = true;
            }

            _rule.Evaluate(state);

            // create the new type
            // CONSIDER: don't allow non-public cap result types
            HttpCapabilitiesBase result = (HttpCapabilitiesBase)HttpRuntime.CreateNonPublicInstance(_resultType);
            result.InitInternal(values);
            
            return result;
        }

    }

    //
    // CapabilitiesRule is a step in the computation of a capabilities object. It can be either
    // (1) import a string from the request object
    // (2) assign a pattern into a variable
    // (3) execute a subsequence if a regex matches
    // (4) execute a subsequence and exit the block if a regex matches
    //
    internal abstract class CapabilitiesRule {
        internal const int Use = 0;
        internal const int Assign = 1;
        internal const int Filter = 2;
        internal const int Case = 3;

        internal int _type;

        internal virtual int Type {
            get {
                return _type;
            }
        }

        internal abstract void Evaluate(CapabilitiesState state);
    }

    //
    // Implementation of <use var="HTTP_ACCEPT_LANGUAGE" as="language" />: grab
    // the server variable and stuff it into the %{language} variable
    //
    internal class CapabilitiesUse : CapabilitiesRule {
        internal String _var;
        internal String _as;

        internal CapabilitiesUse(String var, String asParam) {
            _var = var;
            _as = asParam;
        }

        internal override void Evaluate(CapabilitiesState state) {
            state.SetVariable(_as, state.ResolveServerVariable(_var));
            state.Exit = false;
        }
    }


    //
    // Implementation of the foo = ${bar}-something-%{que}
    // expand the pattern on the right and store it in the %{foo} variable
    //
    internal class CapabilitiesAssignment : CapabilitiesRule {
        internal String _var;
        internal CapabilitiesPattern _pat;

        internal CapabilitiesAssignment(String var, CapabilitiesPattern pat) {
            _type = Assign;
            _var = var;
            _pat = pat;
        }

        internal override void Evaluate(CapabilitiesState state) {
            state.SetVariable(_var, _pat.Expand(state));
            state.Exit = false;
        }
    }

    //
    // Implementation of <filter match="Mozilla/\d+\.\d+" with="${something}" />
    // expand the "with" pattern and match against the "match" expression.
    //
    internal class CapabilitiesSection : CapabilitiesRule {
        internal CapabilitiesPattern _expr;
        internal DelayedRegex _regex;
        internal CapabilitiesRule[] _rules;

        internal CapabilitiesSection(int type, DelayedRegex regex, CapabilitiesPattern expr, ArrayList rulelist) {
            _type = type;
            _regex = regex;
            _expr = expr;
            _rules = (CapabilitiesRule[])rulelist.ToArray(typeof(CapabilitiesRule));
        }

        internal override void Evaluate(CapabilitiesState state) {
            Match match;

            state.Exit = false;

            if (_regex != null) {
                match = _regex.Match(_expr.Expand(state));

                if (!match.Success)
                    return;

                state.AddMatch(_regex, match);
            }

            for (int i = 0; i < _rules.Length; i++) {
                _rules[i].Evaluate(state);

                if (state.Exit)
                    break;
            }

            if (_regex != null) {
                state.PopMatch();
            }

            state.Exit = (Type == Case);
        }
    }

    //
    // Encapsulates the evaluation state used in computing capabilities
    //
    internal class CapabilitiesState {
        internal HttpRequest _request;
        internal IDictionary _values;
        internal ArrayList _matchlist;
        internal ArrayList _regexlist;
        internal bool _exit;
        internal bool _evaluateOnlyUserAgent;

        internal CapabilitiesState(HttpRequest request, IDictionary values) {
            _request = request;
            _values = values;
            _matchlist = new ArrayList();
            _regexlist = new ArrayList();
        }

        internal bool EvaluateOnlyUserAgent {
            get {
                return _evaluateOnlyUserAgent;
            }
            set {
                _evaluateOnlyUserAgent = value;
            }
        }

        internal virtual void ClearMatch() {
            if (_matchlist == null) {
                _regexlist = new ArrayList();
                _matchlist = new ArrayList();
            }
            else {
                _regexlist.Clear();
                _matchlist.Clear();
            }
        }

        internal virtual void AddMatch(DelayedRegex regex, Match match) {
            _regexlist.Add(regex);
            _matchlist.Add(match);
        }

        internal virtual void PopMatch() {
            _regexlist.RemoveAt(_regexlist.Count - 1);
            _matchlist.RemoveAt(_matchlist.Count - 1);
        }

        internal virtual String ResolveReference(String refname) {
            if (_matchlist == null)
                return "";

            int i = _matchlist.Count;

            while (i > 0) {
                i--;
                int groupnum = ((DelayedRegex)_regexlist[i]).GroupNumberFromName(refname);

                if (groupnum >= 0) {
                    Group group = ((Match)_matchlist[i]).Groups[groupnum];
                    if (group.Success) {
                        return group.ToString();
                    }
                }
            }

            return "";
        }

        internal virtual String ResolveServerVariable(String varname) {
            String result;

            if (varname.Length == 0 || varname == "HTTP_USER_AGENT")
                return HttpCapabilitiesEvaluator.GetUserAgent(_request);

            if (EvaluateOnlyUserAgent)
                return "";
            
            InternalSecurityPermissions.AspNetHostingPermissionLevelLow.Assert();
            result = _request.ServerVariables[varname];

            if (result == null)
                return "";

            return result;
        }

        internal virtual String ResolveVariable(String varname) {
            String result;

            result = (String)_values[varname];

            if (result == null)
                return "";

            return result;
        }

        internal virtual void SetVariable(String varname, String value) {
            _values[varname] = value;
        }

        internal virtual bool Exit {
            get {
                return _exit;
            }
            set {
                _exit = value;
            }
        }
    }

    //
    // Represents a single pattern to be expanded
    //
    internal class CapabilitiesPattern {
        internal String[]    _strings;
        internal int[]       _rules;

        internal const int Literal    = 0;    // literal string
        internal const int Reference  = 1;    // regex reference ${name} or $number
        internal const int Variable   = 2;    // regex reference %{name}

        internal static readonly Regex refPat = new Regex("\\G\\$(?:(?<name>\\d+)|\\{(?<name>\\w+)\\})");
        internal static readonly Regex varPat = new Regex("\\G\\%\\{(?<name>\\w+)\\}");
        internal static readonly Regex textPat = new Regex("\\G[^$%\\\\]*(?:\\.[^$%\\\\]*)*");
        internal static readonly Regex errorPat = new Regex(".{0,8}");

        internal static readonly CapabilitiesPattern Default = new CapabilitiesPattern();

        internal CapabilitiesPattern() {
            _strings = new String[1];
            _strings[0] = "";
            _rules = new int[1];
            _rules[0] = Variable;
        }

        internal CapabilitiesPattern(String text) {
            ArrayList strings = new ArrayList();
            ArrayList rules = new ArrayList();

            int textpos = 0;

            for (;;) {
                Match match = null;

                // 1: scan text

                if ((match = textPat.Match(text, textpos)).Success && match.Length > 0) {
                    rules.Add(Literal);
                    strings.Add(Regex.Unescape(match.ToString()));
                    textpos = match.Index + match.Length;
                }

                if (textpos == text.Length)
                    break;

                // 2: look for regex references

                if ((match = refPat.Match(text, textpos)).Success) {
                    rules.Add(Reference);
                    strings.Add(match.Groups["name"].Value);
                }

                // 3: look for variables

                else if ((match = varPat.Match(text, textpos)).Success) {
                    rules.Add(Variable);
                    strings.Add(match.Groups["name"].Value);
                }

                // 4: encountered a syntax error (CONSIDER: add line numbers)

                else {
                    match = errorPat.Match(text, textpos);

                    throw new ArgumentException(
                                               HttpRuntime.FormatResourceString(SR.Unrecognized_construct_in_pattern, match.ToString(), text));
                }

                textpos = match.Index + match.Length;
            }

            _strings = (String[])strings.ToArray(typeof(String));

            _rules = new int[rules.Count];
            for (int i = 0; i < rules.Count; i++)
                _rules[i] = (int)rules[i];
        }

        internal virtual String Expand(CapabilitiesState matchstate) {
            StringBuilder sb = null;
            String result = null;

            for (int i = 0; i < _rules.Length; i++) {
                if (sb == null && result != null)
                    sb = new StringBuilder(result);

                switch (_rules[i]) {
                    case Literal:
                        result = _strings[i];
                        break;

                    case Reference:
                        result = matchstate.ResolveReference(_strings[i]);
                        break;

                    case Variable:
                        result = matchstate.ResolveVariable(_strings[i]);
                        break;
                }

                if (sb != null && result != null)
                    sb.Append(result);
            }

            if (sb != null)
                return sb.ToString();

            if (result != null)
                return result;

            return "";
        }

#if DBG
        internal virtual String Dump() {
            StringBuilder sb = new StringBuilder();

            for (int i = 0; i < _rules.Length; i++) {
                switch (_rules[i]) {
                    case Literal:
                        sb.Append("\"" + _strings[i] + "\"");
                        break;
                    case Reference:
                        sb.Append("${" + _strings[i] + "}");
                        break;
                    default:
                        sb.Append("??");
                        break;
                }

                if (i < _rules.Length - 1)
                    sb.Append(" ");
            }

            return sb.ToString();
        }

        internal virtual String Dump(String indent) {
            return indent + Dump() + "\n";
        }
#endif
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\httpconfigurationcontext.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpConfigurationContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Configuration {
    using System.Security.Permissions;

    /// <include file='doc\HttpConfigurationContext.uex' path='docs/doc[@for="HttpConfigurationContext"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Property dictionary available to section handlers in 
    ///       web applications.
    ///    </para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HttpConfigurationContext {

        private string vpath;
        

        /// <include file='doc\HttpConfigurationContext.uex' path='docs/doc[@for="HttpConfigurationContext.VirtualPath"]/*' />
        /// <devdoc>
        ///     <para>
        ///         Virtual path to the virtual directory containing web.config.
        ///         This could be the virtual path to a file in the case of a 
        ///         section in &lt;location path='file.aspx'&gt;.
        ///     </para>
        /// </devdoc>
        public string VirtualPath {
            get {
                return vpath;
            }
        }

        /// <devdoc>
        ///     <para>Can only be created by ASP.NET Configuration System.</para>
        /// </devdoc>
        internal HttpConfigurationContext(string vpath) {
            this.vpath = vpath;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\httpconfigurationsystembase.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpConfigurationSystemBase.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * implements System.Configuration.IConfigurationSystem, to 
 * plug ASP.NET's config system via ConfigurationSettings.SetConfigurationSystem()
 */
namespace System.Web.Configuration {
    using System.Configuration;
    using System.IO;
    using System.Reflection;
    

    internal class HttpConfigurationSystemBase : IConfigurationSystem {
        protected static HttpConfigurationSystem _system;

        protected HttpConfigurationSystemBase() {
        }

        void IConfigurationSystem.Init() {
        }

        object IConfigurationSystem.GetConfig(string configKey) {
            HttpContext context = HttpContext.Current;

            if (context != null) {
                return context.GetConfig(configKey);
            }
            
            // if no context is available we assume application-level configuration
            HttpConfigurationRecord applicationLevelConfigRecord = HttpConfigurationSystem.GetComplete();
            return applicationLevelConfigRecord.GetConfig(configKey);
        }

        internal static void EnsureInit() {
            lock (typeof(HttpConfigurationSystemBase)) {
                if (_system == null) {
                    _system = new HttpConfigurationSystem();

                    //
                    // Use reflection to do equivalent of: 
                    //
                    //      ConfigurationSettings.SetConfigurationSystem(_system);
                    //
                    // This allows SetConfigurationSystem to be internal but still set by ASP.NET
                    //
                    MethodInfo method = typeof(ConfigurationSettings).GetMethod("SetConfigurationSystem", BindingFlags.Static | BindingFlags.NonPublic); 

                    if (method == null) {
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Config_unable_to_set_configuration_system));
                    }
                    method.Invoke(null, new object [] {_system});
                }
            }
        }


        //
        // Config Path Helper Functions and string constants
        //
        internal const string MachineConfigSubdirectory = "Config";
        internal const string MachineConfigFilename = "machine.config";


        internal static String MsCorLibDirectory {
            get {
                string filename = Assembly.GetAssembly(typeof(object)).Location.Replace('/', '\\');
                return Path.GetDirectoryName(filename);
            }
        }

        internal static string MachineConfigurationDirectory {
            get {
                return Path.Combine(MsCorLibDirectory, MachineConfigSubdirectory);
            }
        }

        internal static string MachineConfigurationFilePath {
            get {
                return Path.Combine(MachineConfigurationDirectory, MachineConfigFilename);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\httpconfigurationrecord.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpConfigurationRecord.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


#if CONFIG_PERF
#warning CONFIG_PERF defined: This build will contain tracing of ASP.NET Configuration performance.
#define TRACE
#endif

namespace System.Web.Configuration {
    using System.Collections;
    using System.Collections.Specialized;
    using System.Configuration;
    using System.Diagnostics;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Web.Util;
    using System.Web.Caching;
    using System.Xml;
    using Debug = System.Web.Util.Debug;
    using System.Globalization;
    

    /// <include file='doc\HttpConfigurationRecord.uex' path='docs/doc[@for="HttpConfigurationRecord"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///     This is the object that is cached per-url.
    /// </devdoc>
    internal class HttpConfigurationRecord {

        #if CONFIG_PERF
            static HttpConfigurationRecord() {
                TracePerf("class ctor " + FormatPerfTime(s_ctorTime));
                long start = Counter.Value;
                new XmlDocument().LoadXml("<root a='a'><child> hi </child><child2/></root>");
                TracePerf("XML Jit time:" + FormatPerfTime(Counter.Time(start)));
                TracePerf("class ctor " + FormatPerfTime(s_ctorTime));
            }
        #endif

        /// <devdoc>
        ///     Holds state like which sections are to be evaluated.  
        ///     Holds the list of XML files containing input for this 
        ///         section (in the case this node in inheritting 
        ///         settings from an ancestor's &lt;location&gt; section).  
        ///     Holds the results of evaluation.
        /// </devdoc>
        private Hashtable _sections;

        /// <devdoc>
        ///     Holds the factory's state like where it's allowed, and if it's locked.
        ///     Holds the factory type string or the <see cref='System.Configuration.IConfigurationSectionHandler'/> object.
        /// </devdoc>
        private Hashtable _factories;

        private bool      _factoriesNoInherit;     // default false
        private ArrayList _deferredList;           //   These two hold LocationInput objects
        private Hashtable _deferredPaths;          //   These two hold LocationInput objects

        private readonly bool _haveParent;
        private readonly string _parentRequestPath;// cannot hold direct reference to parent record, must lookup parent record in cache every time it's needed
        private readonly string _filename;         // default null
        private readonly string _requestPath;
        private readonly bool _inheritable;
        private readonly ConfigurationException _error;

        private static HttpConfigurationRecord _empty; // default null


        static bool stringStartsWithIgnoreCase(string s1, string s2) {
            if (s2.Length > s1.Length) {
                return false;
            }

            return 0 == string.Compare(s1, 0, s2, 0, s2.Length, true, CultureInfo.InvariantCulture);
        }


        internal HttpConfigurationRecord(string filename, HttpConfigurationRecord parent, bool inheritable, string path) {
            #if CONFIG_PERF
                long ctorStart = Counter.Value;
            #endif
        
            Debug.Trace("config", "Create HttpConfigurationRecord(" + 
                (filename == null ? "null" : filename) + ", " + 
                (parent == null   ? "null" : "parent") + ", " + 
                inheritable + ", " + 
                (path == null     ? "null" : path) + ")");

            _requestPath = path;
            _inheritable = inheritable;
            _sections = new Hashtable();

            try {
                if (parent != null) {
                    _haveParent = true;
                    _parentRequestPath = parent.Path;

                    // implement <location> inheritance
                    if (parent._deferredList != null) {
                        foreach (LocationInput deferred in parent._deferredList) {
                            Debug.Trace("config_loc", " ... searching deferred list ... " + _requestPath + " " + deferred.path);

                            if (string.Compare(deferred.path, path, true, CultureInfo.InvariantCulture) == 0) {
                                Debug.Trace("config_loc", "deferred target found " + deferred.path);
                                foreach (string sectionKey in deferred.sections.Keys) {
                                    Debug.Trace("config_loc", "adding section <" + sectionKey + ">");
                                    VerifyAllowDefinition(HaveFactory(sectionKey), null, (IConfigErrorInfo)deferred.sections[sectionKey]);
                                    EnsureSection(sectionKey).AddInput(deferred);
                                }
                                if (deferred.lockedSections != null) {
                                    foreach (string sectionKey in deferred.lockedSections.Keys) {
                                        LockSection(sectionKey);
                                    }
                                }

                            }
                            else if (stringStartsWithIgnoreCase(deferred.path, path)) {
                                Debug.Trace("config_loc", "inheritting deferred for child path " + deferred.path);
                                EnsureDeferred();
                                _deferredList.Add(deferred);
                            }
                        }
                    }
                }

                if (FileUtil.FileExists(filename)) {
                    TracePerf("    Reading config file \"" + filename + "\"");

                    _filename = filename;

                    using (XmlUtil xmlUtil = new XmlUtil(filename)) {
                        
                        ScanFactories(xmlUtil);

                        Debug.Assert(xmlUtil.Reader.Depth <= 1);
                        if (xmlUtil.Reader.Depth == 1) {
                            ScanSectionsRecursive(xmlUtil);
                        }
                    }

                    // Do we need this table after scan?  Nope, only the deferred list, so now free it.
                    _deferredPaths = null; 
                }
                else {
                    if (path == null) {
                        throw new ConfigurationException(SR.GetString(SR.Cannot_read_machine_level_config_file, HttpRuntime.GetSafePath(filename)));
                    }
                    Debug.Trace("config", "Not reading config - file \"" + filename + "\" does not exist");
                }

                #if CONFIG_PERF
                    float time = Counter.Time(ctorStart);
                    s_ctorTime = time + s_ctorTime;
                    TracePerf(
                        "ctor   time:" + FormatPerfTime(time) +
                        " total:" + FormatPerfTime(s_ctorTime) + 
                        " gtotal:" + FormatPerfTime(s_totalTime));
                #endif
            }
            catch (Exception e) {
                _error = TranslateXmlParseOrEvaluateErrors(e, _filename);
            }
        }


        #if CONFIG_PERF

            private  static float s_ctorTime      = 0.0f;
            private  static float s_getConfigTime = 0.0f;
            private  static float s_totalTime {
                get {
                    return s_ctorTime + s_getConfigTime;
                }
            }
        #endif


        internal object this[string configKey] {
            get {
                return GetConfig(configKey);
            }
        }


        internal object GetConfig(string configKey) {
            Debug.Trace("config", "GetConfig(\"" + configKey + "\")");

            #if CONFIG_PERF
                long start = Counter.Value;
            #endif

            object result = GetConfig(configKey, true);
            if (result == null) {
                Debug.Trace("config", "GetConfig returning null");
            }

            #if CONFIG_PERF
                float time = Counter.Time(start);
                s_getConfigTime += time;
                if (time > 0.0005)
                TracePerf( 
                    "get    time:" + FormatPerfTime(time) +
                    " total:" + FormatPerfTime(s_getConfigTime) + 
                    " gtotal:" + FormatPerfTime(s_totalTime) + 
                    "  " + _requestPath + " GetConfig(\"" + configKey + "\")");
            #endif

            return result;
        }

        // same as GetConfig, except it doesn't put inherited results in _results - only cache results where used
        private object ParentGetConfig(string configKey) {
            return GetConfig(configKey, false);
        }


        private object GetConfig(string configKey, bool cacheResult) {
            Debug.Trace("config_verbose", "GetConfig(\"" + configKey + "\", " + cacheResult + ")");

            if (_error != null) {
                throw _error;
            }

            SectionRecord section;
            if (cacheResult) {
                section = EnsureSection(configKey);
            }
            else {
                section = (SectionRecord)_sections[configKey];
            }

            if (section != null) {
                if (section.HaveResult) {
                    return section.Result;
                }
                
                object result = null;
                
                if (section.ToBeEvaluated) {
                    result = Evaluate(configKey, section);
                }
                else if (_haveParent) {
                    result = Parent.ParentGetConfig(configKey);
                }
                
                section.Result = result;
                return result;
            }

            if (_haveParent) {
                return Parent.ParentGetConfig(configKey);
            }

            return null;
        }


        // only called from GetConfig - no locking necessary
        private object Evaluate(string configKey, SectionRecord section) {

            Debug.Trace("config", "Evaluating " + configKey);
            // 
            // Step 1: Get the config factory
            //
            IConfigurationSectionHandler factory = GetFactory(configKey);
            Debug.Assert(factory != null);


            //
            // Step 2: Get the parent result to be passed to the section handler
            //
            object objResult =  _haveParent ? Parent.ParentGetConfig(configKey) : null;


            //
            // Step 3: Evaluate the config section(s)
            //
            string [] keys = configKey.Split(new char[] {'/'});
            object input = section.Input;

            if (section.HaveResult) { // another thread has evaluated the result between the time GetConfig() was called and here...
                return section.Result;  // return the result set by the other thread...
            }

            ArrayList inputs = input as ArrayList;
            int i = 0;

            // here we could have a single input (in input), or we could have an ArrayList containing inputs
            // Note: any inputs can be null - null marks "evaluate current" 
            do {
                if (inputs != null) {
                    input = inputs[i];
                }

                string lastOpenedFilename = null;

                try {
                    if (input == null) { // null input means the section exists in THIS RECORD's config file
                        lastOpenedFilename = _filename;
                        using (XmlUtil xml = new XmlUtil(_filename)) {
                            xml.Reader.MoveToContent();
                            objResult = EvaluateRecursive(factory, objResult, keys, 0, xml);
                        }
                    }
                    else {

                        LocationInput deferred = (LocationInput)input; // input is deferred from a <location path=""> element

                        Debug.Trace("config_loc", " Evaluating deferred input " + deferred.path + " " + configKey);

                        lastOpenedFilename = deferred.filename;
                        using (XmlUtil xml = new XmlUtil(deferred.filename)) {
                            xml.Reader.MoveToContent(); // move to root <configuration>
                            xml.StrictReadToNextElement();

                            // search children of <configuration> for <location>
                            while (xml.Reader.Depth > 0) {
                                Debug.Assert(xml.Reader.Depth == 1);

                                if (xml.Reader.Name == "location") {
                                    string locationPath = xml.Reader.GetAttribute("path");

                                    Debug.Trace("config_loc", "  comparing paths " + locationPath + "==" + deferred.subPath);
                                    if (locationPath != null && locationPath == deferred.subPath) {

                                        // evaluate the location section
                                        objResult = EvaluateRecursive(factory, objResult, keys, 0, xml);
                                        break; // we've found the _only_ section for this <location> element, so go on to next file
                                    }
                                }
                                xml.StrictSkipToNextElement();
                            }
                        }
                    }
                }
                catch (Exception e) {
                    throw TranslateXmlParseOrEvaluateErrors(e, lastOpenedFilename);
                }

            } while (inputs != null && ++i < inputs.Count);
            
            section.Result = objResult;
            section.Input = null;

            return objResult;
        }


        // return: 
        //         factory exists: clone of SectionRecord with factory
        //         no factory:     null
        private FactoryRecord HaveFactory(string configKey) {

            if (_factories != null) {
                FactoryRecord record = (FactoryRecord)_factories[configKey];

                if (record != null && (record.Factory != null || record.FactoryTypeName != null)) {
                    if (record.Removed) {
                        return null;
                    }

                    return record.Clone();
                }
            }

            if (!_factoriesNoInherit && _haveParent) { // this is ok to reference outside the lock because it never changes outside the constructor
                return Parent.HaveFactory(configKey);
            }

            // else
            return null;
        }


        private IConfigurationSectionHandler GetFactory(string configKey) {

            Debug.Trace("config_verbose", "  GetFactory " + configKey);

            FactoryRecord factoryRecord = null;

            if (_factories != null) {
                factoryRecord = (FactoryRecord)_factories[configKey];
            }

            if (factoryRecord != null) {
                if (factoryRecord.Removed) {
                    return null;
                }

                if (factoryRecord.Factory != null) {
                    return factoryRecord.Factory;
                }
                else {
                    // if we still have a type string get the type and create the IConfigurationSectionHandler
                    string strFactoryType = factoryRecord.FactoryTypeName;
                    IConfigurationSectionHandler factory = null;
                    object obj = null;

                    InternalSecurityPermissions.Reflection.Assert();

                    try {
                        // Pub s Type GetType (String typeName, Boolean throwOnError) 
                        Type t = Type.GetType(strFactoryType, true); // catch the errors and report them

                        // throws if t does not implement ICSH
                        HandlerBase.CheckAssignableType(_filename, factoryRecord.LineNumber, typeof(IConfigurationSectionHandler), t);
                        
                        // throws MissingMethodException if no valid ctor
                        obj = HttpRuntime.CreateNonPublicInstance(t); 
                        factory = (IConfigurationSectionHandler)obj;
                    }
                    catch (Exception e) {
                        throw new ConfigurationException(SR.GetString(SR.Exception_creating_section_handler), e, _filename, factoryRecord.LineNumber);
                    }
                    finally {
                        // explicitly revert for code clarity
                        CodeAccessPermission.RevertAssert();
                    }
    
                    Debug.Trace("config_verbose", "   adding factory: " + strFactoryType);

                    factoryRecord.Factory = factory;
                    return factory;
                }
            }

            if (!_factoriesNoInherit && _haveParent) { 
                IConfigurationSectionHandler factory = Parent.GetFactory(configKey);
                if (factoryRecord != null) {
                    factoryRecord.Factory = factory;
                }

                return factory;
            }

            // else
            return null;
        }


        private object EvaluateRecursive(IConfigurationSectionHandler factory, object config, string [] keys, int iKey, XmlUtil xml) {
            string name = keys[iKey];
            Debug.Trace("config_eval", "  EvaluateRecursive " + iKey + " " + name);

            HttpConfigurationContext configContext = new HttpConfigurationContext(_requestPath);

            int depth = xml.Reader.Depth;
            xml.StrictReadToNextElement();

            while (xml.Reader.Depth > depth) {
                if (xml.Reader.Name == name) {
                    if (iKey < keys.Length - 1) {
                        config = EvaluateRecursive(factory, config, keys, iKey + 1, xml);
                        continue; // don't call "Skip" -- EvaluteRecursive forwards the reader
                    }
                    else {
                        Debug.Trace("config_eval", "  EvaluateRecursive " + iKey + " calling Create()");
                        Debug.Assert(iKey == keys.Length - 1);

                        int line = xml.Reader.LineNumber;
                        ConfigXmlDocument doc = new ConfigXmlDocument();
                        doc.LoadSingleElement(((IConfigErrorInfo)xml).Filename, xml.Reader);


                        //
                        // Don't trust configuration data in secure apps  See ASURT 125857
                        //
                        NamedPermissionSet namedPermissionSet = HttpRuntime.NamedPermissionSet;
                        // if in a secure app
                        if (namedPermissionSet != null) {
                            // run configuration section handlers as if user code was on the stack
                            namedPermissionSet.PermitOnly();
                        }

                        // 
                        // Call configuration section handler
                        // 
                        // - try-catch is necessary to insulate ASP.NET runtime from exceptions in user config handlers.
                        //   - bubble ConfigurationExceptions
                        //   - wrap all others in ConfigurationException
                        //
                        try {
                            config = factory.Create(config, configContext, doc.DocumentElement);
                        }
                        catch (ConfigurationException) {
                            throw;
                        }
                        catch (XmlException) {
                            throw;
                        }
                        catch (Exception ex) {
                            throw new ConfigurationException(
                                             SR.GetString(SR.Exception_in_config_section_handler),
                                             ex, ((IConfigErrorInfo)xml).Filename, line);
                        }
                    }
                }
                else if (iKey == 0 && xml.Reader.Name == "location") {
                    string locationPath = xml.Reader.GetAttribute("path");
                    if (locationPath == null || locationPath.Length == 0 || locationPath == ".") {
                        Debug.Trace("config_eval", "EvalRec(" + name + ")");
                        config = EvaluateRecursive(factory, config, keys, iKey, xml);
                        continue; // don't call "Skip" -- EvaluteRecursive forwards the reader
                    }
                }
                xml.StrictSkipToNextElement();
            }
            return config;
        }


        private void ScanFactories(XmlUtil xml) {

            // skip <?xml... PI and comments
            xml.Reader.MoveToContent();

            if (xml.Reader.NodeType != XmlNodeType.Element || xml.Reader.Name != "configuration") {
                throw xml.BuildConfigError(SR.GetString(SR.Config_file_doesnt_have_root_configuration, HttpRuntime.GetSafePath(((IConfigErrorInfo)xml).Filename)));
            }
            xml.CheckForUnrecognizedAttributes();

            // move to first child of <configuration>
            xml.StrictReadToNextElement();
            if (xml.Reader.Depth == 1) {
                if (xml.Reader.Name == "configSections") {
                    xml.CheckForUnrecognizedAttributes();
                    ScanFactoriesRecursive(xml, null);
                }
            }
        }


        /// <devdoc>
        ///     Scans the %lt;configSections> section of a configuration file.  The function is recursive 
        ///     to traverse arbitrarily nested config groups.
        ///
        ///         %lt;sectionGroup name="foo">
        ///             %lt;sectionGroup name="bar">
        ///                 %lt;section name="fooBarSection" type="..." />
        ///         ...
        /// </devdoc>
        private void ScanFactoriesRecursive(XmlUtil xml, string configKey) {
            int depth = xml.Reader.Depth;
            xml.StrictReadToNextElement();

            while (xml.Reader.Depth == depth + 1) {
                switch (xml.Reader.Name) {
                case "sectionGroup": 
                    {
                        string tagName = null;

                        while (xml.Reader.MoveToNextAttribute()) {
                            if (xml.Reader.Name != "name") {
                                xml.ThrowUnrecognizedAttribute();
                            }
                            tagName = xml.Reader.Value;
                        }
                        xml.Reader.MoveToElement(); // if on an attribute move back to the element

                        xml.CheckRequiredAttribute(tagName, "name");
                        VerifySectionName(tagName, xml);

                        string tagKey = TagKey(configKey, tagName);

                        FactoryRecord factoryRecord = HaveFactory(tagKey);
                        if (factoryRecord != null && factoryRecord.Group == false) {
                            throw xml.BuildConfigError(
                                        SR.GetString(SR.Tag_name_already_defined));
                        }

                        Debug.Trace("config_verbose", "Adding Group ............. " + tagKey);
                        FactoryRecord record = (FactoryRecord)EnsureFactories[tagKey];
                        if (record == null) {
                            record = new FactoryRecord();
                            record.Group = true;
                            _factories.Add(tagKey, record);
                        }
                        ScanFactoriesRecursive(xml, tagKey);
                        continue;
                    } 
                case "section": 
                    {
                        string tagName = null;
                        string typeName = null;
                        int typeLineNumber = 0;
                        FactoryFlags allowDefinition = FactoryFlags.AllowDefinitionAny;
                        bool bAllowLocation = true;

                        while (xml.Reader.MoveToNextAttribute()) {
                            switch (xml.Reader.Name) {
                            case "name":
                                tagName = xml.Reader.Value;
                                break;
                            case "type":
                                typeName = xml.Reader.Value;
                                typeLineNumber = xml.Reader.LineNumber;
                                break;
                            case "allowLocation":
                                bAllowLocation = xml.GetBooleanAttribute();
                                break;
                            case "allowDefinition":
                                switch (xml.Reader.Value) {
                                case "Everywhere":
                                    break;
                                case "MachineOnly":
                                    allowDefinition = FactoryFlags.AllowDefinitionMachine;
                                    break;
                                case "MachineToApplication":
                                    allowDefinition = FactoryFlags.AllowDefinitionApp;
                                    break;
                                default:
                                    throw xml.BuildConfigError(SR.GetString(SR.Config_section_allow_definition_attribute_invalid));
                                }
                                break;
                            default:
                                xml.ThrowUnrecognizedAttribute();
                                break;
                            }
                        }
                        xml.Reader.MoveToElement(); // if on an attribute move back to the element

                        xml.CheckRequiredAttribute(tagName, "name");
                        xml.CheckRequiredAttribute(typeName, "type");

                        VerifySectionName(tagName, xml);

                        string tagKey = TagKey(configKey, tagName);

                        FactoryRecord factoryRecord = HaveFactory(tagKey);

                        // if the factory already exists => throw an error
                        if (factoryRecord != null && factoryRecord.Removed == false) {

                            // If two vdirs to map to the same physical directory... and a config 
                            // section is registered in the duplicated directory we would throw errors
                            // This 'if' prevents the error in this case.
                            if (factoryRecord.IsEquivalentFactory(typeName, bAllowLocation, allowDefinition) == false) {
                                throw xml.BuildConfigError(
                                            HttpRuntime.FormatResourceString(SR.Tag_name_already_defined, tagName));
                            }
                        }
                        else {
                            Debug.Trace("config_verbose", "Adding Section ............. " + tagKey);
                            factoryRecord = new FactoryRecord();
                            factoryRecord.FactoryTypeName = typeName;
                            factoryRecord.AllowLocation = bAllowLocation;
                            factoryRecord.AllowDefinition = allowDefinition;
                            factoryRecord.LineNumber = typeLineNumber;
                            EnsureFactories[tagKey] = factoryRecord;
                        }
                    }
                    break;

                case "remove": 
                    {
                        string tagKey;
                        {   // limit the scope of tagName so I don't accidentally use it later
                            string tagName = null;

                            while (xml.Reader.MoveToNextAttribute()) {
                                if (xml.Reader.Name != "name") {
                                    xml.ThrowUnrecognizedAttribute();
                                }
                                tagName = xml.Reader.Value;
                            }
                            xml.Reader.MoveToElement();

                            xml.CheckRequiredAttribute(tagName, "name");
                            VerifySectionName(tagName, xml);

                            tagKey = TagKey(configKey, tagName);
                        }

                        FactoryRecord factoryRecord = HaveFactory(tagKey);
                        if (factoryRecord == null) {
                            throw xml.BuildConfigError(
                                        SR.GetString(SR.Could_not_remove_section_handler_not_found));
                        }
                        if (factoryRecord.Locked) {
                            throw xml.BuildConfigError(
                                        SR.GetString(SR.Could_not_remove_section_handler_locked));
                        }
                        if (factoryRecord.Group) {
                            throw xml.BuildConfigError(
                                        SR.GetString(SR.Could_not_remove_section_handler_group));
                        }

                        // in case the section is from the parent make sure it's set at this config node
                        EnsureFactories[tagKey] = factoryRecord;
                        factoryRecord.Removed = true;
                    }
                    break;

                case "clear":
                    {
                        xml.CheckForUnrecognizedAttributes();

                        // We don't support using <clear/> within <sectionGroup> tags
                        //     (only as direct child of <configSections>).
                        // ASURT 82969
                        if (configKey != null) { 
                            throw xml.BuildConfigError(
                                        SR.GetString(SR.Cannot_clear_sections_within_group));
                        }

                        // we cannot clear if any inheritted sections are locked
                        string lockedSection = FindLockedSectionsRecursive();
                        if (lockedSection != null) {
                            throw xml.BuildConfigError(
                                        SR.GetString(SR.Config_section_cannot_clear_locked_section, lockedSection));
                        }

                        if (_factories != null) {
                            foreach (FactoryRecord factoryRecord in _factories.Values) {
                                if ((factoryRecord.Factory != null || factoryRecord.FactoryTypeName != null) && factoryRecord.Group == false) {
                                    factoryRecord.Removed = true;
                                }
                            }
                        }

                        _factoriesNoInherit = true;
                    }
                    break;

                default: 
                    xml.ThrowUnrecognizedElement();
                    break;
                }

                xml.StrictReadToNextElement();
                // unrecognized children are not allowed
                if (xml.Reader.Depth > depth + 1) {
                    xml.ThrowUnrecognizedElement();
                }
            }
        }


        string FindLockedSectionsRecursive() {
            if (_factories != null) {
                lock (this) {
                    // don't have to repeat if-null check because _factories is only created inside ctor
                    foreach (DictionaryEntry de in _factories) {
                        FactoryRecord factoryRecord = (FactoryRecord) de.Value;
                        if ((factoryRecord.Factory != null || factoryRecord.FactoryTypeName != null) && factoryRecord.Locked) {
                            return (string)de.Key;
                        }
                    }
                }
            }

            if (!_factoriesNoInherit && _haveParent) { // this is ok to reference outside the lock because it never changes outside the constructor
                return Parent.FindLockedSectionsRecursive();
            }

            return null;
        }


        private static string TagKey(string configKey, string tagName) {
            string tagKey = (configKey == null) ? tagName : configKey + "/" + tagName;
            Debug.Trace("config_tag", "    tag " + tagKey);
            return tagKey;
        }


        void ScanSectionsRecursive(XmlUtil xml) {
            ScanSectionsRecursive(xml, null, false, false, null);
        }


        void ScanSectionsRecursive(XmlUtil xml, string configKey, bool location, bool lockSections, LocationInput deferred) {
			ArrayList sectionsToLock = null;
			if (lockSections) {
				sectionsToLock = new ArrayList();
			}

            int depth = xml.Reader.Depth;

            // only move to child nodes of not on first level (we've already passed the first <configsections>)
            if (configKey == null && location == false) {
                Debug.Assert(depth == 1);
                depth = 0;
            }
            else {
                xml.StrictReadToNextElement();
            }

            while (xml.Reader.Depth == depth + 1) {
                string tagName = xml.Reader.Name;
                string tagKey = TagKey(configKey, tagName);

                FactoryRecord factory = HaveFactory(tagKey);
                Debug.Assert(factory == null || factory.Factory != null || factory.FactoryTypeName != null);

                if (factory == null) { // factory not found
                    Debug.Trace("config_scan", tagKey + " factory is null");
                    if (tagKey == "location") {
                        if (configKey != null || location) {
                            throw xml.BuildConfigError(
                                        SR.GetString(SR.Location_location_not_allowed));
                        }
                        ScanLocationSection(xml);
                    }
                    else if (tagKey == "configSections") {
                        throw xml.BuildConfigError(
                                     SR.GetString(SR.Client_config_too_many_configsections_elements, tagName));
                    }
                    else {
                        throw xml.BuildConfigError(
                                     SR.GetString(SR.Unrecognized_configuration_section, tagName));
                    }
                }
                else if (factory.Group) {
                    Debug.Trace("config_scan", "Scanning Group " + tagKey);
                    // This is the Recursive part...
                    ScanSectionsRecursive(xml, tagKey, location, lockSections, deferred);
                }
                else if (factory.Locked) {
                    throw xml.BuildConfigError(SR.GetString(SR.Config_section_locked));
                }
                else {
                    Debug.Trace("config_ctracy", "Adding Input for Section " + tagKey);
                    // We have a valid factory that is not a group and is not locked
                    if (location && factory.AllowLocation == false) {
                        throw xml.BuildConfigError(
                                    SR.GetString(SR.Config_section_cannot_be_used_in_location));
                    }

                    VerifyAllowDefinition(factory, deferred, xml);
                    VerifySectionUniqueness(tagKey, xml, deferred);

                    if (deferred == null) {
                        AddInput(tagKey);
                    }
                    else {
                        deferred.sections[tagKey] = new ConfigErrorInfo(xml); // error info is necessary 
                        // to verify allowDefinition in context of location path of use (ASURT 81034)
                    }
                    if (lockSections) {
                        sectionsToLock.Add(tagKey);
                    }

                    xml.StrictSkipToNextElement();
                }
            }

            if (lockSections && sectionsToLock.Count > 0) {

                if (deferred == null) {

                    foreach (string sectionToLock in sectionsToLock) {
                        LockSection(sectionToLock);
                    }
                } else {

                    Hashtable lockTable;

                    if (deferred.lockedSections == null) {
                        lockTable = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);
                        deferred.lockedSections = lockTable;
                    }
                    else {
                        lockTable = deferred.lockedSections;
                    }

                    foreach (string lockedSection in sectionsToLock) {
                        lockTable[lockedSection] = null;
                    }
                }
            }
        }


        /// <devdoc>
        ///     We adopted WMI's concept of uniqueness.  
        ///
        ///     Rules:  Sections have to be unique per config file.  This means
        ///     if there are two &lt;appSettings> sections in the file the configuration
        ///     system will throw.  The &lt;location> section is a special case, in that
        ///
        ///     1) &lt;location> sections in the same file cannot point to the same path
        ///     (kind of like locations with unique paths are still unique).
        ///
        ///     2) In the contents of a &lt;location> section sections have to be unique.
        ///     In other words there can't be two &lt;appSettings> sections in the same
        ///     location element.
        /// </devdoc>
        void VerifySectionUniqueness(string tagKey, XmlUtil xml, LocationInput deferred) {
            bool throwError = false;
            if (deferred == null) {
                SectionRecord section = (SectionRecord) _sections[tagKey];
                if (section != null && section.ToBeEvaluated) {
                    if (section.Input == null) { // we don't allocate the ArrayList if this is the only input
                        throwError = true;
                    }
                    // this node is marked as null in the ArrayList of inputs, and will always be the last entry
                    else if (section.Input.Count > 0 && section.Input[section.Input.Count - 1] == null) {
                        throwError = true;
                    }
                }
            }
            else {
                if (deferred.sections.ContainsKey(tagKey)) {
                    throwError = true;
                }
            }
            if (throwError) {
                throw xml.BuildConfigError(
                    SR.GetString(SR.Config_sections_must_be_unique));
            }
        }

        void VerifyAllowDefinition(FactoryRecord factory, LocationInput deferred, IConfigErrorInfo errorInfo) {

            switch (factory.AllowDefinition) {

                case FactoryFlags.AllowDefinitionAny:
                    break;

                case FactoryFlags.AllowDefinitionMachine:
                    // only allow in machine.config (and don't allow in <loc> with path in machine.config)
                    if (_requestPath != null || deferred != null) {
                        throw XmlUtil.BuildConfigError(
                                    SR.GetString(SR.Config_allow_definition_error_machine),
                                    errorInfo);
                    }
                    break;

                case FactoryFlags.AllowDefinitionApp:
                    if (deferred == null) { // check deferred input at config record of inheritance
                        if (HandlerBase.IsPathAtAppLevel(_requestPath) == PathLevel.BelowApp) {
                            throw XmlUtil.BuildConfigError(
                                        SR.GetString(SR.Config_allow_definition_error_application),
                                        errorInfo);
                        }
                    }
                    break;

                default:
                    Debug.Assert(false, "Invalid allow definition flag");
                    break;
            }
        }


        private void VerifySectionName(string tagName, XmlUtil xml) {
            if (tagName.StartsWith("config")) {
                throw xml.BuildConfigError(
                            SR.GetString(SR.Tag_name_cannot_begin_with_config));
            }
            if (tagName == "location") {
                throw xml.BuildConfigError(
                            SR.GetString(SR.Tag_name_cannot_be_location));
            }
        }


        static internal HttpConfigurationRecord Empty {
            get {
                if (_empty == null) {
                    _empty = new HttpConfigurationRecord("", null, true, "");
                }
                return _empty;
            }
        }


        internal bool IsInheritable {
            get {
                return _inheritable;
            }
        }


        private HandlerMappingMemo _handlerMemo;

        internal HandlerMappingMemo CachedHandler {
            get {
                return _handlerMemo;
            }
            set {
                _handlerMemo = value;
            }
        }


        internal string Path {
            get {
                return _requestPath;
            }
        }


        internal string Filename {
            get {
                return _filename;
            }
        }

        internal bool HasError {
            get {
                return (_error != null);
            }
        }

        internal void CheckCachedException() {
            if (_error != null) {
                throw _error;
            }
        }

        // cannot hold direct reference to parent record, must lookup parent record in cache every time it's needed
        HttpConfigurationRecord Parent {
            get {
                if (_haveParent) {

                    HttpConfigurationRecord parent = HttpConfigurationSystem.CacheLookup(_parentRequestPath);

                    if (parent != null) {
                        return parent;
                    }

                    HttpContext context = HttpContext.Current; // null ref exc
                    if (context != null) {
                        HttpWorkerRequest wr = context.WorkerRequest;
                        return HttpConfigurationSystem.GetComplete(_parentRequestPath, wr);
                    }
                    else {                        
                        // use "contextless" IHttpMapPath
                        return HttpConfigurationSystem.GetComplete(_parentRequestPath, null);
                    }
                }

                throw new InvalidOperationException(SR.GetString(SR.ConfigParentLookupWithNoParent));
            }
        }


        private void AddInput(string sectionKey) {
            Debug.Trace("config_scan", "Adding Input " + sectionKey);

            SectionRecord section = EnsureSection(sectionKey);
            section.ToBeEvaluated = true;
            
            ArrayList inputs = section.Input;

            if (inputs == null) {
                return;
            }

            // We're guaranteed to never AddInput() the same deferred more than once, but we 
            // need to make sure we don't add _this node_ into the evaluation queue more than once.
            // This is easy, because null, representing this node, will always be the last
            // entry in the queue -- so just check the tail, if it's null then we're done.
            if (inputs[inputs.Count - 1] == null) {
                return;
            }

            inputs.Add(null);
        }


        void VerifyLocationPath(string path, XmlUtil xml) {
            /*
            from http://www.w3.org/Addressing/

              reserved    = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" |
                            "$" | ","

            from OS dialog box

              A filename cannot contain any of the following characters:

                \ / :  * ? " < > | 
            */
            
            if (path.Length != 0 && path != ".") {

                // throw error if found
                const string invalidFirstCharacters = "./\\";  // if you change this also update error message used below
                if (invalidFirstCharacters.IndexOf(path[0]) != -1) {
                    throw xml.BuildConfigError(
                                SR.GetString(SR.Location_path_invalid_first_character));
                }

                // combination of URI reserved characters and OS invalid filename characters, minus / (allowed reserved character)
                const string invalidCharacters = ";?:@&=+$,\\*\"<>|"; // if you change this also update error message used below
                if (path.IndexOfAny(invalidCharacters.ToCharArray()) != -1) {
                    throw xml.BuildConfigError(
                                SR.GetString(SR.Location_path_invalid_character));
                }
            }
        }


        void ScanLocationSection(XmlUtil xml) {

            string subPath = null;
            bool bAllowOverride = true;

            while (xml.Reader.MoveToNextAttribute()) {
                switch (xml.Reader.Name) {
                case "path":
                    subPath = xml.Reader.Value;
                    break;
                case "allowOverride":
                    bAllowOverride = xml.GetBooleanAttribute();
                    break;
                default:
                    xml.ThrowUnrecognizedAttribute();
                    break;
                }
            }
            xml.Reader.MoveToElement(); // if on an attribute move back to the element

            Debug.Trace("config_loc", "Reading <location> with subPath:" + subPath);

            bool bLockSections = !bAllowOverride;

            if (subPath != null) {
                subPath = subPath.Trim();
                VerifyLocationPath(subPath, xml);
            }

            if (subPath == null || subPath.Length == 0 || subPath == ".") {
                ScanSectionsRecursive(xml, null, true, bLockSections, null);
                return;
            }


            string targetPath = null;
            if (_requestPath != null) { 
                targetPath = _requestPath + "/" + subPath;
            }
            else {
                // scanning machine-level config file -- need to worry about site names as part of path="" attr.
                string siteName = HttpConfigurationSystem.SiteName;
                Debug.Trace("config_loc", "<location> siteName: \"" + siteName + "\" subPath: \"" + subPath + "\"");

                if (siteName != null) {
                    Debug.Trace("config_loc", "<location> Test: valid siteName branch");

                    if (stringStartsWithIgnoreCase(subPath, siteName)) {
                        targetPath = subPath.Substring(siteName.Length);
                        Debug.Trace("config_loc", "<location> Test: targetPath branch :" + targetPath);

                        if (targetPath == "/") { // we don't create a config record for "/", so translate it into "", which means root-app-level
                            targetPath = "";
                        }
                    }
                    else {
                        Debug.Trace("config_loc", "<location> Test: return branch");
                    }
                }

                // if the site name doesn't match or this site doesn't have a name 
                // skip this location section and continue scanning the rest of the file
                if (targetPath == null) {
                    xml.StrictSkipToNextElement();
                    return;
                }
            }

            Debug.Trace("config_loc", "<location> adding deferredInput " + targetPath);

            EnsureDeferred();

            LocationInput deferredInput = (LocationInput) _deferredPaths[subPath];

            if (deferredInput == null) {
                deferredInput = new LocationInput();
                deferredInput.path = targetPath;
                deferredInput.subPath = subPath;
                deferredInput.filename = _filename;
                _deferredList.Add(deferredInput);
                _deferredPaths.Add(subPath, deferredInput);
            }
            else {
                throw xml.BuildConfigError(
                            SR.GetString(SR.Config_location_paths_must_be_unique));
            }

            ScanSectionsRecursive(xml, null, true, bLockSections, deferredInput);
        }


        SectionRecord EnsureSection(string configKey) {
            SectionRecord section = (SectionRecord)_sections[configKey];
            if (section == null) {
                section = new SectionRecord();
                lock (_sections.SyncRoot) {
                    _sections[configKey] = section;
                }
            }
            return section;
        }

        Hashtable EnsureFactories {
            get {
                if (_factories == null) {
                    _factories = new Hashtable();
                }
                return _factories;
            }
        }

        void EnsureDeferred() {
            if (_deferredList == null) {
                _deferredList = new ArrayList();
                _deferredPaths = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);
            }
        }

        // called from ctor and from ScanLocation -- both need to lock factories [one inherited (ctor), one inline (ScanLoc)]
        void LockSection(string sectionKey) {
            FactoryRecord factory = (FactoryRecord)EnsureFactories[sectionKey];

            if (factory == null) {
                // HaveFactory returns a clone of the parent's FactoryRecord
                factory = HaveFactory(sectionKey);
				Debug.Assert(factory != null);
                // set the clone as our FactoryRecord for this section
                _factories[sectionKey] = factory;
            }

            factory.Locked = true;
        }


        // see comment in HttpConfigurationSystem.CompseConfig near call to AddDirectoryDependency
        internal void OnDirectoryChange(Object sender, FileChangeEvent e) {
            if (e.Action == FileAction.Error ||
                e.Action == FileAction.Removed ||
                e.Action == FileAction.Modified)
            {
                HttpRuntime.CacheInternal.Remove(HttpConfigurationSystem.CacheKey(_requestPath));
            }
        }


        [Conditional("CONFIG_PERF")]
        internal static void TracePerf(string msg) {
            #if CONFIG_PERF
                SafeNativeMethods.OutputDebugString(msg + "\n");
            #endif
        }

        #if CONFIG_PERF
        internal static string FormatPerfTime(float f) {
            return f.ToString("0.000");
        }
        #endif

        static ConfigurationException TranslateXmlParseOrEvaluateErrors(Exception e, string filename) {
            ConfigurationException ce = e as ConfigurationException;
            if (ce != null) {
                return ce;
            }

            XmlException xe = e as XmlException;
            if (xe != null) {
                return new ConfigurationException( // other errors: wrap in ConfigurationException and give as much info as possible
                                xe.Message, 
                                xe,
                                filename, 
                                xe.LineNumber);
            }
        
            return new ConfigurationException( // other errors: wrap in ConfigurationException and give as much info as possible
                            SR.GetString(SR.Error_loading_XML_file, HttpRuntime.GetSafePath(filename), e.Message),
                            e,
                            filename,
                            0); // no line# info
        }


        /// <devdoc>XmlTextReader Helpers...</devdoc>
        internal class XmlUtil : IDisposable, IConfigErrorInfo {

            private string        _filename;
            private XmlTextReader _reader;

             string IConfigErrorInfo.Filename {
                get { return _filename; } 
            }

            internal XmlTextReader Reader {
                get { return _reader; }
            }

             int IConfigErrorInfo.LineNumber {
                get { return Reader.LineNumber; }
            }

            internal XmlUtil(string localFileName) {
                _filename = localFileName;
                OpenXmlTextReader();
            }

            private void OpenXmlTextReader() {
                
                (new FileIOPermission(FileIOPermissionAccess.Read | FileIOPermissionAccess.PathDiscovery, _filename)).Assert();

                try {
                    _reader = new XmlTextReader(_filename);

                    // if this line is removed, the XmlTextReader delay-creates the stream
                    _reader.MoveToContent(); // actually create the stream (force access to the file)
                }
                catch {
                    Dispose();
                    throw;
                }
                finally {
                    // explicitly revert ps -- for code clarity, advised by ChrisAn during Fx Security Review
                    CodeAccessPermission.RevertAssert();
                }
            }

            public void Dispose() {
                if (_reader != null) {
                    _reader.Close();
                    _reader = null;
                }
            }


            internal ConfigurationException BuildConfigError(string message) {
                return BuildConfigError(message, this);
            }
            internal ConfigurationException BuildConfigError(string message, Exception inner) {
                return BuildConfigError(message, inner, this);
            }
            static internal ConfigurationException BuildConfigError(string message, IConfigErrorInfo errorInfo) {
                return new ConfigurationException(message, errorInfo.Filename, errorInfo.LineNumber);
            }
            static internal ConfigurationException BuildConfigError(string message, Exception inner, IConfigErrorInfo errorInfo) {
                return new ConfigurationException(message, inner, errorInfo.Filename, errorInfo.LineNumber);
            }


            internal void StrictReadToNextElement() {
                Debug.Trace("config_xml", " rrrr Reading " + _reader.Name);
                while (_reader.Read()) {
                    // optimize for the common case
                    if (_reader.NodeType == XmlNodeType.Element) {
                        Debug.Trace("config_xml", " rrrr End Read " + _reader.Name);
                        return;
                    }

                    CheckIgnorableNodeType();
                }
                Debug.Trace("config_xml", " rrrr End Read " + _reader.Name);
            }

            internal void StrictSkipToNextElement() {
                Debug.Trace("config_xml", " ssss Skipping " + _reader.Name);
                _reader.Skip();

                while (!_reader.EOF && _reader.NodeType != XmlNodeType.Element) {
                    CheckIgnorableNodeType();
                    _reader.Read();
                }
                Debug.Trace("config_xml", " ssss End Skip " + _reader.Name);
            }

            internal void CheckIgnorableNodeType() {
                if (_reader.NodeType != XmlNodeType.Comment 
                        && _reader.NodeType != XmlNodeType.EndElement 
                        && _reader.NodeType != XmlNodeType.Whitespace 
                        && _reader.NodeType != XmlNodeType.SignificantWhitespace) {
                    HandlerBase.CheckBreakOnUnrecognizedElement();
                    throw BuildConfigError(SR.GetString(SR.Config_base_unrecognized_element));
                }
            }

            internal void ThrowUnrecognizedAttribute() {
                throw BuildConfigError(
                            SR.GetString(SR.Config_base_unrecognized_attribute, _reader.Name));
            }

            internal void CheckForUnrecognizedAttributes() {
                if (_reader.MoveToNextAttribute()) {
                    ThrowUnrecognizedAttribute();
                }
            }

            internal void ThrowRequiredAttribute(string attrib) {
                throw BuildConfigError(
                            SR.GetString(SR.Missing_required_attribute, attrib, _reader.Name));
            }

            internal void CheckRequiredAttribute(object o, string attrName) {
                if (o == null) {
                    ThrowRequiredAttribute(attrName);
                }
            }

            internal void ThrowUnrecognizedElement() {
                // help debug stress failure ASURT 140745
                HandlerBase.CheckBreakOnUnrecognizedElement();
                    
                throw BuildConfigError(
                            SR.GetString(SR.Config_base_unrecognized_element));
            }

            internal bool GetBooleanAttribute() { 
                if (_reader.Value == "true") {
                    return true;
                }
                else if (_reader.Value == "false") {
                    return false;
                }

                throw BuildConfigError(
                            SR.GetString(SR.Invalid_boolean_attribute, _reader.Name));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\httpconfigurationsystem.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpConfigurationSystem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * config system: finds config files, loads config
 * factories, filters out relevant config file sections, and
 * feeds them to the factories to create config objects.
 */
namespace System.Web.Configuration {
    using Microsoft.Win32;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Configuration;
    using System.IO;
    using System.Threading;
    using System.Web;
    using System.Web.Caching;
    using System.Xml;
    using System.Web.Util;
    using CultureInfo = System.Globalization.CultureInfo;
    using Debug = System.Web.Util.Debug;
    using UnicodeEncoding = System.Text.UnicodeEncoding;
    using UrlPath = System.Web.Util.UrlPath;
    using System.Globalization;
    
    /// <include file='doc\HttpConfigurationSystem.uex' path='docs/doc[@for="HttpConfigurationSystem"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///     The ASP.NET configuration system. Relevant method is "ComposeConfig", called through "GetComplete".
    /// </devdoc>
    internal class HttpConfigurationSystem : HttpConfigurationSystemBase {
        internal const String WebConfigFileName = "web.config";

        // This is for use when we don't have an HttpContext, ie. on threads created 
        // by users to do asyncrounous processing, and also during ASP.NET initialization.  
        // We by default assume the thread belongs to the application 
        // path.  We also store the mappings to all config paths below 
        // the applicaton level, in case those config records expire from 
        // the cache and need to be recreated when there is no context.
        static ContextlessMapPath s_contextlessMapPath;
        static bool s_siteNameSet; // = false;
        static string s_siteName;  // = null;
        static FileChangeEventHandler s_fileChangeEventHandler;
        static readonly bool s_breakOnUnrecognizedElement = ReadBreakOnUnrecognizedElement();

        internal HttpConfigurationSystem() {
        }

        static internal void Init(HttpContext context) {

            // create 'default' mapping in cases when there is no context
            s_contextlessMapPath = new ContextlessMapPath(); 

            string path = context.Request.ApplicationPath;
            Debug.Trace("config_verbose", "App path:" + path);
            s_contextlessMapPath.ApplicationPath = path;

            IHttpMapPath configMap = context.WorkerRequest;
            while (path != null) {
                Debug.Trace("config_verbose", path + ":" + configMap.MapPath(path));
                s_contextlessMapPath.Add(path, configMap.MapPath(path));
                path = ParentPath(path);
            }

 
            Debug.Trace("config_verbose", "Machine path:" + configMap.MachineConfigPath);
            s_contextlessMapPath.SetMachineConfigPath(configMap.MachineConfigPath);
        }

        // This calls back into the ISAPI dll to query the metabase to get
        // the /LM/W3SVC/<site#>/ServerComment, which is where the IIS Admin tool
        // puts the name of the site.
        internal static string SiteName {
            get {
                if (!s_siteNameSet) { // This works ONLY IF we're guaranteed to have a context available thru HttpContext.Current ON CONFIG INIT (when machine.config config record is created).
                    s_siteNameSet = GetSiteNameFromISAPI();
                }
                return s_siteName;
            }
        }                    


        static bool GetSiteNameFromISAPI() {
            Debug.Trace("config_loc", "GetSiteNameFromISAPI()");
            HttpContext context = HttpContext.Current;
            if (context != null) {

                string metabaseAppKey = context.Request.ServerVariables["INSTANCE_META_PATH"];
                const string KEY_LMW3SVC = "/LM/W3SVC/";
                Debug.Assert(metabaseAppKey.StartsWith(KEY_LMW3SVC));
                string appNumber = metabaseAppKey.Substring(KEY_LMW3SVC.Length-1);
                //string appServerComment = "/" + appNumber + "/ServerComment";
                Debug.Trace("config_loc", "appNumber:" + appNumber + " INSTANCE_META_PATH:" + metabaseAppKey);

                UnicodeEncoding encoding = new UnicodeEncoding();

                // null-terminate appNumber and convert to byte array
                byte [] byteAppNumber = encoding.GetBytes(appNumber + "\0"); 
                
                int retVal = 2;
                byte [] outBytes = new byte[64];
                while (retVal == 2) {
                    retVal = context.CallISAPI(UnsafeNativeMethods.CallISAPIFunc.GetSiteServerComment, 
                        byteAppNumber, outBytes);
                    if (retVal == 2) {
                        if (outBytes.Length > 1024) { // should never happen
                            throw new ConfigurationException(HttpRuntime.FormatResourceString(
                                SR.Config_site_name_too_long, 
                                metabaseAppKey));
                        }
                        outBytes = new byte[outBytes.Length * 2];
                    }
                }

                // find WCHAR null terminator in byte array
                int i = 0;
                while (i + 1 < outBytes.Length && (outBytes[i] != 0 || outBytes[i + 1] != 0))
                    i += 2;

                // decode up to null terminator
                s_siteName = encoding.GetString(outBytes, 0, i);
                Debug.Trace("config_loc", "i: " + i + " site name:" + s_siteName);

                return true;
            }
            else {
                Debug.Trace("config_loc", "could not query site name.  No Context.");
            }

            return false; // keep trying to evaluate
        }

        
        internal static HttpConfigurationRecord GetCompleteForApp() {
            if (s_contextlessMapPath != null) {
                return GetComplete(s_contextlessMapPath.ApplicationPath, s_contextlessMapPath);
            }
            else {
                return null;
            }
        }


        // return application-level config record
        internal static HttpConfigurationRecord GetComplete() {
            if (s_contextlessMapPath != null) {
                return GetComplete(s_contextlessMapPath.ApplicationPath, s_contextlessMapPath);
            }
            else {
                return GetComplete(null, null);
            }
        }

        /*
         * This static method called by pathmap-aware users of configuration
         * (namely HttpContext, HttpWorkerRequest)
         */
        internal /*public*/ static HttpConfigurationRecord GetComplete(String reqpath, IHttpMapPath configmap) {
            if (_system == null)
                return HttpConfigurationRecord.Empty;

            return _system.ComposeConfig(reqpath, configmap);
        }


        internal /*public*/ static string[] GetConfigurationDependencies(String reqpath, IHttpMapPath configmap) {
            if (_system == null)
                return null;

            return _system.InternalGetConfigurationDependencies(reqpath, configmap);
        }


        /*
         * GetConfigurationDependencies
         *
         * Returns an array of filenames who are dependancies of the given path.
         * Used by batch compilation.
         */
        internal string[] InternalGetConfigurationDependencies(String reqPath, IHttpMapPath configMap) {

            // remove ending "/"
            if (reqPath != null && reqPath.Length > 0 && reqPath[reqPath.Length - 1] == '/') {
                reqPath = reqPath.Substring(0, reqPath.Length - 1);
            }

            ArrayList configFiles = new ArrayList();
            string path;

            for (path = reqPath;;path = ParentPath(path)) {

                // escape from root
                if (path == null) {
                    configFiles.Add(configMap.MachineConfigPath);
                    break;
                }

                String configfile;
                String mappedfile;

                if (IsPath(path))
                    mappedfile = configMap.MapPath(path);
                else
                    mappedfile = null; // means path was not a path

                if (IsDirectory(mappedfile)) {
                    // for the directory case, grab the config file
                    configfile = Path.Combine(mappedfile, WebConfigFileName);
                    if (FileUtil.FileExists(configfile))
                        configFiles.Add(configfile);
                }
            }

            string [] returnValue = new string[configFiles.Count];

            for (int i = 0; i < configFiles.Count; ++i)
                returnValue[i] = (string)configFiles[i];
        
            return returnValue;
        }


        internal static string CacheKey(string vpath) {
            string pathCi;

            if (vpath == null)
                pathCi = "root";
            else
                pathCi = vpath.ToUpper(CultureInfo.InvariantCulture);

            const string ConfigKey = "System.Web.HttpConfig";
            return ConfigKey + ":" + pathCi;
        }


        // look up item in cache (case-insensitive)
        internal static HttpConfigurationRecord CacheLookup(string vpath) {

            string cachekey = CacheKey(vpath);

            HttpConfigurationRecord record = (HttpConfigurationRecord)HttpRuntime.CacheInternal.Get(cachekey);

            Debug.Trace("config_verbose", "Cache " + 
                ((record == null) ? "miss" : "hit") + " on \"" + cachekey + "\"");

            if (record != null)
                record.CheckCachedException();

            return record;
        }


        static string QuoteString(string str) {
            if (str == null) {
                return "null";
            }
            return "\"" + str + "\"";
        }

        // This function is named after a comment in the original code that sums up what it does nicely. 
        //  // now we zip up the path, composing config
        HttpConfigurationRecord ComposeConfig(String reqPath, IHttpMapPath configmap) {

            // remove ending "/"
            if (reqPath != null && reqPath.Length > 0 && reqPath[reqPath.Length - 1] == '/') {
                reqPath = reqPath.Substring(0, reqPath.Length - 1);
            }

            if (configmap == null && reqPath != null) {
                //
                // s_contextlessMapPath only works for paths from machine-level to application-level
                // This is only exposed to internal APIs, so this is just to make sure we don't break ourselves.
                //
                Debug.Assert(reqPath != null && (reqPath.Length > s_contextlessMapPath.ApplicationPath.Length || 
                        s_contextlessMapPath.ApplicationPath.Substring(0, reqPath.Length) == reqPath));

                configmap = s_contextlessMapPath;
            }
            // QUICK: look up record in cache (case-insensitive)

            // 
            // This is the common case because most pages are requested more than once every five minutes
            // Note: will be null on first invocation
            //
            HttpConfigurationRecord configRecord = CacheLookup(reqPath);

            if (configRecord != null) {
                return configRecord;
            }

            DateTime utcStart = DateTime.UtcNow;

            // SLOW: hunt around

            //
            // Next, we start from the end of the request path and work our way toward the machine-level config
            // record.  The first record we find is the one we use.  Later we'll walk back down the path stack
            // building all the records that weren't found in the cache.
            //
            // Note: On first invocation for this appdomain we won't find anything in the cache, so we'll compose
            //      all config records from machine-level down.
            //
            ArrayList pathStack = new ArrayList();
            String path = reqPath;
            HttpConfigurationRecord parentRecord = null;
            for (;;) {
                // stack child
                pathStack.Add(path);

                // escape from root
                if (path == null)
                    break;

                // go to parent
                path = ParentPath(path);

                // look it up
                parentRecord = CacheLookup(path);

                if (parentRecord == null) {
                    configRecord = null;
                }
                else {
                    if (parentRecord.IsInheritable) { // only inherit from directory ConfigRecords, else keep looking
                        Debug.Trace("config", "Config located in cache " + QuoteString(path));
                        break;
                    }
                    configRecord = parentRecord;
                }
            }

            // now we zip down the path, composing config

            //
            // We walk down the path ...
            // For each directory, we build a config record and add a dependency on the config file
            // The first path that doesn't map to a directory we assume 
            //   is a file (leaf in the config system and not inheritable)
            // Anything left in the path stack after the file* is assumed to 
            //      be pathinfo** and is ignored.
            //
            // Notes:
            // * - we never verify the physical file, it's assumed if the mapped path
            //      is not a directory (is this correct behavior?)
            // ** - pathinfo is the possible junk on the path after the file path:
            //      example: http://localhost/myapp/foo.aspx/bar
            //          /myapp/foo.aspx - file path (see Request.FilePath)
            //          /bar            - pathinfo
            //
            bool isDir = true;
            CacheInternal cacheInternal = HttpRuntime.CacheInternal;

            for (int i = pathStack.Count - 1; i >= 0 && isDir == true; i--) {
                String configFile = null;
                String mappedPath = null;
                Hashtable cachedeps = null;

                path = (String)pathStack[i];


                if (path == null) {
                    mappedPath = "";
                    if (configmap == null) {
                        configFile = HttpConfigurationSystemBase.MachineConfigurationFilePath;
                    }
                    else {
                        configFile = configmap.MachineConfigPath;
                    }

                    // null MachineConfigPath -> never cache config - always return an empty record.
                    if (configFile == null)
                        return HttpConfigurationRecord.Empty;

                    AddFileDependency(configFile);
                }
                else {
                    if (IsPath(path)) {
                        mappedPath = configmap.MapPath(path);

                        if (IsDirectory(mappedPath)) {
                            // for the directory case, grab the config file and a dependency on it
                            configFile = Path.Combine(mappedPath, WebConfigFileName);
                            AddFileDependency(configFile);
                        }
                        else {
                            // otherwise, we're a file and we go ahead and compute as a file
                            isDir = false; // break loop (after record is built)
                            
                            // we need make the cache item dependent on the mapped file location
                            // in case it becomes a directory.
                            if (mappedPath != null) {
                                Debug.Assert(cachedeps == null, "ctracy investigation - cachedeps == null");
                                cachedeps = new Hashtable(SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);
                                cachedeps[mappedPath] = mappedPath;
                            }
                        }
                    }
                }

                configRecord = new HttpConfigurationRecord(configFile, parentRecord, /*mappedPath,*/ isDir, path);
                string key = CacheKey(path);
                CacheDependency dependency = GetCacheDependencies(cachedeps, utcStart);

                Debug.Trace("config_verbose", "Inserting :" + path);

                if (IsBreakOnUnrecognizedElement) {
                    // If the registry key is set to debug the rare 'Unrecognized Element'
                    // stress error, lets try to reproduce the error by having an absolute
                    // expiry of 5 minutes (this will cause us to re-read config much more
                    // often.  Before it took memory pressure.
                    DateTime absouteExpiry = DateTime.UtcNow + new TimeSpan(0,5,0);
                    cacheInternal.UtcInsert(key, configRecord, dependency, absouteExpiry, Cache.NoSlidingExpiration);
                }
                else {
                    if (configRecord.HasError) {
                        cacheInternal.UtcInsert(key, configRecord, dependency, 
                                                DateTime.UtcNow.AddSeconds(5), Cache.NoSlidingExpiration);
                    }
                    else {
                        // default: default cache priority, sliding expiration 
                        // this will make us rarely expire, config is expensive
                        cacheInternal.UtcInsert(key, configRecord, dependency);
                    }
                }
                    
                // This is to wire-up notification of directories who exist (without a config file) and
                // are then deleted.  In this case we don't want to restart the appdomain because no config information has 
                // changed.  We do want to remove the cache record and recreate it on the next request.  (Something in 
                // the cache record might be assuming the directory still exists.)
                if (isDir && !FileUtil.FileExists(configFile) && HandlerBase.IsPathAtAppLevel(path) == PathLevel.BelowApp) {
                    //AddDirectoryDependency(mappedPath, path, configRecord);
                }

                configRecord.CheckCachedException();
                parentRecord = configRecord;
            }

            return configRecord;
        }


        private static CacheDependency GetCacheDependencies(Hashtable cachedeps, DateTime utcStart) {
            if (cachedeps == null)
                return null;

            String[] filenames = new String[cachedeps.Count];
            IDictionaryEnumerator e;
            int j;

            for (e = cachedeps.GetEnumerator(), j = 0; e.MoveNext(); j++) {
                filenames[j] = (String)e.Value;
            }

            return new CacheDependency(false, filenames, utcStart);
        }


        internal static void AddFileDependency(String file) {
            if (file == null || file.Length == 0)
                return;

            // doesn't need to be threadsafe, this will always happen on first request init
            if (s_fileChangeEventHandler == null) {
                s_fileChangeEventHandler = new FileChangeEventHandler(_system.OnConfigChange);
            }

            HttpRuntime.FileChangesMonitor.StartMonitoringFile(
                file,
                s_fileChangeEventHandler);
            
        }


        internal void OnConfigChange(Object sender, FileChangeEvent e) {
            HttpRuntime.OnConfigChange(sender, e);
        }


        private static String ParentPath(String path) {
            if (path == null || path.Length == 0 || path[0] != '/')
                return null;

            int index = path.LastIndexOf('/');
            if (index < 0)
                return null;

            return path.Substring(0, index);
        }


        private static bool IsPath(String path) {
            if (path != null && path.Length > 0 && path[0] != '/') {
                return false;
            }

            return true;
        }


        private static bool IsDirectory(String dir) {
            // treat null (nonpath) as file

            if (dir == null)
                return false;

            // ends with slash: the rule is false
            // (isn't that counterintuitive?)
            // We're treating it as an empty filename

            if (dir.Length > 0 && dir[dir.Length - 1] == '\\') {

                // the form "X:\" return true
                // this allows web apps to map to the root file system path
                if (dir.Length > 1 && dir[1] == ':') {
                    // fall through to DirectoryExists...
                }
                else {
                    return false;
                }
            }

            return FileUtil.DirectoryExists(dir);
        }


        // help debug stress failure ASURT 140745
        static bool ReadBreakOnUnrecognizedElement() {
            RegistryKey regKey = null;
            string breakString = null;
            try {
                regKey = Registry.LocalMachine.OpenSubKey("Software\\Microsoft\\ASP.NET");
                if (regKey != null) {
                    breakString = (string)regKey.GetValue("BreakOnUnrecognizedElement");
                }
            }
            catch {
            }
            finally {
                if (regKey != null) 
                    regKey.Close();
            }
            
            Debug.Trace("config_break", "ReadBreakOnUnrecognizedElement:" + (breakString == null ? "null" : breakString));
            return breakString == "true";
        }
        
        // help debug stress failure ASURT 140745
        internal static bool IsBreakOnUnrecognizedElement {
            get {
                return s_breakOnUnrecognizedElement;
            }
        }


#if CONFIG_PERF
        /// <devdoc>
        ///     This is used to do timing on the configuration system.
        /// </devdoc>
        internal static void FlushConfig(string path) {

            // remove ending "/"
            if (path != null && path.Length > 0 && path[path.Length - 1] == '/') {
                path = path.Substring(0, path.Length - 1);
            }

            CacheInternal cacheInternal = HttpRuntime.CacheInternal;

            for (;;) {

                object o = cache.Remove(CacheKey(path));
                /*
                if (o == null)
                    throw new InvalidOperationException("ConfigurationRecord not found in cache for removal.  FlushConfig failed. " + path);
                    */

                if (path == null) // break _after_ machine.config has been flushed
                    break;

                // go to parent
                path = ParentPath(path);
            }

            HttpContext context = HttpContext.Current;
            // this looks stupid (and it is) but it clears the configuration record cached in the context
            context.ConfigPath = context.ConfigPath;
        }
#endif
    }

#if CONFIG_PERF
    /// <include file='doc\HttpConfigurationSystem.uex' path='docs/doc[@for="HttpConfigPerf"]/*' />
    public class HttpConfigPerf {
        /// <include file='doc\HttpConfigurationSystem.uex' path='docs/doc[@for="HttpConfigPerf.FlushConfig"]/*' />
        public static void FlushConfig(string path) {
            HttpConfigurationSystem.FlushConfig(path);
        }
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\httphandlerssectionhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpHandlersSectionHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Config related classes for HttpApplication
 */

namespace System.Web.Configuration {

    using System.Collections;
    using System.Configuration;
    using System.ComponentModel;
    using System.IO;
    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Reflection;
    using System.Globalization;
    using System.Web.SessionState;
    using System.Web.Security;
    using System.Web.Util;
    using System.Xml;

    /*
     * Simple Handlers config factory
     *
     * syntax:
     *
     *   <handlers>
     *      <clear /> <!-- directive clears all previously set handlers -->
     *      <add verb="*"    path="*.foo" type="System.FooHandler" />
     *      <add verb="GET"  path="*.aspx" type="System.GetHandler" />
     *      <add verb="POST" path="*.aspx" type="System.PostHandler" />
     *   </handlers>
     *
     * output:
     *
     *   ArrayList of HandlerMappings
     */
    /// <include file='doc\HttpHandlersSectionHandler.uex' path='docs/doc[@for="HttpHandlersSectionHandler"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    internal class HttpHandlersSectionHandler : IConfigurationSectionHandler {

        internal HttpHandlersSectionHandler() {
        }

        public virtual object Create(Object parent, Object configContextObj, XmlNode section) {
            // if called through client config don't even load HttpRuntime
            if (!HandlerBase.IsServerConfiguration(configContextObj))
                return null;


            return InternalCreate(parent, section);
        }

        /*
         * Create
         *
         * Given a partially composed config object (possibly null)
         * and some input from the config system, return a
         * further partially composed config object
         */
        internal Object InternalCreate(Object parent, XmlNode node) {
            HandlerMap map;

            // start list as shallow clone of parent

            if (parent == null)
                map = new HandlerMap();
            else
                map = new HandlerMap((HandlerMap)parent);

            map.BeginGroup();

            // process XML section
            HandlerBase.CheckForUnrecognizedAttributes(node);

            foreach (XmlNode child in node.ChildNodes) {

                // skip whitespace and comments

                if (HandlerBase.IsIgnorableAlsoCheckForNonElement(child))
                    continue;

                // process <add> and <clear> elements

                if (child.Name.Equals("add")) {
                    String verb = HandlerBase.RemoveRequiredAttribute(child, "verb");
                    String path = HandlerBase.RemoveRequiredAttribute(child, "path");
                    String classname = HandlerBase.RemoveRequiredAttribute(child, "type");

                    int phase = 1;
                    XmlNode phaseNode = HandlerBase.GetAndRemoveIntegerAttribute(child, "phase", ref phase);
                    if (phaseNode != null)
                        ValidatePhase(phase, phaseNode);

                    bool validate = true;
                    HandlerBase.GetAndRemoveBooleanAttribute(child, "validate", ref validate);


                    HandlerBase.CheckForUnrecognizedAttributes(child);
                    HandlerBase.CheckForChildNodes(child);

                    try {
                        map.Add(new HandlerMapping(verb, path, classname, !validate), phase);
                    }
                    catch (Exception e) {
                        throw new ConfigurationException(e.Message, e, child);
                    }
                }
                else if (child.Name.Equals("remove")) {
                    String verb = HandlerBase.RemoveRequiredAttribute(child, "verb");
                    String path = HandlerBase.RemoveRequiredAttribute(child, "path");
                    bool validate = true;
                    HandlerBase.GetAndRemoveBooleanAttribute(child, "validate", ref validate);


                    HandlerBase.CheckForUnrecognizedAttributes(child);
                    HandlerBase.CheckForChildNodes(child);

                    if (!map.RemoveMapping(verb, path) && validate) {
                        throw new ConfigurationException(
                                                        HttpRuntime.FormatResourceString(SR.No_mapping_to_remove, verb, path),
                                                        child);
                    }
                }
                else if (child.Name.Equals("clear")) {
                    int phase = 1;
                    XmlNode phaseNode = HandlerBase.GetAndRemoveIntegerAttribute(child, "phase", ref phase);
                    HandlerBase.CheckForUnrecognizedAttributes(child);
                    HandlerBase.CheckForChildNodes(child);

                    if (phaseNode == null) {
                        map.ClearAll();
                    }
                    else {
                        ValidatePhase(phase, phaseNode);
                        map.ClearPhase(phase);
                    }
                }
                else {
                    HandlerBase.ThrowUnrecognizedElement(child);
                }
            }

            map.EndGroup();

            return map;
        }

        private static void ValidatePhase(int phase, XmlNode phaseNode) {
            if (phase < 0 || phase > 1) {
                throw new ConfigurationException(
                                HttpRuntime.FormatResourceString(SR.Phase_attribute_out_of_range), 
                                phaseNode);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\httpmodulesconfiguration.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpModulesConfiguration.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Config related classes for HttpApplication
 */

namespace System.Web.Configuration {

    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Collections;
    using System.Reflection;
    using System.Globalization;
    using System.Web;
    using System.Web.SessionState;
    using System.Web.Security;
    using System.Web.Util;

    /*
     * An object that holds modules configuration
     */
    internal class HttpModulesConfiguration {
        private ArrayList _list;

        internal HttpModulesConfiguration() {
            _list = new ArrayList();
        }
        internal HttpModulesConfiguration(HttpModulesConfiguration parent) {
            _list = new ArrayList(parent._list);
        }

        internal int Count {
            get { return _list.Count; }
        }

        internal HttpModuleCollection CreateModules() {
            HttpModuleCollection modules = new HttpModuleCollection();

            foreach (ModulesEntry m in _list) {
                modules.AddModule(m.ModuleName, m.Create());
            }

            modules.AddModule("DefaultAuthentication", new System.Web.Security.DefaultAuthenticationModule());

            return modules;
        }

        internal void Add(String moduleName, String className, bool insert) {
            ModulesEntry entry = new ModulesEntry(moduleName,  className);

            if (insert)
                _list.Insert(0, entry);
            else
                _list.Add(entry);
        }

        internal bool ContainsEntry(String name) {
            foreach (ModulesEntry m in _list) {
                if (String.Compare(m.ModuleName, name, true, CultureInfo.InvariantCulture) == 0)
                    return true;
            }

            return false;
        }

        internal bool RemoveEntry(String name) {
            int n = _list.Count;
            bool found = false;

            for (int i = 0; i < n; i++) {
                ModulesEntry m = (ModulesEntry)_list[i];

                if (String.Compare(m.ModuleName, name, true, CultureInfo.InvariantCulture) == 0) {
                    // inefficient if there are many matches
                    _list.RemoveAt(i);
                    i--;
                    n--;
                    found = true;
                }
            }

            return found;
        }

        internal void RemoveRange(int start, int count) {
            _list.RemoveRange(start, count);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\httpruntimeconfigurationhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpRuntimeConfigurationHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//
// Config for HttpRuntime
//

namespace System.Web.Configuration {

    using System.Collections;
    using System.Configuration;
    using System.IO;
    using System.Text;
    using System.Web.Util;
    using XmlNode = System.Xml.XmlNode;
#if USE_REGEX_CSS_VALIDATION // ASURT 122278
    using System.Text.RegularExpressions;
#endif

    //
    // Config object
    //

    internal class HttpRuntimeConfig {

        internal const int DefaultExecutionTimeout = 90;
        internal const int DefaultMaxRequestLength = 4096 * 1024;  // 4MB
        internal const int DefaultMinFreeThreads = 8;
        internal const int DefaultMinLocalRequestFreeThreads = 4;
        internal const int DefaultAppRequestQueueLimit = 100;
        internal const int DefaultShutdownTimeout = 90;
        internal const int DefaultDelayNotificationTimeout = 5;
        internal const int DefaultWaitChangeNotification = 0;
        internal const int DefaultMaxWaitChangeNotification = 0;

        internal const bool DefaultEnableKernelOutputCache = true;

        private int  _executionTimeout = DefaultExecutionTimeout;
        private int  _maxRequestLength = DefaultMaxRequestLength;
        private bool _useFullyQualifiedRedirectUrl = false;
        private int  _minFreeThreads = DefaultMinFreeThreads;
        private int  _minLocalRequestFreeThreads = DefaultMinLocalRequestFreeThreads;
        private int  _appRequestQueueLimit = DefaultAppRequestQueueLimit;
        private int  _shutdownTimeout = DefaultShutdownTimeout;
        private int  _delayNotificationTimeout = DefaultDelayNotificationTimeout;
        private int  _waitChangeNotification = DefaultWaitChangeNotification;
        private int  _maxWaitChangeNotification = DefaultMaxWaitChangeNotification;

        private bool _enableKernelOutputCache = DefaultEnableKernelOutputCache;
        private bool _enableVersionHeader = false;

#if USE_REGEX_CSS_VALIDATION // ASURT 122278
        private Regex _requestValidationRegex;
#endif

        internal HttpRuntimeConfig(HttpRuntimeConfig parent) {
            if (parent != null) {
                _executionTimeout = parent._executionTimeout;
                _maxRequestLength = parent._maxRequestLength;
                _useFullyQualifiedRedirectUrl = parent._useFullyQualifiedRedirectUrl;
                _minFreeThreads = parent._minFreeThreads;
                _minLocalRequestFreeThreads = parent._minLocalRequestFreeThreads;
                _appRequestQueueLimit = parent._appRequestQueueLimit;
                _shutdownTimeout = parent._shutdownTimeout;
                _delayNotificationTimeout = parent._delayNotificationTimeout;
                _waitChangeNotification = parent._waitChangeNotification;
                _maxWaitChangeNotification = parent._maxWaitChangeNotification;

                _enableKernelOutputCache = parent._enableKernelOutputCache;
                _enableVersionHeader = parent._enableVersionHeader;
#if USE_REGEX_CSS_VALIDATION // ASURT 122278
                _requestValidationRegex = parent._requestValidationRegex;
#endif
            }
        }

        internal int ExecutionTimeout {
            get { return _executionTimeout; }
        }

        internal int MaxRequestLength {
            get { return _maxRequestLength; }  // in bytes
        }

        internal bool UseFullyQualifiedRedirectUrl {
            get { return _useFullyQualifiedRedirectUrl; }
        }

        internal int MinFreeThreads {
            get { return _minFreeThreads; }
        }

        internal int MinLocalRequestFreeThreads {
            get { return _minLocalRequestFreeThreads; }
        }

        internal int AppRequestQueueLimit {
            get { return _appRequestQueueLimit; }
        }

        internal int ShutdownTimeout {
            get { return _shutdownTimeout; }
        }

        internal int DelayNotificationTimeout {
            get { return _delayNotificationTimeout; }
        }

        internal int WaitChangeNotification {
            get { return _waitChangeNotification; }
        }

        internal int MaxWaitChangeNotification {
            get { return _maxWaitChangeNotification; }
        }

        internal bool EnableKernelOutputCache {
            get { return _enableKernelOutputCache; }
        }

        private static String s_versionHeader = null;

        internal String VersionHeader {
            get {
                if (!_enableVersionHeader)
                    return null;

                if (s_versionHeader == null) {
                    String header = null;

                    // construct once (race condition here doesn't matter)
                    try {
                        String version = VersionInfo.SystemWebVersion;
                        int i = version.LastIndexOf('.');
                        if (i > 0)
                            header = version.Substring(0, i);
                    }
                    catch {
                    }

                    if (header == null)
                        header = String.Empty;

                    s_versionHeader = header;
                }

                return s_versionHeader; 
            }
        }

#if USE_REGEX_CSS_VALIDATION // ASURT 122278
        internal Regex RequestValidationRegex {
            get { return _requestValidationRegex; }
        }
#endif

        internal void LoadValuesFromConfigurationInput(XmlNode node) {
            XmlNode n;

            // executionTimeout
            HandlerBase.GetAndRemovePositiveIntegerAttribute(node, "executionTimeout", ref _executionTimeout);

            // maxRequestLength
            int limit = 0;
            if (HandlerBase.GetAndRemoveNonNegativeIntegerAttribute(node, "maxRequestLength", ref limit) != null)
                _maxRequestLength = limit * 1024;

            // useFullyQualifiedRedirectUrl
            HandlerBase.GetAndRemoveBooleanAttribute(node, "useFullyQualifiedRedirectUrl", ref _useFullyQualifiedRedirectUrl);

            // minFreeThreads
            n = HandlerBase.GetAndRemoveNonNegativeIntegerAttribute(node, "minFreeThreads", ref _minFreeThreads);

            int workerMax, ioMax;
            System.Threading.ThreadPool.GetMaxThreads(out workerMax, out ioMax);
            int maxThreads = (workerMax < ioMax) ? workerMax : ioMax;
            if (_minFreeThreads >= maxThreads)
                throw new ConfigurationException(HttpRuntime.FormatResourceString(SR.Min_free_threads_must_be_under_thread_pool_limits, maxThreads.ToString()), (n != null) ? n : node);

            // minLocalRequestFreeThreads
            n = HandlerBase.GetAndRemoveNonNegativeIntegerAttribute(node, "minLocalRequestFreeThreads", ref _minLocalRequestFreeThreads);
            if (_minLocalRequestFreeThreads > _minFreeThreads)
                throw new ConfigurationException(HttpRuntime.FormatResourceString(SR.Local_free_threads_cannot_exceed_free_threads), (n != null) ? n : node);

            // appRequestQueueLimit
            HandlerBase.GetAndRemovePositiveIntegerAttribute(node, "appRequestQueueLimit", ref _appRequestQueueLimit);

            // shutdownTimeout
            HandlerBase.GetAndRemoveNonNegativeIntegerAttribute(node, "shutdownTimeout", ref _shutdownTimeout);

            // delayNotificationTimeout
            HandlerBase.GetAndRemoveNonNegativeIntegerAttribute(node, "delayNotificationTimeout", ref _delayNotificationTimeout);

            // waitChangeNotification
            HandlerBase.GetAndRemoveNonNegativeIntegerAttribute(node, "waitChangeNotification", ref _waitChangeNotification);

            // maxWaitChangeNotification
            HandlerBase.GetAndRemoveNonNegativeIntegerAttribute(node, "maxWaitChangeNotification", ref _maxWaitChangeNotification);

            // enableKernelOutputCache
            HandlerBase.GetAndRemoveBooleanAttribute(node, "enableKernelOutputCache", ref _enableKernelOutputCache);

            // enableVersionHeader
            HandlerBase.GetAndRemoveBooleanAttribute(node, "enableVersionHeader", ref _enableVersionHeader);

#if USE_REGEX_CSS_VALIDATION // ASURT 122278
            // If we find a requestValidationRegex string, create a new regex
            string requestValidationRegexString=null;
            XmlNode attrib = HandlerBase.GetAndRemoveStringAttribute(node, "requestValidationRegex", ref requestValidationRegexString);
            if (attrib != null) {
                // REVIEW: consider using a compiled regex, though that is slow on first hit (and a memory hog).
                // Obviously, we can't precompile it since it's not know ahead of time.
                try {
                    _requestValidationRegex = new Regex(requestValidationRegexString, RegexOptions.IgnoreCase /*| RegexOptions.Compiled*/);
                }
                catch (Exception e) {
                    throw new ConfigurationException(e.Message, e, attrib);
                }
            }
#endif

            // error on unrecognized attributes and nodes
            HandlerBase.CheckForUnrecognizedAttributes(node);
            HandlerBase.CheckForChildNodes(node);
        }
    }

    //
    // Config factory for httpRuntime
    //
    //    <httpRuntime 
    //        executionTimeout="90"
    //        maxRequestLength="4096"
    //        useFullyQualifiedRedirectUrl="false"
    //        minFreeThreads="8"
    //        minLocalRequestFreeThreads="4"
    //        appRequestQueueLimit="100"
    //    />
    //
    internal class HttpRuntimeConfigurationHandler : IConfigurationSectionHandler {

        internal HttpRuntimeConfigurationHandler() {
        }

        public virtual object Create(Object parent, Object configContextObj, XmlNode section) {
            // if called through client config don't even load HttpRuntime
            if (!HandlerBase.IsServerConfiguration(configContextObj))
                return null;


            HttpRuntimeConfig config = new HttpRuntimeConfig((HttpRuntimeConfig)parent);
            config.LoadValuesFromConfigurationInput(section);

            return config;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\identityconfig.cs ===
//------------------------------------------------------------------------------
// <copyright file="IdentityConfig.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * IdentityConfig class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Configuration {
    using System.Xml;
    using System.Configuration;
    using System.Text;
    
    internal class IdentityConfigHandler : IConfigurationSectionHandler {
        
        internal IdentityConfigHandler() {
        }

        public virtual object Create(Object parent, Object configContextObj, XmlNode section) {
            // if called through client config don't even load HttpRuntime
            if (!HandlerBase.IsServerConfiguration(configContextObj))
                return null;
                
            bool impersonation = false;
            String username = null;
            String password = null;

            HandlerBase.CheckForChildNodes(section);
            HandlerBase.GetAndRemoveBooleanAttribute(section, "impersonate", ref impersonation);
            HandlerBase.GetAndRemoveStringAttribute(section, "userName", ref username);
            HandlerBase.GetAndRemoveStringAttribute(section, "password", ref password);

            HandlerBase.CheckForUnrecognizedAttributes(section);
            HandlerBase.CheckForChildNodes(section);
            if (username != null && username.Length < 1)
                username = null;
            if (password != null && (password.StartsWith("registry:") || password.StartsWith("Registry:")))
            {
                StringBuilder str = new StringBuilder(100);
                int iRet = UnsafeNativeMethods.GetCredentialFromRegistry(password, str, 100);
                if (iRet == 0)
                    password = str.ToString();
                else
                    throw new ConfigurationException(
                            HttpRuntime.FormatResourceString(SR.Invalid_credentials_pass),
                            section);                
            }
            if (username != null && (username.StartsWith("registry:") || username.StartsWith("Registry:")))
            {
                StringBuilder str = new StringBuilder(100);
                int iRet = UnsafeNativeMethods.GetCredentialFromRegistry(username, str, 100);
                if (iRet == 0)
                    username = str.ToString();
                else
                    throw new ConfigurationException(
                            HttpRuntime.FormatResourceString(SR.Invalid_credentials_name),
                            section);
            }
            return new IdentityConfig((IdentityConfig) parent, impersonation, username, password, section);
        }
    }

    
    internal sealed class ImpersonateTokenRef {

        private IntPtr _handle;

        internal ImpersonateTokenRef(IntPtr token) {
            _handle = token;
        }
        
        internal IntPtr Handle {
            get { return _handle; }
        }

        // The handle can be kept alive by HttpContext.s_appIdentityConfig (see ASURT#121815)

        ~ImpersonateTokenRef() {
            if (_handle != IntPtr.Zero) UnsafeNativeMethods.CloseHandle(_handle);
        }
    }
   
    internal class IdentityConfig {
        
        private bool    _enableImpersonation;
        private String  _username;
        private String  _password;
        private ImpersonateTokenRef _impersonateTokenRef = new ImpersonateTokenRef(IntPtr.Zero);

        internal bool    EnableImpersonation { get { return _enableImpersonation; }}
        internal String  UserName            { get { return _username; }}
        internal String  Password            { get { return _password; }}
        internal IntPtr  ImpersonateToken    { get { return _impersonateTokenRef.Handle; }}

        internal IdentityConfig(IdentityConfig parent, bool enable, String username, String password, XmlNode section) {
            if (parent != null) {
                _enableImpersonation = parent.EnableImpersonation;
                _username = parent.UserName;
                _password = parent.Password;
                _impersonateTokenRef = parent._impersonateTokenRef;
            }

            // no partial overrides
            if (enable) {
                _username = null;
                _password = null;
                _impersonateTokenRef = new ImpersonateTokenRef(IntPtr.Zero);
            }

            _enableImpersonation = enable;
            _username = username;
            _password = password;
            
            if (_username != null && _enableImpersonation)  {
                if (_password == null)
                    _password = String.Empty;

                StringBuilder szError = new StringBuilder(256);

                HttpContext context = HttpContext.Current;
                IntPtr      token   = IntPtr.Zero;
                if (context.WorkerRequest is System.Web.Hosting.ISAPIWorkerRequest)
                { 
                    byte [] bOut = new byte[IntPtr.Size]; 
                    byte [] bIn1 = System.Text.Encoding.Unicode.GetBytes(_username + "\t" + _password);
                    byte [] bIn  = new byte[bIn1.Length + 2];
                    Buffer.BlockCopy(bIn1, 0, bIn, 0, bIn1.Length);
                    if (context.CallISAPI(UnsafeNativeMethods.CallISAPIFunc.GenerateToken, bIn, bOut) == 1)
                    {
                        Int64 iToken = 0;
                        for(int iter=0; iter<IntPtr.Size; iter++)
                        {
                            iToken = iToken * 256 + bOut[iter];
                        }
                        token = (IntPtr) iToken;
                    }                
                }

                if (token == IntPtr.Zero)
                    token = UnsafeNativeMethods.CreateUserToken(_username, _password, 1, szError, 256);

                _impersonateTokenRef = new ImpersonateTokenRef(token);

                if (_impersonateTokenRef.Handle == IntPtr.Zero) {
                    String strError = szError.ToString();
                    if (strError.Length > 0)
                    {
                        throw new ConfigurationException(
                                HttpRuntime.FormatResourceString(SR.Invalid_credentials_2, strError),
                                section);
                    }
                    else
                    {
                        throw new ConfigurationException(
                                HttpRuntime.FormatResourceString(SR.Invalid_credentials),
                                section);
                    }   
                }
            }
            else if (_password != null && _username == null && _password.Length > 0 && _enableImpersonation) {
                throw new ConfigurationException(
                        HttpRuntime.FormatResourceString(SR.Invalid_credentials),
                        section);
            }
            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\machinekeyconfig.cs ===
//------------------------------------------------------------------------------
// <copyright file="MachineKeyConfig.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * IdentityConfig class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Configuration {
    using System.Text;
    using System.Xml;
    using System.Security.Cryptography;
    using System.Configuration;
    using System.Collections;
    using System.Web.Util;    
    internal class MachineKeyConfigHandler : IConfigurationSectionHandler {
        
        internal MachineKeyConfigHandler() {
        }

        public virtual object Create(Object parent, Object configContextObj, XmlNode section) {
            // if called through client config don't even load HttpRuntime
            if (!HandlerBase.IsServerConfiguration(configContextObj))
                return null;

            return MachineKey.CreateConfig(parent, configContextObj, section);
        }
    }
    
    internal enum MachineKeyValidationMode {
        SHA1, 
        MD5,
        TripleDES
    }

    class MachineKey 
    {
        static object                             s_initLock = new object();
        static MachineKeyConfig                   s_config;        
        private static SymmetricAlgorithm         s_oDes;
        private static Stack                      s_oEncryptorStack;
        private static Stack                      s_oDecryptorStack;
        private static byte []                    s_validationKey;            

        static private MachineKeyValidationMode ValidationMode      { get { EnsureConfig(); return s_config.ValidationMode; }}
        static internal int ValidationKeyHashCode { 
            get { 
                EnsureConfig(); 
                return ByteArrayToHexString(s_validationKey, s_validationKey.Length).GetHashCode(); 
            }
        }
        
        /*
          static private byte[]                   ValidationKey       { get { EnsureConfig(); return s_config.ValidationKey; }}
          static private byte[]                   DecryptionKey       { get { EnsureConfig(); return s_config.DecryptionKey; }}
          static private bool                     AutogenKey          { get { EnsureConfig(); return s_config.AutogenKey; }}
        */
        private const int HASH_SIZE = 20;

        private MachineKey() {
        }

        // NOTE: When encoding the data, this method *may* return the same reference to the input "buf" parameter
        // with the hash appended in the end if there's enough space.  The "length" parameter would also be
        // appropriately adjusted in those cases.  This is an optimization to prevent unnecessary copying of
        // buffers.
        internal static byte[] GetEncodedData(byte [] buf, byte [] modifier, int start, ref int length) 
        {
            EnsureConfig();

            if (s_config.ValidationMode != MachineKeyValidationMode.TripleDES) {
                byte [] bHash = HashData(buf, modifier, start, length);
                if ((buf.Length - (start + length)) >= bHash.Length) {
                    // Append hash to end of buffer if there's space
                    Buffer.BlockCopy(bHash, 0, buf, start + length, bHash.Length);
                    length += bHash.Length;
                    return buf;
                }
                else {
                    byte [] bRet = new byte[length + bHash.Length];
                    Buffer.BlockCopy(buf, start, bRet, 0, length);
                    Buffer.BlockCopy(bHash, 0, bRet, length, bHash.Length);
                    length += bHash.Length;
                    return bRet;
                }
            }
            byte [] ret = EncryptOrDecryptData(true, buf, modifier, start, length);
            length = ret.Length;

            return ret;
        }

        // NOTE: When decoding the data, this method *may* return the same reference to the input "buf" parameter
        // with the "dataLength" parameter containing the actual length of the data in the "buf" (i.e. length of actual 
        // data is (total length of data - hash length)). This is an optimization to prevent unnecessary copying of buffers.
        internal static byte[] GetDecodedData(byte [] buf, byte [] modifier, int start, int length, ref int dataLength) 
        {
            EnsureConfig();

            if (s_config.ValidationMode != MachineKeyValidationMode.TripleDES) {
                byte [] bHash = HashData(buf, modifier, start, length - HASH_SIZE);
                for(int iter=0; iter < bHash.Length; iter++)
                    if (bHash[iter] != buf[start + length - HASH_SIZE + iter])
                        throw new HttpException(HttpRuntime.FormatResourceString(SR.Unable_to_validate_data));

                dataLength = length - HASH_SIZE;
                return buf;
            }
            dataLength = -1;
            return EncryptOrDecryptData(false, buf, modifier, start, length);
        }
        
        internal static byte [] HashData(byte [] buf, byte [] modifier, int start, int length)
        {
            EnsureConfig();
            byte [] hash = null;

            if (s_config.ValidationMode == MachineKeyValidationMode.MD5)
                hash = MD5HashForData(buf, modifier, start, length);
            else
                hash = HMACSHA1HashForData(buf, modifier, start, length);

            // We need to pad the returning hash so that they all have an uniform size (makes it easier when we decode)
            // MD5 will return a 16 byte hash, whereas the default SHA1 returns 20, so we pad it with 4 zero bytes
            System.Web.Util.Debug.Assert(hash.Length <= HASH_SIZE, "Hash size is greater than HASH_SIZE constant!");
            
            if (hash.Length < HASH_SIZE) {
                byte[] tmp = new byte[HASH_SIZE];
                Buffer.BlockCopy(hash, 0, tmp, 0, hash.Length);
                hash = tmp;
            }

            return hash;
        }


        internal static byte [] EncryptOrDecryptData(bool fEncrypt, byte [] buf, byte [] modifier, int start, int length)
        {
            EnsureConfig();
            System.IO.MemoryStream   ms        = new System.IO.MemoryStream();
            ICryptoTransform         oDesEnc   = GetCryptoTransform(fEncrypt);
            CryptoStream             cs        = new CryptoStream(ms, oDesEnc, CryptoStreamMode.Write);

            cs.Write(buf, start, length);
            if (fEncrypt && modifier != null) {
                cs.Write(modifier, 0, modifier.Length);                 
            }
                
            cs.FlushFinalBlock();            
            byte [] bData = ms.ToArray();
            cs.Close();
            ReturnCryptoTransform(fEncrypt, oDesEnc);

            if (!fEncrypt && modifier != null) {
                byte [] bData2 = new byte[bData.Length-modifier.Length];
                Buffer.BlockCopy(bData, 0, bData2, 0, bData2.Length);
                bData = bData2;
            }
            return bData;
        }

        private static byte [] MD5HashForData(byte [] buf, byte [] modifier, int start, int length)
        {
            MD5 md5 = MD5.Create();
            int totalLength = length + s_validationKey.Length;

            if (modifier != null) {
                totalLength += modifier.Length;
            }
            else {
                // Try to avoid doing a copy of the buffer by trying to append the validation key into the existing buffer
                if ((buf.Length - (start + length)) >= s_validationKey.Length) {
                    Buffer.BlockCopy(s_validationKey, 0, buf, start + length, s_validationKey.Length);
                    byte [] computedHash = md5.ComputeHash(buf);

                    // Cleanup validation key from buf
                    for (int i = (start + length); i < (start + length + s_validationKey.Length); i++) {
                        buf[i] = 0;
                    }

                    return computedHash;
                }
            }
            
            byte [] bAll = new byte[totalLength];
            Buffer.BlockCopy(buf, start, bAll, 0, length);
            if (modifier != null) {
                Buffer.BlockCopy(modifier, 0, bAll, length, modifier.Length);
                length += modifier.Length;
            }
            Buffer.BlockCopy(s_validationKey, 0, bAll, length, s_validationKey.Length);
            return md5.ComputeHash(bAll);
        }

        private static byte [] HMACSHA1HashForData(byte [] buf, byte [] modifier, int start, int length)
        {
            ExtendedHMACSHA1 hmac = ExtendedHMACSHA1.GetHMACSHA1();        // Pick up an ExtendedHMACSHA1 off the pool
            HMACBuffer [] hbufs;

            if (modifier != null) {
                hbufs = new HMACBuffer[2];
                hbufs[1].buffer = modifier;
                hbufs[1].start = 0;
                hbufs[1].length = modifier.Length;
            }
            else {
                hbufs = new HMACBuffer[1];
            }

            hbufs[0].buffer = buf;
            hbufs[0].start = start;
            hbufs[0].length = length;

            byte [] ret = hmac.ComputeHash(hbufs);

            ExtendedHMACSHA1.ReturnHMACSHA1(hmac);
            
            return ret;
        }

        internal static string HashAndBase64EncodeString(string s) 
        {
            byte[]  ab;
            byte[]  hash;
            string  result;

            ab = Encoding.Unicode.GetBytes(s);
            hash = HashData(ab, null, 0, ab.Length);
            result = Convert.ToBase64String(hash);

            return result;
        }

        static internal void DestroyByteArray(byte [] buf)
        {
            if (buf == null || buf.Length < 1)
                return;
            for(int iter=0; iter<buf.Length; iter++)
                buf[iter] = (byte)0;
        }

        /////////////////////////////////////////////////////////////////////////////
        static byte[]   s_ahexval;

        static internal byte [] HexStringToByteArray(String str) {
            if (((uint) str.Length & 0x1) == 0x1) {
                return null;
            }

            byte[] ahexval = s_ahexval;
            if (ahexval == null) {
                ahexval = new byte['f' + 1];
                for (int i = ahexval.Length; --i >= 0;) {
                    if ('0' <= i && i <= '9') {
                        ahexval[i] = (byte) (i - '0');
                    }
                    else if ('a' <= i && i <= 'f') {
                        ahexval[i] = (byte) (i - 'a' + 10);
                    }
                    else if ('A' <= i && i <= 'F') {
                        ahexval[i] = (byte) (i - 'A' + 10);
                    }
                }

                s_ahexval = ahexval;
            }

            byte [] result = new byte[str.Length / 2];
            int istr = 0, ir = 0;
            int n = result.Length;
            while (--n >= 0) {
                int c1, c2;
                try {
                    c1 = ahexval[str[istr++]];
                }
                catch {
                    c1 = 0;
                    return null;// Inavlid char
                }
                
                try {
                    c2 = ahexval[str[istr++]];
                }
                catch {
                    c2 = 0; 
                    return null;// Inavlid char                    
                }

                result[ir++] = (byte) ((c1 << 4) + c2);
            }

            return result;
        }

        /////////////////////////////////////////////////////////////////////////////
        static char[] s_acharval;

        static unsafe internal String ByteArrayToHexString(byte [] buf, int iLen) {
            char[] acharval = s_acharval;
            if (acharval == null) {
                acharval = new char[16];
                for (int i = acharval.Length; --i >= 0;) {
                    if (i < 10) {
                        acharval[i] = (char) ('0' + i);
                    }
                    else {
                        acharval[i] = (char) ('A' + (i - 10));
                    }
                }

                s_acharval = acharval;
            }

            if (buf == null)
                return null;

            if (iLen == 0)
                iLen = buf.Length;

            char [] chars = new char[iLen * 2];
            fixed (char * fc = chars, fcharval = acharval) {
                fixed (byte * fb = buf) {
                    char * pc;
                    byte * pb;
                    pc = fc;
                    pb = fb;
                    while (--iLen >= 0) {
                        *pc++ = fcharval[(*pb & 0xf0) >> 4];
                        *pc++ = fcharval[*pb & 0x0f];                
                        pb++;
                    }
                }
            }

            return new String(chars);
        }

        static void EnsureConfig() {
            if (s_config == null) {
                lock (s_initLock) {
                    if (s_config == null) {
                        MachineKeyConfig config = (MachineKeyConfig) HttpContext.GetAppConfig("system.web/machineKey");
                        ConfigureEncryptionObject(config);
                        s_config = config;
                    }
                }
            }
        }

        private static void ConfigureEncryptionObject(MachineKeyConfig config) {
            s_validationKey = config.ValidationKey;            
            byte [] dKey    = config.DecryptionKey;
            ExtendedHMACSHA1.SetValidationKey(s_validationKey);
            config.DestroyKeys();

            if (config.AutogenKey) {
                try {
                    s_oDes = new TripleDESCryptoServiceProvider();
                    s_oDes.Key = dKey;
                }
                catch(Exception){
                    if (config.ValidationMode == MachineKeyValidationMode.TripleDES)
                        throw;
                    s_oDes = new DESCryptoServiceProvider();
                    byte [] bArray = new byte[8];
                    Buffer.BlockCopy(dKey, 0, bArray, 0, 8);                       
                    s_oDes.Key = bArray;
                }
            } else {
                s_oDes = (dKey.Length == 8) ? 
                    (SymmetricAlgorithm) new DESCryptoServiceProvider() : 
                    (SymmetricAlgorithm) new TripleDESCryptoServiceProvider();
                s_oDes.Key = dKey;
            }
            s_oDes.IV  = new byte[8];
            s_oEncryptorStack = new Stack();
            s_oDecryptorStack = new Stack();
            DestroyByteArray(dKey);
        }

        private static ICryptoTransform GetCryptoTransform(bool fEncrypt)
        {
            Stack st = (fEncrypt ? s_oEncryptorStack : s_oDecryptorStack);
            lock(st) {
                if (st.Count > 0)
                    return (ICryptoTransform) st.Pop();
            }
            lock(s_oDes)
                return (fEncrypt ? s_oDes.CreateEncryptor() : s_oDes.CreateDecryptor());
        }
        
        private static void ReturnCryptoTransform(bool fEncrypt, ICryptoTransform ct)
        {
            Stack st = (fEncrypt ? s_oEncryptorStack : s_oDecryptorStack);
            lock(st) {
                if (st.Count <= 100) 
                    st.Push(ct);
            }
        }


        static internal object CreateConfig(Object parent, Object configContextObj, XmlNode section) {
            return new MachineKeyConfig(parent, configContextObj, section);
        }

        class MachineKeyConfig {
            //////////////////////////////////////////////////////////////////
            // Properties

            private MachineKeyValidationMode   _ValidationMode;
            private bool                       _AutogenKey;
            private byte[]                     _ValidationKey;
            private byte[]                     _DecryptionKey;

            internal byte[]                   ValidationKey       { get { return (byte []) _ValidationKey.Clone(); }}
            internal byte[]                   DecryptionKey       { get { return (byte []) _DecryptionKey.Clone(); }}
            internal MachineKeyValidationMode ValidationMode      { get { return _ValidationMode; }}
            internal bool                     AutogenKey          { get { return _AutogenKey; }}

            internal void DestroyKeys() {
                MachineKey.DestroyByteArray(_ValidationKey);
                MachineKey.DestroyByteArray(_DecryptionKey);
            }

            // CTor            
            internal MachineKeyConfig(object parentObject, object contextObject, XmlNode node) {
                MachineKeyConfig parent = (MachineKeyConfig)parentObject;

                HttpConfigurationContext configContext = contextObject as HttpConfigurationContext;
                if (HandlerBase.IsPathAtAppLevel(configContext.VirtualPath) == PathLevel.BelowApp) {
                    throw new ConfigurationException(
                            HttpRuntime.FormatResourceString(SR.No_MachineKey_Config_In_subdir), 
                            node);
                }

                if (parent != null) {
                    _ValidationKey = parent.ValidationKey;
                    _DecryptionKey = parent.DecryptionKey;
                    _ValidationMode = parent.ValidationMode;
                    _AutogenKey = parent.AutogenKey;
                }

                XmlNode vNode = node.Attributes.RemoveNamedItem("validationKey");
                XmlNode dNode = node.Attributes.RemoveNamedItem("decryptionKey");

                int iMode = 0;
                string [] modeStrings = {"SHA1", "MD5", "3DES"};
                XmlNode mNode = HandlerBase.GetAndRemoveEnumAttribute(node, "validation", modeStrings, ref iMode);
                if (mNode != null) {
                    _ValidationMode = (MachineKeyValidationMode) iMode;
                }
                HandlerBase.CheckForUnrecognizedAttributes(node);
                HandlerBase.CheckForChildNodes(node);

                if (vNode != null && vNode.Value != null) 
                {
                    String strKey        = vNode.Value;
                    bool   fAppSpecific  = strKey.EndsWith(",IsolateApps");

                    if (fAppSpecific)
                    {
                        strKey = strKey.Substring(0, strKey.Length - ",IsolateApps".Length);
                    }

                    if (strKey == "AutoGenerate") { // case sensitive
                        _ValidationKey = new byte[64];
                        Buffer.BlockCopy(HttpRuntime.s_autogenKeys, 0, _ValidationKey, 0, 64);                        
                    }
                    else {
                        if (strKey.Length > 128 || strKey.Length < 40)
                            throw new ConfigurationException(
                                    HttpRuntime.FormatResourceString(
                                            SR.Unable_to_get_cookie_authentication_validation_key, strKey.Length.ToString()),
                                    vNode);

                        _ValidationKey = HexStringToByteArray(strKey);
                        if (_ValidationKey == null)
                            throw new ConfigurationException(
                                    HttpRuntime.FormatResourceString(
                                            SR.Invalid_validation_key),
                                    vNode);
                    }

                    if (fAppSpecific)
                    {
                        int dwCode = SymbolHashCodeProvider.Default.GetHashCode(HttpContext.Current.Request.ApplicationPath);                     
                        _ValidationKey[0] =  (byte)  (dwCode & 0xff);
                        _ValidationKey[1] =  (byte) ((dwCode & 0xff00) >> 8);
                        _ValidationKey[2] =  (byte) ((dwCode & 0xff0000) >> 16);
                        _ValidationKey[3] =  (byte) ((dwCode & 0xff000000) >> 24);
                    }
                }

                if (dNode != null) {
                    String strKey        = dNode.Value;
                    bool   fAppSpecific  = strKey.EndsWith(",IsolateApps");

                    if (fAppSpecific)
                    {
                        strKey = strKey.Substring(0, strKey.Length - ",IsolateApps".Length);
                    }

                    if (strKey == "AutoGenerate") { // case sensitive
                        _DecryptionKey = new byte[24];
                        Buffer.BlockCopy(HttpRuntime.s_autogenKeys, 64, _DecryptionKey, 0, 24);
                        _AutogenKey = true;
                    }
                    else {
                        _AutogenKey = false;

                        if (strKey.Length == 48) { // Make sure Triple DES is installed
                            TripleDESCryptoServiceProvider oTemp = null;
                            try {
                                oTemp = new TripleDESCryptoServiceProvider();                                
                            }
                            catch(Exception) {
                            }
                            if (oTemp == null)
                                throw new ConfigurationException(
                                        HttpRuntime.FormatResourceString(
                                                SR.cannot_use_Triple_DES),
                                        dNode);
                        }

                        if (strKey.Length != 48 && strKey.Length != 16)
                            throw new ConfigurationException(
                                    HttpRuntime.FormatResourceString(
                                            SR.Unable_to_get_cookie_authentication_decryption_key, strKey.Length.ToString()),
                                    dNode);

                        _DecryptionKey = HexStringToByteArray(strKey);
                         if (_DecryptionKey == null)
                             throw new ConfigurationException(
                                     HttpRuntime.FormatResourceString(
                                             SR.Invalid_decryption_key),
                                     dNode);
                    }
                    if (fAppSpecific)
                    {
                        int dwCode = SymbolHashCodeProvider.Default.GetHashCode(HttpContext.Current.Request.ApplicationPath);                     
                        _DecryptionKey[0] =  (byte)  (dwCode & 0xff);
                        _DecryptionKey[1] =  (byte) ((dwCode & 0xff00) >> 8);
                        _DecryptionKey[2] =  (byte) ((dwCode & 0xff0000) >> 16);
                        _DecryptionKey[3] =  (byte) ((dwCode & 0xff000000) >> 24);
                    }
                }
            }
        }
    }

    // This class inherits from System.Security.Cryptography.HMACSHA1, providing the same functionality
    // as its base class but extending by allowing the computation of a hash from multiple buffers
    // without having to coalesce them into a single byte[].  
    internal class ExtendedHMACSHA1 : System.Security.Cryptography.HMACSHA1 {
        static private byte [] _ValidationKey;

        static internal void SetValidationKey(byte [] vKey) {
            _ValidationKey = new byte[vKey.Length];
            Buffer.BlockCopy(vKey, 0, _ValidationKey, 0, _ValidationKey.Length);
        }

        internal ExtendedHMACSHA1():base() {
        }

        internal ExtendedHMACSHA1(byte[] rgbKey):base(rgbKey) {
        }

        internal /*public*/ byte[] ComputeHash(HMACBuffer[] buffers) {
            for (int i = 0; i < buffers.Length; i++) {
                HMACBuffer hb = buffers[i];
                HashCore(hb.buffer, hb.start, hb.length);
            }

            byte[] ret = (byte []) HashFinal().Clone();
            Initialize();

            return ret;
        }

        // This is a simple object recycler for the ExtendedHMACSHA1 object
        private static Stack sha1s;
        internal static ExtendedHMACSHA1 GetHMACSHA1() 
        {
            if (sha1s == null) {
                lock(typeof(ExtendedHMACSHA1)) {
                    if (sha1s == null)
                        sha1s = new Stack();
                }
            }

            lock(sha1s) {
                if (sha1s.Count > 0) {
                    return (ExtendedHMACSHA1) sha1s.Pop();
                }
            }
            return new ExtendedHMACSHA1(_ValidationKey);
        }

        internal static void ReturnHMACSHA1(ExtendedHMACSHA1 hmac)
        {
            if (sha1s == null) {
                return;
            }

            lock(sha1s) {
                if (sha1s.Count > 100) {
                    return;
                }
                else {
                    sha1s.Push(hmac);
                }
            }
        }
    }

    // Helper struct to hold the buffer data to be hashed
    internal struct HMACBuffer
    {
        internal byte[] buffer;
        internal int start;
        internal int length;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\ent\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\processmodelconfigurationhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProcessModelConfigurationHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Config related classes for HttpApplication
 */

namespace System.Web.Configuration {

    using System.Collections;
    using System.Configuration;
    using System.Globalization;
    using System.IO;
    using System.Text;
    using System.Web.Util;
    using System.Xml;

    // contains process model settings needed in managed code
    internal class ProcessModelConfig {
        internal int MaxWorkerThreads;
        internal int MaxIoThreads;
        internal int MinWorkerThreads;
        internal int MinIoThreads;
        internal int ResponseDeadlockInterval; // in seconds

        internal ProcessModelConfig(int maxWorkerThreads, int maxIoThreads, int minWorkerThreads, int minIoThreads, int responseDeadlockInterval) {
            int cpuCount = SystemInfo.GetNumProcessCPUs();
            MaxWorkerThreads = maxWorkerThreads * cpuCount;
            MaxIoThreads     = maxIoThreads     * cpuCount;
            MinWorkerThreads = minWorkerThreads * cpuCount;
            MinIoThreads     = minIoThreads     * cpuCount;

            ResponseDeadlockInterval = (responseDeadlockInterval == int.MaxValue) ? -1 : responseDeadlockInterval;
        }
    }

    /// <include file='doc\TraceConfigurationHandler.uex' path='docs/doc[@for="TraceConfigurationHandler"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// This handler does error-checking on the &lt;processModel&gt; config section.  It doesn't do any real work.
    /// </devdoc>
    internal class ProcessModelConfigurationHandler : IConfigurationSectionHandler {

        internal const string sectionName = "system.web/processModel";

        enum LogLevelEnum {
            All,
            None,
            Errors
        }

        internal ProcessModelConfigurationHandler() {
        }

        public virtual object Create(Object parent, object configContextObj, XmlNode section) {
            // if called through client config don't even load HttpRuntime
            if (!HandlerBase.IsServerConfiguration(configContextObj))
                return null;
            
            bool bTemp = false;
            int iTemp = 0;
            uint uiTemp = 0;
            string sTemp = null;
            int maxWorkerThreads = 0;
            int maxIoThreads = 0;
            int minWorkerThreads = 0;
            int minIoThreads = 0;
            int responseDeadlockInterval = 0;

            HandlerBase.GetAndRemoveBooleanAttribute(section, "enable", ref bTemp);
            GetAndRemoveProcessModelTimeout(section, "timeout", ref iTemp);
            GetAndRemoveProcessModelTimeout(section, "idleTimeout", ref iTemp);
            GetAndRemoveProcessModelTimeout(section, "shutdownTimeout", ref iTemp);
            GetAndRemoveIntegerOrInfiniteAttribute(section, "requestLimit", ref iTemp);
            GetAndRemoveIntegerOrInfiniteAttribute(section, "requestQueueLimit", ref iTemp);
            GetAndRemoveIntegerOrInfiniteAttribute(section, "restartQueueLimit", ref iTemp);
            HandlerBase.GetAndRemoveIntegerAttribute(section, "memoryLimit", ref iTemp);
            GetAndRemoveUnsignedIntegerAttribute(section, "cpuMask", ref uiTemp);
            HandlerBase.GetAndRemoveEnumAttribute(section, "logLevel", typeof(LogLevelEnum), ref iTemp);
            HandlerBase.GetAndRemoveStringAttribute(section, "userName", ref sTemp);
            HandlerBase.GetAndRemoveStringAttribute(section, "password", ref sTemp);
            HandlerBase.GetAndRemoveBooleanAttribute(section, "webGarden", ref bTemp);
            GetAndRemoveProcessModelTimeout(section, "clientConnectedCheck", ref iTemp);
            HandlerBase.GetAndRemoveStringAttribute(section, "comImpersonationLevel", ref sTemp);
            HandlerBase.GetAndRemoveStringAttribute(section, "comAuthenticationLevel", ref sTemp);
            GetAndRemoveProcessModelTimeout(section, "responseDeadlockInterval", ref responseDeadlockInterval);
            GetAndRemoveProcessModelTimeout(section, "responseRestartDeadlockInterval", ref iTemp);
            HandlerBase.GetAndRemovePositiveIntegerAttribute(section, "maxWorkerThreads", ref maxWorkerThreads);
            HandlerBase.GetAndRemovePositiveIntegerAttribute(section, "maxIoThreads", ref maxIoThreads);
            HandlerBase.GetAndRemovePositiveIntegerAttribute(section, "minWorkerThreads", ref minWorkerThreads);
            HandlerBase.GetAndRemovePositiveIntegerAttribute(section, "minIoThreads", ref minIoThreads);
            HandlerBase.GetAndRemoveStringAttribute(section, "serverErrorMessageFile", ref sTemp);
            GetAndRemoveIntegerOrInfiniteAttribute(section, "requestAcks", ref iTemp);
            GetAndRemoveProcessModelTimeout(section, "pingFrequency", ref iTemp);
            GetAndRemoveProcessModelTimeout(section, "pingTimeout", ref iTemp);
            GetAndRemoveIntegerOrInfiniteAttribute(section, "asyncOption", ref iTemp);
                

            HandlerBase.CheckForUnrecognizedAttributes(section);
            HandlerBase.CheckForChildNodes(section);

            return new ProcessModelConfig(maxWorkerThreads, maxIoThreads, minWorkerThreads, minIoThreads, responseDeadlockInterval);
        }

        static XmlNode GetAndRemoveProcessModelTimeout(XmlNode section, string attrName, ref int val) {

            string sValue = null;
            XmlNode a = HandlerBase.GetAndRemoveStringAttribute(section, attrName, ref sValue);

            if (sValue != null) {
                try {
                    if (sValue == "Infinite") {
                        val = int.MaxValue;
                    } 
                    else if (sValue.IndexOf(':') == -1) {
                        val = 60 * int.Parse(sValue, CultureInfo.InvariantCulture);
                    }
                    else {
                        string [] times = sValue.Split(new char [] {':'});

                        if (times.Length > 3) {
                            throw new ConfigurationException(SR.GetString(SR.Config_Process_model_time_invalid), a);
                        }

                        int timeInSeconds = 0;
                        foreach (string time in times) {
                            timeInSeconds = timeInSeconds * 60 + int.Parse(time, NumberStyles.None, CultureInfo.InvariantCulture);
                        }
                        val = timeInSeconds;
                    }
                }
                catch (Exception e) {
                    throw new ConfigurationException(SR.GetString(SR.Config_Process_model_time_invalid), e, a);
                }
            }
            return a;
        }

        static XmlNode GetAndRemoveIntegerOrInfiniteAttribute(XmlNode node, string attrib, ref int val) {
            string sValue = null;
            XmlNode a = HandlerBase.GetAndRemoveStringAttribute(node, attrib, ref sValue);

            if (a != null) {
                if (sValue == "Infinite") {
                    val = int.MaxValue;
                } 
                else {
                    try {
                        val = int.Parse(sValue, NumberStyles.None, CultureInfo.InvariantCulture);
                    }
                    catch (Exception e) {
                        throw new ConfigurationException(
                            HttpRuntime.FormatResourceString(SR.Invalid_integer_attribute, a.Name),
                            e, a);
                    }
                }
            }

            return a;
        }

        static XmlNode GetAndRemoveUnsignedIntegerAttribute(XmlNode node, string attrib, ref uint val) {
            string sValue = null;
            XmlNode a = HandlerBase.GetAndRemoveStringAttribute(node, attrib, ref sValue);

            if (a != null) {
                try {
                    val = ParseHexOrDecUInt(sValue);
                }
                catch (Exception e) {
                    throw new ConfigurationException(
                        HttpRuntime.FormatResourceString(SR.Invalid_integer_attribute, a.Name),
                        e, a);
                }
            }

            return a;
        }

        static uint ParseHexOrDecUInt(string s) {
            if (s.Length > 1 && s[0] == '0' && s[1] == 'x')
                return uint.Parse(s.Substring(2), NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture);
            else 
                return uint.Parse(s, NumberStyles.None, CultureInfo.InvariantCulture);
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\modulesentry.cs ===
//------------------------------------------------------------------------------
// <copyright file="ModulesEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Config related classes for HttpApplication
 * 
 */

namespace System.Web.Configuration {

    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Collections;
    using System.Reflection;
    using System.Globalization;
    using System.Web;
    using System.Web.SessionState;
    using System.Web.Security;
    using System.Web.Util;

    /*
     * Single Entry of request to class
     */
    internal class ModulesEntry {
        private String _name;
        private Type _type;

        internal ModulesEntry(String name, String typeName) {
            _name = (name != null) ? name : String.Empty;
            _type = Type.GetType(typeName, true);

            if (!typeof(IHttpModule).IsAssignableFrom(_type)) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Type_not_module, typeName));
            }
        }

        internal static bool IsTypeMatch(Type type, String typeName) {
            return(type.Name.Equals(typeName) || type.FullName.Equals(typeName));
        }

        internal String ModuleName {
            get { return _name; }
        }

        internal /*public*/ IHttpModule Create() {
            return (IHttpModule)HttpRuntime.CreateNonPublicInstance(_type);
        }

        internal /*public*/ Type Type {
            get {
                return _type;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\exp\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\httpmodulesconfigurationhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpModulesConfigurationHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Config related classes for HttpApplication
 */

namespace System.Web.Configuration {

    using System.IO;
    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Collections;
    using System.Configuration;
    using System.Reflection;
    using System.Globalization;
    using System.Web.SessionState;
    using System.Web.Security;
    using System.Web.Util;
    using System.Xml;

    /*
     * Simple Application config factory
     *
     * syntax:
     *
     *   <httpModules>
     *      <clear /> <!-- directive clears all previously set handlers -->
     *      <add name="MyModule" type="System.Web.MyModule" />
     *      <add name="YourModule" type="System.YourModule" />
     *      <add name="AnotherModule" type="System.AnotherModule" />
     *      <remove name="YourModule" />
     *   </httpModules>
     *
     * output:
     *
     *   ArrayList of ModulesEntrys
     */
    /// <include file='doc\HttpModulesConfigurationHandler.uex' path='docs/doc[@for="HttpModulesConfigurationHandler"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    internal class HttpModulesConfigurationHandler : IConfigurationSectionHandler {
        
        internal HttpModulesConfigurationHandler() {
        }

        /*
         * Create
         *
         * Given a partially composed config object (possibly null)
         * and some input from the config system, return a
         * further partially composed config object
         */
        public virtual object Create(Object parent, Object configContextObj, XmlNode section) {
            // if called through client config don't even load HttpRuntime
            if (!HandlerBase.IsServerConfiguration(configContextObj))
                return null;
            
            HttpModulesConfiguration appConfig;

            // start list as shallow clone of parent

            if (parent == null)
                appConfig = new HttpModulesConfiguration();
            else
                appConfig = new HttpModulesConfiguration((HttpModulesConfiguration)parent);

            // process XML section in order and apply the directives

            HandlerBase.CheckForUnrecognizedAttributes(section);
            foreach (XmlNode child in section.ChildNodes) {

                // skip whitespace and comments
                if (HandlerBase.IsIgnorableAlsoCheckForNonElement(child))
                    continue;

                // process <add> and <clear> elements

                if (child.Name == "add") {
                    String name = HandlerBase.RemoveRequiredAttribute(child, "name");
                    String classname = HandlerBase.RemoveRequiredAttribute(child, "type");
                    bool insert = false;

                    /* position and validate removed  See ASURT 96814
                    int iTemp = 0;
                    XmlNode attribute = HandlerBase.GetAndRemoveEnumAttribute(child, "position", typeof(HttpModulesConfigurationPosition), ref iTemp);
                    if (attribute != null) {
                        HttpModulesConfigurationPosition pos = (HttpModulesConfigurationPosition)iTemp;
                        if (pos == HttpModulesConfigurationPosition.Start) {
                            insert = true;
                        }
                    }

                    bool validate = true;
                    HandlerBase.GetAndRemoveBooleanAttribute(child, "validate", ref validate);
                    */

                    if (IsSpecialModule(classname)) {
                        throw new ConfigurationException(
                                        HttpRuntime.FormatResourceString(SR.Special_module_cannot_be_added_manually, classname), 
                                        child);
                    }

                    if (IsSpecialModuleName(name)) {
                        throw new ConfigurationException(
                                        HttpRuntime.FormatResourceString(SR.Special_module_cannot_be_added_manually, name), 
                                        child);
                    }

                    HandlerBase.CheckForUnrecognizedAttributes(child);
                    HandlerBase.CheckForChildNodes(child);

                    if (appConfig.ContainsEntry(name)) {
                        throw new ConfigurationException(
                                        HttpRuntime.FormatResourceString(SR.Module_already_in_app, name), 
                                        child);
                    }
                    else {
                        try {
                            appConfig.Add(name, classname, insert);
                        }
                        catch (Exception e) {
                            throw new ConfigurationException(e.Message, e, child);
                        }
                    }
                }
                else if (child.Name == "remove") {
                    String name = HandlerBase.RemoveRequiredAttribute(child, "name");
                    /*
                    bool validate = true;
                    HandlerBase.GetAndRemoveBooleanAttribute(child, "validate", ref validate);
                    */

                    HandlerBase.CheckForUnrecognizedAttributes(child);
                    HandlerBase.CheckForChildNodes(child);

                    if (!appConfig.RemoveEntry(name)) {
                        if (IsSpecialModuleName(name)) {
                            throw new ConfigurationException(
                                            HttpRuntime.FormatResourceString(SR.Special_module_cannot_be_removed_manually, name),
                                            child);
                        }
                        else {
                            throw new ConfigurationException(
                                            HttpRuntime.FormatResourceString(SR.Module_not_in_app, name),
                                            child);
                        }
                    }

                }
                else if (child.Name == "clear") {
                    HandlerBase.CheckForUnrecognizedAttributes(child);
                    HandlerBase.CheckForChildNodes(child);
                    appConfig.RemoveRange(0, appConfig.Count);
                }
                else {
                    HandlerBase.ThrowUnrecognizedElement(child);
                }
            }

            // inheritance rule for modules config:
            // machine-level and site-level config allows inheritance, dir- (app-) level does not.

            return appConfig;
        }

        static bool IsSpecialModule(String className) {
            return ModulesEntry.IsTypeMatch(typeof(System.Web.Security.DefaultAuthenticationModule), className);
        }

        static bool IsSpecialModuleName(String name) {
            return (String.Compare(name, "DefaultAuthentication", true, CultureInfo.InvariantCulture) == 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\traceconfigurationhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="TraceConfigurationHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Config related classes for HttpApplication
 */

namespace System.Web.Configuration {

    using System.Collections;
    using System.Configuration;
    using System.IO;
    using System.Text;
    using System.Web.Util;
    using System.Xml;

    /*
     * TraceConfig config object
     */

    internal class TraceConfig {
        private int             _requestLimit = 10;
        private TraceMode       _outputMode;
        private bool            _isEnabled = false;
        private bool            _pageOutput;
        private bool            _localOnly = true;

        internal TraceConfig (TraceConfig parent) {
            if (parent != null) {
                _requestLimit       = parent._requestLimit;
                _outputMode         = parent._outputMode;
                _isEnabled          = parent._isEnabled;
                _pageOutput         = parent._pageOutput;
                _localOnly          = parent._localOnly;
            }
        }

        internal int RequestLimit {
            get { return _requestLimit; }
        }

        internal TraceMode OutputMode {
            get { return _outputMode; }
        }

        internal bool IsEnabled {
            get { return _isEnabled; }
        }

        internal bool LocalOnly {
            get { return _localOnly; }
        }
        internal bool PageOutput { 
            get { return _pageOutput; } 
        }

        internal void LoadValuesFromConfigurationXml(XmlNode section) {

            HandlerBase.GetAndRemoveBooleanAttribute(section, "enabled", ref _isEnabled);
            HandlerBase.GetAndRemoveNonNegativeIntegerAttribute(section, "requestLimit", ref _requestLimit);
            HandlerBase.GetAndRemoveBooleanAttribute(section, "pageOutput", ref _pageOutput);
            HandlerBase.GetAndRemoveBooleanAttribute(section, "localOnly", ref _localOnly);

            string [] values = {"SortByTime", "SortByCategory"};
            // TraceMode is in another file in a different namespace ... so lets have some protection if they change
            Debug.Assert(TraceMode.SortByTime == (TraceMode)0);
            Debug.Assert(TraceMode.SortByCategory == (TraceMode)1);
            int iMode = 0;
            XmlNode attribute = HandlerBase.GetAndRemoveEnumAttribute(section, "traceMode", values, ref iMode);
            if (attribute != null) {
                _outputMode = (TraceMode)iMode;
            }

            HandlerBase.CheckForUnrecognizedAttributes(section);
            // section can have no content
            HandlerBase.CheckForChildNodes(section);
        }
    }

    /*
     * Config factory for Trace section
     *
     * syntax:
     *
     *    <trace
     *        enabled=...
     *        requestLimit=...
     *        pageOutput=...
     *	      traceMode=...
     *    />
     *
     * output:
     */
    /// <include file='doc\TraceConfigurationHandler.uex' path='docs/doc[@for="TraceConfigurationHandler"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    internal class TraceConfigurationHandler : IConfigurationSectionHandler {

        internal TraceConfigurationHandler() {
        }

        public virtual object Create(Object parent, object configContextObj, XmlNode section) {
            // if called through client config don't even load HttpRuntime
            if (!HandlerBase.IsServerConfiguration(configContextObj))
                return null;


            TraceConfig config = new TraceConfig((TraceConfig)parent);
            config.LoadValuesFromConfigurationXml(section);

            return config;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\sectionrecord.cs ===
//------------------------------------------------------------------------------
// <copyright file="SectionRecord.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Configuration {
    using System.Web.Util;
    using System.Collections;
    using System.Configuration;

    internal class LocationInput {
        internal string path;
        internal string subPath;
        internal string filename;
        internal Hashtable sections = new Hashtable();
        internal Hashtable lockedSections;
        
        internal LocationInput() {
        }
    }

    internal interface IConfigErrorInfo {
        string Filename   { get; }
        int    LineNumber { get; }
    }

    internal class ConfigErrorInfo : IConfigErrorInfo {
        string filename;
        int    lineNumber;

        internal ConfigErrorInfo(IConfigErrorInfo errorInfo) {
            filename = errorInfo.Filename;
            lineNumber = errorInfo.LineNumber;
        }

        /*public*/ string IConfigErrorInfo.Filename { get { return filename; } }
        /*public*/ int    IConfigErrorInfo.LineNumber { get { return lineNumber; } }
    }



    internal enum SectionStateEnum {
        // state of the section
        None,
        ToBeEvaluated,
        ResultIsException,
        ResultIsValid
    }


    internal class SectionRecord {
        object result;          // holds result of this section
        ArrayList input;        // holds the list of other config files needed to be evauated for this section (via <location> sections)
        SectionStateEnum state;

        internal SectionRecord() {
        }

        internal object Result {
            get {
                if (ResultIsException) {
                    throw (Exception) result;
                }
                return result;
            }
            set {
                result = value;
                ResultIsValid = true;
            }
        }


        internal ArrayList Input {
            get {
                return input;
            }
            set {
                input = value;
            }
        }


        internal void AddInput(LocationInput deferred) {
            if (input == null && deferred != null) {
                input = new ArrayList();
            }
            input.Add(deferred);
            ToBeEvaluated = true;
        }


        internal bool ToBeEvaluated {
            get {
                return state == SectionStateEnum.ToBeEvaluated;
            }
            set {
                if (value) {
                    state = SectionStateEnum.ToBeEvaluated;
                }
            }
        }


        internal bool HaveResult {
            get {
                return ResultIsException || ResultIsValid;
            }
        }


        internal Exception ResultException {
            set {
                result = value;
                state = SectionStateEnum.ResultIsException;
            }
        }


        private bool ResultIsException {
            get {
                return state == SectionStateEnum.ResultIsException;
            }
        }


        private bool ResultIsValid {
            get {
                return state == SectionStateEnum.ResultIsValid;
            }
            set {
                if (value) {
                    state = SectionStateEnum.ResultIsValid;
                }
                else {
                    Debug.Assert(false);
                }
            }
        }
    }


    [Flags]
    internal enum FactoryFlags {
        // Factory Flags
        Locked          = 0x1,
        Removed         = 0x2,
        Group           = 0x4,
        AllowLocation   = 0x8,

        // AllowDefinition is a 2-bit enum (Any, Machine, App)
        AllowDefinitionAny      = 0x00,
        AllowDefinitionMachine  = 0x10,
        AllowDefinitionApp      = 0x20,
        AllowDefinitionMask     = AllowDefinitionMachine | AllowDefinitionApp

    }


    internal class FactoryRecord {
        IConfigurationSectionHandler factory;
        string factoryTypeName;
        FactoryFlags flags;
        int lineNumber;

        private static readonly string GroupFactorySingleton = "Group";

        internal FactoryRecord() {
        }
        
        internal FactoryRecord Clone() {
            FactoryRecord clone = new FactoryRecord();
            clone.factory = factory;
            clone.factoryTypeName = factoryTypeName;
            clone.flags = flags;
            return clone;
        }


        internal IConfigurationSectionHandler Factory {
            get {
                return factory;
            }
            set {
                factory = value;
            }
        }


        internal string FactoryTypeName {
            get {
                return factoryTypeName;
            }
            set {
                factoryTypeName = value;
            }
        }


        internal bool Locked {
            get {
                return (flags & FactoryFlags.Locked) != 0;
            }
            set {
                if (value) {
                    flags |= FactoryFlags.Locked;
                }
                else {
                    flags &= ~FactoryFlags.Locked;
                }
            }
        }


        internal bool Removed {
            get {
                return (flags & FactoryFlags.Removed) != 0;
            }
            set {
                if (value) {
                    flags |= FactoryFlags.Removed;
                }
                else {
                    flags &= ~FactoryFlags.Removed;
                }
            }
        }


        internal bool Group {
            get {
                return (flags & FactoryFlags.Group) != 0;
            }
            set {
                if (value) {
                    flags |= FactoryFlags.Group;
                    FactoryTypeName = GroupFactorySingleton;
                }
                else {
                    Debug.Assert(false);
                }
            }
        }


        internal bool AllowLocation {
            get {
                return (flags & FactoryFlags.AllowLocation) != 0;
            }
            set {
                if (value) {
                    flags |= FactoryFlags.AllowLocation;
                }
                else {
                    flags &= ~FactoryFlags.AllowLocation;
                }
            }
        }


        internal FactoryFlags AllowDefinition {
            get {
                return flags & FactoryFlags.AllowDefinitionMask;
            }
            set {
                Debug.Assert(value == FactoryFlags.AllowDefinitionAny 
                    || value == FactoryFlags.AllowDefinitionMachine 
                    || value == FactoryFlags.AllowDefinitionApp);
                flags = (flags & ~FactoryFlags.AllowDefinitionMask) | value;
            }
        }

        /// <devdoc>
        ///     <para>
        ///         This is used in HttpConfigurationRecord.GetFactory() to give file and line source
        ///         when a section handler type is invalid or cannot be loaded.
        ///     </para>
        /// </devdoc>
        internal int LineNumber {
            get {
                return lineNumber;
            }
            set {
                lineNumber = value;
            }
        }

        internal bool IsEquivalentFactory(string typeName, bool allowLocation, FactoryFlags allowDefinition) {
            if (allowLocation != AllowLocation || allowDefinition != AllowDefinition)
                return false;

            try {
                if (Factory != null) {
                    Type t = Type.GetType(typeName);
                    if (t == Factory.GetType()) {
                        return true;
                    }
                }
                else {
                    Debug.Trace("ctracy", "Checking " + FactoryTypeName + " against " + typeName);
                    if (FactoryTypeName == typeName) {
                        return true;
                    }

                    Type t = Type.GetType(typeName);
                    Type t2 = Type.GetType(FactoryTypeName);
                    if (t == t2) {
                        return true;
                    }
                }
            }
            catch {
            }

            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\webcontrolssectionhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ClientTargetSectionHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Configuration {
    using System.Collections;
    using System.Collections.Specialized;
    using System.Configuration;
    using System.Xml;

    //  Config handler for the clienttarget section
    //
    //  <webControls
    //      clientScriptsLocation="myclientscriptpath"
    //  />
    /// <internalonly />
    /// <devdoc>
    /// </devdoc>
    sealed class WebControlsSectionHandler : IConfigurationSectionHandler {

        internal WebControlsSectionHandler() {
        }

        public object Create(object parent, object configContextObj, XmlNode section) {
            // This line allows us to continue to return a config object of a public type
            // like we did in the first release.  Third parties rely on this to get the 
            // client script location.  But if the section handler is run in client code
            // we will return null, so we aren't exposing information through the 
            // client configuration system.
            if (!HandlerBase.IsServerConfiguration(configContextObj))
                return null;

            // delegate to SingleTagSectionHandler to do the real work
            SingleTagSectionHandler singleTagSectionHandler = new SingleTagSectionHandler();
            return singleTagSectionHandler.Create(parent, configContextObj, section);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\handlers\batchhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="BatchHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * BatchHandler: performs batch compilation in a directory
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */
namespace System.Web.Handlers {
    using System;
    using System.Web;
    using System.Web.UI;
    using System.Web.Compilation;

    /// <include file='doc\BatchHandler.uex' path='docs/doc[@for="BatchHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal class BatchHandler : IHttpHandler {

        internal BatchHandler() {
        }

        void IHttpHandler.ProcessRequest(HttpContext context) {

            try {
                // Only allowed in full trust (ASURT 124294)
                InternalSecurityPermissions.UnmanagedCode.Demand();

                // If we already got an exception trying to batch this directory, just rethrow it
                Exception e = (Exception)CodeDomBatchManager.BatchErrors[context.Request.BaseDir];
                if (e != null)
                    throw e;

                CompilationLock.GetLock();

                // Allow plenty of time for the batch compilation to complete
                context.Server.ScriptTimeout = 3600;

                PreservedAssemblyEntry.BatchHandlerInit(context);

                CodeDomBatchManager.BatchCompile(context.Request.BaseDir, context);

                // If we get this far and no exception was thrown, it must have worked
                context.Response.Write("<h1>Batch compilation was successful!</h1>");
            }
            finally {
                CompilationLock.ReleaseLock();
            }
        }

        /// <include file='doc\BatchHandler.uex' path='docs/doc[@for="BatchHandler.IsReusable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsReusable {
            get { return true; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\handlers\tracehandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="TraceHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Trace Handler
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */
namespace System.Web.Handlers {
    using System;
    using System.Collections;
    using System.Web;
    using System.Globalization;
    using System.Web.UI;
    using System.Web.UI.WebControls;
    using System.Web.UI.HtmlControls;
    using System.Web.SessionState;
    using System.Data;
    using System.Text;
    using System.Drawing;
    using System.Security.Permissions;

    
    /// <include file='doc\TraceHandler.uex' path='docs/doc[@for="TraceHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class TraceHandler : IHttpHandler {
        private const string _style = 
        "<style type=\"text/css\">\r\n" +
        "span.tracecontent { background-color:white; color:black;font: 10pt verdana, arial; }\r\n" +
        "span.tracecontent table { font: 10pt verdana, arial; cellspacing:0; cellpadding:0; margin-bottom:25}\r\n" +
        "span.tracecontent tr.subhead { background-color:cccccc;}\r\n" +
        "span.tracecontent th { padding:0,3,0,3 }\r\n" +
        "span.tracecontent th.alt { background-color:black; color:white; padding:3,3,2,3; }\r\n" +
        "span.tracecontent td { padding:0,3,0,3 }\r\n" +
        "span.tracecontent tr.alt { background-color:eeeeee }\r\n" +
        "span.tracecontent h1 { font: 24pt verdana, arial; margin:0,0,0,0}\r\n" +
        "span.tracecontent h2 { font: 18pt verdana, arial; margin:0,0,0,0}\r\n" +
        "span.tracecontent h3 { font: 12pt verdana, arial; margin:0,0,0,0}\r\n" +
        "span.tracecontent th a { color:darkblue; font: 8pt verdana, arial; }\r\n" +
        "span.tracecontent a { color:darkblue;text-decoration:none }\r\n" +
        "span.tracecontent a:hover { color:darkblue;text-decoration:underline; }\r\n" +
        "span.tracecontent div.outer { width:90%; margin:15,15,15,15}\r\n" +
        "span.tracecontent table.viewmenu td { background-color:006699; color:white; padding:0,5,0,5; }\r\n" +
        "span.tracecontent table.viewmenu td.end { padding:0,0,0,0; }\r\n" +
        "span.tracecontent table.viewmenu a {color:white; font: 8pt verdana, arial; }\r\n" +
        "span.tracecontent table.viewmenu a:hover {color:white; font: 8pt verdana, arial; }\r\n" +
        "span.tracecontent a.tinylink {color:darkblue; font: 8pt verdana, arial;text-decoration:underline;}\r\n" +
        "span.tracecontent a.link {color:darkblue; text-decoration:underline;}\r\n" +
        "span.tracecontent div.buffer {padding-top:7; padding-bottom:17;}\r\n" +
        "span.tracecontent .small { font: 8pt verdana, arial }\r\n" +
        "span.tracecontent table td { padding-right:20 }\r\n" +
        "span.tracecontent table td.nopad { padding-right:5 }\r\n" +
        "</style>\r\n";

        private HttpContext     _context;
        private HttpResponse    _response;
        private HttpRequest     _request;
        private HtmlTextWriter  _writer;

        /// <include file='doc\TraceHandler.uex' path='docs/doc[@for="TraceHandler.TraceHandler"]/*' />
        public TraceHandler() {
            InternalSecurityPermissions.UnmanagedCode.Demand();
        }

        /// <include file='doc\TraceHandler.uex' path='docs/doc[@for="TraceHandler.IHttpHandler.ProcessRequest"]/*' />
        /// <internalonly/>
        void IHttpHandler.ProcessRequest(HttpContext context) {

            if (!context.Request.IsLocal && HttpRuntime.Profile.LocalOnly) {
                HttpException e = new HttpException(403, null);
                e.SetFormatter(new TraceHandlerErrorFormatter(true));
                throw e;
            }
            
            _context = context;
            _response = _context.Response;
            _request = _context.Request;
            _writer = Page.CreateHtmlTextWriterInternal(_response.Output, _request);

            _context.Trace.IsEnabled = false;

            _writer.Write("<html>\r\n");
            _writer.Write("<head>\r\n");
            _writer.Write(StyleSheet);
            _writer.Write("</head>\r\n");

            _writer.Write("<body>\r\n");
            _writer.Write("<span class=\"tracecontent\">\r\n");

            if (!HttpRuntime.Profile.IsConfigEnabled) {
                HttpException e = new HttpException();
                e.SetFormatter(new TraceHandlerErrorFormatter(false));
                throw e;
            }

            ArrayList datasets = HttpRuntime.Profile.GetData();

            // first check if we should clear data
            if (_request.QueryString["clear"] != null) {
                HttpRuntime.Profile.Reset();
                string url = _request.RawUrl;
                _response.Redirect(url.Substring(0, url.IndexOf("?")));
            }
            
            // then check if we are drilling down
            string strid = _request.QueryString["id"];
            if (strid != null) {
                int index = Int32.Parse(strid, CultureInfo.InvariantCulture);
                if (index >=0 && index < datasets.Count) {
                    ShowDetails((DataSet) datasets[index]);
                    _writer.Write("</span>\r\n</body>\r\n</html>\r\n");
                    return;
                }
            }

            // if we get here, its just generic request
            ShowRequests(datasets);
            _writer.Write("</span>\r\n</body>\r\n</html>\r\n");
        }

        /// <include file='doc\TraceHandler.uex' path='docs/doc[@for="TraceHandler.IHttpHandler.IsReusable"]/*' />
        /// <internalonly/>
        bool IHttpHandler.IsReusable {
            get { return false; }
        }

        /// <include file='doc\TraceHandler.uex' path='docs/doc[@for="TraceHandler.ShowDetails"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void ShowDetails(DataSet data) {
            Table table;

            _writer.Write("<h1>" + HttpRuntime.FormatResourceString(SR.Trace_Request_Details) + "</h1><br>");

            table = CreateDetailsTable(data.Tables[SR.Trace_Request]);
            if (table != null)
                table.RenderControl(_writer);

            table = CreateTraceTable(data.Tables[SR.Trace_Trace_Information]);
            if (table != null)
                table.RenderControl(_writer);

            table = CreateControlTable(data.Tables[SR.Trace_Control_Tree]);
            if (table != null)
                table.RenderControl(_writer);

            table = CreateTable(data.Tables[SR.Trace_Session_State]);
            if (table != null)
                table.RenderControl(_writer);

            table = CreateTable(data.Tables[SR.Trace_Application_State]);
            if (table != null)
                table.RenderControl(_writer);

            table = CreateTable(data.Tables[SR.Trace_Cookies_Collection]);
            if (table != null)
                table.RenderControl(_writer);

            table = CreateTable(data.Tables[SR.Trace_Headers_Collection]);
            if (table != null)
                table.RenderControl(_writer);

            table = CreateTable(data.Tables[SR.Trace_Form_Collection]);
            if (table != null)
                table.RenderControl(_writer);

            table = CreateTable(data.Tables[SR.Trace_Querystring_Collection]);
            if (table != null)
                table.RenderControl(_writer);

            table = CreateTable(data.Tables[SR.Trace_Server_Variables]);
            if (table != null)
                table.RenderControl(_writer);

        }

        /// <include file='doc\TraceHandler.uex' path='docs/doc[@for="TraceHandler.ShowRequests"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void ShowRequests(ArrayList datasets) {
            // add the title, application name, physical path, etc. 
            Table table = new Table();
            table.CellPadding = 0;
            table.CellSpacing = 0;
            table.Width = Unit.Percentage(100);
            TableRow trow = AddRow(table);

            AddCell(trow, HttpRuntime.FormatResourceString(SR.Trace_Application_Trace));
            TableCell tcell = AddCell(trow, "[ <a href=\"Trace.axd?clear=1\" class=\"link\">" + HttpRuntime.FormatResourceString(SR.Trace_Clear_Current) + "</a> ]");
            tcell.HorizontalAlign = HorizontalAlign.Right;
            tcell.VerticalAlign = VerticalAlign.Bottom;

            string vroot = _request.ApplicationPath;
            int vrootLen = vroot.Length;

            trow = AddRow(table);
            AddCell(trow, "<h2>" + HttpUtility.HtmlEncode(vroot.Substring(1)) + "<h2><p>");

            // check if we have permission to show the physical path.  If not, don't show anything. 
            string physicalPath = "&nbsp";
            if (HttpRuntime.HasAppPathDiscoveryPermission())
                physicalPath  = "<b>" + HttpRuntime.FormatResourceString(SR.Trace_Physical_Directory) + "</b> " + _request.PhysicalApplicationPath;
            tcell = AddCell(trow, physicalPath);
            tcell.HorizontalAlign = HorizontalAlign.Right;
            tcell.VerticalAlign = VerticalAlign.Bottom;

            table.RenderControl(_writer);

            //////// add the table of requests  ///////
            table = new Table();
            table.CellPadding = 0;
            table.CellSpacing = 0;
            table.Width = Unit.Percentage(100);

            trow = AddRow(table);

            // title for the table
            tcell = AddHeaderCell(trow, "<h3><b>" + HttpRuntime.FormatResourceString(SR.Trace_Requests_This) + "</b></h3>");
            tcell.ColumnSpan = 5;
            tcell.CssClass = "alt";
            tcell.HorizontalAlign = HorizontalAlign.Left;

            tcell = AddHeaderCell(trow, SR.GetString(SR.Trace_Remaining) + " " + HttpRuntime.Profile.RequestsRemaining.ToString(NumberFormatInfo.InvariantInfo));
            tcell.CssClass = "alt";
            tcell.HorizontalAlign = HorizontalAlign.Right;


            // add headers for the columns
            trow = AddRow(table);
            trow.HorizontalAlign = HorizontalAlign.Left;
            trow.CssClass = "subhead";
            AddHeaderCell(trow, HttpRuntime.FormatResourceString(SR.Trace_No));
            AddHeaderCell(trow, HttpRuntime.FormatResourceString(SR.Trace_Time_of_Request));
            AddHeaderCell(trow, HttpRuntime.FormatResourceString(SR.Trace_File));
            AddHeaderCell(trow, HttpRuntime.FormatResourceString(SR.Trace_Status_Code));
            AddHeaderCell(trow, HttpRuntime.FormatResourceString(SR.Trace_Verb));
            AddHeaderCell(trow, "&nbsp");

            // now fill the table with requests
            bool isAlt = true;
            for (int i=0; i<datasets.Count; i++) {
                // for each request
                DataSet current = (DataSet) datasets[i];
                trow = AddRow(table);
                if (isAlt)
                    trow.CssClass = "alt";

                AddCell(trow, (i + 1).ToString(NumberFormatInfo.InvariantInfo));
                AddCell(trow, (string) current.Tables[SR.Trace_Request].Rows[0][SR.Trace_Time_of_Request]);
                AddCell(trow, ((string) current.Tables[SR.Trace_Request].Rows[0][SR.Trace_Url]).Substring(vrootLen));
                AddCell(trow, current.Tables[SR.Trace_Request].Rows[0][SR.Trace_Status_Code].ToString());
                AddCell(trow, (string) current.Tables[SR.Trace_Request].Rows[0][SR.Trace_Request_Type]);

                TableCell linkcell = AddCell(trow, "");
                HtmlAnchor a = new HtmlAnchor();
                a.HRef = "Trace.axd?id=" + i;
                a.InnerHtml = "<b><nobr>" + HttpRuntime.FormatResourceString(SR.Trace_View_Details);
                a.Attributes["class"] = "tinylink";
                linkcell.Controls.Add(a);

                isAlt = !isAlt;
            }
            table.RenderControl(_writer);
        }


        ////// Static methods for creating tables //////////
        static private TableRow AddRow(Table t) {
            TableRow trow = new TableRow();
            t.Rows.Add(trow);
            return trow;
        }

        static private TableCell AddHeaderCell(TableRow trow, string text) {
            TableHeaderCell tcell = new TableHeaderCell();
            tcell.Text = text;
            trow.Cells.Add(tcell);
            return tcell;
        }

        static private TableCell AddCell(TableRow trow, string text) {
            TableCell tcell = new TableCell();
            tcell.Text = text;
            trow.Cells.Add(tcell);
            return tcell;
        }

        static internal string StyleSheet {
            get { return _style;}
        }

        static internal Table CreateControlTable(DataTable datatable) {

            Table           table = new Table();
            TableRow        trow;
            TableCell       tcell;
            IEnumerator     en;
            string          parent;
            string          control;
            Hashtable       indentLevels = new Hashtable();
            int             indent;
            bool            isAlt = false;

            table.Width = Unit.Percentage(100);
            table.CellPadding = 0;
            table.CellSpacing = 0;


            // add a title for the table - same as table name
            trow = AddRow(table);
            tcell = AddHeaderCell(trow, "<h3><b>" + HttpRuntime.FormatResourceString(datatable.TableName) + "</b></h3>");
            tcell.CssClass = "alt";
            tcell.ColumnSpan = 4;
            tcell.HorizontalAlign = HorizontalAlign.Left;

            // add the header information 
            trow = AddRow(table);
            trow.CssClass = "subhead";
            trow.HorizontalAlign = HorizontalAlign.Left;
            AddHeaderCell(trow, HttpRuntime.FormatResourceString(SR.Trace_Control_Id));
            AddHeaderCell(trow, HttpRuntime.FormatResourceString(SR.Trace_Type));
            AddHeaderCell(trow, HttpRuntime.FormatResourceString(SR.Trace_Render_Size_children));
            AddHeaderCell(trow, HttpRuntime.FormatResourceString(SR.Trace_Viewstate_Size_Nochildren));


            // prime the indentLevels hashtable with an initial value
            indentLevels["ROOT"] = 0;

            // now show the tree
            en = datatable.Rows.GetEnumerator();
            while (en.MoveNext()) {
                parent = (string) ((DataRow) en.Current)[SR.Trace_Parent_Id];
                control = HttpUtility.HtmlEncode((string) ((DataRow) en.Current)[SR.Trace_Control_Id]);

                // this lets us determine how far to indent each control
                indent = (int) indentLevels[parent];
                indentLevels[control] = indent + 1;

                // do the indent 
                StringBuilder indentedControl = new StringBuilder();
                for (int i=0; i<indent; i++)
                    indentedControl.Append("&nbsp;&nbsp;&nbsp;&nbsp;");

                // page has a blank ID, so we'll fill in something nice for it
                if (control.Length == 0)
                    indentedControl.Append(HttpRuntime.FormatResourceString(SR.Trace_Page));
                else
                    indentedControl.Append(control);

                trow = AddRow(table);
                AddCell(trow, indentedControl.ToString());
                AddCell(trow, (string) ((DataRow) en.Current)[SR.Trace_Type]);

                object size = ((DataRow) en.Current)[SR.Trace_Render_Size];
                if (size != null)
                    AddCell(trow, ((int) size).ToString(NumberFormatInfo.InvariantInfo));
                else
                    AddCell(trow, "---");

                size = ((DataRow) en.Current)[SR.Trace_Viewstate_Size];
                if (size != null)
                    AddCell(trow, ((int) size).ToString(NumberFormatInfo.InvariantInfo));
                else
                    AddCell(trow, "---");

                // alternate colors
                if (isAlt)
                    trow.CssClass = "alt";
                isAlt = !isAlt;
            }

            return table;
        }

        static internal Table CreateTraceTable(DataTable datatable) {

            if (datatable.Rows.Count == 0)
                return null;

            IEnumerator     en;
            bool            isAlt = false;
            Table           table = new Table();
            TableRow        trow;
            TableCell       tcell;
            DataRow         datarow;


            table.Width = Unit.Percentage(100);
            table.CellPadding = 0;
            table.CellSpacing = 0;

            // add a title for the table - same as table name
            trow = AddRow(table);
            tcell = AddHeaderCell(trow, "<h3><b>" + HttpRuntime.FormatResourceString(datatable.TableName) + "</b></h3>");
            tcell.CssClass = "alt";
            tcell.ColumnSpan = 10;
            tcell.HorizontalAlign = HorizontalAlign.Left;

            // add the header information - same as column names
            trow = AddRow(table);
            trow.CssClass = "subhead";
            trow.HorizontalAlign = HorizontalAlign.Left;
            AddHeaderCell(trow, HttpRuntime.FormatResourceString(SR.Trace_Category));
            AddHeaderCell(trow, HttpRuntime.FormatResourceString(SR.Trace_Message));
            AddHeaderCell(trow, HttpRuntime.FormatResourceString(SR.Trace_From_First));
            AddHeaderCell(trow, HttpRuntime.FormatResourceString(SR.Trace_From_Last));

            // now fill in the values, but don't display null values
            en = datatable.DefaultView.GetEnumerator(); 
            while (en.MoveNext()) {
                trow = AddRow(table);
                datarow = ((DataRowView) en.Current).Row;

                // FormatPlainTextAsHtml the values first
                AddCell(trow, HttpUtility.FormatPlainTextAsHtml((string) datarow[SR.Trace_Category]));
                StringBuilder message = new StringBuilder(HttpUtility.FormatPlainTextAsHtml((string) datarow[SR.Trace_Message]));

                object errormessage = datarow["ErrorInfoMessage"];
                object errorstack =   datarow["ErrorInfoStack"];
                if (!(errormessage is System.DBNull))
                    message.Append("<br>" + HttpUtility.FormatPlainTextAsHtml((string) errormessage));
                if (!(errorstack is System.DBNull))
                    message.Append("<br>" + HttpUtility.FormatPlainTextAsHtml((string) errorstack));

                AddCell(trow, message.ToString());
                AddCell(trow, datarow[SR.Trace_From_First].ToString());
                AddCell(trow, datarow[SR.Trace_From_Last].ToString());

                if (datarow[SR.Trace_Warning].Equals("yes"))
                    trow.ForeColor = Color.Red;

                // alternate colors
                if (isAlt)
                    trow.CssClass = "alt";

                isAlt = !isAlt;
            }

            return table;
        }

        static internal Table CreateTable(DataTable datatable) {
            if (datatable.Rows.Count == 0)
                return null;

            IEnumerator     en;
            bool            isAlt = false;
            Object[]        cells;
            Table           table = new Table();
            TableRow        trow;
            TableCell       tcell;


            table.Width = Unit.Percentage(100);
            table.CellPadding = 0;
            table.CellSpacing = 0;

            // add a title for the table - same as table name
            trow = AddRow(table);
            tcell = AddHeaderCell(trow, "<h3><b>" + HttpRuntime.FormatResourceString(datatable.TableName) + "</b></h3>");
            tcell.CssClass = "alt";
            tcell.ColumnSpan = 10;
            tcell.HorizontalAlign = HorizontalAlign.Left;

            // add the header information - same as column names
            trow = AddRow(table);
            trow.CssClass = "subhead";
            trow.HorizontalAlign = HorizontalAlign.Left;
            en = datatable.Columns.GetEnumerator();
            while (en.MoveNext())
                AddHeaderCell(trow, HttpRuntime.FormatResourceString(((DataColumn) en.Current).ColumnName));

            // now fill in the values, but don't display null values
            en = datatable.Rows.GetEnumerator();
            while (en.MoveNext()) {
                cells = ((DataRow) en.Current).ItemArray;
                trow = AddRow(table);

                for (int i=0; i<cells.Length; i++) {
                    string temp = HttpUtility.HtmlEncode(cells[i].ToString());
                    AddCell(trow, (temp.Length != 0) ? temp : "&nbsp;");
                }

                // alternate colors
                if (isAlt)
                    trow.CssClass = "alt";
                isAlt = !isAlt;
            }

            return table;

        }

        static internal Table CreateDetailsTable(DataTable datatable) {
            Table table = new Table();
            table.Width = Unit.Percentage(100);
            table.CellPadding = 0;
            table.CellSpacing = 0;

            TableRow trow = AddRow(table);
            TableCell tcell = AddHeaderCell(trow, "<h3><b>" + HttpRuntime.FormatResourceString(SR.Trace_Request_Details) + "</b></h3>");
            tcell.ColumnSpan = 10;
            tcell.CssClass = "alt";
            tcell.HorizontalAlign = HorizontalAlign.Left;

            trow = AddRow(table);
            trow.HorizontalAlign = HorizontalAlign.Left;
            AddHeaderCell(trow, HttpRuntime.FormatResourceString(SR.Trace_Session_Id) + ":");
            AddCell(trow, datatable.Rows[0][SR.Trace_Session_Id].ToString());
            AddHeaderCell(trow, HttpRuntime.FormatResourceString(SR.Trace_Request_Type) + ":");
            AddCell(trow, datatable.Rows[0][SR.Trace_Request_Type].ToString());

            trow = AddRow(table);
            trow.HorizontalAlign = HorizontalAlign.Left;
            AddHeaderCell(trow, HttpRuntime.FormatResourceString(SR.Trace_Time_of_Request) + ":");
            AddCell(trow, datatable.Rows[0][SR.Trace_Time_of_Request].ToString());
            AddHeaderCell(trow, HttpRuntime.FormatResourceString(SR.Trace_Status_Code) + ":");
            AddCell(trow, datatable.Rows[0][SR.Trace_Status_Code].ToString());

            trow = AddRow(table);
            trow.HorizontalAlign = HorizontalAlign.Left;
            AddHeaderCell(trow, HttpRuntime.FormatResourceString(SR.Trace_Request_Encoding) + ":");
            AddCell(trow, datatable.Rows[0][SR.Trace_Request_Encoding].ToString());
            AddHeaderCell(trow, HttpRuntime.FormatResourceString(SR.Trace_Response_Encoding) + ":");
            AddCell(trow, datatable.Rows[0][SR.Trace_Response_Encoding].ToString());

            return table;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\configuration\securitypolicyconfig.cs ===
//------------------------------------------------------------------------------
// <copyright file="SecurityPolicyConfig.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * SecurityPolicyConfig class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Configuration {
    using System.Xml;
    using System.Security.Cryptography;
    using System.Configuration;
    using System.Collections;
    
    internal class SecurityPolicyConfigHandler : IConfigurationSectionHandler {
        internal SecurityPolicyConfigHandler() {
        }

        public virtual object Create(Object parent, Object configContextObj, XmlNode section) {
            // if called through client config don't even load HttpRuntime
            if (!HandlerBase.IsServerConfiguration(configContextObj))
                return null;

            
            HttpConfigurationContext configContext = configContextObj as HttpConfigurationContext;
            
            // section handlers can run in client mode with ConfigurationSettings.GetConfig("sectionName")
            // detect this case and return null to be ensure no exploits from secure client scenarios
            // see ASURT 123738
            if (configContext == null) {
                return null;
            }
            
            if (HandlerBase.IsPathAtAppLevel(configContext.VirtualPath) == PathLevel.BelowApp)
                throw new ConfigurationException(
                        HttpRuntime.FormatResourceString(SR.Cannot_specify_below_app_level, section.Name),
                        section);

            return new SecurityPolicyConfig((SecurityPolicyConfig) parent, section, ConfigurationException.GetXmlNodeFilename(section));
        }
    }
    

    internal class SecurityPolicyConfig {

        internal Hashtable   PolicyFiles { get { return _PolicyFiles; }}

        internal SecurityPolicyConfig(SecurityPolicyConfig parent, XmlNode node, String strFile) {
            if (parent != null)
                _PolicyFiles = (Hashtable) parent.PolicyFiles.Clone();
            else
                _PolicyFiles = new Hashtable();


            // CONSIDER: Path.GetDirectoryName()
            String strDir  = strFile.Substring(0, strFile.LastIndexOf('\\')+1);
    
            foreach (XmlNode child in node.ChildNodes) {
                ////////////////////////////////////////////////////////////
                // Step 1: For each child
                if (HandlerBase.IsIgnorableAlsoCheckForNonElement(child))
                    continue;

                if (child.Name != "trustLevel") 
                    HandlerBase.ThrowUnrecognizedElement(child);

                string name = null;
                string file = null;
                XmlNode nameAttribute = HandlerBase.GetAndRemoveRequiredStringAttribute(child, "name", ref name);
                HandlerBase.GetAndRemoveRequiredStringAttribute(child, "policyFile", ref file);
                HandlerBase.CheckForUnrecognizedAttributes(child);
                HandlerBase.CheckForChildNodes(child);
                
                bool fAppend = true; // Append dir to filename
                if (file.Length > 1) {

                    char c1 = file[1];
                    char c0 = file[0];

                    if (c1 == ':') // Absolute file path
                        fAppend = false;
                    else
                        if (c0 == '\\' && c1 == '\\') // UNC file path
                            fAppend = false;
                }

                String strTemp;
                if (fAppend)
                    strTemp = strDir + file;
                else
                    strTemp = file;

                if (_PolicyFiles.Contains(name)) {
                    throw new ConfigurationException(
                                    HttpRuntime.FormatResourceString(SR.Security_policy_level_already_defined, name), 
                                    nameAttribute);
                }
                _PolicyFiles.Add(name, strTemp);
            }

            HandlerBase.CheckForUnrecognizedAttributes(node);

        }

        private  Hashtable   _PolicyFiles;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\redist\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\handlers\tracehandlererrorformatter.cs ===
//------------------------------------------------------------------------------
// <copyright file="TraceHandlerErrorFormatter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   TraceHandlerErrorFormatter.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web.Handlers {
    using System.IO;
    using System.Web.Util;
    using System.Web;
    using System.Collections;

    internal class TraceHandlerErrorFormatter : ErrorFormatter {
        bool _isRemote;

        internal TraceHandlerErrorFormatter(bool isRemote) {
            _isRemote = isRemote;
        }

        protected override string ErrorTitle {
            get { return HttpRuntime.FormatResourceString(SR.Trace_Error_Title);}
        }

        protected override string Description {
            get { 
                if(_isRemote)
                    return HttpRuntime.FormatResourceString(SR.Trace_Error_LocalOnly_Description);
                else
                    return HttpRuntime.FormatResourceString(SR.Trace_Error_Enabled_Description);
            }
        }

        protected override string MiscSectionTitle {
            get { return null; }
        }

        protected override string MiscSectionContent {
            get { return null; }
        }

        protected override string ColoredSquareTitle {
            get { return HttpRuntime.FormatResourceString(SR.Generic_Err_Details_Title); }
        }

        protected override string ColoredSquareDescription {
            get { 
                if(_isRemote)
                    return HttpUtility.HtmlEncode(HttpRuntime.FormatResourceString(SR.Trace_Error_LocalOnly_Details_Desc)); 
                else
                    return HttpUtility.HtmlEncode(HttpRuntime.FormatResourceString(SR.Trace_Error_Enabled_Details_Desc)); 
            }
            
        }

        protected override string ColoredSquareContent {
            get { 
                if(_isRemote)
                    return HttpUtility.HtmlEncode(HttpRuntime.FormatResourceString(SR.Trace_Error_LocalOnly_Details_Sample));
                else
                    return HttpUtility.HtmlEncode(HttpRuntime.FormatResourceString(SR.Trace_Error_Enabled_Details_Sample));
            }
        }

        protected override bool ShowSourceFileInfo {
            get { return false;}
        }

        internal override bool CanBeShownToAllUsers {
            get { return true;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\hosting\isapiruntime.cs ===
//------------------------------------------------------------------------------
// <copyright file="ISAPIRuntime.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * The ASP.NET runtime services
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

namespace System.Web.Hosting {
    using System.Runtime.InteropServices;       
    using System.Collections;
    using System.Reflection;

    using System.Web;
    using System.Web.Util;
    using System.Globalization;
    using System.Security.Permissions;
    
    /// <include file='doc\ISAPIRuntime.uex' path='docs/doc[@for="IISAPIRuntime"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    /// <internalonly/>
    [ComImport, Guid("08a2c56f-7c16-41c1-a8be-432917a1a2d1"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    public interface IISAPIRuntime {
        /// <include file='doc\ISAPIRuntime.uex' path='docs/doc[@for="IISAPIRuntime.StartProcessing"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        
        void StartProcessing();
        /// <include file='doc\ISAPIRuntime.uex' path='docs/doc[@for="IISAPIRuntime.StopProcessing"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        
        void StopProcessing();

        /// <include file='doc\ISAPIRuntime.uex' path='docs/doc[@for="IISAPIRuntime.ProcessRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [return: MarshalAs(UnmanagedType.I4)]
        int ProcessRequest(
                          [In]
                          IntPtr ecb, 
                          [In, MarshalAs(UnmanagedType.I4)]
                          int useProcessModel);
        /// <include file='doc\ISAPIRuntime.uex' path='docs/doc[@for="IISAPIRuntime.DoGCCollect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        
        void DoGCCollect();
    }

    /// <include file='doc\ISAPIRuntime.uex' path='docs/doc[@for="ISAPIRuntime"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    /// <internalonly/>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class ISAPIRuntime : IISAPIRuntime {
        public ISAPIRuntime() {
            InternalSecurityPermissions.UnmanagedCode.Demand();
        }

        /// <include file='doc\ISAPIRuntime.uex' path='docs/doc[@for="ISAPIRuntime.StartProcessing"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void StartProcessing() {
            Debug.Trace("ISAPIRuntime", "StartProcessing");
        }

        /// <include file='doc\ISAPIRuntime.uex' path='docs/doc[@for="ISAPIRuntime.StopProcessing"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void StopProcessing() {
            Debug.Trace("ISAPIRuntime", "StopProcessing");
            HttpRuntime.Close();
        }

        /*
         * Process one ISAPI request
         *
         * @param ecb ECB
         * @param useProcessModel flag set to true when out-of-process
         */
        /// <include file='doc\ISAPIRuntime.uex' path='docs/doc[@for="ISAPIRuntime.ProcessRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int ProcessRequest(IntPtr ecb, int iWRType) {
            HttpWorkerRequest  wr = ISAPIWorkerRequest.CreateWorkerRequest(ecb, iWRType);            
//              switch (iWRType) {
//                  case 2:
//                      wr = new IEWorkerRequest(ecb);
//                      break;
//                  default:
//                      wr = ISAPIWorkerRequest.CreateWorkerRequest(ecb, iWRType);
//  		    break;
//              }

            // check if app path matches (need to restart app domain?)

            String wrPath = wr.GetAppPathTranslated();
            String adPath = HttpRuntime.AppDomainAppPathInternal;


            if (adPath == null || wrPath.Equals(".") ||  // for xsptool it is '.'
                String.Compare(wrPath, adPath, true, CultureInfo.InvariantCulture) == 0) {
                HttpRuntime.ProcessRequest( wr );
                return 0;
            }
            else {
                // need to restart app domain
                HttpRuntime.ShutdownAppDomain("Physical application path changed from " + adPath + " to " + wrPath);
                return 1;
            }
        }

        /// <include file='doc\ISAPIRuntime.uex' path='docs/doc[@for="ISAPIRuntime.DoGCCollect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void DoGCCollect() {
            for (int c = 10; c > 0; c--) {
                System.GC.Collect();
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\hosting\appdomainfactory.cs ===
//------------------------------------------------------------------------------
// <copyright file="AppDomainFactory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * AppDomain factory -- creates app domains on demand
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Hosting {
    using System.Runtime.InteropServices;   
    using System.Collections;
    using System.Globalization;
    using System.Reflection;
    using System.Security.Policy;
    using System.Web;
    using System.Web.Util;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\AppDomainFactory.uex' path='docs/doc[@for="IAppDomainFactory"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    /// <internalonly/>
    [ComImport, Guid("e6e21054-a7dc-4378-877d-b7f4a2d7e8ba"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    public interface IAppDomainFactory {
        /// <include file='doc\AppDomainFactory.uex' path='docs/doc[@for="IAppDomainFactory.Create"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [return: MarshalAs(UnmanagedType.Interface)]
        Object Create(
                     [In, MarshalAs(UnmanagedType.BStr)]
                     String module, 
                     [In, MarshalAs(UnmanagedType.BStr)]
                     String typeName, 
                     [In, MarshalAs(UnmanagedType.BStr)]
                     String appId, 
                     [In, MarshalAs(UnmanagedType.BStr)]
                     String appPath,
                     [In, MarshalAs(UnmanagedType.BStr)]
                     String strUrlOfAppOrigin,
                     [In, MarshalAs(UnmanagedType.I4)]
                     int iZone);
    }

    /// <include file='doc\AppDomainFactory.uex' path='docs/doc[@for="AppDomainFactory"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    /// <internalonly/>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class AppDomainFactory : IAppDomainFactory {
        
        /// <include file='doc\AppDomainFactory.uex' path='docs/doc[@for="AppDomainFactory.AppDomainFactory"]/*' />
        public AppDomainFactory() {
            InternalSecurityPermissions.UnmanagedCode.Demand();
        }

        /*
         *  Creates an app domain with an object inside
         */
        /// <include file='doc\AppDomainFactory.uex' path='docs/doc[@for="AppDomainFactory.Create"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [return: MarshalAs(UnmanagedType.Interface)] 
        public Object Create(String module, String typeName, String appId, String appPath, 
                             String strUrlOfAppOrigin, int iZone) {

            //
            //  Fill app a Dictionary with 'binding rules' -- name value string pairs
            //  for app domain creation
            //

            // REVIEW: the webform suites pass '.' as the app path, so if we detect this,
            // turn app path into the current directory

            if (appPath[0] == '.') {
                System.IO.FileInfo file = new System.IO.FileInfo(appPath);
                appPath = file.FullName;
            }

            if (!appPath.EndsWith("\\")) {
                appPath = appPath + "\\";
            }

            String domainId       = ConstructAppDomainId(appId);
            String appVPath       = ExtractVPathFromAppId(appId);
            String appName        = ConstructAppName(appId, appPath);

            IDictionary bindings = new Hashtable(20);
            AppDomainSetup setup = new AppDomainSetup();
            PopulateDomainBindings(domainId, appId, appName, appPath, appVPath, setup, bindings);

            //
            //  Create the app domain
            //

            AppDomain appDomain = null;

            Debug.Trace("AppDomainFactory", "Creating appdomain.  appPath = " + appPath + "; domainId = " + domainId);

            try {
                appDomain = AppDomain.CreateDomain(domainId,
                                                   GetDefaultDomainIdentity(strUrlOfAppOrigin),
                                                   setup);

                foreach (DictionaryEntry e in bindings)
                    appDomain.SetData((String)e.Key, (String)e.Value);
            }
#if DBG
            catch (Exception e) {
                Debug.Trace("AppDomainFactory", "AppDomain.CreateDomain failed");
                System.Web.UI.Util.DumpExceptionStack(e);
            }
#else
            catch (Exception) {
                Debug.Trace("AppDomainFactory", "AppDomain.CreateDomain failed");
            }
#endif

            if (appDomain == null)
                return null;

            Object result = null;

            try {

                // Configure app domain's security

                PolicyLevel policyLevel = GetPolicyForUrl(strUrlOfAppOrigin, iZone, MakeFileUrl(appPath, false /*dontEscape*/));
                if (policyLevel != null)
                    appDomain.SetAppDomainPolicy(policyLevel);

                // Create the object in the app domain

#if DBG
                try {
                    result = appDomain.CreateInstance(module, typeName);
                }
                catch (Exception e) {
                    Debug.Trace("AppDomainFactory", "appDomain.CreateInstance failed");
                    System.Web.UI.Util.DumpExceptionStack(e);
                    throw;
                }
#else
                result = appDomain.CreateInstance(module, typeName);
#endif
            }
            finally {
                if (result == null)
                    AppDomain.Unload(appDomain);
            }

            return result;
        }

        internal static void PopulateDomainBindings(String domainId, String appId, String appName, 
                                                    String appPath, String appVPath,
                                                    AppDomainSetup setup, IDictionary dict) {
            // assembly loading settings
            setup.PrivateBinPath        = "bin";
            setup.PrivateBinPathProbe   = "*";  // disable loading from app base
            setup.ShadowCopyFiles       = "true";
            setup.ApplicationBase       = MakeFileUrl(appPath, true /* dontEscape, see ASURT 107881 */);
            setup.ApplicationName       = appName;
            setup.ConfigurationFile     = "web.config";

            // Disallow code download, since it's unreliable in services (ASURT 123836/127606)
            setup.DisallowCodeDownload  = true;

            // internal settings
            dict.Add(".appDomain",     "*");
            dict.Add(".appId",         appId);
            dict.Add(".appPath",       appPath);
            dict.Add(".appVPath",      appVPath);
            dict.Add(".domainId",      domainId);
            dict.Add(".appName",       appName);
        }

        private static Evidence GetDefaultDomainIdentity(String strUrlOfAppOrigin) {
            Evidence     evidence      = new Evidence();
            bool         hasZone       = false;
            IEnumerator  enumerator;

            if (strUrlOfAppOrigin == null || strUrlOfAppOrigin.Length < 1)
                strUrlOfAppOrigin = "http://localhost/ASP_Plus";

            enumerator = AppDomain.CurrentDomain.Evidence.GetHostEnumerator();
            while (enumerator.MoveNext()) {
                if (enumerator.Current is Zone)
                    hasZone = true;
                evidence.AddHost( enumerator.Current );
            }

            enumerator = AppDomain.CurrentDomain.Evidence.GetAssemblyEnumerator();
            while (enumerator.MoveNext()) {
                evidence.AddAssembly( enumerator.Current );
            }

            evidence.AddHost( new Url( strUrlOfAppOrigin ) );
            if (!hasZone)
                evidence.AddHost( new Zone( SecurityZone.MyComputer ) );

            return evidence;
        }

        private static String ExtractVPathFromAppId(String id) {
            // app id is /LM/W3SVC/1/ROOT for root or /LM/W3SVC/1/ROOT/VDIR

            // find fifth / (assuming it starts with /)
            int si = 0;
            for (int i = 1; i < 5; i++) {
                si = id.IndexOf('/', si+1);
                if (si < 0)
                    break;
            }

            if (si < 0) // root?
                return "/";
            else
                return id.Substring(si);
        }

        private static String ConstructAppName(string id, string physicalDir) {
            return (String.Concat(id, physicalDir).GetHashCode()).ToString("x");
        }

        internal static String ConstructSimpleAppName(string virtPath) {
            if (virtPath.Length <= 1) // root?
                return "root";
            else
                return virtPath.Substring(1).ToLower(CultureInfo.InvariantCulture).Replace('/', '_');
        }

        private static String ConstructAppDomainId(String id) {
            int domainCount = 0;

            lock (s_Lock) {
                domainCount = ++s_domainCount;
            }

            return id + "-" + domainCount.ToString(NumberFormatInfo.InvariantInfo) + "-" + DateTime.UtcNow.ToFileTime().ToString();
        }

        private static String MakeFileUrl(String path, bool dontEscape) {
            Uri uri = new Uri(path, dontEscape);
            return uri.ToString();
        }

        private static PolicyLevel GetPolicyForUrl(String strUrl, int iZone, String strAppPath) {
            if (strUrl == null || strAppPath == null || strUrl.Length < 1 || strAppPath.Length < 1)
                return null;

            Evidence         evidence  = new Evidence();
            PolicyLevel      plReturn  = PolicyLevel.CreateAppDomainLevel();
            PermissionSet    denyPS = null;
            PermissionSet    ps;
            UnionCodeGroup   allCG;
            UnionCodeGroup   snCG;
            UnionCodeGroup   cg;

            evidence.AddAssembly(new Url(strUrl));
            evidence.AddAssembly(new Zone((SecurityZone) iZone));

            ps =  SecurityManager.ResolvePolicy(evidence,
                                                null, null, null, out denyPS);

            ps.RemovePermission( typeof( UrlIdentityPermission ) );
            ps.RemovePermission( typeof( ZoneIdentityPermission ) );


            allCG = new UnionCodeGroup( new AllMembershipCondition(), 
                                        new PolicyStatement( new PermissionSet( PermissionState.None )) );
            snCG = new UnionCodeGroup(
                                     new StrongNameMembershipCondition(new StrongNamePublicKeyBlob( s_microsoftPublicKey ), null, null ), 
                                     new PolicyStatement ( new PermissionSet( PermissionState.Unrestricted ) ) );

            if (!strAppPath.EndsWith("/"))
                strAppPath += "/";
            strAppPath += "*";

            cg = new UnionCodeGroup(
                                   new UrlMembershipCondition(strAppPath), 
                                   new PolicyStatement(ps));

            allCG.AddChild( snCG );
            allCG.AddChild( cg );
            plReturn.RootCodeGroup.AddChild(allCG);

            return plReturn;
        }

        private static int s_domainCount = 0;
        private static Object s_Lock = new Object();

        private static byte[] s_microsoftPublicKey = 
        { 
            0, 36, 0, 0, 4, 128, 0, 0, 148, 0, 0, 0, 6, 2, 0, 0, 0, 36, 0, 0,
            82, 83, 65, 49, 0, 4, 0, 0, 3, 0, 0, 0, 207, 203, 50, 145, 170,
            113, 95, 233, 157, 64, 212, 144, 64, 51, 111, 144, 86, 215, 136,
            111, 237, 70, 119, 91, 199, 187, 84, 48, 186, 68, 68, 254, 248, 52,
            142, 189, 6, 249, 98, 243, 151, 118, 174, 77, 195, 183, 176, 74,
            127, 230, 244, 159, 37, 247, 64, 66, 62, 191, 44, 11, 137, 105, 141,
            141, 8, 172, 72, 214, 156, 237, 15, 200, 248, 59, 70, 94, 8, 7, 172,
            17, 236, 29, 204, 125, 5, 78, 128, 122, 67, 51, 109, 222, 64, 138,
            83, 147, 164, 133, 86, 18, 50, 114, 206, 238, 231, 47, 22, 96, 183,
            25, 39, 211, 133, 97, 170, 191, 92, 172, 29, 241, 115, 70, 51, 198,
            2, 248, 242, 213 
        };
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\hosting\applicationhost.cs ===
//------------------------------------------------------------------------------
// <copyright file="ApplicationHost.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Hosting {

    using System;
    using System.IO;
    using System.Collections;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Web;
    using System.Web.Configuration;
    using System.Web.Util;
    using System.Security.Permissions;

    /// <include file='doc\ApplicationHost.uex' path='docs/doc[@for="ApplicationHost"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class ApplicationHost {

        private ApplicationHost() {
        }

        /*
         * Creates new app domain for hosting of ASP.NET apps with a
         * user defined 'host' object in it.  The host is needed to make
         * cross-domain calls to process requests in the host's app domain
         */
        /// <include file='doc\ApplicationHost.uex' path='docs/doc[@for="ApplicationHost.CreateApplicationHost"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Object CreateApplicationHost(Type hostType, String virtualDir, String physicalDir) {
            InternalSecurityPermissions.UnmanagedCode.Demand();

            if (Environment.OSVersion.Platform != PlatformID.Win32NT)
                throw new PlatformNotSupportedException(SR.GetString(SR.RequiresNT));

            if (!physicalDir.EndsWith("\\"))
                physicalDir = physicalDir + "\\";

            String installDir       = HttpRuntime.AspInstallDirectoryInternal;
            String domainId         = (DateTime.Now.ToString(DateTimeFormatInfo.InvariantInfo).GetHashCode()).ToString("x");
            String appName          = (String.Concat(virtualDir, physicalDir).GetHashCode()).ToString("x");

            IDictionary bindings = new Hashtable(20);
            AppDomainSetup setup = new AppDomainSetup();
            AppDomainFactory.PopulateDomainBindings(domainId, appName, appName, physicalDir, virtualDir, setup, bindings);

            // create the app domain and configure it
            AppDomain appDomain = AppDomain.CreateDomain(domainId, null, setup);

            foreach (DictionaryEntry e in bindings)
                appDomain.SetData((String)e.Key, (String)e.Value);

            // hosting specific settings
            appDomain.SetData(".hostingVirtualPath",    virtualDir);
            appDomain.SetData(".hostingInstallDir",     installDir);

            // init comfig in the new app domain
            InitConfigInNewAppDomain(appDomain);

            // create and return the object in the app domain
            ObjectHandle h = appDomain.CreateInstance(hostType.Module.Assembly.FullName, hostType.FullName);
            return h.Unwrap();
        }

        private static void InitConfigInNewAppDomain(AppDomain appDomain) {
            Type helperType = typeof(ConfigInitHelper);
            ObjectHandle h = appDomain.CreateInstance(helperType.Module.Assembly.FullName, helperType.FullName);
            ConfigInitHelper helper = (ConfigInitHelper)h.Unwrap();
            helper.InitConfig();
        }

        internal class ConfigInitHelper : MarshalByRefObject {

            // this constructor needs to be public despite the fact that it's in an internal
            // class so it can be created by Activator.CreateInstance.
            public ConfigInitHelper() {}

            internal void InitConfig() {
                HttpConfigurationSystemBase.EnsureInit();
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\hosting\simpleworkerrequest.cs ===
//------------------------------------------------------------------------------
// <copyright file="SimpleWorkerRequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Hosting {

    using System.Collections;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Security.Principal;
    using System.Security;
    using System.Security.Permissions;
    using System.Threading;
    using System.Web.Configuration;
    using System.Web.Util;

    //
    // Simple Worker Request provides a concrete implementation 
    // of HttpWorkerRequest that writes the respone to the user
    // supplied writer.
    //
    /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [ComVisible(false)]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class SimpleWorkerRequest : HttpWorkerRequest {

        private bool        _hasRuntimeInfo;
        private String      _appVirtPath;       // "/foo"
        private String      _appPhysPath;       // "c:\foo\"
        private String      _page;
        private String      _pathInfo;
        private String      _queryString;
        private TextWriter  _output;
        private String      _installDir;

        private void ExtractPagePathInfo() {
            int i = _page.IndexOf('/');

            if (i >= 0) {
                _pathInfo = _page.Substring(i);
                _page = _page.Substring(0, i);
            }
        }

        private String GetPathInternal(bool includePathInfo) {
            String s = _appVirtPath.Equals("/") ? ("/" + _page) : (_appVirtPath + "/" + _page);

            if (includePathInfo && _pathInfo != null)
                return s + _pathInfo;
            else
                return s;
        }

        //
        //  HttpWorkerRequest implementation
        //

        // "/foo/page.aspx/tail"
        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.GetUriPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String GetUriPath() {
            return GetPathInternal(true);
        }

        // "param=bar"
        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.GetQueryString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String GetQueryString() {
            return _queryString;
        }

        // "/foo/page.aspx/tail?param=bar"
        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.GetRawUrl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String GetRawUrl() {
            String qs = GetQueryString();
            if (qs != null && qs.Length > 0)
                return GetPathInternal(true) + "?" + qs;
            else
                return GetPathInternal(true);
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.GetHttpVerbName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String GetHttpVerbName() {
            return "GET";
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.GetHttpVersion"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String GetHttpVersion() {
            return "HTTP/1.0";
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.GetRemoteAddress"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String GetRemoteAddress() {
            return "127.0.0.1";
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.GetRemotePort"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetRemotePort() {
            return 0;
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.GetLocalAddress"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String GetLocalAddress() {
            return "127.0.0.1";
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.GetLocalPort"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetLocalPort() {
            return 80;
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.GetUserToken"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override IntPtr GetUserToken() {
            return IntPtr.Zero;
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.GetFilePath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String GetFilePath() {
            return GetPathInternal(false);
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.GetFilePathTranslated"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String GetFilePathTranslated() {
            String path =  _appPhysPath + _page.Replace('/', '\\');
            InternalSecurityPermissions.PathDiscovery(path).Demand();
            return path;
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.GetPathInfo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String GetPathInfo() {
            return (_pathInfo != null) ? _pathInfo : String.Empty;
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.GetAppPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String GetAppPath() {
            return _appVirtPath;
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.GetAppPathTranslated"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String GetAppPathTranslated() {
            InternalSecurityPermissions.PathDiscovery(_appPhysPath).Demand();
            return _appPhysPath;
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.GetServerVariable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String GetServerVariable(String name) {
            return String.Empty;
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.MapPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String MapPath(String path) {
            if (!_hasRuntimeInfo)
                return null;

            String mappedPath = null;
            String appPath = _appPhysPath.Substring(0, _appPhysPath.Length-1); // without trailing "\"

            if (path == null || path.Length == 0 || path.Equals("/")) {
                mappedPath = appPath;
            }
            if (path.StartsWith(_appVirtPath)) {
                mappedPath = appPath + path.Substring(_appVirtPath.Length).Replace('/', '\\');
            }

            InternalSecurityPermissions.PathDiscovery(mappedPath).Demand();
            return mappedPath;
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.MachineConfigPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string MachineConfigPath {
            get {
                if (_hasRuntimeInfo) {
                    string path = HttpConfigurationSystemBase.MachineConfigurationFilePath;
                    InternalSecurityPermissions.PathDiscovery(path).Demand();
                    return path;
                }
                else 
                    return null;
            }
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.MachineInstallDirectory"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override String MachineInstallDirectory {
            get {
                if (_hasRuntimeInfo) {
                    InternalSecurityPermissions.PathDiscovery(_installDir).Demand();
                    return _installDir;
                }
                return null;
            }
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.SendStatus"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void SendStatus(int statusCode, String statusDescription) {
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.SendKnownResponseHeader"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void SendKnownResponseHeader(int index, String value) {
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.SendUnknownResponseHeader"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void SendUnknownResponseHeader(String name, String value) {
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.SendResponseFromMemory"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void SendResponseFromMemory(byte[] data, int length) {
            _output.Write(System.Text.Encoding.Default.GetChars(data, 0, length));
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.SendResponseFromFile"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void SendResponseFromFile(String filename, long offset, long length) {
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.SendResponseFromFile1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void SendResponseFromFile(IntPtr handle, long offset, long length) {
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.FlushResponse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void FlushResponse(bool finalFlush) {
        }

        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.EndOfRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void EndOfRequest() {
        }

        //
        // Ctors
        //

        private SimpleWorkerRequest() {
        }

        /*
         *  Ctor that gets application data from HttpRuntime, assuming
         *  HttpRuntime has been set up (app domain specially created, etc.)
         */
        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.SimpleWorkerRequest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SimpleWorkerRequest(String page, String query, TextWriter output) {
            InternalSecurityPermissions.UnmanagedCode.Demand();

            _queryString = query;
            _output = output;
            _page = page;

            ExtractPagePathInfo();

            _appPhysPath = Thread.GetDomain().GetData(".appPath").ToString();
            _appVirtPath = Thread.GetDomain().GetData(".hostingVirtualPath").ToString();
            _installDir  = Thread.GetDomain().GetData(".hostingInstallDir").ToString();

            _hasRuntimeInfo = true;
        }

        /*
         *  Ctor that gets application data as arguments,assuming HttpRuntime
         *  has not been set up.
         *
         *  This allows for limited functionality to execute handlers.
         */
        /// <include file='doc\SimpleWorkerRequest.uex' path='docs/doc[@for="SimpleWorkerRequest.SimpleWorkerRequest1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SimpleWorkerRequest(String appVirtualDir, String appPhysicalDir, String page, String query, TextWriter output) {
            InternalSecurityPermissions.UnmanagedCode.Demand();

            if (Thread.GetDomain().GetData(".appPath") != null) {
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Wrong_SimpleWorkerRequest));
            }

            _appVirtPath = appVirtualDir;
            _appPhysPath = appPhysicalDir;
            _queryString = query;
            _output = output;
            _page = page;

            ExtractPagePathInfo();

            if (!_appPhysPath.EndsWith("\\"))
                _appPhysPath += "\\";
                
            _hasRuntimeInfo = false;
        }
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\codeaccesssecurityhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeAccessSecurityHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * CodeAccessSecurityHandler class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Security {
    using System.Collections;
    using System.Configuration;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Web.Util;
    using System.Web.Configuration;
    using System.Xml;


    internal class CodeAccessSecurityHandler : IConfigurationSectionHandler {
        internal CodeAccessSecurityHandler() {
        }

        public virtual object Create(Object parent, Object configContextObj, XmlNode section) {
            // if called through client config don't even load HttpRuntime
            if (!HandlerBase.IsServerConfiguration(configContextObj))
                return null;

            HttpConfigurationContext configContext = (HttpConfigurationContext)configContextObj;
            if (HandlerBase.IsPathAtAppLevel(configContext.VirtualPath) == PathLevel.BelowApp)
                throw new ConfigurationException(
                        HttpRuntime.FormatResourceString(SR.Cannot_specify_below_app_level, section.Name),
                        section);

            HandlerBase.CheckForChildNodes(section);
            CodeAccessSecurityValues oRet = new CodeAccessSecurityValues();

            XmlNode oAttribute = section.Attributes.RemoveNamedItem("level");
            if (oAttribute != null)
                oRet.level = oAttribute.Value;
            else
                oRet.level = (parent != null ? ((CodeAccessSecurityValues)parent).level : "");

            oAttribute = section.Attributes.RemoveNamedItem("originUrl");
            if (oAttribute != null)
                oRet.url = oAttribute.Value;
            else
                oRet.url = (parent != null ? ((CodeAccessSecurityValues)parent).url : "");

            HandlerBase.CheckForUnrecognizedAttributes(section);

            oRet.filename = ConfigurationException.GetXmlNodeFilename(section);
            oRet.lineNumber = ConfigurationException.GetXmlNodeLineNumber(section);

            return oRet;
        }
    }

    internal class CodeAccessSecurityValues {
        internal String level;
        internal String url;
        // Keep error-info so we can throw a ConfigurationException if the trust level is not found.
        // This gives the user the XML source and line no. to give the context of the error.
        internal string filename;
        internal int    lineNumber;

        internal CodeAccessSecurityValues() {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\fileauthorizationmodule.cs ===
//------------------------------------------------------------------------------
// <copyright file="FileAuthorizationModule.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * FileAclAuthorizationModule class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Security {
    using System.Runtime.Serialization;
    using System.IO;
    using System.Web;
    using System.Web.Caching;
    using System.Web.Util;
    using System.Web.Configuration;
    using System.Collections;
    using System.Security.Principal;
    using System.Globalization;
    using System.Security.Permissions;
    using System.Runtime.InteropServices;
    

    /// <include file='doc\FileAuthorizationModule.uex' path='docs/doc[@for="FileAuthorizationModule"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Verifies that the remote user has NT permissions to access the
    ///       file requested.
    ///    </para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class FileAuthorizationModule : IHttpModule {

        /// <include file='doc\FileAuthorizationModule.uex' path='docs/doc[@for="FileAuthorizationModule.FileAuthorizationModule"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.Security.FileAuthorizationModule'/>
        ///       class.
        ///     </para>
        /// </devdoc>
        public FileAuthorizationModule() {
            InternalSecurityPermissions.UnmanagedCode.Demand();
        }

        /// <include file='doc\FileAuthorizationModule.uex' path='docs/doc[@for="FileAuthorizationModule.Init"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Init(HttpApplication app) {
            app.AuthorizeRequest += new EventHandler(this.OnEnter);
        }

        /// <include file='doc\FileAuthorizationModule.uex' path='docs/doc[@for="FileAuthorizationModule.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Dispose() {
        }

        void OnEnter(Object source, EventArgs eventArgs) {
            HttpApplication app;
            HttpContext context;

            app = (HttpApplication)source;
            context = app.Context;

            ////////////////////////////////////////////////////////////
            // Step 1: Check if this is WindowsLogin
            if ( context.User           == null ||
                 context.User.Identity  == null || 
                 (context.User.Identity is WindowsIdentity )  == false) {
                // It's not a windows authenticated user: allow access
                return;
            }


            int   iAccess  = 0;
            if ( String.Compare(context.Request.HttpMethod, "GET",  false, CultureInfo.InvariantCulture) == 0 ||
                 String.Compare(context.Request.HttpMethod, "HEAD", false, CultureInfo.InvariantCulture) == 0 ||
                 String.Compare(context.Request.HttpMethod, "POST", false, CultureInfo.InvariantCulture) == 0  ) {
                iAccess = 1;
            }
            else {
                iAccess = 3;
            }
            ////////////////////////////////////////////////////////////
            // Step 3: Check the cache for the file-security-descriptor
            //        for the requested file
            Object                        sec;
            FileSecurityDescriptorWrapper oSecDesc;
            string                        oCacheKey;
            bool                          fCacheAddFailed = false;
            string                        requestPhysicalPath = context.Request.PhysicalPathInternal;

            oCacheKey = "System.Web.Security.FileSecurityDescriptorWrapper:" + requestPhysicalPath;

            sec = HttpRuntime.CacheInternal.Get(oCacheKey);

            // If it's not present in the cache, then create it and add to the cache
            if (sec == null || !(sec is FileSecurityDescriptorWrapper)) {

                // If the file doesn't exist on disk, we'll send back a 404
                //if (!FileUtil.FileExists(requestPhysicalPath))
                //    return;

                // Make it a "sensitive" dependency object so it won't filter out notification
                // if the access time is sooner than dependency creation time.
                // The problem is that setting the ACL won't change the access time of a file.
                // Get the file-security descriptor from native code:
                //   ctor of FileSecurityDescriptorWrapper does that
                oSecDesc = new FileSecurityDescriptorWrapper(requestPhysicalPath);

                if (oSecDesc.IsHandleValid()) {
                    // Add it to the cache: ignore failures, since a different thread may have added it or the file doesn't exist
                    try {
                        CacheDependency dependency = new CacheDependency(true, requestPhysicalPath);
                        HttpRuntime.CacheInternal.UtcInsert(
                                oCacheKey, 
                                oSecDesc, 
                                dependency, 
                                Cache.NoAbsoluteExpiration, 
                                Cache.NoSlidingExpiration,
                                CacheItemPriority.Default, 
                                new CacheItemRemovedCallback(oSecDesc.OnCacheItemRemoved));
                    }
                    catch (Exception) {
                        fCacheAddFailed = true;
                    }
                }
            }
            else { // Cast it to the appropiate type
                oSecDesc = (FileSecurityDescriptorWrapper) sec;
            }

            ////////////////////////////////////////////////////////////
            // Step 4: Check if access is allowed            
            bool fAllowed;
            
            if (oSecDesc._AnonymousAccessChecked && !context.User.Identity.IsAuthenticated)
                fAllowed = oSecDesc._AnonymousAccess;
            else
                fAllowed = oSecDesc.IsAccessAllowed(context.WorkerRequest.GetUserToken(), iAccess);

            if (!oSecDesc._AnonymousAccessChecked && !context.User.Identity.IsAuthenticated)
            {
                oSecDesc._AnonymousAccess = fAllowed;
                oSecDesc._AnonymousAccessChecked = true;
            }

            ////////////////////////////////////////////////////////////
            // Step 5: Free the security descriptor if adding to cache failed
            if (fCacheAddFailed)
                oSecDesc.FreeSecurityDescriptor();


            ////////////////////////////////////////////////////////////
            // Step 6: Allow or deny access
            if (fAllowed) { // Allow access
                return;
            }
            else { // Disallow access
                context.Response.StatusCode = 401;
                WriteErrorMessage(context);
                app.CompleteRequest();
                return;
            }
        }



        private void WriteErrorMessage(HttpContext context) {
            CustomErrors customErrorsSetting = CustomErrors.GetSettings(context);

            if (!customErrorsSetting.CustomErrorsEnabled(context.Request)) {
                context.Response.Write((new FileAccessFailedErrorFormatter(context.Request.PhysicalPathInternal)).GetHtmlErrorMessage(false));
            } else {
                context.Response.Write((new FileAccessFailedErrorFormatter(null)).GetHtmlErrorMessage(true));  
            }
        }


        static internal bool RequestRequiresAuthorization(HttpContext context) {
            Object                        sec;
            FileSecurityDescriptorWrapper oSecDesc;
            string                        oCacheKey;

            oCacheKey = "System.Web.Security.FileSecurityDescriptorWrapper:" + context.Request.PhysicalPathInternal;

            sec = HttpRuntime.CacheInternal.Get(oCacheKey);

            // If it's not present in the cache, then return true
            if (sec == null || !(sec is FileSecurityDescriptorWrapper))
                return true;

            oSecDesc = (FileSecurityDescriptorWrapper) sec;
            if (oSecDesc._AnonymousAccessChecked && oSecDesc._AnonymousAccess)
                return false;

            return true;
        }
    }

    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    internal class FileSecurityDescriptorWrapper {
        ~FileSecurityDescriptorWrapper() {
            UnsafeNativeMethods.FreeFileSecurityDescriptor(_descriptorHandle);
        }

        internal FileSecurityDescriptorWrapper(String strFile) {
            _descriptorHandle = new HandleRef(this, UnsafeNativeMethods.GetFileSecurityDescriptor(strFile));
        }

        internal bool IsAccessAllowed(IntPtr iToken, int iAccess) {
            if (_descriptorHandle.Handle == (IntPtr)0 || iToken == (IntPtr)0)
                return true;

            if (_descriptorHandle.Handle == (IntPtr) (-1))
                return false;

            return(UnsafeNativeMethods.IsAccessToFileAllowed(_descriptorHandle, iToken, iAccess) != 0);
        }

        internal void OnCacheItemRemoved(String key, Object value, CacheItemRemovedReason reason) {
            FreeSecurityDescriptor();
        }

        internal void FreeSecurityDescriptor() {
            /*
            if (_descriptorHandle.Handle != (IntPtr)0 && _descriptorHandle.Handle != (IntPtr) (-1)) {
                HandleRef hDes = new HandleRef(this, _descriptorHandle.Handle);
                _descriptorHandle = new HandleRef(this, (IntPtr) (-1));

                if (hDes.Handle != (IntPtr)0 && hDes.Handle != (IntPtr) (-1))
                    UnsafeNativeMethods.FreeFileSecurityDescriptor(hDes);
            }
            */
        }

        internal bool IsHandleValid() { return (_descriptorHandle.Handle != (IntPtr)(-1) &&  _descriptorHandle.Handle != (IntPtr)(0)); }
        private  HandleRef _descriptorHandle;
        internal bool _AnonymousAccessChecked;
        internal bool _AnonymousAccess;
    }

    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    internal class FileAccessFailedErrorFormatter : ErrorFormatter {
        private String _strFile;
        internal FileAccessFailedErrorFormatter(string strFile) {
            _strFile = strFile;
            if (_strFile == null)
                _strFile = String.Empty;
        }

        protected override string ErrorTitle {
            get { return HttpRuntime.FormatResourceString(SR.Assess_Denied_Title);}
            //get { return "Access Denied Error";}
        }

        protected override string Description {
            get {
                return HttpRuntime.FormatResourceString(SR.Assess_Denied_Description3); 
                //return "An error occurred while accessing the resources required to serve this request. &nbsp; This typically happens if you do not have permissions to view the file you are trying to access.";
            }
        }

        protected override string MiscSectionTitle {
            get { return HttpRuntime.FormatResourceString(SR.Assess_Denied_Section_Title3); }
            //get { return "Error message 401.3";}
        }

        protected override string MiscSectionContent {
            get {      
                if (_strFile.Length > 0)
                    return HttpRuntime.FormatResourceString(SR.Assess_Denied_Misc_Content3, HttpRuntime.GetSafePath(_strFile));
                //return "Access is denied due to NT ACLs on the requested file. Ask the web server's administrator to give you access to "+ _strFile + ".";
                else
                    return HttpRuntime.FormatResourceString(SR.Assess_Denied_Misc_Content3_2);
            }
        }

        protected override string ColoredSquareTitle {
            get { return null;}
        }

        protected override string ColoredSquareContent {
            get { return null;}
        }

        protected override bool ShowSourceFileInfo {
            get { return false;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\formsauthentication.cs ===
//------------------------------------------------------------------------------
// <copyright file="FormsAuthentication.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * FormsAuthentication class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

namespace System.Web.Security {
    using System;
    using System.Web;
    using System.Text;
    using System.Web.Configuration;
    using System.Web.Caching;
    using System.Collections;
    using System.Web.Util;
    using System.Security.Cryptography;
    using System.Security.Principal;
    using System.Threading;
    using System.Globalization;
    using System.Security.Permissions;
    

    /// <include file='doc\FormsAuthentication.uex' path='docs/doc[@for="FormsAuthentication"]/*' />
    /// <devdoc>
    ///    This class consists of static methods that
    ///    provides helper utilities for manipulating authentication tickets.
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class FormsAuthentication {
        private const int  MAC_LENGTH    = 20;
        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        // Helper functions: Hash a password
        /// <include file='doc\FormsAuthentication.uex' path='docs/doc[@for="FormsAuthentication.HashPasswordForStoringInConfigFile"]/*' />
        /// <devdoc>
        ///    Initializes FormsAuthentication by reading
        ///    configuration and getting the cookie values and encryption keys for the given
        ///    application.
        /// </devdoc>
        public static String HashPasswordForStoringInConfigFile(String password, String passwordFormat) {
            if (password == null) {
                throw new ArgumentNullException("password");
            }
            if (passwordFormat == null) {
                throw new ArgumentNullException("passwordFormat");
            }

            byte []  bBlob;
            if (String.Compare(passwordFormat, "sha1", true, CultureInfo.InvariantCulture) == 0)
                bBlob = GetMacFromBlob(Encoding.UTF8.GetBytes(password));
            else if (String.Compare(passwordFormat, "md5", true, CultureInfo.InvariantCulture) == 0)
                bBlob = GetMD5FromBlob(Encoding.UTF8.GetBytes(password));
            else
                throw new ArgumentException(HttpRuntime.FormatResourceString(SR.InvalidArgumentValue, "passwordFormat"));


            return MachineKey.ByteArrayToHexString(bBlob, 0);
        }

        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        // Initialize this
        /// <include file='doc\FormsAuthentication.uex' path='docs/doc[@for="FormsAuthentication.Initialize"]/*' />
        /// <devdoc>
        ///    Initializes FormsAuthentication by reading
        ///    configuration and getting the cookie values and encryption keys for the given
        ///    application.
        /// </devdoc>
        public static void Initialize() {
            if (_Initialized)
                return;

            lock(typeof(FormsAuthentication)) {
                if (_Initialized)
                    return;

                HttpContext         context = HttpContext.Current;
                AuthenticationConfig settings = (AuthenticationConfig) context.GetConfig("system.web/authentication");
                
                _FormsName = settings.CookieName;
                _RequireSSL = settings.RequireSSL;
                _SlidingExpiration = settings.SlidingExpiration;
                if (_FormsName == null)
                    _FormsName = CONFIG_DEFAULT_COOKIE;
                
                _Protection = settings.Protection;
                _Timeout = settings.Timeout;
                _FormsCookiePath = settings.FormsCookiePath;
                _Initialized = true;
            }
        }

        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        // Decrypt and get the auth ticket
        /// <include file='doc\FormsAuthentication.uex' path='docs/doc[@for="FormsAuthentication.Decrypt"]/*' />
        /// <devdoc>
        ///    <para>Given an encrypted authenitcation ticket as
        ///       obtained from an HTTP cookie, this method returns an instance of a
        ///       FormsAuthenticationTicket class.</para>
        /// </devdoc>
        public static FormsAuthenticationTicket Decrypt(String encryptedTicket) {
            if (encryptedTicket == null || encryptedTicket.Length == 0)
                throw new ArgumentException(HttpRuntime.FormatResourceString(SR.InvalidArgumentValue, "encryptedTicket"));

            Initialize();
            Trace("Decrypting cookie: " + encryptedTicket);

            byte [] bBlob = MachineKey.HexStringToByteArray(encryptedTicket);
            if (bBlob == null || bBlob.Length < 1)
                throw new ArgumentException(HttpRuntime.FormatResourceString(SR.InvalidArgumentValue, "encryptedTicket"));

            if (_Protection == FormsProtectionEnum.All || _Protection == FormsProtectionEnum.Encryption) {
                bBlob = MachineKey.EncryptOrDecryptData(false, bBlob, null, 0, bBlob.Length);
                if (bBlob == null)
                    return null;
            }

            if (_Protection == FormsProtectionEnum.All || _Protection == FormsProtectionEnum.Validation) {

                //////////////////////////////////////////////////////////////////////
                // Step 2: Get the MAC: Last MAC_LENGTH bytes
                if (bBlob.Length <= MAC_LENGTH)
                    return null;

                byte [] bTicket = new byte[bBlob.Length - MAC_LENGTH];

                Buffer.BlockCopy(bBlob, 0, bTicket, 0, bTicket.Length);
                byte [] bMac    = MachineKey.HashData(bTicket, null, 0, bTicket.Length);

                //////////////////////////////////////////////////////////////////////
                // Step 3: Make sure the MAC is correct
                if (bMac == null) {
                    Trace("Decrypting cookie failed to get the MAC.");
                    return null;
                }

                if (bMac.Length != MAC_LENGTH) {
                    Trace("Decrypting cookie failed due to bad MAC length: " + bMac.Length);
                    return null;
                }
                for (int iter=0; iter<MAC_LENGTH; iter++)
                    if (bMac[iter] != bBlob[bTicket.Length + iter]) {
                        Trace("Incorrect byte at " + iter + ", byte1: " + ((int)bMac[iter]) + ", byte2: "+((int)bBlob[bTicket.Length+iter])  );
                        return null;                   
                    }

                bBlob = bTicket;
            }

            //////////////////////////////////////////////////////////////////////
            // Step 4: Change binary ticket to managed struct
            int               iSize = ((bBlob.Length > 4096) ? 4096 : bBlob.Length);
            StringBuilder     name = new StringBuilder(iSize);
            StringBuilder     data = new StringBuilder(iSize);
            StringBuilder     path = new StringBuilder(iSize);
            byte []           pBin = new byte[2];
            long []           pDates = new long[2];
            
            int iRet = UnsafeNativeMethods.CookieAuthParseTicket(bBlob, bBlob.Length, 
                                                                 name, iSize, 
                                                                 data, iSize, 
                                                                 path, iSize,
                                                                 pBin, pDates);
            
            if (iRet != 0)
                return null;
            
            return new FormsAuthenticationTicket((int) pBin[0], 
                                                 name.ToString(), 
                                                 DateTime.FromFileTime(pDates[0]), 
                                                 DateTime.FromFileTime(pDates[1]), 
                                                 (bool) (pBin[1] != 0), 
                                                 data.ToString(),
                                                 path.ToString());
        }


        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        // Encrypt a ticket
        /// <include file='doc\FormsAuthentication.uex' path='docs/doc[@for="FormsAuthentication.Encrypt"]/*' />
        /// <devdoc>
        ///    Given a FormsAuthenticationTicket, this
        ///    method produces a string containing an encrypted authentication ticket suitable
        ///    for use in an HTTP cookie.
        /// </devdoc>
        public static String  Encrypt(FormsAuthenticationTicket ticket) {
            if (ticket == null)
                throw new ArgumentNullException("ticket");

            Initialize();
            //////////////////////////////////////////////////////////////////////
            // Step 1: Make it into a binary blob
            byte [] bBlob   = MakeTicketIntoBinaryBlob(ticket);
            if (bBlob == null)
                return null;
            
            if (_Protection == FormsProtectionEnum.None)
                return MachineKey.ByteArrayToHexString(bBlob, 0);

            //////////////////////////////////////////////////////////////////////
            // Step 2: Get the MAC and add to the blob
            if (_Protection == FormsProtectionEnum.All || _Protection == FormsProtectionEnum.Validation) {
                byte [] bMac    = MachineKey.HashData(bBlob, null, 0, bBlob.Length);
                if (bMac == null)
                    return null;            

                Trace("Encrypt: MAC length is: " + bMac.Length);

                byte [] bAll  = new byte[bMac.Length + bBlob.Length];
                Buffer.BlockCopy(bBlob, 0, bAll, 0, bBlob.Length);
                Buffer.BlockCopy(bMac, 0, bAll, bBlob.Length, bMac.Length);                            
                
                if (_Protection == FormsProtectionEnum.Validation)
                    return MachineKey.ByteArrayToHexString(bAll, 0);

                bBlob = bAll;
            }


            //////////////////////////////////////////////////////////////////////
            // Step 3: Do the actual encryption
            bBlob = MachineKey.EncryptOrDecryptData(true, bBlob, null, 0, bBlob.Length);
            return MachineKey.ByteArrayToHexString(bBlob, bBlob.Length);
        }

        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        // Verify User name and Password
        /// <include file='doc\FormsAuthentication.uex' path='docs/doc[@for="FormsAuthentication.Authenticate"]/*' />
        /// <devdoc>
        ///    Given the supplied credentials, this method
        ///    attempts to validate the credentials against those contained in the configured
        ///    credential store.
        /// </devdoc>
        public static bool Authenticate(String name, String password) {
            //////////////////////////////////////////////////////////////////////
            // Step 1: Make sure we are initialized
            if (name == null || password == null)
                return false;

            Initialize();
            //////////////////////////////////////////////////////////////////////
            // Step 2: Get the user database
            HttpContext context = HttpContext.Current;
            AuthenticationConfig settings = (AuthenticationConfig) context.GetConfig("system.web/authentication");            
            Hashtable hTable = settings.Credentials;

            if (hTable == null) {
                Trace("No user database");
                return false;
            }

            //////////////////////////////////////////////////////////////////////
            // Step 3: Get the (hashed) password for this user
            String pass = (String) hTable[name.ToLower(CultureInfo.InvariantCulture)];
            if (pass == null) {
                Trace("User not found");
                return false;
            }

            //////////////////////////////////////////////////////////////////////
            // Step 4: Hash the given password
            String   encPassword;
            switch (settings.PasswordFormat) {
                case FormsAuthPasswordFormat.SHA1:
                    encPassword = HashPasswordForStoringInConfigFile(password, "sha1");
                    break;

                case FormsAuthPasswordFormat.MD5:
                    encPassword = HashPasswordForStoringInConfigFile(password, "md5");
                    break;

                case FormsAuthPasswordFormat.Clear:
                    encPassword = password;
                    break;

                default:
                    return false;
            }

            //////////////////////////////////////////////////////////////////////
            // Step 5: Compare the hashes
            return(String.Compare(encPassword, 
                                  pass, 
                                  settings.PasswordFormat != FormsAuthPasswordFormat.Clear, 
                                  CultureInfo.InvariantCulture) 
                   == 0);
        }

        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////

        /// <include file='doc\FormsAuthentication.uex' path='docs/doc[@for="FormsAuthentication.SignOut"]/*' />
        /// <devdoc>
        ///    Given an authenticated user, calling SignOut
        ///    removes the authentication ticket by doing a SetForms with an empty value. This
        ///    removes either durable or session cookies.
        /// </devdoc>
        public static void SignOut() {
            Initialize();
            HttpContext    context   = HttpContext.Current;
            HttpCookie cookie = new HttpCookie(FormsCookieName, "");
            cookie.Path = _FormsCookiePath;
            cookie.Expires = new System.DateTime(1999, 10, 12);
            cookie.Secure = _RequireSSL;
            context.Response.Cookies.RemoveCookie(FormsCookieName);
            context.Response.Cookies.Add(cookie);
        }
        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////

        /// <include file='doc\FormsAuthentication.uex' path='docs/doc[@for="FormsAuthentication.SetAuthCookie"]/*' />
        /// <devdoc>
        ///    This method creates an authentication ticket
        ///    for the given userName and attaches it to the cookies collection of the outgoing
        ///    response. It does not perform a redirect.
        /// </devdoc>
        public static void SetAuthCookie(String userName, bool createPersistentCookie) {
            Initialize();
            SetAuthCookie(userName, createPersistentCookie, FormsAuthentication.FormsCookiePath);
        }

        /// <include file='doc\FormsAuthentication.uex' path='docs/doc[@for="FormsAuthentication.SetAuthCookie1"]/*' />
        /// <devdoc>
        ///    This method creates an authentication ticket
        ///    for the given userName and attaches it to the cookies collection of the outgoing
        ///    response. It does not perform a redirect.
        /// </devdoc>
        public static void SetAuthCookie(String userName, bool createPersistentCookie, String strCookiePath) {
            Initialize();
            HttpContext.Current.Response.Cookies.Add(GetAuthCookie(userName, createPersistentCookie, strCookiePath));
        }

        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////

        /// <include file='doc\FormsAuthentication.uex' path='docs/doc[@for="FormsAuthentication.GetAuthCookie"]/*' />
        /// <devdoc>
        ///    Creates an authentication cookie for a given
        ///    user name. This does not set the cookie as part of the outgoing response, so
        ///    that an application can have more control over how the cookie is issued.
        /// </devdoc>
        public static HttpCookie GetAuthCookie(String userName, bool createPersistentCookie) {
            Initialize();
            return GetAuthCookie(userName, createPersistentCookie, FormsAuthentication.FormsCookiePath);
        }

        /// <include file='doc\FormsAuthentication.uex' path='docs/doc[@for="FormsAuthentication.GetAuthCookie1"]/*' />
        public static HttpCookie GetAuthCookie(String userName, bool createPersistentCookie, String strCookiePath) {
            Initialize();
            if (userName == null)
                userName = "";

            if (strCookiePath == null || strCookiePath.Length < 1)
                strCookiePath = FormsCookiePath;
            FormsAuthenticationTicket ticket = new FormsAuthenticationTicket(
                    1, // version
                    userName, // User-Name
                    DateTime.Now, // Issue-Date
                    createPersistentCookie ? DateTime.Now.AddYears(50) : DateTime.Now.AddMinutes(_Timeout), // Expiration
                    createPersistentCookie, // IsPersistent
                    "", // User-Data
                    strCookiePath); // Cookie Path
            
            String strTicket = Encrypt(ticket);
            Trace("ticket is " + strTicket);
            if (strTicket == null || strTicket.Length < 1)
                        throw new HttpException(
                                HttpRuntime.FormatResourceString(
                                        SR.Unable_to_encrypt_cookie_ticket));
                

            HttpCookie cookie = new HttpCookie(FormsCookieName, strTicket);

            cookie.Path = strCookiePath;
            cookie.Secure = _RequireSSL;            
            if (ticket.IsPersistent)
                cookie.Expires = ticket.Expiration;
            return cookie;
        }

        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////

        /// <include file='doc\FormsAuthentication.uex' path='docs/doc[@for="FormsAuthentication.GetRedirectUrl"]/*' />
        /// <devdoc>
        ///    Returns the redirect URL for the original
        ///    request that caused the redirect to the login page.
        /// </devdoc>
        public static String GetRedirectUrl(String userName, bool createPersistentCookie) {
            Initialize();
            if (userName == null)
                return null;

            HttpContext                context   = HttpContext.Current;
            String                     strRU     = context.Request["ReturnUrl"];

            //////////////////////////////////////////////////////////////////////
            // Step 1: If ReturnUrl does not exist, then redirect to the
            //         current apps default.aspx
            if (strRU == null) {
                // redirect to path, not URL (ASURT 113391)
                strRU = UrlPath.Combine(context.Request.ApplicationPath, "default.aspx");
            }

            return strRU;
        }

        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        // Redirect from logon page to orignal page
        /// <include file='doc\FormsAuthentication.uex' path='docs/doc[@for="FormsAuthentication.RedirectFromLoginPage"]/*' />
        /// <devdoc>
        ///    This method redirects an authenticated user
        ///    back to the original URL that they requested.
        /// </devdoc>
        public static void RedirectFromLoginPage(String userName, bool createPersistentCookie) {
            Initialize();
            RedirectFromLoginPage(userName, createPersistentCookie, FormsAuthentication.FormsCookiePath);
        }

        /// <include file='doc\FormsAuthentication.uex' path='docs/doc[@for="FormsAuthentication.RedirectFromLoginPage1"]/*' />
        public static void RedirectFromLoginPage(String userName, bool createPersistentCookie, String strCookiePath) {
            Initialize();
            if (userName == null)
                return;

            SetAuthCookie(userName, createPersistentCookie, strCookiePath);
            HttpContext.Current.Response.Redirect(GetRedirectUrl(userName, createPersistentCookie), false);
        }

        /// <include file='doc\FormsAuthentication.uex' path='docs/doc[@for="FormsAuthentication.RenewTicketIfOld"]/*' />
        public static FormsAuthenticationTicket RenewTicketIfOld(FormsAuthenticationTicket tOld) {
            if (tOld == null)
                return null;

            DateTime dtN = DateTime.Now;
            TimeSpan t1  = dtN - tOld.IssueDate;
            TimeSpan t2  = tOld.Expiration - dtN;

            if (t2 > t1)
                return tOld;
           
            return new FormsAuthenticationTicket (
                    tOld.Version,
                    tOld.Name,
                    dtN, // Issue Date: Now
                    dtN + (tOld.Expiration - tOld.IssueDate), // Expiration
                    tOld.IsPersistent,
                    tOld.UserData,
                    tOld.CookiePath                    
                    );
        }

        /// <include file='doc\FormsAuthentication.uex' path='docs/doc[@for="FormsAuthentication.FormsCookieName"]/*' />
        public static String FormsCookieName { get { Initialize(); return _FormsName; }}
        /// <include file='doc\FormsAuthentication.uex' path='docs/doc[@for="FormsAuthentication.FormsCookiePath"]/*' />
        public static String FormsCookiePath { get { Initialize(); return _FormsCookiePath; }}       
        /// <include file='doc\FormsAuthentication.uex' path='docs/doc[@for="FormsAuthentication.RequireSSL"]/*' />
        public static bool   RequireSSL { get { Initialize(); return _RequireSSL; }}
        /// <include file='doc\FormsAuthentication.uex' path='docs/doc[@for="FormsAuthentication.SlidingExpiration"]/*' />
        public static bool   SlidingExpiration { get { Initialize(); return _SlidingExpiration; }}

        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        // Private stuff

        /////////////////////////////////////////////////////////////////////////////
        // Config Tags
        private  const String   CONFIG_DEFAULT_COOKIE    = ".ASPXAUTH";

        /////////////////////////////////////////////////////////////////////////////
        // Private data
        private static bool                _Initialized;
        private static String              _FormsName;
        private static FormsProtectionEnum _Protection;
        private static Int32               _Timeout;
        private static String              _FormsCookiePath;
        private static bool                _RequireSSL;
        private static bool                _SlidingExpiration;

        /////////////////////////////////////////////////////////////////////////////        
        private static void Trace(String str) {
            Debug.Trace("cookieauth", str);
        }

        /////////////////////////////////////////////////////////////////////////////        
        private static byte [] MakeTicketIntoBinaryBlob(FormsAuthenticationTicket ticket) {
            byte []   bData  = new byte[4096];
            byte []   pBin   = new byte[2];
            long []   pDates = new long[2];

            // Fill the first 8 bytes of the blob with random bits
            byte []   bRandom = new byte[8];
            RNGCryptoServiceProvider randgen = new RNGCryptoServiceProvider();
            randgen.GetBytes(bRandom);
            Buffer.BlockCopy(bRandom, 0, bData, 0, 8);

            pBin[0] = (byte) ticket.Version;
            pBin[1] = (byte) (ticket.IsPersistent ? 1 : 0);
            pDates[0] = ticket.IssueDate.ToFileTime();
            pDates[1] = ticket.Expiration.ToFileTime();

            int iRet = UnsafeNativeMethods.CookieAuthConstructTicket(
                    bData, bData.Length, 
                    ticket.Name, ticket.UserData, ticket.CookiePath,
                    pBin, pDates);

            if (iRet < 0)
                return null;

            byte[] ciphertext = new byte[iRet];
            Buffer.BlockCopy(bData, 0, ciphertext, 0, iRet);
            return ciphertext;
        }

        /////////////////////////////////////////////////////////////////////////////        
        private static byte [] GetMacFromBlob(byte [] bDataIn) {
            SHA1               sha       = SHA1.Create();
            return sha.ComputeHash(bDataIn);
        }

        /////////////////////////////////////////////////////////////////////////////        
        private static byte [] GetMD5FromBlob(byte [] bDataIn) {
            MD5                md5       = MD5.Create();
            return md5.ComputeHash(bDataIn);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\backstopauthenticationmodule.cs ===
//------------------------------------------------------------------------------
// <copyright file="BackStopAuthenticationModule.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Security {
    using  System.Runtime.Serialization;
    using  System.Web;
    using  System.Security.Principal;
    using System.Security.Permissions;

    /// <include file='doc\BackStopAuthenticationModule.uex' path='docs/doc[@for="DefaultAuthenticationModule"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class DefaultAuthenticationModule : IHttpModule {
        private DefaultAuthenticationEventHandler _eventHandler;

        /// <include file='doc\BackStopAuthenticationModule.uex' path='docs/doc[@for="DefaultAuthenticationModule.DefaultAuthenticationModule"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.Security.DefaultAuthenticationModule'/>
        ///       class.
        ///     </para>
        /// </devdoc>
        public DefaultAuthenticationModule() {
            InternalSecurityPermissions.UnmanagedCode.Demand();
        }

        /// <include file='doc\BackStopAuthenticationModule.uex' path='docs/doc[@for="DefaultAuthenticationModule.Authenticate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event DefaultAuthenticationEventHandler Authenticate {
            add {
                _eventHandler += value;
            }
            remove {
                _eventHandler -= value;
            }
        }

        /// <include file='doc\BackStopAuthenticationModule.uex' path='docs/doc[@for="DefaultAuthenticationModule.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Dispose() {
        }

        /// <include file='doc\BackStopAuthenticationModule.uex' path='docs/doc[@for="DefaultAuthenticationModule.Init"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Init(HttpApplication app) {
            app.DefaultAuthentication += new EventHandler(this.OnEnter);
        }

        ////////////////////////////////////////////////////////////
        // OnAuthenticate: Custom Authentication modules can override
        //             this method to create a custom IPrincipal object from
        //             a DefaultIdentity
        void OnAuthenticate(DefaultAuthenticationEventArgs e) {
            ////////////////////////////////////////////////////////////
            // If there are event handlers, invoke the handlers
            if (_eventHandler != null) {
                _eventHandler(this, e);
            }
        }

        ////////////////////////////////////////////////////////////
        // AddOnAuthenticate and RemoveOnAuthenticate: Use these
        //   methods to hook up event handlers to handle the
        //   OnAuthenticate Event
        void OnEnter(Object source, EventArgs eventArgs) {
            HttpApplication app;
            HttpContext context;

            app = (HttpApplication)source;
            context = app.Context;

            ////////////////////////////////////////////////////////////
            // Step 1: Check if authentication failed
            if (context.Response.StatusCode > 200) { // Invalid credentials
                if (context.Response.StatusCode == 401)
                    WriteErrorMessage(context);

                app.CompleteRequest();
                return;
            }

            ////////////////////////////////////////////////////////////
            // Step 2: If no auth module has created an IPrincipal, then fire
            //         OnAuthentication event
            if (context.User == null) {
                OnAuthenticate (new DefaultAuthenticationEventArgs(context) );
                if (context.Response.StatusCode > 200) { // Invalid credentials
                    if (context.Response.StatusCode == 401)
                        WriteErrorMessage(context);

                    app.CompleteRequest();
                    return;
                }
            }

            ////////////////////////////////////////////////////////////
            // Step 3: Attach an anonymous user to this request, if none
            //         of the authentication modules created a user
            if (context.User == null) {
                context.User = new GenericPrincipal(new GenericIdentity(String.Empty, String.Empty), new String[0]); 
            }

            app.SetPrincipalOnThread(context.User);
        }

        /////////////////////////////////////////////////////////////////////////////
        void WriteErrorMessage(HttpContext context) {
            context.Response.Write(AuthFailedErrorFormatter.GetErrorText());
        }
    }

    //////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////
    internal class AuthFailedErrorFormatter : ErrorFormatter {
        private static string _strErrorText;
        private static object _syncObject   = new object();

        internal AuthFailedErrorFormatter() {
        }

        internal /*public*/ static string GetErrorText() {
            if (_strErrorText != null)
                return _strErrorText;

            lock(_syncObject) {
                if (_strErrorText == null)
                    _strErrorText = (new AuthFailedErrorFormatter()).GetHtmlErrorMessage();
            }

            return _strErrorText;                
        }

        protected override string ErrorTitle {
            get { return HttpRuntime.FormatResourceString(SR.Assess_Denied_Title);}
        }

        protected override string Description {
            get {
                return HttpRuntime.FormatResourceString(SR.Assess_Denied_Description1);
                //"An error occurred while accessing the resources required to serve this request. &nbsp; This typically happens when you provide the wrong user-name and/or password.";
            }
        }

        protected override string MiscSectionTitle {            
            get { return HttpRuntime.FormatResourceString(SR.Assess_Denied_MiscTitle1);} 
            //"Error message 401.1";}
        }

        protected override string MiscSectionContent {
            get {
                return HttpRuntime.FormatResourceString(SR.Assess_Denied_MiscContent1);
                //return "Logon credentials provided were not recognized. Make sure you are providing the correct user-name and password. Otherwise, ask the web server's administrator for help.";
            }
        }

        protected override string ColoredSquareTitle {
            get { return null;}
        }

        protected override string ColoredSquareContent {
            get { return null;}
        }

        protected override bool ShowSourceFileInfo {
            get { return false;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\customauthenticationeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="CustomAuthenticationEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   CustomAuthenticationEventHandler.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
This file is not to be compiled -- ManuVa 9/11/2000

//------------------------------------------------------------------------------
// <copyright file="CustomAuthenticationEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * CustomAuthenticationEventHandler class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web.Security {
    using  System.Security.Principal;

    /// <include file='doc\CustomAuthenticationEventHandler.uex' path='docs/doc[@for="CustomAuthenticationEventHandler"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>Initializes a newly created instance of the CustomAuthenticationEventHandler
    ///       Class.</para>
    /// </devdoc>
    public delegate void CustomAuthenticationEventHandler(Object sender,  CustomAuthenticationEvent e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\customauthenticationevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="CustomAuthenticationEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   CustomAuthenticationEvent.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
This file is not to be compiled -- ManuVa 9/11/2000

//------------------------------------------------------------------------------
// <copyright file="CustomAuthenticationEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * CustomAuthenticationEvent class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web.Security {
    using  System.Security.Principal;
    /// <include file='doc\CustomAuthenticationEvent.uex' path='docs/doc[@for="CustomAuthenticationEvent"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The basic authentication module raises this event.
    ///    </para>
    /// </devdoc>
    public sealed class CustomAuthenticationEvent : EventArgs {
        private IPrincipal         _User;
        private String        _UserName;
        private String        _UserPassword;
        private HttpContext   _Context;

        /// <include file='doc\CustomAuthenticationEvent.uex' path='docs/doc[@for="CustomAuthenticationEvent.User"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        public IPrincipal         User { get { return _User;} set { _User = value;}}
        /// <include file='doc\CustomAuthenticationEvent.uex' path='docs/doc[@for="CustomAuthenticationEvent.UserName"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        public String        UserName { get { return _UserName;}}
        /// <include file='doc\CustomAuthenticationEvent.uex' path='docs/doc[@for="CustomAuthenticationEvent.UserPassword"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        public String        UserPassword { get { return _UserPassword;}}
        /// <include file='doc\CustomAuthenticationEvent.uex' path='docs/doc[@for="CustomAuthenticationEvent.Context"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public HttpContext   Context { get { return _Context;}}

        /// <include file='doc\CustomAuthenticationEvent.uex' path='docs/doc[@for="CustomAuthenticationEvent.CustomAuthenticationEvent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a newly created instance of the CustomAuthenticationEvent
        ///       Class.
        ///    </para>
        /// </devdoc>
        public CustomAuthenticationEvent(String  userName, String userPassword, HttpContext  context) {
            _Context         = context;
            _UserName        = userName;
            _UserPassword    = userPassword;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\formsauthenticationeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="FormsAuthenticationEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * CustomAuthenticationEventHandler class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web.Security {
    using  System.Security.Principal;

    /// <include file='doc\FormsAuthenticationEventHandler.uex' path='docs/doc[@for="FormsAuthenticationEventHandler"]/*' />
    /// <devdoc>
    ///    <para>This delegate defines the signature for the
    ///       FormsAuthentication_OnAuthenticate event handler.</para>
    /// </devdoc>
    public delegate void FormsAuthenticationEventHandler(Object sender,  FormsAuthenticationEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\security\formsauthenticationeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="FormsAuthenticationEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * FormsAuthenticationEventArgs class
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.Web.Security {
    using  System.Security.Principal;
    using System.Security.Permissions;

    /// <include file='doc\FormsAuthenticationEventArgs.uex' path='docs/doc[@for="FormsAuthenticationEventArgs"]/*' />
    /// <devdoc>
    ///    <SPAN>The 
    ///       event argument passed to the FormsAuthentication_OnAuthenticate event.<SPAN> </SPAN>Contains a FormsIdentity object and the
    ///    IPrincipal object used for the context.</SPAN>
    /// </devdoc>
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class FormsAuthenticationEventArgs : EventArgs {
        private IPrincipal        _User;
        private HttpContext       _Context;

        /// <include file='doc\FormsAuthenticationEventArgs.uex' path='docs/doc[@for="FormsAuthenticationEventArgs.User"]/*' />
        /// <devdoc>
        ///    <para><SPAN>The 
        ///       IPrincipal object to be associated with the request.<SPAN>
        ///    </SPAN></SPAN></para>
        /// </devdoc>
        public  IPrincipal        User { 
            get { return _User;} 
            set { 
                InternalSecurityPermissions.ControlPrincipal.Demand();
                _User = value;
            }
        }
        /// <include file='doc\FormsAuthenticationEventArgs.uex' path='docs/doc[@for="FormsAuthenticationEventArgs.Context"]/*' />
        /// <devdoc>
        ///    This is the HttpContext intrinsic - most
        ///    notably provides access to Request, Response, and User objects.
        /// </devdoc>
        public  HttpContext       Context { get { return _Context;}}

        /// <include file='doc\FormsAuthenticationEventArgs.uex' path='docs/doc[@for="FormsAuthenticationEventArgs.FormsAuthenticationEventArgs"]/*' />
        /// <devdoc>
        ///    Constructor
        /// </devdoc>
        public FormsAuthenticationEventArgs(HttpContext context) {
            _Context = context;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\system\web\hosting\isapiworkerrequest.cs ===
//------------------------------------------------------------------------------
// <copyright file="ISAPIWorkerRequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Hosting {
    using System.Text;
    using System.Configuration.Assemblies;
    using System.Runtime.InteropServices;                                                       
    using System.Collections;
    using System.Collections.Specialized;
    using System.IO;
    using System.Globalization;
    using System.Threading;
    using Microsoft.Win32;
    using System.Web;
    using System.Web.Util;
    using System.Web.Configuration;
    using System.Web.Caching;

//
// recyclable buffers for IntPtr[] and int[]
// to avoid pinning gen0
//

internal class RecyclableArrayHelper {
    private const int ARRAY_SIZE = 128;
    private const int MAX_FREE_ARRAYS = 64;
    private static IntegerArrayAllocator s_IntegerArrayAllocator;
    private static IntPtrArrayAllocator s_IntPtrArrayAllocator;

    static RecyclableArrayHelper() {
        s_IntegerArrayAllocator = new IntegerArrayAllocator(ARRAY_SIZE, MAX_FREE_ARRAYS);
        s_IntPtrArrayAllocator  = new IntPtrArrayAllocator(ARRAY_SIZE, MAX_FREE_ARRAYS);
    }

    internal static int[] GetIntegerArray(int minimumLength) {
        if( minimumLength <= ARRAY_SIZE )
            return(int[])s_IntegerArrayAllocator.GetBuffer();
        else
            return new int[minimumLength];
    }

    internal static IntPtr[] GetIntPtrArray(int minimumLength) {
        if( minimumLength <= ARRAY_SIZE )
            return(IntPtr[])s_IntPtrArrayAllocator.GetBuffer();
        else
            return new IntPtr[minimumLength];
    }

    internal static void ReuseIntegerArray(int[] array) {
        if (array != null && array.Length == ARRAY_SIZE)
            s_IntegerArrayAllocator.ReuseBuffer(array);
    }

    internal static void ReuseIntPtrArray(IntPtr[] array) {
        if (array != null && array.Length == ARRAY_SIZE)
            s_IntPtrArrayAllocator.ReuseBuffer(array);
    }
}

//
// char[] appendable buffer. Recyclable up to 1K
// Also encapsulates encoding (using utf-8) into recyclable byte[] buffer.
//
// Usage:
//      new RecyclableCharBuffer
//      Append
//      ...
//      GetEncodedBytesBuffer
//      Dispose
//

internal class RecyclableCharBuffer {
    private const int BUFFER_SIZE       = 1024;
    private const int MAX_FREE_BUFFERS  = 64;
    private static CharBufferAllocator  s_CharBufferAllocator;
    private static UbyteBufferAllocator s_ByteBufferAllocator;

    private char[]  _charBuffer;
    private int     _size;
    private int     _freePos;
    private bool    _recyclable;


    private byte[]  _byteBuffer;

    static RecyclableCharBuffer() {
        s_CharBufferAllocator = new CharBufferAllocator(BUFFER_SIZE, MAX_FREE_BUFFERS);
        s_ByteBufferAllocator = new UbyteBufferAllocator(Encoding.UTF8.GetMaxByteCount(BUFFER_SIZE), MAX_FREE_BUFFERS);
    }

    internal RecyclableCharBuffer() {
        _charBuffer = (char[])s_CharBufferAllocator.GetBuffer();
        _size = _charBuffer.Length;
        _freePos = 0;
        _recyclable = true;
    }

    internal void Dispose() {
        if (_recyclable) {
            if (_charBuffer != null)
                s_CharBufferAllocator.ReuseBuffer(_charBuffer);

            if (_byteBuffer != null)
                s_ByteBufferAllocator.ReuseBuffer(_byteBuffer);
        }

        _charBuffer = null;
        _byteBuffer = null;
    }

    private void Grow(int newSize) {
        if (newSize <= _size)
            return;

        if (newSize < _size*2)
            newSize = _size*2;

        char[] newBuffer = new char[newSize];

        if (_freePos > 0)
            Array.Copy(_charBuffer, newBuffer, _freePos);

        _charBuffer = newBuffer;
        _size = newSize;
        _recyclable = false;
    }

    internal void Append(char ch) {
        if (_freePos >= _size)
            Grow(_freePos+1);

        _charBuffer[_freePos++] = ch;
    }

    internal void Append(String s) {
        int l = s.Length;
        int newFreePos = _freePos + l;

        if (newFreePos > _size)
            Grow(newFreePos);

        s.CopyTo(0, _charBuffer, _freePos, l);
        _freePos = newFreePos;
    }

    internal byte[] GetEncodedBytesBuffer() {
        if (_byteBuffer != null)
            return _byteBuffer;

        // null terminate

        Append('\0');

        // convert to bytes

        if (_recyclable) {
            // still using the original recyclable char buffer 
            // -- can use recyclable byte buffer

            _byteBuffer = (byte[])s_ByteBufferAllocator.GetBuffer();

            if (_freePos > 0)
                Encoding.UTF8.GetBytes(_charBuffer, 0, _freePos, _byteBuffer, 0);
        }
        else {
            _byteBuffer = Encoding.UTF8.GetBytes(_charBuffer, 0, _freePos);
        }

        return _byteBuffer;
    }

    public override String ToString() {
        return (_charBuffer != null && _freePos > 0) ? new String(_charBuffer, 0, _freePos) : null;
    }
}

//
// byte[] buffer of encoded chars bytes. Recyclable up to 4K
// Also encapsulates decoding into recyclable char[] buffer.
//
// Usage:
//      new RecyclableByteBuffer
//      fill .Buffer up
//      GetDecodedTabSeparatedStrings
//      Dispose
//

internal class RecyclableByteBuffer {
    private const int BUFFER_SIZE       = 4096;
    private const int MAX_FREE_BUFFERS  = 64;
    private static UbyteBufferAllocator s_ByteBufferAllocator;
    private static CharBufferAllocator  s_CharBufferAllocator;

    private int     _offset;
    private byte[]  _byteBuffer;
    private bool    _recyclable;

    private char[]  _charBuffer;

    static RecyclableByteBuffer() {
        s_ByteBufferAllocator = new UbyteBufferAllocator(BUFFER_SIZE, MAX_FREE_BUFFERS);
        s_CharBufferAllocator = new CharBufferAllocator(BUFFER_SIZE, MAX_FREE_BUFFERS);
    }

    internal RecyclableByteBuffer() {
        _byteBuffer = (byte[])s_ByteBufferAllocator.GetBuffer();
        _recyclable = true;
    }

    internal void Dispose() {
        if (_recyclable) {
            if (_byteBuffer != null)
                s_ByteBufferAllocator.ReuseBuffer(_byteBuffer);

            if (_charBuffer != null)
                s_CharBufferAllocator.ReuseBuffer(_charBuffer);
        }

        _byteBuffer = null;
        _charBuffer = null;
    }

    internal byte[] Buffer {
        get { return _byteBuffer; }
    }

    internal void Resize(int newSize) {
        _byteBuffer = new byte[newSize];
        _recyclable = false;
    }

    private void Skip(int count) {
        if (count <= 0)
            return;

        // adjust offset
        int l = _byteBuffer.Length;
        int c = 0;

        for (int i = 0; i < l; i++) {
            if (_byteBuffer[i] == (byte)'\t') {
                if (++c == count) {
                    _offset = i+1;
                    return;
                }
            }
        }
    }

    private int CalcLength()
    {
        // calculate null termitated length

        if (_byteBuffer != null) {
            int l = _byteBuffer.Length;

            for (int i = _offset; i < l; i++) {
                if (_byteBuffer[i] == 0)
                    return i - _offset;
            }
        }

        return 0;
    }

    private char[] GetDecodedCharBuffer(Encoding encoding, ref int len) {
        if (_charBuffer != null)
            return _charBuffer;

        if (len == 0) {
            _charBuffer = new char[0];
        }
        else if (_recyclable) {
            _charBuffer = (char[])s_CharBufferAllocator.GetBuffer();
            len = encoding.GetChars(_byteBuffer, _offset, len, _charBuffer, 0);
        }
        else {
            _charBuffer = encoding.GetChars(_byteBuffer, _offset, len);
            len = _charBuffer.Length;
        }

        return _charBuffer;
    }

    internal string GetDecodedString(Encoding encoding) {
        int len = CalcLength();
        return encoding.GetString(_byteBuffer, 0, len);
    }

    internal string GetDecodedString(Encoding encoding, int len) {
        return encoding.GetString(_byteBuffer, 0, len);
    }

    internal String[] GetDecodedTabSeparatedStrings(Encoding encoding, int numStrings, int numSkipStrings) {
        if (numSkipStrings > 0)
            Skip(numSkipStrings);

        int len = CalcLength();
        char[] s = GetDecodedCharBuffer(encoding, ref len);

        String[] ss = new String[numStrings];

        int iStart = 0;
        int iEnd;
        int foundStrings = 0;

        for (int iString = 0; iString < numStrings; iString++) {
            iEnd = len;

            for (int i = iStart; i < len; i++) {
                if (s[i] == '\t') {
                    iEnd = i;
                    break;
                }
            }

            if (iEnd > iStart)
                ss[iString] = new String(s, iStart, iEnd-iStart);
            else
                ss[iString] = String.Empty;

            foundStrings++;

            if (iEnd == len)
                break;

            iStart = iEnd+1;
        }

        if (foundStrings < numStrings) {
            len = CalcLength();
            iStart = _offset;

            for (int iString = 0; iString < numStrings; iString++) {
                iEnd = len;

                for (int i = iStart; i < len; i++) {
                    if (_byteBuffer[i] == (byte)'\t') {
                        iEnd = i;
                        break;
                    }
                }

                if (iEnd > iStart)
                    ss[iString] = encoding.GetString(_byteBuffer, iStart, iEnd-iStart);
                else
                    ss[iString] = String.Empty;

                if (iEnd == len)
                    break;

                iStart = iEnd+1;
            }

        }

        return ss;
    }
}


//
// class to encapsulate writing from byte[] and IntPtr (resource)
//

internal class MemoryBytes {
    private int         _size;
    private byte[]      _arrayData;
    private GCHandle    _pinnedArrayData;
    private IntPtr      _intptrData;

    internal MemoryBytes(byte[] data, int size) {
        _size = size;
        _arrayData = data;
        _intptrData = IntPtr.Zero;
    }

    internal MemoryBytes(IntPtr data, int size) {
        _size = size;
        _arrayData = null;
        _intptrData = data;
    }

    internal int Size {
        get { return _size; }
    }

    internal IntPtr LockMemory() {
        if (_arrayData != null) {
            _pinnedArrayData = GCHandle.Alloc(_arrayData, GCHandleType.Pinned);
            return Marshal.UnsafeAddrOfPinnedArrayElement(_arrayData, 0);
        }
        else {
            return _intptrData;
        }
    }

    internal void UnlockMemory() {
        if (_arrayData != null) {
            _pinnedArrayData.Free();
        }
    }
}

//
// recyclable pinnable char[] buffer to get Unicode server variables
//
// Usage:
//      new ServerVarCharBuffer
//      get PinnedAddress, Length
//      [Resize]
//      Dispose
//

internal class ServerVarCharBuffer {
    private const int BUFFER_SIZE       = 1024;
    private const int MAX_FREE_BUFFERS  = 64;
    private static CharBufferAllocator  s_CharBufferAllocator;

    private bool        _recyclable;
    private char[]      _charBuffer;
    private bool        _pinned;
    private GCHandle    _pinnedCharBufferHandle;
    private IntPtr      _pinnedAddr;

    static ServerVarCharBuffer() {
        s_CharBufferAllocator = new CharBufferAllocator(BUFFER_SIZE, MAX_FREE_BUFFERS);
    }

    internal ServerVarCharBuffer() {
        _charBuffer = (char[])s_CharBufferAllocator.GetBuffer();
        _recyclable = true;
    }

    internal void Dispose() {
        if (_pinned) {
            _pinnedCharBufferHandle.Free();
            _pinned = false;
        }

        if (_recyclable) {
            if (_charBuffer != null)
                s_CharBufferAllocator.ReuseBuffer(_charBuffer);
        }

        _charBuffer = null;
    }

    internal IntPtr PinnedAddress {
        get { 
            if (!_pinned) {
                _pinnedCharBufferHandle = GCHandle.Alloc(_charBuffer, GCHandleType.Pinned);
                _pinnedAddr = Marshal.UnsafeAddrOfPinnedArrayElement(_charBuffer, 0);
                _pinned = true;
            }

            return _pinnedAddr;
        }
    }

    internal int Length {
        get {
            return _charBuffer.Length;
        }
    }

    internal void Resize(int newSize) {
        if (_pinned) {
            _pinnedCharBufferHandle.Free();
            _pinned = false;
        }

        _charBuffer = new char[newSize];
        _recyclable = false;
    }
}

//
// Async IO completion callback from IIS
//
internal delegate void ISAPIAsyncCompletionCallback(IntPtr ecb, int byteCount, int error);

//
// Implementation of HttpWorkerRequest based on ECB
//
internal abstract class ISAPIWorkerRequest : HttpWorkerRequest {
    
    protected IntPtr _ecb;     // ECB as integer
    protected IntPtr _token;   // user token as integer

    // Request data obtained during initialization (basics)

    protected String _method;
    protected String _path;
    protected String _filePath;
    protected String _pathInfo;
    protected String _pathTranslated;
    protected String _appPath;
    protected String _appPathTranslated;

    protected int _contentType;
    protected int _contentTotalLength;
    protected int _contentAvailLength;

    protected int _queryStringLength;

    // Request data obtained later on

    private bool _preloadedContentRead;
    private byte[] _preloadedContent;

    private bool _requestHeadersAvailable;
    private String[][] _unknownRequestHeaders;
    private String[] _knownRequestHeaders;

    private bool      _clientCertFetched;
    private DateTime  _clientCertValidFrom;
    private DateTime  _clientCertValidUntil;
    private byte []   _clientCert;
    private int       _clientCertEncoding;
    private byte []   _clientCertPublicKey;
    private byte []   _clientCertBinaryIssuer;    

    // Outgoing headers storage

    private bool _headersSent;
    private bool _contentLengthSent;
    private bool _chunked;
    private RecyclableCharBuffer _headers = new RecyclableCharBuffer();
    private RecyclableCharBuffer _status  = new RecyclableCharBuffer();
    private bool _statusSet = true;

    // Outgoing data cached for a single FlushCore

    private byte[]      _cachedResponseStatus;
    private byte[]      _cachedResponseHeaders;
    private int         _cachedResponseKeepConnected;
    private int         _cachedResponseBodyLength;
    private ArrayList   _cachedResponseBodyBytes;
    private int         _cachedResponseBodyBytesIoLockCount;

    // Notification about the end of IO

    private HttpWorkerRequest.EndOfSendNotification _endOfRequestCallback;
    private Object                                  _endOfRequestCallbackArg;
    private int                                     _endOfRequestCallbackLockCount;


    //  Constants for posted content type

    private const int CONTENT_NONE = 0;
    private const int CONTENT_FORM = 1;
    private const int CONTENT_MULTIPART = 2;
    private const int CONTENT_OTHER = 3;

    //
    // ISAPI status constants (for DoneWithSession)
    //

    private const int STATUS_SUCCESS = 1;
    private const int STATUS_SUCCESS_AND_KEEP_CONN = 2;
    private const int STATUS_PENDING = 3;
    private const int STATUS_ERROR = 4;

    //
    // Private helpers
    //

    private String[] ReadBasics(int[] contentInfo) {
        // call getbasics

        RecyclableByteBuffer buf = new RecyclableByteBuffer();

        int r = GetBasicsCore(buf.Buffer, buf.Buffer.Length, contentInfo);

        while (r < 0) {
            buf.Resize(-r);     // buffer not big enough
            r = GetBasicsCore(buf.Buffer, buf.Buffer.Length, contentInfo);
        }

        if (r == 0)
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_retrieve_request_data));

        // convert to characters and split the buffer into strings

        String[] ss = buf.GetDecodedTabSeparatedStrings(Encoding.Default, 6, 0);

        // recycle buffers

        buf.Dispose();

        return ss;
    }

    private static readonly char[] s_ColonOrNL = { ':', '\n' };

    private void ReadRequestHeaders() {
        if (_requestHeadersAvailable)
            return;

        _knownRequestHeaders = new String[RequestHeaderMaximum];

        // construct unknown headers as array list of name1,value1,...

        ArrayList headers = new ArrayList();

        String s = GetServerVariable("ALL_RAW");
        int l = (s != null) ? s.Length : 0;
        int i = 0;

        while (i < l)
        {
            //  find next :

            int ci = s.IndexOfAny(s_ColonOrNL, i);

            if (ci < 0)
                break;

            if (s[ci] == '\n') {
                // ignore header without :
                i = ci+1;
                continue;
            }

            if (ci == i) {
                i++;
                continue;
            }

            // add extract name
            String name = s.Substring(i, ci-i).Trim();

            //  find next \n
            int ni = s.IndexOf('\n', ci+1);
            if (ni < 0)
                ni = l;

            while (ni < l-1 && s[ni+1] == ' ')  {   // continuation of header (ASURT 115064)
                ni = s.IndexOf('\n', ni+1);
                if (ni < 0)
                    ni = l;
            }

            // extract value
            String value = s.Substring(ci+1, ni-ci-1).Trim();

            // remember
            int knownIndex = GetKnownRequestHeaderIndex(name);
            if (knownIndex >= 0) {
                _knownRequestHeaders[knownIndex] = value;
            }
            else {
                headers.Add(name);
                headers.Add(value);
            }

            i = ni+1;
        }

        // copy to array unknown headers

        int n = headers.Count / 2;
        _unknownRequestHeaders = new String[n][];
        int j = 0;

        for (i = 0; i < n; i++) {
            _unknownRequestHeaders[i] = new String[2];
            _unknownRequestHeaders[i][0] = (String)headers[j++];
            _unknownRequestHeaders[i][1] = (String)headers[j++];
        }

        _requestHeadersAvailable = true;
    }

    private void SendHeaders() {
        if (!_headersSent) {
            if (_statusSet) {
                _headers.Append("\r\n");

                AddHeadersToCachedResponse(
                    _status.GetEncodedBytesBuffer(), 
                    _headers.GetEncodedBytesBuffer(), 
                    (_contentLengthSent || _chunked) ? 1 : 0);

                _headersSent = true;
            }
        }
    }

    private void SendResponseFromFileStream(FileStream f, long offset, long length)  {
        long fileSize = f.Length;

        if (length == -1)
            length = fileSize - offset;

        if (offset < 0 || length > fileSize - offset)
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_range));

        if (length > 0) {
            if (offset > 0)
                f.Seek(offset, SeekOrigin.Begin);

            byte[] fileBytes = new byte[(int)length];
            int bytesRead = f.Read(fileBytes, 0, (int)length);
            AddBodyToCachedResponse(fileBytes, bytesRead);
        }
    }

    private void ResetCachedResponse() {
        _cachedResponseStatus = null;
        _cachedResponseHeaders = null;
        _cachedResponseBodyLength = 0;
        _cachedResponseBodyBytes = null;
    }

    private void AddHeadersToCachedResponse(byte[] status, byte[] header, int keepConnected) {
        _cachedResponseStatus = status;
        _cachedResponseHeaders = header;
        _cachedResponseKeepConnected = keepConnected;
    }

    private void AddBodyToCachedResponse(MemoryBytes bytes) {
        if (_cachedResponseBodyBytes == null)
            _cachedResponseBodyBytes = new ArrayList();
        _cachedResponseBodyBytes.Add(bytes);
        _cachedResponseBodyLength += bytes.Size;
    }

    private void AddBodyToCachedResponse(byte[] data, int size) {
        if (size > 0)
            AddBodyToCachedResponse(new MemoryBytes(data, size));
    }

    private void AddBodyToCachedResponse(IntPtr data, int size) {
        if (size > 0)
            AddBodyToCachedResponse(new MemoryBytes(data, size));
    }

    internal void UnlockCachedResponseBytesOnceAfterIoComplete() {
        if (Interlocked.Decrement(ref _cachedResponseBodyBytesIoLockCount) == 0) {
            // unlock pinned memory
            if (_cachedResponseBodyBytes != null) {
                int numFragments = _cachedResponseBodyBytes.Count;
                for (int i = 0; i < numFragments; i++) {
                    try {
                        ((MemoryBytes)_cachedResponseBodyBytes[i]).UnlockMemory();
                    }
                    catch {
                    }
                }
            }

            // don't remember cached data anymore
            ResetCachedResponse();
        }
    }

    private void FlushCachedResponse(bool isFinal) {
        if (_ecb == IntPtr.Zero)
            return;

        bool        asyncFlush = false;
        int         numFragments = 0;
        IntPtr[]    fragments = null;
        int[]       fragmentLengths = null;

        try {
            // prepare body fragments as IntPtr[] of pointers and int[] of lengths
            if (_cachedResponseBodyLength > 0) {
                numFragments = _cachedResponseBodyBytes.Count;
                fragments = RecyclableArrayHelper.GetIntPtrArray(numFragments);
                fragmentLengths = RecyclableArrayHelper.GetIntegerArray(numFragments);

                for (int i = 0; i < numFragments; i++) {
                    MemoryBytes bytes = (MemoryBytes)_cachedResponseBodyBytes[i];
                    fragments[i] = bytes.LockMemory();
                    fragmentLengths[i] = bytes.Size;
                }
            }

            // prepare doneWithSession and finalStatus
            int doneWithSession = isFinal ? 1 : 0;
            int finalStatus = isFinal ? ((_cachedResponseKeepConnected != 0) ? STATUS_SUCCESS_AND_KEEP_CONN : STATUS_SUCCESS) : 0;

            // set the count to two - one for return from FlushCore and one for async IO completion
            // the cleanup should happen on the later of the two
            _cachedResponseBodyBytesIoLockCount = 2;

            // increment the lock count controlling end of request callback
            // so that the callback would be called at the later of EndRequest
            // and the async IO completion
            // (doesn't need to be interlocked as only one thread could start the IO)
            _endOfRequestCallbackLockCount++;

            try {
                // send to unmanaged code
                FlushCore(
                    _cachedResponseStatus, _cachedResponseHeaders, _cachedResponseKeepConnected,
                    _cachedResponseBodyLength, numFragments, fragments, fragmentLengths,
                    doneWithSession, finalStatus, out asyncFlush);
            }
            finally {
                if (isFinal)
                    _ecb = IntPtr.Zero;
            }
        }
        finally {
            // in case of synchronous IO adjust down the lock counts
            if (!asyncFlush) {
                _cachedResponseBodyBytesIoLockCount--;
                _endOfRequestCallbackLockCount--;
            }

            // unlock pinned memory
            UnlockCachedResponseBytesOnceAfterIoComplete();

            // recycle buffers
            RecyclableArrayHelper.ReuseIntPtrArray(fragments);
            RecyclableArrayHelper.ReuseIntegerArray(fragmentLengths);
        }
    }

    internal void CallEndOfRequestCallbackOnceAfterAllIoComplete() {
        if (_endOfRequestCallback != null) {
            // only call the callback on the latest of EndRequest and async IO completion
            if (Interlocked.Decrement(ref _endOfRequestCallbackLockCount) == 0) {
                try {
                    _endOfRequestCallback(this, _endOfRequestCallbackArg);
                }
                catch {
                }
            }
        }
    }

    //
    // ctor
    //

    internal ISAPIWorkerRequest(IntPtr ecb) {
        _ecb = ecb;

        PerfCounters.IncrementCounter(AppPerfCounter.REQUESTS_TOTAL);
    }

    internal void Initialize() {
        // setup basic values

        ReadRequestBasics();

        if (_appPathTranslated != null && _appPathTranslated.Length > 2 && !_appPathTranslated.EndsWith("\\"))
            _appPathTranslated += "\\";  // IIS 6.0 doesn't add the trailing '\'

        // Increment incoming request length
        PerfCounters.IncrementCounterEx(AppPerfCounter.REQUEST_BYTES_IN, _contentTotalLength);
    }

    internal virtual void ReadRequestBasics() {

        // Get requests basics

        int[] contentInfo = new int[4];
        String[] basicStrings = ReadBasics(contentInfo);

        if (basicStrings == null || basicStrings.Length != 6)
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_retrieve_request_data));

        // Remember content info

        _contentType        = contentInfo[0];
        _contentTotalLength = contentInfo[1];
        _contentAvailLength = contentInfo[2];
        _queryStringLength  = contentInfo[3];

        // Remember basic strings

        _method             = basicStrings[0];
        _filePath           = basicStrings[1];
        _pathInfo           = basicStrings[2];
        _path = (_pathInfo.Length > 0) ? (_filePath + _pathInfo) : _filePath;
        _pathTranslated     = basicStrings[3];
        _appPath            = basicStrings[4];
        _appPathTranslated  = basicStrings[5];
    }

    //
    // Public methods
    //

    internal static ISAPIWorkerRequest CreateWorkerRequest(IntPtr ecb, int UseProcessModel) {
        ISAPIWorkerRequest wr = null;

        if (UseProcessModel != 0) {
            wr = new ISAPIWorkerRequestOutOfProc(ecb);
        }
        else {
            // Check for IIS6
            int version = UnsafeNativeMethods.EcbGetVersion(ecb);

            if ((version >> 16) >= 6)
                wr = new ISAPIWorkerRequestInProcForIIS6(ecb);
            else
                wr = new ISAPIWorkerRequestInProc(ecb);
        }

        wr.Initialize();
        return wr;
    }

    public override String GetUriPath() {
        return _path;
    }

    public override String GetQueryString() {
        if (_queryStringLength == 0)
            return "";

        int size = _queryStringLength + 2;
        StringBuilder buf = new StringBuilder(size);

        int r = GetQueryStringCore(0, buf, size);

        if (r != 1)
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_get_query_string));

        return buf.ToString();
    }

    public override byte[] GetQueryStringRawBytes() {
        byte[] buf = new byte[_queryStringLength];

        if (_queryStringLength > 0) {
            int r = GetQueryStringRawBytesCore(buf, _queryStringLength);

            if (r != 1)
                throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_get_query_string_bytes));
        }

        return buf;
    }


    public override String GetRawUrl() {
        String qs = GetQueryString();

        if (qs != null && qs.Length > 0)
            return _path + "?" + qs;
        else
            return _path;
    }

    public override String GetHttpVerbName() {
        return _method;
    }

    public override String GetHttpVersion() {
        return GetServerVariable("SERVER_PROTOCOL");
    }

    public override String GetRemoteAddress() {
        return GetServerVariable("REMOTE_ADDR");
    }

    public override String GetRemoteName() {
        return GetServerVariable("REMOTE_HOST");
    }

    public override int GetRemotePort() {
        return 0;   // unknown in ISAPI
    }

    public override String GetLocalAddress() {
        return GetServerVariable("LOCAL_ADDR");
    }

    public override int GetLocalPort() {
        return Int32.Parse(GetServerVariable("SERVER_PORT"));
    }

    public override String GetServerName() {
        return GetServerVariable("SERVER_NAME");
    }

    public override bool IsSecure() {
        String https = GetServerVariable("HTTPS");
        return (https != null && https.Equals("on"));
    }

    public override String GetFilePath() {
        return _filePath;
    }

    public override String GetFilePathTranslated() {
        return _pathTranslated; 
    }

    public override String GetPathInfo() {
        return _pathInfo;
    }

    public override String GetAppPath() {
        return _appPath; 
    }

    public override String GetAppPathTranslated() {
        return _appPathTranslated;
    }

    public override byte[] GetPreloadedEntityBody() {
        if (!_preloadedContentRead) {
            if (_contentAvailLength > 0) {
                _preloadedContent = new byte[_contentAvailLength];

                int r = GetPreloadedPostedContentCore(_preloadedContent, _contentAvailLength);

                if (r < 0)
                    throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_read_posted_data));
            }

            _preloadedContentRead = true;
        }

        return _preloadedContent;
    }

    public override bool IsEntireEntityBodyIsPreloaded() {
        return (_contentAvailLength == _contentTotalLength);
    }

    public override int ReadEntityBody(byte[] buffer, int size)  {
        int r = GetAdditionalPostedContentCore(buffer, size);
        
        if (r < 0)
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_read_posted_data));

        return r;
    }

    public override long GetBytesRead() {
        throw new HttpException(HttpRuntime.FormatResourceString(SR.Not_supported));
    }

    public override String GetKnownRequestHeader(int index)  {
        if (!_requestHeadersAvailable) {
            // special case important ones so that no all headers parsing is required

            switch (index) {
                case HeaderCookie:
                    return GetServerVariable("HTTP_COOKIE");

                case HeaderContentType:
                    if (_contentType == CONTENT_FORM)
                        return "application/x-www-form-urlencoded";
                    break;

                case HeaderContentLength:
                    if (_contentType != CONTENT_NONE)
                        return (_contentTotalLength).ToString();
                    break;

                case HeaderUserAgent:
                    return GetServerVariable("HTTP_USER_AGENT");
            }

            // parse all headers
            ReadRequestHeaders();
        }

        return _knownRequestHeaders[index];
    }
    
    public override String GetUnknownRequestHeader(String name) {
        if (!_requestHeadersAvailable)
            ReadRequestHeaders();

        int n = _unknownRequestHeaders.Length;

        for (int i = 0; i < n; i++) {
            if (String.Compare(name, _unknownRequestHeaders[i][0], true, CultureInfo.InvariantCulture) == 0)
                return _unknownRequestHeaders[i][1];
        }

        return null;
    }

    public override String[][] GetUnknownRequestHeaders() {
        if (!_requestHeadersAvailable)
            ReadRequestHeaders();

        return _unknownRequestHeaders;
    }

    public override void SendStatus(int statusCode, String statusDescription) {
        _status.Append(statusCode.ToString());
        _status.Append(" ");
        _status.Append(statusDescription);
        _statusSet = true;
    }

    public override void SendKnownResponseHeader(int index, String value) {
        if (_headersSent)
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_append_header_after_headers_sent));

        _headers.Append(GetKnownResponseHeaderName(index));
        _headers.Append(": ");
        _headers.Append(value);
        _headers.Append("\r\n");

        if (index == HeaderContentLength)
            _contentLengthSent = true;
        else if (index == HeaderTransferEncoding && (value != null && value.Equals("chunked")))
            _chunked = true;
    }

    public override void SendUnknownResponseHeader(String name, String value) {
        if (_headersSent)
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_append_header_after_headers_sent));

        _headers.Append(name);
        _headers.Append(": ");
        _headers.Append(value);
        _headers.Append("\r\n");
    }

    public override void SendCalculatedContentLength(int contentLength) {
        if (!_headersSent)
        {
            _headers.Append("Content-Length: ");
            _headers.Append(contentLength.ToString());
            _headers.Append("\r\n");
            _contentLengthSent = true;
        }
    }

    public override bool HeadersSent() {
        return _headersSent;
    }

    public override bool IsClientConnected() {
        return (IsClientConnectedCore() == 0) ? false : true;
    }

    public override void CloseConnection() {
        CloseConnectionCore();
    }
    
    public override void SendResponseFromMemory(byte[] data, int length) {
        if (!_headersSent)
            SendHeaders();

        if (length > 0)
            AddBodyToCachedResponse(data, length);
    }

    public override void SendResponseFromMemory(IntPtr data, int length) {
        if (!_headersSent)
            SendHeaders();

        if (length > 0)
            AddBodyToCachedResponse(data, length);
    }
    
    public override void SendResponseFromFile(String filename, long offset, long length) {
        if (!_headersSent)
            SendHeaders();

        if (length == 0)
            return;

        FileStream f = null;

        try {
            f = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read);
            SendResponseFromFileStream(f, offset, length);
        }
        finally {
            if (f != null)
                f.Close();
        }
    }

    public override void SendResponseFromFile(IntPtr handle, long offset, long length) {
        if (!_headersSent)
            SendHeaders();

        if (length == 0)
            return;

        FileStream f = null;

        try {
            f = new FileStream(handle, FileAccess.Read, false);
            SendResponseFromFileStream(f, offset, length);
        }
        finally {
            if (f != null)
                f.Close();
        }
    }

    public override void FlushResponse(bool finalFlush) {
        // only flush headers - the data is write through

        if (!_headersSent)
            SendHeaders();

        FlushCachedResponse(finalFlush);
    }

    public override void EndOfRequest() {
        FlushCachedResponse(true);

        // recycle the headers and status buffers
        _headers.Dispose();  
        _headers = null;
        _status.Dispose();  
        _status = null;

        CallEndOfRequestCallbackOnceAfterAllIoComplete();
    }

    public override void SetEndOfSendNotification(HttpWorkerRequest.EndOfSendNotification callback, Object extraData) {
        _endOfRequestCallback = callback;
        _endOfRequestCallbackArg = extraData;
        _endOfRequestCallbackLockCount = 1;   // when goes to 0 the callback is called
    }

    public override String MapPath(String path) {
        // Check if it's in the cache
        String cacheKey = "ISAPIWorkerRequest.MapPath:" + path;

        String result = (String)HttpRuntime.CacheInternal.Get(cacheKey);

        if (result != null) {
            // found in the cache
            Debug.Trace("MapPath", "cached(" + path +")=" + result);
            return result;
        }

        String reqpath = path;

        // special case: null, "" -> "/"

        if (path == null || path.Length == 0)
            reqpath = "/";

        reqpath = reqpath.Replace('\\', '/');

        reqpath = reqpath.Replace("//", "/");

        if (String.CompareOrdinal(reqpath, _filePath) == 0) {
            // for the current page path don't need to call IIS
            Debug.Trace("MapPath", reqpath  +" is the page path");
            result = _pathTranslated;
        }
        else if (String.CompareOrdinal(reqpath, _appPath) == 0) {
            // for application path don't need to call IIS
            Debug.Trace("MapPath", reqpath  +" is the app path");
            result = _appPathTranslated;
        }
        else {
            // check if starts with the same directory as the current page
            int i = _filePath.LastIndexOf('/');
            if (i >= 0 && reqpath.Length > i+1 && String.CompareOrdinal(_filePath, 0, reqpath, 0, i+1) == 0) {
                // and doesn't have / and has .
                if (reqpath.IndexOf('/', i+1) < 0 && reqpath.IndexOf('.', i+1) >= 0) {
                    // assume it is in the same physical directory as the current page and don't call IIS
                    Debug.Trace("MapPath", reqpath  +" is the same directory as the current page path " + _filePath);
                    result = _pathTranslated.Substring(0, _pathTranslated.LastIndexOf('\\')+1) + reqpath.Substring(i+1);
                }
            }
        }

        if (result == null) {
            // slow way -- call IIS
            Debug.Trace("MapPath", "SLOW PATH -- call IIS (" + reqpath + ")");
            result = MapPathSlowUsingIISCore(reqpath);

            // If there is a question mark in the result, IIS probably substituted some high
            // characters.  In that case, fixup the end of the string by replacing it with
            // the characters from the virtual path (with '/' switched to '\').  ASURT 81995.
            int questionMarkIndex = result.IndexOf('?');
            if (questionMarkIndex >= 0 && questionMarkIndex < result.LastIndexOf('\\')) {
                int numCharsToRestore = result.Length-questionMarkIndex;
                if (numCharsToRestore < reqpath.Length) {
                    string charsToRestore = reqpath.Substring(
                        reqpath.Length-numCharsToRestore).Replace('/', '\\');;
                    result = result.Substring(0, questionMarkIndex) + charsToRestore;
                }
            }
            else {

                // Even if there were no question marks, save and restore the filename
                // (last element of reqpath)

                int i = reqpath.LastIndexOf('/');
                if (i >= 0 && i < reqpath.Length-1 && reqpath.IndexOf('.', i+1) >= 0)
                    result = result.Substring(0, result.LastIndexOf('\\')+1) + reqpath.Substring(i+1);
            }
        }

        // special cases: remove "\" from end if the argument path doesn't end with '/'
        // the extra slash is not removed, however, for argument of "/"
        if (PathEndsWithExtraSlash(result) && !VPathEndsWithSlash(path))
            result = result.Substring(0, result.Length - 1);

        /////////////////////////////////////////////////////////////////////////////
        // Add to the cache: Valid for 10 minutes
        HttpRuntime.CacheInternal.UtcInsert(cacheKey, result, null, DateTime.UtcNow.AddMinutes(10), Cache.NoSlidingExpiration);

        Debug.Trace("MapPath", "    result=" + result);
        return result;
    }

    internal virtual String MapPathSlowUsingIISCore(String path) {
        int size = 256;
        byte[] buf = new byte[size];
        int r = MapUrlToPathCore(path, buf, size);

        while (r < 0) {
            // buffer not big enough
            size = -r;
            buf = new byte[size];
            r = MapUrlToPathCore(path, buf, size);
        }

        int length = 0;
        while (length < size && buf[length] != 0) {
            length++;
        }

        if (r != 1)
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Cannot_map_path, path));

        // Convert from DBCS to Unicode
        return Encoding.Default.GetString(buf, 0, length);
    }

    private static bool PathEndsWithExtraSlash(String path) {
        if (path == null)
            return false;
        int l = path.Length;
        if (l == 0 || path[l-1] != '\\')
            return false;
        if (l == 3 && path[1] == ':')   // c:\ case
            return false;
        return true;
    }

    private static bool VPathEndsWithSlash(String path) {
        if (path == null)
            return false;
        int l = path.Length;
        return (l > 0 && path[l-1] == '/');
    }

    public override String MachineConfigPath {
        get {
            return HttpConfigurationSystemBase.MachineConfigurationFilePath;
        }
    }

    public override String MachineInstallDirectory {
        get {
            return HttpRuntime.AspInstallDirectory;
        }
    }
        
    public override IntPtr GetUserToken() {
        return GetUserTokenCore();
    }

    public override IntPtr GetVirtualPathToken() {
        return GetVirtualPathTokenCore();
    }

    public override byte[] GetClientCertificate() {
        if (!_clientCertFetched)
            FetchClientCertificate();

        return _clientCert;
    }

    public override DateTime GetClientCertificateValidFrom() {
        if (!_clientCertFetched)
            FetchClientCertificate();

        return _clientCertValidFrom;
    }

    public override DateTime GetClientCertificateValidUntil() {
        if (!_clientCertFetched)
            FetchClientCertificate();

        return _clientCertValidUntil;
    }

    public override byte [] GetClientCertificateBinaryIssuer() {
        if (!_clientCertFetched)
            FetchClientCertificate();
        return _clientCertBinaryIssuer;
    }

    public override int GetClientCertificateEncoding() {
        if (!_clientCertFetched)
            FetchClientCertificate();
        return _clientCertEncoding;
    }

    public override byte [] GetClientCertificatePublicKey() {
        if (!_clientCertFetched)
            FetchClientCertificate();
        return _clientCertPublicKey;
    }

    private void FetchClientCertificate() {
        if (_clientCertFetched)
            return;

        _clientCertFetched = true;

        byte[]         buf        = new byte[8192];        
        int[]          pInts      = new int[4];            
        long[]         pDates     = new long[2];            
        int            iRet       = GetClientCertificateCore(buf, pInts, pDates);

        if (iRet < 0 && (-iRet) > 8192) {
            iRet = -iRet + 100;
            buf  = new byte[iRet];
            iRet = GetClientCertificateCore(buf, pInts, pDates);                
        }
        if (iRet > 0) {
            _clientCertEncoding = pInts[0];

            if (pInts[1] < buf.Length && pInts[1] > 0) {
                _clientCert = new byte[pInts[1]];
                Array.Copy(buf, _clientCert, pInts[1]);

                if (pInts[2] + pInts[1] < buf.Length && pInts[2] > 0) {
                    _clientCertBinaryIssuer = new byte[pInts[2]];
                    Array.Copy(buf, pInts[1], _clientCertBinaryIssuer, 0, pInts[2]);
                }

                if (pInts[2] + pInts[1] + pInts[3] < buf.Length && pInts[3] > 0) {
                    _clientCertPublicKey = new byte[pInts[3]];
                    Array.Copy(buf, pInts[1] + pInts[2], _clientCertPublicKey, 0, pInts[3]);
                }
            }
        }
            
        if (iRet > 0 && pDates[0] != 0)
            _clientCertValidFrom = DateTime.FromFileTime(pDates[0]);
        else
            _clientCertValidFrom = DateTime.Now;

        if (iRet > 0 && pDates[1] != 0)
            _clientCertValidUntil = DateTime.FromFileTime(pDates[1]);
        else
            _clientCertValidUntil = DateTime.Now;
    }

    //
    // internal methods specific to ISAPI
    //

    internal void AppendLogParameter(String logParam) {
        AppendLogParameterCore(logParam);
    }

    internal virtual void SendEmptyResponse() {
    }

    //
    // PInvoke callback wrappers -- overridden by the derived classes
    //

    internal abstract int GetBasicsCore(byte[] buffer, int size, int[] contentInfo);
    internal abstract int GetQueryStringCore(int encode, StringBuilder buffer, int size);
    internal abstract int GetQueryStringRawBytesCore(byte[] buffer, int size);
    internal abstract int GetPreloadedPostedContentCore(byte[] bytes, int bufferSize);
    internal abstract int GetAdditionalPostedContentCore(byte[] bytes, int bufferSize);
    internal abstract void FlushCore(byte[]     status, 
                                     byte[]     header, 
                                     int        keepConnected,
                                     int        totalBodySize,
                                     int        numBodyFragments,
                                     IntPtr[]   bodyFragments,
                                     int[]      bodyFragmentLengths,
                                     int        doneWithSession,
                                     int        finalStatus,
                                     out bool   async);
    internal abstract int IsClientConnectedCore();
    internal abstract int CloseConnectionCore();
    internal abstract int MapUrlToPathCore(String url, byte[] buffer, int size);
    internal abstract IntPtr GetUserTokenCore();
    internal abstract IntPtr GetVirtualPathTokenCore();
    internal abstract int AppendLogParameterCore(String logParam);
    internal abstract int GetClientCertificateCore(byte[] buffer, int [] pInts, long [] pDates);
    internal abstract int CallISAPI(UnsafeNativeMethods.CallISAPIFunc iFunction, byte [] bufIn, byte [] bufOut);
}

//
// In-process ISAPIWorkerRequest
//
// Does queueing of IO operations. ISAPI only support one async IO at a time.
//

internal class ISAPIWorkerRequestInProc : ISAPIWorkerRequest {

    private IDictionary _serverVars;

    internal ISAPIWorkerRequestInProc(IntPtr ecb) : base(ecb) {
    }

    internal override int GetBasicsCore(byte[] buffer, int size, int[] contentInfo) {
        if (_ecb == IntPtr.Zero)
            return 0;

        return UnsafeNativeMethods.EcbGetBasics(_ecb, buffer, size, contentInfo);
    }
    
    internal override int GetQueryStringCore(int encode, StringBuilder buffer, int size) {
        if (_ecb == IntPtr.Zero)
            return 0;

        return UnsafeNativeMethods.EcbGetQueryString(_ecb, encode, buffer, size);
    }

    internal override int GetQueryStringRawBytesCore(byte[] buffer, int size) {
        if (_ecb == IntPtr.Zero)
            return 0;

        return UnsafeNativeMethods.EcbGetQueryStringRawBytes(_ecb, buffer, size);
    }

    internal override int GetPreloadedPostedContentCore(byte[] bytes, int bufferSize) {
        if (_ecb == IntPtr.Zero)
            return 0;
        int rc = UnsafeNativeMethods.EcbGetPreloadedPostedContent(_ecb, bytes, bufferSize);
        if (rc > 0)
            PerfCounters.IncrementCounterEx(AppPerfCounter.REQUEST_BYTES_IN, rc);
        return rc;
    }

    internal override int GetAdditionalPostedContentCore(byte[] bytes, int bufferSize) {
        if (_ecb == IntPtr.Zero)
            return 0;
        int rc = UnsafeNativeMethods.EcbGetAdditionalPostedContent(_ecb, bytes, bufferSize);
        if (rc > 0)
            PerfCounters.IncrementCounterEx(AppPerfCounter.REQUEST_BYTES_IN, rc);
        return rc;
    }

    internal override int GetClientCertificateCore(byte[] buffer, int [] pInts, long [] pDates) {
        if (_ecb == IntPtr.Zero)
            return 0;

        return UnsafeNativeMethods.EcbGetClientCertificate(_ecb, buffer, buffer.Length, pInts, pDates);
    }

    public override String GetKnownRequestHeader(int index)  {
        String header = null;

        // in-proc (iis6) special case some headers into server vars to avoid header parsing
        switch (index) {
            case HeaderIfModifiedSince:
                header = GetServerVariable("HTTP_IF_MODIFIED_SINCE");
                break;

            case HeaderIfNoneMatch:
                header = GetServerVariable("HTTP_IF_NONE_MATCH");
                break;

            default:
                header = base.GetKnownRequestHeader(index);
                break;
        }

        return header;
    }


    internal override int IsClientConnectedCore()
    {
        if (_ecb == IntPtr.Zero)
            return 0;

        return UnsafeNativeMethods.EcbIsClientConnected(_ecb);
    }

    internal override void FlushCore(byte[]     status, 
                                     byte[]     header, 
                                     int        keepConnected,
                                     int        totalBodySize,
                                     int        numBodyFragments,
                                     IntPtr[]   bodyFragments,
                                     int[]      bodyFragmentLengths,
                                     int        doneWithSession,
                                     int        finalStatus,
                                     out bool   async) {
        async = false;

        if (_ecb == IntPtr.Zero)
            return;

        if (totalBodySize > 0)
            PerfCounters.IncrementCounterEx(AppPerfCounter.REQUEST_BYTES_OUT, totalBodySize);

        UnsafeNativeMethods.EcbFlushCore(
                        _ecb, 
                        status, 
                        header,
                        keepConnected,
                        totalBodySize,
                        numBodyFragments,
                        bodyFragments,
                        bodyFragmentLengths,
                        doneWithSession,
                        finalStatus,
                        0,
                        0,
                        null);
    }

    internal override int CloseConnectionCore() {
        if (_ecb == IntPtr.Zero)
            return 0;

        return UnsafeNativeMethods.EcbCloseConnection(_ecb);
    }

    internal override int MapUrlToPathCore(String url, byte[] buffer, int size) {
        if (_ecb == IntPtr.Zero)
            return 0;

        return UnsafeNativeMethods.EcbMapUrlToPath(_ecb, url, buffer, size);
    }

    internal override IntPtr GetUserTokenCore() {
        if (_token == IntPtr.Zero && _ecb != IntPtr.Zero)
            _token = UnsafeNativeMethods.EcbGetImpersonationToken(_ecb, IntPtr.Zero);
        return _token;
    }

    internal override IntPtr GetVirtualPathTokenCore() {
        if (_token == IntPtr.Zero && _ecb != IntPtr.Zero)
            _token = UnsafeNativeMethods.EcbGetVirtualPathToken(_ecb, IntPtr.Zero);

        return _token;
    }

    internal override int AppendLogParameterCore(String logParam) {
        if (_ecb == IntPtr.Zero)
            return 0;

        return UnsafeNativeMethods.EcbAppendLogParameter(_ecb, logParam);
    }

    internal virtual String GetServerVariableCore(String name) {
        String value = null;

        RecyclableByteBuffer buf = new RecyclableByteBuffer();

        int retVal = UnsafeNativeMethods.EcbGetServerVariable(_ecb, name, buf.Buffer, buf.Buffer.Length);

        while (retVal < 0) {
            buf.Resize(-retVal);     // buffer not big enough
            retVal = UnsafeNativeMethods.EcbGetServerVariable(_ecb, name, buf.Buffer, buf.Buffer.Length);
        }

        if (retVal > 0)
            value = buf.GetDecodedString(Encoding.UTF8, retVal);

        buf.Dispose();

        return value;
    }

    public override String GetServerVariable(String name) {
        // PATH_TRANSLATED is mangled -- do not use the original server variable
        if (name.Equals("PATH_TRANSLATED"))
            return GetFilePathTranslated();

        if (_serverVars == null) {
            _serverVars = new Hashtable(17, SymbolHashCodeProvider.Default, SymbolEqualComparer.Default);
            _serverVars.Add("APPL_MD_PATH", HttpRuntime.AppDomainAppIdInternal);
        }

        object obj = _serverVars[name];
        string varValue = null;

        // We never saw this serverVar
        if (obj == null) {
            varValue = GetServerVariableCore(name);

            if (varValue != null) {
                _serverVars.Add(name, varValue);
                obj = varValue;
            }
            else {
                // Add a self-link to denote we've seen it, but no value exists
                _serverVars.Add(name, _serverVars);
            }

        }
        // Else we saw this already but there was no value for it?
    