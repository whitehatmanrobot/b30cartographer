ublic member function is called in response to channels being
 *		purged from the lower domain during an information base merge operation.
 *		The purge is forwarded downward to all attachments.  Then the channel
 *		are deleted from the local information base.  For each user channel
 *		all resources in use by that user will be reclaimed.
 */
Void	Domain::PurgeChannelsIndication (
				PConnection         pOrigConn,
				CUidList           *purge_user_list,
				CChannelIDList     *purge_channel_list)
{
    CAttachment        *pAtt;
	UserID				uid;
	ChannelID			chid;

	/*
	 *	Make sure this indication came from the top provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	This loop re-transmits the purge channel indication to all
		 *	downward attachments.
		 */
		m_AttachmentList.Reset();
		while (NULL != (pAtt = m_AttachmentList.Iterate()))
		{
			pAtt->PurgeChannelsIndication(purge_user_list, purge_channel_list);
		}

		/*
		 *	Iterate through the list of channels to be purged, deleting each
		 *	channel.
		 */
		purge_channel_list->Reset();
		while (NULL != (chid = purge_channel_list->Iterate()))
		{
			/*
			 *	See if the specified channel is in the local information base.
			 *	If it is not, ignore it (this is a normal condition during a
			 *	purge operation).
			 */
			if (m_ChannelList2.Find(chid))
			{
				/*
				 *	Check to see if the channel ID corresponds to a user ID
				 *	channel.  If it does, report the error and do nothing.  If
				 *	it is not a user ID channel, then delete the channel.
				 */
				if (ValidateUserID(chid, NULL) == FALSE)
				{
					/*
					 *	Delete the channel.
					 */
					DeleteChannel(chid);
				}
				else
				{
					/*
					 *	The specified channel is in the Channel List, but it
					 *	does not refer to a user channel.  This indicates that
					 *	an error has occurred at the upward provider.  Ignore
					 *	the indication.
					 */
					ERROR_OUT(("Domain::PurgeChannelsIndication: UserChannel in purge_channel_list"));
				}
			}
		}

		/*
		 *	Iterate through the list of users to be purged, deleting
		 *	each one.
		 */
		purge_user_list->Reset();
		while (NULL != (uid = purge_user_list->Iterate()))
		{
			/*
			 *	See if the specified user is in the local information base.
			 *	If it is not, ignore it (this is a normal condition during a
			 *	purge operation).
			 */
			if (m_ChannelList2.Find(uid))
			{
				/*
				 *	Check to see if the user ID corresponds to a valid user in
				 *	the sub-tree of this provider.
				 */
				if (ValidateUserID(uid, NULL))
				{
					/*
					 *	Delete the user from the local information base.
					 */
					DeleteUser(uid);
				}
				else
				{
					/*
					 *	The specified ID is in the Channel List, but it does not
					 *	refer to a user channel.  This indicates that an error
					 *	has occurred at the upward provider.  Ignore the
					 *	indication.
					 */
					ERROR_OUT(("Domain::PurgeChannelsIndication: non-UserChannel in purge_user_list"));
				}
			}
		}
	}
	else
	{
		/*
		 *	This indication was received from someone besides the top provider.
		 */
		ERROR_OUT(("Domain::PurgeChannelsIndication: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	MergeTokensRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This public member function is called by a former top provider during
 *		a domain merge operation.  It travels upward to the top provider of
 *		the combined domain, where the merge can be processed.  Any providers
 *		that it travels through on the way must remember how to route the
 *		confirm back to the originator.
 */
Void	Domain::MergeTokensRequest (
				PConnection             pOrigConn,
				CTokenAttributesList   *merge_token_list,
				CTokenIDList           *purge_token_list)
{
	PTokenAttributes	merge_token;
	TokenState			token_state;
	TokenID				token_id;
	PToken				token;
	CUidList           *owner_list;
	UserID				uid;
	CTokenAttributesList merge_confirm_list;

	/*
	 *	Make sure that this request is coming from a legitimate downward
	 *	attachment before processing it.
	 */
	if (m_AttachmentList.FindConn(pOrigConn))
	{
		/*
		 *	Is this the top provider.  If so the request can be processed
		 *	locally.  If not, it must be forwarded toward the top provider.
		 */
		if (IsTopProvider())
		{
			/*
			 *	Iterate through the merge token list, attempting to add each
			 *	token in sequence.
			 */
			merge_token_list->Reset();
			while (NULL != (merge_token = merge_token_list->Iterate()))
			{
				/*
				 *	Get the address of the structure containing the next token
				 *	to merge.  Then get the token ID from the structure.
				 */
				token_state = merge_token->token_state;
				switch (token_state)
				{
					case TOKEN_GRABBED:
						token_id = merge_token->
								u.grabbed_token_attributes.token_id;
						break;

					case TOKEN_INHIBITED:
						token_id = merge_token->
								u.inhibited_token_attributes.token_id;
						break;

					case TOKEN_GIVING:
						token_id = merge_token->
								u.giving_token_attributes.token_id;
						break;

					case TOKEN_GIVEN:
						token_id = merge_token->
								u.given_token_attributes.token_id;
						break;
				}

				/*
				 *	Check to see if the requested token is in the local
				 *	information base.
				 */
				if (NULL != (token = m_TokenList2.Find(token_id)))
				{
					/*
					 *	If the token already exists within this domain, then
					 *	we need to compare the state of the local token and
					 *	the state of the token being merged.  If they are
					 *	both inhibited, then the merge operation can proceed
					 *	successfully.  However, if either one is something
					 *	besides inhibited, then the merge request will be
					 *	rejected.
					 */
					if ((token_state == TOKEN_INHIBITED) &&
							(token->GetTokenState () == TOKEN_INHIBITED))
					{
						/*
						 *	Add each inhibiting user from the former lower
						 *	domain to the token for this domain.
						 */
						TRACE_OUT(("Domain::MergeTokensRequest: merging inhibiting user IDs"));
						owner_list = merge_token->
								u.inhibited_token_attributes.inhibitors;
						owner_list->Reset();
						while (NULL != (uid = owner_list->Iterate()))
						{
							token->TokenInhibitRequest (NULL, uid, token_id);
						}

						/*
						 *	Add the token attributes structure to the merge
						 *	list, so that it will be included as part of the
						 *	merge tokens confirm.
						 */
						merge_confirm_list.Append(merge_token);
					}
					else
					{
						/*
						 *	The token is in use in the upper domain, and a merge
						 *	is not possible.  So add the token ID to the purge
						 *	list, so that it will be purged from the lower
						 *	domain.
						 */
						WARNING_OUT(("Domain::MergeTokensRequest: token in use - rejecting merge"));
						purge_token_list->Append(token_id);
					}
				}
				else
				{
					/*
					 *	The token does not exist in the local information base.
					 *	Attempt to add it.
					 */
					AddToken (merge_token, &merge_confirm_list,
							purge_token_list);
				}
			}

			/*
			 *	Issue the merge tokens confirm to the originator of the request.
			 */
			pOrigConn->MergeTokensConfirm(&merge_confirm_list, purge_token_list);
		}
		else
		{
			/*
			 *	This must be an intermediate provider in the upper domain.
			 *	Forward the request upward to be handled by the Top Provider
			 *	of the upper domain.  Also append the identity of the
			 *	requestor to the merge queue, so that the pending response
			 *	can be routed appropriately.
			 */
			TRACE_OUT(("Domain::MergeTokensRequest: forwarding request to Top Provider"));
			m_MergeQueue.Append(pOrigConn);
			m_pConnToTopProvider->MergeTokensRequest(merge_token_list, purge_token_list);
		}
	}
	else
	{
		/*
		 *	This request is coming from a provider that is unknown in this
		 *	domain.  Simply ignore the request.
		 */
		ERROR_OUT(("Domain::MergeTokensRequest: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	MergeTokensConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially invoked by the Top Provider of the upper
 *		domain during a domain merge operation.  It travels downward until it
 *		reaches the former Top Provider of the lower domain.  It contains
 *		notification of whether or not the merge of the token was successful.
 */
Void	Domain::MergeTokensConfirm (
				PConnection             pOrigConn,
				CTokenAttributesList   *merge_token_list,
				CTokenIDList           *purge_token_list)
{
    PConnection         pConn;
	PTokenAttributes	merge_token;
	TokenState			token_state;
	TokenID				token_id;
	PToken				token;
	CUidList           *owner_list;
	UserID				uid;
	CTokenAttributesList merge_confirm_list;

	/*
	 *	Check to make sure that it came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	Now check the merge state.  If the state is inactive, then that
		 *	means that this provider is an intermediate provider (i.e. a
		 *	provider that lies between the top provider and the former top
		 *	provider of the lower domain).  If the state is not inactive, then
		 *	this must be the former top provider of the lower domain.
		 */
		if (Merge_State == MERGE_INACTIVE)
		{
			/*
			 *	Since this came from the Top Provider, it should be a response
			 *	to an outstanding merge request that passed through this
			 *	provider.  If so, then the merge queue will not be empty.  Check
			 *	this before proceeding with the request.
			 */
			if (NULL != (pConn = m_MergeQueue.Get()))
			{
				/*
				 *	Get the identity of the provider to which this confirm must
				 *	forwarded.
				 */

				/*
				 *	If the provider is still attached to this provider, then
				 *	forward the merge confirm.
				 */
				if (m_AttachmentList.FindConn(pConn))
				{
					/*
					 *	Iterate through the merge token list, attempting to add
					 *	each token in sequence.
					 */
					merge_token_list->Reset();
					while (NULL != (merge_token = merge_token_list->Iterate()))
					{
						/*
						 *	Get the address of the structure containing the next
						 *	token to merge.  Then get the token ID from the
						 *	structure.
						 */
						token_state = merge_token->token_state;
						switch (token_state)
						{
							case TOKEN_GRABBED:
								token_id = merge_token->
										u.grabbed_token_attributes.token_id;
								break;

							case TOKEN_INHIBITED:
								token_id = merge_token->
										u.inhibited_token_attributes.token_id;
								break;

							case TOKEN_GIVING:
								token_id = merge_token->
										u.giving_token_attributes.token_id;
								break;

							case TOKEN_GIVEN:
								token_id = merge_token->
										u.given_token_attributes.token_id;
								break;
						}

						/*
						 *	Check to see if the requested token is in the local
						 *	information base.
						 */
						if (NULL != (token = m_TokenList2.Find(token_id)))
						{
							/*
							 *	The token already exists in the information base
							 *	of this intermediate provider.  The only valid
							 *	case where this could happen is if the token
							 *	being merged is inhibited in both upper and
							 *	lower domains.  Check this.
							 */
							if ((token_state == TOKEN_INHIBITED) &&
								(token->GetTokenState () == TOKEN_INHIBITED))
							{
								/*
								 *	Add each inhibiting user from the former
								 *	lower domain to the token for this domain.
								 */
								TRACE_OUT(("Domain::MergeTokensConfirm: merging inhibiting user IDs"));
								owner_list = merge_token->
										u.inhibited_token_attributes.inhibitors;
								owner_list->Reset();
								while (NULL != (uid = owner_list->Iterate()))
								{
									token->TokenInhibitRequest(NULL, uid, token_id);
								}

								/*
								 *	Add the token attributes structure to the
								 *	merge list, so that it will be included as
								 *	part of the merge tokens confirm.
								 */
								merge_confirm_list.Append(merge_token);
							}
							else
							{
								/*
								 *	The states of the tokens in the upper and
								 *	lower domain are invalid.  This should have
								 *	been resolved by the Top Provider before
								 *	issuing this merge request.  Report the
								 *	error and continue.
								 */
								ERROR_OUT(("Domain::MergeTokensConfirm: bad token in merge confirm"));
							}
						}
						else
						{
							/*
							 *	The token does not exist in the local
							 *	information base.  Attempt to add it.
							 */
							AddToken (merge_token, &merge_confirm_list,
									purge_token_list);
						}
					}

					/*
					 *	Forward merge confirm toward the former top provider
					 *	of the lower domain.
					 */
					pConn->MergeTokensConfirm(&merge_confirm_list, purge_token_list);
				}
				else
				{
					/*
					 *	The provider from which the outstanding request came
					 *	must have been lost since the request was initially
					 *	forwarded upward.  We need to issue some notification
					 *	of this upward, depending on the response within the
					 *	confirm.
					 */
					ERROR_OUT(("Domain::MergeTokensConfirm: forwarding attachment lost"));
				}
			}
			else
			{
				/*
				 *	There is no outstanding request with which this confirm is
				 *	associated.  Something is wrong above.  All this provider
				 *	can do is ignore the errant confirm.
				 */
				ERROR_OUT (("Domain::MergeTokensConfirm: no outstanding merge requests"));
			}
		}
		else
		{
			/*
			 *	If we have received a confirm from the top provider, hen there
			 *	should be at least one outstanding merge request.  Make sure
			 *	this is true before proceeding.
			 */
			if (Outstanding_Merge_Requests != 0)
			{
				/*
				 *	If there are any entries in the purge token list, it is
				 *	necessary to issue a purge tokens indication to all
				 *	downward attachments.
				 */
				if (purge_token_list->IsEmpty() == FALSE)
				{
					/*
					 *	Issue a PurgeTokensIndication downward to all
					 *	attachments.
					 */
                    CAttachment *pAtt;
					m_AttachmentList.Reset();
					while (NULL != (pAtt = m_AttachmentList.Iterate()))
					{
						pAtt->PurgeTokensIndication(this, purge_token_list);
					}

					/*
					 *	Iterate through the list of tokens to be purged,
					 *	removing each from the local information base.
					 */
					purge_token_list->Reset();
					while (NULL != (token_id = purge_token_list->Iterate()))
					{
						DeleteToken (token_id);
					}
				}
	
				/*
				 *	Decrement the number of outstanding merge requests.  If
				 *	there are now no more, then proceed to the next state
				 *	in the merger state machine.
				 */
				if (--Outstanding_Merge_Requests == 0)
					MergeInformationBase ();
			}
			else
			{
				/*
				 *	We have received a merge confirm when there are no
				 *	outstanding merge requests.  Ignore the confirm.
				 */
				ERROR_OUT(("Domain::MergeTokensConfirm: no outstanding merge requests"));
			}
		}
	}
	else
	{
		/*
		 *	This merge confirm has been received from someone besides the top
		 *	provider.  Ignore it.
		 */
		ERROR_OUT(("Domain::MergeTokensConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	PurgeTokensIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function is first invoked by the former Top Provider of
 *		the lower domain during a merge operation.  This indicates that a
 *		token merge into the upper domain was rejected.  After verifying that
 *		this MCS command is valid, is should simply be repeated downward to all
 *		attachments.
 */
Void	Domain::PurgeTokensIndication (
				PConnection         pOrigConn,
				CTokenIDList       *purge_token_list)
{
    CAttachment        *pAtt;
    TokenID				token_id;

	/*
	 *	Check to make sure that this MCS command came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	This is a valid command.  Iterate through the attachment list,
		 *	forwarding the command to everyone below this provider in the
		 *	domain hierarchy.
		 */
		TRACE_OUT(("Domain::PurgeTokensIndication: forwarding indication to all attachments"));
		m_AttachmentList.Reset();
		while (NULL != (pAtt = m_AttachmentList.Iterate()))
		{
			pAtt->PurgeTokensIndication(this, purge_token_list);
		}

		/*
		 *	Iterate through the list of tokens to be purged, deleting each one.
		 */
		purge_token_list->Reset();
		while (NULL != (token_id = purge_token_list->Iterate()))
		{
			/*
			 *	See if the specified token is in the local information base.
			 *	If it is not ignore it (this is a normal condition during a
			 *	purge operation).  If it is, then delete it.
			 */
			if (m_TokenList2.Find(token_id))
				DeleteToken (token_id);
		}
	}
	else
	{
		/*
		 *	This indication was received from someone besides the Top Provider.
		 *	Ignore it.
		 */
		ERROR_OUT(("Domain::PurgeTokensIndication: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	DisconnectProviderUltimatum ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is generated whenever an attachment becomes invalid.
 *		The local provider must respond by breaking all ties to the attachment.
 *		If the attachment is to the Top Provider, this will cause the domain
 *		to completely eradicate itself (return to the initialized state).
 *
 *		Note that when an attachment is lost, it is not removed from the
 *		merge queue.  This allows this provider to continue to route
 *		outstanding merge confirms appropriately, even when one of the
 *		attachments is lost.  Removing the attachments from the merge queue
 *		here will result in outstanding merge confirms being directed to the
 *		wrong attachments.
 */
Void	Domain::DisconnectProviderUltimatum (
				CAttachment        *pOrigAtt,
				Reason				reason)
{
	/*
	 *	If we lost the connection to the Top Provider, we have no choice but
	 *	to purge the entire domain.  Ways of preventing this drastic action
	 *	are being studied, but for now this implementation conforms to the
	 *	definition of T.125.
	 */
	if (pOrigAtt == m_pConnToTopProvider)
	{
        ASSERT(pOrigAtt->IsConnAttachment());
		TRACE_OUT(("Domain::DisconnectProviderUltimatum: purging entire domain"));
		m_pConnToTopProvider = NULL;
		PurgeDomain (reason);
	}

	/*
	 *	If we lose a downward attachment, then we must free up all resources
	 *	associated with that attachment.  This is handled by a private member
	 *	function.
	 */
	if (m_AttachmentList.Find(pOrigAtt))
	{
		TRACE_OUT(("Domain::DisconnectProviderUltimatum: deleting downward attachment=0x%p", pOrigAtt));
		DeleteAttachment(pOrigAtt, reason);
	}

	/*
	 *	If we lost an attachment that has an outstanding AttachUserRequest,
	 *	go ahead and remove it from the attach user queue.  Note that this
	 *	works differently from the merge queue.  With AttachUserConfirms, it
	 *	makes no difference what order they are processed in, so we can do
	 *	this.  With Merge???Confirms, they MUST be processed in order, so
	 *	we leave the lost attachment in the queue, and allow the confirm
	 *	command handler to deal with the fact that the attachment is no
	 *	longer valid.
	 */
	while (m_AttachUserQueue.Remove(pOrigAtt))
	{
		TRACE_OUT(("Domain::DisconnectProviderUltimatum: pending user attachment deleted=0x%p", pOrigAtt));
	}
}

/*
 *	Void	RejectUltimatum ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function is called when a provider detects a PDU that it
 *		cannot correctly process, the default behavior is to disconnect the
 *		connection that conveys the PDU.
 */
Void	Domain::RejectUltimatum (
				PConnection     pOrigConn,
				Diagnostic,
				PUChar,
				ULong)
{
	/*
	 *	Send a disconnect provider ultimatum to the attachment that has accused
	 *	us of wrongdoing.
	 */
	pOrigConn->DisconnectProviderUltimatum(REASON_PROVIDER_INITIATED);

	/*
	 *	Simulate the reception of a disconnect provider ultimatum from that
	 *	same attachment.  This will cause the connection to be cleanly broken
	 *	on both sides.
	 */
	DisconnectProviderUltimatum(pOrigConn, REASON_PROVIDER_INITIATED);
}

/*
 *	Void	AttachUserRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initiated by a user attachment, when a new user
 *		wishes to attach to this domain.  It is forwarded upward to the Top
 *		Provider of the domain, who ultimately has to process the request.
 */
Void	Domain::AttachUserRequest (
				CAttachment     *pOrigAtt)
{
	UserID				user_id;
	PChannel			channel;

	/*
	 *	Check to see if this is the Top Provider or not.  If it is, then the
	 *	request can be processed locally.  If not, then the request must be
	 *	forwarded upward to the Top Provider.
	 */
	if (IsTopProvider())
	{
		/*
		 *	This is the Top Provider, so process the request here.  Check to
		 *	see if the arbitrated domain parameters allow the addition of
		 *	a new user to the domain.
		 */
		if (Number_Of_Users < Domain_Parameters.max_user_ids)
		{
			/*
			 *	Also check to see if the arbitrated domain parameters allow the
			 *	addition of a new channel to the domain (since a user is also
			 *	channel).
			 */
			if (Number_Of_Channels < Domain_Parameters.max_channel_ids)
			{
				/*
				 *	Adding a new user is not a problem.  Get a unique ID to use
				 *	as the user ID, and then create a new UserChannel object.
				 */
				user_id = AllocateDynamicChannel ();
				DBG_SAVE_FILE_LINE
				channel = new UserChannel(user_id, pOrigAtt, this, m_pConnToTopProvider,
				                          &m_ChannelList2, &m_AttachmentList);
				if (channel != NULL)
				{
					/*
					 *	Add the new channel object to the channel list.  Note
					 *	that it is not necessary for this object to issue the
					 *	attach user confirm, because that was handled by the
					 *	constructor of the UserChannel object.
					 */
					TRACE_OUT(("Domain::AttachUserRequest: adding user ID = %04X", (UINT) user_id));
					m_ChannelList2.Insert(user_id, channel);
					Number_Of_Users++;
					Number_Of_Channels++;

					/*
					 *	If this represents an attachment that did not previously
					 *	exist, then this must be a local user attachment.  Add
					 *	it to the attachment list as such.
					 */
					if (! m_AttachmentList.Find(pOrigAtt))
                    {
                        ASSERT(pOrigAtt->IsUserAttachment());
						m_AttachmentList.Append(pOrigAtt);
                    }
				}
				else
				{
					/*
					 *	The allocation of the UserChannel object failed.  Issue
					 *	an unsuccessful attach user confirm.
					 */
					ERROR_OUT(("Domain::AttachUserRequest: user allocation failed"));
					pOrigAtt->AttachUserConfirm(RESULT_UNSPECIFIED_FAILURE, 0);
				}
			}
			else
			{
				/*
				 *	The negotiated domain parameters will not allow a new
				 *	channel to be added to the domain.  Reject the request.
				 */
				ERROR_OUT(("Domain::AttachUserRequest: too many channels"));
				pOrigAtt->AttachUserConfirm(RESULT_TOO_MANY_CHANNELS, 0);
			}
		}
		else
		{
			/*
			 *	The negotiated domain parameters will not allow a new user
			 *	to be added to the domain.  Reject the request.
			 */
			ERROR_OUT(("Domain::AttachUserRequest: too many users"));
			pOrigAtt->AttachUserConfirm(RESULT_TOO_MANY_USERS, 0);
		}
	}
	else
	{
		/*
		 *	This is not the Top Provider, so the request must be forwarded
		 *	upward toward the Top Provider.  Add the originator of the request
		 *	to the attach user queue, so that this provider can properly route
		 *	the returning confirm (when it arrives).
		 */
		TRACE_OUT(("Domain::AttachUserRequest: adding attachment to attach user queue"));
		m_AttachUserQueue.Append(pOrigAtt);

		m_pConnToTopProvider->AttachUserRequest();
	}
}

/*
 *	Void	AttachUserConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially generated by the Top Provider upon
 *		receipt of an AttachUserRequest.  It contains the result of that
 *		request.  If the result is successful, then it also contains the user
 *		ID for the new user.  This confirm needs to be routed all the was back
 *		to the user attachment that originated the request.
 */
Void	Domain::AttachUserConfirm (
				PConnection         pOrigConn,
				Result				result,
				UserID				uidInitiator)
{
    CAttachment        *pAtt;
	PChannel			channel;
	CUidList			detach_user_list;

	/*
	 *	Make sure that the request originated with the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	The reception of this confirm means that there should be an
		 *	outstanding request.  Make sure this is the case before proceeding.*
		 */
		if (NULL != (pAtt = m_AttachUserQueue.Get()))
		{
			/*
			 *	There is an outstanding request.  Get the identity of the
			 *	attachment from which the request originated.
			 */
	
			/*
			 *	If the result was successful, then it is necessary for this
			 *	provider to create a UserChannel object in the local information
			 *	base for the new user.
			 */
			if (result == RESULT_SUCCESSFUL)
			{
				/*
				 *	Make sure the channel ID is not already in use before
				 *	proceeding.
				 */
				if (! m_ChannelList2.Find(uidInitiator))
				{
					/*
					 *	Create a new UserChannel object, using the ID generated
					 *	by the Top Provider.
					 */
					DBG_SAVE_FILE_LINE
					channel = new UserChannel(uidInitiator, pAtt, this, m_pConnToTopProvider,
					                          &m_ChannelList2, &m_AttachmentList);
					if (channel != NULL)
					{
						/*
						 *	Add the UserChannel object to the channel list.
						 */
						TRACE_OUT(("Domain::AttachUserConfirm: adding user ID = %04X", (UINT) uidInitiator));
						if(m_ChannelList2.Insert(uidInitiator, channel))
						{
                                                Number_Of_Users++;
                                                Number_Of_Channels++;

                                                /*
                                                *	If the user's attachment is not already in the
                                                *	attachment list, then this must be a new local
                                                *	attachment.  Add it to the attachment list as such.
                                                */
                                                if (! m_AttachmentList.Find(pAtt))
                                                {
                                                    ASSERT(pAtt->IsUserAttachment());
                                                    m_AttachmentList.Append(pAtt);
                                                }
						}
						else
						{
						    delete channel;
						}
					}
					else
					{
						/*
						 *	The local provider was unable to allocate the
						 *	UserChannel object.  This means that the new user
						 *	must be removed from the domain.  To do this, send
						 *	a DetachUserRequest to the Top Provider and an
						 *	unsuccessful AttachUserConfirm to the originator
						 *	of the request.
						 */
						ERROR_OUT(("Domain::AttachUserConfirm: user allocation failed"));
						detach_user_list.Append(uidInitiator);
						m_pConnToTopProvider->DetachUserRequest(REASON_PROVIDER_INITIATED, &detach_user_list);
						pAtt->AttachUserConfirm(RESULT_UNSPECIFIED_FAILURE, 0);
					}
				}
				else
				{
					/*
					 *	The ID associated with this confirm is already in use.
					 *	This indicates that something is wrong above.  This
					 *	provider has no choice but to ignore the confirm.
					 */
					WARNING_OUT(("Domain::AttachUserConfirm: channel ID already in use"));
				}
			}
			else
			{
				/*
				 *	Since the result of the attach was not successful, this
				 *	provider does not have to add anything to its channel list.
				 *	The only required action is to forward the confirm to the
				 *	originating user.
				 */
				TRACE_OUT(("Domain::AttachUserConfirm: echoing failed confirm"));
				pAtt->AttachUserConfirm(result, uidInitiator);
			}
		}
		else
		{
			/*
			 *	The attach user queue is empty.  This probably indicates that
			 *	the connection to the user who originated the request was lost
			 *	before the confirm got back.  This provider doesn't need to
			 *	do anything except issue a DetachUserRequest (if the confirm
			 *	indicates that the attach operation was successful).
			 */
			WARNING_OUT(("Domain::AttachUserConfirm: attach user queue empty"));

			if (result == RESULT_SUCCESSFUL)
			{
				TRACE_OUT (("Domain::AttachUserConfirm: sending DetachUserRequest"));
				detach_user_list.Append(uidInitiator);
				m_pConnToTopProvider->DetachUserRequest(REASON_DOMAIN_DISCONNECTED, &detach_user_list);
			}
		}
	}
	else
	{
		/*
		 *	This confirm was received from someone besides the Top Provider.
		 *	Ignore it.
		 */
		ERROR_OUT(("Domain::AttachUserConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	DetachUserRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initiated by a user attachment that wishes to leave
 *		the domain.  After validation, delete the user from the information base
 *		pass the request upward.
 */
Void	Domain::DetachUserRequest (
				CAttachment        *pOrigAtt,
				Reason				reason,
				CUidList           *user_id_list)
{
	UserID				uid;
	CUidList			detach_user_list;

	/*
	 *	Iterate through the list of users named to be deleted.
	 */
	user_id_list->Reset();
	while (NULL != (uid = user_id_list->Iterate()))
	{
		/*
		 *	Make sure the user really exists in the sub-tree from which this
		 *	request originated.
		 */
		if (ValidateUserID(uid, pOrigAtt))
		{
			/*
			 *	Delete the user from the local information base.
			 */
			DeleteUser(uid);

			/*
			 *	Put the user ID into the list of validated user IDs.
			 */
			detach_user_list.Append(uid);
		}
		else
		{
			/*
			 *	There is no such user in the sub-tree from which this request
			 *	originated.
			 */
			WARNING_OUT(("Domain::DetachUserRequest: invalid user ID"));
		}
	}

	/*
	 *	Check to see if there are any users to be deleted.  If so, then process
	 *	the request.
	 */
	if (detach_user_list.IsEmpty() == FALSE)
	{
		/*
		 *	Check to see if this is the Top Provider.
		 */
		if (IsTopProvider())
		{
			/*
			 *	This is the Top Provider, so issue a detach user indication to
			 *	all downward attachments.
			 */
			TRACE_OUT(("Domain::DetachUserRequest: sending DetachUserIndication to all attachments"));
            CAttachment *pAtt;
			m_AttachmentList.Reset();
			while (NULL != (pAtt = m_AttachmentList.Iterate()))
			{
				pAtt->DetachUserIndication(reason, &detach_user_list);
			}
		}
		else
		{
			/*
			 *	This is not the Top Provider, so forward the detach user
			 *	request upward.
			 */
			TRACE_OUT(("Domain::DetachUserRequest: forwarding DetachUserRequest to Top Provider"));
			m_pConnToTopProvider->DetachUserRequest(reason, &detach_user_list);
		}
	}
	else
	{
		/*
		 *	The user ID list contained no valid entries, so ignore the request.
		 */
		ERROR_OUT(("Domain::DetachUserRequest: no valid user IDs"));
	}
}

/*
 *	Void	DetachUserIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider in response to
 *		a user detaching from the domain (willingly or otherwise).  It is
 *		forwarded downward in the hierarchy where it will eventually reach all
 *		providers and their user attachments.
 */
Void	Domain::DetachUserIndication (
				PConnection         pOrigConn,
				Reason				reason,
				CUidList           *user_id_list)
{
	UserID			uid;

	/*
	 *	Verify that the indication came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	The first thing to do is repeat the indication to all downward
		 *	attachments.  Keep in mind that this sends the detach indication
		 *	to user attachments as well as remote connections.
		 */
		TRACE_OUT(("Domain::DetachUserIndication: forwarding DetachUserIndication to all attachments"));
        CAttachment *pAtt;
		m_AttachmentList.Reset();
		while (NULL != (pAtt = m_AttachmentList.Iterate()))
		{
			pAtt->DetachUserIndication(reason, user_id_list);
		}

		/*
		 *	Iterate through the list of users, deleting those that are in
		 *	the sub-tree of this provider.
		 */
		user_id_list->Reset();
		while (NULL != (uid = user_id_list->Iterate()))
		{
			/*
			 *	Check to see if this user is somewhere in the sub-tree of this
			 *	provider.  If so it is necessary to delete the user channel from
			 *	the channel list.  Note that it is perfectly normal to receive a
			 *	detach user indication for a user that is not in the sub-tree of
			 *	the receiving provider.
			 */
			if (ValidateUserID(uid, NULL) )
			{
				/*
				 *	Delete the user from the local information base.
				 */
				DeleteUser(uid);
			}
		}
	}
	else
	{
		/*
		 *	This indication was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::DetachUserIndication: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	ChannelJoinRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user attachment that wishes
 *		to join a channel.  It flows upward in the hierarchy until it reaches
 *		a provider who is already joined to the channel.  That provider (which
 *		is not necessarily the Top Provider), will issue a channel join
 *		confirm, indicating whether or not the join was successful.
 */
Void	Domain::ChannelJoinRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	PChannel		channel;
	ChannelID		requested_id;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	See if the channel already exists in the local information base.
		 *	If so, then let the Channel object handle the join request.
		 */
		if (NULL != (channel = m_ChannelList2.Find(channel_id)))
		{
			TRACE_OUT(("Domain::ChannelJoinRequest: sending join request to channel object"));
			channel->ChannelJoinRequest(pOrigAtt, uidInitiator, channel_id);
		}
		else
		{
			/*
			 *	The channel does not already exist in the channel list.  Check
			 *	to see if this is the Top Provider.  If so, we can try to
			 *	add the channel to the list.  If this is not the Top Provider,
			 *	then we simply forward the request upward.
			 */
			if (IsTopProvider())
			{
				/*
				 *	Save the value of the channel the user originally attempted
				 *	to join.  This may change if this is a request to join
				 *	channel 0 (an assigned channel).
				 */
				requested_id = channel_id;

				/*
				 *	We already know the channel does not exist in the channel
				 *	list.  Therefore, this is a valid request only if the
				 *	channel being joined is a static channel or channel 0 (which
				 *	is interpreted as a request for an assigned channel).
				 *	Dynamic channels (those above 1000) can only be joined if
				 *	they already exist.
				 */
				if (requested_id <= 1000)
				{
					/*
					 *	See if the arbitrated domain parameters will allow the
					 *	addition of a new channel.
					 */
					if (Number_Of_Channels < Domain_Parameters.max_channel_ids)
					{
						/*
						 *	If this is a request for an assigned channel, then
						 *	allocate a random channel ID in the dynamic range.
						 *	Then create a new Channel object.
						 */
						if (requested_id == 0)
							channel_id = AllocateDynamicChannel ();
						DBG_SAVE_FILE_LINE
						channel = new Channel(channel_id, this, m_pConnToTopProvider,
						                      &m_ChannelList2, &m_AttachmentList);
						if (channel != NULL)
						{
							/*
							 *	The creation of the new channel was successful.
							 *	Add it to the channel list.
							 */
							TRACE_OUT(("Domain::ChannelJoinRequest: adding channel ID = %04X", (UINT) channel_id));
							m_ChannelList2.Insert(channel_id, channel);
							Number_Of_Channels++;

							/*
							 *	When new channels are created, they are
							 *	initially empty.  So we must join the
							 *	originating attachment to the newly created
							 *	attachment.  This will also cause a channel
							 *	join confirm to be issued to the originator.
							 */
							channel->ChannelJoinRequest(pOrigAtt, uidInitiator, requested_id);
						}
						else
						{
							/*
							 *	Allocation of the Channel object failed.  We
							 *	must therefore issue an unsuccessful channel
							 *	join confirm to the originating attachment.
							 */
							ERROR_OUT(("Domain::ChannelJoinRequest: channel allocation failed"));
							pOrigAtt->ChannelJoinConfirm(RESULT_UNSPECIFIED_FAILURE, uidInitiator, requested_id, 0);
						}
					}
					else
					{
						/*
						 *	Domain parmeters will not allow the addition of
						 *	any more channels.  Fail the request.
						 */
						ERROR_OUT(("Domain::ChannelJoinRequest: join denied - too many channels"));
						pOrigAtt->ChannelJoinConfirm(RESULT_TOO_MANY_CHANNELS, uidInitiator, requested_id, 0);
					}
				}
				else
				{
					/*
					 *	There has been an attempt to join a dynamic channel
					 *	that doesn't already exist.  This is not allowed, so
					 *	fail the request.
					 */
					WARNING_OUT(("Domain::ChannelJoinRequest: attempt to join non-existent dynamic channel"));
					pOrigAtt->ChannelJoinConfirm(RESULT_NO_SUCH_CHANNEL, uidInitiator, requested_id, 0);
				}
			}
			else
			{
				/*
				 *	The channel does not exist locally, and this is not the
				 *	Top Provider.  That means this is someone else problem.
				 *	Issue the request upward toward the Top Provider.
				 */
				TRACE_OUT(("Domain::ChannelJoinRequest: forwarding join request to Top Provider"));
				m_pConnToTopProvider->ChannelJoinRequest(uidInitiator, channel_id);
			}
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::ChannelJoinRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	ChannelJoinConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command originates from a provider who receives a channel
 *		join request, and has enough information to respond.  This is not
 *		necessarily the Top Provider.  An intermediate can respond if the
 *		channel exists in its information base.  This confirm is forwarded
 *		back to the original requestor, letting it know whether or not the
 *		join was successful.
 */
Void	Domain::ChannelJoinConfirm (
				PConnection         pOrigConn,
				Result				result,
				UserID				uidInitiator,
				ChannelID			requested_id,
				ChannelID			channel_id)
{
	PChannel		channel;
	CChannelIDList	channel_leave_list;

	/*
	 *	Verify that the confirm came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	Make sure that the requesting user is still somewhere in the
		 *	sub-tree of this provider.
		 */
		if (ValidateUserID (uidInitiator, NULL) )
		{
			/*
			 *	Found out which downward attachment leads to the requesting
			 *	user.
			 */
			if (NULL != (channel = m_ChannelList2.Find(uidInitiator)))
			{
    			CAttachment *pAtt = channel->GetAttachment();
                ASSERT(pAtt);
    			/*
    			 *	Was the result successful.  If is was, then the local provider
    			 *	needs to make sure the channel is in the local channel list.
    			 *	If its not already there, it will have to be created.
    			 */
    			if (result == RESULT_SUCCESSFUL)
    			{
    				/*
    				 *	See if the named channel already exists in the channel list.
    				 */
    				if (NULL != (channel = m_ChannelList2.Find(channel_id)))
    				{
    					/*
    					 *	A Channel object already exists for the named channel.
    					 *	Let it handle the join confirm.
    					 */
    					TRACE_OUT(("Domain::ChannelJoinConfirm: sending confirm to channel object"));
    					channel->ChannelJoinConfirm(pAtt, result, uidInitiator, requested_id, channel_id);
    				}
    				else
    				{
    					/*
    					 *	The new channel will have to be created.
    					 */
    					DBG_SAVE_FILE_LINE
    					channel = new Channel(channel_id, this, m_pConnToTopProvider,
    					                      &m_ChannelList2, &m_AttachmentList);
    					if (channel != NULL)
    					{
    						/*
    						 *	Add the newly created channel to the channel list,
    						 *	and then let the Channel object handle the join
    						 *	confirm.
    						 */
    						TRACE_OUT(("Domain::ChannelJoinConfirm: adding channel ID = %04X", (UINT) channel_id));
    						m_ChannelList2.Insert(channel_id, channel);
    						Number_Of_Channels++;

    						channel->ChannelJoinConfirm(pAtt, result, uidInitiator, requested_id, channel_id);
    					}
    					else
    					{
    						/*
    						 *	The allocation of the Channel object failed.  It
    						 *	is therefore necessary for this provider to cause
    						 *	the channel to be deleted from the domain.  It
    						 *	does this by issuing a channel leave request to
    						 *	the Top Provider, and an unsuccessful channel
    						 *	join confirm to the originating user.
    						 */
    						ERROR_OUT(("Domain::ChannelJoinConfirm: channel allocation failed"));
    						channel_leave_list.Append(channel_id);
    						m_pConnToTopProvider->ChannelLeaveRequest(&channel_leave_list);
    						pAtt->ChannelJoinConfirm(RESULT_UNSPECIFIED_FAILURE, uidInitiator, requested_id, 0);
    					}
    				}
    			}
    			else
    			{
    				/*
    				 *	The result was not successful, so this provider does not
    				 *	have to worry about creating the channel.  It merely
    				 *	forwards the join confirm to the originating user.
    				 */
    				TRACE_OUT(("Domain::ChannelJoinConfirm: forwarding ChannelJoinConfirm to user"));
    				pAtt->ChannelJoinConfirm(result, uidInitiator, requested_id, channel_id);
    			}
    		}
    		else
    		{
    		    ERROR_OUT(("Domain::ChannelJoinConfirm: cannot find the channel"));
    		}
		}
		else
		{
			/*
			 *	The named initiator does not exist in the sub-tree of this
			 *	provider.  This could happen if the user is detached before
			 *	the confirm returns.  It will be necessary to issue a channel
			 *	leave request upward (if the join was successful).
			 */
			WARNING_OUT(("Domain::ChannelJoinConfirm: initiator not found"));

			if (result == RESULT_SUCCESSFUL)
			{
				TRACE_OUT(("Domain::ChannelJoinConfirm: sending ChannelLeaveRequest to Top Provider"));
				channel_leave_list.Append(channel_id);
				m_pConnToTopProvider->ChannelLeaveRequest(&channel_leave_list);
			}
		}
	}
	else
	{
		/*
		 *	This confirm was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::ChannelJoinConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	ChannelLeaveRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially issued by a user that wishes to leave a
 *		channel.  This request will stop cascading upward when it reaches a
 *		provider that has more attachments joined to the channel than the
 *		one that is leaving.  If the requesting user is the only joined to
 *		a channel, this request will flow all the way to the Top Provider.
 */
Void	Domain::ChannelLeaveRequest (
				CAttachment        *pOrigAtt,
				CChannelIDList     *channel_id_list)
{
	ChannelID		chid;
	PChannel		channel;
	CChannelIDList	channel_leave_list;

	/*
	 *	Make sure that the attachment leaving the channel really does exist.
	 */
	if (m_AttachmentList.Find(pOrigAtt))
	{
		/*
		 *	Iterate through the list of channels to be left, processing each
		 *	one independently.
		 */
		channel_id_list->Reset();
		while (NULL != (chid = channel_id_list->Iterate()))
		{
			/*
			 *	Check to make sure that the channel being left really does
			 *	exist.
			 */
			if (NULL != (channel = m_ChannelList2.Find(chid)))
			{
				/*
				 *	Let the Channel object deal with this request.  After
				 *	sending the leave request to the channel, it is necessary to
				 *	check the validity of the channel object determine if it
				 *	should be deleted as a result of this leave operation.
				 */
				TRACE_OUT(("Domain::ChannelLeaveRequest: processing leave request for channel ID = %04X", (UINT) chid));
				channel_leave_list.Clear();
				channel_leave_list.Append(chid);
				channel->ChannelLeaveRequest(pOrigAtt, &channel_leave_list);
				if (channel->IsValid () == FALSE)
					DeleteChannel(chid);
			}
			else
			{
				/*
				 *	The named channel does not exist in the information base.
				 *	Ignore the request.
				 */
				WARNING_OUT(("Domain::ChannelLeaveRequest: received leave request for non-existent channel"));
			}
		}
	}
	else
	{
		/*
		 *	This request originated from an attachment that does not exist
		 *	in the sub-tree of this provider.
		 */
		ERROR_OUT(("Domain::ChannelLeaveRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	ChannelConveneRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user that wishes to convene a
 *		new private channel.  It is forwarded upward to the Top Provider who
 *		will attempt to create the private channel.
 */
Void	Domain::ChannelConveneRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator)
{
	ChannelID		channel_id;
	PChannel		channel;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	If this is the Top Provider, then the request can be serviced
		 *	locally.  If not, then it must be forwarded upward.
		 */
		if (IsTopProvider())
		{
			/*
			 *	See if the arbitrated domain parameters will allow the
			 *	addition of a new channel.
			 */
			if (Number_Of_Channels < Domain_Parameters.max_channel_ids)
			{
				/*
				 *	Since this is a request for a private channel, it is
				 *	necessary to allocate a channel ID from the dynamic range.
				 *	Then, create the private channel.
				 */
				channel_id = AllocateDynamicChannel ();
				DBG_SAVE_FILE_LINE
				channel = new PrivateChannel(channel_id, uidInitiator, this, m_pConnToTopProvider,
				                             &m_ChannelList2, &m_AttachmentList);
				if (channel != NULL)
				{
					/*
					 *	The creation of the new private channel was successful.
					 *	Add it to the channel list.  Note that the channel
					 *	object itself will issue the channel convene confirm.
					 */
					TRACE_OUT(("Domain::ChannelConveneRequest: adding channel ID = %04X", (UINT) channel_id));
					m_ChannelList2.Insert(channel_id, channel);
					Number_Of_Channels++;
				}
				else
				{
					/*
					 *	Allocation of the PrivateChannel object failed.  We
					 *	must therefore issue an unsuccessful channel
					 *	convene confirm to the originating attachment.
					 */
					ERROR_OUT(("Domain::ChannelConveneRequest: channel allocation failed"));
					pOrigAtt->ChannelConveneConfirm(RESULT_UNSPECIFIED_FAILURE, uidInitiator, 0);
				}
			}
			else
			{
				/*
				 *	Domain parmeters will not allow the addition of
				 *	any more channels.  Fail the request.
				 */
				ERROR_OUT(("Domain::ChannelConveneRequest: join denied - too many channels"));
				pOrigAtt->ChannelConveneConfirm(RESULT_TOO_MANY_CHANNELS, uidInitiator, 0);
			}
		}
		else
		{
			/*
			 *	This is not the Top Provider.  That means this is someone elses
			 *	problem.  Issue the request upward toward the Top Provider.
			 */
			TRACE_OUT(("Domain::ChannelConveneRequest: forwarding convene request to Top Provider"));
			m_pConnToTopProvider->ChannelConveneRequest(uidInitiator);
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::ChannelConveneRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	ChannelConveneConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider in response to
 *		a previously received ChannelConveneRequest.  This command contains the
 *		results of the request.
 */
Void	Domain::ChannelConveneConfirm (
				PConnection         pOrigConn,
				Result				result,
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	PChannel		channel;

	/*
	 *	Verify that the confirm came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	Make sure that the requesting user is still somewhere in the
		 *	sub-tree of this provider.
		 */
		if (ValidateUserID (uidInitiator, NULL) )
		{
			/*
			 *	Found out which downward attachment leads to the requesting
			 *	user.
			 */
			if (NULL != (channel = m_ChannelList2.Find(uidInitiator)))
			{
    			CAttachment *pAtt = channel->GetAttachment();
    			ASSERT(pAtt);
    			/*
    			 *	Was the result successful.  If is was, then the local provider
    			 *	needs to create the new private channel in the local information
    			 *	base.
    			 */
    			if (result == RESULT_SUCCESSFUL)
    			{
    				/*
    				 *	See if the named channel already exists in the channel list.
    				 *	Note that it is an error to receive a channel convene
    				 *	confirm for a channel that already exists.  This would
    				 *	indicate a logic error somewhere in the domain hierarchy
    				 *	above this provider.
    				 */
    				if (! m_ChannelList2.Find(channel_id))
    				{
    					/*
    					 *	The new private channel has to be created.
    					 */
    					DBG_SAVE_FILE_LINE
    					channel = new PrivateChannel(channel_id, uidInitiator, this, m_pConnToTopProvider,
    					                             &m_ChannelList2, &m_AttachmentList);
    					if (channel != NULL)
    					{
    						/*
    						 *	Add the newly created channel to the channel list.
    						 *	Let the Channel object handle the convene confirm.
    						 */
    						TRACE_OUT(("Domain::ChannelConveneConfirm: adding channel ID = %04X", (UINT) channel_id));
    						if(m_ChannelList2.Insert(channel_id, channel))
    						{
        						Number_Of_Channels++;
    						}
    						else
    						{
    						       delete channel; 
    						}
    					}
    					else
    					{
    						/*
    						 *	The allocation of the Channel object failed.  It
    						 *	is therefore necessary for this provider to cause
    						 *	the channel to be deleted from the domain.  It
    						 *	does this by issuing a channel disband request to
    						 *	the Top Provider, and an unsuccessful channel
    						 *	convene confirm to the originating user.
    						 */
    						ERROR_OUT(("Domain::ChannelConveneConfirm: channel allocation failed"));
    						m_pConnToTopProvider->ChannelDisbandRequest(uidInitiator, channel_id);
    						pAtt->ChannelConveneConfirm(RESULT_UNSPECIFIED_FAILURE, uidInitiator, 0);
    					}
    				}
    				else
    				{
    					/*
    					 *	A Channel object already exists for the named channel.
    					 *	This is an error, so report the problem, and ignore
    					 *	the confirm.
    					 */
    					ERROR_OUT(("Domain::ChannelConveneConfirm: channel already exists in channel list"));
    				}
    			}
    			else
    			{
    				/*
    				 *	The result was not successful, so this provider does not
    				 *	have to worry about creating the channel.  It merely
    				 *	forwards the join confirm to the originating user.
    				 */
    				TRACE_OUT(("Domain::ChannelConveneConfirm: forwarding ChannelConveneConfirm to user"));
    				pAtt->ChannelConveneConfirm(result, uidInitiator, channel_id);
    			}
    		}
    		else
    		{
    		    ERROR_OUT(("Domain::ChannelConveneConfirm: cannot find the channel"));
    		}
		}
		else
		{
			/*
			 *	The named initiator does not exist in the sub-tree of this
			 *	provider.  This could happen if the user is detached before
			 *	the confirm returns.  Note that since a DetachUserIndication
			 *	will automatically be issued upward for the lost channel
			 *	manager, it is unnecessary for this provider to take any
			 *	special action to eliminate the unowned private channel.
			 */
			ERROR_OUT(("Domain::ChannelConveneConfirm: initiator not found"));
		}
	}
	else
	{
		/*
		 *	This confirm was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::ChannelConveneConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	ChannelDisbandRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user that wishes to disband a
 *		private channel that it previously created.  If the channel is in the
 *		local information base, the request is sent to it.  Otherwise, the
 *		request is ignored.
 */
Void	Domain::ChannelDisbandRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	PChannel	channel;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	Check to see if the specified channel exists in the Channel List.
		 */
		if (NULL != (channel = m_ChannelList2.Find(channel_id)))
		{
			/*
			 *	Send the disband request to the channel object to handle it.
			 *	Then ask the channel object if this request has resulted in a
			 *	need for the channel to be deleted.  This will occur when the
			 *	disband request is handled at the Top Provider.
			 */
			if (channel->GetChannelType() == PRIVATE_CHANNEL)
			{
			    PrivateChannel *pPrivChnl = (PrivateChannel *) channel;
    			TRACE_OUT(("Domain::ChannelDisbandRequest: sending disband request to channel object"));
    			pPrivChnl->ChannelDisbandRequest(pOrigAtt, uidInitiator, channel_id);
    		}
    	    else
    	    {
    	        ERROR_OUT(("Domain::ChannelDisbandRequest: it should be private chanel"));
    	    }
			if (channel->IsValid () == FALSE)
				DeleteChannel (channel_id);
		}
		else
		{
			/*
			 *	The channel does not exist in the information base.  That means
			 *	that this request is invalid, and should be ignored.
			 */
			ERROR_OUT(("Domain::ChannelDisbandRequest: channel does not exist"));
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::ChannelDisbandRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	ChannelDisbandIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider when it decides
 *		to delete a private channel from the domain.  It travels downward to
 *		all attachments and connections that contain an admitted user or the
 *		channel manager in their sub-tree.
 */
Void	Domain::ChannelDisbandIndication (
				PConnection         pOrigConn,
				ChannelID			channel_id)
{
	PChannel		channel;

	/*
	 *	Verify that the indication came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	Check to see if the specified channel exists in the Channel List.
		 */
		if (NULL != (channel = m_ChannelList2.Find(channel_id)))
		{
			/*
			 *	Send the disband indication to the channel object to handle it.
			 *	Then delete the object from the local information base, as it is
			 *	no longer needed.
			 */
			if (channel->GetChannelType() == PRIVATE_CHANNEL)
			{
			    PrivateChannel *pPrivChnl = (PrivateChannel *) channel;
    			TRACE_OUT(("Domain::ChannelDisbandIndication: sending disband indication to channel object"));
    			pPrivChnl->ChannelDisbandIndication(channel_id);
    		}
    	    else
    	    {
    	        ERROR_OUT(("Domain::ChannelDisbandIndication: it should be private chanel"));
    	    }
			if (channel->IsValid () == FALSE)
				DeleteChannel (channel_id);
		}
		else
		{
			/*
			 *	The channel does not exist in the information base.  That means
			 *	that this indication is invalid, and should be ignored.
			 */
			ERROR_OUT(("Domain::ChannelDisbandIndication: channel does not exist"));
		}
	}
	else
	{
		/*
		 *	This indication was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::ChannelDisbandIndication: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	ChannelAdmitRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the manager of a private channel
 *		when it wishes to expand the authorized user list of that channel.  If
 *		the channel is in the local information base, the request is sent to it.
 *		Otherwise, the request is ignored.
 */
Void	Domain::ChannelAdmitRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				ChannelID			channel_id,
				CUidList           *user_id_list)
{
	PChannel		channel;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	Check to see if the specified channel exists in the Channel List.
		 */
		if (NULL != (channel = m_ChannelList2.Find(channel_id)))
		{
			if (channel->GetChannelType() == PRIVATE_CHANNEL)
			{
			    PrivateChannel *pPrivChnl = (PrivateChannel *) channel;
    			/*
    			 *	Send the admit request to the channel object to handle it.
    			 */
    			TRACE_OUT(("Domain::ChannelAdmitRequest: sending admit request to channel object"));
    			pPrivChnl->ChannelAdmitRequest(pOrigAtt, uidInitiator, channel_id, user_id_list);
    		}
    	    else
    	    {
    	        ERROR_OUT(("Domain::ChannelAdmitRequest: it should be private chanel"));
    	    }
		}
		else
		{
			/*
			 *	The channel does not exist in the information base.  That means
			 *	that this request is invalid, and should be ignored.
			 */
			ERROR_OUT(("Domain::ChannelAdmitRequest: channel does not exist"));
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::ChannelAdmitRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	ChannelAdmitIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider when it receives
 *		a channel admit indication from the manager of a private channel.  This
 *		indication is broadcast downward to all providers that contain an
 *		admitted user somewhere in their sub-tree.  A side-effect of this
 *		indication is that a private channel will be created in the information
 *		base if one does not already exist.
 */
Void	Domain::ChannelAdmitIndication (
				PConnection         pOrigConn,
				UserID				uidInitiator,
				ChannelID			channel_id,
				CUidList           *user_id_list)
{
	PChannel	channel;

	/*
	 *	Verify that the indication came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	Check to see if the specified channel exists in the Channel List.
		 */
		if (NULL != (channel = m_ChannelList2.Find(channel_id)))
		{
			if (channel->GetChannelType() == PRIVATE_CHANNEL)
			{
			    PrivateChannel *pPrivChnl = (PrivateChannel *) channel;
    			/*
    			 *	Send the admit indication to the channel object to handle it.
    			 */
    			TRACE_OUT(("Domain::ChannelAdmitIndication: sending admit indication to channel object"));
    			pPrivChnl->ChannelAdmitIndication(pOrigConn, uidInitiator, channel_id, user_id_list);
    	    }
    	    else
    	    {
    	        ERROR_OUT(("Domain::ChannelAdmitIndication: it should be private chanel"));
    	    }
		}
		else
		{
			/*
			 *	Since the private channel does not exist in the information
			 *	base, it will be necessary to create one.  After it is created,
			 *	it can handle the channel admit indication.
			 */
			DBG_SAVE_FILE_LINE
			channel = new PrivateChannel(channel_id, uidInitiator, this, m_pConnToTopProvider,
			                             &m_ChannelList2, &m_AttachmentList);
			if (channel != NULL)
			{
    			PrivateChannel *pPrivChnl = (PrivateChannel *) channel;
				/*
				 *	Put the newly created private channel into the domain
				 *	information base.
				 */
				TRACE_OUT(("Domain::ChannelAdmitIndication: adding channel ID = %04X", (UINT) channel_id));
				if(m_ChannelList2.Insert(channel_id, channel))
				{
        				Number_Of_Channels++;

        				/*
        				 *	Send the admit indication to the new channel object to
        				 *	handle it.
        				 */
        				pPrivChnl->ChannelAdmitIndication(pOrigConn, uidInitiator, channel_id, user_id_list);
				}
				else
				{
				    delete channel;
				}
			}
			else
			{
				/*
				 *	We have been told by the Top Provider to create a private
				 *	channel, but we can't due to a resource shortage.  We also
				 *	can't purge the channel from the domain since the channel
				 *	manager does not exist in the sub-tree of this provider.
				 *	We are therefore out of sync with the Top Provider, and
				 *	there is nothing we can do about it (except for possibly
				 *	disconnecting from the Top Provider and purging the entire
				 *	domain from this node downward).
				 */
				ERROR_OUT(("Domain::ChannelAdmitIndication: channel allocation failure"));
			}
		}
	}
	else
	{
		/*
		 *	This indication was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		WARNING_OUT(("Domain::ChannelAdmitIndication: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	ChannelExpelRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the manager of a private channel
 *		when it wishes to shrink the authorized user list of that channel.  If
 *		the channel is in the local information base, the request is sent to it.
 *		Otherwise, the request is ignored.
 */
Void	Domain::ChannelExpelRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				ChannelID			channel_id,
				CUidList           *user_id_list)
{
	PChannel		channel;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	Check to see if the specified channel exists in the Channel List.
		 */
		if (NULL != (channel = m_ChannelList2.Find(channel_id)))
		{
			if (channel->GetChannelType() == PRIVATE_CHANNEL)
			{
			    PrivateChannel *pPrivChnl = (PrivateChannel *) channel;
    			/*
    			 *	Send the admit request to the channel object to handle it.
    			 */
    			TRACE_OUT(("Domain::ChannelExpelRequest: "
    					"sending expel request to channel object"));
    			pPrivChnl->ChannelExpelRequest(pOrigAtt, uidInitiator, channel_id, user_id_list);
    		}
    	    else
    	    {
    	        ERROR_OUT(("Domain::ChannelExpelRequest: it should be private chanel"));
    	    }
		}
		else
		{
			/*
			 *	The channel does not exist in the information base.  That means
			 *	that this request is invalid, and should be ignored.
			 */
			WARNING_OUT(("Domain::ChannelExpelRequest: channel does not exist"));
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		WARNING_OUT(("Domain::ChannelExpelRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	ChannelExpelIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider when it receives
 *		a request from the manager of a private channel to reduce the
 *		authorized user list.  It travels downward to all attachments and
 *		connections that contain an admitted user or the channel manager in
 *		their sub-tree.
 */
Void	Domain::ChannelExpelIndication (
				PConnection         pOrigConn,
				ChannelID			channel_id,
				CUidList           *user_id_list)
{
	PChannel			channel;

	/*
	 *	Verify that the indication came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	Check to see if the specified channel exists in the Channel List.
		 */
		if (NULL != (channel = m_ChannelList2.Find(channel_id)))
		{
			if (channel->GetChannelType() == PRIVATE_CHANNEL)
			{
			    PrivateChannel *pPrivChnl = (PrivateChannel *) channel;
    			/*
    			 *	Send the expel indication to the channel object to handle it.
    			 *	Then check to see if the channel is still valid (delete it
    			 *	if not).  This would occur if the expel results in an empty
    			 *	admitted user list, and the channel manager is also not in the
    			 *	sub-tree of this provider.
    			 */
    			TRACE_OUT(("Domain::ChannelExpelIndication: sending expel indication to channel object"));
    			pPrivChnl->ChannelExpelIndication(pOrigConn, channel_id, user_id_list);
            }
    	    else
    	    {
    	        ERROR_OUT(("Domain::ChannelExpelIndication: it should be private chanel"));
    	    }
			if (channel->IsValid () == FALSE)
				DeleteChannel (channel_id);
		}
		else
		{
			/*
			 *	The channel does not exist in the information base.  That means
			 *	that this indication is invalid, and should be ignored.
			 */
			ERROR_OUT(("Domain::ChannelExpelIndication: channel does not exist"));
		}
	}
	else
	{
		/*
		 *	This indication was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::ChannelExpelIndication: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	SendDataRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially issued by a user attachment that wishes
 *		to send data on a particular channel in this domain.  The request will
 *		flow upward all the way to the Top Provider.  It will also cause
 *		send data indications to be sent downward to all other attachments
 *		that are joined to the channel.
 */
Void	Domain::SendDataRequest (
				CAttachment        *pOrigAtt,
				UINT				type,
				PDataPacket			data_packet)
{
	PChannel		channel;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(data_packet->GetInitiator(), pOrigAtt))
	{
		/*
		 *	See if the channel exists in the local information base.  If it does
		 *	then let the Channel object handle the routing of the data.  If
		 *	it does not exist, then simply forward the request upward to be
		 *	handled by the next higher provider (unless this is the Top
		 *	Provider).
		 */
		if (NULL != (channel = m_ChannelList2.Find(data_packet->GetChannelID())))
			channel->SendDataRequest(pOrigAtt, type, data_packet);

		else if (! IsTopProvider())
			m_pConnToTopProvider->SendDataRequest(data_packet);
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		WARNING_OUT (("Domain::SendDataRequest: invalid originator=0x%p, uidInitiator=%d", pOrigAtt, data_packet->GetInitiator()));
	}
}

/*
 *	Void	SendDataIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is issued by all providers that receive a send data
 *		request on a channel to which one of their attachments is joined.  It
 *		delivers data in a non-uniform fashion to all users joined to the
 *		named channel.
 */
Void	Domain::SendDataIndication (
				PConnection         pOrigConn,
				UINT				type,
				PDataPacket			data_packet)
{
	PChannel		channel;

	/*
	 *	Verify that the indication came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	See if the channel exists in the local information base.  If it does
		 *	then let the Channel object handle the routing of the data.  If
		 *	it does not exist, then ignore the request.
		 */
		if (NULL != (channel = m_ChannelList2.Find(data_packet->GetChannelID())))
			channel->SendDataIndication(pOrigConn, type, data_packet);
	}
	else
	{
		/*
		 *	This indication was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		WARNING_OUT (("Domain::SendDataIndication: invalid originator=0x%p, initiator=%d", pOrigConn, data_packet->GetInitiator()));
	}
}

/*
 *	Void	TokenGrabRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user attachment that wishes
 *		to grab a token.  It flows upward to the Top Provider, who attempts
 *		to satisfy the request.
 */
Void	Domain::TokenGrabRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				TokenID				token_id)
{
	PToken			token;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	If the token already exists in the token list, then let the Token
		 *	object deal with the request.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			TRACE_OUT(("Domain::TokenGrabRequest: sending grab request to token object"));
			token->TokenGrabRequest(pOrigAtt, uidInitiator, token_id);
		}
		else
		{
			/*
			 *	The token does not exist yet.  Check to see if this is the Top
			 *	Provider.  If it is, then the request can be processed locally.
			 *	Otherwise, forward the request upward.
			 */
			if (IsTopProvider())
			{
				/*
				 *	Check to see if the arbitrated domain parameters will allow
				 *	the addition of another token.
				 */
				if (Number_Of_Tokens < Domain_Parameters.max_token_ids)
				{
					/*
					 *	Try to create a new Token object.
					 */
					DBG_SAVE_FILE_LINE
					token = new Token(token_id, this, m_pConnToTopProvider, &m_ChannelList2, &m_AttachmentList);
					if (token != NULL)
					{
						/*
						 *	Put the newly created Token object into the token
						 *	list.  Then pass the grab request to it.
						 */
						TRACE_OUT(("Domain::TokenGrabRequest: adding token ID = %04X", (UINT) token_id));
						m_TokenList2.Append(token_id, token);
						Number_Of_Tokens++;
						token->TokenGrabRequest(pOrigAtt, uidInitiator, token_id);
					}
					else
					{
						/*
						 *	The allocation of the Token object failed.  It is
						 *	therefore necessary to fail the request.
						 */
						ERROR_OUT(("Domain::TokenGrabRequest: token allocation failed"));
						pOrigAtt->TokenGrabConfirm(RESULT_UNSPECIFIED_FAILURE, uidInitiator, token_id, TOKEN_NOT_IN_USE);
					}
				}
				else
				{
					/*
					 *	The arbitrated domain parameters will not allow the
					 *	creation of another token in this domain.  So fail
					 *	the request.
					 */
					ERROR_OUT(("Domain::TokenGrabRequest: grab denied - too many tokens"));
					pOrigAtt->TokenGrabConfirm(RESULT_TOO_MANY_TOKENS, uidInitiator, token_id, TOKEN_NOT_IN_USE);
				}
			}
			else
			{
				/*
				 *	This is not the Top Provider.  Forward the request upward.
				 */
				TRACE_OUT(("Domain::TokenGrabRequest: forwarding grab request to Top Provider"));
				m_pConnToTopProvider->TokenGrabRequest(uidInitiator, token_id);
			}
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::TokenGrabRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	TokenGrabConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider upon receipt of
 *		a grab request.  It is sent back to the initiating user, containing
 *		the result of the request.
 */
Void	Domain::TokenGrabConfirm (
				PConnection         pOrigConn,
				Result				result,
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	PToken			token;

	/*
	 *	Verify that the confirm came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	See if the token already exists in the local information base.  If
		 *	so, let it handle this.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			TRACE_OUT(("Domain::TokenGrabConfirm: sending grab confirm to token object"));
			token->TokenGrabConfirm(result, uidInitiator, token_id, token_status);
		}
		else
		{
			PChannel	channel;
			/*
			 *	Make sure that the requesting user is still somewhere in the
			 *	sub-tree of this provider.
			 */
			if (ValidateUserID (uidInitiator, NULL) )
			{
				/*
				 *	Determine which attachment leads to the initiating user.
				 */
				if (NULL != (channel = m_ChannelList2.Find(uidInitiator)))
				{
    			    CAttachment *pAtt = channel->GetAttachment();
    			    ASSERT(pAtt);
    				/*
    				 *	If the result of the request is successful, then it is
    				 *	necessary to create the token in the local information base.
    				 */
    				if (result == RESULT_SUCCESSFUL)
    				{
    					/*
    					 *	Create the token.
    					 */
    					DBG_SAVE_FILE_LINE
    					token = new Token(token_id, this, m_pConnToTopProvider, &m_ChannelList2, &m_AttachmentList);
    					if (token != NULL)
    					{
    						/*
    						 *	Put the newly created Token object into the token
    						 *	list.  Then pass the grab confirm to it.
    						 */
    						TRACE_OUT(("Domain::TokenGrabConfirm: adding token ID = %04X", (UINT) token_id));
    						m_TokenList2.Append(token_id, token);
    						Number_Of_Tokens++;
    						token->TokenGrabConfirm(result, uidInitiator, token_id, token_status);
    					}
    					else
    					{
    						/*
    						 *	The creation of the token failed.  It is therefore
    						 *	necessary to send a failed confirm to the initiating
    						 *	user, as well as a token release request to the Top
    						 *	Provider.
    						 */
    						ERROR_OUT(("Domain::TokenGrabConfirm: token creation failed"));
    						m_pConnToTopProvider->TokenReleaseRequest(uidInitiator, token_id);
    						pAtt->TokenGrabConfirm(RESULT_UNSPECIFIED_FAILURE, uidInitiator, token_id, TOKEN_NOT_IN_USE);
    					}
    				}
    				else
    				{
    					/*
    					 *	The confirm was unsuccessful, so there is no need to
    					 *	create a token in the information base.  Just forward
    					 *	the confirm to the initiating user.
    					 */
    					TRACE_OUT(("Domain::TokenGrabConfirm: forwarding failed grab confirm"));
    					pAtt->TokenGrabConfirm(result, uidInitiator, token_id, token_status);
    				}
                }
                else
                {
                    ERROR_OUT(("Domain::TokenGrabConfirm: cannot find channel"));
                }
			}
			else
			{
				/*
				 *	The named initiator does not exist in the sub-tree of this
				 *	provider.  Ignore the confirm.
				 */
				ERROR_OUT(("Domain::TokenGrabConfirm: invalid initiator, uidInitiator=%u", (UINT) uidInitiator));
			}
		}
	}
	else
	{
		/*
		 *	This confirm was received from someone besides the Top Provider.
		 *	Ignore the confirm.
		 */
		ERROR_OUT(("Domain::TokenGrabConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	TokenInhibitRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user attachment that wishes
 *		to inhibit a token.  It flows upward to the Top Provider, who attempts
 *		to satisfy the request.
 */
Void	Domain::TokenInhibitRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				TokenID				token_id)
{
	PToken			token;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	If the token already exists in the token list, then let the Token
		 *	object deal with the request.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			TRACE_OUT(("Domain::TokenInhibitRequest: sending inhibit request to token object"));
			token->TokenInhibitRequest(pOrigAtt, uidInitiator, token_id);
		}
		else
		{
			/*
			 *	The token does not exist yet.  Check to see if this is the Top
			 *	Provider.  If it is, then the request can be processed locally.
			 *	Otherwise, forward the request upward.
			 */
			if (IsTopProvider())
			{
				/*
				 *	Check to see if the arbitrated domain parameters will allow
				 *	the addition of another token.
				 */
				if (Number_Of_Tokens < Domain_Parameters.max_token_ids)
				{
					/*
					 *	Try to create a new Token object.
					 */
					DBG_SAVE_FILE_LINE
					token = new Token(token_id, this, m_pConnToTopProvider, &m_ChannelList2, &m_AttachmentList);
					if (token != NULL)
					{
						/*
						 *	Put the newly created Token object into the token
						 *	list.  Then pass the inhibit request to it.
						 */
						TRACE_OUT(("Domain::TokenInhibitRequest: adding token ID = %04X", (UINT) token_id));
						m_TokenList2.Append(token_id, token);
						Number_Of_Tokens++;
						token->TokenInhibitRequest(pOrigAtt, uidInitiator, token_id);
					}
					else
					{
						/*
						 *	The allocation of the Token object failed.  It is
						 *	therefore necessary to fail the request.
						 */
						ERROR_OUT(("Domain::TokenInhibitRequest: token allocation failed"));
						pOrigAtt->TokenInhibitConfirm(RESULT_UNSPECIFIED_FAILURE, uidInitiator, token_id, TOKEN_NOT_IN_USE);
					}
				}
				else
				{
					/*
					 *	The arbitrated domain parameters will not allow the
					 *	creation of another token in this domain.  So fail
					 *	the request.
					 */
					ERROR_OUT(("Domain::TokenInhibitRequest: inhibit denied - too many tokens"));
					pOrigAtt->TokenInhibitConfirm(RESULT_TOO_MANY_TOKENS, uidInitiator, token_id, TOKEN_NOT_IN_USE);
				}
			}
			else
			{
				/*
				 *	This is not the Top Provider.  Forward the request upward.
				 */
				TRACE_OUT(("Domain::TokenInhibitRequest: forwarding inhibit request to Top Provider"));
				m_pConnToTopProvider->TokenInhibitRequest(uidInitiator, token_id);
			}
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::TokenInhibitRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	TokenInhibitConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider upon receipt of
 *		a inhibit request.  It is sent back to the initiating user, containing
 *		the result of the request.
 */
Void	Domain::TokenInhibitConfirm (
				PConnection         pOrigConn,
				Result				result,
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	PToken			token;

	/*
	 *	Verify that the confirm came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	See if the token already exists in the local information base.  If
		 *	so, let it handle this.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			TRACE_OUT(("Domain::TokenInhibitConfirm: sending inhibit confirm to token object"));
			token->TokenInhibitConfirm(result, uidInitiator, token_id, token_status);
		}
		else
		{
			PChannel	channel;
			/*
			 *	Make sure that the requesting user is still somewhere in the
			 *	sub-tree of this provider.
			 */
			if (ValidateUserID (uidInitiator, NULL) )
			{
				/*
				 *	Determine which attachment leads to the requesting user.
				 */
				if (NULL != (channel = m_ChannelList2.Find(uidInitiator)))
				{
    				CAttachment *pAtt = channel->GetAttachment();
    				ASSERT(pAtt);
    				/*
    				 *	If the result of the request is successful, then it is
    				 *	necessary to create the token in the local information base.
    				 */
    				if (result == RESULT_SUCCESSFUL)
    				{
    					/*
    					 *	Create the token.
    					 */
    					DBG_SAVE_FILE_LINE
    					token = new Token(token_id, this, m_pConnToTopProvider, &m_ChannelList2, &m_AttachmentList);
    					if (token != NULL)
    					{
    						/*
    						 *	Put the newly created Token object into the token
    						 *	list.  Then pass the inhibit confirm to it.
    						 */
    						TRACE_OUT(("Domain::TokenInhibitConfirm: adding token ID = %04X", (UINT) token_id));
    						m_TokenList2.Append(token_id, token);
    						Number_Of_Tokens++;
    						token->TokenInhibitConfirm(result, uidInitiator, token_id, token_status);
    					}
    					else
    					{
    						/*
    						 *	The creation of the token failed.  It is therefore
    						 *	necessary to send a failed confirm to the initiating
    						 *	user, as well as a token release request to the Top
    						 *	Provider.
    						 */
    						ERROR_OUT(("Domain::TokenInhibitConfirm: token creation failed"));
    						m_pConnToTopProvider->TokenReleaseRequest(uidInitiator, token_id);
    						pAtt->TokenInhibitConfirm(RESULT_UNSPECIFIED_FAILURE, uidInitiator, token_id, TOKEN_NOT_IN_USE);
    					}
    				}
    				else
    				{
    					/*
    					 *	The confirm was unsuccessful, so there is no need to
    					 *	create a token in the information base.  Just forward
    					 *	the confirm to the initiating user.
    					 */
    					ERROR_OUT(("Domain::TokenInhibitConfirm: forwarding failed inhibit confirm"));
    					pAtt->TokenInhibitConfirm(result, uidInitiator, token_id, token_status);
    				}
                }
                else
                {
                    ERROR_OUT(("Domain::TokenInhibitConfirm: cannot find channel"));
                }
			}
			else
			{
				/*
				 *	The named initiator does not exist in the sub-tree of this
				 *	provider.  Ignore the confirm.
				 */
				ERROR_OUT(("Domain::TokenInhibitConfirm: initiator not valid, uidInitiator=%u", (UINT) uidInitiator));
			}
		}
	}
	else
	{
		/*
		 *	This confirm was received from someone besides the Top Provider.
		 *	Ignore the confirm.
		 */
		ERROR_OUT(("Domain::TokenInhibitConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	TokenGiveRequest ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void	Domain::TokenGiveRequest (
				CAttachment        *pOrigAtt,
				PTokenGiveRecord	pTokenGiveRec)
{
	PToken		token;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(pTokenGiveRec->uidInitiator, pOrigAtt))
	{
		/*
		 *	If the token already exists in the token list, then let the
		 *	Token object deal with the request.
		 */
		if (NULL != (token = m_TokenList2.Find(pTokenGiveRec->token_id)))
		{
			TRACE_OUT(("Domain::TokenGiveRequest: sending give request to token object"));
			token->TokenGiveRequest(pOrigAtt, pTokenGiveRec);
		}
		else
		{
			/*
			 *	Check to see if this is the Top Provider.  If it is, then the
			 *	request can be processed locally.  Otherwise, forward the
			 *	request upward.
			 */
			if (IsTopProvider())
			{
				/*
				 *	The token does not exist in this domain.  Report this and
				 *	send the appropriate give confirm back to the originating
				 *	user.
				 */
				ERROR_OUT(("Domain::TokenGiveRequest: token does not exist"));
				pOrigAtt->TokenGiveConfirm(RESULT_TOKEN_NOT_POSSESSED,
						pTokenGiveRec->uidInitiator, pTokenGiveRec->token_id, TOKEN_NOT_IN_USE);
			}
			else
			{
				/*
				 *	This is not the Top Provider.  Forward the request upward.
				 */
				TRACE_OUT(("Domain::TokenGiveRequest: forwarding give request to Top Provider"));
				m_pConnToTopProvider->TokenGiveRequest(pTokenGiveRec);
			}
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::TokenGiveRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	TokenGiveIndication ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void	Domain::TokenGiveIndication (
				PConnection         pOrigConn,
				PTokenGiveRecord	pTokenGiveRec)
{
	PToken			token;
	TokenID		token_id = pTokenGiveRec->token_id;

	/*
	 *	Verify that the indication came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	See if the token already exists in the local information base.  If
		 *	so, let it handle this.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			TRACE_OUT(("Domain::TokenGiveIndication: sending give indication to token object"));
			token->TokenGiveIndication(pTokenGiveRec);
		}
		else
		{
			/*
			 *	Make sure that the specified receiver is somewhere in the
			 *	sub-tree of this provider.
			 */
			if (ValidateUserID (pTokenGiveRec->receiver_id, NULL) )
			{
				/*
				 *	Create the token.
				 */
				DBG_SAVE_FILE_LINE
				token = new Token(token_id, this, m_pConnToTopProvider, &m_ChannelList2, &m_AttachmentList);
				if (token != NULL)
				{
					/*
					 *	Put the newly created Token object into the token
					 *	list.  Then pass the give indication to it.
					 */
					TRACE_OUT(("Domain::TokenGiveIndication: adding token ID = %04X", (UINT) token_id));
					if(m_TokenList2.Append(token_id, token))
					{
        					Number_Of_Tokens++;
	        				token->TokenGiveIndication(pTokenGiveRec);
					}
					else
					{
					    delete token;
					}
				}
				else
				{
					/*
					 *	The creation of the token failed.  It is therefore
					 *	necessary to send a failed give response to the Top
					 *	Provider.
					 */
					ERROR_OUT(("Domain::TokenGiveIndication: token creation failed"));
					m_pConnToTopProvider->TokenGiveResponse(RESULT_UNSPECIFIED_FAILURE,
                                                            pTokenGiveRec->uidInitiator, token_id);
				}
			}
			else
			{
				/*
				 *	The specified receiver does not exist in the sub-tree of
				 *	this provider.  It is not necessary for this provider to
				 *	take special action, since the detach user indication for
				 *	the receiver will clean up.
				 */
				ERROR_OUT(("Domain::TokenGiveIndication: receiver not valid"));
			}
		}
	}
	else
	{
		/*
		 *	This indication was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::TokenGiveIndication: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	TokenGiveResponse ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void	Domain::TokenGiveResponse (
				CAttachment        *pOrigAtt,
				Result				result,
				UserID				receiver_id,
				TokenID				token_id)
{
	PToken			token;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this response originated.
	 */
	if (ValidateUserID(receiver_id, pOrigAtt))
	{
		/*
		 *	If the token already exists in the token list, then let the
		 *	Token object deal with the response.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			/*
			 *	Send the give response to the token object.  Then check to
			 *	see if it is still valid (delete it if not).
			 */
			TRACE_OUT(("Domain::TokenGiveResponse: sending give response to token object"));
			token->TokenGiveResponse(result, receiver_id, token_id);
			if (token->IsValid () == FALSE)
				DeleteToken (token_id);
		}
		else
		{
			/*
			 *	The token is not in the information base, which means that it
			 *	cannot be being given to the initiator of this response.
			 *	Ignore the response.
			 */
			ERROR_OUT(("Domain::TokenGiveResponse: no such token"));
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this response
		 *	originated.  Ignore the response.
		 */
		ERROR_OUT(("Domain::TokenGiveResponse: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	TokenGiveConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void	Domain::TokenGiveConfirm (
				PConnection         pOrigConn,
				Result				result,
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	PToken			token;

	/*
	 *	Verify that the confirm came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	See if the token already exists in the local information base.  If
		 *	so, let it handle this.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			/*
			 *	Send the give confirm to the token object.  Then check to
			 *	see if it is still valid (delete it if not).
			 */
			TRACE_OUT(("Domain::TokenGiveConfirm: sending give confirm to token object"));
			token->TokenGiveConfirm(result, uidInitiator, token_id, token_status);
			if (token->IsValid () == FALSE)
				DeleteToken (token_id);
		}
		else
		{
			/*
			 *	Make sure that the requesting user is still somewhere in the
			 *	sub-tree of this provider.
			 */
			if (ValidateUserID (uidInitiator, NULL) )
			{
				PChannel	channel;
				/*
				 *	Determine which attachment leads to the requesting user.
				 *	Then forward the confirm in that direction.
				 */
				TRACE_OUT(("Domain::TokenGiveConfirm: forwarding give confirm"));
				if (NULL != (channel = m_ChannelList2.Find(uidInitiator)))
				{
				    CAttachment *pAtt = channel->GetAttachment();
				    if (pAtt)
				    {
				        pAtt->TokenGiveConfirm(result, uidInitiator, token_id, token_status);
				    }
				    else
				    {
				        ERROR_OUT(("Domain::TokenGiveConfirm: cannot get attachment"));
				    }
				}
				else
				{
				    ERROR_OUT(("Domain::TokenGiveConfirm: cannot find channel"));
				}
			}
			else
			{
				/*
				 *	The named initiator does not exist in the sub-tree of this
				 *	provider.  Ignore the confirm.
				 */
				ERROR_OUT(("Domain::TokenGiveConfirm: initiator not valid"));
			}
		}
	}
	else
	{
		/*
		 *	This confirm was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::TokenGiveConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	TokenPleaseRequest ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void	Domain::TokenPleaseRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				TokenID				token_id)
{
	PToken		token;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	If the token already exists in the token list, then let the
		 *	Token object deal with the request.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			TRACE_OUT(("Domain::TokenPleaseRequest: sending please request to token object"));
			token->TokenPleaseRequest(uidInitiator, token_id);
		}
		else
		{
			/*
			 *	Check to see if this is the Top Provider.  If it is, then the
			 *	request can be processed locally.  Otherwise, forward the
			 *	request upward.
			 */
			if (IsTopProvider())
			{
				/*
				 *	The token being released is not owned by anyone.  Report the
				 *	incident to the diagnostic window, but do nothing.  This
				 *	simply indicates that someone has issued a please request
				 *	for a token that no one owns.
				 */
				ERROR_OUT(("Domain::TokenPleaseRequest: token does not exist"));
			}
			else
			{
				/*
				 *	This is not the Top Provider.  Forward the request upward.
				 */
				TRACE_OUT(("Domain::TokenPleaseRequest: forwarding please request to Top Provider"));
				m_pConnToTopProvider->TokenPleaseRequest(uidInitiator, token_id);
			}
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::TokenPleaseRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	TokenPleaseIndication ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void	Domain::TokenPleaseIndication (
				PConnection         pOrigConn,
				UserID				uidInitiator,
				TokenID				token_id)
{
	PToken		token;

	/*
	 *	Verify that the indication came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	See if the token already exists in the local information base.  If
		 *	so, let it handle this.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			TRACE_OUT(("Domain::TokenPleaseIndication: sending please indication to token object"));
			token->TokenPleaseIndication(uidInitiator, token_id);
		}
		else
		{
			/*
			 *	Since token please indication is only sent downward to providers
			 *	that have owners in their sub-tree, it should not be possible
			 *	to get here.  This indicates that this provider received the
			 *	indication with NO owners in its sub-tree.  Report the error
			 *	and ignore the indication.
			 */
			ERROR_OUT(("Domain::TokenPleaseIndication: invalid token"));
		}
	}
	else
	{
		/*
		 *	This indication was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::TokenPleaseIndication: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	TokenReleaseRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user attachment that wishes
 *		to release a token.  It flows upward to the Top Provider, who attempts
 *		to satisfy the request.
 */
Void	Domain::TokenReleaseRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				TokenID				token_id)
{
	PToken			token;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	If the token already exists in the token list, then let the
		 *	Token object deal with the request.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			/*
			 *	Send the release request to the token object.  Then check to
			 *	see if it is still valid (delete it if not).
			 */
			TRACE_OUT(("Domain::TokenReleaseRequest: sending release request to token object"));
			token->TokenReleaseRequest(pOrigAtt, uidInitiator, token_id);
			if (token->IsValid () == FALSE)
				DeleteToken (token_id);
		}
		else
		{
			/*
			 *	Check to see if this is the Top Provider.  If it is, then the
			 *	request can be processed locally.  Otherwise, forward the
			 *	request upward.
			 */
			if (IsTopProvider())
			{
				/*
				 *	The token being released is not owned by anyone.  Return
				 *	a failure to the initiating user.
				 */
				ERROR_OUT(("Domain::TokenReleaseRequest: token does not exist"));
				pOrigAtt->TokenReleaseConfirm(RESULT_TOKEN_NOT_POSSESSED, uidInitiator, token_id, TOKEN_NOT_IN_USE);
			}
			else
			{
				/*
				 *	This is not the Top Provider.  Forward the request upward.
				 */
				TRACE_OUT(("Domain::TokenReleaseRequest: forwarding release request to Top Provider"));
				m_pConnToTopProvider->TokenReleaseRequest(uidInitiator, token_id);
			}
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::TokenReleaseRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	TokenReleaseConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider upon receipt of
 *		a release request.  It is sent back to the initiating user, containing
 *		the result of the request.
 */
Void	Domain::TokenReleaseConfirm (
				PConnection         pOrigConn,
				Result				result,
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	PToken			token;

	/*
	 *	Verify that the confirm came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	See if the token already exists in the local information base.  If
		 *	so, let it handle this.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			/*
			 *	Send the release confirm to the token object.  Then check to
			 *	see if it is still valid (delete it if not).
			 */
			TRACE_OUT(("Domain::TokenReleaseConfirm: sending release confirm to token object"));
			token->TokenReleaseConfirm(result, uidInitiator, token_id, token_status);
			if (token->IsValid () == FALSE)
				DeleteToken (token_id);
		}
		else
		{
			/*
			 *	Make sure that the requesting user is still somewhere in the
			 *	sub-tree of this provider.
			 */
			if (ValidateUserID (uidInitiator, NULL) )
			{
				PChannel	channel;
				/*
				 *	Determine which attachment leads to the requesting user.
				 *	Then forward the confirm in that direction.
				 */
				TRACE_OUT(("Domain::TokenReleaseConfirm: forwarding release confirm"));
				if (NULL != (channel = m_ChannelList2.Find(uidInitiator)))
				{
				    CAttachment *pAtt = channel->GetAttachment();
				    if (pAtt)
				    {
				        pAtt->TokenReleaseConfirm(result, uidInitiator, token_id, token_status);
				    }
				    else
				    {
				        ERROR_OUT(("Domain::TokenReleaseConfirm: cannot get attachment"));
				    }
				}
				else
				{
				    ERROR_OUT(("Domain::TokenReleaseConfirm: cannot find channel"));
				}
			}
			else
			{
				/*
				 *	The named initiator does not exist in the sub-tree of this
				 *	provider.  Ignore the confirm.
				 */
				WARNING_OUT(("Domain::TokenReleaseConfirm: initiator not valid"));
			}
		}
	}
	else
	{
		/*
		 *	This confirm was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::TokenReleaseConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	TokenTestRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user attachment that wishes
 *		to test a token.  It flows upward to the Top Provider, who attempts
 *		to satisfy the request.
 */
Void	Domain::TokenTestRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				TokenID				token_id)
{
	PToken		token;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	If the token already exists in the token list, then let the Token
		 *	object deal with the request.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			TRACE_OUT(("Domain::TokenTestRequest: sending test request to token object"));
			token->TokenTestRequest(pOrigAtt, uidInitiator, token_id);
		}
		else
		{
			/*
			 *	Check to see if this is the Top Provider.  If it is, then the
			 *	request can be processed locally.  Otherwise, forward the
			 *	request upward.
			 */
			if (IsTopProvider())
			{
				/*
				 *	If the token is not in the list, send a confirm back to
				 *	the initiating user telling it that the token is not in use.
				 */
				ERROR_OUT(("Domain::TokenTestRequest: no such token - available"));
				pOrigAtt->TokenTestConfirm(uidInitiator, token_id, TOKEN_NOT_IN_USE);
			}
			else
			{
				/*
				 *	This is not the Top Provider.  Forward the request upward.
				 */
				TRACE_OUT(("Domain::TokenTestRequest: forwarding test request to Top Provider"));
				m_pConnToTopProvider->TokenTestRequest(uidInitiator, token_id);
			}
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::TokenTestRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	TokenTestConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider upon receipt of
 *		a test request.  It is sent back to the initiating user, containing
 *		the result of the request.
 */
Void	Domain::TokenTestConfirm (
				PConnection         pOrigConn,
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	PToken			token;

	/*
	 *	Verify that the confirm came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	See if the token already exists in the local information base.  If
		 *	so, let it handle this.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			TRACE_OUT(("Domain::TokenTestConfirm: sending test confirm to token object"));
			token->TokenTestConfirm(uidInitiator, token_id, token_status);
		}
		else
		{
			/*
			 *	Make sure that the requesting user is still somewhere in the
			 *	sub-tree of this provider.
			 */
			if (ValidateUserID (uidInitiator, NULL) )
			{
				PChannel	channel;
				/*
				 *	Determine which attachment leads to the requesting user.
				 *	Then forward the confirm in that direction.
				 */
				TRACE_OUT(("Domain::TokenTestConfirm: forwarding test confirm"));
				if (NULL != (channel = m_ChannelList2.Find(uidInitiator)))
				{
    				CAttachment *pAtt = channel->GetAttachment();
    				if (pAtt)
    				{
    				    pAtt->TokenTestConfirm(uidInitiator, token_id, token_status);
    				}
    				else
    				{
    				    ERROR_OUT(("Domain::TokenTestConfirm: cannot get attachment"));
    				}
				}
				else
				{
				    ERROR_OUT(("Domain::TokenTestConfirm: cannot find channel"));
				}
			}
			else
			{
				/*
				 *	The named initiator does not exist in the sub-tree of this
				 *	provider.  Ignore the confirm.
				 */
				ERROR_OUT(("Domain::TokenTestConfirm: initiator not valid uidInitiator=%u", (UINT) uidInitiator));
			}
		}
	}
	else
	{
		/*
		 *	This confirm was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::TokenTestConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void		LockDomainParameters ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is used to initialize the values of the domain parameters
 *		instance variable.
 *
 *	Formal Parameters:
 *		domain_parameters
 *			This is a pointer to the domain parameters structure from which the
 *			values are to be obtained.  If it is set to NULL, then put a default
 *			set of parameters into the instance variable.
 *		parameters_locked
 *			This parameter indicates whether or not these parameters have been
 *			locked into the domain by acceptance of the first connection.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Domain::LockDomainParameters (
					PDomainParameters	domain_parameters,
					BOOL    			parameters_locked)
{
	/*
	 *	If the structure pointer is valid, then copy the structure into the
	 *	internal instance variable.
	 */
	if (domain_parameters != NULL)
		Domain_Parameters = *domain_parameters;
	else
	{
		/*
		 *	Set default values for all domain parameters.
		 */
		Domain_Parameters.max_channel_ids = DEFAULT_MAXIMUM_CHANNELS;
		Domain_Parameters.max_user_ids = DEFAULT_MAXIMUM_USERS;
		Domain_Parameters.max_token_ids = DEFAULT_MAXIMUM_TOKENS;
		Domain_Parameters.number_priorities = DEFAULT_NUMBER_OF_PRIORITIES;
		Domain_Parameters.min_throughput = DEFAULT_MINIMUM_THROUGHPUT;
		Domain_Parameters.max_height = DEFAULT_MAXIMUM_DOMAIN_HEIGHT;
		Domain_Parameters.max_mcspdu_size = DEFAULT_MAXIMUM_PDU_SIZE;
		Domain_Parameters.protocol_version = DEFAULT_PROTOCOL_VERSION;

        if (g_fWinsockDisabled)
        {
    		Domain_Parameters.number_priorities = DEFAULT_NUM_PLUGXPRT_PRIORITIES;
        }
	}

	/*
	 *	Indicate whether or not these parameters are locked.
	 */
	Domain_Parameters_Locked = parameters_locked;
}

/*
 *	ChannelID	AllocateDynamicChannel ()
 *
 *	Private
 *
 *	Functional Description:
 *		This member function is used to allocate an unused channel ID in the
 *		dynamic range (1001 - 65535).  It uses a random number generator to
 *		perform this task.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A channel ID in the dynamic range that is guaranteed to be unused.
 *
 *	Side Effects:
 *		None.
 */
ChannelID	Domain::AllocateDynamicChannel ()
{
	ChannelID		channel_id;

	/*
	 *	Stay in this loop until a unused channel ID is found.  Note that this
	 *	loop make sthe assumption that there will be at least one unused ID
	 *	in there somewhere.
	 */
	while (TRUE)
	{
		/*
		 *	Get a random number in the dynamic channel range.
		 */
		channel_id = (ChannelID) Random_Channel_Generator.GetRandomChannel ();

		/*
		 *	If it is not is use, then break out of the loop and return the
		 *	channel ID.
		 */
		if (! m_ChannelList2.Find(channel_id))
			break;
	}

	return (channel_id);
}

/*
 *	BOOL    ValidateUserID ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to validate a user ID.  It can be used in one of
 *		two ways.  If the passed in attachment is NULL, then this routine will
 *		check to see if the ID corresponds to a user ID anywhere in the sub-tree
 *		of this provider.  If the passed in attachment is not NULL, then this
 *		routine checks to see if the ID is valid user ID associated with that
 *		particular attachment.
 *
 *	Formal Parameters:
 *		user_id
 *			This is the ID to be checked for validity.
 *		attachment
 *			This is the attachment that is presumably associated with the user
 *			ID.  If NULL, we are checking for validity irrespective of
 *			attachment.
 *
 *	Return Value:
 *		This routine will return TRUE if the user ID valid.  FALSE otherwise.
 *
 *	Side Effects:
 *		None.
 */
BOOL    Domain::ValidateUserID (
					UserID				user_id,
					CAttachment        *pAtt)
{
	PChannel		channel;

	/*
	 *	Is the user ID even contained in the channel list.
	 */
	if (NULL != (channel = m_ChannelList2.Find(user_id)))
	{
		/*
		 *	It is in the channel list.  Now check to see if it corresponds to
		 *	a user ID channel.
		 */
		if (channel->GetChannelType () == USER_CHANNEL)
		{
			/*
			 *	Check to make sure that the real user attachment matches the
			 *	passed in one (unless the passed in one is NULL, in which
			 *	case it automatically matches).
			 */
			if ((pAtt == NULL) || (pAtt == channel->GetAttachment()))
				return TRUE;
		}
	}

	return (FALSE);
}

/*
 *	Void	PurgeDomain ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to purge the entire domain.  This can happen for
 *		two reasons.  Either the Top Provider is lost, or the local user has
 *		asked for the domain to be deleted.  Either way, this function breaks
 *		all attachments, and frees up all resources in use by the domain.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		The domain information base is returned to its initial state.
 */
Void	Domain::PurgeDomain (
				Reason			reason)
{
	CAttachment        *pAtt;
	PChannel			channel;
	CUidList			user_list;
	UserID				uid;

	/*
	 *	If there is a Top Provider, send a disconnect to it.
	 */
	if (m_pConnToTopProvider != NULL)
	{
		TRACE_OUT(("Domain::PurgeDomain: disconnecting top provider"));
		m_pConnToTopProvider->DisconnectProviderUltimatum (reason);
		m_pConnToTopProvider = NULL;
	}

	/*
	 *	Send disconnects to all downward attachments.  Then clear out the
	 *	attachment list.
	 */
	TRACE_OUT(("Domain::PurgeDomain: disconnecting all downward attachments"));
	while (NULL != (pAtt = m_AttachmentList.Get()))
	{
		pAtt->DisconnectProviderUltimatum(reason);

		/*
		 *	If there are any pending attach user requests on the attachment
		 *	that was just broken, delete them.  Note that this is a loop
		 *	because there can be more than one.
		 */
		while (m_AttachUserQueue.Remove(pAtt));
	}

	/*
	 *	Send a disconnect to all attachments that represent attach user requests
	 *	in process.  Then clear the queue out.
	 */
	while (NULL != (pAtt = m_AttachUserQueue.Get()))
	{
		pAtt->DisconnectProviderUltimatum(reason);
	}

	/*
	 *	Clear the merge queue.  The actual attachments have already been broken
	 *	above.
	 */
	m_MergeQueue.Clear();

	/*
	 *	We cannot just delete all channels and tokens, because doing so would
	 *	cause them to issue various indications to attachments that are no
	 *	longer valid.  To get around this, we must delete all attachments (which
	 *	was done above) and all user objects from the channel list, and then
	 *	reclaim unowned resources.  This will cause all static, assigned, and
	 *	private channels, as well as tokens, to delete themselves.
	 */
	m_ChannelList2.Reset();
	while (NULL != (channel = m_ChannelList2.Iterate(&uid)))
	{
		if (channel->GetChannelType () == USER_CHANNEL)
			user_list.Append(uid);
	}

	/*
	 *	Delete all users from the channel list.  Since there are no valid users
	 *	in the domain, all resources that are tied to users will be reclaimed
	 *	below.
	 */
	user_list.Reset();
	while (NULL != (uid = user_list.Iterate()))
	{
		DeleteChannel((ChannelID) uid);
	}

	/*
	 *	Reclaim unowned resources.  Since all resources (channels and tokens)
	 *	are tied to the existence of either attachments or users, this call
	 *	will result in all channels and tokens being cleanly deleted (since
	 *	there aren't any attachments or users).
	 */
	ReclaimResources ();

	/*
	 *	Reset the state to all initial values.
	 */
	Merge_State = MERGE_INACTIVE;
	Outstanding_Merge_Requests = 0;
	Number_Of_Users = 0;
	Number_Of_Channels = 0;
	Number_Of_Tokens = 0;
	m_nDomainHeight = 0;
	m_DomainHeightList2.Clear();
	LockDomainParameters (NULL, FALSE);
}

/*
 *	Void	DeleteAttachment ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to free up all resources that are "bound" to
 *		particular attachment.  It also deletes the downward attachment.
 *
 *	Formal Parameters:
 *		attachment
 *			This is the attachment to be deleted.
 *		reason
 *			This is the reason for the deletion.  This is merely passed on in
 *			any MCS commands that are sent as a result of this deletion.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		Resources in the domain information base are freed up.
 */
Void	Domain::DeleteAttachment (
				CAttachment        *pAtt,
				Reason				reason)
{
	ChannelID           chid;
	PChannel			channel;
	CUidList			user_deletion_list;
	CChannelIDList		channel_deletion_list;
	CChannelIDList		channel_leave_list;

	/*
	 *	Check to make sure the attachment is real before proceeding.
	 */
	if (m_AttachmentList.Remove(pAtt))
	{
		/*
		 *	Remove the attachment from the downward attachment list.
		 */

		/*
		 *	Iterate through the channel list building two lists, as follows:
		 *
		 *	1.	A list of users who lie in the direction of the lost attachment.
		 *		These users must be deleted from the information base, and
		 *		their detachment reported appropriately.
		 *	2.	A list of channels that must be deleted as a result of the lost
		 *		attachment.  This list is created by sending a channel leave
		 *		request to all channels, and then checking to see if they are
		 *		still valid.  All static and assigned channels that only had
		 *		that attachment joined will be deleted as a result of this.
		 *		This also results in the attachment being removed from all
		 *		channel attachment lists, avoiding the possibility of sending
		 *		data to an invalid attachment.
		 */
		m_ChannelList2.Reset();
		while (NULL != (channel = m_ChannelList2.Iterate(&chid)))
		{
			/*
			 *	Check to see if this is a user ID channel whose user lies on the
			 *	other side of the lost attachment.  If so, add the channel to
			 *	the deletion list.
			 */
			if (channel->GetChannelType () == USER_CHANNEL)
			{
				if (channel->GetAttachment() == pAtt)
				{
					user_deletion_list.Append(chid);
					continue;
				}
			}

			/*
			 *	Issue the leave request to the channel.  Then check to see if it
			 *	is still valid.  If not, then add it to the deletion list.
			 */
			channel_leave_list.Clear();
			channel_leave_list.Append(chid);
			channel->ChannelLeaveRequest(pAtt, &channel_leave_list);
			if (channel->IsValid () == FALSE)
				channel_deletion_list.Append(chid);
		}
	
		/*
		 *	Iterate through the channel list, deleting the channels it
		 *	contains.
		 */
		channel_deletion_list.Reset();
		while (NULL != (chid = channel_deletion_list.Iterate()))
		{
			DeleteChannel(chid);
		}

		/*
		 *	If there are any users to be deleted, simulate a DetachUserRequest
		 *	with the list of users to be deleted.
		 */	
		if (user_deletion_list.IsEmpty() == FALSE)
			DetachUserRequest(pAtt, reason, &user_deletion_list);

		/*
		 *	Check to see if the deleted attachment is represented in the
		 *	domain height list.  If it is, then this loss could result in a
		 *	change in the overall domain height.
		 */
		if (m_DomainHeightList2.Remove((PConnection) pAtt))
		{
			/*
			 *	The attachment is in the list.  Remove it from the list, and
			 *	call the subroutine that determines whether an overall height
			 *	change has occurred that may require further activity.
			 */
			CalculateDomainHeight ();
		}
	}
	else
	{
		/*
		 *	The named attachment isn't even in the attachment list.
		 */
		ERROR_OUT(("Domain::DeleteAttachment: unknown attachment=0x%p", pAtt));
	}
}

/*
 *	Void	DeleteUser ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine deletes a user from the information base.  This is fairly
 *		complex task because there are a lot of dependencies on users within
 *		the MCS protocol.  If the user being deleted is locall attached, then
 *		the attachment must be severed.  Also, any resources that are being
 *		held by the user must be reclaimed.  And finally, the user channel
 *		object that represents the user must be deleted from the local channel
 *		list.
 *
 *	Formal Parameters:
 *		user_id
 *			This is the ID of the user being deleted.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Domain::DeleteUser (
				UserID				user_id)
{
	CAttachment        *pAtt;
	ChannelID           chid;
	PChannel			channel;
	CChannelIDList		deletion_list;
	CChannelIDList		channel_leave_list;

	/*
	 *	Make sure this is a valid user in the sub-tree of this provider before
	 *	proceeding.
	 */
	if (ValidateUserID (user_id, NULL) )
	{
		/*
		 *	Determine which attachment leads to the user in question.
		 */
		if (NULL != (channel = m_ChannelList2.Find(user_id)))
		{
    		pAtt = channel->GetAttachment();

    		/*
    		 *	Delete the user channel now that it is no longer necessary.
    		 */
    		DeleteChannel (user_id);

    		/*
    		 *	Check to see if the user's attachment is still valid.  It is
    		 *	possible that the user is being deleted as a result of losing the
    		 *	attachment that leads to it.
    		 */
    		if (m_AttachmentList.Find(pAtt) && pAtt->IsUserAttachment())
    		{
    			/*
    			 *	If this user was locally attached, then it is necessary to
    			 *	remove it from the attachment list, as well as making sure that
    			 *	no other channel objects attempt to reference it.
    			 */
    			/*
    			 *	Remove the attachment from the downward attachment list.
    			 */
    			TRACE_OUT(("Domain::DeleteUser: deleting local attachment"));
    			m_AttachmentList.Remove(pAtt);
    			((PUser) pAtt)->Release();

    			/*
    			 *	Iterate through the channel list issuing leave requests to
    			 *	each channel.  This prevents a Channel object from trying to
    			 *	send data on an attachment that is no longer valid.  This
    			 *	loop also builds a list of Channel objects that should be
    			 *	deleted as a result of this detachment.
    			 */
    			m_ChannelList2.Reset();
    			while (NULL != (channel = m_ChannelList2.Iterate(&chid)))
    			{
    				/*
    				 *	Issue the leave request to the channel.  Then check to
    				 *	see if it is still valid.  If not, then add it to the
    				 *	deletion list.
    				 */
    				channel_leave_list.Clear();
    				channel_leave_list.Append(chid);
    				channel->ChannelLeaveRequest(pAtt, &channel_leave_list);
    				if (channel->IsValid () == FALSE)
    					deletion_list.Append(chid);
    			}

    			/*
    			 *	Iterator through the deletion list, deleting the channels it
    			 *	contains.
    			 */
    			deletion_list.Reset();
    			while (NULL != (chid = deletion_list.Iterate()))
    			{
    				DeleteChannel(chid);
    			}
    		}

    		/*
    		 *	Reclaim all resources that may have been freed as a result of the
    		 *	deleted user.
    		 */
    		ReclaimResources ();
    	}
    	else
    	{
    	    ERROR_OUT(("Domain::DeleteUser: cannot find channel"));
    	}
	}
	else
	{
		/*
		 *	The specified user ID is not valid.
		 */
		ERROR_OUT(("Domain::DeleteUser: unknown user ID"));
	}
}

/*
 *	Void	DeleteChannel ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function deleted a channel from the channel list.  It also adjusts
 *		the appropriate channel counter (according to type), and reports the
 *		deletion.
 *
 *	Formal Parameters:
 *		channel_id
 *			This is the ID of the channel to be deleted.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Domain::DeleteChannel (
				ChannelID		channel_id)
{
	PChannel			channel;

	/*
	 *	Make sure the channel being deleted is real before proceeding.
	 */
	if (NULL != (channel = m_ChannelList2.Remove(channel_id)))
	{
		/*
		 *	Report the type of channel being deleted, and decrement the
		 *	appropriate counter.
		 */
		Number_Of_Channels--;
		switch (channel->GetChannelType ())
		{
			case STATIC_CHANNEL:
				TRACE_OUT (("Domain::DeleteChannel: "
						"deleting static channel ID = %04X", channel_id));
				break;

			case ASSIGNED_CHANNEL:
				TRACE_OUT (("Domain::DeleteChannel: "
						"deleting assigned channel ID = %04X", channel_id));
				break;

			case USER_CHANNEL:
				TRACE_OUT (("Domain::DeleteChannel: "
						"deleting user channel ID = %04X", channel_id));
				Number_Of_Users--;
				break;

			case PRIVATE_CHANNEL:
				TRACE_OUT (("Domain::DeleteChannel: "
						"deleting private channel ID = %04X", channel_id));
				break;

			default:
				ERROR_OUT (("Domain::DeleteChannel: "
						"ERROR - deleting unknown channel ID = %04X",
						channel_id));
				Number_Of_Channels++;
				break;
		}

		/*
		 *	Delete the channel object.
		 */
		delete channel;
	}
	else
	{
		ERROR_OUT(("Domain::DeleteChannel: unknown channel ID"));
	}
}

/*
 *	Void	DeleteToken ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function deletes a token from the token list.  It also adjusts
 *		the token counter.
 *
 *	Formal Parameters:
 *		token_id
 *			This is the ID of the token to be deleted.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Domain::DeleteToken (
				TokenID			token_id)
{
	PToken		token;

	/*
	 *	Check to make sure that the token being deleted is real before
	 *	proceeding.
	 */
	if (NULL != (token = m_TokenList2.Remove(token_id)))
	{
		/*
		 *	Remove the token from the token list and delete it.
		 */
		TRACE_OUT(("Domain::DeleteToken: deleting token ID = %04X", (UINT) token_id));
		delete token;

		/*
		 *	Decrement the token counter.
		 */
		Number_Of_Tokens--;
	}
	else
	{
		ERROR_OUT(("Domain::DeleteToken: unknown token ID"));
	}
}

/*
 *	Void	ReclaimResources ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function walks through both the channel and token lists, removing
 *		all objects that are no longer valid.  This function just queries each
 *		channel and token to see if it is still valid.  This allows for the
 *		reclamation of resources when a user is deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Domain::ReclaimResources ()
{
	ChannelID       chid;
	PChannel		channel;
	CChannelIDList	channel_deletion_list;
	TokenID         tid;
	PToken			token;
	CTokenIDList	token_deletion_list;

	/*
	 *	Iterate through the channel list, asking each channel if it is still
	 *	valid.  Any that are not will be deleted by the next loop.
	 */
	m_ChannelList2.Reset();
	while (NULL != (channel = m_ChannelList2.Iterate(&chid)))
	{
		/*
		 *	Check to see if the channel is still valid.  If not, add it to the
		 *	deletion list.
		 */
		if (channel->IsValid () == FALSE)
			channel_deletion_list.Append(chid);
	}

	/*
	 *	Delete all channels in the deletion list.
	 */
	channel_deletion_list.Reset();
	while (NULL != (chid = channel_deletion_list.Iterate()))
	{
		DeleteChannel(chid);
	}

	/*
	 *	Iterate through the token list, asking each token if it is still
	 *	valid.  Any that are not will be deleted by the next loop.
	 */
	m_TokenList2.Reset();
	while (NULL != (token = m_TokenList2.Iterate(&tid)))
	{
		/*
		 *	Check to see if the token is still valid.  If the grabber or
		 *	inhibitor was the only owner of the token, then it will be freed
		 *	here.
		 */
		if (token->IsValid () == FALSE)
			token_deletion_list.Append(tid);
	}

	/*
	 *	Delete all tokens in the deletion list.
	 */
	while (NULL != (tid = token_deletion_list.Get()))
	{
		DeleteToken(tid);
	}
}

/*
 *	Void	MergeInformationBase ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is essentially a state machine for the domain merger
 *		process.  Domain merging is currently implemented to only try and
 *		merge one type of resource at a time.  Each time this routine is
 *		called, the next type of resource is merged.  After all resources have
 *		been merged, this provider ceases to be a Top Provider, and the merge
 *		state is returned to inactive.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		Contents of the domain information are merged upward to the Top
 *		Provider of the upper domain.
 */
Void	Domain::MergeInformationBase ()
{
	MergeState		merge_state;
	Channel_Type	channel_type;
	PChannel		channel;
	PToken			token;

	/*
	 *	This call is not valid unless there is a Top Provider to merge the
	 *	information upward to.
	 */
	if (m_pConnToTopProvider != NULL)
	{
		/*
		 *	As part of the transition to the next merge state, set the number
		 *	of outstanding merge requests to 0.
		 */
		Outstanding_Merge_Requests = 0;
		merge_state = Merge_State;
	
		while (Outstanding_Merge_Requests == 0)
		{
			/*
			 *	Each case of this switch statement sets two variables.  The
			 *	first is the merge state.  This is bumped to the next state
			 *	in the sequence.  The second is the channel type.  This is
			 *	used for controlling which type of channel is being merged
			 *	upward for this state.
			 */
			switch (merge_state)
			{
				case MERGE_INACTIVE:
					TRACE_OUT(("Domain::MergeInformationBase: merging User IDs"));
					merge_state = MERGE_USER_IDS;
					channel_type = USER_CHANNEL;
					break;
		
				case MERGE_USER_IDS:
					TRACE_OUT(("Domain::MergeInformationBase: merging Static Channels"));
					merge_state = MERGE_STATIC_CHANNELS;
					channel_type = STATIC_CHANNEL;
					break;
		
				case MERGE_STATIC_CHANNELS:
					TRACE_OUT(("Domain::MergeInformationBase: merging Assigned Channels"));
					merge_state = MERGE_ASSIGNED_CHANNELS;
					channel_type = ASSIGNED_CHANNEL;
					break;
		
				case MERGE_ASSIGNED_CHANNELS:
					TRACE_OUT(("Domain::MergeInformationBase: merging Private Channels"));
					merge_state = MERGE_PRIVATE_CHANNELS;
					channel_type = PRIVATE_CHANNEL;
					break;
		
				case MERGE_PRIVATE_CHANNELS:
					TRACE_OUT(("Domain::MergeInformationBase: merging Tokens"));
					merge_state = MERGE_TOKENS;
					break;

				case MERGE_TOKENS:
					TRACE_OUT(("Domain::MergeInformationBase: domain merger complete"));
					merge_state = MERGE_COMPLETE;
					break;

				default:
					ERROR_OUT(("Domain::MergeInformationBase: invalid merge state"));
					break;
			}
	
			/*
			 *	If the merge is now complete, then this provider must cease
			 *	to be a Top Provider.
			 */
			if (merge_state == MERGE_COMPLETE)
			{
				/*
				 *	Reset the merge state, and break out of this loop.
				 */
				merge_state = MERGE_INACTIVE;
				break;
			}

			/*
			 *	Check to see if we are to merge tokens on this pass.
			 */
			if (merge_state == MERGE_TOKENS)
			{
				/*
				 *	Iterate through the token list, sending merge requests to
				 *	each Token object.  Pass in the identity of the pending
				 *	Top Provider, so that the Token object knows where to send
				 *	the MergeTokensRequest.  Increment the number of
				 *	outstanding merge requests.
				 */
				m_TokenList2.Reset();
				while (NULL != (token = m_TokenList2.Iterate()))
				{
					token->IssueMergeRequest ();
					Outstanding_Merge_Requests++;
				}
			}
			else
			{
				/*
				 *	This must be a merge state for channels.  Iterate through
				 *	the channel list, sending a merge request to each Channel
				 *	object whose type matches that specified by the merge
				 *	state that we are.  Increment the outstanding merge
				 *	request counter each time one is sent.
				 */
				m_ChannelList2.Reset();
				while (NULL != (channel = m_ChannelList2.Iterate()))
				{
					if (channel->GetChannelType () == channel_type)
					{
						channel->IssueMergeRequest ();
						Outstanding_Merge_Requests++;
					}
				}
			}
		}

		SetMergeState (merge_state);
	}
	else
	{
		/*
		 *	This routine has been called when the domain is not in the
		 *	appropriate state.
		 */
		ERROR_OUT(("Domain::MergeInformationBase: unable to merge at this time"));
	}
}

/*
 *	Void	SetMergeState ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function sets the merge state to the passed in value.  It also
 *		detects the transition between MERGE_INACTIVE and any other state.
 *		This transition causes the domain to issue MergeDomainIndication to
 *		all downward attachments.
 *
 *	Formal Parameters:
 *		merge_state
 *			This is the merge state that we are moving to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Domain::SetMergeState (
				MergeState		merge_state)
{
	CAttachment     *pAtt;

	/*
	 *	Don't do anything unless the merge state is actually changing.
	 */
	if (Merge_State != merge_state)
	{
		/*
		 *	If the old state is inactive, then that means that we are just
		 *	beginning a domain merge operation.  If this is the case, then
		 *	iterate through the downward attachment list, telling all
		 *	attachments about the domain merge.
		 *
		 *	Note that a side effect of this call is that all MCS commands
		 *	are shut off from the attachments that receive it.  This allows the
		 *	domain information base to remain stable during a merge operation.
		 */
		if (Merge_State == MERGE_INACTIVE)
		{
			m_AttachmentList.Reset();
			while (NULL != (pAtt = m_AttachmentList.Iterate()))
			{
				pAtt->MergeDomainIndication(MERGE_DOMAIN_IN_PROGRESS);
			}
		}

		/*
		 *	Set the merge state.
		 */
		Merge_State = merge_state;

		/*
		 *	If the new state is inactive, then that means that we have just
		 *	completed a domain merge operation.  If this is the case, then
		 *	iterate through the downward attachment list, telling all
		 *	attachments about the completion of the merge.
		 *
		 *	Note that a side effect of this call is to re-enable MCS commands
		 *	from the attachments that receive it.
		 */
		if (Merge_State == MERGE_INACTIVE)
		{
			m_AttachmentList.Reset();
			while (NULL != (pAtt = m_AttachmentList.Iterate()))
			{
				pAtt->MergeDomainIndication(MERGE_DOMAIN_COMPLETE);
			}
		}
	}
}

/*
 *	Void	AddChannel ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to add a channel to the channel list during a
 *		merge channel operation.  This type of channel addition works a little
 *		differently, since we do not want to send confirms to the users, but
 *		rather, to former Top Provider of the lower domain.
 *
 *	Formal Parameters:
 *		attachment
 *			This is the initial attachment that the channel is to have joined
 *			to it.
 *		merge_channel
 *			This is a pointer to a channel attributes structure containing the
 *			attributes of the channel to be added.
 *		merge_channel_list
 *			This is a list of channel attribute structures for those channels
 *			that were successfully merged into the domain information base.  It
 *			will be used to issue the merge channels confirm downward.
 *		purge_channel_list
 *			This is a list of channel IDs for those channels that were not
 *			successfully merged into the domain information base.  It will be
 *			used to issue the merge channels confirm downward.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Domain::AddChannel (
				PConnection             pConn,
				PChannelAttributes		merge_channel,
				CChannelAttributesList *merge_channel_list,
				CChannelIDList         *purge_channel_list)
{
	Channel_Type	channel_type;
	ChannelID		channel_id=0;
	BOOL    		joined;
	ChannelID		channel_manager=0;
	CUidList       *admitted_list;
	PChannel		channel=NULL;
	CUidList		detach_user_list;
	CChannelIDList	channel_leave_list;

	/*
	 *	Determine what has to be done according to the channel type.
	 */
	channel_type = merge_channel->channel_type;
	switch (channel_type)
	{
		case STATIC_CHANNEL:
			/*
			 *	Get the channel ID from the attributes structure.
			 */
			channel_id = merge_channel->u.static_channel_attributes.channel_id;

			/*
			 *	If this is the Top Provider, check to see if current
			 *	domain parameters will permit the merge.
			 */
			if ((m_pConnToTopProvider == NULL) &&
					(Number_Of_Channels >= Domain_Parameters.max_channel_ids))
			{
				ERROR_OUT(("Domain::AddChannel: too many channels"));
				channel = NULL;
				break;
			}

			/*
			 *	Attempt to create a new Channel object.
			 */
			TRACE_OUT(("Domain::AddChannel: adding new channel ID = %04X", (UINT) channel_id));
			DBG_SAVE_FILE_LINE
			channel = new Channel(channel_id, this, m_pConnToTopProvider, &m_ChannelList2,
			                      &m_AttachmentList, pConn);
			/*
			 *	Increment the number of channels if everything went okay.
			 */
			if (channel != NULL)
				Number_Of_Channels++;
			break;

		case USER_CHANNEL:
			/*
			 *	Get the channel ID from the attributes structure.
			 */
			joined = merge_channel->u.user_channel_attributes.joined;
			channel_id = merge_channel->u.user_channel_attributes.user_id;

			/*
			 *	If this is the Top Provider, check to see if current
			 *	domain parameters will permit the merge.
			 */
			if ((m_pConnToTopProvider == NULL) &&
					((Number_Of_Users >= Domain_Parameters.max_user_ids) ||
					(Number_Of_Channels >= Domain_Parameters.max_channel_ids)))
			{
				ERROR_OUT(("Domain::AddChannel: too many users"));
				channel = NULL;
				break;
			}

			/*
			 *	Attempt to create a new UserChannel object to represent the
			 *	merged user ID.
			 */
			TRACE_OUT(("Domain::AddChannel: adding new user ID = %04X", (UINT) channel_id));

			DBG_SAVE_FILE_LINE
			channel = new UserChannel(channel_id, pConn, this, m_pConnToTopProvider,
			                          &m_ChannelList2, &m_AttachmentList, joined ? pConn : NULL);
			/*
			 *	Increment the number of users if everything went okay.
			 */
			if (channel != NULL)
			{
				Number_Of_Users++;
				Number_Of_Channels++;
			}
			break;

		case PRIVATE_CHANNEL:
			/*
			 *	Get the channel ID and the channel manager ID from the
			 *	attributes structure.
			 */
			joined = merge_channel->u.private_channel_attributes.joined;
			channel_id = merge_channel->u.private_channel_attributes.channel_id;
			channel_manager = merge_channel->
					u.private_channel_attributes.channel_manager;
			admitted_list = merge_channel->
					u.private_channel_attributes.admitted_list;

			/*
			 *	If this is the Top Provider, check to see if current
			 *	domain parameters will permit the merge.
			 */
			if ((m_pConnToTopProvider == NULL) &&
					(Number_Of_Channels >= Domain_Parameters.max_channel_ids))
			{
				ERROR_OUT(("Domain::AddChannel: too many channels"));
				channel = NULL;
				break;
			}

			/*
			 *	Attempt to create a new PrivateChannel object.
			 */
			TRACE_OUT(("Domain::AddChannel: adding new private channel ID = %04X", (UINT) channel_id));

			DBG_SAVE_FILE_LINE
    		channel = new PrivateChannel(channel_id, channel_manager, this, m_pConnToTopProvider,
                                         &m_ChannelList2, &m_AttachmentList, admitted_list,
                                         joined ? pConn : NULL);
			/*
			 *	Increment the number of channels if everything went okay.
			 */
			if (channel != NULL)
				Number_Of_Channels++;
			break;

		case ASSIGNED_CHANNEL:
			/*
			 *	Get the channel ID from the attributes structure.
			 */
			channel_id = merge_channel->
					u.assigned_channel_attributes.channel_id;

			/*
			 *	If this is the Top Provider, check to see if current
			 *	domain parameters will permit the merge.
			 */
			if ((m_pConnToTopProvider == NULL) &&
					(Number_Of_Channels >= Domain_Parameters.max_channel_ids))
			{
				ERROR_OUT(("Domain::AddChannel: too many channels"));
				channel = NULL;
				break;
			}

			/*
			 *	Attempt to create a new Channel object.
			 */
			TRACE_OUT(("Domain::AddChannel: adding new channel ID = %04X", (UINT) channel_id));

			DBG_SAVE_FILE_LINE
			channel = new Channel(channel_id, this, m_pConnToTopProvider, &m_ChannelList2,
			                      &m_AttachmentList, pConn);
			/*
			 *	Increment the number of channels if everything went okay.
			 */
			if (channel != NULL)
				Number_Of_Channels++;
			break;
	}

	if (channel != NULL)
	{
		/*
		 *	The channel was successfully created.  Add it to the channel list
		 *	and add the channel structure to the merge channel list, which is
		 *	used to issue the merge channels confirm downward.
		 */
		 if(m_ChannelList2.Insert(channel_id, channel))
		 {
        		merge_channel_list->Append(merge_channel);
		 }
		 else
		 {
                    Number_Of_Channels--;
                    delete channel;
		 }
	}
	else
	{
		/*
		 *	The channel merge operation has failed.  We need to tell whoever
		 *	is interested in this situation.
		 */
		WARNING_OUT(("Domain::AddChannel: channel merger failed"));

		if (m_pConnToTopProvider != NULL)
		{
			/*
			 *	If this is not the Top Provider, then the Top Provider needs
			 *	to be told about the problem.  If this is a user channel, then
			 *	issue a detach user request.  If it is a normal channel, issue
			 *	a channel leave request.  If it is a private channel, issue a
			 *	channel disband request.
			 */
			switch (channel_type)
			{
				case STATIC_CHANNEL:
				case ASSIGNED_CHANNEL:
					TRACE_OUT(("Domain::AddChannel: sending ChannelLeaveRequest to Top Provider"));
					channel_leave_list.Append(channel_id);
					m_pConnToTopProvider->ChannelLeaveRequest(&channel_leave_list);
					break;

				case USER_CHANNEL:
					TRACE_OUT(("Domain::AddChannel: sending DetachUserRequest to Top Provider"));
					detach_user_list.Append(channel_id);
					m_pConnToTopProvider->DetachUserRequest(REASON_PROVIDER_INITIATED, &detach_user_list);
					break;

				case PRIVATE_CHANNEL:
					TRACE_OUT(("Domain::AddChannel: sending ChannelDisbandRequest to Top Provider"));
					m_pConnToTopProvider->ChannelDisbandRequest(channel_manager, channel_id);
					break;
			}
		}
	
		/*
		 *	Since the merge has failed, we need to put the channel ID into the
		 *	purge channel list (which is used to issue the merge channels
		 *	confirm downward).
		 */
		purge_channel_list->Append(channel_id);
	}
}

/*
 *	Void	AddToken ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to add a token to the token list during a
 *		merge token operation.  This type of token addition works a little
 *		differently, since we do not want to send confirms to the owners of
 *		the token, but rather, to the former Top Provider of the lower domain.
 *
 *	Formal Parameters:
 *		merge_token
 *			This is a pointer to a token attributes structure containing the
 *			attributes of the token to be added.
 *		merge_token_list
 *			This is a list of token attribute structures for those tokens
 *			that were successfully merged into the domain information base.  It
 *			will be used to issue the merge tokens confirm downward.
 *		purge_token_list
 *			This is a list of token IDs for those tokens that were not
 *			successfully merged into the domain information base.  It will be
 *			used to issue the merge tokens confirm downward.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Domain::AddToken (
				PTokenAttributes		merge_token,
				CTokenAttributesList   *merge_token_list,
				CTokenIDList           *purge_token_list)
{
	TokenState		token_state;
	TokenID			token_id;
	UserID			grabber;
	CUidList       *inhibitor_list;
	UserID			recipient;
	PToken			token;
	UserID			uid;

	/*
	 *	Determine what state the token to be merged is in.  Then get the
	 *	required information for each particular state.
	 */
	token_state = merge_token->token_state;
	switch (token_state)
	{
		case TOKEN_GRABBED:
			token_id = merge_token->u.grabbed_token_attributes.token_id;
			grabber = merge_token->u.grabbed_token_attributes.grabber;
			inhibitor_list = NULL;
			recipient = 0;
			break;

		case TOKEN_INHIBITED:
			token_id = merge_token->u.inhibited_token_attributes.token_id;
			grabber = 0;
			inhibitor_list = merge_token->
					u.inhibited_token_attributes.inhibitors;
			recipient = 0;
			break;

		case TOKEN_GIVING:
			token_id = merge_token->u.giving_token_attributes.token_id;
			grabber = merge_token->u.giving_token_attributes.grabber;
			inhibitor_list = NULL;
			recipient = merge_token->u.giving_token_attributes.recipient;
			break;

		case TOKEN_GIVEN:
			token_id = merge_token->u.given_token_attributes.token_id;
			grabber = 0;
			inhibitor_list = NULL;
			recipient = merge_token->u.given_token_attributes.recipient;
			break;
	}

	/*
	 *	Check to see if it is okay to add this token.  If we are the top
	 *	provider, and adding this token would cause us to exceed the arbitrated
	 *	limit on tokens, then we must fail the request.
	 */
	if ((m_pConnToTopProvider != NULL) ||
			(Number_Of_Tokens < Domain_Parameters.max_token_ids))
	{
		/*
		 *	Create a new token with all merged values as determined above.
		 */
		DBG_SAVE_FILE_LINE
		token = new Token(token_id, this, m_pConnToTopProvider, &m_ChannelList2,
				&m_AttachmentList, token_state, grabber, inhibitor_list, recipient);
		if (token != NULL)
		{
			/*
			 *	If the creation was successful, add the token to the list and
			 *	add the token attributes structure to the merge token list.
			 */
			TRACE_OUT(("Domain::AddToken: add new token ID = %04X", (UINT) token_id));
			if(m_TokenList2.Append(token_id, token))
			{
			Number_Of_Tokens++;
			merge_token_list->Append(merge_token);
			}
			else
			{
			    delete token;
			}
		}
		else
		{
			/*
			 *	The token allocation has failed.  It is therefore necessary to
			 *	perform some cleanup operations.
			 */
			WARNING_OUT (("Domain::AddToken: token allocation failed"));

			/*
			 *	Check to see if this is the top provider.  If not, then it
			 *	is necessary to issue appropriate requests upward to free the
			 *	token from the information bases above.
			 */
			if (m_pConnToTopProvider != NULL)
			{
				/*
				 *	Determine which state the token is in.  This affects how
				 *	the cleanup needs to work.
				 */
				switch (token_state)
				{
					case TOKEN_GRABBED:
						/*
						 *	If the token is grabbed, then issue a release to
						 *	free it above.
						 */
						m_pConnToTopProvider->TokenReleaseRequest(grabber, token_id);
						break;

					case TOKEN_INHIBITED:
						{
							/*
							 *	Iterate through the inhibitor list, issuing a
							 *	release request for each user contained therein.
							 *	This will result in the token being freed at all
							 *	upward providers.
							 */
							inhibitor_list->Reset();
							while (NULL != (uid = inhibitor_list->Iterate()))
							{
								m_pConnToTopProvider->TokenReleaseRequest(uid, token_id);
							}
						}
						break;

					case TOKEN_GIVING:
						/*
						 *	If the token is being given from one user to
						 *	another, issue a release on behalf of the current
						 *	owner, and a rejected give response on behalf
						 *	of the recipient.
						 *
						 *	WARNING:
						 *	This will cause the current owner to receive a
						 *	release confirm with no outstanding request.
						 */
						m_pConnToTopProvider->TokenReleaseRequest(grabber, token_id);
						m_pConnToTopProvider->TokenGiveResponse(RESULT_USER_REJECTED,
						                                        recipient, token_id);
						break;

					case TOKEN_GIVEN:
						/*
						 *	Issue a rejected give response on behalf of the
						 *	user that is being offered the token.
						 */
						m_pConnToTopProvider->TokenGiveResponse(RESULT_USER_REJECTED,
						                                        recipient, token_id);
						break;
				}
			}

			/*
			 *	Add the token ID to the purge token list, which will be passed
			 *	downward to the former top provider of the lower domain.  This
			 *	will tell that provider that the token was NOT accepted in the
			 *	upper domain.
			 */
			purge_token_list->Append(token_id);
		}
	}
	else
	{
		/*
		 *	The upper domain already has the domain limit of tokens.  So
		 *	automatically reject the merge request.
		 */
		ERROR_OUT(("Domain::AddToken: too many tokens - rejecting merge"));
		purge_token_list->Append(token_id);
	}
}

/*
 *	Void	CalculateDomainHeight ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is called whenever an event occurs that could have
 *		resulted in a change in the overall height of the domain.  This includes
 *		making and breaking connections, and the reception of an erect domain
 *		request from a lower provider.
 *
 *		This routine will adjust the height of the current provider, and if
 *		this is the top provider, will take necessary steps to insure that the
 *		arbitrated domain parameters are not violated.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Domain::CalculateDomainHeight ()
{
	UINT_PTR	domain_height;
	UINT_PTR	temp_domain_height;
	CAttachment        *pAtt;

	/*
	 *	Initialize domain height to zero.  This will only be increased if there
	 *	is at least one remote attachment below this one.
	 */
	domain_height = 0;

	/*
	 *	Check to see if there is anyone below this provider that would affect
	 *	its height in the domain (this would be remote attachments that have
	 *	issued ErectDomainRequests to tell this provider of their height).
	 */
	if (m_DomainHeightList2.IsEmpty() == FALSE)
	{
		/*
		 *	Iterate through the domain height list to determine which downward
		 *	attachment has the greatest height.  This is the height that will be
		 *	used to determine height of this provider.
		 */
		m_DomainHeightList2.Reset();
		while (NULL != (temp_domain_height = m_DomainHeightList2.Iterate()))
		{
			if (domain_height < temp_domain_height)
				domain_height = temp_domain_height;
		}

		/*
		 *	The height of this provider is one greater than the height of its
		 *	highest downward attachment.
		 */
		domain_height++;
	}

	/*
	 *	Compare the calculated domain height with the current domain height.
	 *	If they are the same, then no further action needs to be taken.
	 */
	if (domain_height != m_nDomainHeight)
	{
		TRACE_OUT(("Domain::CalculateDomainHeight: new domain height = %d", (UINT) domain_height));
		m_nDomainHeight = domain_height;

		/*
		 *	The domain height has changed.  We need to verify that the
		 *	arbitrated domain height has not been violated.
		 */
		if (m_nDomainHeight > Domain_Parameters.max_height)
		{
			/*
			 *	The new domain height is invalid.  We must issue a plumb
			 *	domain indication downward to enforce the arbitrated
			 *	domain height.
			 */
			TRACE_OUT(("Domain::CalculateDomainHeight: issuing plumb domain indication"));
			m_AttachmentList.Reset();
			while (NULL != (pAtt = m_AttachmentList.Iterate()))
			{
				pAtt->PlumbDomainIndication(Domain_Parameters.max_height);
			}
		}

		/*
		 *	If this is not the Top Provider, then it is necessary to transmit an
		 *	erect domain request upward to inform the upper domain of the
		 *	change.
		 */
		if (m_pConnToTopProvider != NULL)
		{
			/*
			 *	Issue an erect domain request upward to inform the upper
			 *	domain of the change in height.  Without this, the Top Provider
			 *	would have no way of determining when the domain height is
			 *	invalid.
			 */
			m_pConnToTopProvider->ErectDomainRequest(m_nDomainHeight, DEFAULT_THROUGHPUT_ENFORCEMENT_INTERVAL);
		}
	}
}



PUser CAttachmentList::IterateUser(void)
{
    CAttachment *pAtt;
    while (NULL != (pAtt = Iterate()))
    {
        if (pAtt->IsUserAttachment())
        {
            return (PUser) pAtt;
        }
    }
    return NULL;
}


PConnection CAttachmentList::IterateConn(void)
{
    CAttachment *pAtt;
    while (NULL != (pAtt = Iterate()))
    {
        if (pAtt->IsConnAttachment())
        {
            return (PConnection) pAtt;
        }
    }
    return NULL;
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\csap.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_SAP);
/*
 *      csap.cpp
 *
 *      Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *      Abstract:
 *              This implementation file for the CControlSAP class contains Service
 *              Access entry and exit points specific to the Node Controller.  This
 *              module inherits the common entry and exit points from the CBaseSap object.
 *              On request and responses, parameter checking is performed to ensure that
 *              they can be properly processed.  Queuing and flushing of out bound
 *              messages is     taken care of in the base class.
 *
 *      Protected Instance Variables:
 *              See file SAP.CPP for definitions of instance variables.
 *
 *      Private Instance Variables:
 *              m_nJoinResponseTag:
 *                      This tag is used to match join request with join responses from the
 *                      node controller.
 *                      
 *              m_JoinResponseTagList2:
 *                      This list keeps up with all the outstanding join response tags.
 *                      Tags are added to this list on a join indication and removed
 *                      from this list on a Join response.
 *
 *      Private Member Functions:
 *              IsNumericNameValid
 *                      This routine is used to validate a numeric string by checking to
 *                      make sure that none of the constraints imposed by the ASN.1
 *                      specification are violated.
 *              IsTextNameValid
 *                      This routine is used to validate a text string by checking to make
 *                      sure that none of the constraints imposed by the ASN.1 specification
 *                      are violated.
 *              QueueJoinIndication
 *                      This routine is used to place join indications into the queue of
 *                      messages to be delivered to the node controller.
 *              HandleResourceFailure
 *                      This routine is used to clean up after any resource allocation
 *                      failures which may have occurred by sending a status indication
 *                      reporting the error.
 *              FreeCallbackMessage
 *                      This routine is used to free up any data which was allocated in
 *                      order to send a callback message to the node controller.
 *              RetrieveUserDataList
 *                      This routine is used to fill in a user data list using a
 *                      CUserDataListContainer container.  The memory needed to hold the user data
 *                      will be allocated by this routine.
 *
 *      Caveats:
 *              None.
 *
 *      Author:
 *              blp
 */

#include "ms_util.h"
#include "csap.h"
#include "conf.h"
#include "gcontrol.h"

//      Defintions to support Join Response Tag hash list
#define MAXIMUM_CONFERENCE_NAME_LENGTH                          255


//  This is how much time the apps have to cleanup with MCS and GCC
//  after GCCCleanup is called. They may be terminated if they do not
//  cleanup in this amount of time.
#define PROCESS_TERMINATE_TIME  5000

/*
 *      Static variables used within the C to C++ converter.
 *
 *      Static_Controller
 *              This is a pointer to the one-and-only controller created within the
 *              GCC system.  This object is created during
 *              GCCStartup by the process
 *              that is taking on the responsibilities of the node controller.
 */
GCCController      *g_pGCCController = NULL;
CControlSAP        *g_pControlSap = NULL;

char                g_szGCCWndClassName[24];


// The MCS main thread handle
extern HANDLE           g_hMCSThread;

/*
 *      GCCError        GCCStartup()
 *
 *      Public
 *
 *      Functional Description:
 *              This API entry point is used to initialize the GCC DLL for action.  It
 *              creates an instance of the Controller, which controls all activity
 *              during a GCC session.  Note that there is only one instance of the
 *              Controller, no matter how many applications are utilizing GCC
 *              services.
 */
GCCError WINAPI T120_CreateControlSAP
(
    IT120ControlSAP               **ppIControlSap,
    LPVOID                          pUserDefined,
    LPFN_T120_CONTROL_SAP_CB        pfnControlSapCallback
)
{
    GCCError    rc;

    if (NULL != ppIControlSap && NULL != pfnControlSapCallback)
    {
        if (NULL == g_pGCCController && NULL == g_pControlSap)
        {
            //
            // Create the window class for all the SAPs, including both
            // control SAP and applet SAP.
            //
            WNDCLASS wc;
            ::wsprintfA(g_szGCCWndClassName, "GCC%0lx_%0lx", (UINT) ::GetCurrentProcessId(), (UINT) ::GetTickCount());
            ASSERT(::lstrlenA(g_szGCCWndClassName) < sizeof(g_szGCCWndClassName));
            ::ZeroMemory(&wc, sizeof(wc));
            // wc.style         = 0;
            wc.lpfnWndProc      = SapNotifyWndProc;
            // wc.cbClsExtra    = 0;
            // wc.cbWndExtra    = 0;
            wc.hInstance        = g_hDllInst;
            // wc.hIcon         = NULL;
            // wc.hbrBackground = NULL;
            // wc.hCursor       = NULL;
            // wc.lpszMenuName  = NULL;
            wc.lpszClassName    = g_szGCCWndClassName;
            if (::RegisterClass(&wc))
            {
                /*
                 *      This process is to become the node controller.  Create a
                 *      controller object to carry out these duties.
                 */
                DBG_SAVE_FILE_LINE
                g_pGCCController = new GCCController(&rc);
                if (NULL != g_pGCCController && GCC_NO_ERROR == rc)
                {
                     /*
                     ** Create the control SAP. Note that the Node Controller
                     ** interface must be in place before this is called so
                     ** that the control SAP can register itself.
                     */
                    DBG_SAVE_FILE_LINE
                    g_pControlSap = new CControlSAP();
                    if (NULL != g_pControlSap)
                    {
                        /*
                         *      Tell the application interface object what it
                         *      needs to know send callbacks to the node
                         *      controller.
                         */
                        TRACE_OUT(("T120_CreateControlSAP: controller successfully created"));
                        *ppIControlSap = g_pControlSap;
                        g_pControlSap->RegisterNodeController(pfnControlSapCallback, pUserDefined);
                    }
                    else
                    {
                        ERROR_OUT(("T120_CreateControlSAP: can't create CControlSAP"));
                        rc = GCC_ALLOCATION_FAILURE;
                    }
                }
                else
                {
                    ERROR_OUT(("T120_CreateControlSAP: deleting faulty controller"));
                    if (NULL != g_pGCCController)
                    {
                        g_pGCCController->Release();
                        g_pGCCController = NULL;
                    }
                        rc = GCC_ALLOCATION_FAILURE;
                }
            }
            else
            {
                ERROR_OUT(("T120_CreateControlSAP: can't register window class, err=%u", (UINT) GetLastError()));
                rc = GCC_ALLOCATION_FAILURE;
            }
        }
        else
        {
            ERROR_OUT(("T120_CreateControlSAP: GCC has already been initialized, g_pControlSap=0x%x, g_pGCCCotnroller=0x%x", g_pControlSap, g_pGCCController));
            rc = GCC_ALREADY_INITIALIZED;
        }
    }
    else
    {
        ERROR_OUT(("T120_CreateControlSAP: null pointers, ppIControlSap=0x%x, pfnControlSapCallback=0x%x", ppIControlSap, pfnControlSapCallback));
        rc = GCC_INVALID_PARAMETER;
    }
    return rc;
}

/*
 *      GCCError        GCCCleanup()
 *
 *      Public
 *
 *      Functional Description:
 *              This function deletes the controller (if one exists).  It is VERY
 *              important that only the routine that successfully called
 *              GCCInitialize call this routine.  Once this routine has been called,
 *              all other GCC calls will fail.
 */
void CControlSAP::ReleaseInterface ( void )
{
    UnregisterNodeController();

    /*
     *  Destroy the controller, which will clean up all
     *  resources in use at this time.  Then reset the flag
     *  indicating that GCC is initialized (since it no
     *  longer is).
     */
    TRACE_OUT(("GCCControlSap::ReleaseInterface: deleting controller"));
    g_pGCCController->Release();

    //  This is how much time the apps have to cleanup with MCS and GCC
    //  after GCCCleanup is called. They may be terminated if they do not
    //  cleanup in this amount of time.
    if (WAIT_TIMEOUT == ::WaitForSingleObject(g_hMCSThread, PROCESS_TERMINATE_TIME))
    {
        WARNING_OUT(("GCCControlSap::ReleaseInterface: Timed out waiting for MCS thread to exit. Apps did not cleanup in time."));
    }
    ::CloseHandle(g_hMCSThread);
    g_hMCSThread = NULL;

    //
    // LONCHANC: We should free control sap after exiting the GCC work thread
    // because the work thread may still use the control sap to flush messages.
    //
    Release();

    ::UnregisterClass(g_szGCCWndClassName, g_hDllInst);
}


/*
 *      CControlSAP()
 *
 *      Public Function Description
 *              This is the control sap constructor. It is responsible for
 *              registering control sap with the application interface via
 *              an owner callback.
 */
CControlSAP::CControlSAP ( void )
:
    CBaseSap(MAKE_STAMP_ID('C','S','a','p')),
    m_pfnNCCallback(NULL),
    m_pNCData(NULL),
    m_nJoinResponseTag(0),
    m_JoinResponseTagList2()
{
}

/*
 *      ~CControlSap()
 *
 *      Public Function Description
 *              This is the controller destructor.  It is responsible for
 *              flushing any pending upward bound messages and freeing all
 *              the resources tied up with pending messages.  Also it clears
 *              the message queue and queue of command targets that are registered
 *              with it.  Actually all command targets at this point should
 *              already have been unregistered but this is just a double check.
 */
CControlSAP::~CControlSAP ( void )
{
    //
    // No one should use this global pointer any more.
    //
    ASSERT(this == g_pControlSap);
    g_pControlSap = NULL;
}


void CControlSAP::PostCtrlSapMsg ( GCCCtrlSapMsgEx *pCtrlSapMsgEx )
{
    //
    // LONCHANC: GCC WorkThread may also get to here.
    // For instance, the following stack trace happen during exiting a conference.
    //      CControlSAP::AddToMessageQueue()
    //      CControlSAP::ConfDisconnectConfirm()
    //      CConf::DisconnectProviderIndication()
    //      CConf::Owner-Callback()
    //      MCSUser::FlushOutgoingPDU()
    //      CConf::FlushOutgoingPDU()
    //      GCCController::EventLoop()
    //      GCCControllerThread(void * 0x004f1bf0)
    //
    ASSERT(NULL != m_hwndNotify);
    if( 0 == ::PostMessage(m_hwndNotify,
                  CSAPMSG_BASE + (UINT) pCtrlSapMsgEx->Msg.message_type,
                  (WPARAM) pCtrlSapMsgEx,
                  (LPARAM) this) )
    {
        delete pCtrlSapMsgEx;
        pCtrlSapMsgEx = NULL;
    }
}


#if defined(GCCNC_DIRECT_INDICATION) || defined(GCCNC_DIRECT_CONFIRM)
void CControlSAP::SendCtrlSapMsg ( GCCCtrlSapMsg *pCtrlSapMsg )
{
    extern DWORD g_dwNCThreadID;
    ASSERT(g_dwNCThreadID == ::GetCurrentThreadId());

    if (NULL != m_pfnNCCallback)
    {
        pCtrlSapMsg->user_defined = m_pNCData;
        (*m_pfnNCCallback)(pCtrlSapMsg);
    }
}
#endif // GCCNC_DIRECT_INDICATION || GCCNC_DIRECT_CONFIRM


/*
 *      void RegisterNodeController()
 *
 *      Public Functional Description:
 *              This routine sets up the node controller callback structure which
 *              holds all the information needed by GCC to perform a node controller
 *              callback.  It also sets up the task switching window required to
 *              perform the context switch.
 */


/*
 *      void UnregisterNodeController()
 *
 *      Public Functional Description:
 */


/*
 *      ConfCreateRequest()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              create request from the node controller.  This function just passes this
 *              request to the controller via an owner callback.
 */
GCCError CControlSAP::ConfCreateRequest
(
    GCCConfCreateRequest       *pReq,
    GCCConfID                  *pnConfID
)
{
        GCCError                rc;
        CONF_CREATE_REQUEST             ccr;

        DebugEntry(CControlSAP::ConferenceCreateRequest);

    // initialize for cleanup
    ccr.convener_password = NULL;
    ccr.password = NULL;
    ccr.user_data_list = NULL;

    // copy security setting
    ccr.fSecure = pReq->fSecure;

    /*
        **      This section of the code performs all the necessary parameter
        **      checking.
        */
        
        //      Check for invalid conference name
        if (pReq->Core.conference_name != NULL)
        {
                /*
                **      Do not allow non-numeric or zero length strings to get
                **      past this point.
                */
                if (pReq->Core.conference_name->numeric_string != NULL)
                {
                        if (! IsNumericNameValid(pReq->Core.conference_name->numeric_string))
            {
                ERROR_OUT(("CControlSAP::ConfCreateRequest: invalid numeric name=%s", pReq->Core.conference_name->numeric_string));
                                rc = GCC_INVALID_CONFERENCE_NAME;
                goto MyExit;
            }
                }
                else
        {
            ERROR_OUT(("CControlSAP::ConfCreateRequest: null numeric string"));
                        rc = GCC_INVALID_CONFERENCE_NAME;
            goto MyExit;
        }

                if (pReq->Core.conference_name->text_string != NULL)
                {
                        if (! IsTextNameValid(pReq->Core.conference_name->text_string))
            {
                ERROR_OUT(("CControlSAP::ConfCreateRequest: invalid text name=%s", pReq->Core.conference_name->text_string));
                                rc = GCC_INVALID_CONFERENCE_NAME;
                goto MyExit;
            }
                }
        }
        else
    {
        ERROR_OUT(("CControlSAP::ConfCreateRequest: null conf name"));
                rc = GCC_INVALID_CONFERENCE_NAME;
        goto MyExit;
    }
        
        //      Check for valid conference modifier     
        if (pReq->Core.conference_modifier != NULL)
        {
                if (! IsNumericNameValid(pReq->Core.conference_modifier))
        {
            ERROR_OUT(("CControlSAP::ConfCreateRequest: invalid conf modifier=%s", pReq->Core.conference_modifier));
                        rc = GCC_INVALID_CONFERENCE_MODIFIER;
            goto MyExit;
        }
        }

        //      Check for valid convener password
        if (pReq->convener_password != NULL)
        {
                if (pReq->convener_password->numeric_string != NULL)
                {
                        if (! IsNumericNameValid(pReq->convener_password->numeric_string))
            {
                ERROR_OUT(("CControlSAP::ConfCreateRequest: invalid convener password=%s", pReq->convener_password->numeric_string));
                                rc = GCC_INVALID_PASSWORD;
                goto MyExit;
            }
                }
                else
        {
            ERROR_OUT(("CControlSAP::ConfCreateRequest: null convener password numeric string"));
                        rc = GCC_INVALID_PASSWORD;
            goto MyExit;
        }

            //  Construct the convener password container       
                DBG_SAVE_FILE_LINE
                ccr.convener_password = new CPassword(pReq->convener_password, &rc);
                if (ccr.convener_password == NULL || GCC_NO_ERROR != rc)
        {
            ERROR_OUT(("CControlSAP::ConfCreateRequest: can't create convener password"));
                        rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
        }
    }

        //      Check for valid password
        if (pReq->password != NULL)
        {
                if (pReq->password->numeric_string != NULL)
                {
                        if (! IsNumericNameValid(pReq->password->numeric_string))
            {
                ERROR_OUT(("CControlSAP::ConfCreateRequest: invalid password=%s", pReq->password->numeric_string));
                                rc = GCC_INVALID_PASSWORD;
                goto MyExit;
            }
                }
                else
        {
            ERROR_OUT(("CControlSAP::ConfCreateRequest: null password numeric string"));
                        rc = GCC_INVALID_PASSWORD;
            goto MyExit;
        }

        //      Construct the password container        
                DBG_SAVE_FILE_LINE
                ccr.password = new CPassword(pReq->password, &rc);
                if (ccr.password == NULL || GCC_NO_ERROR != rc)
        {
            ERROR_OUT(("CControlSAP::ConfCreateRequest: can't create password"));
                        rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
        }
    }

        if (pReq->Core.connection_handle == NULL)
    {
        ERROR_OUT(("CControlSAP::ConfCreateRequest: bad connection handle"));
                rc = GCC_BAD_CONNECTION_HANDLE_POINTER;
        goto MyExit;
    }

        /*
        **      If no errors occurred start building the general purpose containers
        **      to be passed on.
        */

    // copy the core component which has the same representation in both API and internal
    ccr.Core = pReq->Core;

        //      Construct the user data list container  
        if (pReq->number_of_user_data_members != 0)
        {
                DBG_SAVE_FILE_LINE
                ccr.user_data_list = new CUserDataListContainer(pReq->number_of_user_data_members, pReq->user_data_list, &rc);
                if (ccr.user_data_list == NULL || GCC_NO_ERROR != rc)
        {
            ERROR_OUT(("CControlSAP::ConfCreateRequest: can't create user data list container"));
                        rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
        }
        }

        //      Perform the owner callback
    ::EnterCriticalSection(&g_csGCCProvider);
        rc = g_pGCCController->ConfCreateRequest(&ccr, pnConfID);
    ::LeaveCriticalSection(&g_csGCCProvider);

MyExit:

        //      Free up all the containers

        //      Free up the convener password container
        if (ccr.convener_password != NULL)
    {
                ccr.convener_password->Release();
    }

        //      Free up the password container
        if (ccr.password != NULL)
        {
                ccr.password->Release();
        }

        //      Free up any memory used in callback
        if (ccr.user_data_list != NULL)
        {
                ccr.user_data_list->Release();
        }

        DebugExitINT(CControlSAP::ConferenceCreateRequest, rc);
        return rc;
}

/*
 *      ConfCreateResponse ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              create response from the node controller, to be sent to the provider
 *              that issued the conference create request. This function just passes
 *              this request to the controller via an owner callback.
 */
GCCError CControlSAP::ConfCreateResponse
(
        GCCNumericString                        conference_modifier,
        GCCConfID                               conference_id,
        BOOL                                            use_password_in_the_clear,
        PDomainParameters                       domain_parameters,
        UINT                                            number_of_network_addresses,
        PGCCNetworkAddress              *       local_network_address_list,
        UINT                                            number_of_user_data_members,
        PGCCUserData                    *       user_data_list,                         
        GCCResult                                       result
)
{
        GCCError                                        rc = GCC_NO_ERROR;
        ConfCreateResponseInfo          create_response_info;

        DebugEntry(CControlSAP::ConfCreateResponse);

        /*
        **      This section of the code performs all the necessary parameter
        **      checking.
        */

        //      Check for valid conference modifier     
        if (conference_modifier != NULL)
        {
                if (IsNumericNameValid(conference_modifier) == FALSE)
                {
                    ERROR_OUT(("CControlSAP::ConfCreateResponse: invalid conf modifier"));
                        rc = GCC_INVALID_CONFERENCE_MODIFIER;
                }
        }

        /*
        **      If no errors occurred fill in the info structure and pass it on to the
        **      owner object.
        */
        if (rc == GCC_NO_ERROR)
        {
                //      Construct the user data list    
                if (number_of_user_data_members != 0)
                {
                        DBG_SAVE_FILE_LINE
                        create_response_info.user_data_list = new CUserDataListContainer(
                                                                                number_of_user_data_members,
                                                                                user_data_list,
                                                                                &rc);
                        if (create_response_info.user_data_list == NULL)
                        {
                            ERROR_OUT(("CControlSAP::ConfCreateResponse: can't create CUserDataListContainer"));
                                rc = GCC_ALLOCATION_FAILURE;
                        }
                }
                else
                {
                        create_response_info.user_data_list = NULL;
                }

                if (rc == GCC_NO_ERROR)
                {
                        //      Fill in the conference create info structure and send it on
                        create_response_info.conference_modifier = conference_modifier;
                        create_response_info.conference_id = conference_id;
                        create_response_info.use_password_in_the_clear =
                                                                                                        use_password_in_the_clear;
                        create_response_info.domain_parameters = domain_parameters;
                        create_response_info.number_of_network_addresses =
                                                                                                        number_of_network_addresses;
                        create_response_info.network_address_list       =
                                                                                                        local_network_address_list;
                        create_response_info.result     = result;
                
                        //      Perform the owner callback
            ::EnterCriticalSection(&g_csGCCProvider);
                        rc = g_pGCCController->ConfCreateResponse(&create_response_info);
            ::LeaveCriticalSection(&g_csGCCProvider);
                }

                if (create_response_info.user_data_list != NULL)
                {
                        create_response_info.user_data_list->Release();
                }
        }

        DebugExitINT(CControlSAP::ConfCreateResponse, rc);
        return rc;
}

/*
 *      ConfQueryRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              query request from the node controller. This function just passes
 *              this request to the controller via an owner callback.
 */
GCCError CControlSAP::ConfQueryRequest
(
        GCCNodeType                                     node_type,
        PGCCAsymmetryIndicator          asymmetry_indicator,
        TransportAddress                        calling_address,
        TransportAddress                        called_address,
    BOOL                        fSecure,
        UINT                                            number_of_user_data_members,
        PGCCUserData                    *       user_data_list,
        PConnectionHandle                       connection_handle
)
{
        GCCError                                        rc = GCC_NO_ERROR;
        ConfQueryRequestInfo            conf_query_request_info;

        DebugEntry(CControlSAP::ConfQueryRequest);

        //      Check for an invalid called address.
        if (called_address == NULL)
        {
            ERROR_OUT(("CControlSAP::ConfQueryRequest: invalid transport"));
                rc = GCC_INVALID_TRANSPORT;
        }

        //      Check for an invalid connection handle.
        if (connection_handle == NULL)
        {
            ERROR_OUT(("CControlSAP::ConfQueryRequest: null connection handle"));
                rc = GCC_BAD_CONNECTION_HANDLE_POINTER;
        }

        //      Check for a valid node type.
        if ((node_type != GCC_TERMINAL) &&
                (node_type != GCC_MULTIPORT_TERMINAL) &&
                (node_type != GCC_MCU))
        {
            ERROR_OUT(("CControlSAP::ConfQueryRequest: invalid node type=%u", (UINT) node_type));
                rc = GCC_INVALID_NODE_TYPE;
        }

        //      Check for an invalid asymmetry indicator.
        if (asymmetry_indicator != NULL)
        {
                if ((asymmetry_indicator->asymmetry_type != GCC_ASYMMETRY_CALLER) &&
                        (asymmetry_indicator->asymmetry_type != GCC_ASYMMETRY_CALLED) &&
                        (asymmetry_indicator->asymmetry_type != GCC_ASYMMETRY_UNKNOWN))
                {
                    ERROR_OUT(("CControlSAP::ConfQueryRequest: invalid asymmetry indicator=%u", (UINT) asymmetry_indicator->asymmetry_type));
                        rc = GCC_INVALID_ASYMMETRY_INDICATOR;
                }
        }

        //      Create user data container if necessary.
        if ((number_of_user_data_members != 0) &&
                (rc == GCC_NO_ERROR))
        {
                DBG_SAVE_FILE_LINE
                conf_query_request_info.user_data_list = new CUserDataListContainer (   
                                                                                                        number_of_user_data_members,
                                                                                                        user_data_list,
                                                                                                        &rc);
                if (conf_query_request_info.user_data_list == NULL)
                {
                    ERROR_OUT(("CControlSAP::ConfQueryRequest: can't create CUserDataListContainer"));
                        rc = GCC_ALLOCATION_FAILURE;
                }
        }
        else
        {
                conf_query_request_info.user_data_list = NULL;
        }

        // Call back the controller to send the response.
        if (rc == GCC_NO_ERROR)
        {
                conf_query_request_info.node_type = node_type;
                conf_query_request_info.asymmetry_indicator = asymmetry_indicator;
        
                conf_query_request_info.calling_address = calling_address;
                conf_query_request_info.called_address = called_address;
        
                conf_query_request_info.connection_handle = connection_handle;
                conf_query_request_info.fSecure = fSecure;

        ::EnterCriticalSection(&g_csGCCProvider);
                rc = g_pGCCController->ConfQueryRequest(&conf_query_request_info);
        ::LeaveCriticalSection(&g_csGCCProvider);
        }

        if (conf_query_request_info.user_data_list != NULL)
        {
                conf_query_request_info.user_data_list->Release();
        }

        DebugExitINT(CControlSAP::ConfQueryRequest, rc);
        return rc;
}


void CControlSAP::CancelConfQueryRequest ( ConnectionHandle hQueryReqConn )
{
    DebugEntry(CControlSAP::CancelConfQueryRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
    g_pGCCController->CancelConfQueryRequest(hQueryReqConn);
    ::LeaveCriticalSection(&g_csGCCProvider);

    DebugExitVOID(CControlSAP::CancelConfQueryRequest);
}

/*
 *      ConfQueryResponse ()
 *
 *      Public Function Description
 *              This function is called by the DLL interface when it gets a conference
 *              query response from the node controller.  This function just passes
 *              this response to the controller via an owner callback.
 */
GCCError CControlSAP::ConfQueryResponse
(
        GCCResponseTag                          query_response_tag,
        GCCNodeType                                     node_type,
        PGCCAsymmetryIndicator          asymmetry_indicator,
        UINT                                            number_of_user_data_members,
        PGCCUserData                    *       user_data_list,
        GCCResult                                       result
)
{
        GCCError                                        rc = GCC_NO_ERROR;
        ConfQueryResponseInfo           conf_query_response_info;

        DebugEntry(CControlSAP::ConfQueryResponse);

        //      Check for a valid node type.
        if ((node_type != GCC_TERMINAL) &&
                (node_type != GCC_MULTIPORT_TERMINAL) &&
                (node_type != GCC_MCU))
        {
            ERROR_OUT(("CControlSAP::ConfQueryResponse: invalid node type=%u", (UINT) node_type));
                rc = GCC_INVALID_NODE_TYPE;
        }

        //      Check for an invalid asymmetry indicator.
        if (asymmetry_indicator != NULL)
        {
                if ((asymmetry_indicator->asymmetry_type != GCC_ASYMMETRY_CALLER) &&
                        (asymmetry_indicator->asymmetry_type != GCC_ASYMMETRY_CALLED) &&
                        (asymmetry_indicator->asymmetry_type != GCC_ASYMMETRY_UNKNOWN))
                {
                    ERROR_OUT(("CControlSAP::ConfQueryResponse: invalid asymmetry indicator=%u", (UINT) asymmetry_indicator->asymmetry_type));
                        rc = GCC_INVALID_ASYMMETRY_INDICATOR;
                }
        }

        //      Create user data container if necessary.
        if ((number_of_user_data_members != 0) &&
                (rc == GCC_NO_ERROR))
        {
                DBG_SAVE_FILE_LINE
                conf_query_response_info.user_data_list = new CUserDataListContainer(
                                                                                                        number_of_user_data_members,
                                                                                                        user_data_list,
                                                                                                        &rc);
                if (conf_query_response_info.user_data_list == NULL)
                {
                    ERROR_OUT(("CControlSAP::ConfQueryResponse: can't create CUserDataListContainer"));
                        rc = GCC_ALLOCATION_FAILURE;
                }
        }
        else
        {
                conf_query_response_info.user_data_list = NULL;
        }

        //      Call back the controller to send the response.
        if (rc == GCC_NO_ERROR)
        {
                conf_query_response_info.query_response_tag = query_response_tag;
                conf_query_response_info.node_type = node_type;
                conf_query_response_info.asymmetry_indicator = asymmetry_indicator;
                conf_query_response_info.result = result;
        
        ::EnterCriticalSection(&g_csGCCProvider);
                rc = g_pGCCController->ConfQueryResponse(&conf_query_response_info);
        ::LeaveCriticalSection(&g_csGCCProvider);
        }

        //      Free the data associated with the user data container.
        if (conf_query_response_info.user_data_list != NULL)
        {
                conf_query_response_info.user_data_list->Release();
        }

        DebugExitINT(CControlSAP::ConfQueryResponse, rc);
        return rc;
}

/*
 *      AnnouncePresenceRequest()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets an announce
 *              presence request from the node controller.  This function passes this
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that control sap maintains. The ConferenceID
 *              passed in is used to index the list of command targets to get the
 *              correct conference.
 */
GCCError CControlSAP::AnnouncePresenceRequest
(
        GCCConfID                               conference_id,
        GCCNodeType                                     node_type,
        GCCNodeProperties                       node_properties,
        LPWSTR                                          pwszNodeName,
        UINT                                            number_of_participants,
        LPWSTR                                  *       participant_name_list,
        LPWSTR                                          pwszSiteInfo,
        UINT                                            number_of_network_addresses,
        PGCCNetworkAddress              *       network_address_list,
        LPOSTR                      alternative_node_id,
        UINT                                            number_of_user_data_members,
        PGCCUserData                    *       user_data_list
)
{
        GCCError                                rc = GCC_NO_ERROR;
        GCCNodeRecord                   node_record;

        DebugEntry(CControlSAP::AnnouncePresenceRequest);

        //      Check for a valid node type
        if ((node_type != GCC_TERMINAL) &&
                (node_type != GCC_MULTIPORT_TERMINAL) &&
                (node_type != GCC_MCU))
        {
            ERROR_OUT(("CControlSAP::AnnouncePresenceRequest: invalid node type=%u", node_type));
                rc = GCC_INVALID_NODE_TYPE;
        }
        
        //      Check for valid node properties.
        if ((node_properties != GCC_PERIPHERAL_DEVICE) &&
                (node_properties != GCC_MANAGEMENT_DEVICE) &&
                (node_properties != GCC_PERIPHERAL_AND_MANAGEMENT_DEVICE) &&
                (node_properties != GCC_NEITHER_PERIPHERAL_NOR_MANAGEMENT))
        {
            ERROR_OUT(("CControlSAP::AnnouncePresenceRequest: invalid node properties=%u", node_properties));
                rc = GCC_INVALID_NODE_PROPERTIES;
        }

        // Check to make sure the conference exists.
        if (rc == GCC_NO_ERROR)
        {
                CConf *pConf;

        ::EnterCriticalSection(&g_csGCCProvider);
                if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
                {
                        //      Fill in the node record and pass it on.
                        node_record.node_type = node_type;
                        node_record.node_properties = node_properties;
                        node_record.node_name = pwszNodeName;
                        node_record.number_of_participants = (USHORT)number_of_participants;
                        node_record.participant_name_list = participant_name_list;
                        node_record.site_information = pwszSiteInfo;
                        node_record.number_of_network_addresses = number_of_network_addresses;
                        node_record.network_address_list = network_address_list;
                        node_record.alternative_node_id = alternative_node_id;
                        node_record.number_of_user_data_members = (USHORT)number_of_user_data_members;
                        node_record.user_data_list = user_data_list;

                        //      Pass the record on to the conference object.
                        rc = pConf->ConfAnnouncePresenceRequest(&node_record);
                }
                else
                {
                    TRACE_OUT(("CControlSAP::AnnouncePresenceRequest: invalid conference ID=%u", (UINT) conference_id));
                        rc = GCC_INVALID_CONFERENCE;
                }
        ::LeaveCriticalSection(&g_csGCCProvider);
        }

        DebugExitINT(CControlSAP::AnnouncePresenceRequest, rc);
        return rc;
}


/*
 *      ConfDisconnectRequest()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              disconnect request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
GCCError CControlSAP::ConfDisconnectRequest ( GCCConfID conference_id )
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfDisconnectRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                //      Pass the disconnect on to the conference object.
                rc = pConf->ConfDisconnectRequest();
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfDisconnectRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfDisconnectRequest, rc);
        return rc;
}

/*
 *      ConfTerminateRequest()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              terminate request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConfTerminateRequest
(
        GCCConfID                               conference_id,
        GCCReason                                       reason
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfTerminateRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                //      Pass the disconnect on to the conference object
                rc = pConf->ConfTerminateRequest(reason);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfTerminateRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfTerminateRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfEjectUserRequest()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              eject user request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
GCCError CControlSAP::ConfEjectUserRequest
(
        GCCConfID                               conference_id,
        UserID                                          ejected_node_id,
        GCCReason                                       reason
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfEjectUserRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (ejected_node_id < MINIMUM_USER_ID_VALUE)
        {
            ERROR_OUT(("CControlSAP::ConfEjectUserRequest: invalid mcs user ID=%u", (UINT) ejected_node_id));
                rc = GCC_INVALID_MCS_USER_ID;
        }
        else
        // Check to make sure the conference exists.
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                //      Pass the command on to the conference object
                rc = pConf->ConfEjectUserRequest(ejected_node_id, reason);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfEjectUserRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfEjectUserRequest, rc);
        return rc;
}

/*
 *      ConfJoinRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              join request from the node controller, to be sent to the top provider
 *              either directly or through a directly connected intermediate provider.
 *          This function just passes this request to the controller via an owner
 *              callback.
 */
GCCError CControlSAP::ConfJoinRequest
(
        PGCCConferenceName                              conference_name,
        GCCNumericString                                called_node_modifier,
        GCCNumericString                                calling_node_modifier,
        PGCCPassword                                    convener_password,
        PGCCChallengeRequestResponse    password_challenge,
        LPWSTR                                                  pwszCallerID,
        TransportAddress                                calling_address,
        TransportAddress                                called_address,
        BOOL                                                    fSecure,
        PDomainParameters                               domain_parameters,
        UINT                                                    number_of_network_addresses,
        PGCCNetworkAddress                      *       local_network_address_list,
        UINT                                                    number_of_user_data_members,
        PGCCUserData                            *       user_data_list,
        PConnectionHandle                               connection_handle,
        GCCConfID                   *   pnConfID
)
{
        GCCError                                rc = GCC_NO_ERROR;
        ConfJoinRequestInfo             join_request_info;

        DebugEntry(CControlSAP::ConfJoinRequest);

        //      Check for invalid conference name
        if (conference_name != NULL)
        {
                /*
                **      Check to make sure a valid conference name exists.
                */
                if ((conference_name->numeric_string == NULL) &&
                                (conference_name->text_string == NULL))
                {
                    ERROR_OUT(("CControlSAP::ConfJoinRequest: invalid conference name (1)"));
                        rc = GCC_INVALID_CONFERENCE_NAME;
                }
                /*
                **      If both numeric and text versions of the conference name exist,
                **      make sure they are both valid.
                */
                else if ((conference_name->numeric_string != NULL) &&
                                (conference_name->text_string != NULL))
                {
                        if ((IsNumericNameValid(conference_name->numeric_string) == FALSE)
                                        || (IsTextNameValid(conference_name->text_string) == FALSE))
                        {
                    ERROR_OUT(("CControlSAP::ConfJoinRequest: invalid conference name (2)"));
                                rc = GCC_INVALID_CONFERENCE_NAME;
                        }
                }
                /*
                **      If only a numeric version of the conference name is provided, check
                **      to make sure it is valid.
                */
                else if (conference_name->numeric_string != NULL)
                {
                        if (IsNumericNameValid(conference_name->numeric_string) == FALSE)
                        {
                            ERROR_OUT(("CControlSAP::ConfJoinRequest: invalid conference name (3)"));
                                rc = GCC_INVALID_CONFERENCE_NAME;
                        }
                }
                /*
                **      If only a text version of the conference name is provided, check to
                **      make sure it is valid.
                */
                else
                {
                        if (IsTextNameValid(conference_name->text_string) == FALSE)
                        {
                    ERROR_OUT(("CControlSAP::ConfJoinRequest: invalid conference name (4)"));
                                rc = GCC_INVALID_CONFERENCE_NAME;
                        }
                }
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfJoinRequest: invalid conference name (5)"));
                rc = GCC_INVALID_CONFERENCE_NAME;
        }

        //      Check for valid called_node_modifier.
        if (called_node_modifier != NULL)
        {
                if (IsNumericNameValid(called_node_modifier) == FALSE)
                {
            ERROR_OUT(("CControlSAP::ConfJoinRequest: invalid called node modifier"));
                        rc = GCC_INVALID_CONFERENCE_MODIFIER;
                }
        }

        //      Check for valid calling_node_modifier   
        if (calling_node_modifier != NULL)
        {
                if (IsNumericNameValid(calling_node_modifier) == FALSE)
                {
            ERROR_OUT(("CControlSAP::ConfJoinRequest: invalid calling node modifier"));
                        rc = GCC_INVALID_CONFERENCE_MODIFIER;
                }
        }

        //      Check for valid convener password
        if (convener_password != NULL)
        {
                if (convener_password->numeric_string != NULL)
                {
                        if (IsNumericNameValid(convener_password->numeric_string) == FALSE)
            {
                    ERROR_OUT(("CControlSAP::ConfJoinRequest: invalid convener password"));
                                rc = GCC_INVALID_PASSWORD;
            }
                }
                else
        {
            ERROR_OUT(("CControlSAP::ConfJoinRequest: null convener password"));
                        rc = GCC_INVALID_PASSWORD;
        }
        }

        if (connection_handle == NULL)
    {
        ERROR_OUT(("CControlSAP::ConfJoinRequest: null connection handle"));
                rc = GCC_BAD_CONNECTION_HANDLE_POINTER;
    }

        if (called_address == NULL)
    {
        ERROR_OUT(("CControlSAP::ConfJoinRequest: null transport address"));
                rc = GCC_INVALID_TRANSPORT_ADDRESS;
    }

        /*
        **      If no errors occurred start building the general purpose containers
        **      to be passed on.
        */
        if (rc == GCC_NO_ERROR)
        {
                //      Construct a convener password container
                if (convener_password != NULL)
                {
                        DBG_SAVE_FILE_LINE
                        join_request_info.convener_password = new CPassword(convener_password, &rc);
                        if (join_request_info.convener_password == NULL)
            {
                ERROR_OUT(("CControlSAP::ConfJoinRequest: can't create CPassword (1)"));
                                rc = GCC_ALLOCATION_FAILURE;
            }
                }
                else
        {
                        join_request_info.convener_password = NULL;
        }

                //      Construct a password challenge container
                if ((password_challenge != NULL) &&     (rc == GCC_NO_ERROR))
                {
                        DBG_SAVE_FILE_LINE
                        join_request_info.password_challenge = new CPassword(password_challenge, &rc);
                        if (join_request_info.password_challenge == NULL)
            {
                ERROR_OUT(("CControlSAP::ConfJoinRequest: can't create CPassword (2)"));
                                rc = GCC_ALLOCATION_FAILURE;
            }
                }
                else
        {
                        join_request_info.password_challenge = NULL;
        }

                //      Construct the user data list    
                if ((number_of_user_data_members != 0) &&
                        (rc == GCC_NO_ERROR))
                {
                        DBG_SAVE_FILE_LINE
                        join_request_info.user_data_list = new CUserDataListContainer(
                                                                                number_of_user_data_members,
                                                                                user_data_list,
                                                                                &rc);
                                                                                
                        if (join_request_info.user_data_list == NULL)
                        {
                ERROR_OUT(("CControlSAP::ConfJoinRequest: can't create CUserDataListContainer"));
                                rc = GCC_ALLOCATION_FAILURE;
                        }
                }
                else
                {
                        join_request_info.user_data_list = NULL;
                }

                /*
                **      If all the containers were successfully created go ahead and
                **      fill in the rest of the create request info structure and pass
                **      it on to the owner object.
                */
                if (rc == GCC_NO_ERROR)
                {
                        join_request_info.conference_name = conference_name;
                        join_request_info.called_node_modifier = called_node_modifier;
                        join_request_info.calling_node_modifier =calling_node_modifier;
                        join_request_info.pwszCallerID = pwszCallerID;
                        join_request_info.calling_address = calling_address;
                        join_request_info.called_address = called_address;
                        join_request_info.fSecure = fSecure;
                        join_request_info.domain_parameters = domain_parameters;
                        join_request_info.number_of_network_addresses = number_of_network_addresses;
                        join_request_info.local_network_address_list = local_network_address_list;

                        join_request_info.connection_handle = connection_handle;

            ::EnterCriticalSection(&g_csGCCProvider);
                        rc = g_pGCCController->ConfJoinRequest(&join_request_info, pnConfID);
            ::LeaveCriticalSection(&g_csGCCProvider);
                }

                //      Free up all the containers

                //      Free up the convener password container
                if (join_request_info.convener_password != NULL)
                {
                        join_request_info.convener_password->Release();
                }

                //      Free up the password container
                if (join_request_info.password_challenge != NULL)
                {
                        join_request_info.password_challenge->Release();
                }

                //      Free up any memory used in callback
                if (join_request_info.user_data_list != NULL)
                {
                        join_request_info.user_data_list->Release();
                }
        }

        DebugExitINT(CControlSAP::ConfJoinRequest, rc);
        return rc;
}

/*
 *      ConfJoinResponse ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              join response from the node controller.  This routine is responsible
 *              for routing the response to either the conference that made the
 *              request or the controller.  Responses which are routed to a conference
 *              are associated with requests that originate at a subnode that is a
 *              node removed from the Top Provider.
 */
GCCError CControlSAP::ConfJoinResponse
(
        GCCResponseTag                                  join_response_tag,
        PGCCChallengeRequestResponse    password_challenge,
        UINT                                                    number_of_user_data_members,
        PGCCUserData                            *       user_data_list,
        GCCResult                                               result
)
{
        GCCError                                rc = GCC_NO_ERROR;
        PJoinResponseStructure  join_info;
        CPassword               *password_challenge_container = NULL;
        CUserDataListContainer  *user_data_container = NULL;

        DebugEntry(CControlSAP::ConfJoinResponse);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (join_info = m_JoinResponseTagList2.Find(join_response_tag)))
        {
                /*
                **      First create the data containers used in the join response.
                */

                //      Set up the password challenge container
                if (password_challenge != NULL)
                {
                        DBG_SAVE_FILE_LINE
                        password_challenge_container = new CPassword(password_challenge, &rc);
                        if (password_challenge_container == NULL)
            {
                ERROR_OUT(("CControlSAP::ConfJoinResponse: can't create CPassword"));
                                rc = GCC_ALLOCATION_FAILURE;
            }
                }

                //      Set up the user data list container
                if ((number_of_user_data_members != 0) && (rc == GCC_NO_ERROR))
                {
                        DBG_SAVE_FILE_LINE
                        user_data_container = new CUserDataListContainer(number_of_user_data_members, user_data_list, &rc);
                        if (user_data_container == NULL)
            {
                ERROR_OUT(("CControlSAP::ConfJoinResponse: can't create CUserDataListContainer"));
                                rc = GCC_ALLOCATION_FAILURE;
            }
                }

                if (rc == GCC_NO_ERROR)
                {
                        if (join_info->command_target_call == FALSE)
                        {
                ConfJoinResponseInfo    join_response_info;
                                /*
                                **      Since the request originated from the Owner Object the
                                **      response gets routed to the Owner Object.
                                */
                                join_response_info.password_challenge =
                                                                                                password_challenge_container;
                                join_response_info.conference_id = join_info->conference_id;
                                join_response_info.connection_handle =
                                                                                                join_info->connection_handle;
                                join_response_info.user_data_list = user_data_container;
                                join_response_info.result = result;

                                rc = g_pGCCController->ConfJoinIndResponse(&join_response_info);
                        }
                        else
                        {
                            CConf *pConf;
                                /*
                                **      If the conference is terminated before the conference join
                                **      is responded to, a GCC_INVALID_CONFERENCE errror will occur.
                                */
                                if (NULL != (pConf = g_pGCCController->GetConfObject(join_info->conference_id)))
                                {
                                        rc = pConf->ConfJoinReqResponse(
                                                                                        join_info->user_id,
                                                                                        password_challenge_container,
                                                                                        user_data_container,
                                                                                        result);
                                }
                                else
                                {
                    WARNING_OUT(("CControlSAP::ConfJoinResponse: invalid conference ID=%u", (UINT) join_info->conference_id));
                                        rc = GCC_INVALID_CONFERENCE;

                                        //      If this error occurs go ahead and cleanup up
                                        m_JoinResponseTagList2.Remove(join_response_tag);
                                        delete join_info;
                                }
                        }
                }

                /*
                **      Remove the join information structure from the join response list
                **      if no error is returned.
                */
                if (rc == GCC_NO_ERROR)
                {
                        m_JoinResponseTagList2.Remove(join_response_tag);
                        delete join_info;
                }

                //      Free up all the containers

                //      Free up the password challenge container
                if (password_challenge_container != NULL)
                {
                        password_challenge_container->Release();
                }

                //      Free up any memory used in callback
                if (user_data_container != NULL)
                {
                        user_data_container->Release();
                }
        }
        else
        {
                rc = GCC_INVALID_JOIN_RESPONSE_TAG;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfJoinResponse, rc);
        return rc;
}

/*
 *      ConfInviteRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              invite request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
GCCError CControlSAP::ConfInviteRequest
(
        GCCConfID                       conference_id,
        LPWSTR                                  pwszCallerID,
        TransportAddress                calling_address,
        TransportAddress                called_address,
        BOOL                                    fSecure,
        UINT                                    number_of_user_data_members,
        PGCCUserData            *       user_data_list,
        PConnectionHandle               connection_handle
)
{
        GCCError                        rc = GCC_NO_ERROR;
        CUserDataListContainer *user_data_list_ptr = NULL;

        DebugEntry(CControlSAP::ConfInviteRequest);

        if (called_address == NULL)
        {
            ERROR_OUT(("CControlSAP::ConfInviteRequest: null called address"));
                rc = GCC_INVALID_TRANSPORT_ADDRESS;
        }

        if (connection_handle == NULL)
        {
            ERROR_OUT(("CControlSAP::ConfInviteRequest: null connection handle"));
                rc = GCC_BAD_CONNECTION_HANDLE_POINTER;
        }

        if (rc == GCC_NO_ERROR)
        {
            CConf *pConf;

        ::EnterCriticalSection(&g_csGCCProvider);
                // Check to make sure the conference exists.
                if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
                {
                        //      Construct the user data list container  
                        if (number_of_user_data_members != 0)
                        {
                                DBG_SAVE_FILE_LINE
                                user_data_list_ptr = new CUserDataListContainer(number_of_user_data_members, user_data_list, &rc);
                                if (user_data_list_ptr == NULL)
                {
                    ERROR_OUT(("CControlSAP::ConfInviteRequest: can't create CUserDataListContainer"));
                                        rc = GCC_ALLOCATION_FAILURE;
                }
                        }

                        //      Send the request on to the conference object.
                        if (rc == GCC_NO_ERROR)
                        {
                                rc = pConf->ConfInviteRequest(pwszCallerID,
                                                                                                calling_address,
                                                                                                called_address,
                                                                                                fSecure,
                                                                                                user_data_list_ptr,
                                                                                                connection_handle);
                        }

                        //      Free up any memory used in callback
                        if (user_data_list_ptr != NULL)
                        {
                                user_data_list_ptr->Release();
                        }
                }
                else
                {
                        rc = GCC_INVALID_CONFERENCE;
                }
        ::LeaveCriticalSection(&g_csGCCProvider);
        }

        DebugExitINT(CControlSAP::ConfInviteRequest, rc);
        return rc;
}


void CControlSAP::CancelInviteRequest
(
    GCCConfID           nConfID,
    ConnectionHandle    hInviteReqConn
)
{
    CConf      *pConf;
    DebugEntry(CControlSAP::CancelInviteRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
    // Check to make sure the conference exists.
    if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
    {
        pConf->CancelInviteRequest(hInviteReqConn);
    }
    ::LeaveCriticalSection(&g_csGCCProvider);

    DebugExitVOID(CControlSAP::CancelInviteRequest);
}



GCCError CControlSAP::GetParentNodeID
(
    GCCConfID           nConfID,
    GCCNodeID          *pnidParent
)
{
    GCCError    rc = T120_INVALID_PARAMETER;
    CConf      *pConf;
    DebugEntry(CControlSAP::GetParentNodeID);

    if (NULL != pnidParent)
    {
        ::EnterCriticalSection(&g_csGCCProvider);
        // Check to make sure the conference exists.
        if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
        {
            *pnidParent = pConf->GetParentNodeID();
            rc = GCC_NO_ERROR;
        }
        ::LeaveCriticalSection(&g_csGCCProvider);
    }

    DebugExitINT(CControlSAP::GetParentNodeID, rc);
    return rc;
}


/*
 *      ConfInviteResponse ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              invite response from the node controller.  This function passes the
 *              response on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
GCCError CControlSAP::ConfInviteResponse
(
        GCCConfID                       conference_id,
        GCCNumericString                conference_modifier,
        BOOL                                    fSecure,
        PDomainParameters               domain_parameters,
        UINT                                    number_of_network_addresses,
        PGCCNetworkAddress      *       local_network_address_list,
        UINT                                    number_of_user_data_members,
        PGCCUserData            *       user_data_list,
        GCCResult                               result
)
{
        GCCError                                        rc = GCC_NO_ERROR;
        ConfInviteResponseInfo          invite_response_info;

        DebugEntry(CControlSAP::ConfInviteResponse);

        //      Check for invalid conference name
        if (conference_modifier != NULL)
        {
                if (IsNumericNameValid(conference_modifier) == FALSE)
                {
                    ERROR_OUT(("CControlSAP::ConfInviteResponse: invalid conference modifier"));
                        rc = GCC_INVALID_CONFERENCE_MODIFIER;
                }
        }

        /*
        **      If no errors occurred fill in the info structure and pass it on to the
        **      owner object.
        */
        if (rc == GCC_NO_ERROR)
        {
                //      Construct the user data list    
                if (number_of_user_data_members != 0)
                {
                        DBG_SAVE_FILE_LINE
                        invite_response_info.user_data_list = new CUserDataListContainer(number_of_user_data_members, user_data_list, &rc);
                        if (invite_response_info.user_data_list == NULL)
            {
                ERROR_OUT(("CControlSAP::ConfInviteResponse: can't create CUserDataListContainer"));
                                rc = GCC_ALLOCATION_FAILURE;
            }
                }
                else
        {
                        invite_response_info.user_data_list = NULL;
        }

                if (rc == GCC_NO_ERROR)
                {
                        invite_response_info.conference_id = conference_id;
                        invite_response_info.conference_modifier = conference_modifier;
                        invite_response_info.fSecure = fSecure;
                        invite_response_info.domain_parameters = domain_parameters;
                        
                        invite_response_info.number_of_network_addresses =
                                                                                                        number_of_network_addresses;
                        invite_response_info.local_network_address_list =
                                                                                                        local_network_address_list;
                        invite_response_info.result = result;

                        //      Call back the controller to issue invite response.
            ::EnterCriticalSection(&g_csGCCProvider);
                        rc = g_pGCCController->ConfInviteResponse(&invite_response_info);
            ::LeaveCriticalSection(&g_csGCCProvider);
                }

                //      Free up the data associated with the user data container.
                if (invite_response_info.user_data_list != NULL)
                {
                        invite_response_info.user_data_list->Release();
                }
        }

        DebugExitINT(CControlSAP::ConfInviteResponse, rc);
        return rc;
}

/*
 *      ConfLockRequest ()
 *
 *      Public Function Description:
 *              This function is called by the interface when it gets a conference
 *              lock request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConfLockRequest ( GCCConfID conference_id )
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfLockRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConfLockRequest();
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfInviteResponse: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfLockRequest, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConfLockResponse ()
 *
 *      Public Function Description:
 *              This function is called by the interface when it gets a conference
 *              lock response from the node controller.  This function passes the
 *              response on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
GCCError CControlSAP::ConfLockResponse
(
        GCCConfID                                       conference_id,
        UserID                                                  requesting_node,
        GCCResult                                               result
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfLockResponse);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConfLockResponse(requesting_node, result);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfLockResponse: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfLockResponse, rc);
        return rc;
}

/*
 *      ConfUnlockRequest ()
 *
 *      Public Function Description:
 *              This function is called by the interface when it gets a conference
 *              unlock request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConfUnlockRequest ( GCCConfID conference_id )
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfUnlockRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConfUnlockRequest();
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfUnlockRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfUnlockRequest, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConfUnlockResponse ()
 *
 *      Public Function Description:
 *              This function is called by the interface when it gets a conference
 *              unlock response from the node controller.  This function passes the
 *              response on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConfUnlockResponse
(
        GCCConfID                                       conference_id,
        UserID                                                  requesting_node,
        GCCResult                                               result
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfUnlockResponse);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConfUnlockResponse(requesting_node, result);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfUnlockResponse: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfUnlockResponse, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConductorAssignRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conductor
 *              assign request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorAssignRequest ( GCCConfID conference_id )
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConductorAssignRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConductorAssignRequest();
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConductorAssignRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
    }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConductorAssignRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorReleaseRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conductor
 *              release request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorReleaseRequest ( GCCConfID conference_id )
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConductorReleaseRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConductorReleaseRequest();
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConductorReleaseRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConductorReleaseRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorPleaseRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conductor
 *              please request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorPleaseRequest ( GCCConfID conference_id )
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConductorPleaseRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConductorPleaseRequest();
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConductorPleaseRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConductorPleaseRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorGiveRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conductor
 *              give request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorGiveRequest
(
        GCCConfID                       conference_id,
        UserID                                  recipient_user_id
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConductorGiveRequest);

        // Make sure the ID of the conductorship recipient is valid.
        if (recipient_user_id < MINIMUM_USER_ID_VALUE)
                return (GCC_INVALID_MCS_USER_ID);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConductorGiveRequest (recipient_user_id);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConductorGiveRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConductorGiveRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorGiveResponse ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conductor
 *              give response from the node controller.  This function passes the
 *              response on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
GCCError CControlSAP::ConductorGiveResponse
(
        GCCConfID                       conference_id,
        GCCResult                               result
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConductorGiveResponse);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConductorGiveResponse (result);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConductorGiveResponse: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConductorGiveResponse, rc);
        return rc;
}

/*
 *      ConductorPermitGrantRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conductor
 *              permit grant request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorPermitGrantRequest
(
        GCCConfID                       conference_id,
        UINT                                    number_granted,
        PUserID                                 granted_node_list,
        UINT                                    number_waiting,
        PUserID                                 waiting_node_list
)
{
        GCCError    rc;
        CConf       *pConf;
        UINT        i;

        DebugEntry(CControlSAP::ConductorPermitGrantRequest);

    ::EnterCriticalSection(&g_csGCCProvider);

        // Check to make sure the conference exists.
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                /*
                **      Run through both lists to make sure that valid MCS User IDs
                **      are used.
                */
                for (i = 0; i < number_granted; i++)
                {
                        if (granted_node_list[i] < MINIMUM_USER_ID_VALUE)
                        {
                            ERROR_OUT(("CControlSAP::ConductorPermitGrantRequest: invalid granted user ID"));
                                rc = GCC_INVALID_MCS_USER_ID;
                                goto MyExit;
                        }
                }

                for (i = 0; i < number_waiting; i++)
                {
                        if (waiting_node_list[i] < MINIMUM_USER_ID_VALUE)
                        {
                            ERROR_OUT(("CControlSAP::ConductorPermitGrantRequest: invalid waiting user ID"));
                                rc = GCC_INVALID_MCS_USER_ID;
                                goto MyExit;
                        }
                }

                rc = pConf->ConductorPermitGrantRequest(number_granted,
                                                                                                granted_node_list,
                                                                                                number_waiting,
                                                                                                waiting_node_list);
        }
        else
        {
                rc = GCC_INVALID_CONFERENCE;
        }

MyExit:

    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConductorPermitGrantRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorPermitAskRequest()
 *
 *      Public Function Description
 *              This routine is called in order to ask for certain permissions to be
 *              granted (or not granted) by the conductor.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorPermitAskRequest
(
    GCCConfID           nConfID,
    BOOL                fGrantPermission
)
{
    GCCError    rc;
    CConf       *pConf;

    DebugEntry(CControlSAP::ConductorPermitAskRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
        {
                rc = pConf->ConductorPermitAskRequest(fGrantPermission);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConductorPermitAskRequest: invalid conference ID=%u", (UINT) nConfID));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

    DebugExitINT(CControlSAP::ConductorPermitAskRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfTimeRemainingRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference time
 *              remaining request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
GCCError CControlSAP::ConfTimeRemainingRequest
(
        GCCConfID                       conference_id,
        UINT                                    time_remaining,
        UserID                                  node_id
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfTimeRemainingRequest);

    ::EnterCriticalSection(&g_csGCCProvider);

        // Check to make sure the node ID is valid and the conference exists.
        if ((node_id < MINIMUM_USER_ID_VALUE) && (node_id != 0))
        {
            ERROR_OUT(("CControlSAP::ConfTimeRemainingRequest: invalid node ID"));
                rc = GCC_INVALID_MCS_USER_ID;
        }
        else
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConferenceTimeRemainingRequest(time_remaining, node_id);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfTimeRemainingRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }

    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfTimeRemainingRequest, rc);
        return rc;
}

/*
 *      ConfTimeInquireRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference time
 *              inquire request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConfTimeInquireRequest
(
        GCCConfID                       conference_id,
        BOOL                                    time_is_conference_wide
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfTimeInquireRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConfTimeInquireRequest(time_is_conference_wide);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfTimeInquireRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfTimeInquireRequest, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConfExtendRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              extend request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConfExtendRequest
(
        GCCConfID                                       conference_id,
        UINT                                                    extension_time,
        BOOL                                                    time_is_conference_wide
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfExtendRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConfExtendRequest(extension_time, time_is_conference_wide);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfExtendRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfExtendRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfAssistanceRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              assistance request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConfAssistanceRequest
(
        GCCConfID                       conference_id,
        UINT                                    number_of_user_data_members,
        PGCCUserData    *               user_data_list
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfAssistanceRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConfAssistanceRequest(number_of_user_data_members, user_data_list);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfAssistanceRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfAssistanceRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      TextMessageRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a text message
 *              request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::TextMessageRequest
(
        GCCConfID                                       conference_id,
        LPWSTR                                                  pwszTextMsg,
        UserID                                                  destination_node
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::TextMessageRequest);

    ::EnterCriticalSection(&g_csGCCProvider);

        // Check to make sure the node ID is valid and the conference exists.
        if ((destination_node < MINIMUM_USER_ID_VALUE) &&
                (destination_node != 0))
        {
            ERROR_OUT(("CControlSAP::TextMessageRequest: invalid user ID"));
                rc = GCC_INVALID_MCS_USER_ID;
        }
        else
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->TextMessageRequest(pwszTextMsg, destination_node);
        }
        else
        {
            WARNING_OUT(("CControlSAP::TextMessageRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }

    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::TextMessageRequest, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConfTransferRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              transfer request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConfTransferRequest
(
        GCCConfID               conference_id,
        PGCCConferenceName      destination_conference_name,
        GCCNumericString        destination_conference_modifier,
        UINT                            number_of_destination_addresses,
        PGCCNetworkAddress      *destination_address_list,
        UINT                            number_of_destination_nodes,
        PUserID                         destination_node_list,
        PGCCPassword            password
)
{
        GCCError                        rc = GCC_NO_ERROR;
        CPassword           *password_data = NULL;
        CNetAddrListContainer *network_address_list = NULL;
        UINT                            i = 0;
        
        DebugEntry(CControlSAP::ConfTransferRequest);

        //      Check for invalid conference name
        if (destination_conference_name != NULL)
        {
                /*
                **      Do not allow non-numeric or zero length strings to get
                **      past this point.
                */
                if (destination_conference_name->numeric_string != NULL)
                {
                        if (IsNumericNameValid (
                                        destination_conference_name->numeric_string) == FALSE)
                        {
                            ERROR_OUT(("CControlSAP::ConfTransferRequest: invalid numeric conference name"));
                                rc = GCC_INVALID_CONFERENCE_NAME;
                        }
                }
                else if (destination_conference_name->text_string != NULL)
                {
                        if (IsTextNameValid (
                                        destination_conference_name->text_string) == FALSE)
                        {
                            ERROR_OUT(("CControlSAP::ConfTransferRequest: invalid text conference name"));
                                rc = GCC_INVALID_CONFERENCE_NAME;
                        }
                }
                else
                {
                    ERROR_OUT(("CControlSAP::ConfTransferRequest: null numeric/text conference name"));
                        rc = GCC_INVALID_CONFERENCE_NAME;
                }

                if ((rc == GCC_NO_ERROR) &&
                                (destination_conference_name->text_string != NULL))
                {
                        if (IsTextNameValid (
                                        destination_conference_name->text_string) == FALSE)
                        {
                            ERROR_OUT(("CControlSAP::ConfTransferRequest: invalid text conference name"));
                                rc = GCC_INVALID_CONFERENCE_NAME;
                        }
                }
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfTransferRequest: null conference name"));
                rc = GCC_INVALID_CONFERENCE_NAME;
        }

        //      Check for valid conference modifier     
        if ((destination_conference_modifier != NULL) &&
                (rc == GCC_NO_ERROR))
        {
                if (IsNumericNameValid(destination_conference_modifier) == FALSE)
                {
                    ERROR_OUT(("CControlSAP::ConfTransferRequest: invalid conference modifier"));
                        rc = GCC_INVALID_CONFERENCE_MODIFIER;
                }
        }

        //      Check for valid password
        if ((password != NULL) &&
                (rc == GCC_NO_ERROR))
        {
                if (password->numeric_string != NULL)
                {
                        if (IsNumericNameValid(password->numeric_string) == FALSE)
                        {
                    ERROR_OUT(("CControlSAP::ConfTransferRequest: invalid password"));
                                rc = GCC_INVALID_PASSWORD;
                        }
                }
                else
                {
                    ERROR_OUT(("CControlSAP::ConfTransferRequest: null password"));
                        rc = GCC_INVALID_PASSWORD;
                }
        }
        
        //      Check for invalid user IDs
        if (rc == GCC_NO_ERROR)
        {
                while (i != number_of_destination_nodes)
                {
                        if (destination_node_list[i] < MINIMUM_USER_ID_VALUE)
                        {
                                rc = GCC_INVALID_MCS_USER_ID;
                                break;
                        }
                        
                        i++;
                }
        }
        
        if (rc == GCC_NO_ERROR)
        {
        CConf *pConf;

        ::EnterCriticalSection(&g_csGCCProvider);

                if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
                {
                        //      Construct the password container        
                        if (password != NULL)
                        {
                                DBG_SAVE_FILE_LINE
                                password_data = new CPassword(password, &rc);
                                if (password_data == NULL)
                                {
                                    ERROR_OUT(("CControlSAP::ConfTransferRequest: can't create CPassword"));
                                        rc = GCC_ALLOCATION_FAILURE;
                                }
                        }
                                
                        //      Construct the network address(es) container
                        if ((number_of_destination_addresses != 0) &&
                                        (rc == GCC_NO_ERROR))
                        {
                                DBG_SAVE_FILE_LINE
                                network_address_list = new CNetAddrListContainer(
                                                                                                number_of_destination_addresses,
                                                                                                destination_address_list,
                                                                                                &rc);
                                if (network_address_list == NULL)
                                {
                                    ERROR_OUT(("CControlSAP::CNetAddrListContainer: can't create CPassword"));
                                        rc = GCC_ALLOCATION_FAILURE;
                                }
                        }
                                
                        if (rc == GCC_NO_ERROR)
                        {
                                rc = pConf->ConfTransferRequest(destination_conference_name,
                                                                                                        destination_conference_modifier,
                                                                                                        network_address_list,
                                                                                                        number_of_destination_nodes,
                                                                                                        destination_node_list,
                                                                                                        password_data);
                        }

                        //      Free the data associated with the containers.
                        if (password_data != NULL)
                        {
                                password_data->Release();
                        }

                        if (network_address_list != NULL)
                        {
                                network_address_list->Release();
                        }
                }
                else
                {
                        rc = GCC_INVALID_CONFERENCE;
                }

        ::LeaveCriticalSection(&g_csGCCProvider);
        }

        DebugExitINT(CControlSAP::ConfTransferRequest, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConfAddRequest  ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              add request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConfAddRequest
(
        GCCConfID                       conference_id,
        UINT                                    number_of_network_addresses,
        PGCCNetworkAddress *    network_address_list,
        UserID                                  adding_node,
        UINT                                    number_of_user_data_members,
        PGCCUserData            *       user_data_list
)
{
        GCCError                        rc = GCC_NO_ERROR;
        CNetAddrListContainer *network_address_container = NULL;
        CUserDataListContainer *user_data_container = NULL;
        CConf               *pConf;

        DebugEntry(CControlSAP::ConfAddRequest);

        if ((adding_node < MINIMUM_USER_ID_VALUE) &&
                (adding_node != 0))
        {
            ERROR_OUT(("CControlSAP::ConfAddRequest: invalid adding node ID"));
                return GCC_INVALID_MCS_USER_ID;
        }

        if (number_of_network_addresses == 0)
        {
            ERROR_OUT(("CControlSAP::ConfAddRequest: no network address"));
                return GCC_BAD_NETWORK_ADDRESS;
        }

    ::EnterCriticalSection(&g_csGCCProvider);

        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                //      Construct the network address(es) container
                if (number_of_network_addresses != 0)
                {
                        DBG_SAVE_FILE_LINE
                        network_address_container = new CNetAddrListContainer(
                                                                                        number_of_network_addresses,
                                                                                        network_address_list,
                                                                                        &rc);
                        if (network_address_container == NULL)
            {
                ERROR_OUT(("CControlSAP::ConfAddRequest: can't create CNetAddrListContainer"));
                            rc = GCC_ALLOCATION_FAILURE;
            }
                }

                //      Construct the user data list container  
                if ((number_of_user_data_members != 0) &&
                        (rc == GCC_NO_ERROR))
                {
                        DBG_SAVE_FILE_LINE
                        user_data_container = new CUserDataListContainer(number_of_user_data_members, user_data_list, &rc);
                        if (user_data_container == NULL)
            {
                ERROR_OUT(("CControlSAP::ConfAddRequest: can't create CUserDataListContainer"));
                                rc = GCC_ALLOCATION_FAILURE;
            }
                }
                else
        {
                        user_data_container = NULL;
        }

                if (rc == GCC_NO_ERROR)
                {
                        rc = pConf->ConfAddRequest(network_address_container,
                                                                                adding_node,
                                                                                user_data_container);
                }

                //      Free the data associated with the containers.
                if (network_address_container != NULL)
                {
                        network_address_container->Release();
                }

                if (user_data_container != NULL)
                {
                        user_data_container->Release();
                }
        }
        else
        {
                rc = GCC_INVALID_CONFERENCE;
        }

    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfAddRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfAddResponse ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              add response from the node controller.  This function passes the
 *              response on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
GCCError CControlSAP::ConfAddResponse
(
        GCCResponseTag                  add_response_tag,
        GCCConfID                       conference_id,
        UserID                                  requesting_node,
        UINT                                    number_of_user_data_members,
        PGCCUserData            *       user_data_list,
        GCCResult                               result
)
{
        GCCError                        rc = GCC_NO_ERROR;
        CUserDataListContainer *user_data_container = NULL;
        CConf   *pConf;

        DebugEntry(CControlSAP::ConfAddResponse);

        if (requesting_node < MINIMUM_USER_ID_VALUE)
        {
            ERROR_OUT(("CControlSAP::ConfAddResponse: invalid user ID"));
                return GCC_INVALID_MCS_USER_ID;
        }

    ::EnterCriticalSection(&g_csGCCProvider);

        // Check to make sure the conference exists.
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                //      Construct the user data list container  
                if ((number_of_user_data_members != 0) &&
                        (rc == GCC_NO_ERROR))
                {
                        DBG_SAVE_FILE_LINE
                        user_data_container = new CUserDataListContainer(number_of_user_data_members, user_data_list, &rc);
                        if (user_data_container == NULL)
            {
                ERROR_OUT(("CControlSAP::ConfAddResponse: can't create CUserDataListContainer"));
                                rc = GCC_ALLOCATION_FAILURE;
            }
                }
                else
        {
                        user_data_container = NULL;
        }

                if (rc == GCC_NO_ERROR)
                {
                        rc = pConf->ConfAddResponse(add_response_tag,
                                                                                        requesting_node,
                                                                                        user_data_container,
                                                                                        result);
                }

                //      Free the data associated with the user data container.
                if (user_data_container != NULL)
                {
                        user_data_container->Release();
                }
        }
        else
        {
        WARNING_OUT(("CControlSAP::ConfAddResponse: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }

    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfAddResponse, rc);
        return rc;
}

#ifdef NM_RESET_DEVICE
/*
 *      ResetDevice ()
 *
 *      Public Function Description
 *              This routine is called in order to explicitly reset a particular
 *              transport stack.  The call is routed to the controller in order to take
 *              the appropriate action.
 */
GCCError CControlSAP::ResetDevice ( LPSTR device_identifier )
{
        GCCError                        rc;
        MCSError            mcs_error;

        DebugEntry(CControlSAP::ResetDevice);

    ::EnterCriticalSection(&g_csGCCProvider);

        //      Call back the controller to reset the device.
    mcs_error =  g_pMCSIntf->ResetDevice(device_identifier);
    rc = g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);

        //
        // If the the node controller was in a query, this will tell the node controller
        // to remove the query.
        //
        ConfQueryConfirm(GCC_TERMINAL, NULL, NULL, NULL,
                         GCC_RESULT_CONNECT_PROVIDER_FAILED, NULL);

    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ResetDevice, rc);
        return rc;
}
#endif // NM_RESET_DEVICE

/*
 *      ConfCreateIndication ()
 *
 *      Public Function Description
 *              This function is called by the GCC Controller when it gets a connect
 *              provider indication from MCS, carrying a conference create request PDU.
 *              This function fills in all the parameters in the CreateIndicationInfo
 *              structure. It then adds it to a queue of messages supposed to be sent to
 *              the node controller in the next heartbeat.
 */
GCCError CControlSAP::ConfCreateIndication
(
        PGCCConferenceName                      conference_name,
        GCCConfID                               conference_id,
        CPassword                   *convener_password,
        CPassword                   *password,
        BOOL                                            conference_is_locked,
        BOOL                                            conference_is_listed,
        BOOL                                            conference_is_conductible,
        GCCTerminationMethod            termination_method,
        PPrivilegeListData                      conductor_privilege_list,
        PPrivilegeListData                      conducted_mode_privilege_list,
        PPrivilegeListData                      non_conducted_privilege_list,
        LPWSTR                                          pwszConfDescriptor,
        LPWSTR                                          pwszCallerID,
        TransportAddress                        calling_address,
        TransportAddress                        called_address,
        PDomainParameters                       domain_parameters,
        CUserDataListContainer      *user_data_list,
        ConnectionHandle                        connection_handle
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfCreateIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_CREATE_INDICATION;

    /*
    **  Copy the information that needs to be sent to the node
    **  controller into local memory that can be deleted once the
    **  information to be sent to the application is flushed.  Note that
    **  if an error     occurs in one call to "CopyDataToGCCMessage" then no
    **  action is taken on subsequent calls to that routine.
    */

    // start with success
    rc = GCC_NO_ERROR;

    //  Copy the conference name
    ::CSAP_CopyDataToGCCMessage_ConfName(
            conference_name,
            &(Msg.u.create_indication.conference_name));

    //  Copy the Convener Password
    ::CSAP_CopyDataToGCCMessage_Password(
            convener_password,
            &(Msg.u.create_indication.convener_password));

    //  Copy the Password
    ::CSAP_CopyDataToGCCMessage_Password(
            password,
            &(Msg.u.create_indication.password));

    //  Copy the Conductor Privilege List
    GCCConfPrivileges _ConductorPrivileges;
    ::CSAP_CopyDataToGCCMessage_PrivilegeList(
            conductor_privilege_list,
            &(Msg.u.create_indication.conductor_privilege_list),
            &_ConductorPrivileges);

    //  Copy the Conducted-mode Conference Privilege List
    GCCConfPrivileges _ConductedModePrivileges;
    ::CSAP_CopyDataToGCCMessage_PrivilegeList(
            conducted_mode_privilege_list,
            &(Msg.u.create_indication.conducted_mode_privilege_list),
            &_ConductedModePrivileges);

    //  Copy the Non-Conducted-mode Conference Privilege List
    GCCConfPrivileges _NonConductedPrivileges;
    ::CSAP_CopyDataToGCCMessage_PrivilegeList(
            non_conducted_privilege_list,
            &(Msg.u.create_indication.non_conducted_privilege_list),
            &_NonConductedPrivileges);

    //  Copy the Conference Descriptor
    ::CSAP_CopyDataToGCCMessage_IDvsDesc(
            pwszConfDescriptor,
            &(Msg.u.create_indication.conference_descriptor));

    //  Copy the Caller Identifier
    ::CSAP_CopyDataToGCCMessage_IDvsDesc(
            pwszCallerID,
            &(Msg.u.create_indication.caller_identifier));

    //  Copy the Calling Address
    ::CSAP_CopyDataToGCCMessage_Call(
            calling_address,
            &(Msg.u.create_indication.calling_address));

    //  Copy the Called Address
    ::CSAP_CopyDataToGCCMessage_Call(
            called_address,
            &(Msg.u.create_indication.called_address));

    //  Copy the Domain Parameters
    DomainParameters _DomainParams;
    ::CSAP_CopyDataToGCCMessage_DomainParams(
            domain_parameters,
            &(Msg.u.create_indication.domain_parameters),
            &_DomainParams);

    //  Copy the User Data
    LPBYTE pUserDataMemory = NULL;
    if (user_data_list != NULL)
    {
        rc = RetrieveUserDataList(
                user_data_list,
                &(Msg.u.create_indication.number_of_user_data_members),
                &(Msg.u.create_indication.user_data_list),
                &pUserDataMemory);
    }
    else
    {
        Msg.u.create_indication.number_of_user_data_members = 0;
        Msg.u.create_indication.user_data_list = NULL;
    }

    if (GCC_NO_ERROR == rc)
    {
        //      Queue up the message for delivery to the Node Controller.
        Msg.nConfID = conference_id;
        Msg.u.create_indication.conference_id = conference_id;
        Msg.u.create_indication.conference_is_locked = conference_is_locked;
        Msg.u.create_indication.conference_is_listed = conference_is_listed;
        Msg.u.create_indication.conference_is_conductible = conference_is_conductible;
        Msg.u.create_indication.termination_method = termination_method;
        Msg.u.create_indication.connection_handle = connection_handle;

        SendCtrlSapMsg(&Msg);

        delete pUserDataMemory;
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CREATE_INDICATION, TRUE)))
    {
        ::ZeroMemory(&(pMsgEx->Msg.u.create_indication), sizeof(pMsgEx->Msg.u.create_indication));
    }
    else
        {
            ERROR_OUT(("CControlSAP::ConfCreateIndication: can't create GCCCtrlSapMsgEx"));
            rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
        }

    /*
        **      Copy the information that needs to be sent to the node
        **      controller into local memory that can be deleted once the
        **      information to be sent to the application is flushed.  Note that
        **      if an error     occurs in one call to "CopyDataToGCCMessage" then no
        **      action is taken on subsequent calls to that routine.
        */

        // start with success
        rc = GCC_NO_ERROR;

        //      Copy the conference name
        ::CSAP_CopyDataToGCCMessage_ConfName(
                        pMsgEx->pToDelete,
                        conference_name,
                        &(pMsgEx->Msg.u.create_indication.conference_name),
                        &rc);

        //      Copy the Convener Password
        ::CSAP_CopyDataToGCCMessage_Password(
                        TRUE,   // convener password
                        pMsgEx->pToDelete,
                        convener_password,
                        &(pMsgEx->Msg.u.create_indication.convener_password),
                        &rc);

        //      Copy the Password
        ::CSAP_CopyDataToGCCMessage_Password(
                        FALSE,  // non-convener password
                        pMsgEx->pToDelete,
                        password,
                        &(pMsgEx->Msg.u.create_indication.password),
                        &rc);

        //      Copy the Conductor Privilege List
        ::CSAP_CopyDataToGCCMessage_PrivilegeList(
                        conductor_privilege_list,
                        &(pMsgEx->Msg.u.create_indication.conductor_privilege_list),
                        &rc);
        pMsgEx->pToDelete->conductor_privilege_list = pMsgEx->Msg.u.create_indication.conductor_privilege_list;

        //      Copy the Conducted-mode Conference Privilege List
        ::CSAP_CopyDataToGCCMessage_PrivilegeList(
                        conducted_mode_privilege_list,
                        &(pMsgEx->Msg.u.create_indication.conducted_mode_privilege_list),
                        &rc);
        pMsgEx->pToDelete->conducted_mode_privilege_list = pMsgEx->Msg.u.create_indication.conducted_mode_privilege_list;

        //      Copy the Non-Conducted-mode Conference Privilege List
        ::CSAP_CopyDataToGCCMessage_PrivilegeList(
                        non_conducted_privilege_list,
                        &(pMsgEx->Msg.u.create_indication.non_conducted_privilege_list),
                        &rc);
        pMsgEx->pToDelete->non_conducted_privilege_list = pMsgEx->Msg.u.create_indication.non_conducted_privilege_list;

        //      Copy the Conference Descriptor
        ::CSAP_CopyDataToGCCMessage_IDvsDesc(
                        FALSE,  // conference descriptor
                        pMsgEx->pToDelete,
                        pwszConfDescriptor,
                        &(pMsgEx->Msg.u.create_indication.conference_descriptor),
                        &rc);

        //      Copy the Caller Identifier
        ::CSAP_CopyDataToGCCMessage_IDvsDesc(
                        TRUE,   // caller id
                        pMsgEx->pToDelete,
                        pwszCallerID,
                        &(pMsgEx->Msg.u.create_indication.caller_identifier),
                        &rc);

        //      Copy the Calling Address
        ::CSAP_CopyDataToGCCMessage_Call(
                        TRUE,   // calling address
                        pMsgEx->pToDelete,
                        calling_address,
                        &(pMsgEx->Msg.u.create_indication.calling_address),
                        &rc);

        //      Copy the Called Address
        ::CSAP_CopyDataToGCCMessage_Call(
                        FALSE,  // called address
                        pMsgEx->pToDelete,
                        called_address,
                        &(pMsgEx->Msg.u.create_indication.called_address),
                        &rc);

        //      Copy the Domain Parameters
        ::CSAP_CopyDataToGCCMessage_DomainParams(
                        pMsgEx->pToDelete,
                        domain_parameters,
                        &(pMsgEx->Msg.u.create_indication.domain_parameters),
                        &rc);

        if (GCC_NO_ERROR != rc)
        {
                ERROR_OUT(("CControlSAP::ConfCreateIndication: can't copy data to gcc message"));
                goto MyExit;
        }

        //      Copy the User Data
        if (user_data_list != NULL)
        {
                rc = RetrieveUserDataList(
                                user_data_list,
                                &(pMsgEx->Msg.u.create_indication.number_of_user_data_members),
                                &(pMsgEx->Msg.u.create_indication.user_data_list),
                                &(pMsgEx->pToDelete->user_data_list_memory));
                if (GCC_NO_ERROR != rc)
                {
                        goto MyExit;
                }
        }
        else
        {
                // pMsgEx->Msg.u.create_indication.number_of_user_data_members = 0;
                // pMsgEx->Msg.u.create_indication.user_data_list = NULL;
        }

        //      Queue up the message for delivery to the Node Controller.
        pMsgEx->Msg.nConfID = conference_id;
        pMsgEx->Msg.u.create_indication.conference_id = conference_id;
        pMsgEx->Msg.u.create_indication.conference_is_locked = conference_is_locked;
        pMsgEx->Msg.u.create_indication.conference_is_listed = conference_is_listed;
        pMsgEx->Msg.u.create_indication.conference_is_conductible = conference_is_conductible;
        pMsgEx->Msg.u.create_indication.termination_method = termination_method;
        pMsgEx->Msg.u.create_indication.connection_handle = connection_handle;

        PostIndCtrlSapMsg(pMsgEx);

MyExit:

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfCreateIndication, rc);
        return rc;
}

/*
 *      ConfQueryIndication ()
 *
 *      Public Function Description
 *              This function is called by the GCC Controller when it need to send a
 *              conference query indication to the node controller. It adds the message
 *              to a queue of messages to be sent to the node controller in the next
 *              heartbeat.
 */
GCCError CControlSAP::ConfQueryIndication
(
        GCCResponseTag                          query_response_tag,
        GCCNodeType                                     node_type,
        PGCCAsymmetryIndicator          asymmetry_indicator,
        TransportAddress                        calling_address,
        TransportAddress                        called_address,
        CUserDataListContainer      *user_data_list,
        ConnectionHandle                        connection_handle
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfQueryIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_QUERY_INDICATION;

    /*
    **  Copy the information that needs to be sent to the node
    **  controller into local memory that can be deleted once the
    **  information to be sent to the application is flushed.  Note that
    **  if an error     occurs in one call to "CopyDataToGCCMessage" then no
    **  action is taken on subsequent calls to that routine.
    */

    // start with success
    rc = GCC_NO_ERROR;

    //  Copy the Calling Address
    ::CSAP_CopyDataToGCCMessage_Call(
            calling_address,
            &(Msg.u.query_indication.calling_address));

    //  Copy the Calling Address
    ::CSAP_CopyDataToGCCMessage_Call(
            called_address,
            &(Msg.u.query_indication.called_address));

    //  Copy the asymmetry indicator if it exists
    GCCAsymmetryIndicator AsymIndicator;
    if (asymmetry_indicator != NULL)
    {
        Msg.u.query_indication.asymmetry_indicator = &AsymIndicator;
        AsymIndicator = *asymmetry_indicator;
    }
    else
    {
        Msg.u.query_indication.asymmetry_indicator = NULL;
    }

    //  Lock and Copy the user data if it exists
    LPBYTE pUserDataMemory = NULL;
    if (user_data_list != NULL)
    {
        rc = RetrieveUserDataList(
                user_data_list,
                &(Msg.u.query_indication.number_of_user_data_members),
                &(Msg.u.query_indication.user_data_list),
                &pUserDataMemory);
    }
    else
    {
        Msg.u.query_indication.number_of_user_data_members = 0;
        Msg.u.query_indication.user_data_list = NULL;
    }

    if (GCC_NO_ERROR == rc)
    {
        //      If everything is OK add the message to the message queue
        Msg.u.query_indication.query_response_tag = query_response_tag;
        Msg.u.query_indication.node_type = node_type;
        Msg.u.query_indication.connection_handle = connection_handle;

        SendCtrlSapMsg(&Msg);

        delete pUserDataMemory;
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_QUERY_INDICATION, TRUE)))
    {
        ::ZeroMemory(&(pMsgEx->Msg.u.query_indication), sizeof(pMsgEx->Msg.u.query_indication));
    }
    else
        {
            ERROR_OUT(("CControlSAP::ConfCreateIndication: can't create GCCCtrlSapMsgEx"));
            rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
        }

    /*
        **      Copy the information that needs to be sent to the node
        **      controller into local memory that can be deleted once the
        **      information to be sent to the application is flushed.  Note that
        **      if an error     occurs in one call to "CopyDataToGCCMessage" then no
        **      action is taken on subsequent calls to that routine.
        */

        // start with success
        rc = GCC_NO_ERROR;

        //      Copy the Calling Address
        ::CSAP_CopyDataToGCCMessage_Call(
                        TRUE,   // calling address
                        pMsgEx->pToDelete,
                        calling_address,
                        &(pMsgEx->Msg.u.query_indication.calling_address),
                        &rc);

        //      Copy the Calling Address
        ::CSAP_CopyDataToGCCMessage_Call(
                        FALSE,  // called address
                        pMsgEx->pToDelete,
                        called_address,
                        &(pMsgEx->Msg.u.query_indication.called_address),
                        &rc);

        if (GCC_NO_ERROR != rc)
        {
                ERROR_OUT(("CControlSAP::ConfQueryIndication: can't copy data to gcc message"));
                goto MyExit;
        }

        //      Copy the asymmetry indicator if it exists
        if (asymmetry_indicator != NULL)
        {
                DBG_SAVE_FILE_LINE
                pMsgEx->Msg.u.query_indication.asymmetry_indicator = new GCCAsymmetryIndicator;
                if (pMsgEx->Msg.u.query_indication.asymmetry_indicator != NULL)
                {
                        *(pMsgEx->Msg.u.query_indication.asymmetry_indicator) = *asymmetry_indicator;
                }
                else
                {
                        rc = GCC_ALLOCATION_FAILURE;
                        goto MyExit;
                }
        }
        else
        {
                // pMsgEx->Msg.u.query_indication.asymmetry_indicator = NULL;
        }
        
        //      Lock and Copy the user data if it exists
        if (user_data_list != NULL)
        {
                rc = RetrieveUserDataList(
                                user_data_list,
                                &(pMsgEx->Msg.u.query_indication.number_of_user_data_members),
                                &(pMsgEx->Msg.u.query_indication.user_data_list),
                                &(pMsgEx->pToDelete->user_data_list_memory));
                if (GCC_NO_ERROR != rc)
                {
                        goto MyExit;
                }
        }
        else
        {
                // pMsgEx->Msg.u.query_indication.number_of_user_data_members = 0;
                // pMsgEx->Msg.u.query_indication.user_data_list = NULL;
        }
        
        //      If everything is OK add the message to the message queue
        pMsgEx->Msg.u.query_indication.query_response_tag = query_response_tag;
        pMsgEx->Msg.u.query_indication.node_type = node_type;
        pMsgEx->Msg.u.query_indication.connection_handle = connection_handle;

        PostIndCtrlSapMsg(pMsgEx);

MyExit:

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfQueryIndication, rc);
        return rc;
}

/*
 *      ConfQueryConfirm ()
 *
 *      Public Function Description
 *              This function is called by the GCC Controller when it need to send a
 *              conference query confirm to the node controller. It adds the message
 *              to a queue of messages to be sent to the node controller in the next
 *              heartbeat.
 */
GCCError CControlSAP::ConfQueryConfirm
(
        GCCNodeType                                     node_type,
        PGCCAsymmetryIndicator          asymmetry_indicator,
        CConfDescriptorListContainer *conference_list,
        CUserDataListContainer      *user_data_list,
        GCCResult                                       result,
        ConnectionHandle                        connection_handle
)
{
        GCCError            rc = GCC_NO_ERROR;

        DebugEntry(CControlSAP::ConfQueryConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_QUERY_CONFIRM;

    GCCAsymmetryIndicator _AsymIndicator;
    if (asymmetry_indicator != NULL)
    {
        Msg.u.query_confirm.asymmetry_indicator = &_AsymIndicator;
        _AsymIndicator = *asymmetry_indicator;
    }
    else
    {
        Msg.u.query_confirm.asymmetry_indicator = NULL;
    }

    // Get the conference descriptor list if one exists
    if (conference_list != NULL)
    {
        rc = conference_list->LockConferenceDescriptorList();
        if (rc == GCC_NO_ERROR)
        {
            conference_list->GetConferenceDescriptorList(
                    &(Msg.u.query_confirm.conference_descriptor_list),
                    &(Msg.u.query_confirm.number_of_descriptors));
        }
    }
    else
    {
        Msg.u.query_confirm.conference_descriptor_list = NULL;
        Msg.u.query_confirm.number_of_descriptors = 0;
    }

    // Lock and Copy the user data if it exists
    LPBYTE pUserDataMemory = NULL;
    if (user_data_list != NULL)
    {
        rc = RetrieveUserDataList(
                user_data_list,
                &(Msg.u.query_confirm.number_of_user_data_members),
                &(Msg.u.query_confirm.user_data_list),
                &pUserDataMemory);
    }
    else
    {
        Msg.u.query_confirm.number_of_user_data_members = 0;
        Msg.u.query_confirm.user_data_list = NULL;
    }

    if (rc == GCC_NO_ERROR)
    {
        Msg.u.query_confirm.node_type = node_type;
        Msg.u.query_confirm.result = result;
        Msg.u.query_confirm.connection_handle = connection_handle;

        // Queue up the message for delivery to the Node Controller.
        SendCtrlSapMsg(&Msg);

        // clean up
        delete pUserDataMemory;
    }
    else
    {
        HandleResourceFailure(rc);
    }

    // clean up
    if (NULL != conference_list)
    {
        conference_list->UnLockConferenceDescriptorList();
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_QUERY_CONFIRM, TRUE)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.query_confirm), sizeof(pMsgEx->Msg.u.query_confirm));

        if (asymmetry_indicator != NULL)
                {
                        DBG_SAVE_FILE_LINE
                        pMsgEx->Msg.u.query_confirm.asymmetry_indicator = new GCCAsymmetryIndicator;
                        if (pMsgEx->Msg.u.query_confirm.asymmetry_indicator != NULL)
                        {
                                *(pMsgEx->Msg.u.query_confirm.asymmetry_indicator) = *asymmetry_indicator;
                        }
                        else
                        {
                                rc = GCC_ALLOCATION_FAILURE;
                        ERROR_OUT(("CControlSAP::ConfQueryConfirm: can't create GCCAsymmetryIndicator"));
                        }
                }
                else
        {
                        // pMsgEx->Msg.u.query_confirm.asymmetry_indicator = NULL;
        }

                //      Get the conference descriptor list if one exists
                if (conference_list != NULL)
                {
                        pMsgEx->pToDelete->conference_list = conference_list;

                        rc = conference_list->LockConferenceDescriptorList();
                        if (rc == GCC_NO_ERROR)
                        {
                                conference_list->GetConferenceDescriptorList (
                                                &(pMsgEx->Msg.u.query_confirm.conference_descriptor_list),
                                                &(pMsgEx->Msg.u.query_confirm.number_of_descriptors));
                        }
                }
                else
                {
                        // pMsgEx->Msg.u.query_confirm.conference_descriptor_list = NULL;
                        // pMsgEx->Msg.u.query_confirm.number_of_descriptors = 0;
                }

                //      Lock and Copy the user data if it exists
                if (user_data_list != NULL)
                {
                        rc = RetrieveUserDataList (
                                        user_data_list,
                                        &(pMsgEx->Msg.u.query_confirm.number_of_user_data_members),
                                        &(pMsgEx->Msg.u.query_confirm.user_data_list),
                                        &(pMsgEx->pToDelete->user_data_list_memory));
                }
                else
                {
                        // pMsgEx->Msg.u.query_confirm.number_of_user_data_members = 0;
                        // pMsgEx->Msg.u.query_confirm.user_data_list = NULL;
                }

                if (rc == GCC_NO_ERROR)
                {
                        pMsgEx->Msg.u.query_confirm.node_type = node_type;
                        pMsgEx->Msg.u.query_confirm.result = result;
                        pMsgEx->Msg.u.query_confirm.connection_handle = connection_handle;

                        //      Queue up the message for delivery to the Node Controller.
                        PostConfirmCtrlSapMsg(pMsgEx);
                }
        }
        else
        {
                rc = GCC_ALLOCATION_FAILURE;
                ERROR_OUT(("CControlSAP::ConfQueryConfirm: can't create GCCCtrlSapMsgEx"));
        }

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfQueryConfirm, rc);
        return rc;
}


/*
 *      ConfJoinIndication ()
 *
 *      Public Function Description
 *              This join indication is recevied from the owner object. This join
 *              indication is designed to make the join response very flexible at the
 *              node controller.  The node controller can respond to this indication
 *              by either creating a new conference and moving the joiner into it,
 *              putting the joiner in the conference requested or putting the joiner
 *              into a different conference that already exist.
 */
// LONCHANC: from GCCController, normal code path.
GCCError CControlSAP::ConfJoinIndication
(
        GCCConfID                               conference_id,
        CPassword                   *convener_password,
        CPassword                   *password_challenge,
        LPWSTR                                          pwszCallerID,
        TransportAddress                        calling_address,
        TransportAddress                        called_address,
        CUserDataListContainer      *user_data_list,
        BOOL                                            intermediate_node,
        ConnectionHandle                        connection_handle
)
{
        PJoinResponseStructure  join_info;
        GCCError                                rc;

        DebugEntry(CControlSAP::ConfJoinIndication);

        //      First generate a Join Response Handle and add info to response list
        while (1)
        {
                m_nJoinResponseTag++;
                if (NULL == m_JoinResponseTagList2.Find(m_nJoinResponseTag))
                        break;
        }

        DBG_SAVE_FILE_LINE
        join_info = new JoinResponseStructure;
        if (join_info != NULL)
        {
                join_info->connection_handle = connection_handle;
                join_info->conference_id = conference_id;
                join_info->user_id = NULL;
                join_info->command_target_call = FALSE;

                m_JoinResponseTagList2.Append(m_nJoinResponseTag, join_info);

                //      Queue up the message for delivery to the Node Controller.
                rc = QueueJoinIndication(       m_nJoinResponseTag,
                                                                                        conference_id,
                                                                                        convener_password,
                                                                                        password_challenge,
                                                                                        pwszCallerID,
                                                                                        calling_address,
                                                                                        called_address,
                                                                                        user_data_list,
                                                                                        intermediate_node,
                                                                                        connection_handle);
        }
        else
        {
                rc = GCC_ALLOCATION_FAILURE;
                ERROR_OUT(("CControlSAP::ConfJoinIndication: can't create JoinResponseStructure"));
        }

        DebugExitINT(CControlSAP::ConfJoinIndication, rc);
        return rc;
}

/*
 *      ConfInviteIndication ()
 *
 *      Public Function Description
 *              This function is called by the GCC Controller when it need to send a
 *              conference invite indication to the node controller. It adds the message
 *              to a queue of messages to be sent to the node controller in the next
 *              heartbeat.
 */
GCCError CControlSAP::ConfInviteIndication
(
        GCCConfID                       conference_id,
        PGCCConferenceName              conference_name,
        LPWSTR                                  pwszCallerID,
        TransportAddress                calling_address,
        TransportAddress                called_address,
        BOOL                                    fSecure,
        PDomainParameters               domain_parameters,
        BOOL                                    clear_password_required,
        BOOL                                    conference_is_locked,
        BOOL                                    conference_is_listed,
        BOOL                                    conference_is_conductible,
        GCCTerminationMethod    termination_method,
        PPrivilegeListData              conductor_privilege_list,
        PPrivilegeListData              conducted_mode_privilege_list,
        PPrivilegeListData              non_conducted_privilege_list,
        LPWSTR                                  pwszConfDescriptor,
        CUserDataListContainer  *user_data_list,
        ConnectionHandle                connection_handle
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfInviteIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_INVITE_INDICATION;

    //
    // Copy the information that needs to be sent to the node
    // controller into local memory that can be deleted once the
    // information to be sent to the application is flushed.  Note that
    // if an error      occurs in one call to "CopyDataToGCCMessage" then no
    // action is taken on subsequent calls to that routine.
    //

    // start with success
    rc = GCC_NO_ERROR;

    //  Copy the conference name
    ::CSAP_CopyDataToGCCMessage_ConfName(
            conference_name,
            &(Msg.u.invite_indication.conference_name));

    //  Copy the Conductor Privilege List
    GCCConfPrivileges _ConductorPrivileges;
    ::CSAP_CopyDataToGCCMessage_PrivilegeList(
            conductor_privilege_list,
            &(Msg.u.invite_indication.conductor_privilege_list),
            &_ConductorPrivileges);

    //  Copy the Conducted-mode Conference Privilege List
    GCCConfPrivileges _ConductedModePrivileges;
    ::CSAP_CopyDataToGCCMessage_PrivilegeList(
            conducted_mode_privilege_list,
            &(Msg.u.invite_indication.conducted_mode_privilege_list),
            &_ConductedModePrivileges);

    //  Copy the Non-Conducted-mode Conference Privilege List
    GCCConfPrivileges _NonConductedPrivileges;
    ::CSAP_CopyDataToGCCMessage_PrivilegeList(
            non_conducted_privilege_list,
            &(Msg.u.invite_indication.non_conducted_privilege_list),
            &_NonConductedPrivileges);

    //  Copy the Conference Descriptor
    ::CSAP_CopyDataToGCCMessage_IDvsDesc(
            pwszConfDescriptor,
            &(Msg.u.invite_indication.conference_descriptor));

    //  Copy the Caller Identifier
    ::CSAP_CopyDataToGCCMessage_IDvsDesc(
            pwszCallerID,
            &(Msg.u.invite_indication.caller_identifier));

    //  Copy the Calling Address
    ::CSAP_CopyDataToGCCMessage_Call(
            calling_address,
            &(Msg.u.invite_indication.calling_address));

    //  Copy the Called Address
    ::CSAP_CopyDataToGCCMessage_Call(
            called_address,
            &(Msg.u.invite_indication.called_address));

    //  Copy the Domain Parameters
    DomainParameters _DomainParams;
    ::CSAP_CopyDataToGCCMessage_DomainParams(
            domain_parameters,
            &(Msg.u.invite_indication.domain_parameters),
            &_DomainParams);

    //  Copy the User Data
    LPBYTE pUserDataMemory = NULL;
    if (user_data_list != NULL)
    {
        rc = RetrieveUserDataList(
                user_data_list,
                &(Msg.u.invite_indication.number_of_user_data_members),
                &(Msg.u.invite_indication.user_data_list),
                &pUserDataMemory);
        ASSERT(GCC_NO_ERROR == rc);
    }
    else
    {
        Msg.u.invite_indication.number_of_user_data_members = 0;
        Msg.u.invite_indication.user_data_list = NULL;
    }

    if (GCC_NO_ERROR == rc)
    {
        Msg.u.invite_indication.conference_id = conference_id;
        Msg.u.invite_indication.clear_password_required = clear_password_required;
        Msg.u.invite_indication.conference_is_locked = conference_is_locked;
        Msg.u.invite_indication.conference_is_listed = conference_is_listed;
        Msg.u.invite_indication.conference_is_conductible = conference_is_conductible;
        Msg.u.invite_indication.termination_method = termination_method;
        Msg.u.invite_indication.connection_handle = connection_handle;

        Msg.u.invite_indication.fSecure = fSecure;

        SendCtrlSapMsg(&Msg);

        delete pUserDataMemory;
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_INVITE_INDICATION, TRUE)))
    {
        ::ZeroMemory(&(pMsgEx->Msg.u.invite_indication), sizeof(pMsgEx->Msg.u.invite_indication));
    }
    else
        {
            ERROR_OUT(("CControlSAP::ConfInviteIndication: can't create GCCCtrlSapMsgEx"));
            rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
        }

        /*
        **      Copy the information that needs to be sent to the node
        **      controller into local memory that can be deleted once the
        **      information to be sent to the application is flushed.  Note that
        **      if an error     occurs in one call to "CopyDataToGCCMessage" then no
        **      action is taken on subsequent calls to that routine.
        */

        // start with success
        rc = GCC_NO_ERROR;

        //      Copy the conference name
        ::CSAP_CopyDataToGCCMessage_ConfName(
                        pMsgEx->pToDelete,
                        conference_name,
                        &(pMsgEx->Msg.u.invite_indication.conference_name),
                        &rc);

        //      Copy the Conductor Privilege List
        ::CSAP_CopyDataToGCCMessage_PrivilegeList(
                        conductor_privilege_list,
                        &(pMsgEx->Msg.u.invite_indication.conductor_privilege_list),
                        &rc);
        pMsgEx->pToDelete->conductor_privilege_list = pMsgEx->Msg.u.invite_indication.conductor_privilege_list;

        //      Copy the Conducted-mode Conference Privilege List
        ::CSAP_CopyDataToGCCMessage_PrivilegeList(
                        conducted_mode_privilege_list,
                        &(pMsgEx->Msg.u.invite_indication.conducted_mode_privilege_list),
                        &rc);
        pMsgEx->pToDelete->conducted_mode_privilege_list = pMsgEx->Msg.u.invite_indication.conducted_mode_privilege_list;

        //      Copy the Non-Conducted-mode Conference Privilege List
        ::CSAP_CopyDataToGCCMessage_PrivilegeList(
                        non_conducted_privilege_list,
                        &(pMsgEx->Msg.u.invite_indication.non_conducted_privilege_list),
                        &rc);
        pMsgEx->pToDelete->non_conducted_privilege_list = pMsgEx->Msg.u.invite_indication.non_conducted_privilege_list;

        //      Copy the Conference Descriptor
        ::CSAP_CopyDataToGCCMessage_IDvsDesc(
                        FALSE,  // conference descriptor
                        pMsgEx->pToDelete,
                        pwszConfDescriptor,
                        &(pMsgEx->Msg.u.invite_indication.conference_descriptor),
                        &rc);
        
        //      Copy the Caller Identifier
        ::CSAP_CopyDataToGCCMessage_IDvsDesc(
                        TRUE,   // caller id
                        pMsgEx->pToDelete,
                        pwszCallerID,
                        &(pMsgEx->Msg.u.invite_indication.caller_identifier),
                        &rc);
        
        //      Copy the Calling Address
        ::CSAP_CopyDataToGCCMessage_Call(
                        TRUE,   /// calling address
                        pMsgEx->pToDelete,
                        calling_address,
                        &(pMsgEx->Msg.u.invite_indication.calling_address),
                        &rc);
        
        //      Copy the Called Address
        ::CSAP_CopyDataToGCCMessage_Call(
                        FALSE,  // called address
                        pMsgEx->pToDelete,
                        called_address,
                        &(pMsgEx->Msg.u.invite_indication.called_address),
                        &rc);

        //      Copy the Domain Parameters
        ::CSAP_CopyDataToGCCMessage_DomainParams(
                        pMsgEx->pToDelete,
                        domain_parameters,
                        &(pMsgEx->Msg.u.invite_indication.domain_parameters),
                        &rc);

        if (GCC_NO_ERROR != rc)
        {
                ERROR_OUT(("CControlSAP::ConfInviteIndication: can't copy data to gcc message"));
                goto MyExit;
        }

        //      Copy the User Data
        if (user_data_list != NULL)
        {
                rc = RetrieveUserDataList(
                                user_data_list,
                                &(pMsgEx->Msg.u.invite_indication.number_of_user_data_members),
                                &(pMsgEx->Msg.u.invite_indication.user_data_list),
                                &(pMsgEx->pToDelete->user_data_list_memory));
                if (GCC_NO_ERROR != rc)
                {
                        goto MyExit;
                }
        }
        else
        {
                // pMsgEx->Msg.u.invite_indication.number_of_user_data_members = 0;
                // pMsgEx->Msg.u.invite_indication.user_data_list = NULL;
        }

        pMsgEx->Msg.u.invite_indication.conference_id = conference_id;
        pMsgEx->Msg.u.invite_indication.clear_password_required = clear_password_required;
        pMsgEx->Msg.u.invite_indication.conference_is_locked = conference_is_locked;
        pMsgEx->Msg.u.invite_indication.conference_is_listed = conference_is_listed;
        pMsgEx->Msg.u.invite_indication.conference_is_conductible = conference_is_conductible;
        pMsgEx->Msg.u.invite_indication.termination_method = termination_method;
        pMsgEx->Msg.u.invite_indication.connection_handle = connection_handle;

        //      Queue up the message for delivery to the Node Controller.
        PostIndCtrlSapMsg(pMsgEx);

MyExit:

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfInviteIndication, rc);
        return rc;
}

#ifdef TSTATUS_INDICATION
/*
 *      GCCError   TransportStatusIndication()
 *
 *      Public Function Description
 *              This function is called by the GCC Controller when it need to send a
 *              transport status indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.      This callback message uses Rogue Wave strings to
 *              store the message information.  These strings are held in a
 *              TransportStatusInfo structure which is stored in a DataToBeDeleted
 *              structure which is freed up after the callback is issued.
 */
GCCError CControlSAP::TransportStatusIndication ( PTransportStatus transport_status )
{
    GCCError                            rc;

    DebugEntry(CControlSAP::TransportStatusIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_TRANSPORT_STATUS_INDICATION;

    Msg.u.transport_status.device_identifier = transport_status->device_identifier;
    Msg.u.transport_status.remote_address = transport_status->remote_address;
    Msg.u.transport_status.message = transport_status->message;
    Msg.u.transport_status.state = transport_status->state;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx         *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TRANSPORT_STATUS_INDICATION, TRUE)))
    {
        // ::ZeroMemory(&(pMsgEx->Msg.u.transport_status), sizeof(pMsgEx->Msg.u.transport_status));
        pMsgEx->Msg.u.transport_status.device_identifier = ::My_strdupA(transport_status->device_identifier);
        pMsgEx->Msg.u.transport_status.remote_address = ::My_strdupA(transport_status->remote_address);
        pMsgEx->Msg.u.transport_status.message = ::My_strdupA(transport_status->message);
                pMsgEx->Msg.u.transport_status.state = transport_status->state;

        PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
        {
            ERROR_OUT(("CControlSAP::TransportStatusIndication: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::TransportStatusIndication, rc);
        return rc;
}
        
/*
 *      StatusIndication()
 *
 *      Public Function Description
 *              This function is called by the GCC Controller when it need to send a
 *              status indication to the node controller. It adds the message to a
 *              queue of messages to be sent to the node controller in the next
 *              heartbeat.
 *
 *      Caveats
 *              Note that we do not handle a resource error here to avoid an
 *              endless loop that could occur when this routine is called from the
 *              HandleResourceError() routine.
 */
GCCError CControlSAP::StatusIndication
(
        GCCStatusMessageType    status_message_type,
        UINT                                    parameter
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::StatusIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_STATUS_INDICATION;

    Msg.u.status_indication.status_message_type = status_message_type;
    Msg.u.status_indication.parameter = parameter;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_STATUS_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.status_indication), sizeof(pMsgEx->Msg.u.status_indication));
        pMsgEx->Msg.u.status_indication.status_message_type = status_message_type;
                pMsgEx->Msg.u.status_indication.parameter = parameter;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
                rc = GCC_NO_ERROR;
        }
    else
    {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::StatusIndication, rc);
        return rc;
}
#endif  // TSTATUS_INDICATION

/*
 *      GCCError   ConnectionBrokenIndication ()
 *
 *      Public Function Description
 *              This function is called by the GCC Controller when it need to send a
 *              connection broken indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConnectionBrokenIndication ( ConnectionHandle connection_handle )
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConnectionBrokenIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_CONNECTION_BROKEN_INDICATION;

    Msg.u.connection_broken_indication.connection_handle = connection_handle;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONNECTION_BROKEN_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.connection_broken_indication), sizeof(pMsgEx->Msg.u.connection_broken_indication));
                pMsgEx->Msg.u.connection_broken_indication.connection_handle = connection_handle;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
                rc = GCC_NO_ERROR;
        }
        else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConnectionBrokenIndication, rc);
        return rc;
}

/*
 *      The following routines are virtual command target calls.
 */

/*
 *      ConfCreateConfirm()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference create confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfCreateConfirm
(
        PGCCConferenceName                              conference_name,
        GCCNumericString                                conference_modifier,
        GCCConfID                                       conference_id,
        PDomainParameters                               domain_parameters,
        CUserDataListContainer              *user_data_list,
        GCCResult                                               result,
        ConnectionHandle                                connection_handle
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfCreateConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_CREATE_CONFIRM;

    /*
    **  Copy the information that needs to be sent to the node
    **  controller into local memory that can be deleted once the
    **  information to be sent to the application is flushed.  Note that
    **  if an error     occurs in one call to "CopyDataToGCCMessage" then no
    **  action is taken on subsequent calls to that routine.
    */

    // start with success
    rc = GCC_NO_ERROR;

    // Copy the conference name
    ::CSAP_CopyDataToGCCMessage_ConfName(
            conference_name,
            &(Msg.u.create_confirm.conference_name));

    // Copy the conference name modifier
    ::CSAP_CopyDataToGCCMessage_Modifier(
            conference_modifier,
            &(Msg.u.create_confirm.conference_modifier));

    // Copy the Domain Parameters
    DomainParameters _DomainParams;
    ::CSAP_CopyDataToGCCMessage_DomainParams(
        domain_parameters,
        &(Msg.u.create_confirm.domain_parameters),
        &_DomainParams);

    // Copy the User Data
    LPBYTE pUserDataMemory = NULL;
    if (user_data_list != NULL)
    {
        rc = RetrieveUserDataList(
                user_data_list,
                &(Msg.u.create_confirm.number_of_user_data_members),
                &(Msg.u.create_confirm.user_data_list),
                &pUserDataMemory);
    }
    else
    {
        TRACE_OUT(("CControlSAP:ConfCreateConfirm: User Data List is NOT present"));
        Msg.u.create_confirm.number_of_user_data_members = 0;
        Msg.u.create_confirm.user_data_list = NULL;
    }

    if (GCC_NO_ERROR == rc)
    {
        Msg.nConfID = conference_id;
        Msg.u.create_confirm.conference_id = conference_id;
        Msg.u.create_confirm.result= result;
        Msg.u.create_confirm.connection_handle= connection_handle;

        SendCtrlSapMsg(&Msg);

        // clean up
        delete pUserDataMemory;
    }
    else
    {
        HandleResourceFailure(rc);
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CREATE_CONFIRM, TRUE)))
    {
        ::ZeroMemory(&(pMsgEx->Msg.u.create_confirm), sizeof(pMsgEx->Msg.u.create_confirm));
    }
    else
        {
            ERROR_OUT(("CControlSAP::ConfCreateConfirm: can't create GCCCtrlSapMsgEx"));
            rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
        }

        /*
        **      Copy the information that needs to be sent to the node
        **      controller into local memory that can be deleted once the
        **      information to be sent to the application is flushed.  Note that
        **      if an error     occurs in one call to "CopyDataToGCCMessage" then no
        **      action is taken on subsequent calls to that routine.
        */

        // start with success
        rc = GCC_NO_ERROR;

        //      Copy the conference name
        ::CSAP_CopyDataToGCCMessage_ConfName(
                        pMsgEx->pToDelete,
                        conference_name,
                        &(pMsgEx->Msg.u.create_confirm.conference_name),
                        &rc);

        //      Copy the conference name modifier
        ::CSAP_CopyDataToGCCMessage_Modifier(
                FALSE,  // conference modifier
                pMsgEx->pToDelete,
                conference_modifier,
                &(pMsgEx->Msg.u.create_confirm.conference_modifier),
                &rc);

        //      Copy the Domain Parameters
        ::CSAP_CopyDataToGCCMessage_DomainParams(
                pMsgEx->pToDelete,
                domain_parameters,
                &(pMsgEx->Msg.u.create_confirm.domain_parameters),
                &rc);

        if (GCC_NO_ERROR != rc)
        {
                ERROR_OUT(("CControlSAP::ConfCreateConfirm: can't copy data to gcc message"));
                goto MyExit;
        }

        //      Copy the User Data
        if (user_data_list != NULL)
        {
                rc = RetrieveUserDataList(
                                user_data_list,
                                &(pMsgEx->Msg.u.create_confirm.number_of_user_data_members),
                                &(pMsgEx->Msg.u.create_confirm.user_data_list),
                                &(pMsgEx->pToDelete->user_data_list_memory));
                if (GCC_NO_ERROR != rc)
                {
                        goto MyExit;
                }
        }
        else
        {
                TRACE_OUT(("CControlSAP:ConfCreateConfirm: User Data List is NOT present"));
                // pMsgEx->Msg.u.create_confirm.number_of_user_data_members = 0;
                // pMsgEx->Msg.u.create_confirm.user_data_list = NULL;
        }

        //      Queue up the message for delivery to the Node Controller.
        pMsgEx->Msg.nConfID = conference_id;
        pMsgEx->Msg.u.create_confirm.conference_id = conference_id;
        pMsgEx->Msg.u.create_confirm.result= result;
        pMsgEx->Msg.u.create_confirm.connection_handle= connection_handle;

        PostConfirmCtrlSapMsg(pMsgEx);

MyExit:

        /*
        **      Clean up after any resource allocation error which may have occurred.
        */
        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfCreateConfirm, rc);
        return rc;
}

/*
 *      ConfDisconnectIndication()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference disconnect indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfDisconnectIndication
(
        GCCConfID       conference_id,
        GCCReason               reason,
        UserID                  disconnected_node_id
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfDisconnectIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_DISCONNECT_INDICATION;

    Msg.nConfID = conference_id;
    Msg.u.disconnect_indication.conference_id = conference_id;
    Msg.u.disconnect_indication.reason = reason;
    Msg.u.disconnect_indication.disconnected_node_id = disconnected_node_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_DISCONNECT_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.disconnect_indication), sizeof(pMsgEx->Msg.u.disconnect_indication));
        pMsgEx->Msg.nConfID = conference_id;
                pMsgEx->Msg.u.disconnect_indication.conference_id = conference_id;
                pMsgEx->Msg.u.disconnect_indication.reason = reason;
                pMsgEx->Msg.u.disconnect_indication.disconnected_node_id = disconnected_node_id;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfDisconnectIndication, rc);
        return rc;
}

/*
 *      ConfDisconnectConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference disconnect confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfDisconnectConfirm
(
        GCCConfID           conference_id,
        GCCResult           result
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfDisconnectConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_DISCONNECT_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_DISCONNECT_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.disconnect_confirm), sizeof(pMsgEx->Msg.u.disconnect_confirm));
        pMsgEx->Msg.nConfID = conference_id;
                pMsgEx->Msg.u.disconnect_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.disconnect_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfDisconnectConfirm, rc);
        return rc;
}


/*
 *      GCCError   ConfJoinIndication()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference join indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 *
 *              Since this is received by the command target call we know that the
 *              response must be routed back to the same conference.  We must also
 *              pass back the user_id when the response is made.
 */
// LONCHANC: from Conf2/MCSUser/ProcessJoinRequestPDU.
// forwarded from an existing child node.
GCCError CControlSAP::ForwardedConfJoinIndication
(
        UserID                                  sender_id,
        GCCConfID                       conference_id,
        CPassword               *convener_password,
        CPassword               *password_challenge,
        LPWSTR                                  pwszCallerID,
        CUserDataListContainer  *user_data_list
)
{
        GCCError                                rc = GCC_NO_ERROR;
        PJoinResponseStructure  join_info;
        LPWSTR                                  caller_id_ptr;

        DebugEntry(CControlSAP::ForwardedConfJoinIndication);

        //      First generate a Join Response Handle and add info to response list
        while (1)
        {
                m_nJoinResponseTag++;
                if (NULL == m_JoinResponseTagList2.Find(m_nJoinResponseTag))
                        break;
        }

        //      Create a new "info" structure to hold the join information.
        DBG_SAVE_FILE_LINE
        join_info = new JoinResponseStructure;
        if (join_info != NULL)
        {
                caller_id_ptr = pwszCallerID;

                join_info->connection_handle = NULL;
                join_info->conference_id = conference_id;
                join_info->user_id = sender_id;
                join_info->command_target_call = TRUE;

                m_JoinResponseTagList2.Append(m_nJoinResponseTag, join_info);

                //      Queue up the message for delivery to the Node Controller.
                rc = QueueJoinIndication(       
                                                        m_nJoinResponseTag,
                                                        conference_id,
                                                        convener_password,
                                                        password_challenge,
                                                        caller_id_ptr,
                                                        NULL,   //      Transport address not supported here
                                                        NULL,   //      Transport address not supported here
                                                        user_data_list,
                                                        FALSE,   //     Not an intermediate node
                                                        0);
        }
        else
        {
                rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

        DebugExitINT(CControlSAP::ForwardedConfJoinIndication, rc);
        return rc;
}

/*
 *      GCCError   ConfJoinConfirm()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference join confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfJoinConfirm
(
        PGCCConferenceName                      conference_name,
        GCCNumericString                        remote_modifier,
        GCCNumericString                        local_modifier,
        GCCConfID                               conference_id,
        CPassword                   *password_challenge,
        PDomainParameters                       domain_parameters,
        BOOL                                            password_in_the_clear,
        BOOL                                            conference_is_locked,
        BOOL                                            conference_is_listed,
        BOOL                                            conference_is_conductible,
        GCCTerminationMethod            termination_method,
        PPrivilegeListData                      conductor_privilege_list,
        PPrivilegeListData                      conduct_mode_privilege_list,
        PPrivilegeListData                      non_conduct_privilege_list,
        LPWSTR                                          pwszConfDescription,
        CUserDataListContainer      *user_data_list,    
        GCCResult                                       result,
        ConnectionHandle                        connection_handle,
        PBYTE                       pbRemoteCred,
        DWORD                       cbRemoteCred
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfJoinConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_JOIN_CONFIRM;

    /*
    **  Copy the information that needs to be sent to the node
    **  controller into local memory that can be deleted once the
    **  information to be sent to the application is flushed.  Note that
    **  if an error     occurs in one call to "CopyDataToGCCMessage" then no
    **  action is taken on subsequent calls to that routine.
    */

    // start with success
    rc = GCC_NO_ERROR;

    // Copy the conference name
    ::CSAP_CopyDataToGCCMessage_ConfName(
            conference_name,
            &(Msg.u.join_confirm.conference_name));

    // Copy the remote modifier
    ::CSAP_CopyDataToGCCMessage_Modifier(
            remote_modifier,
            &(Msg.u.join_confirm.called_node_modifier));

    // Copy the local conference name modifier
    ::CSAP_CopyDataToGCCMessage_Modifier(
            local_modifier,
            &(Msg.u.join_confirm.calling_node_modifier));

    // Copy the Password challange
    ::CSAP_CopyDataToGCCMessage_Challenge(
            password_challenge,
            &(Msg.u.join_confirm.password_challenge));

    // Copy the Domain Parameters
    DomainParameters _DomainParams;
    ::CSAP_CopyDataToGCCMessage_DomainParams(
            domain_parameters,
            &(Msg.u.join_confirm.domain_parameters),
            &_DomainParams);

    // Copy the Conductor Privilege List
    GCCConfPrivileges _ConductorPrivilegeList;
    ::CSAP_CopyDataToGCCMessage_PrivilegeList(
            conductor_privilege_list,
            &(Msg.u.join_confirm.conductor_privilege_list),
            &_ConductorPrivilegeList);

    // Copy the Conducted-mode Conference Privilege List
    GCCConfPrivileges _ConductedModePrivilegeList;
    ::CSAP_CopyDataToGCCMessage_PrivilegeList(
            conduct_mode_privilege_list,
            &(Msg.u.join_confirm.conducted_mode_privilege_list),
            &_ConductedModePrivilegeList);

    // Copy the Non-Conducted-mode Conference Privilege List
    GCCConfPrivileges _NonConductedModePrivilegeList;
    ::CSAP_CopyDataToGCCMessage_PrivilegeList(
            non_conduct_privilege_list,
            &(Msg.u.join_confirm.non_conducted_privilege_list),
            &_NonConductedModePrivilegeList);

    // Copy the Conference Descriptor
    ::CSAP_CopyDataToGCCMessage_IDvsDesc(
            pwszConfDescription,
            &(Msg.u.join_confirm.conference_descriptor));

    // Copy the User Data
    LPBYTE pUserDataMemory = NULL;
    if (user_data_list != NULL)
    {
        rc = RetrieveUserDataList(
                user_data_list,
                &(Msg.u.join_confirm.number_of_user_data_members),
                &(Msg.u.join_confirm.user_data_list),
                &pUserDataMemory);
    }
    else
    {
        Msg.u.join_confirm.number_of_user_data_members = 0;
        Msg.u.join_confirm.user_data_list = NULL;
    }

    if (GCC_NO_ERROR == rc)
    {
        Msg.nConfID = conference_id;
        Msg.u.join_confirm.conference_id = conference_id;
        Msg.u.join_confirm.clear_password_required = password_in_the_clear;
        Msg.u.join_confirm.conference_is_locked = conference_is_locked;
        Msg.u.join_confirm.conference_is_listed = conference_is_listed;
        Msg.u.join_confirm.conference_is_conductible = conference_is_conductible;
        Msg.u.join_confirm.termination_method = termination_method;
        Msg.u.join_confirm.result = result;
        Msg.u.join_confirm.connection_handle = connection_handle;
        Msg.u.join_confirm.pb_remote_cred = pbRemoteCred;
        Msg.u.join_confirm.cb_remote_cred = cbRemoteCred;

        SendCtrlSapMsg(&Msg);

        // clean up
        delete pUserDataMemory;
    }
    else
    {
        HandleResourceFailure(rc);
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_JOIN_CONFIRM, TRUE)))
    {
        ::ZeroMemory(&(pMsgEx->Msg.u.join_confirm), sizeof(pMsgEx->Msg.u.join_confirm));
    }
    else
        {
            ERROR_OUT(("CControlSAP::ConfJoinConfirm: can't create GCCCtrlSapMsgEx"));
            rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
        }

        /*
        **      Copy the information that needs to be sent to the node
        **      controller into local memory that can be deleted once the
        **      information to be sent to the application is flushed.  Note that
        **      if an error     occurs in one call to "CopyDataToGCCMessage" then no
        **      action is taken on subsequent calls to that routine.
        */

        // start with success
        rc = GCC_NO_ERROR;

        //      Copy the conference name
        ::CSAP_CopyDataToGCCMessage_ConfName(
                        pMsgEx->pToDelete,
                        conference_name,
                        &(pMsgEx->Msg.u.join_confirm.conference_name),
                        &rc);

        //      Copy the remote modifier
        ::CSAP_CopyDataToGCCMessage_Modifier(
                        TRUE,   // remote modifier
                        pMsgEx->pToDelete,
                        remote_modifier,
                        &(pMsgEx->Msg.u.join_confirm.called_node_modifier),
                        &rc);

        //      Copy the local conference name modifier
        ::CSAP_CopyDataToGCCMessage_Modifier(
                        FALSE,  // conference modifier
                        pMsgEx->pToDelete,
                        local_modifier,
                        &(pMsgEx->Msg.u.join_confirm.calling_node_modifier),
                        &rc);

        //      Copy the Password challange
        ::CSAP_CopyDataToGCCMessage_Challenge(
                        pMsgEx->pToDelete,
                        password_challenge,
                        &(pMsgEx->Msg.u.join_confirm.password_challenge),
                        &rc);

        //      Copy the Domain Parameters
        ::CSAP_CopyDataToGCCMessage_DomainParams(
                        pMsgEx->pToDelete,
                        domain_parameters,
                        &(pMsgEx->Msg.u.join_confirm.domain_parameters),
                        &rc);

        //      Copy the Conductor Privilege List
        ::CSAP_CopyDataToGCCMessage_PrivilegeList(
                        conductor_privilege_list,
                        &(pMsgEx->Msg.u.join_confirm.conductor_privilege_list),
                        &rc);
        pMsgEx->pToDelete->conductor_privilege_list = pMsgEx->Msg.u.join_confirm.conductor_privilege_list;

        //      Copy the Conducted-mode Conference Privilege List
        ::CSAP_CopyDataToGCCMessage_PrivilegeList(
                        conduct_mode_privilege_list,
                        &(pMsgEx->Msg.u.join_confirm.conducted_mode_privilege_list),
                        &rc);
        pMsgEx->pToDelete->conducted_mode_privilege_list = pMsgEx->Msg.u.join_confirm.conducted_mode_privilege_list;

        //      Copy the Non-Conducted-mode Conference Privilege List
        ::CSAP_CopyDataToGCCMessage_PrivilegeList(
                        non_conduct_privilege_list,
                        &(pMsgEx->Msg.u.join_confirm.non_conducted_privilege_list),
                        &rc);
        pMsgEx->pToDelete->non_conducted_privilege_list = pMsgEx->Msg.u.join_confirm.non_conducted_privilege_list;

        //      Copy the Conference Descriptor
        ::CSAP_CopyDataToGCCMessage_IDvsDesc(
                        FALSE,  // conference descriptor
                        pMsgEx->pToDelete,
                        pwszConfDescription,
                        &(pMsgEx->Msg.u.join_confirm.conference_descriptor),
                        &rc);

        if (GCC_NO_ERROR != rc)
        {
                goto MyExit;
        }

        //      Copy the User Data
        if (user_data_list != NULL)
        {
                rc = RetrieveUserDataList(
                                user_data_list,
                                &(pMsgEx->Msg.u.join_confirm.number_of_user_data_members),
                                &(pMsgEx->Msg.u.join_confirm.user_data_list),
                                &(pMsgEx->pToDelete->user_data_list_memory));
                if (GCC_NO_ERROR != rc)
                {
                        goto MyExit;
                }
        }
        else
        {
                // pMsgEx->Msg.u.join_confirm.number_of_user_data_members = 0;
                // pMsgEx->Msg.u.join_confirm.user_data_list = NULL;
        }
        
        //      Queue up the message for delivery to the Node Controller.
        pMsgEx->Msg.nConfID = conference_id;
        pMsgEx->Msg.u.join_confirm.conference_id = conference_id;
        pMsgEx->Msg.u.join_confirm.clear_password_required = password_in_the_clear;
        pMsgEx->Msg.u.join_confirm.conference_is_locked = conference_is_locked;
        pMsgEx->Msg.u.join_confirm.conference_is_listed = conference_is_listed;
        pMsgEx->Msg.u.join_confirm.conference_is_conductible = conference_is_conductible;
        pMsgEx->Msg.u.join_confirm.termination_method = termination_method;
        pMsgEx->Msg.u.join_confirm.result = result;
        pMsgEx->Msg.u.join_confirm.connection_handle = connection_handle;

        PostConfirmCtrlSapMsg(pMsgEx);

MyExit:

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfJoinConfirm, rc);
        return rc;
}

/*
 *      GCCError   ConfInviteConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference invite confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfInviteConfirm
(
        GCCConfID                       conference_id,
        CUserDataListContainer  *user_data_list,
        GCCResult                               result,
        ConnectionHandle                connection_handle
)
{
        GCCError    rc = GCC_NO_ERROR;

        DebugEntry(CControlSAP::ConfInviteConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_INVITE_CONFIRM;

    // Copy the User Data
    LPBYTE pUserDataMemory = NULL;
    if (user_data_list != NULL)
    {
        rc = RetrieveUserDataList(
                user_data_list,
                &(Msg.u.invite_confirm.number_of_user_data_members),
                &(Msg.u.invite_confirm.user_data_list),
                &pUserDataMemory);
    }
    else
    {
        Msg.u.invite_confirm.number_of_user_data_members = 0;
        Msg.u.invite_confirm.user_data_list = NULL;
    }

    if (GCC_NO_ERROR == rc)
    {
        Msg.nConfID = conference_id;
        Msg.u.invite_confirm.conference_id = conference_id;
        Msg.u.invite_confirm.result = result;
        Msg.u.invite_confirm.connection_handle = connection_handle;

        SendCtrlSapMsg(&Msg);

        // clean up
        delete pUserDataMemory;
    }
    else
    {
        HandleResourceFailure(rc);
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_INVITE_CONFIRM, TRUE)))
    {
        ::ZeroMemory(&(pMsgEx->Msg.u.invite_confirm), sizeof(pMsgEx->Msg.u.invite_confirm));
    }
    else
        {
            ERROR_OUT(("CControlSAP::ConfInviteConfirm: can't create GCCCtrlSapMsgEx"));
            rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
        }

        //      Copy the User Data
        if (user_data_list != NULL)
        {
                rc = RetrieveUserDataList(
                                user_data_list,
                                &(pMsgEx->Msg.u.invite_confirm.number_of_user_data_members),
                                &(pMsgEx->Msg.u.invite_confirm.user_data_list),
                                &(pMsgEx->pToDelete->user_data_list_memory));
                if (GCC_NO_ERROR != rc)
                {
                        goto MyExit;
                }
        }
        else
        {
                // pMsgEx->Msg.u.invite_confirm.number_of_user_data_members = 0;
                // pMsgEx->Msg.u.invite_confirm.user_data_list = NULL;
        }

    pMsgEx->Msg.nConfID = conference_id;
        pMsgEx->Msg.u.invite_confirm.conference_id = conference_id;
        pMsgEx->Msg.u.invite_confirm.result = result;
        pMsgEx->Msg.u.invite_confirm.connection_handle = connection_handle;

        //      Queue up the message for delivery to the Node Controller.
        PostConfirmCtrlSapMsg(pMsgEx);

MyExit:

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfInviteConfirm, rc);
        return rc;
}


/*
 *      GCCError   ConfTerminateIndication ()
 *
 *      Public Function Description
 *              This function is called by the GCC Controller when it need to send a
 *              conference terminate indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::
ConfTerminateIndication
(
        GCCConfID                       conference_id,
        UserID                                  requesting_node_id,
        GCCReason                               reason
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfTerminateIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_TERMINATE_INDICATION;

    Msg.nConfID = conference_id;
    Msg.u.terminate_indication.conference_id = conference_id;
    Msg.u.terminate_indication.requesting_node_id = requesting_node_id;
    Msg.u.terminate_indication.reason = reason;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TERMINATE_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.terminate_indication), sizeof(pMsgEx->Msg.u.terminate_indication));
        pMsgEx->Msg.nConfID = conference_id;
                pMsgEx->Msg.u.terminate_indication.conference_id = conference_id;
                pMsgEx->Msg.u.terminate_indication.requesting_node_id = requesting_node_id;
                pMsgEx->Msg.u.terminate_indication.reason = reason;
        
                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfTerminateIndication, rc);
        return rc;
}

/*
 *      ConfLockReport()
 *
 *      Public Function Descrpition
 *              This function is called by the CConf when it need to send a
 *              conference lock report to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfLockReport
(
        GCCConfID                               conference_id,
        BOOL                                            conference_is_locked
)
{
        GCCError            rc;
        GCCCtrlSapMsgEx     *pMsgEx;

        DebugEntry(CControlSAP::ConfLockReport);

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_LOCK_REPORT_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.lock_report_indication), sizeof(pMsgEx->Msg.u.lock_report_indication));
                pMsgEx->Msg.u.lock_report_indication.conference_id = conference_id;
                pMsgEx->Msg.u.lock_report_indication.conference_is_locked = conference_is_locked;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

        DebugExitINT(CControlSAP::ConfLockReport, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConfLockIndication()
 *
 *      Public Function Descrpition:
 *              This function is called by the CConf when it need to send a
 *              conference lock indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfLockIndication
(
        GCCConfID                                       conference_id,
        UserID                                                  source_node_id
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfLockIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_LOCK_INDICATION;

    Msg.u.lock_indication.conference_id = conference_id;
    Msg.u.lock_indication.requesting_node_id = source_node_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_LOCK_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.lock_indication), sizeof(pMsgEx->Msg.u.lock_indication));
                pMsgEx->Msg.u.lock_indication.conference_id = conference_id;
                pMsgEx->Msg.u.lock_indication.requesting_node_id = source_node_id;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfLockIndication, rc);
        return rc;
}

/*
 *      ConfLockConfirm()
 *
 *      Public Function Descrpition
 *              This function is called by the CConf when it need to send a
 *              conference lock confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfLockConfirm
(
        GCCResult                       result,
        GCCConfID           conference_id
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfLockConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_LOCK_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_LOCK_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.lock_confirm), sizeof(pMsgEx->Msg.u.lock_confirm));
        pMsgEx->Msg.u.lock_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.lock_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfLockConfirm, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConfUnlockIndication()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference unlock indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfUnlockIndication
(
        GCCConfID                                       conference_id,
        UserID                                                  source_node_id
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfUnlockIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_UNLOCK_INDICATION;

    Msg.u.unlock_indication.conference_id = conference_id;
    Msg.u.unlock_indication.requesting_node_id = source_node_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_UNLOCK_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.unlock_indication), sizeof(pMsgEx->Msg.u.unlock_indication));
        pMsgEx->Msg.u.unlock_indication.conference_id = conference_id;
                pMsgEx->Msg.u.unlock_indication.requesting_node_id = source_node_id;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfUnlockIndication, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConfUnlockConfirm()
 *
 *      Public Function Descrpition
 *              This function is called by the CConf when it need to send a
 *              conference unlock confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfUnlockConfirm
(
        GCCResult                       result,
        GCCConfID           conference_id
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfUnlockConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_UNLOCK_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_UNLOCK_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.unlock_confirm), sizeof(pMsgEx->Msg.u.unlock_confirm));
        pMsgEx->Msg.u.unlock_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.unlock_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfUnlockConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfPermissionToAnnounce ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference permission to announce to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfPermissionToAnnounce
(
        GCCConfID           conference_id,
        UserID                          node_id
)
{
        GCCError            rc;
        GCCCtrlSapMsgEx     *pMsgEx;

        DebugEntry(CControlSAP::ConfPermissionToAnnounce);

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_PERMIT_TO_ANNOUNCE_PRESENCE)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.permit_to_announce_presence), sizeof(pMsgEx->Msg.u.permit_to_announce_presence));
        pMsgEx->Msg.nConfID = conference_id;
                pMsgEx->Msg.u.permit_to_announce_presence.conference_id= conference_id;
                pMsgEx->Msg.u.permit_to_announce_presence.node_id =  node_id;

        //
        // LONCHANC: We should treat it as a confirm, even though it is
        // an indication. When this node is a top provider, we may send this
        // message in the middle of doing something. In essence, it behaves
        // like a confirm.
        //

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

        DebugExitINT(CControlSAP::ConfPermissionToAnnounce, rc);
        return rc;
}


/*
 *      ConfAnnouncePresenceConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference announce presence confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfAnnouncePresenceConfirm
(
        GCCConfID           conference_id,
        GCCResult                       result
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfAnnouncePresenceConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_ANNOUNCE_PRESENCE_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_ANNOUNCE_PRESENCE_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.announce_presence_confirm), sizeof(pMsgEx->Msg.u.announce_presence_confirm));
        pMsgEx->Msg.nConfID = conference_id;
                pMsgEx->Msg.u.announce_presence_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.announce_presence_confirm.result =  result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
                rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfAnnouncePresenceConfirm, rc);
        return rc;
}


/*
 *      ConfTerminateConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference terminate confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfTerminateConfirm
(
        GCCConfID                       conference_id,
        GCCResult                               result
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfTerminateConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_TERMINATE_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TERMINATE_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.terminate_confirm), sizeof(pMsgEx->Msg.u.terminate_confirm));
        pMsgEx->Msg.nConfID = conference_id;
                pMsgEx->Msg.u.terminate_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.terminate_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfTerminateConfirm, rc);
        return rc;
}


/*
 *      ConfEjectUserIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference eject user indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfEjectUserIndication
(
        GCCConfID                       conference_id,
        GCCReason                               reason,
        UserID                                  gcc_node_id
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfEjectUserIndication);

#ifdef GCCNC_DIRECT_INDICATION

    //
    // WPARAM: reason, ejected node ID.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_EJECT_USER_INDICATION, reason, gcc_node_id, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_EJECT_USER_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.eject_user_indication), sizeof(pMsgEx->Msg.u.eject_user_indication));
        pMsgEx->Msg.nConfID = conference_id;
                pMsgEx->Msg.u.eject_user_indication.conference_id = conference_id;
                pMsgEx->Msg.u.eject_user_indication.ejected_node_id = gcc_node_id;
                pMsgEx->Msg.u.eject_user_indication.reason = reason;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfEjectUserIndication, rc);
        return rc;
}


/*
 *      ConfEjectUserConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference eject user confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfEjectUserConfirm
(
        GCCConfID                       conference_id,
        UserID                                  ejected_node_id,
        GCCResult                               result
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfEjectUserConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: LOWORD=result. HIWORD=nid.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_EJECT_USER_CONFIRM, result, ejected_node_id, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_EJECT_USER_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.eject_user_confirm), sizeof(pMsgEx->Msg.u.eject_user_confirm));
                pMsgEx->Msg.u.eject_user_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.eject_user_confirm.ejected_node_id = ejected_node_id;
                pMsgEx->Msg.u.eject_user_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfEjectUserConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorAssignConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conductor assign confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorAssignConfirm
(
        GCCResult                               result,
        GCCConfID                       conference_id
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConductorAssignConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_CONDUCT_ASSIGN_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_ASSIGN_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_assign_confirm), sizeof(pMsgEx->Msg.u.conduct_assign_confirm));
                pMsgEx->Msg.u.conduct_assign_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_assign_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConductorAssignConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorReleaseConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conductor release confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorReleaseConfirm
(
        GCCResult                               result,
        GCCConfID                       conference_id
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConductorReleaseConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_CONDUCT_RELEASE_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_RELEASE_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_release_confirm), sizeof(pMsgEx->Msg.u.conduct_release_confirm));
                pMsgEx->Msg.u.conduct_release_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_release_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConductorReleaseConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorPleaseIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conductor please indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorPleaseIndication
(
        GCCConfID                       conference_id,
        UserID                                  requester_node_id
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConductorPleaseIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_CONDUCT_PLEASE_INDICATION;

    Msg.u.conduct_please_indication.conference_id = conference_id;
    Msg.u.conduct_please_indication.requester_node_id = requester_node_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_PLEASE_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_please_indication), sizeof(pMsgEx->Msg.u.conduct_please_indication));
                pMsgEx->Msg.u.conduct_please_indication.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_please_indication.requester_node_id = requester_node_id;

                //      Queue up the message for delivery to the Node Controller.
                PostCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConductorPleaseIndication, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorPleaseConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conductor please confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorPleaseConfirm
(
        GCCResult                               result,
        GCCConfID                       conference_id
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConductorPleaseConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_CONDUCT_PLEASE_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_PLEASE_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_please_confirm), sizeof(pMsgEx->Msg.u.conduct_please_confirm));
                pMsgEx->Msg.u.conduct_please_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_please_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConductorPleaseConfirm, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConductorGiveIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conductor give indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConductorGiveIndication ( GCCConfID conference_id )
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConductorGiveIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_CONDUCT_GIVE_INDICATION;

    Msg.u.conduct_give_indication.conference_id = conference_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_GIVE_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_give_indication), sizeof(pMsgEx->Msg.u.conduct_give_indication));
                pMsgEx->Msg.u.conduct_give_indication.conference_id = conference_id;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConductorGiveIndication, rc);
        return rc;
}


/*
 *      ConductorGiveConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conductor give confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorGiveConfirm
(
        GCCResult                               result,
        GCCConfID                       conference_id,
        UserID                                  recipient_node
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConductorGiveConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: LOWORD=result. HIWORD=nid.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_CONDUCT_GIVE_CONFIRM, result, recipient_node, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_GIVE_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_give_confirm), sizeof(pMsgEx->Msg.u.conduct_give_confirm));
                pMsgEx->Msg.u.conduct_give_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_give_confirm.result = result;
                pMsgEx->Msg.u.conduct_give_confirm.recipient_node_id = recipient_node;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConductorGiveConfirm, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConductorPermitAskIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conductor permit ask indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorPermitAskIndication
(
        GCCConfID                       conference_id,
        BOOL                                    grant_flag,
        UserID                                  requester_id
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConductorPermitAskIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_CONDUCT_ASK_INDICATION;

    Msg.u.conduct_permit_ask_indication.conference_id = conference_id;
    Msg.u.conduct_permit_ask_indication.permission_is_granted = grant_flag;
    Msg.u.conduct_permit_ask_indication.requester_node_id = requester_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_ASK_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_permit_ask_indication), sizeof(pMsgEx->Msg.u.conduct_permit_ask_indication));
                pMsgEx->Msg.u.conduct_permit_ask_indication.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_permit_ask_indication.permission_is_granted = grant_flag;
                pMsgEx->Msg.u.conduct_permit_ask_indication.requester_node_id = requester_id;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConductorPermitAskIndication, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorPermitAskConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conductor permit ask confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorPermitAskConfirm
(
        GCCResult                               result,
        BOOL                                    grant_permission,
        GCCConfID                       conference_id
)
{
        GCCError            rc;
        GCCCtrlSapMsgEx     *pMsgEx;

        DebugEntry(CControlSAP::ConductorPermitAskConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: LOWORD=result. HIWORD=permission.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_CONDUCT_ASK_CONFIRM, result, grant_permission, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_ASK_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_permit_ask_confirm), sizeof(pMsgEx->Msg.u.conduct_permit_ask_confirm));
                pMsgEx->Msg.u.conduct_permit_ask_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_permit_ask_confirm.result = result;
                pMsgEx->Msg.u.conduct_permit_ask_confirm.permission_is_granted = grant_permission;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConductorPermitAskConfirm, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConductorPermitGrantConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conductor permit grant confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorPermitGrantConfirm
(
        GCCResult                               result,
        GCCConfID                       conference_id
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConductorPermitGrantConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_CONDUCT_GRANT_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_GRANT_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_permit_grant_confirm), sizeof(pMsgEx->Msg.u.conduct_permit_grant_confirm));
                pMsgEx->Msg.u.conduct_permit_grant_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_permit_grant_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
    {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConductorPermitGrantConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfTimeRemainingIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference time remaining indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfTimeRemainingIndication
(
        GCCConfID                       conference_id,
        UserID                                  source_node_id,
        UserID                                  node_id,
        UINT                                    time_remaining
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfTimeRemainingIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_TIME_REMAINING_INDICATION;

    Msg.u.time_remaining_indication.conference_id = conference_id;
    Msg.u.time_remaining_indication.source_node_id= source_node_id;
    Msg.u.time_remaining_indication.node_id = node_id;
    Msg.u.time_remaining_indication.time_remaining= time_remaining;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        //GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TIME_REMAINING_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.time_remaining_indication), sizeof(pMsgEx->Msg.u.time_remaining_indication));
                pMsgEx->Msg.u.time_remaining_indication.conference_id = conference_id;
                pMsgEx->Msg.u.time_remaining_indication.source_node_id= source_node_id;
                pMsgEx->Msg.u.time_remaining_indication.node_id = node_id;
                pMsgEx->Msg.u.time_remaining_indication.time_remaining= time_remaining;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfTimeRemainingIndication, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfTimeRemainingConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference time remaining confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfTimeRemainingConfirm
(
        GCCConfID                       conference_id,
        GCCResult                               result
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfTimeRemainingConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_TIME_REMAINING_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TIME_REMAINING_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.time_remaining_confirm), sizeof(pMsgEx->Msg.u.time_remaining_confirm));
                pMsgEx->Msg.u.time_remaining_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.time_remaining_confirm.result= result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
                rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfTimeRemainingConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfTimeInquireIndication()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference time inquire indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfTimeInquireIndication
(
        GCCConfID               conference_id,
        BOOL                            time_is_conference_wide,
        UserID                          requesting_node_id
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfTimeInquireIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_TIME_INQUIRE_INDICATION;

    Msg.u.time_inquire_indication.conference_id = conference_id;
    Msg.u.time_inquire_indication.time_is_conference_wide = time_is_conference_wide;
    Msg.u.time_inquire_indication.requesting_node_id = requesting_node_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TIME_INQUIRE_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.time_inquire_indication), sizeof(pMsgEx->Msg.u.time_inquire_indication));
                pMsgEx->Msg.u.time_inquire_indication.conference_id = conference_id;
                pMsgEx->Msg.u.time_inquire_indication.time_is_conference_wide = time_is_conference_wide;
                pMsgEx->Msg.u.time_inquire_indication.requesting_node_id = requesting_node_id;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfTimeInquireIndication, rc);
        return rc;
}


/*
 *      ConfTimeInquireConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference time inquire confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfTimeInquireConfirm
(
        GCCConfID                       conference_id,
        GCCResult                               result
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfTimeInquireConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_TIME_INQUIRE_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TIME_INQUIRE_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.time_inquire_confirm), sizeof(pMsgEx->Msg.u.time_inquire_confirm));
                pMsgEx->Msg.u.time_inquire_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.time_inquire_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfTimeInquireConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfExtendIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference extend indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfExtendIndication
(
        GCCConfID                       conference_id,
        UINT                                    extension_time,
        BOOL                                    time_is_conference_wide,
        UserID                  requesting_node_id
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfExtendIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_CONFERENCE_EXTEND_INDICATION;

    Msg.u.conference_extend_indication.conference_id = conference_id;
    Msg.u.conference_extend_indication.extension_time = extension_time;
    Msg.u.conference_extend_indication.time_is_conference_wide = time_is_conference_wide;
    Msg.u.conference_extend_indication.requesting_node_id = requesting_node_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONFERENCE_EXTEND_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conference_extend_indication), sizeof(pMsgEx->Msg.u.conference_extend_indication));
                pMsgEx->Msg.u.conference_extend_indication.conference_id = conference_id;
                pMsgEx->Msg.u.conference_extend_indication.extension_time = extension_time;
                pMsgEx->Msg.u.conference_extend_indication.time_is_conference_wide = time_is_conference_wide;
                pMsgEx->Msg.u.conference_extend_indication.requesting_node_id = requesting_node_id;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfExtendIndication, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfExtendConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference extend confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfExtendConfirm
(
        GCCConfID                       conference_id,
        UINT                                    extension_time,
        GCCResult                               result
)
{
        GCCError            rc;
        GCCCtrlSapMsgEx     *pMsgEx;

        DebugEntry(CControlSAP::ConfExtendConfirm);

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONFERENCE_EXTEND_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conference_extend_confirm), sizeof(pMsgEx->Msg.u.conference_extend_confirm));
                pMsgEx->Msg.u.conference_extend_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.conference_extend_confirm.extension_time = extension_time;
                pMsgEx->Msg.u.conference_extend_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

        DebugExitINT(CControlSAP::ConfExtendConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfAssistanceIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference assistance indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfAssistanceIndication
(
        GCCConfID                       conference_id,
        CUserDataListContainer  *user_data_list,
        UserID                                  source_node_id
)
{
    GCCError    rc;

    DebugEntry(CControlSAP::ConfAssistanceIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_ASSISTANCE_INDICATION;

    rc = GCC_NO_ERROR;

    //  Copy the User Data if it exists.
    LPBYTE pUserDataMemory = NULL;
    if (user_data_list != NULL)
    {
        rc = RetrieveUserDataList(
                    user_data_list,
                    &(Msg.u.conference_assist_indication.number_of_user_data_members),
                    &(Msg.u.conference_assist_indication.user_data_list),
                    &pUserDataMemory);
        ASSERT(GCC_NO_ERROR == rc);
    }
    else
    {
        Msg.u.conference_assist_indication.number_of_user_data_members = 0;
        Msg.u.conference_assist_indication.user_data_list = NULL;
    }

    if (GCC_NO_ERROR == rc)
    {
        Msg.u.conference_assist_indication.conference_id = conference_id;
        Msg.u.conference_assist_indication.source_node_id = source_node_id;

        SendCtrlSapMsg(&Msg);

        delete pUserDataMemory;
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_ASSISTANCE_INDICATION)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.conference_assist_indication), sizeof(pMsgEx->Msg.u.conference_assist_indication));

        rc = GCC_NO_ERROR;

        //      Copy the User Data if it exists.
        if (user_data_list != NULL)
        {
                rc = RetrieveUserDataList(
                        user_data_list,
                        &(pMsgEx->Msg.u.conference_assist_indication.number_of_user_data_members),
                        &(pMsgEx->Msg.u.conference_assist_indication.user_data_list),
                        &(pMsgEx->pToDelete->user_data_list_memory));
                ASSERT(GCC_NO_ERROR == rc);
        }
        else
        {
                // pMsgEx->Msg.u.conference_assist_indication.number_of_user_data_members = 0;
                // pMsgEx->Msg.u.conference_assist_indication.user_data_list = NULL;
        }

        if (GCC_NO_ERROR == rc)
        {
                pMsgEx->Msg.u.conference_assist_indication.conference_id = conference_id;
                pMsgEx->Msg.u.conference_assist_indication.source_node_id = source_node_id;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        }
    }
    else
    {
        ERROR_OUT(("CControlSAP::ConfAssistanceIndication: can't create CreateCtrlSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

        /*
        **      Clean up after any resource allocation error which may have occurred.
        */
        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfAssistanceIndication, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConfAssistanceConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference assistance confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfAssistanceConfirm
(
        GCCConfID               conference_id,
        GCCResult                               result
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfAssistanceConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_ASSISTANCE_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_ASSISTANCE_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conference_assist_confirm), sizeof(pMsgEx->Msg.u.conference_assist_confirm));
                pMsgEx->Msg.u.conference_assist_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.conference_assist_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfAssistanceConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      TextMessageIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              text message indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::TextMessageIndication
(
        GCCConfID                                       conference_id,
        LPWSTR                                                  pwszTextMsg,
        UserID                                                  source_node_id
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::TextMessageIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_TEXT_MESSAGE_INDICATION;

    Msg.u.text_message_indication.text_message = pwszTextMsg;
    Msg.u.text_message_indication.conference_id = conference_id;
    Msg.u.text_message_indication.source_node_id = source_node_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TEXT_MESSAGE_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.text_message_indication), sizeof(pMsgEx->Msg.u.text_message_indication));

        if (NULL != (pMsgEx->Msg.u.text_message_indication.text_message = ::My_strdupW(pwszTextMsg)))
                {
                        pMsgEx->Msg.u.text_message_indication.conference_id = conference_id;
                        pMsgEx->Msg.u.text_message_indication.source_node_id = source_node_id;

                        //      Queue up the message for delivery to the Node Controller.
                        PostIndCtrlSapMsg(pMsgEx);
            rc = GCC_NO_ERROR;
                }
        }
    else
        {
            rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::TextMessageIndication, rc);
        return rc;
}
#endif // JASPER

/*
 *      TextMessageConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              text message confirm to the node controller. It adds the message
 *              to a queue of messages to be sent to the node controller in the
 *              next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::TextMessageConfirm
(
        GCCConfID                                       conference_id,
        GCCResult                                               result
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::TextMessageConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_TEXT_MESSAGE_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TEXT_MESSAGE_CONFIRM)))
    {
        // ::ZeroMemory(&(pMsgEx->Msg.u.text_message_confirm), sizeof(pMsgEx->Msg.u.text_message_confirm));
                pMsgEx->Msg.u.text_message_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.text_message_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::TextMessageConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfTransferIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference transfer indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfTransferIndication
(
        GCCConfID                   conference_id,
        PGCCConferenceName          destination_conference_name,
        GCCNumericString            destination_conference_modifier,
        CNetAddrListContainer   *destination_address_list,
        CPassword               *password
)
{
    GCCError                    rc = GCC_NO_ERROR;

    DebugEntry(CControlSAP::ConfTransferIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_TRANSFER_INDICATION;

    //
    // Copy the information that needs to be sent to the node
    // controller into local memory that can be deleted once the
    // information to be sent to the application is flushed.  Note that
    // if an error      occurs in one call to "CopyDataToGCCMessage" then no
    // action is taken on subsequent calls to that routine.
    //

    //  Copy the conference name
    ::CSAP_CopyDataToGCCMessage_ConfName(
            destination_conference_name,
            &(Msg.u.transfer_indication.destination_conference_name));

    //  Copy the conference name modifier
    ::CSAP_CopyDataToGCCMessage_Modifier(
            destination_conference_modifier,
            &(Msg.u.transfer_indication.destination_conference_modifier));

    //  Copy the Password
    ::CSAP_CopyDataToGCCMessage_Password(
            password,
            &(Msg.u.transfer_indication.password));

    LPBYTE pDstAddrListData = NULL;
    if (destination_address_list != NULL)
    {
        //
        // First determine the size of the block required to hold all
        // of the network address list data.
        //
        UINT block_size = destination_address_list->LockNetworkAddressList();

        DBG_SAVE_FILE_LINE
        if (NULL != (pDstAddrListData = new BYTE[block_size]))
        {
            destination_address_list->GetNetworkAddressListAPI(
                &(Msg.u.transfer_indication.number_of_destination_addresses),
                &(Msg.u.transfer_indication.destination_address_list),
                pDstAddrListData);
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfTransferIndication: can't create net addr memory, size=%u", (UINT) block_size));
            rc = GCC_ALLOCATION_FAILURE;
        }

        // Unlock the network address list data.
        destination_address_list->UnLockNetworkAddressList();
    }
    else
    {
        Msg.u.transfer_indication.number_of_destination_addresses = 0;
        Msg.u.transfer_indication.destination_address_list = NULL;
    }

    if (rc == GCC_NO_ERROR)
    {
        Msg.u.transfer_indication.conference_id = conference_id;

        SendCtrlSapMsg(&Msg);

        delete pDstAddrListData;
    }

#else

    GCCCtrlSapMsgEx     *pMsgEx;
        UINT                            block_size;

        /*
        **      Allocate the GCC callback message and fill it in with the
        **      appropriate values.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TRANSFER_INDICATION, TRUE)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.transfer_indication), sizeof(pMsgEx->Msg.u.transfer_indication));

        /*
                **      Copy the information that needs to be sent to the node
                **      controller into local memory that can be deleted once the
                **      information to be sent to the application is flushed.  Note that
                **      if an error     occurs in one call to "CopyDataToGCCMessage" then no
                **      action is taken on subsequent calls to that routine.
                */

                //      Copy the conference name
                ::CSAP_CopyDataToGCCMessage_ConfName(
                                pMsgEx->pToDelete,
                                destination_conference_name,
                                &(pMsgEx->Msg.u.transfer_indication.destination_conference_name),
                                &rc);

                //      Copy the conference name modifier
                ::CSAP_CopyDataToGCCMessage_Modifier(
                                FALSE,  // conference modifier
                                pMsgEx->pToDelete,
                                destination_conference_modifier,
                                &(pMsgEx->Msg.u.transfer_indication.destination_conference_modifier),
                                &rc);

                //      Copy the Password
                ::CSAP_CopyDataToGCCMessage_Password(
                                FALSE,  // non-convener password
                                pMsgEx->pToDelete,
                                password,
                                &(pMsgEx->Msg.u.transfer_indication.password),
                                &rc);

                if ((rc == GCC_NO_ERROR) &&
                        (destination_address_list != NULL))
                {
                        /*
                        **      First determine the size of the block required to hold all
                        **      of the network address list data.
                        */
                        block_size = destination_address_list->LockNetworkAddressList();

            DBG_SAVE_FILE_LINE
                        if (NULL != (pMsgEx->pBuf = new BYTE[block_size]))
                        {
                                destination_address_list->GetNetworkAddressListAPI(
                                        &(pMsgEx->Msg.u.transfer_indication.number_of_destination_addresses),
                                        &(pMsgEx->Msg.u.transfer_indication.destination_address_list),
                                        pMsgEx->pBuf);
                        }
                        else
                        {
                            ERROR_OUT(("CControlSAP::ConfTransferIndication: can't create net addr memory, size=%u", (UINT) block_size));
                                rc = GCC_ALLOCATION_FAILURE;
                        }

                        // Unlock the network address list data.
                        destination_address_list->UnLockNetworkAddressList();
                }
                else
                {
                        // pMsgEx->Msg.u.transfer_indication.number_of_destination_addresses = 0;
                        // pMsgEx->Msg.u.transfer_indication.destination_address_list = NULL;
                }

                if (rc == GCC_NO_ERROR)
                {
                        pMsgEx->Msg.u.transfer_indication.conference_id = conference_id;

                        //      Queue up the message for delivery to the Node Controller.
                        PostIndCtrlSapMsg(pMsgEx);
                }
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfTransferIndication: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfTransferIndication, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfTransferConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference transfer confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfTransferConfirm
(
        GCCConfID                       conference_id,
        PGCCConferenceName              destination_conference_name,
        GCCNumericString                destination_conference_modifier,
        UINT                                    number_of_destination_nodes,
        PUserID                                 destination_node_list,
        GCCResult                               result
)
{
        GCCError                        rc = GCC_NO_ERROR;
        GCCCtrlSapMsgEx     *pMsgEx;
        UINT                            i;

        DebugEntry(CControlSAP::ConfTransferConfirm);

        /*
        **      Allocate the GCC callback message and fill it in with the
        **      appropriate values.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TRANSFER_CONFIRM, TRUE)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.transfer_confirm), sizeof(pMsgEx->Msg.u.transfer_confirm));

        /*
                **      Copy the information that needs to be sent to the node
                **      controller into local memory that can be deleted once the
                **      information to be sent to the application is flushed.  Note that
                **      if an error     occurs in one call to "CopyDataToGCCMessage" then no
                **      action is taken on subsequent calls to that routine.
                */

                //      Copy the conference name
                ::CSAP_CopyDataToGCCMessage_ConfName(
                                pMsgEx->pToDelete,
                                destination_conference_name,
                                &(pMsgEx->Msg.u.transfer_confirm.destination_conference_name),
                                &rc);

                //      Copy the conference name modifier
                ::CSAP_CopyDataToGCCMessage_Modifier(
                                FALSE,  // conference modifier
                                pMsgEx->pToDelete,
                                destination_conference_modifier,
                                &(pMsgEx->Msg.u.transfer_confirm.destination_conference_modifier),
                                &rc);

                if ((rc == GCC_NO_ERROR) &&
                        (number_of_destination_nodes != 0))
                {
                        //      Allocate memory to hold the list of nodes.
                        DBG_SAVE_FILE_LINE
                        if (NULL != (pMsgEx->pBuf = new BYTE[number_of_destination_nodes * sizeof (UserID)]))
                        {
                                /*
                                 * Retrieve the actual pointer to memory from the Memory
                                 * object.
                                 */
                                pMsgEx->Msg.u.transfer_confirm.destination_node_list = (UserID *) pMsgEx->pBuf;

                                for (i = 0; i < number_of_destination_nodes; i++)
                                {
                                        pMsgEx->Msg.u.transfer_confirm.destination_node_list[i] = destination_node_list[i];
                                }
                        }
                        else
                        {
                                ERROR_OUT(("CControlSAP::ConfTransferConfirm: Error allocating memory"));
                                rc = GCC_ALLOCATION_FAILURE;
                        }
                }

                if (rc == GCC_NO_ERROR)
                {
                        pMsgEx->Msg.u.transfer_confirm.number_of_destination_nodes = number_of_destination_nodes;
                        pMsgEx->Msg.u.transfer_confirm.conference_id = conference_id;
                        pMsgEx->Msg.u.transfer_confirm.result = result;

                        //      Queue up the message for delivery to the Node Controller.
                        PostConfirmCtrlSapMsg(pMsgEx);
                }
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfTransferConfirm: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure();
        }

        DebugExitINT(CControlSAP::ConfTransferConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfAddIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference add indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfAddIndication
(
        GCCConfID                   conference_id,
        GCCResponseTag              add_response_tag,
        CNetAddrListContainer   *network_address_list,
        CUserDataListContainer  *user_data_list,
        UserID                              requesting_node
)
{
        GCCError                        rc = GCC_NO_ERROR;

        DebugEntry(CControlSAP::ConfAddIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_ADD_INDICATION;

    //
    // First determine the size of the block required to hold all
    // of the network address list data.
    //
    UINT block_size = network_address_list->LockNetworkAddressList();

    //
    // Add the size of the user data block if any user data exists
    //
    if (user_data_list != NULL)
    {
        block_size += user_data_list->LockUserDataList();
    }

    //
    // Allocate memory to hold the user data and network addresses.
    //
    LPBYTE pData;

    DBG_SAVE_FILE_LINE
    if (NULL != (pData = new BYTE[block_size]))
    {
        LPBYTE pDataTemp = pData;
        //
        // Retrieve the network address list data from the container
        // and unlock the container data.
        //
        pDataTemp += network_address_list->GetNetworkAddressListAPI(
                        &(Msg.u.add_indication.number_of_network_addresses),
                        &(Msg.u.add_indication.network_address_list),
                        pData);

        network_address_list->UnLockNetworkAddressList();

        //
        // Retrieve the user data from the container if it exists
        // and unlock the container data.
        //
        if (user_data_list != NULL)
        {
            user_data_list->GetUserDataList(
                    &(Msg.u.add_indication.number_of_user_data_members),
                    &(Msg.u.add_indication.user_data_list),
                    pDataTemp);

            user_data_list->UnLockUserDataList();
        }
        else
        {
            Msg.u.add_indication.number_of_user_data_members = 0;
            Msg.u.add_indication.user_data_list = NULL;
        }

        Msg.u.add_indication.conference_id = conference_id;
        Msg.u.add_indication.requesting_node_id = requesting_node;
        Msg.u.add_indication.add_response_tag = add_response_tag;

        SendCtrlSapMsg(&Msg);
        rc = GCC_NO_ERROR;

        delete [] pData;
    }
    else
    {
        ERROR_OUT(("CControlSAP::ConfAddIndication: can't allocate buffer, size=%u", (UINT) block_size));
        rc = GCC_ALLOCATION_FAILURE;
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;
        UINT                            block_size;
        LPBYTE                          memory_ptr;

        /*
        **      Allocate the GCC callback message and fill it in with the
        **      appropriate values.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_ADD_INDICATION)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.add_indication), sizeof(pMsgEx->Msg.u.add_indication));

        /*
                **      First determine the size of the block required to hold all
                **      of the network address list data.
                */
                block_size = network_address_list->LockNetworkAddressList();

                /*
                **      Add the size of the user data block if any user data exists
                */
                if (user_data_list != NULL)
                {
                        block_size += user_data_list->LockUserDataList();
                }

                /*
                **      Allocate memory to hold the user data and network addresses.
                */
                DBG_SAVE_FILE_LINE
                if (NULL != (pMsgEx->pBuf = new BYTE[block_size]))
                {
                    memory_ptr = pMsgEx->pBuf;

                        /*
                         * Retrieve the network address list data from the container
                         * and unlock the container data.
                         */                     
                        memory_ptr += network_address_list->GetNetworkAddressListAPI(
                                                &(pMsgEx->Msg.u.add_indication.number_of_network_addresses),
                                                &(pMsgEx->Msg.u.add_indication.network_address_list),
                                                memory_ptr);

                        network_address_list->UnLockNetworkAddressList();

                        /*
                         * Retrieve the user data from the container if it exists
                         * and unlock the container data.
                         */
                        if (user_data_list != NULL)
                        {
                                user_data_list->GetUserDataList(
                                                        &(pMsgEx->Msg.u.add_indication.number_of_user_data_members),
                                                        &(pMsgEx->Msg.u.add_indication.user_data_list),
                                                        memory_ptr);

                                user_data_list->UnLockUserDataList();
                        }
                        else
                        {
                                // pMsgEx->Msg.u.add_indication.number_of_user_data_members = 0;
                                // pMsgEx->Msg.u.add_indication.user_data_list = NULL;
                        }

                        pMsgEx->Msg.u.add_indication.conference_id = conference_id;
                        pMsgEx->Msg.u.add_indication.requesting_node_id = requesting_node;
                        pMsgEx->Msg.u.add_indication.add_response_tag = add_response_tag;

                        //      Queue up the message for delivery to the Node Controller.
                        PostIndCtrlSapMsg(pMsgEx);
                rc = GCC_NO_ERROR;
                }
                else
                {
            ERROR_OUT(("CControlSAP::ConfAddIndication: can't allocate buffer, size=%u", (UINT) block_size));
                        rc = GCC_ALLOCATION_FAILURE;
                }
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfAddIndication: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfAddIndication, rc);
        return rc;
}


/*
 *      ConfAddConfirm
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference add confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfAddConfirm
(
        GCCConfID                   conference_id,
        CNetAddrListContainer   *network_address_list,
        CUserDataListContainer  *user_data_list,
        GCCResult                           result
)
{
        GCCError                        rc = GCC_NO_ERROR;

        DebugEntry(CControlSAP::ConfAddConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_ADD_CONFIRM;

    //
    // First determine the size of the block required to hold all
    // of the network address list data.
    //
    UINT cbDataSize = network_address_list->LockNetworkAddressList();

    //
    // Add the size of the user data block if any user data exists
    //
    if (user_data_list != NULL)
    {
        cbDataSize += user_data_list->LockUserDataList();
    }

    //
    // Allocate memory to hold the user data and network addresses.
    //
    DBG_SAVE_FILE_LINE
    LPBYTE pAllocated = new BYTE[cbDataSize];
    LPBYTE pData;
    if (NULL != (pData = pAllocated))
    {
        //
        // Retrieve the network address list data from the container
        // and unlock the container data.
        //
        pData += network_address_list->GetNetworkAddressListAPI(
                    &(Msg.u.add_confirm.number_of_network_addresses),
                    &(Msg.u.add_confirm.network_address_list),
                    pData);

        network_address_list->UnLockNetworkAddressList();

        //
        // Retrieve the user data from the container if it exists
        // and unlock the container data.
        //
        if (user_data_list != NULL)
        {
            user_data_list->GetUserDataList(
                &(Msg.u.add_confirm.number_of_user_data_members),
                &(Msg.u.add_confirm.user_data_list),
                pData);

            user_data_list->UnLockUserDataList();
        }
        else
        {
            Msg.u.add_confirm.number_of_user_data_members = 0;
            Msg.u.add_confirm.user_data_list = NULL;
        }

        Msg.nConfID = conference_id;
        Msg.u.add_confirm.conference_id = conference_id;
        Msg.u.add_confirm.result = result;

        SendCtrlSapMsg(&Msg);
        rc = GCC_NO_ERROR;

        // clean up
        delete [] pAllocated;
    }
    else
    {
        ERROR_OUT(("CControlSAP::ConfAddConfirm: can't allocate buffer, size=%u", (UINT) cbDataSize));
        rc = GCC_ALLOCATION_FAILURE;
        HandleResourceFailure(rc);
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;
        UINT                            block_size;
        LPBYTE                          memory_ptr;

        /*
        **      Allocate the GCC callback message and fill it in with the
        **      appropriate values.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_ADD_CONFIRM)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.add_confirm), sizeof(pMsgEx->Msg.u.add_confirm));

        /*
                **      First determine the size of the block required to hold all
                **      of the network address list data.
                */
                block_size = network_address_list->LockNetworkAddressList();

                /*
                **      Add the size of the user data block if any user data exists
                */
                if (user_data_list != NULL)
                        block_size += user_data_list->LockUserDataList();

                /*
                **      Allocate memory to hold the user data and network addresses.
                */
                DBG_SAVE_FILE_LINE
                if (NULL != (pMsgEx->pBuf = (LPBYTE) new BYTE[block_size]))
                {
                        memory_ptr = pMsgEx->pBuf;

                        /*
                         * Retrieve the network address list data from the container
                         * and unlock the container data.
                         */                     
                        memory_ptr += network_address_list->GetNetworkAddressListAPI(
                                                &(pMsgEx->Msg.u.add_confirm.number_of_network_addresses),
                                                &(pMsgEx->Msg.u.add_confirm.network_address_list),
                                                memory_ptr);

                        network_address_list->UnLockNetworkAddressList();

                        /*
                         * Retrieve the user data from the container if it exists
                         * and unlock the container data.
                         */
                        if (user_data_list != NULL)
                        {
                                user_data_list->GetUserDataList(
                                                        &(pMsgEx->Msg.u.add_confirm.number_of_user_data_members),
                                                        &(pMsgEx->Msg.u.add_confirm.user_data_list),
                                                        memory_ptr);

                                user_data_list->UnLockUserDataList();
                        }
                        else
                        {
                                // pMsgEx->Msg.u.add_confirm.number_of_user_data_members = 0;
                                // pMsgEx->Msg.u.add_confirm.user_data_list = NULL;
                        }
            pMsgEx->Msg.nConfID = conference_id;
                        pMsgEx->Msg.u.add_confirm.conference_id = conference_id;
                        pMsgEx->Msg.u.add_confirm.result = result;

                        //      Queue up the message for delivery to the Node Controller.
                        PostConfirmCtrlSapMsg(pMsgEx);
                rc = GCC_NO_ERROR;
                }
                else
                {
                    ERROR_OUT(("CControlSAP::ConfAddConfirm: can't allocate buffer, size=%u", (UINT) block_size));
                        rc = GCC_ALLOCATION_FAILURE;
                }
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfAddConfirm: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfAddConfirm, rc);
        return rc;
}


/*
 *      SubInitializationCompleteIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              sub-initialization complete indication to the node controller. It adds
 *              the message     to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::SubInitializationCompleteIndication
(
        UserID                          user_id,
        ConnectionHandle        connection_handle
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::SubInitializationCompleteIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_SUB_INITIALIZED_INDICATION;

    Msg.u.conf_sub_initialized_indication.subordinate_node_id = user_id;
    Msg.u.conf_sub_initialized_indication.connection_handle =connection_handle;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_SUB_INITIALIZED_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conf_sub_initialized_indication), sizeof(pMsgEx->Msg.u.conf_sub_initialized_indication));
                pMsgEx->Msg.u.conf_sub_initialized_indication.subordinate_node_id = user_id;
                pMsgEx->Msg.u.conf_sub_initialized_indication.connection_handle =connection_handle;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::SubInitializationCompleteIndication, rc);
        return rc;
}


/*
 *      Private member functions of the CControlSAP object.
 */

/*
 *      BOOL            CControlSAP::IsNumericNameValid(        
 *                                                                              GCCNumericString        numeric_string)
 *
 *      Public member function of CControlSAP.
 *
 *      Function Description:
 *              This routine is used to validate a numeric string by checking to make
 *              sure that none of the constraints imposed by the ASN.1 specification
 *              are violated.
 *
 *      Formal Parameters:
 *              numeric_string          (i)     The numeric string to validate.
 *
 *      Return Value:
 *              TRUE                            - The numeric string is valid.
 *              FALSE                           - The numeric string violates an ASN.1 constraint.
 *
 *  Side Effects:
 *              None.
 *
 *      Caveats:
 *              None.
 */
BOOL CControlSAP::IsNumericNameValid ( GCCNumericString numeric_string )
{
        BOOL                    rc = TRUE;
        UINT                    numeric_string_length = 0;

//
// LONCHANC: We should change it such that the default is FALSE
// because many cases except one can be FALSE.
//
        if (numeric_string != NULL)
        {
                if (*numeric_string == 0)
                        rc = FALSE;
                else
                {
                        while (*numeric_string != 0)
                        {
                                /*
                                **      Check to make sure the characters in the numeric string are
                                **      within the allowable range.
                                */
                                if ((*numeric_string < '0') ||
                                        (*numeric_string > '9'))
                                {
                                        rc = FALSE;
                                        break;
                                }
                        
                                numeric_string++;
                                numeric_string_length++;

                                /*
                                **      Check to make sure that the length of the string is within
                                **      the allowable range.
                                */
                                if (numeric_string_length > MAXIMUM_CONFERENCE_NAME_LENGTH)
                                {
                                        rc = FALSE;
                                        break;
                                }
                        }
                }
        }
        else
                rc = FALSE;
        
        return rc;
}


/*
 *      BOOL            CControlSAP::IsTextNameValid (LPWSTR text_string)
 *
 *      Public member function of CControlSAP.
 *
 *      Function Description:
 *              This routine is used to validate a text string by checking to make
 *              sure that none of the constraints imposed by the ASN.1 specification
 *              are violated.
 *
 *      Formal Parameters:
 *              text_string                     (i)     The text string to validate.
 *
 *      Return Value:
 *              TRUE                            - The text string is valid.
 *              FALSE                           - The text string violates an ASN.1 constraint.
 *
 *  Side Effects:
 *              None.
 *
 *      Caveats:
 *              None.
 */
BOOL CControlSAP::IsTextNameValid ( LPWSTR text_string )
{
        BOOL                    rc = TRUE;
        UINT                    text_string_length = 0;
        
        if (text_string != NULL)
        {
                /*
                **      Check to make sure that the length of the string is within
                **      the allowable range.
                */
                while (*text_string != 0)
                {
                        text_string++;
                        text_string_length++;

                        if (text_string_length > MAXIMUM_CONFERENCE_NAME_LENGTH)
                        {
                                rc = FALSE;
                                break;
                        }
                }
        }
        else
                rc = FALSE;
        
        return rc;
}


/*
 *      GCCError  CControlSAP::QueueJoinIndication(
 *                                                      GCCResponseTag                          response_tag,
 *                                                      GCCConfID                               conference_id,
 *                                                      CPassword                   *convener_password,
 *                                                      CPassword                   *password_challenge,
 *                                                      LPWSTR                                          pwszCallerID,
 *                                                      TransportAddress                        calling_address,
 *                                                      TransportAddress                        called_address,
 *                                                      CUserDataListContainer      *user_data_list,
 *                                                      BOOL                                            intermediate_node,
 *                                                      ConnectionHandle                        connection_handle)
 *
 *      Public member function of CControlSAP.
 *
 *      Function Description:
 *              This routine is used to place join indications into the queue of
 *              messages to be delivered to the node controller.
 *
 *      Formal Parameters:
 *              response_tag            (i) Unique tag associated with this join .
 *              conference_id           (i) The conference identifier.
 *              convener_password       (i) Password used to obtain convener privileges.
 *              password_challenge      (i) Password used to join the conference.
 *              pwszCallerID            (i) Identifier of party initiating call.
 *              calling_address         (i) Transport address of party making call.
 *              called_address          (i) Transport address of party being called.
 *              user_data_list          (i) User data carried in the join.
 *              intermediate_node       (i) Flag indicating whether join is made at
 *                                                                      intermediate node.
 *              connection_handle       (i) Handle for the logical connection.
 *
 *      Return Value:
 *              GCC_NO_ERROR                            - Message successfully queued.
 *              GCC_ALLOCATION_FAILURE          - A resource allocation failure occurred.
 *
 *  Side Effects:
 *              None.
 *
 *      Caveats:
 *              None.
 */
GCCError CControlSAP::QueueJoinIndication
(
        GCCResponseTag                          response_tag,
        GCCConfID                               conference_id,
        CPassword                   *convener_password,
        CPassword                   *password_challenge,
        LPWSTR                                          pwszCallerID,
        TransportAddress                        calling_address,
        TransportAddress                        called_address,
        CUserDataListContainer      *user_data_list,
        BOOL                                            intermediate_node,
        ConnectionHandle                        connection_handle
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::QueueJoinIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_JOIN_INDICATION;

    /*
    **  Copy the information that needs to be sent to the node
    **  controller into local memory that can be deleted once the
    **  information to be sent to the application is flushed.  Note that
    **  if an error     occurs in one call to "CopyDataToGCCMessage" then no
    **  action is taken on subsequent calls to that routine.
    */

    // start with success
    rc = GCC_NO_ERROR;

    //  Copy the Convener Password
    ::CSAP_CopyDataToGCCMessage_Password(
            convener_password,
            &(Msg.u.join_indication.convener_password));

    //  Copy the Password
    ::CSAP_CopyDataToGCCMessage_Challenge(
            password_challenge,
            &(Msg.u.join_indication.password_challenge));

    //  Copy the Caller Identifier
    ::CSAP_CopyDataToGCCMessage_IDvsDesc(
            pwszCallerID,
            &(Msg.u.join_indication.caller_identifier));

    //  Copy the Calling Address
    ::CSAP_CopyDataToGCCMessage_Call(
            calling_address,
            &(Msg.u.join_indication.calling_address));

    //  Copy the Called Address
    ::CSAP_CopyDataToGCCMessage_Call(
            called_address,
            &(Msg.u.join_indication.called_address));

    //  Copy the User Data if it exists.
    LPBYTE pUserDataMemory = NULL;
    if (user_data_list != NULL)
    {
        rc = RetrieveUserDataList(
                user_data_list,
                &(Msg.u.join_indication.number_of_user_data_members),
                &(Msg.u.join_indication.user_data_list),
                &pUserDataMemory);
    }
    else
    {
        Msg.u.join_indication.number_of_user_data_members = 0;
        Msg.u.join_indication.user_data_list = NULL;
    }

    if (GCC_NO_ERROR == rc)
    {
        /*
        **      Filling in the rest of the information that needs to be sent
        **      to the application.
        */
        Msg.u.join_indication.join_response_tag = response_tag;
        Msg.u.join_indication.conference_id = conference_id ;
        Msg.u.join_indication.node_is_intermediate = intermediate_node;
        Msg.u.join_indication.connection_handle = connection_handle;

        SendCtrlSapMsg(&Msg);

        delete pUserDataMemory;

        if (NULL != convener_password)
        {
            convener_password->UnLockPasswordData();
        }
        if (NULL != password_challenge)
        {
            password_challenge->UnLockPasswordData();
        }
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;

        /*
        **      Allocate the GCC callback message and fill it in with the
        **      appropriate values.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_JOIN_INDICATION, TRUE)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.join_indication), sizeof(pMsgEx->Msg.u.join_indication));

        /*
        **      Copy the information that needs to be sent to the node
        **      controller into local memory that can be deleted once the
        **      information to be sent to the application is flushed.  Note that
        **      if an error     occurs in one call to "CopyDataToGCCMessage" then no
        **      action is taken on subsequent calls to that routine.
        */

        // start with success
        rc = GCC_NO_ERROR;

        //      Copy the Convener Password
        ::CSAP_CopyDataToGCCMessage_Password(
                        TRUE,   // convener password
                        pMsgEx->pToDelete,
                        convener_password,
                        &(pMsgEx->Msg.u.join_indication.convener_password),
                        &rc);

        //      Copy the Password
        ::CSAP_CopyDataToGCCMessage_Challenge(
                        pMsgEx->pToDelete,
                        password_challenge,
                        &(pMsgEx->Msg.u.join_indication.password_challenge),
                        &rc);

        //      Copy the Caller Identifier
        ::CSAP_CopyDataToGCCMessage_IDvsDesc(
                        TRUE,   // caller id
                        pMsgEx->pToDelete,
                        pwszCallerID,
                        &(pMsgEx->Msg.u.join_indication.caller_identifier),
                        &rc);

        //      Copy the Calling Address
        ::CSAP_CopyDataToGCCMessage_Call(
                        TRUE,   // calling address
                        pMsgEx->pToDelete,
                        calling_address,
                        &(pMsgEx->Msg.u.join_indication.calling_address),
                        &rc);

        //      Copy the Called Address
        ::CSAP_CopyDataToGCCMessage_Call(
                        FALSE,  // called address
                        pMsgEx->pToDelete,
                        called_address,
                        &(pMsgEx->Msg.u.join_indication.called_address),
                        &rc);

        if (GCC_NO_ERROR == rc)
        {
            //  Copy the User Data if it exists.
            if (user_data_list != NULL)
            {
                rc = RetrieveUserDataList(
                        user_data_list,
                        &(pMsgEx->Msg.u.join_indication.number_of_user_data_members),
                        &(pMsgEx->Msg.u.join_indication.user_data_list),
                        &(pMsgEx->pToDelete->user_data_list_memory));
                ASSERT(GCC_NO_ERROR == rc);
            }
            else
            {
                // pMsgEx->Msg.u.join_indication.number_of_user_data_members = 0;
                // pMsgEx->Msg.u.join_indication.user_data_list = NULL;
            }

            if (GCC_NO_ERROR == rc)
            {
                /*
                **      Filling in the rest of the information that needs to be sent
                **      to the application.
                */
                pMsgEx->Msg.u.join_indication.join_response_tag = response_tag;
                pMsgEx->Msg.u.join_indication.conference_id = conference_id ;
                pMsgEx->Msg.u.join_indication.node_is_intermediate = intermediate_node;
                pMsgEx->Msg.u.join_indication.connection_handle = connection_handle;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
            }
        }
    }
    else
    {
        ERROR_OUT(("CControlSAP::QueueJoinIndication: can't create GCCCtrlSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::QueueJoinIndication, rc);
        return rc;
}


/*
 *      GCCError CControlSAP::RetrieveUserDataList(
 *                                                              CUserDataListContainer *user_data_list_object,
 *                                                              PUShort                         number_of_data_members,
 *                                                              PGCCUserData            **user_data_list,
 *                                                              LPBYTE              *pUserDataMemory)
 *
 *      Public member function of CControlSAP.
 *
 *      Function Description:
 *              This routine is used to fill in a user data list using a CUserDataListContainer
 *              container.  The memory needed to hold the user data will be allocated
 *              by this routine.
 *
 *      Formal Parameters:
 *              user_data_list_object           (i) The CUserDataListContainer container holding the
 *                                                                                      user data.
 *              number_of_data_members          (o) The number of elements in the list of
 *                                                                                      user data.
 *              user_data_list                          (o) The "API" user data list to fill in.
 *              data_to_be_deleted                      (o) Structure which will hold the memory
 *                                                                                      allocated for the user data.
 *
 *      Return Value:
 *              GCC_NO_ERROR                            - User data successfully retrieved.
 *              GCC_ALLOCATION_FAILURE          - A resource allocation failure occurred.
 *
 *  Side Effects:
 *              None.
 *
 *      Caveats:
 *              None.
 */
GCCError CControlSAP::RetrieveUserDataList
(
        CUserDataListContainer  *user_data_list_object,
        UINT                    *number_of_data_members,
        PGCCUserData            **user_data_list,
        LPBYTE                  *ppUserDataMemory
)
{
        GCCError                rc = GCC_NO_ERROR;
        UINT                    user_data_length;

        DebugEntry(CControlSAP::RetrieveUserDataList);

        /*
         * Lock the user data list object in order to determine the amount of
         * memory to allocate to hold the user data.
         */
        user_data_length = user_data_list_object->LockUserDataList ();

        DBG_SAVE_FILE_LINE
        if (NULL != (*ppUserDataMemory = new BYTE[user_data_length]))
        {
                /*
                 * The CUserDataListContainer "Get" call will set the user_data_list
                 * pointer equal to this memory pointer.
                 */
                user_data_list_object->GetUserDataList(
                                                number_of_data_members,
                                                user_data_list,
                                                *ppUserDataMemory);
        }
        else
        {
                ERROR_OUT(("CControlSAP::RetrieveUserDataList: Error allocating memory"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        /*
         * Unlock the data for the user data list object.
         */
        user_data_list_object->UnLockUserDataList ();

        DebugExitINT(CControlSAP::RetrieveUserDataList, rc);
        return rc;
}





/* ------ pure virtual in CBaseSap (shared with CAppSap) ------ */


/*
 *      ConfRosterInquireConfirm()
 *
 *      Public Function Description
 *              This routine is called in order to return a requested conference
 *              roster to an application or the node controller.
 */
GCCError CControlSAP::ConfRosterInquireConfirm
(
        GCCConfID                               conference_id,
        PGCCConferenceName                      conference_name,
        GCCNumericString                        conference_modifier,
        LPWSTR                                          pwszConfDescriptor,
        CConfRoster                                     *conference_roster,
        GCCResult                                       result,
    GCCAppSapMsgEx              **ppAppSapMsgEx
)
{
        GCCCtrlSapMsgEx     *pMsgEx;
        GCCError                        rc = GCC_NO_ERROR;
        UINT                            memory_block_size = 0;
        int                                     name_unicode_string_length;
        int                                     descriptor_unicode_string_length;
        LPBYTE                          pBuf = NULL;
    LPBYTE              memory_pointer;

    DebugEntry(CControlSAP::ConfRosterInquireConfirm);

    ASSERT(NULL == ppAppSapMsgEx);

    /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_ROSTER_INQUIRE_CONFIRM)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.conf_roster_inquire_confirm), sizeof(pMsgEx->Msg.u.conf_roster_inquire_confirm));

        /*
                 * Determine the length of the numeric portion of the conference name.
                 */
                if (conference_name->numeric_string != NULL)
                {
                        memory_block_size += (::lstrlenA(conference_name->numeric_string) + 1);
                        memory_block_size = ROUNDTOBOUNDARY(memory_block_size);
                }
                        
                /*
                 * Determine the length of the text portion of the conference name if it
                 * exists.  A UnicodeString object is created temporarily to determine
                 * the length of the string.
                 */
                if (conference_name->text_string != NULL)
                {
                        name_unicode_string_length = ROUNDTOBOUNDARY(
                                (::lstrlenW(conference_name->text_string) + 1) * sizeof(WCHAR));

                        memory_block_size += name_unicode_string_length;
                }
                
                /*
                 *      Determine the length of the conference modifier.
                 */
                if (conference_modifier != NULL)
                {
                        memory_block_size += (::lstrlenA(conference_modifier) + 1);
                        memory_block_size = ROUNDTOBOUNDARY(memory_block_size);
                }

                /*
                 * Determine the length of the conference descriptor.  A UnicodeString
                 * object is created temporarily to determine the length of the string.
                 */
                if (pwszConfDescriptor != NULL)
                {
                        descriptor_unicode_string_length = ROUNDTOBOUNDARY(
                                (::lstrlenW(pwszConfDescriptor) + 1) * sizeof(WCHAR));

                        memory_block_size += descriptor_unicode_string_length;
                }

                /*
                 * Lock the data for the conference roster.  The lock call will
                 * return the length of the data to be serialized for the roster so
                 * add that     length to the total memory block size and allocate the
                 * memory block.
                 */
                memory_block_size += conference_roster->LockConferenceRoster();

                /*
                 * If the memory was successfully allocated, get a pointer to the
                 * memory.  The first pointer in the roster inquire confirm message
                 * will be set to this location and all serialized data written into
                 * the memory block.
                 */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx->pBuf = new BYTE[memory_block_size]))
                {
            memory_pointer = pMsgEx->pBuf;

            /*
                         * Write the conference name string(s) into memory and set the
                         * message structure pointers.
                         */
                        if (conference_name->numeric_string != NULL)
                        {
                ::lstrcpyA((LPSTR)memory_pointer, (LPSTR)conference_name->numeric_string);
                                                
                                pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_name.
                                                numeric_string = (LPSTR) memory_pointer;

                                memory_pointer += ROUNDTOBOUNDARY(
                                                ::lstrlenA(conference_name->numeric_string) + 1);
                        }
                        else
                        {
                                // pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_name.numeric_string = NULL;
                        }

                        /*
                         * Copy the text portion of the conference name if it exists.
                         */
                        if (conference_name->text_string != NULL)
                        {
                ::CopyMemory(memory_pointer, (LPSTR)conference_name->text_string, name_unicode_string_length);

                                pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_name.text_string = (LPWSTR)memory_pointer;

                                memory_pointer += name_unicode_string_length;
                        }
                        else
                        {
                                // pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_name.text_string = NULL;
                        }
                        
                        /*
                         *      Copy the conference modifier is it exists
                         */
                        if (conference_modifier != NULL)
                        {
                ::lstrcpyA((LPSTR)memory_pointer, (LPSTR)conference_modifier);

                                pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_modifier = (LPSTR) memory_pointer;

                                memory_pointer += ROUNDTOBOUNDARY(::lstrlenA(conference_modifier) + 1);
                        }
                        else
                        {
                                // pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_modifier = NULL;
                        }

                        /*
                         * Copy the conference descriptor.
                         */
                        if (pwszConfDescriptor != NULL)
                        {
                ::CopyMemory(memory_pointer, (LPSTR)pwszConfDescriptor, descriptor_unicode_string_length);
                                pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_descriptor = (LPWSTR) memory_pointer;
                                memory_pointer += descriptor_unicode_string_length;
                        }
                        else
                        {
                                // pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_descriptor = NULL;
                        }

                        /*
                         * Retrieve the conference roster data from the roster object.
                         * The roster object will serialize any referenced data into
                         * the memory block passed in to the "Get" call.
                         */
                        conference_roster->GetConfRoster(
                                        &pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_roster,
                                        memory_pointer);

            pMsgEx->Msg.nConfID = conference_id;
                        pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_id = conference_id;
                        pMsgEx->Msg.u.conf_roster_inquire_confirm.result = result;

                        /*
                         * Add the message to the queue for delivery to the application or
                         * node controller.
                         */
                        PostConfirmCtrlSapMsg(pMsgEx);
                rc = GCC_NO_ERROR;
                }
                else
                {
            ERROR_OUT(("CControlSAP::ConfRosterInquireConfirm: can't allocate buffer, size=%u", (UINT) memory_block_size));
                        rc = GCC_ALLOCATION_FAILURE;
                }

                /*
                 * Unlock the data for the conference roster.
                 */
                conference_roster->UnLockConferenceRoster();
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfRosterInquireConfirm: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (rc != GCC_NO_ERROR)
    {
        FreeCtrlSapMsgEx(pMsgEx);

        ASSERT(GCC_ALLOCATION_FAILURE == rc);
            HandleResourceFailure();
    }

    DebugExitINT(CControlSAP::ConfRosterInquireConfirm, rc);
        return (rc);
}


/*
 *      AppRosterInquireConfirm()
 *
 *      Public Function Description
 *              This routine is called in order to return a requested list of
 *              application rosters to an application or the node controller.
 */
GCCError CControlSAP::AppRosterInquireConfirm
(
        GCCConfID                               conference_id,
        CAppRosterMsg                           *roster_message,
        GCCResult                                       result,
    GCCAppSapMsgEx              **ppAppSapMsgEx
)
{
#ifdef JASPER
        GCCError                                rc = GCC_NO_ERROR;
        GCCCtrlSapMsgEx         *pMsgEx;
        UINT                                    number_of_rosters;
    LPBYTE                  pBuf = NULL;

    DebugEntry(CControlSAP::AppRosterInquireConfirm);

    ASSERT(NULL == ppAppSapMsgEx);

        /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_APP_ROSTER_INQUIRE_CONFIRM, TRUE)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.app_roster_inquire_confirm), sizeof(pMsgEx->Msg.u.app_roster_inquire_confirm));

        /*
                 * Lock the data for the roster message and retrieve the data.
                 */
                rc = roster_message->LockApplicationRosterMessage();
                if (rc == GCC_NO_ERROR)
                {
                        rc = roster_message->GetAppRosterMsg(&pBuf, &number_of_rosters);
                        if (rc == GCC_NO_ERROR)
                        {
                                /*
                                 * Retrieve the memory pointer and save it in the list of
                                 * GCCApplicationRoster pointers.
                                 */
                                pMsgEx->Msg.u.app_roster_inquire_confirm.application_roster_list =
                                                (PGCCApplicationRoster *) pBuf;
                        }
                        else
                        {
                                /*
                                 * Cleanup after an error.
                                 */
                                roster_message->UnLockApplicationRosterMessage();
                        }
                }

                /*
                 * If everything is OK up to here, send the message on up.
                 */
                if (rc == GCC_NO_ERROR)
                {
                        pMsgEx->pToDelete->application_roster_message = roster_message;
                        
                        pMsgEx->Msg.u.app_roster_inquire_confirm.conference_id = conference_id;
                        pMsgEx->Msg.u.app_roster_inquire_confirm.number_of_rosters = number_of_rosters;
                        pMsgEx->Msg.u.app_roster_inquire_confirm.result = result;

                        /*
                         * Add the message to the queue for delivery to the application
                         * or node controller.
                         */
                        PostConfirmCtrlSapMsg(pMsgEx);
                }
        }
        else
        {
            ERROR_OUT(("CControlSAP::AppRosterInquireConfirm: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (rc != GCC_NO_ERROR)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

    DebugExitINT(CControlSAP::AppRosterInquireConfirm, rc);
        return (rc);
#else
    return GCC_NO_ERROR;
#endif // JASPER
}

/*
 *      ConductorInquireConfirm ()
 *
 *      Public Function Description
 *              This routine is called in order to return conductorship information
 *              which has been requested.
 *
 */
GCCError CControlSAP::ConductorInquireConfirm
(
    GCCNodeID                           conductor_node_id,
    GCCResult                           result,
    BOOL                                        permission_flag,
    BOOL                                        conducted_mode,
    GCCConfID                       conference_id
)
{
#ifdef JASPER
        GCCError            rc;
        GCCCtrlSapMsgEx     *pMsgEx;

    DebugEntry(CControlSAP::ConductorInquireConfirm);

        /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_INQUIRE_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_inquire_confirm), sizeof(pMsgEx->Msg.u.conduct_inquire_confirm));
                pMsgEx->Msg.u.conduct_inquire_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_inquire_confirm.result = result;
                pMsgEx->Msg.u.conduct_inquire_confirm.mode_is_conducted = conducted_mode;
                pMsgEx->Msg.u.conduct_inquire_confirm.conductor_node_id = conductor_node_id;
                pMsgEx->Msg.u.conduct_inquire_confirm.permission_is_granted = permission_flag;

                /*
                 * Add the message to the queue for delivery to the application or
                 * node controller.
                 */
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
        else
        {
                rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

    DebugExitINT(CControlSAP::ConductorInquireConfirm, rc);
        return rc;
#else
    return GCC_NO_ERROR;
#endif // JASPER
}


/*
 *      AppInvokeConfirm ()
 *
 *      Public Function Description
 *              This routine is called in order to confirm a call requesting application
 *              invocation.
 */
GCCError CControlSAP::AppInvokeConfirm
(
        GCCConfID                                       conference_id,
        CInvokeSpecifierListContainer   *invoke_list,
        GCCResult                                               result,
        GCCRequestTag                   nReqTag
)
{
    GCCCtrlSapMsgEx     *pMsgEx;
        GCCError            rc = GCC_NO_ERROR;
        UINT                invoke_list_memory_length;

    DebugEntry(CControlSAP::AppInvokeConfirm);

        /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_APPLICATION_INVOKE_CONFIRM)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.application_invoke_confirm), sizeof(pMsgEx->Msg.u.application_invoke_confirm));

        /*
                **      Determine the amount of memory necessary to hold the list of
                **      invoke specifiers and allocate that memory.
                */
                invoke_list_memory_length = invoke_list->LockApplicationInvokeSpecifierList();
                if (invoke_list_memory_length != 0)
                {
                        /*
                         * If the memory was successfully allocated, get a pointer
                         * to the memory and save it in the app_protocol_entity_list
                         * pointer of the GCC message.  Call the
                         * CInvokeSpecifierList object to fill in the
                         * list.
                         */
            DBG_SAVE_FILE_LINE
            if (NULL != (pMsgEx->pBuf = new BYTE[invoke_list_memory_length]))
                        {
                                pMsgEx->Msg.u.application_invoke_confirm.app_protocol_entity_list =
                                        (GCCAppProtocolEntity **) pMsgEx->pBuf;

                                invoke_list->GetApplicationInvokeSpecifierList(
                                                &(pMsgEx->Msg.u.application_invoke_confirm.number_of_app_protocol_entities),
                                                pMsgEx->pBuf);
                                pMsgEx->Msg.u.application_invoke_confirm.conference_id = conference_id;
                                pMsgEx->Msg.u.application_invoke_confirm.result = result;

                                /*
                                 * Add the message to the queue for delivery to the application
                                 * or node controller.
                                 */
                                PostConfirmCtrlSapMsg(pMsgEx);
                rc = GCC_NO_ERROR;
                        }
                        else
                        {
                            ERROR_OUT(("CControlSAP::AppInvokeConfirm: can't allocate buffer, size=%u", (UINT) invoke_list_memory_length));
                                rc = GCC_ALLOCATION_FAILURE;
                        }
                }
                
                /*
                **      Unlock the data for the invoke specifier list.
                */
                invoke_list->UnLockApplicationInvokeSpecifierList();
        }
        else
        {
            ERROR_OUT(("CControlSAP::AppInvokeConfirm: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (rc != GCC_NO_ERROR)
    {
        FreeCtrlSapMsgEx(pMsgEx);

        ASSERT(GCC_ALLOCATION_FAILURE == rc);
                HandleResourceFailure();
    }

    DebugExitINT(CControlSAP::AppInvokeConfirm, rc);
        return rc;
}


/*
 *      AppInvokeIndication ()
 *
 *      Public Function Description
 *              This routine is called in order to send an indication to an application
 *              or node controller that a request for application invocation has been
 *              made.
 */
GCCError CControlSAP::AppInvokeIndication
(
        GCCConfID                                       conference_id,
        CInvokeSpecifierListContainer   *invoke_list,
        GCCNodeID                                               invoking_node_id
)
{
    GCCError            rc = GCC_NO_ERROR;

    DebugEntry(CControlSAP::AppInvokeIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_APPLICATION_INVOKE_INDICATION;

    UINT                invoke_list_memory_length;

    /*
    **  Determine the amount of memory necessary to hold the list of
    **  invoke specifiers and allocate that memory.
    */
    invoke_list_memory_length = invoke_list->LockApplicationInvokeSpecifierList();
    if (invoke_list_memory_length != 0)
    {
        LPBYTE pBuf;
        /*
        * If the memory was successfully allocated, get a pointer
        * to the memory and save it in the app_protocol_entity_list
        * pointer of the GCC message.  Call the
        * CInvokeSpecifierList object to fill in the
        * list.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pBuf = new BYTE[invoke_list_memory_length]))
        {
            Msg.u.application_invoke_indication.app_protocol_entity_list = (GCCAppProtocolEntity **) pBuf;

            invoke_list->GetApplicationInvokeSpecifierList(
                    &(Msg.u.application_invoke_indication.number_of_app_protocol_entities),
                    pBuf);

            Msg.u.application_invoke_indication.conference_id = conference_id;
            Msg.u.application_invoke_indication.invoking_node_id = invoking_node_id;

            SendCtrlSapMsg(&Msg);
            // rc = GCC_NO_ERROR;

            delete [] pBuf;
        }
        else
        {
            ERROR_OUT(("CControlSAP::AppInvokeIndication: can't allocate buffer, size=%u", (UINT) invoke_list_memory_length));
            rc = GCC_ALLOCATION_FAILURE;
        }
    }

    /*
    **  Unlock the data for the invoke specifier list.
    */
    invoke_list->UnLockApplicationInvokeSpecifierList ();

#else

        GCCCtrlSapMsgEx     *pMsgEx;
        UINT                invoke_list_memory_length;

        /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_APPLICATION_INVOKE_INDICATION)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.application_invoke_indication), sizeof(pMsgEx->Msg.u.application_invoke_indication));

        /*
                **      Determine the amount of memory necessary to hold the list of
                **      invoke specifiers and allocate that memory.
                */
                invoke_list_memory_length = invoke_list->LockApplicationInvokeSpecifierList();
                if (invoke_list_memory_length != 0)
                {
                        /*
                         * If the memory was successfully allocated, get a pointer
                         * to the memory and save it in the app_protocol_entity_list
                         * pointer of the GCC message.  Call the
                         * CInvokeSpecifierList object to fill in the
                         * list.
                         */
                DBG_SAVE_FILE_LINE
            if (NULL != (pMsgEx->pBuf = new BYTE[invoke_list_memory_length]))
                        {
                                pMsgEx->Msg.u.application_invoke_indication.app_protocol_entity_list =
                                        (GCCAppProtocolEntity **) pMsgEx->pBuf;
                
                                invoke_list->GetApplicationInvokeSpecifierList(
                                                        &(pMsgEx->Msg.u.application_invoke_indication.number_of_app_protocol_entities),
                                                        pMsgEx->pBuf);
        
                                pMsgEx->Msg.u.application_invoke_indication.conference_id = conference_id;
                                pMsgEx->Msg.u.application_invoke_indication.invoking_node_id = invoking_node_id;

                PostIndCtrlSapMsg(pMsgEx);
                rc = GCC_NO_ERROR;
                        }
                        else
                        {
                            ERROR_OUT(("CControlSAP::AppInvokeIndication: can't allocate buffer, size=%u", (UINT) invoke_list_memory_length));
                                rc = GCC_ALLOCATION_FAILURE;
                        }
                }

                /*
                **      Unlock the data for the invoke specifier list.
                */
                invoke_list->UnLockApplicationInvokeSpecifierList ();
        }
        else
        {
            ERROR_OUT(("CControlSAP::AppInvokeIndication: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (rc != GCC_NO_ERROR)
    {
        FreeCtrlSapMsgEx(pMsgEx);

        ASSERT(GCC_ALLOCATION_FAILURE == rc);
                HandleResourceFailure();
    }

#endif // GCCNC_DIRECT_INDICATION

    DebugExitINT(CControlSAP::AppInvokeIndication, rc);
        return rc;
}

/*
 *      ConfRosterReportIndication ()
 *
 *      Public Function Description
 *              This routine is called in order to indicate to applications and the
 *              node controller that the conference roster has been updated.
 */
GCCError CControlSAP::ConfRosterReportIndication
(
        GCCConfID                               conference_id,
        CConfRosterMsg                          *roster_message
)
{
        GCCError                                rc = GCC_NO_ERROR;

    DebugEntry(CControlSAP::ConfRosterReportIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_ROSTER_REPORT_INDICATION;

    /*
     * Lock the conference roster message in order to force the object
     * to serialize the data into its internal memory.
     */
    rc = roster_message->LockConferenceRosterMessage();
    if (rc == GCC_NO_ERROR)
    {
        LPBYTE  pBuf = NULL;
        /*
         * Retrieve the actual pointer to memory object that the
         * serialized conference roster is contained in from the
         * conference roster message.
         */
        rc = roster_message->GetConferenceRosterMessage(&pBuf);
        if (rc == GCC_NO_ERROR)
        {
            Msg.nConfID = conference_id;
            Msg.u.conf_roster_report_indication.conference_id = conference_id;
            Msg.u.conf_roster_report_indication.conference_roster = (PGCCConferenceRoster) pBuf;

            SendCtrlSapMsg(&Msg);
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfRosterReportIndication: can't get conf roster message"));
        }
        roster_message->UnLockConferenceRosterMessage();
    }
    else
    {
        ERROR_OUT(("CControlSAP::ConfRosterReportIndication: can't lock conf roster message"));
    }

#else

        GCCCtrlSapMsgEx         *pMsgEx;

        /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_ROSTER_REPORT_INDICATION, TRUE)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conf_roster_report_indication), sizeof(pMsgEx->Msg.u.conf_roster_report_indication));

        /*
                 * Lock the conference roster message in order to force the object
                 * to serialize the data into its internal memory.
                 */
                rc = roster_message->LockConferenceRosterMessage();
                if (rc == GCC_NO_ERROR)
                {
                LPBYTE  pBuf = NULL;
                        /*
                         * Retrieve the actual pointer to memory object that the
                         * serialized conference roster is contained in from the
                         * conference roster message.
                         */
                        rc = roster_message->GetConferenceRosterMessage(&pBuf);
                        if (rc == GCC_NO_ERROR)
                        {
                                pMsgEx->Msg.u.conf_roster_report_indication.conference_roster =
                                                (PGCCConferenceRoster) pBuf;

                                /*
                                 * Fill in the roster's conference ID and then queue up the
                                 * message.
                                 */
                                pMsgEx->Msg.nConfID = conference_id;
                                pMsgEx->Msg.u.conf_roster_report_indication.conference_id = conference_id;
                                pMsgEx->pToDelete->conference_roster_message = roster_message;

                                PostIndCtrlSapMsg(pMsgEx);
                        }
                        else
                        {
                ERROR_OUT(("CControlSAP::ConfRosterReportIndication: can't get conf roster message"));
                        }
                }
                else
                {
            ERROR_OUT(("CControlSAP::ConfRosterReportIndication: can't lock conf roster message"));
                }
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfRosterReportIndication: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (rc != GCC_NO_ERROR)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_INDICATION

    DebugExitINT(CControlSAP::ConfRosterReportIndication, rc);
        return rc;
}

/*
 *      AppRosterReportIndication()
 *
 *      Public Function Description
 *              This routine is called in order to indicate to applications and the
 *              node controller that the list of application rosters has been updated.
 */
GCCError CControlSAP::AppRosterReportIndication
(
        GCCConfID                               conference_id,
        CAppRosterMsg                           *roster_message
)
{
        GCCError                                rc = GCC_NO_ERROR;

    DebugEntry(CControlSAP::AppRosterReportIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_APP_ROSTER_REPORT_INDICATION;

    /*
     * Determine the amount of memory needed to hold the list of
     * application rosters and allocate that memory.
     */
    rc = roster_message->LockApplicationRosterMessage();
    if (rc == GCC_NO_ERROR)
    {
        LPBYTE          pBuf = NULL;
        ULONG           cRosters;

        rc = roster_message->GetAppRosterMsg(&pBuf, &cRosters);
        if (rc == GCC_NO_ERROR)
        {
            Msg.u.app_roster_report_indication.conference_id = conference_id;
            Msg.u.app_roster_report_indication.application_roster_list = (PGCCApplicationRoster *) pBuf;
            Msg.u.app_roster_report_indication.number_of_rosters = cRosters;

            SendCtrlSapMsg(&Msg);
        }
        else
        {
            ERROR_OUT(("CControlSAP: AppRosterReportIndication: GetAppRosterMsg failed"));
        }
        roster_message->UnLockApplicationRosterMessage();
    }
    else
    {
        ERROR_OUT(("CControlSAP: AppRosterReportIndication: LockApplicationRosterMessage failed"));
    }

#else

        GCCCtrlSapMsgEx         *pMsgEx;
        LPBYTE                  pBuf = NULL;
        UINT                                    cRosters;

        /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_APP_ROSTER_REPORT_INDICATION, TRUE)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.app_roster_report_indication), sizeof(pMsgEx->Msg.u.app_roster_report_indication));

        /*
                 * Determine the amount of memory needed to hold the list of
                 * application rosters and allocate that memory.
                 */
                rc = roster_message->LockApplicationRosterMessage();
                if (rc == GCC_NO_ERROR)
                {
                        rc = roster_message->GetAppRosterMsg(&pBuf, &cRosters);
                        if (rc == GCC_NO_ERROR)
                        {
                                /*
                                 * Save it in the list of GCCApplicationRoster pointers.
                                 */
                                pMsgEx->Msg.u.app_roster_report_indication.application_roster_list =
                                                (PGCCApplicationRoster *) pBuf;
                        }
                        else
                        {
                                /*
                                 * Cleanup after an error.
                                 */
                                ERROR_OUT(("CControlSAP: AppRosterReportIndication: GetAppRosterMsg failed"));
                                roster_message->UnLockApplicationRosterMessage();
                        }
                }
                else
                {
                        ERROR_OUT(("CControlSAP: AppRosterReportIndication: LockApplicationRosterMessage failed"));
                }

                /*
                 * If everything is OK up to here, send the message on up.
                 */
                if (rc == GCC_NO_ERROR)
                {
                        pMsgEx->Msg.u.app_roster_report_indication.conference_id = conference_id;
                        pMsgEx->Msg.u.app_roster_report_indication.number_of_rosters = cRosters;

                        pMsgEx->pToDelete->application_roster_message = roster_message;

                        /*
                         * Add the message to the queue for delivery to the application
                         * or node controller.
                         */
                        PostIndCtrlSapMsg(pMsgEx);
                }
        }
        else
        {
                ERROR_OUT(("CControlSAP: AppRosterReportIndication: Failed to allocate a GCC message"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (rc != GCC_NO_ERROR)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_INDICATION

    DebugExitINT(CControlSAP::AppRosterReportIndication, rc);
        return rc;
}



/* ------ from CBaseSap ------ */


/*
 *      ConductorAssignIndication ()
 *
 *      Public Function Description
 *              This routine is called in order to send an indication to an application
 *              or node controller that a request has been made to assign conductorship.
 */
GCCError CControlSAP::ConductorAssignIndication
(
        UserID                                  conductor_node_id,
        GCCConfID                       conference_id
)
{
#ifdef JASPER
        GCCError            rc;

    DebugEntry(CControlSAP::ConductorAssignIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_CONDUCT_ASSIGN_INDICATION;

    Msg.u.conduct_assign_indication.conference_id = conference_id;
    Msg.u.conduct_assign_indication.node_id = conductor_node_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

        /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_ASSIGN_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_assign_indication), sizeof(pMsgEx->Msg.u.conduct_assign_indication));
                pMsgEx->Msg.u.conduct_assign_indication.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_assign_indication.node_id = conductor_node_id;

                /*
                 * Add the message to the queue for delivery to the application or
                 * node controller.
                 */
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
        else
        {
                rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

    DebugExitINT(CControlSAP::ConductorAssignIndication, rc);
        return rc;
#else
    return GCC_NO_ERROR;
#endif // JASPER
}

/*
 *      ConductorReleaseIndication ()
 *
 *      Public Function Description
 *              This routine is called in order to send an indication to an application
 *              or node controller that a request for releasing conductorship has been
 *              made.
 */
GCCError CControlSAP::
ConductorReleaseIndication ( GCCConfID conference_id )
{
#ifdef JASPER
    GCCError            rc;

    DebugEntry(CControlSAP::ConductorReleaseIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_CONDUCT_RELEASE_INDICATION;

    Msg.u.conduct_release_indication.conference_id = conference_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

        /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_RELEASE_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_release_indication), sizeof(pMsgEx->Msg.u.conduct_release_indication));
                pMsgEx->Msg.u.conduct_release_indication.conference_id = conference_id;

                /*
                 * Add the message to the queue for delivery to the application or
                 * node controller.
                 */
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
        else
        {
                rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

    DebugExitINT(CControlSAP::ConductorReleaseIndication, rc);
        return rc;
#else
    return GCC_NO_ERROR;
#endif // JASPER
}

/*
 *      ConductorPermitGrantIndication ()
 *
 *      Public Function Description
 *              This routine is called in order to send an indication to an application
 *              or node controller that a request for permission from the conductor
 *              has been made.
 */
GCCError CControlSAP::ConductorPermitGrantIndication
(
        GCCConfID               conference_id,
        UINT                            number_granted,
        GCCNodeID                       *granted_node_list,
        UINT                            number_waiting,
        GCCNodeID                       *waiting_node_list,
        BOOL                            permission_is_granted
)
{
#ifdef JASPER
        GCCError                        rc = GCC_NO_ERROR;

    DebugEntry(CControlSAP::ConductorPermitGrantIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg       Msg;
    Msg.message_type = GCC_CONDUCT_GRANT_INDICATION;

    Msg.u.conduct_permit_grant_indication.conference_id = conference_id;
    Msg.u.conduct_permit_grant_indication.number_granted = number_granted;
    Msg.u.conduct_permit_grant_indication.granted_node_list = granted_node_list;
    Msg.u.conduct_permit_grant_indication.number_waiting = number_waiting;
    Msg.u.conduct_permit_grant_indication.waiting_node_list = waiting_node_list;
    Msg.u.conduct_permit_grant_indication.permission_is_granted = permission_is_granted;

    SendCtrlSapMsg(&Msg);

#else

        GCCCtrlSapMsgEx     *pMsgEx;
        int                                     bulk_memory_size;
        LPBYTE                          memory_pointer;
        UINT                            i;

        /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_GRANT_INDICATION)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.conduct_permit_grant_indication), sizeof(pMsgEx->Msg.u.conduct_permit_grant_indication));

        /*
                **      Here we determine if bulk memory is necessary.
                */
                if ((number_granted != 0) || (number_waiting != 0))
                {
                        /*
                        **      We must first determine how big the bulk memory block will be
                        **      and allocate that memory.
                        */
                        bulk_memory_size = (ROUNDTOBOUNDARY(sizeof(UserID)) * number_granted) +
                                                                (ROUNDTOBOUNDARY(sizeof(UserID)) * number_waiting);

            DBG_SAVE_FILE_LINE
            if (NULL != (pMsgEx->pBuf = new BYTE[bulk_memory_size]))
            {
                memory_pointer = pMsgEx->pBuf;
            }
            else
            {
                ERROR_OUT(("CControlSAP::ConductorPermitGrantIndication: can't allocate buffer, size=%u", (UINT) bulk_memory_size));
                                rc = GCC_ALLOCATION_FAILURE;
            }
                }

                if (rc == GCC_NO_ERROR)
                {
                        /*
                        **      If there are any nodes in the permission list copy them over.
                        */
                        if (number_granted != 0)
                        {
                                TRACE_OUT(("CControlSAP::ConductorPermitGrantIndication:"
                                                        " number_granted = %d", number_granted));
                                                        
                                pMsgEx->Msg.u.conduct_permit_grant_indication.
                                                granted_node_list =     (PUserID)memory_pointer;

                                for (i = 0; i < number_granted; i++)
                                {
                                        pMsgEx->Msg.u.conduct_permit_grant_indication.
                                                granted_node_list[i] = granted_node_list[i];
                                }
                                
                                memory_pointer += ROUNDTOBOUNDARY(sizeof(UserID)) * number_granted;
                        }
                        else
                        {
                                // pMsgEx->Msg.u.conduct_permit_grant_indication.granted_node_list =    NULL;
                        }

                        /*
                        **      If there are any nodes in the waiting list copy them over.
                        */
                        if (number_waiting != 0)
                        {
                                TRACE_OUT(("CControlSAP::ConductorPermitGrantIndication:"
                                                        " number_waiting = %d", number_waiting));

                                pMsgEx->Msg.u.conduct_permit_grant_indication.
                                                waiting_node_list = (PUserID)memory_pointer;
                                        
                                for (i = 0; i < number_waiting; i++)
                                {
                                        pMsgEx->Msg.u.conduct_permit_grant_indication.
                                                waiting_node_list[i] = waiting_node_list[i];
                                }
                        }
                        else
                        {
                                // pMsgEx->Msg.u.conduct_permit_grant_indication.waiting_node_list = NULL;
                        }

                        pMsgEx->Msg.u.conduct_permit_grant_indication.conference_id = conference_id;
                        pMsgEx->Msg.u.conduct_permit_grant_indication.number_granted = number_granted;
                        pMsgEx->Msg.u.conduct_permit_grant_indication.number_waiting = number_waiting;
                        pMsgEx->Msg.u.conduct_permit_grant_indication.permission_is_granted = permission_is_granted;

                        /*
                         * Add the message to the queue for delivery to the application or
                         * node controller.
                         */
                        PostIndCtrlSapMsg(pMsgEx);
                }
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConductorPermitGrantIndication: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (rc != GCC_NO_ERROR)
        {
        FreeCtrlSapMsgEx(pMsgEx);

        ASSERT(GCC_ALLOCATION_FAILURE == rc);
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

    DebugExitINT(CControlSAP::ConductorPermitGrantIndication, rc);
        return (rc);
#else
    return GCC_NO_ERROR;
#endif // JASPER
}


GCCError CControlSAP::AppletInvokeRequest
(
    GCCConfID                   nConfID,
    UINT                        number_of_app_protcol_entities,
    GCCAppProtocolEntity      **app_protocol_entity_list,
    UINT                        number_of_destination_nodes,
    UserID                     *list_of_destination_nodes
)
{
    GCCAppProtEntityList ApeList;
    GCCSimpleNodeList NodeList;
    GCCRequestTag nReqTag;

    ApeList.cApes = number_of_app_protcol_entities;
    ApeList.apApes = app_protocol_entity_list;

    NodeList.cNodes = number_of_destination_nodes;
    NodeList.aNodeIDs = list_of_destination_nodes;

    return CBaseSap::AppInvoke(nConfID, &ApeList, &NodeList, &nReqTag);
}

GCCError CControlSAP::ConfRosterInqRequest
(
    GCCConfID       nConfID
)
{
    return CBaseSap::ConfRosterInquire(nConfID, NULL);
}

#ifdef JASPER
GCCError CControlSAP::ConductorInquireRequest
(
    GCCConfID       nConfID
)
{
    return CBaseSap::ConductorInquire(nConfID);
}
#endif // JASPER


//
// LONCHANC: The following SAP_*** stuff are all app sap related
// because FreeCallbackMessage() in CControlSAP does not handle
// the DataToBeDeleted stuff.
//

/*
 *      void    CopyDataToGCCMessage(   
 *                                                      SapCopyType                             copy_type,
 *                                                      PDataToBeDeleted                data_to_be_deleted,
 *                                                      LPVOID                                  source_ptr,
 *                                                      LPVOID                                  destination_ptr,
 *                                                      PGCCError                               rc)
 *
 *      Protected member function of CControlSAP.
 *
 *      Function Description:
 *              This routine is used to fill in the various components of the message
 *              structures to be delivered to applications or the node controller.
 *
 *      Formal Parameters:
 *              copy_type                       (i) Enumerated type indicating what field is to be
 *                                                                      copied.
 *              data_to_be_deleted      (o) Structure to hold part of the data to be
 *                                                                      delivered in the message.
 *              source_ptr                      (i) Pointer to structure to copy from.
 *              destination_ptr         (o) Pointer to structure to copy into.
 *              rc              (o) Return value for routine.
 *
 *      Return Value:
 *              None.
 *
 *  Side Effects:
 *              None.
 *
 *      Caveats:
 *              The return value should be setup before it is passed into this
 *              routine.  This allows the error checking to be done in one place
 *              (this routine).
 */

void CSAP_CopyDataToGCCMessage_ConfName
(
        PDataToBeDeleted                data_to_be_deleted,
        PGCCConferenceName              source_conference_name,
        PGCCConferenceName              destination_conference_name,
        PGCCError                               pRetCode
)
{
        if (GCC_NO_ERROR == *pRetCode)
        {
                LPSTR pszNumeric;
                LPWSTR pwszText;

                if (source_conference_name != NULL)
                {
                        if (source_conference_name->numeric_string != NULL)
                        {
                                /*
                                 * First copy the numeric conference name if one exists.
                                 */
                                if (NULL != (pszNumeric = ::My_strdupA(source_conference_name->numeric_string)))
                                {
                                        destination_conference_name->numeric_string = (GCCNumericString) pszNumeric;
                                        data_to_be_deleted->pszNumericConfName = pszNumeric;
                                }
                                else
                                {
                                        *pRetCode = GCC_ALLOCATION_FAILURE;
                                }
                        }
                        else
                        {
                                // destination_conference_name->numeric_string = NULL;
                        }

                        /*
                         * Next copy the text conference name if one exists.
                         */
                        if ((source_conference_name->text_string != NULL) &&
                                (*pRetCode == GCC_NO_ERROR))
                        {
                                if (NULL != (pwszText = ::My_strdupW(source_conference_name->text_string)))
                                {
                                        destination_conference_name->text_string = pwszText;
                                        data_to_be_deleted->pwszTextConfName = pwszText;
                                }
                                else
                                {
                                        *pRetCode = GCC_ALLOCATION_FAILURE;
                                }
                        }
                        else
                        {
                                // destination_conference_name->text_string = NULL;
                        }
                }
                else
                {
                        // destination_conference_name->numeric_string = NULL;
                        // destination_conference_name->text_string = NULL;
                }

                ASSERT(GCC_NO_ERROR == *pRetCode);
        }
}


void CSAP_CopyDataToGCCMessage_Modifier
(
        BOOL                                    fRemoteModifier,
        PDataToBeDeleted                data_to_be_deleted,
        GCCNumericString                source_numeric_string,
        GCCNumericString                *destination_numeric_string,
        PGCCError                               pRetCode
)
{
        if (GCC_NO_ERROR == *pRetCode)
        {
                LPSTR numeric_ptr;

                if (source_numeric_string != NULL)
                {
                        if (NULL != (numeric_ptr = ::My_strdupA(source_numeric_string)))
                        {
                                *destination_numeric_string = (GCCNumericString) numeric_ptr;

                                if (fRemoteModifier)
                                {
                                        data_to_be_deleted->pszRemoteModifier =  numeric_ptr;
                                }
                                else
                                {
                                        data_to_be_deleted->pszConfNameModifier = numeric_ptr;
                                }

                                TRACE_OUT(("CopyDataToGCCMessage_Modifier: modifier = %s", *destination_numeric_string));
                        }
                        else
                        {
                                // *destination_numeric_string = NULL;
                                *pRetCode = GCC_ALLOCATION_FAILURE;
                        }
                }
                else
                {
                        // *destination_numeric_string = NULL;
                }

                ASSERT(GCC_NO_ERROR == *pRetCode);
        }
}


void CSAP_CopyDataToGCCMessage_Password
(
        BOOL                                    fConvener,
        PDataToBeDeleted                data_to_be_deleted,
        CPassword               *source_password,
        PGCCPassword                    *destination_password,
        PGCCError                               pRetCode
)
{
        if (GCC_NO_ERROR == *pRetCode)
        {
                if (source_password != NULL)
                {
                        source_password->LockPasswordData();
                        source_password->GetPasswordData (destination_password);

                        if (fConvener)
                        {
                                data_to_be_deleted->convener_password = source_password;
                        }
                        else
                        {
                                data_to_be_deleted->password = source_password;
                        }
                }
                else
                {
                        // *destination_password = NULL;
                }

                ASSERT(GCC_NO_ERROR == *pRetCode);
        }
}


void CSAP_CopyDataToGCCMessage_Challenge
(
        PDataToBeDeleted                                data_to_be_deleted,
        CPassword                       *source_password,
        PGCCChallengeRequestResponse    *password_challenge,
        PGCCError                                               pRetCode
)
{
        if (GCC_NO_ERROR == *pRetCode)
        {
                if (source_password != NULL)
                {
                        source_password->LockPasswordData();
                        source_password->GetPasswordChallengeData (password_challenge);
                        
                        data_to_be_deleted->password = source_password;
                }
                else
                {
                        // *password_challenge = NULL;
                }

                ASSERT(GCC_NO_ERROR == *pRetCode);
        }
}


void CSAP_CopyDataToGCCMessage_PrivilegeList
(
        PPrivilegeListData                      source_privilege_list_data,
        PGCCConferencePrivileges        *destination_privilege_list,
        PGCCError                                       pRetCode
)
{
        if (GCC_NO_ERROR == *pRetCode)
        {
                if (source_privilege_list_data != NULL)
                {
                        DBG_SAVE_FILE_LINE
                        if (NULL != (*destination_privilege_list = new GCCConferencePrivileges))
                        {
                                **destination_privilege_list =
                                        *(source_privilege_list_data->GetPrivilegeListData());
                        }
                        else
                        {
                                *pRetCode = GCC_ALLOCATION_FAILURE;
                        }
                }
                else
                {
                        // *destination_privilege_list = NULL;
                }

                ASSERT(GCC_NO_ERROR == *pRetCode);
        }
}


void CSAP_CopyDataToGCCMessage_IDvsDesc
(
        BOOL                            fCallerID,
        PDataToBeDeleted        data_to_be_deleted,
        LPWSTR                          source_text_string,
        LPWSTR                          *destination_text_string,
        PGCCError                       pRetCode
)
{
        if (GCC_NO_ERROR == *pRetCode)
        {
                if (source_text_string != NULL)
                {
                        if (NULL != (*destination_text_string = ::My_strdupW(source_text_string)))
                        {
                                if (fCallerID)
                                {
                                        data_to_be_deleted->pwszCallerID = *destination_text_string;
                                }
                                else
                                {
                                        data_to_be_deleted->pwszConfDescriptor = *destination_text_string;
                                }
                        }
                        else
                        {
                                *pRetCode = GCC_ALLOCATION_FAILURE;
                        }
                }
                else
                {
                        // *destination_text_string = NULL;
                }

                ASSERT(GCC_NO_ERROR == *pRetCode);
        }
}


//
// LONCHANC: TransportAddress is defined as LPSTR (i.e. char *)
//
void CSAP_CopyDataToGCCMessage_Call
(
        BOOL                            fCalling,
        PDataToBeDeleted        data_to_be_deleted,
        TransportAddress        source_transport_address,
        TransportAddress        *destination_transport_address,
        PGCCError                       pRetCode
)
{
        if (GCC_NO_ERROR == *pRetCode)
        {
                if (source_transport_address != NULL)
                {
                        if (NULL != (*destination_transport_address = ::My_strdupA(source_transport_address)))
                        {
                                if (fCalling)
                                {
                                        data_to_be_deleted->pszCallingAddress = *destination_transport_address ;
                                }
                                else
                                {
                                        data_to_be_deleted->pszCalledAddress = *destination_transport_address ;
                                }
                        }
                        else
                        {
                                *pRetCode = GCC_ALLOCATION_FAILURE;
                        }
                }
                else
                {
                        // *destination_transport_address = NULL;
                }

                ASSERT(GCC_NO_ERROR == *pRetCode);
        }
}


void CSAP_CopyDataToGCCMessage_DomainParams
(
        PDataToBeDeleted        data_to_be_deleted,
        PDomainParameters       source_domain_parameters,
        PDomainParameters       *destination_domain_parameters,
        PGCCError                       pRetCode
)
{
        if (GCC_NO_ERROR == *pRetCode)
        {
                if (source_domain_parameters != NULL)
                {
                        DBG_SAVE_FILE_LINE
                        if (NULL != (*destination_domain_parameters = new DomainParameters))
                        {
                                **destination_domain_parameters = *source_domain_parameters;
                                data_to_be_deleted->pDomainParams = *destination_domain_parameters;
                        }
                        else
                        {
                                *pRetCode = GCC_ALLOCATION_FAILURE;
                        }
                }
                else
                {
                        // *destination_domain_parameters = NULL;
                }

                ASSERT(GCC_NO_ERROR == *pRetCode);
        }
}




void CControlSAP::NotifyProc ( GCCCtrlSapMsgEx *pCtrlSapMsgEx )
{
    if (NULL != m_pfnNCCallback)
    {
        pCtrlSapMsgEx->Msg.user_defined = m_pNCData;
        (*m_pfnNCCallback)(&(pCtrlSapMsgEx->Msg));
    }

    //
    // Free this callback message.
    //
    FreeCtrlSapMsgEx(pCtrlSapMsgEx);
}



void CControlSAP::WndMsgHandler
(
    UINT        uMsg,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    ASSERT(uMsg >= CSAPCONFIRM_BASE);

    GCCCtrlSapMsg   Msg;
    Msg.message_type = (GCCMessageType) (uMsg - CSAPCONFIRM_BASE);
    Msg.nConfID = (GCCConfID) lParam;

    GCCResult nResult = (GCCResult) LOWORD(wParam);

    switch (Msg.message_type)
    {
    case GCC_EJECT_USER_CONFIRM:
#ifdef JASPER
        Msg.u.eject_user_confirm.conference_id = Msg.nConfID;
        Msg.u.eject_user_confirm.result = nResult;
        Msg.u.eject_user_confirm.ejected_node_id = (GCCNodeID) HIWORD(wParam);
#endif // JASPER
        break;

    case GCC_CONDUCT_GIVE_CONFIRM:
#ifdef JASPER
        Msg.u.conduct_give_confirm.conference_id = Msg.nConfID;
        Msg.u.conduct_give_confirm.result = nResult;
        Msg.u.conduct_give_confirm.recipient_node_id = (GCCNodeID) HIWORD(wParam);
#endif // JASPER
        break;

    case GCC_CONDUCT_ASK_CONFIRM:
#ifdef JASPER
        Msg.u.conduct_permit_ask_confirm.conference_id = Msg.nConfID;
        Msg.u.conduct_permit_ask_confirm.result = nResult;
        Msg.u.conduct_permit_ask_confirm.permission_is_granted = HIWORD(wParam);;
#endif // JASPER
        break;

    case GCC_EJECT_USER_INDICATION:
        Msg.u.eject_user_indication.conference_id = Msg.nConfID;
        Msg.u.eject_user_indication.ejected_node_id = (GCCNodeID) HIWORD(wParam);
        Msg.u.eject_user_indication.reason = (GCCReason) LOWORD(wParam);
        break;

    // case GCC_DISCONNECT_CONFIRM:
    // case GCC_LOCK_CONFIRM:
    // case GCC_UNLOCK_CONFIRM:
    // case GCC_ANNOUNCE_PRESENCE_CONFIRM:
    // case GCC_TERMINATE_CONFIRM:
    // case GCC_CONDUCT_ASSIGN_CONFIRM:
    // case GCC_CONDUCT_RELEASE_CONFIRM:
    // case GCC_CONDUCT_PLEASE_CONFIRM:
    // case GCC_CONDUCT_GRANT_CONFIRM:
    // case GCC_TIME_REMAINING_CONFIRM:
    // case GCC_TIME_INQUIRE_CONFIRM:
    // case GCC_ASSISTANCE_CONFIRM:
    // case GCC_TEXT_MESSAGE_CONFIRM:
    default:
        // This is a shortcut to fill in conf id and gcc result.
        Msg.u.simple_confirm.conference_id = Msg.nConfID;
        Msg.u.simple_confirm.result = nResult;
        break;
    }

    SendCtrlSapMsg(&Msg);
}


GCCCtrlSapMsgEx * CControlSAP::CreateCtrlSapMsgEx
(
    GCCMessageType          eMsgType,
    BOOL                    fUseToDelete
)
{
    GCCCtrlSapMsgEx *pMsgEx;
    UINT            cbSize = (UINT)(fUseToDelete ?
                             sizeof(GCCCtrlSapMsgEx) + sizeof(DataToBeDeleted) :
                             sizeof(GCCCtrlSapMsgEx));

        DBG_SAVE_FILE_LINE
    if (NULL != (pMsgEx = (GCCCtrlSapMsgEx *) new BYTE[cbSize]))
    {
        pMsgEx->Msg.message_type = eMsgType;
        pMsgEx->pBuf = NULL;
        if (fUseToDelete)
        {
            pMsgEx->pToDelete = (DataToBeDeleted *) (pMsgEx + 1);
            ::ZeroMemory(pMsgEx->pToDelete, sizeof(DataToBeDeleted));
        }
        else
        {
            pMsgEx->pToDelete = NULL;
        }
    }

    return pMsgEx;
}


void CControlSAP::FreeCtrlSapMsgEx ( GCCCtrlSapMsgEx *pMsgEx )
{
    switch (pMsgEx->Msg.message_type)
    {
    case GCC_QUERY_INDICATION:
        delete pMsgEx->Msg.u.query_indication.asymmetry_indicator;
        break;

#ifndef GCCNC_DIRECT_CONFIRM
    case GCC_QUERY_CONFIRM:
        delete pMsgEx->Msg.u.query_confirm.asymmetry_indicator;
        break;
#endif

#ifdef JASPER
    case GCC_TEXT_MESSAGE_INDICATION:
        delete pMsgEx->Msg.u.text_message_indication.text_message;
        break;
#endif // JASPER

#ifdef TSTATUS_INDICATION
    case GCC_TRANSPORT_STATUS_INDICATION:
        delete pMsgEx->Msg.u.transport_status.device_identifier;
        delete pMsgEx->Msg.u.transport_status.remote_address;
        delete pMsgEx->Msg.u.transport_status.message;
        break;
#endif
    }

    //
    // Now free up the data to be deleted,
    //
    if (NULL != pMsgEx->pToDelete)
    {
        DataToBeDeleted *p = pMsgEx->pToDelete;

        delete p->pszNumericConfName;
        delete p->pwszTextConfName;
        delete p->pszConfNameModifier;
        delete p->pszRemoteModifier;
        delete p->pwszConfDescriptor;
        delete p->pwszCallerID;
        delete p->pszCalledAddress;
        delete p->pszCallingAddress;
        delete p->user_data_list_memory;
        delete p->pDomainParams;
        delete p->conductor_privilege_list;
        delete p->conducted_mode_privilege_list;
        delete p->non_conducted_privilege_list;

        if (p->convener_password != NULL)
        {
            p->convener_password->UnLockPasswordData();
        }

        if (p->password != NULL)
        {
            p->password->UnLockPasswordData();
        }

        if (p->conference_list != NULL)
        {
            p->conference_list->UnLockConferenceDescriptorList();
        }

        if (p->conference_roster_message != NULL)
        {
            //
            // Set bulk memory back to NULL here since the conference
            // roster message object is responsible for freeing this up.
            //
            pMsgEx->pBuf = NULL;
            p->conference_roster_message->UnLockConferenceRosterMessage();
        }

        if (p->application_roster_message != NULL)
        {
            //
            // Set bulk memory back to NULL here since the application
            // roster message object is responsible for freeing this up.
            //
            pMsgEx->pBuf = NULL;

            //
            // App roster indication can definitely be sent to app sap.
            //
            ::EnterCriticalSection(&g_csGCCProvider);
            p->application_roster_message->UnLockApplicationRosterMessage();
            ::LeaveCriticalSection(&g_csGCCProvider);
        }
    }

    //
    // Next free up any bulk memory used.
    //
    delete pMsgEx->pBuf;

    //
    // Finally, free the structure itself.
    //
    delete pMsgEx;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\ernccm.cpp ===
/****************************************************************************/
/*                                                                          */
/* ERNCCM.CPP                                                               */
/*                                                                          */
/* Conference Manager class for the Reference System Node Controller.       */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  07Jul95 NFC             Created.                                        */
/*  23Aug95 NFC             Bad trace in StartConference().                 */
/*  05Sep95 NFC             Integration with CMP_Notify* API.               */
/*  13Sep95 NFC             Added handler for GCC_EJECT_USER_INDICATION     */
/*  19Sep95 NFC             Missing break in GetConfIDFromMessage().        */
/****************************************************************************/
#include "precomp.h"
DEBUG_FILEZONE(ZONE_GCC_NC);
#include "ernccons.h"
#include "nccglbl.hpp"
#include "erncvrsn.hpp"
#include "t120app.h"
#include <cuserdta.hpp>
#include <confcli.h>
#include <confreg.h>

#include "erncconf.hpp"
#include "ernccm.hpp"
#include "ernctrc.h"
#include <iappldr.h>

#include "appldr.h"
#include <time.h>
#include <string.h>
#include "plgxprt.h"

#ifdef _DEBUG
BOOL    g_fInterfaceBreak = FALSE;
#endif

#define MAX_INVALID_PASSWORDS    5

// Global data structures.
DCRNCConferenceManager     *g_pNCConfMgr = NULL;
CQueryRemoteWorkList       *g_pQueryRemoteList = NULL;
INodeControllerEvents      *g_pCallbackInterface = NULL;
HINSTANCE                   g_hDllInst = NULL;
IT120ControlSAP            *g_pIT120ControlSap = NULL;
BOOL                        g_bRDS = FALSE;

extern PController g_pMCSController;

// Private function prototypes.

void HandleAddInd(AddIndicationMessage * pAddInd);
void HandleQueryConfirmation(QueryConfirmMessage * pQueryMessage);
void HandleQueryIndication(QueryIndicationMessage * pQueryMessage);
void HandleConductGiveInd(ConductGiveIndicationMessage * pConductGiveInd);
void HandleLockIndication(LockIndicationMessage * pLockInd);
void HandleUnlockIndication(UnlockIndicationMessage * pUnlockInd);
void HandleSubInitializedInd(SubInitializedIndicationMessage * pSubInitInd);
void HandleTimeInquireIndication(TimeInquireIndicationMessage * pTimeInquireInd);
void HandleApplicationInvokeIndication(ApplicationInvokeIndicationMessage * pInvokeMessage);

BOOL InitializePluggableTransport(void);
void CleanupPluggableTransport(void);



BOOL WINAPI DllMain(HINSTANCE hDllInst, DWORD fdwReason, LPVOID)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            g_hDllInst = hDllInst;
            ASSERT (g_hDllInst != NULL);
            DisableThreadLibraryCalls (hDllInst);
            DBG_INIT_MEMORY_TRACKING(hDllInst);
            ::InitializeCriticalSection(&g_csTransport);
            T120DiagnosticCreate();
            g_bRDS = ( NULL != ::FindAtomA("NMSRV_ATOM"));
            break;
        }

        case DLL_PROCESS_DETACH:
        {
             g_hDllInst = NULL;
            /*
             *    Go cleanup all resources on behalf of the process that is
             *    detaching from this DLL.
             */
            T120DiagnosticDestroy ();
            ::DeleteCriticalSection(&g_csTransport);
            DBG_CHECK_MEMORY_TRACKING(hDllInst);
            break;
        }
    }
    return (TRUE);
}


HRESULT WINAPI
T120_CreateNodeController
(
    INodeController         **ppNodeCtrlIntf,
    INodeControllerEvents   *pEventsCallback
)
{
    DebugEntry(T120_CreateNodeController);

    HRESULT hr;
    if (NULL == g_pNCConfMgr)
    {
        if (NULL != ppNodeCtrlIntf && NULL != pEventsCallback)
        {
            *ppNodeCtrlIntf = NULL;

            DBG_SAVE_FILE_LINE
            if (NULL != (g_pNCConfMgr = new DCRNCConferenceManager(pEventsCallback, &hr)))
            {
                if (S_OK == hr)
                {
                    *ppNodeCtrlIntf = (INodeController*) g_pNCConfMgr;
                }
                else
                {
                    g_pNCConfMgr->Release();
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = UI_RC_T120_ALREADY_INITIALIZED;
    }

    DebugExitHRESULT(T120_CreateNodeController, hr);
    return hr;
}


/****************************************************************************/
/* Constructor - see ernccm.hpp                                             */
/****************************************************************************/
DCRNCConferenceManager::
DCRNCConferenceManager
(
    INodeControllerEvents       *pCallback,
    HRESULT                     *pRetCode
)
:
    CRefCount(MAKE_STAMP_ID('N', 'C', 'C', 'M')),
    m_eState(CM_ST_UNINITIALIZED)
{
    GCCError    GCCrc;
    HRESULT     hr = NO_ERROR;

    DebugEntry(DCRNCConferenceManager::DCRNCConferenceManager);

    ::InitializePluggableTransport();

    //
    // There should be only one NC conference manager in the system.
    //
    ASSERT(NULL == g_pNCConfMgr);

    ASSERT(pRetCode);

    // initialize applet loader structure
    ::AppLdr_Initialize();

    //
    // Save the callback interface to nmcom.dll
    //
    g_pCallbackInterface = pCallback;

    //
    // Validate that there is a node name.
    //
    LPWSTR pwszNodeName;
    if (NULL != (pwszNodeName = ::GetNodeName()))
    {
        delete pwszNodeName;
    }
    else
    {
        ERROR_OUT(("Failed to obtain node name"));
        hr = UI_RC_NO_NODE_NAME;
        goto MyExit;
    }

    //
    // Load versioning information.
    //
    hr = ::InitOurVersion();
    if (NO_ERROR != hr)
    {
        ERROR_OUT(("Failed to load version info"));
        goto MyExit;
    }

    //
    // Create the query-remote list.
    //
    ASSERT(NULL == g_pQueryRemoteList);
    DBG_SAVE_FILE_LINE
    g_pQueryRemoteList = new CQueryRemoteWorkList();
    if (g_pQueryRemoteList == NULL)
    {
        ERROR_OUT(("Failed to create Query Remote List"));
        hr = UI_RC_OUT_OF_MEMORY;
        goto MyExit;
    }

    /************************************************************************/
    /* For GCCInitialize:                                                   */
    /*                                                                      */
    /* - pass in a pointer to CM as the user defined data, allowing         */
    /*   GCCCallBackHandler to call back into CM to handle GCC callbacks.   */
    /************************************************************************/
    GCCrc = ::T120_CreateControlSAP(&g_pIT120ControlSap, this, GCCCallBackHandler);
    if (GCCrc == GCC_NO_ERROR)
    {
        m_eState = CM_ST_GCC_INITIALIZED;
        hr = NO_ERROR;
    }
    else
    {
        ERROR_OUT(("Failed to initializeGCC, GCC error %d", GCCrc));
        hr = ::GetGCCRCDetails(GCCrc);
    }

MyExit:

    *pRetCode = hr;

    DebugExitHRESULT(DCRNCConferenceManager::DCRNCConferenceManager, hr);
}


/****************************************************************************/
/* Destructor - see ernccm.hpp                                              */
/****************************************************************************/
DCRNCConferenceManager::
~DCRNCConferenceManager(void)
{
    DebugEntry(DCRNCConferenceManager::~DCRNCConferenceManager);

    //
    // Make sure no one can use this global pointer any more since
    // we are deleting this object.
    //
    g_pNCConfMgr = NULL;
    g_pCallbackInterface = NULL;

    //
    // Release cached version
    //
    ::ReleaseOurVersion();

    //
    // Clean up the query-remote list
    //
    delete g_pQueryRemoteList;
    g_pQueryRemoteList = NULL;

    //
    // If we have initialized GCC, uninitialize it.
    //
    if (NULL != g_pIT120ControlSap)
    {
        ASSERT(CM_ST_GCC_INITIALIZED == m_eState);
        g_pIT120ControlSap->ReleaseInterface();
        g_pIT120ControlSap = NULL;
    }
    m_eState = CM_ST_UNINITIALIZED;

    ::CleanupPluggableTransport();

    DebugExitVOID(DCRNCConferenceManager::~DCRNCConferenceManager);
}



// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Implementation of INodeController interface
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


STDMETHODIMP_(void) DCRNCConferenceManager::
ReleaseInterface ( void )
{
    DebugEntry(DCRNCConferenceManager::ReleaseInterface);
    InterfaceEntry();

    // de-initialize applet loader structure
    ::AppLdr_Shutdown();

    //
    // End and delete all the conferences.
    //
    PCONFERENCE pConf;
    while (NULL != (pConf = m_ConfList.Get()))
    {
        RemoveConference(pConf, TRUE, TRUE);
    }

    //
    // Free the query remote list
    //
    g_pQueryRemoteList->DeleteList();

    //
    // Empty our sequential lists of entries without owners.
    //
    m_InviteIndWorkList.DeleteList();
    m_JoinIndWorkList.DeleteList();

    //
    // Reset the NC related data
    //
    g_pCallbackInterface = NULL;

    //
    // Release this object now.
    //
    Release();

    DebugExitVOID(DCRNCConferenceManager::ReleaseInterface);
}


STDMETHODIMP DCRNCConferenceManager::
QueryRemote
(
    LPVOID              pCallerContext,
    LPCSTR              pcszNodeAddress,
    BOOL                fSecure,
    BOOL                bIsConferenceActive
)
{
    DebugEntry(DCRNCConferenceManager::QueryRemote);
    InterfaceEntry();

    HRESULT hr;

#if defined(TEST_PLUGGABLE) && defined(_DEBUG)
    if (g_fWinsockDisabled)
    {
        pcszNodeAddress = ::FakeNodeAddress(pcszNodeAddress);
    }
#endif

    if (NULL != pcszNodeAddress)
    {
        // if winsock is disabled, block any IP address or machine name
        if (g_fWinsockDisabled)
        {
            if (! IsValidPluggableTransportName(pcszNodeAddress))
            {
                return UI_RC_NO_WINSOCK;
            }
        }

        // Construct context for the life of the request.
        DBG_SAVE_FILE_LINE
        CQueryRemoteWork *pQueryRemote;
        DBG_SAVE_FILE_LINE
        pQueryRemote = new CQueryRemoteWork(pCallerContext,
                                            bIsConferenceActive ? GCC_ASYMMETRY_CALLER : GCC_ASYMMETRY_UNKNOWN,
                                            // GCC_ASYMMETRY_CALLER, // lonchanc: always want to be the caller
                                            pcszNodeAddress,
                                            fSecure,
                                            &hr);
        if (NULL != pQueryRemote && NO_ERROR == hr)
        {
            //
            // LONCHANC: The following call is to put this query remote work item
            // to the global list, and do the work. We have to do this because
            // we removed the physical connection.
            //
            pQueryRemote->SetHr(NO_ERROR);

            // Put entry in list of pending query requests to
            // issue GCCConferenceQuery on connection.
            g_pQueryRemoteList->AddWorkItem(pQueryRemote);

            hr = NO_ERROR;
        }
        else
        {
            ERROR_OUT(("DCRNCConferenceManager::QueryRemote:: can't allocate query remote work item"));
            delete pQueryRemote;
            hr = UI_RC_OUT_OF_MEMORY;
        }
    }
    else
    {
        ERROR_OUT(("DCRNCConferenceManager::QueryRemote:: null pcszAddress"));
        hr = UI_RC_NO_ADDRESS;
    }

    DebugExitHRESULT(DCRNCConferenceManager::QueryRemote, hr);
    return hr;
}


STDMETHODIMP DCRNCConferenceManager::
CancelQueryRemote ( LPVOID pCallerContext )
{
    DebugEntry(DCRNCConferenceManager::CancelQueryRemote);
    InterfaceEntry();

    HRESULT hr = g_pQueryRemoteList->Cancel(pCallerContext);

    DebugExitHRESULT(DCRNCConferenceManager::CancelQueryRemote, hr);
    return hr;
}


STDMETHODIMP DCRNCConferenceManager::
CreateConference
(
    LPCWSTR             pcwszConfName,
    LPCWSTR             pcwszPassword,
    PBYTE        pbHashedPassword,
    DWORD        cbHashedPassword,
    BOOL        fSecure,
    CONF_HANDLE         *phConf
)
{
    DebugEntry(DCRNCConferenceManager::CreateConference);
    InterfaceEntry();

    HRESULT hr;

    if (NULL != phConf)
    {
        *phConf = NULL;
        if (! ::IsEmptyStringW(pcwszConfName))
        {
            PCONFERENCE     pNewConf;

            /************************************************************************/
            /* Create a new conference.                                             */
            /************************************************************************/
            hr = CreateNewConference(pcwszConfName, NULL, &pNewConf, FALSE, fSecure);
            if (NO_ERROR == hr)
            {
                ASSERT(NULL != pNewConf);

                /****************************************************************/
                /* Only need the name for a new local conference.               */
                /****************************************************************/
                hr = pNewConf->StartLocal(pcwszPassword, pbHashedPassword, cbHashedPassword);
                if (NO_ERROR == hr)
                {
                    pNewConf->SetNotifyToDo(TRUE);
                    *phConf = (CONF_HANDLE) pNewConf;
                }
                else
                {
                    ERROR_OUT(("DCRNCConferenceManager::CreateConference: can't start local conference, hr=0x%x", (UINT) hr));
                    if (hr != UI_RC_CONFERENCE_ALREADY_EXISTS)
                    {
                        RemoveConference(pNewConf);
                    }
                }
            }
            else
            {
                ERROR_OUT(("DCRNCConferenceManager::CreateConference: failed to create new conference, hr=0x%x", (UINT) hr));
            }
        }
        else
        {
            ERROR_OUT(("DCRNCConferenceManager::CreateConference: invalid conference name"));
            hr = UI_RC_NO_CONFERENCE_NAME;
        }
    }
    else
    {
        ERROR_OUT(("DCRNCConferenceManager::CreateConference: null phConf"));
        hr = UI_RC_BAD_PARAMETER;
    }

    DebugExitHRESULT(DCRNCConferenceManager::CreateConference, hr);
    return hr;
}


STDMETHODIMP DCRNCConferenceManager::
JoinConference
(
    LPCWSTR             pcwszConfName,
    LPCWSTR             pcwszPassword,
    LPCSTR              pcszNodeAddress,
    BOOL                fSecure,
    USERDATAINFO       *pUserDataInfoEntries,
    UINT                cUserDataEntries,
    CONF_HANDLE        *phConf
)
{
    DebugEntry(DCRNCConferenceManager::JoinConference);
    InterfaceEntry();

    HRESULT hr;

#if defined(TEST_PLUGGABLE) && defined(_DEBUG)
    if (g_fWinsockDisabled)
    {
        pcszNodeAddress = ::FakeNodeAddress(pcszNodeAddress);
    }
#endif

    if (NULL != phConf)
    {
        *phConf = NULL;
        if (! ::IsEmptyStringW(pcwszConfName) && NULL != pcszNodeAddress)
        {
            // if winsock is disabled, block any IP address or machine name
            if (g_fWinsockDisabled)
            {
                if (! IsValidPluggableTransportName(pcszNodeAddress))
                {
                    return UI_RC_NO_WINSOCK;
                }
            }

            PCONFERENCE     pNewConf;

            // Create a new conference, or find a new conference that
            // has just rejected a join because of an invalid password,
            // and call its Join() entry point.
            hr = CreateNewConference(pcwszConfName, NULL, &pNewConf, TRUE, fSecure);
            if (NO_ERROR == hr)
            {
                // First join attempt. Do all of the start connection.
                hr = pNewConf->Join((LPSTR) pcszNodeAddress,
                                    pUserDataInfoEntries,
                                    cUserDataEntries,
                                    pcwszPassword);
            }
            else
            if (hr == UI_RC_CONFERENCE_ALREADY_EXISTS)
            {
                // Conference already exists.
                // Look to see if it is awaiting a join with a password.
                // If so, then retry the join.
                // Otherwise drop through to return an error.
                // Note that we walk the list here again to find the existing
                // conference rather than pass back from CreateNewConference(),
                // because that would be a side effect behavior that can (and has!)
                // introduce obscure bugs in unrelated code.
                hr = NO_ERROR;
                pNewConf = GetConferenceFromName(pcwszConfName);
                ASSERT(NULL != pNewConf);
                if( NULL == pNewConf )
                {
                    hr = UI_RC_NO_CONFERENCE_NAME;
                }
                else if (! pNewConf->IsConnListEmpty())
                {
                    CLogicalConnection *pConEntry = pNewConf->PeekConnListHead();
                    if (pConEntry->GetState() == CONF_CON_PENDING_PASSWORD)
                    {
                        hr = pNewConf->JoinWrapper(pConEntry, pcwszPassword);
                    }
                }
            }

            // Delete the conference if the join fails
            // for any reason other than trying to join
            // a local conference.
            if (NO_ERROR == hr)
            {
                pNewConf->SetNotifyToDo(TRUE);
                *phConf = (CONF_HANDLE) pNewConf;
            }
            else
            {
                if (hr != UI_RC_CONFERENCE_ALREADY_EXISTS)
                {
                    ERROR_OUT(("DCRNCConferenceManager::JoinConference: Failed to create new conference, hr=0x%x", (UINT) hr));
                }
                RemoveConference(pNewConf);
            }
        }
        else
        {
            hr = (pcszNodeAddress == NULL) ? UI_RC_NO_ADDRESS : UI_RC_NO_CONFERENCE_NAME;
            ERROR_OUT(("DCRNCConferenceManager::JoinConference: invalid parameters, hr=0x%x", (UINT) hr));
        }
    }
    else
    {
        ERROR_OUT(("DCRNCConferenceManager::JoinConference: null phConf"));
        hr = UI_RC_BAD_PARAMETER;
    }

    DebugExitHRESULT(DCRNCConferenceManager::JoinConference, hr);
    return hr;
}


STDMETHODIMP DCRNCConferenceManager::
GetUserData
(
    ROSTER_DATA_HANDLE  hUserData,
    const GUID         *pcGUID,
    UINT               *pcbData,
    LPVOID             *ppvData
)
{
    DebugEntry(DCRNCConferenceManager::GetUserData);
    InterfaceEntry();

    HRESULT hr;
    GCCNodeRecord * pRosterEntry = (GCCNodeRecord *) hUserData;

    if (NULL != pRosterEntry)
    {
        ASSERT(NULL != pcbData);
        hr = ::GetUserData(pRosterEntry->number_of_user_data_members,
                           pRosterEntry->user_data_list,
                           (GUID*) pcGUID,
                           pcbData,
                           ppvData);
        if (NO_ERROR != hr && UI_RC_NO_SUCH_USER_DATA != hr)
        {
            ERROR_OUT(("DCRNCConferenceManager::GetUserData: GetUserData failed, hr=0x%x", (UINT) hr));
        }
    }
    else
    {
        hr = UI_RC_BAD_ADDRESS;
        ERROR_OUT(("DCRNCConferenceManager::GetUserData: null pRosterEntry"));
    }

    DebugExitHRESULT(DCRNCConferenceManager::GetUserData, hr);
    return hr;
}


STDMETHODIMP_(UINT) DCRNCConferenceManager::
GetPluggableConnID
(
    LPCSTR pcszNodeAddress
)
{
    return ::GetPluggableTransportConnID(pcszNodeAddress);
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Implementation of Methods for DCRNCConferenceManager
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


void DCRNCConferenceManager::
WndMsgHandler(UINT uMsg, LPARAM lParam)
{
    DebugEntry(DCRNCConferenceManager::WndMsgHandler);
    TRACE_OUT(("DCRNCConferenceManager::WndMsgHandler: uMsg=%u, lParam=0x%x", (UINT) uMsg, (UINT) lParam));

    switch (uMsg)
    {
    case NCMSG_FIRST_ROSTER_RECVD:
        {
            PCONFERENCE pConf = (PCONFERENCE) lParam;
            if (NULL != pConf)
            {
                pConf->FirstRoster();
            }
        }
        break;

    case NCMSG_QUERY_REMOTE_FAILURE:
        {
            CQueryRemoteWork *pWork = (CQueryRemoteWork *) lParam;
            if (NULL != pWork)
            {
                pWork->SyncQueryRemoteResult();
            }
        }
        break;

    default:
        ERROR_OUT(("DCRNCConferenceManager::WndMsgHandler: unknown msg=%u, lParam=0x%x", uMsg, (UINT) lParam));
        break;
    }

    DebugExitVOID(DCRNCConferenceManager::WndMsgHandler);
}


/****************************************************************************/
/* CreateNewConference - create a new instance of DCRNCConference and add   */
/* it to the conference list.                                               */
/****************************************************************************/
HRESULT DCRNCConferenceManager::
CreateNewConference
(
    LPCWSTR             pcwszConfName,
    GCCConfID           nConfID,
    PCONFERENCE        *ppConf,
    BOOL                fFindExistingConf,
    BOOL                fSecure
)
{
    HRESULT hr;

    DebugEntry(DCRNCConferenceManager::CreateNewConference);
    ASSERT(ppConf);

    // Make sure there is not already an active conference of the same name.
    PCONFERENCE pConf = GetConferenceFromName(pcwszConfName);
    if (NULL == pConf)
    {
        // Add new conference
        DBG_SAVE_FILE_LINE
        pConf = new DCRNCConference(pcwszConfName, nConfID, fSecure, &hr);
        if (NULL != pConf && NO_ERROR == hr)
        {
            // Conference added, so include in list.
            m_ConfList.Append(pConf);
#ifdef _DEBUG
            pConf->OnAppended();
#endif

            // This reference is for nmcom.dll so that ReleaseInterface will do
            // the right thing.
            pConf->AddRef();
        }
        else
        {
            ERROR_OUT(("DCRNCConferenceManager::CreateNewConference: can't create conf, hr=0x%x, pConf=0x%p", (UINT) hr, pConf));
            if (pConf == NULL)
            {
                hr = UI_RC_OUT_OF_MEMORY;
            }
            else
            {
                pConf->Release();
                pConf = NULL;
            }
        }

        *ppConf = pConf;
    }
    else
    {
        WARNING_OUT(("DCRNCConferenceManager::CreateNewConference: conf already exists"));
        hr = UI_RC_CONFERENCE_ALREADY_EXISTS;
        *ppConf = fFindExistingConf ? pConf : NULL;
    }

    DebugExitHRESULT(DCRNCConferenceManager::CreateNewConference, hr);
    return hr;
}


/***************************************************************************/
/* GetConfIDFromMessage() - Get the conference ID from the message.        */
/***************************************************************************/
GCCConfID GetConfIDFromMessage ( GCCMessage * pGCCMessage )
{
    GCCConfID nConfID = pGCCMessage->nConfID;

#ifdef _DEBUG
    /************************************************************************/
    /* Dig the conference ID out of the message.                            */
    /************************************************************************/
    switch (pGCCMessage->message_type)
    {
    case GCC_CREATE_INDICATION:
        // nConfID = pGCCMessage->u.create_indication.conference_id;
        break;

    case GCC_CREATE_CONFIRM:
        // nConfID = pGCCMessage->u.create_confirm.conference_id;
        break;

    case GCC_JOIN_CONFIRM:
        // nConfID = pGCCMessage->u.join_confirm.conference_id;
        break;

    case GCC_INVITE_CONFIRM:
        // nConfID = pGCCMessage->u.invite_confirm.conference_id;
        break;

    case GCC_ADD_CONFIRM:
        // nConfID = pGCCMessage->u.add_confirm.conference_id;
        break;

    case GCC_DISCONNECT_INDICATION:
        // nConfID = pGCCMessage->u.disconnect_indication.conference_id;
        break;

    case GCC_DISCONNECT_CONFIRM:
        // nConfID = pGCCMessage->u.disconnect_confirm.conference_id;
        break;

    case GCC_TERMINATE_INDICATION:
        // nConfID = pGCCMessage->u.terminate_indication.conference_id;
        break;

    case GCC_TERMINATE_CONFIRM:
        // nConfID = pGCCMessage->u.terminate_confirm.conference_id;
        break;

    case GCC_ANNOUNCE_PRESENCE_CONFIRM:
        // nConfID = pGCCMessage->u.announce_presence_confirm.conference_id;
        break;

    case GCC_ROSTER_REPORT_INDICATION:
        // nConfID = pGCCMessage->u.conf_roster_report_indication.conference_id;
        break;

    case GCC_ROSTER_INQUIRE_CONFIRM:
        // nConfID = pGCCMessage->u.conf_roster_inquire_confirm.conference_id;
        break;

    case GCC_PERMIT_TO_ANNOUNCE_PRESENCE:
        // nConfID = pGCCMessage->u.permit_to_announce_presence.conference_id;
        break;

    case GCC_EJECT_USER_INDICATION:
        // nConfID = pGCCMessage->u.eject_user_indication.conference_id;
        break;

    default :
        // nConfID = 0;
        ERROR_OUT(("Unknown message"));
        break;
    }
#endif // _DEBUG

    return nConfID;
}


PCONFERENCE DCRNCConferenceManager::
GetConferenceFromID ( GCCConfID conferenceID )
{
    PCONFERENCE pConf = NULL;
    m_ConfList.Reset();
    while (NULL != (pConf = m_ConfList.Iterate()))
    {
        if (pConf->GetID() == conferenceID)
        {
            break;
        }
    }
    return pConf;
}


PCONFERENCE DCRNCConferenceManager::
GetConferenceFromName ( LPCWSTR pcwszConfName )
{
    PCONFERENCE pConf = NULL;
    if (! ::IsEmptyStringW(pcwszConfName))
    {
        m_ConfList.Reset();
        while (NULL != (pConf = m_ConfList.Iterate()))
        {
            if ((0 == ::My_strcmpW(pConf->GetName(), pcwszConfName)) &&
                (pConf->IsActive()))
            {
                break;
            }
        }
    }
    return pConf;
}


// GetConferenceFromNumber - get the T120 conference with the specified number.

PCONFERENCE DCRNCConferenceManager::
GetConferenceFromNumber ( GCCNumericString NumericName )
{
    PCONFERENCE pConf = NULL;

    if (! ::IsEmptyStringA(NumericName))
    {
        m_ConfList.Reset();
        while (NULL != (pConf = m_ConfList.Iterate()))
        {
            LPSTR pszConfNumericName = pConf->GetNumericName();
            if (NULL != pszConfNumericName &&
                0 == ::lstrcmpA(pszConfNumericName, NumericName))
            {
                break;
            }
        }
    }

    return pConf;
}


/****************************************************************************/
/* Handle a GCC callback.                                                   */
/****************************************************************************/
void DCRNCConferenceManager::
HandleGCCCallback ( GCCMessage * pGCCMessage )
{
    DebugEntry(DCRNCConferenceManager::HandleGCCCallback);
    TRACE_OUT(("DCRNCConferenceManager::HandleGCCCallback: msg_type=%u", (UINT) pGCCMessage->message_type));

    switch (pGCCMessage->message_type)
    {
    case GCC_CREATE_CONFIRM:
        {
            PCONFERENCE pConf;
            LPWSTR pwszConfName;

            // For create confirm, the conference won't
            // know its ID yet (it is contained in this message), so get
            // the conference by name.
            if (NO_ERROR == ::GetUnicodeFromGCC(
                                pGCCMessage->u.create_confirm.conference_name.numeric_string,
                                pGCCMessage->u.create_confirm.conference_name.text_string,
                                &pwszConfName))
            {
                pConf = GetConferenceFromName(pwszConfName);
                if (NULL != pConf)
                {
                    pConf->HandleGCCCallback(pGCCMessage);
                }
                delete pwszConfName;
            }
        }
        break;

    case GCC_JOIN_CONFIRM:
        HandleJoinConfirm(&(pGCCMessage->u.join_confirm));
        break;

    case GCC_CONDUCT_GIVE_INDICATION:
        HandleConductGiveInd(&(pGCCMessage->u.conduct_give_indication));
        break;

    case GCC_JOIN_INDICATION:
        HandleJoinInd(&(pGCCMessage->u.join_indication));
        break;

    case GCC_ADD_INDICATION:
        HandleAddInd(&(pGCCMessage->u.add_indication));
        break;

    case GCC_SUB_INITIALIZED_INDICATION:
        HandleSubInitializedInd(&(pGCCMessage->u.conf_sub_initialized_indication));
        break;

    case GCC_ROSTER_REPORT_INDICATION:
        // update the (node id, name) list and user data
        UpdateNodeIdNameListAndUserData(pGCCMessage);
        // fall through
    case GCC_INVITE_CONFIRM:
    case GCC_ADD_CONFIRM:
    case GCC_DISCONNECT_INDICATION:
    case GCC_DISCONNECT_CONFIRM:
    case GCC_TERMINATE_INDICATION:
    case GCC_TERMINATE_CONFIRM:
    case GCC_ANNOUNCE_PRESENCE_CONFIRM:
    case GCC_ROSTER_INQUIRE_CONFIRM:
    case GCC_PERMIT_TO_ANNOUNCE_PRESENCE:
    case GCC_EJECT_USER_INDICATION:
        {
            /****************************************************************/
            /* All these events are passed straight onto one of our         */
            /* conferences.                                                 */
            /****************************************************************/

            /****************************************************************/
            /* Get the conference ID from the message                       */
            /****************************************************************/
            GCCConfID nConfID = ::GetConfIDFromMessage(pGCCMessage);

            /****************************************************************/
            /* See whether we have a conference with this ID;               */
            /****************************************************************/
            PCONFERENCE pConf = GetConferenceFromID(nConfID);
            if (NULL != pConf)
            {
                /****************************************************************/
                /* Pass the event onto the conference.                          */
                /****************************************************************/
                pConf->HandleGCCCallback(pGCCMessage);
            }
            else
            {
                // bugbug: should still reply to indications that require a response.
                TRACE_OUT(("DCRNCConferenceManager::HandleGCCCallback: No conference found with ID %d", nConfID));
            }
        }
        break;

#ifdef TSTATUS_INDICATION
    case GCC_TRANSPORT_STATUS_INDICATION:
        {
            WORD state = 0;
            TRACE_OUT(("DCRNCConferenceManager::HandleGCCCallback: GCC msg type GCC_TRANSPORT_STATUS_INDICATION"));
            TRACE_OUT(("Device identifier '%s'",
                 pGCCMessage->u.transport_status.device_identifier));
            TRACE_OUT(("Remote address '%s'",
                 pGCCMessage->u.transport_status.remote_address));
            TRACE_OUT(("Message '%s'",
                 pGCCMessage->u.transport_status.message));
            state = pGCCMessage->u.transport_status.state;
        #ifdef DEBUG
            LPSTR stateString =
            (state == TSTATE_NOT_READY       ? "TSTATE_NOT_READY" :
            (state == TSTATE_NOT_CONNECTED   ? "TSTATE_NOT_CONNECTED" :
            (state == TSTATE_CONNECT_PENDING ? "TSTATE_CONNECT_PENDING" :
            (state == TSTATE_CONNECTED       ? "TSTATE_CONNECTED" :
            (state == TSTATE_REMOVED         ? "TSTATE_REMOVED" :
            ("UNKNOWN STATE"))))));
            TRACE_OUT(("DCRNCConferenceManager::HandleGCCCallback: Transport state %d (%s)",
                 pGCCMessage->u.transport_status.state,
                 (const char *)stateString));
        #endif // DEBUG
        }
        break;

    case GCC_STATUS_INDICATION:
        {
            WORD state = 0;
        #ifdef DEBUG
            LPSTR stateString =
            (state == GCC_STATUS_PACKET_RESOURCE_FAILURE    ? "GCC_STATUS_PACKET_RESOURCE_FAILURE  " :
            (state == GCC_STATUS_PACKET_LENGTH_EXCEEDED     ? "GCC_STATUS_PACKET_LENGTH_EXCEEDED   " :
            (state == GCC_STATUS_CTL_SAP_RESOURCE_ERROR     ? "GCC_STATUS_CTL_SAP_RESOURCE_ERROR   " :
            (state == GCC_STATUS_APP_SAP_RESOURCE_ERROR     ? "GCC_STATUS_APP_SAP_RESOURCE_ERROR   " :
            (state == GCC_STATUS_CONF_RESOURCE_ERROR        ? "GCC_STATUS_CONF_RESOURCE_ERROR      " :
            (state == GCC_STATUS_INCOMPATIBLE_PROTOCOL      ? "GCC_STATUS_INCOMPATIBLE_PROTOCOL    " :
            (state == GCC_STATUS_JOIN_FAILED_BAD_CONF_NAME  ? "GCC_STATUS_JOIN_FAILED_BAD_CONF_NAME" :
            (state == GCC_STATUS_JOIN_FAILED_BAD_CONVENER   ? "GCC_STATUS_JOIN_FAILED_BAD_CONVENER " :
            (state == GCC_STATUS_JOIN_FAILED_LOCKED         ? "GCC_STATUS_JOIN_FAILED_LOCKED       " :
            ("UNKNOWN STATUS"))))))))));
            TRACE_OUT(("DCRNCConferenceManager::HandleGCCCallback: GCC_STATUS_INDICATION, type %d (%s)",
                pGCCMessage->u.status_indication.status_message_type,
                (const char *)stateString));
        #endif  // DEBUG
        }
        break;
#endif  // TSTATUS_INDICATION

    case GCC_INVITE_INDICATION:
        /****************************************************************/
        /* We have been invited into a conference: Create a new         */
        /* (incoming) conference.                                        */
        /****************************************************************/
        HandleInviteIndication(&(pGCCMessage->u.invite_indication));
        break;

    case GCC_CREATE_INDICATION:
        /****************************************************************/
        /* A new conference has been created.                           */
        /****************************************************************/
        HandleCreateIndication(&(pGCCMessage->u.create_indication));
        break;

    case GCC_QUERY_CONFIRM:
        HandleQueryConfirmation(&(pGCCMessage->u.query_confirm));
        break;

    case GCC_QUERY_INDICATION:
        HandleQueryIndication(&(pGCCMessage->u.query_indication));
        break;

    case GCC_CONNECTION_BROKEN_INDICATION:
        BroadcastGCCCallback(pGCCMessage);
        break;

    case GCC_LOCK_INDICATION:
        HandleLockIndication(&(pGCCMessage->u.lock_indication));
        break;

    // case GCC_APPLICATION_INVOKE_CONFIRM:
        // This just indicates the g_pIT120ControlSap->AppletInvokeRequest succeeded.
        // There is no official confirmation from the remote machine.
        // FUTURE: Add protocol + code to respond to the launch request.
        // break;

    case GCC_APPLICATION_INVOKE_INDICATION:
        HandleApplicationInvokeIndication(&(pGCCMessage->u.application_invoke_indication));
        break;

    case GCC_UNLOCK_INDICATION:
        HandleUnlockIndication(&(pGCCMessage->u.unlock_indication));
        break;

    case GCC_TIME_INQUIRE_INDICATION:
        HandleTimeInquireIndication(&(pGCCMessage->u.time_inquire_indication));
        break;

#ifdef DEBUG
    case GCC_APP_ROSTER_REPORT_INDICATION:
        TRACE_OUT(("DCRNCConferenceManager::HandleGCCCallback: GCC msg type GCC_APP_ROSTER_REPORT_INDICATION"));
        break;
#endif /* DEBUG */

    default :
        /****************************************************************/
        /* This should be an exhaustive list of all the events we dont  */
        /* handle:                                                      */
        /*                                                              */
        /*  GCC_TEXT_MESSAGE_INDICATION                                 */
        /*  GCC_TIME_REMAINING_INDICATION                               */
        /*                                                              */
        /*  GCC_ALLOCATE_HANDLE_CONFIRM                                 */
        /*  GCC_APP_ROSTER_INQUIRE_CONFIRM                              */
        /*  GCC_ASSIGN_TOKEN_CONFIRM                                    */
        /*  GCC_ASSISTANCE_CONFIRM                                      */
        /*  GCC_ASSISTANCE_INDICATION                                   */
        /*  GCC_CONDUCT_ASK_CONFIRM                                     */
        /*  GCC_CONDUCT_ASK_INDICATION                                  */
        /*  GCC_CONDUCT_ASSIGN_CONFIRM                                  */
        /*  GCC_CONDUCT_ASSIGN_INDICATION                               */
        /*  GCC_CONDUCT_GIVE_CONFIRM                                    */
        /*  GCC_CONDUCT_GRANT_CONFIRM                                   */
        /*  GCC_CONDUCT_GRANT_INDICATION                                */
        /*  GCC_CONDUCT_INQUIRE_CONFIRM                                 */
        /*  GCC_CONDUCT_PLEASE_CONFIRM                                  */
        /*  GCC_CONDUCT_PLEASE_INDICATION                               */
        /*  GCC_CONDUCT_RELEASE_CONFIRM                                 */
        /*  GCC_CONDUCT_RELEASE_INDICATION                              */
        /*  GCC_CONFERENCE_EXTEND_CONFIRM                               */
        /*  GCC_CONFERENCE_EXTEND_INDICATION                            */
        /*  GCC_DELETE_ENTRY_CONFIRM                                    */
        /*  GCC_EJECT_USER_CONFIRM                                      */
        /*  GCC_ENROLL_CONFIRM                                          */
        /*  GCC_LOCK_CONFIRM                                            */
        /*  GCC_LOCK_REPORT_INDICATION                                  */
        /*  GCC_MONITOR_CONFIRM                                         */
        /*  GCC_MONITOR_INDICATION                                      */
        /*  GCC_PERMIT_TO_ENROLL_INDICATION:                            */
        /*  GCC_REGISTER_CHANNEL_CONFIRM                                */
        /*  GCC_RETRIEVE_ENTRY_CONFIRM                                  */
        /*  GCC_SET_PARAMETER_CONFIRM                                   */
        /*  GCC_TEXT_MESSAGE_CONFIRM                                    */
        /*  GCC_TIME_INQUIRE_CONFIRM                                    */
        /*  GCC_TIME_REMAINING_CONFIRM                                  */
        /*  GCC_TRANSFER_CONFIRM                                        */
        /*  GCC_TRANSFER_INDICATION                                     */
        /*  GCC_UNLOCK_CONFIRM                                          */
        /****************************************************************/
        TRACE_OUT(("DCRNCConferenceManager::HandleGCCCallback: Ignoring msg_type=%u", pGCCMessage->message_type));
        break;
    }

    DebugExitVOID(DCRNCConferenceManager::HandleGCCCallback);
}


void DCRNCConferenceManager::
BroadcastGCCCallback ( GCCMessage *pGCCMessage )
{
    DebugEntry(DCRNCConferenceManager::BroadcastGCCCallback);

    // An event has come in that is of potential interest to all
    // conferences, so pass it on to them.
    // Note that this is currently only used for broken logical
    // connections that are actually on a single conference because
    // T120 maps logical connections to conferences.
    PCONFERENCE pConf;
    m_ConfList.Reset();
    while (NULL != (pConf = m_ConfList.Iterate()))
    {
        pConf->HandleGCCCallback(pGCCMessage);
    }

    DebugExitVOID(DCRNCConferenceManager::BroadcastGCCCallback);
}


// HandleJoinConfirm - handle a GCC_JOIN_CONFIRM message.
void DCRNCConferenceManager::
HandleJoinConfirm ( JoinConfirmMessage * pJoinConfirm )
{
    PCONFERENCE         pConf = NULL;
    LPWSTR              pwszConfName;

    DebugEntry(DCRNCConferenceManager::HandleJoinConfirm);

    // For join confirm, the conference won't know its ID yet
    // (it is contained in this message),
    // so get the conference by name.
    HRESULT hr = GetUnicodeFromGCC((PCSTR)pJoinConfirm->conference_name.numeric_string,
                                    pJoinConfirm->conference_name.text_string,
                                    &pwszConfName);
    if (NO_ERROR == hr)
    {
        pConf = GetConferenceFromName(pwszConfName);
        delete pwszConfName;
    }

    if (pConf == NULL)
    {
        pConf = GetConferenceFromNumber(pJoinConfirm->conference_name.numeric_string);
    }

    if (pConf != NULL)
    {
        pConf->HandleJoinConfirm(pJoinConfirm);
    }

    DebugExitVOID(DCRNCConferenceManager::HandleJoinConfirm);
}


#ifdef ENABLE_START_REMOTE
// HandleCreateIndication - handle a GCC_CREATE_INDICATION message.
void DCRNCConferenceManager::
HandleCreateIndication ( CreateIndicationMessage * pCreateMessage )
{
    PCONFERENCE         pNewConference = NULL;
    HRESULT             hr = UI_RC_USER_REJECTED;
    LPWSTR              name;

    DebugEntry(DCRNCConferenceManager::HandleCreateIndication);

    TRACE_OUT(("GCC event:  GCC_CREATE_INDICATION"));
    TRACE_OUT(("Conference ID %ld", pCreateMessage->conference_id));
    if (pCreateMessage->conductor_privilege_list == NULL)
    {
        TRACE_OUT(("Conductor privilege list is NULL"));
    }
    else
    {
        TRACE_OUT(("Conductor priv, terminate allowed %d",
            pCreateMessage->conductor_privilege_list->terminate_is_allowed));
    }

    if (pCreateMessage->conducted_mode_privilege_list == NULL)
    {
        TRACE_OUT(("Conducted mode privilege list is NULL"));
    }
    else
    {
        TRACE_OUT(("Conducted mode priv, terminate allowed %d",
            pCreateMessage->conducted_mode_privilege_list->terminate_is_allowed));
    }

    if (pCreateMessage->non_conducted_privilege_list == NULL)
    {
        TRACE_OUT(("Non-conducted mode privilege list is NULL"));
    }
    else
    {
        TRACE_OUT(("non-conducted priv, terminate allowed %d",
            pCreateMessage->non_conducted_privilege_list->terminate_is_allowed));
    }

    hr = ::GetUnicodeFromGCC((PCSTR)pCreateMessage->conference_name.numeric_string,
                             (PWSTR)pCreateMessage->conference_name.text_string,
                             &name);
    if (NO_ERROR == hr)
    {
        hr = CreateNewConference(name,
                                pCreateMessage->conference_id,
                                &pNewConference);
        delete name;
    }

    if (NO_ERROR == hr)
    {
        hr = pNewConference->StartIncoming();
        if (NO_ERROR == hr)
        {
            g_pNCConfMgr->CreateConferenceRequest(pNewConference);
            return;
        }
    }

    ERROR_OUT(("Failed to create incoming conference"));
    GCCCreateResponse(hr, pMsg->conference_id, &pMsg->conference_name);

    DebugExitVOID(DCRNCConferenceManager::HandleCreateIndication);
}
#endif // ENABLE_START_REMOTE


void DCRNCConferenceManager::
GCCCreateResponse
(
    HRESULT             hr,
    GCCConfID           conference_id,
    GCCConferenceName * pGCCName
)
{
    DebugEntry(DCRNCConferenceManager::GCCCreateResponse);

    GCCError GCCrc =  g_pIT120ControlSap->ConfCreateResponse(
                                NULL,
                                conference_id,
                                0,
                                NULL,        /*  domain_parameters              */
                                0,           /*  number_of_network_addresses    */
                                NULL,        /*  local_network_address_list     */
                                0,           /*  number_of_user_data_members    */
                                NULL,        /*  user_data_list                 */
                                ::MapRCToGCCResult(hr));
    TRACE_OUT(("GCC call: g_pIT120ControlSap->ConfCreateResponse, rc=%d", GCCrc));

    DebugExitVOID(DCRNCConferenceManager::GCCCreateResponse);
}


/****************************************************************************/
/* HandleInviteIndication - handle a GCC_INVITE_INDICATION message.         */
/****************************************************************************/
void DCRNCConferenceManager::
HandleInviteIndication ( InviteIndicationMessage * pInviteMessage )
{
    LPWSTR                  pwszConfName;
    PCONFERENCE             pNewConference = NULL;
    HRESULT                 hr;
    CLogicalConnection     *pConEntry;
    CInviteIndWork         *pInviteUI;
    PT120PRODUCTVERSION     pVersion;

    DebugEntry(DCRNCConferenceManager::HandleInviteIndication);

    TRACE_OUT(("GCC event: GCC_INVITE_INDICATION"));
    TRACE_OUT(("Invited into conference ID %ld", pInviteMessage->conference_id));


    // Create a new conference, using the constructor for an incoming T120
    // conference.
    hr = GetUnicodeFromGCC((PCSTR)pInviteMessage->conference_name.numeric_string,
                           (PWSTR)pInviteMessage->conference_name.text_string,
                           &pwszConfName);

    //
    // Check to see if we're allowed to be invited. We may never get here
    // if we properly signal callers that we won't accept a nonsecure
    // Invite, but if they do it anyway or lead with T.120 we will enforce
    // the registry setting here.
    //
    RegEntry re(CONFERENCING_KEY, HKEY_CURRENT_USER);

    if ( re.GetNumber(REGVAL_SECURITY_INCOMING_REQUIRED,
                        DEFAULT_SECURITY_INCOMING_REQUIRED ))
    {
        if ( !pInviteMessage->fSecure )
        {
            WARNING_OUT(("HandleInviteIndication: CONNECTION is NOT SECURE"));
            hr = UI_RC_T120_SECURITY_FAILED;
        }
    }

    if (NO_ERROR == hr)
    {
        hr = CreateNewConference(pwszConfName,
                                 pInviteMessage->conference_id,
                                 &pNewConference,
                                 FALSE,
                                 pInviteMessage->fSecure);
        delete pwszConfName;
        if (NO_ERROR == hr)
        {
            // Make sure the conference object does not go away randomly.
            pNewConference->AddRef();

            pNewConference->SetActive(FALSE);
            DBG_SAVE_FILE_LINE
            pConEntry = pNewConference->NewLogicalConnection(CONF_CON_INVITED,
                                        pInviteMessage->connection_handle,
                                        NULL,
                                        0,
                                        pInviteMessage->fSecure);
            if (NULL != pConEntry)
            {
                // Save the T120 connection handle in the connection record
                // so that disconnect indications take down the conference.
                pConEntry->SetInviteReqConnHandle(pInviteMessage->connection_handle);
                hr = pNewConference->StartIncoming();

                // Linearize the invite requests so that two invites don't fight each other
                // for attention, and so that the second invite has a conference to see in
                // rosters and join if the first invite gets accepted.
                if (NO_ERROR == hr)
                {
                    pVersion = ::GetVersionData(pInviteMessage->number_of_user_data_members,
                                                pInviteMessage->user_data_list);
                    DBG_SAVE_FILE_LINE
                    pInviteUI = new CInviteIndWork(pNewConference,
                                        (LPCWSTR)(pInviteMessage->caller_identifier),
                                        pVersion,
                                        pInviteMessage->user_data_list,
                                        pInviteMessage->number_of_user_data_members,
                                        pConEntry);
                    if (pInviteUI)
                    {
                        pNewConference->SetInviteIndWork(pInviteUI);
                        m_InviteIndWorkList.AddWorkItem(pInviteUI);
                        hr = NO_ERROR;
                    }
                    else
                    {
                        hr = UI_RC_OUT_OF_MEMORY;
                    }
                }
            }
            else
            {
                hr = UI_RC_OUT_OF_MEMORY;
            }

            // This Release corresponds to the above AddRef.
            if (0 == pNewConference->Release())
            {
                // Make sure no one will use it any more.
                pNewConference = NULL;
            }
        }
    }

    if (NO_ERROR != hr)
    {
        if (NULL != pNewConference)
        {
            pNewConference->InviteResponse(hr);
        }
        else
        {
            // LONCHANC: we have to somehow send a response PDU out.
            g_pIT120ControlSap->ConfInviteResponse(
                            pInviteMessage->conference_id,
                            NULL,
                            pInviteMessage->fSecure,
                            NULL,               //  domain parms
                            0,                  //  number_of_network_addresses
                            NULL,               //  local_network_address_list
                            g_nVersionRecords,  //  number_of_user_data_members
                            g_ppVersionUserData,//  user_data_list
                            GCC_RESULT_ENTRY_ALREADY_EXISTS);
        }
    }

    DebugExitHRESULT(DCRNCConferenceManager::HandleInviteIndication, hr);
}



/****************************************************************************/
/* HandleJoinInd - handle a GCC_JOIN_INDICATION message.                    */
/****************************************************************************/
void DCRNCConferenceManager::
HandleJoinInd ( JoinIndicationMessage * pJoinInd )
{
    DebugEntry(DCRNCConferenceManager::HandleJoinInd);

    GCCResult Result = GCC_RESULT_SUCCESSFUL;

    // Look up conference ID, and if not found, dismiss request.
    CJoinIndWork           *pJoinUI;
    CLogicalConnection     *pConEntry;
    PT120PRODUCTVERSION     pVersion;

    PCONFERENCE pConf = GetConferenceFromID(pJoinInd->conference_id);
    if (NULL != pConf)
    {
        //
        // Under RDS, if this conference has been hit with bad passwords
        // too many times, everyone is out of luck and we will not accept
        // anyone into this conference anymore.
        //

        if (g_bRDS && ( pConf->InvalidPwdCount() >= MAX_INVALID_PASSWORDS ))
        {
            WARNING_OUT(("RDS: locked out by too many bad pwd attempts"));
            Result = GCC_RESULT_USER_REJECTED;
        }
        // Validate conference password, if required.
        else if (!pConf->ValidatePassword(pJoinInd->password_challenge))
        {
            //
            // Only increment the wrong password count if one was
            // supplied
            //

            if ( pJoinInd->password_challenge )
                pConf->IncInvalidPwdCount();

            if ( g_bRDS &&
                ( pConf->InvalidPwdCount() >= MAX_INVALID_PASSWORDS ))
            {
                Result = GCC_RESULT_USER_REJECTED;
            }
            else
            {
                Result = GCC_RESULT_INVALID_PASSWORD;
            }
        }
        else
            pConf->ResetInvalidPwdCount();
    }
    else
    {
        Result = GCC_RESULT_INVALID_CONFERENCE;
    }

    if (Result == GCC_RESULT_SUCCESSFUL)
    {
        DBG_SAVE_FILE_LINE
        pConEntry = pConf->NewLogicalConnection(
                                            CONF_CON_JOINED,
                                            pJoinInd->connection_handle,
                                            NULL,
                                            0,
                                            pConf->IsSecure());
        if (NULL != pConEntry)
        {
            HRESULT hr;
            pVersion = ::GetVersionData(pJoinInd->number_of_user_data_members,
                                        pJoinInd->user_data_list);
            DBG_SAVE_FILE_LINE
            pJoinUI = new CJoinIndWork(pJoinInd->join_response_tag,
                                       pConf,
                                       pJoinInd->caller_identifier,
                                       pConEntry,
                                       pVersion,
                                       pJoinInd->number_of_user_data_members,
                                       pJoinInd->user_data_list,
                                       &hr);
            if (NULL != pJoinUI && NO_ERROR == hr)
            {
                m_JoinIndWorkList.AddWorkItem(pJoinUI);
                return;
            }

            // Handle failure
            delete pJoinUI;
            pConEntry->Delete(UI_RC_OUT_OF_MEMORY);
        }
        Result = GCC_RESULT_RESOURCES_UNAVAILABLE;
    }

    ::GCCJoinResponseWrapper(pJoinInd->join_response_tag,
                             NULL,
                             Result,
                             pJoinInd->conference_id);

    DebugExitVOID(DCRNCConferenceManager::HandleJoinInd);
}


void HandleQueryConfirmation ( QueryConfirmMessage * pQueryMessage )
{
    DebugEntry(HandleQueryConfirmation);

    ASSERT(g_pQueryRemoteList);

    CQueryRemoteWork *pQueryRemote;

    // Must have a pending query and it must be first in
    // sequential work list.
    g_pQueryRemoteList->Reset();
    while (NULL != (pQueryRemote = g_pQueryRemoteList->Iterate()))
    {
        if (pQueryRemote->GetConnectionHandle() == pQueryMessage->connection_handle)
        {
            // GCC has given us a valid query response, so handle it.
            pQueryRemote->HandleQueryConfirmation(pQueryMessage);
            break;
        }
    }

    if (NULL == pQueryRemote)
    {
        // Unexpected GCC Query Confirmation.
        WARNING_OUT(("HandleQueryConfirmation: Unmatched GCCQueryConfirm"));
    }

    DebugExitVOID(HandleQueryConfirmation);
}


/****************************************************************************/
/* NotifyConferenceComplete() - see ernccm.hpp                              */
/****************************************************************************/
void DCRNCConferenceManager::
NotifyConferenceComplete
(
    PCONFERENCE         pConf,
    BOOL                bIncoming,
    HRESULT             result
)
{
    DebugEntry(DCRNCConferenceManager::NotifyConferenceComplete);

    ASSERT(NULL != pConf);

    // If the new conference was successfully added, then ensure that it
    // is marked as active. This is for the invite case, and is done before
    // telling the UI about the conference.
    HRESULT hr = result;
    if (NO_ERROR == hr)
    {
        pConf->SetActive(TRUE);
    }

    // If the conference failed to start, tell the UI so that
    // it can display a pop-up.
    // Note this this allows message pre-emption which can cause GCC to give back a GCC event.
    // In particular, a JoinRequest completion event, which must be ignored.

    // The following is a guard because NotifyConferenceComplete is called all
    // over the place and we do not want the user notified through callbacks
    // for inline errors. All inline errors are meant to trickle back through the
    // originating API, so these callbacks are only enabled once the user is returned
    // success.
    if (pConf->GetNotifyToDo())
    {
        pConf->SetNotifyToDo(FALSE);

        //
        // LONCHANC: This function may be called inside
        // ConfMgr::ReleaseInterface(). As a result, the global pointer
        // to the callback interface may already be nulled out.
        // Check it before use it.
        //
        if (NULL != g_pCallbackInterface)
        {
            g_pCallbackInterface->OnConferenceStarted(pConf, hr);
        }
    }

    if (NO_ERROR == hr)
    {
        // If the conference is new as the result of an invite, then it has an entry
        // at the start of the sequential work item list. Now that the conference is up
        // and the UI has been told, this entry is removed to allow other invite
        // requests to be processed.
        m_InviteIndWorkList.RemoveWorkItem(pConf->GetInviteIndWork());
        pConf->SetInviteIndWork(NULL);
    }
    else
    {
        RemoveConference(pConf);
    }

    DebugExitVOID(DCRNCConferenceManager::NotifyConferenceComplete);
}


/****************************************************************************/
/* NotifyRosterChanged() - see ernccm.hpp                                   */
/****************************************************************************/


// RemoveConference() - remove the conference from the conference list,
// and destroy the conference.
void DCRNCConferenceManager::
RemoveConference ( PCONFERENCE pConf, BOOL fDontCheckList, BOOL fReleaseNow )
{
    DebugEntry(DCRNCConferenceManager::RemoveConference);

    if (pConf != NULL)
    {
        if (m_ConfList.Remove(pConf) || fDontCheckList)
        {
            pConf->OnRemoved(fReleaseNow);
            m_InviteIndWorkList.PurgeListEntriesByOwner(pConf);
            m_JoinIndWorkList.PurgeListEntriesByOwner(pConf);
        }
        else
        {
            // If we get here, we haven't found the conference.
            // This actually happens because when a conference is being
            // terminated, its destructor calls DCRNCConference::Leave()
            // to ensure a speedy exit, if required. However, if the
            // conference is currently not yet active (e.g. waiting for
            // the user to supply a password), calling Leave() causes
            // RemoveConference() to be called back. In this case,
            // because the conference has already been removed from the
            // list, this function does nothing.
        }
    }

    DebugExitVOID(DCRNCConferenceManager::RemoveConference);
}


/****************************************************************************/
/* EjectUserFromConference() - see ernccm.hpp                               */
/****************************************************************************/


/****************************************************************************/
/* SendUserTextMessage() - see ernccm.hpp                               */
/****************************************************************************/


/****************************************************************************/
/* TimeRemainingInConference() - see ernccm.hpp                               */
/****************************************************************************/


/****************************************************************************/
/* GCC callback function.                                                   */
/****************************************************************************/
void CALLBACK DCRNCConferenceManager::
GCCCallBackHandler ( GCCMessage * pGCCMessage )
{
    DCRNCConferenceManager *pConfManager;

    /************************************************************************/
    /* The message has a user defined field which we use to store a pointer */
    /* to the CM class.  Use it to pass the message onto CM.                */
    /************************************************************************/
    pConfManager = (DCRNCConferenceManager *) pGCCMessage->user_defined;

    //
    // Check the pointer isnt completely daft,
    // and guard against getting events after shutting down
    // (a current bug in GCC/MCS).
    if (pConfManager == g_pNCConfMgr)
    {
        /************************************************************************/
        /* Pass the message onto CM and return the returned code.               */
        /************************************************************************/
        g_pNCConfMgr->HandleGCCCallback(pGCCMessage);
    }
    else
    {
        WARNING_OUT(("Dud user_defined field, pConfMgr=%p, g_pNCConfMgr=%p",
                        pConfManager, g_pNCConfMgr));
    }
}




HRESULT GCCJoinResponseWrapper
(
    GCCResponseTag                  join_response_tag,
    GCCChallengeRequestResponse    *password_challenge,
    GCCResult                       result,
    GCCConferenceID                 conferenceID,
    UINT                            nUserData,
    GCCUserData                   **ppUserData
)
{
    HRESULT     hr;
    GCCError    GCCrc;

    DebugEntry(GCCJoinResponseWrapper);

    TRACE_OUT(("GCC event:  GCC_JOIN_INDICATION"));
    TRACE_OUT(("Response tag %d", join_response_tag));

    if (g_pControlSap->IsThisNodeTopProvider(conferenceID) == FALSE)
    {
        GCCrc = g_pIT120ControlSap->ConfJoinResponse(join_response_tag,
                                            password_challenge,
                                            nUserData,
                                            ppUserData,
                                            result);

    }
    else
    {
        GCCrc = g_pIT120ControlSap->ConfJoinResponse(join_response_tag,
                                            password_challenge,
                                            g_nVersionRecords,
                                            g_ppVersionUserData,
                                            result);
    }
    hr = ::GetGCCRCDetails(GCCrc);
    TRACE_OUT(("GCC call:  g_pIT120ControlSap->ConfJoinResponse, rc=%d", GCCrc));

    if ((GCCrc != GCC_NO_ERROR) &&
        (result != GCC_RESULT_USER_REJECTED))
    {
        /********************************************************************/
        /* If the call to join response fails, we must try again to reject  */
        /* the join request.                                                */
        /********************************************************************/
        ERROR_OUT(("GCCJoinResponseWrapper: GCC error %d responding to join ind", GCCrc));
        GCCrc = g_pIT120ControlSap->ConfJoinResponse(join_response_tag,
                                            password_challenge,
                                            g_nVersionRecords,
                                            g_ppVersionUserData,
                                            GCC_RESULT_USER_REJECTED);

        TRACE_OUT(("GCC call:  g_pIT120ControlSap->ConfJoinResponse (again), rc=%d", GCCrc));
        if (GCCrc != GCC_NO_ERROR)
        {
            /****************************************************************/
            /* If it fails a second time we really are in deep doggy-do.    */
            /****************************************************************/
            ERROR_OUT(("GCCJoinResponseWrapper: g_pIT120ControlSap->ConfJoinResponse failed again..."));
        }
    }

    DebugExitHRESULT(GCCJoinResponseWrapper, hr);
    return hr;
}


void HandleQueryIndication ( QueryIndicationMessage * pQueryMessage )
{
    DebugEntry(HandleQueryIndication);

    GCCAsymmetryIndicator   ai, ai2;
    GCCNodeType             node_type;
    GCCError                GCCrc;
    CQueryRemoteWork       *pQueryRemote = NULL;
    GCCResult                result = GCC_RESULT_SUCCESSFUL;
    OSVERSIONINFO           osvi;

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (FALSE == ::GetVersionEx (&osvi))
    {
        ERROR_OUT(("GetVersionEx() failed!"));
    }

    if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId &&  g_bRDS )
    {
        SOCKET socket_number;
        if (g_pMCSController->FindSocketNumber(pQueryMessage->connection_handle, &socket_number))
        {
            TransportConnection XprtConn;
            SET_SOCKET_CONNECTION(XprtConn, socket_number);
            PSocket pSocket = g_pSocketList->FindByTransportConnection(XprtConn);
            ASSERT(NULL != pSocket);
            if (NULL != pSocket)
            {
                AddToMessageLog(EVENTLOG_INFORMATION_TYPE,
                                0,
                                MSG_INF_ACCESS,
                                pSocket->Remote_Address);
                pSocket->Release();
            }
        }
    }
    // If the caller did not pass in the protocol for deciding who is caller
    // then fabricate something for him and make him the caller.

    if (pQueryMessage->asymmetry_indicator)
    {
        ai = *pQueryMessage->asymmetry_indicator;
    }
    else
    {
        ai.asymmetry_type = GCC_ASYMMETRY_CALLER;
        ai.random_number = 0;
    }

    // let's set default random number, which will be read only in the "unknown" case.
    ai2.random_number = ai.random_number;

    // prepare the query respone
    switch (ai.asymmetry_type)
    {
    case GCC_ASYMMETRY_CALLED:
        ai2.asymmetry_type = GCC_ASYMMETRY_CALLER;
        break;
    case GCC_ASYMMETRY_CALLER:
        ai2.asymmetry_type = GCC_ASYMMETRY_CALLED;
        break;
    case GCC_ASYMMETRY_UNKNOWN:
        // Check if we are not in a pending query
        ASSERT(g_pQueryRemoteList);
        if (! g_pQueryRemoteList->IsEmpty())
        {
            pQueryRemote = g_pQueryRemoteList->PeekHead();
        }
        // If we queryed as unknown
        if (pQueryRemote && pQueryRemote->IsInUnknownQueryRequest())
        {
            pQueryRemote->GetAsymIndicator(&ai2);
            if (ai2.asymmetry_type == GCC_ASYMMETRY_UNKNOWN &&
                ai2.random_number  > ai.random_number)
            {
                result = GCC_RESULT_USER_REJECTED;
            }
        }
        else
        {
            ai2.asymmetry_type = GCC_ASYMMETRY_UNKNOWN;
            // ai2.random_number = ~ ai.random_number;
            ai2.random_number--; // lonchanc: we should always be the callee in this case.
        }
        break;

    default:
        result = GCC_RESULT_USER_REJECTED;
        break;
    }

    // Figure out my node type.
    LoadAnnouncePresenceParameters(&node_type, NULL, NULL, NULL);

    // Issue reply.
    GCCrc = g_pIT120ControlSap->ConfQueryResponse(
                                       pQueryMessage->query_response_tag,
                                       node_type,
                                       &ai2,
                                       g_nVersionRecords,
                                       g_ppVersionUserData,
                                       result);
    if (GCCrc)
    {
        TRACE_OUT(("HandleQueryIndication: g_pIT120ControlSap->ConfQueryResponse failed, rc=%d", GCCrc));
    }

    DebugExitVOID(HandleQueryIndication);
}


void HandleConductGiveInd ( ConductGiveIndicationMessage * pConductGiveInd )
{
    DebugEntry(HandleConductGiveInd);

    // Node controller does not accept conductorship being handed over
    // from another node, so reject request.
    GCCError GCCrc = g_pIT120ControlSap->ConductorGiveResponse(pConductGiveInd->conference_id,
                                                GCC_RESULT_USER_REJECTED);
    TRACE_OUT(("HandleConductGiveInd: Failed to reject ConductGiveIndication, gcc_rc=%u", (UINT) GCCrc));

    DebugExitVOID(HandleConductGiveInd);
}


void HandleAddInd ( AddIndicationMessage * pAddInd )
{
    DebugEntry(HandleAddInd);

    // Just reject the request because we don't do adds on behalf of someone else.
    GCCError GCCrc = g_pIT120ControlSap->ConfAddResponse(
                             pAddInd->add_response_tag,     // add_response_tag
                             pAddInd->conference_id,        // conference_id
                             pAddInd->requesting_node_id,   // requesting_node
                             0,                             // number_of_user_data_members
                             NULL,                          // user_data_list
                             GCC_RESULT_USER_REJECTED);     // result
    TRACE_OUT(("HandleAddInd: Failed to reject AddIndication, gcc_rc=%u", (UINT) GCCrc));

    DebugExitVOID(HandleAddInd);
}


void HandleLockIndication ( LockIndicationMessage * pLockInd )
{
    DebugEntry(HandleLockIndication);

    // Just reject the request because we don't do locked conferences.
    GCCError GCCrc = g_pIT120ControlSap->ConfLockResponse(
                            pLockInd->conference_id,        // conference_id
                            pLockInd->requesting_node_id,   // requesting_node
                            GCC_RESULT_USER_REJECTED);      // result
    TRACE_OUT(("HandleLockIndication: Failed to reject LockIndication, gcc_rc=%u", (UINT) GCCrc));

    DebugExitVOID(HandleLockIndication);
}


void HandleUnlockIndication ( UnlockIndicationMessage * pUnlockInd )
{
    DebugEntry(HandleUnlockIndication);

    // Reject the request because we don't manage
    // locking/unlocking of conferences.
    GCCError GCCrc = g_pIT120ControlSap->ConfLockResponse(
                            pUnlockInd->conference_id,        // conference_id
                            pUnlockInd->requesting_node_id,   // requesting_node
                            GCC_RESULT_USER_REJECTED);      // result
    TRACE_OUT(("HandleUnlockIndication: Failed to reject UnlockIndication, gcc_rc=%u", (UINT) GCCrc));

    DebugExitVOID(HandleUnlockIndication);
}


void HandleSubInitializedInd ( SubInitializedIndicationMessage * pSubInitInd )
{
    DebugEntry(HandleSubInitializedInd);

    CLogicalConnection *pConEntry = g_pNCConfMgr->GetConEntryFromConnectionHandle(
                                        pSubInitInd->connection_handle);
    if (NULL != pConEntry)
    {
        pConEntry->SetConnectionNodeID(pSubInitInd->subordinate_node_id);
    }

    DebugExitVOID(HandleSubInitializedInd);
}


// This function is used by the GCC_SUB_INITIALIZED_INDICATION handler.
// This handler was added to bind the request to enter someone into
// a conference to the resulting conference roster, so that you could
// tell which new entry in the roster was the one you requested in.
// Since the above handler only gets a connection handle (recast here to a
// request handle) and a userID, this means that the local GCC implementation
// is guarunteeing that connection handles are unique to a local machine
// and not duplicated in different conferences (this fact is also being used
// by the node controller to know when someone invited into a conference leaves).
CLogicalConnection *  DCRNCConferenceManager::
GetConEntryFromConnectionHandle ( ConnectionHandle hInviteIndConn )
{
    PCONFERENCE             pConf;
    CLogicalConnection      *pConEntry;

    m_ConfList.Reset();
    while (NULL != (pConf = m_ConfList.Iterate()))
    {
        pConEntry = pConf->GetConEntry(hInviteIndConn);
        if (NULL != pConEntry)
        {
            return(pConEntry);
        }
    }
    return(NULL);
}


void HandleTimeInquireIndication ( TimeInquireIndicationMessage * pTimeInquireInd )
{
    DebugEntry(HandleTimeInquireIndication);

    // Since we don't currently time messages, and there is no mechanism to say this,
    // or to even say that there is no such conference that we know about, just
    // say that the conference has one hour remaining, with the same scope as the request.
    UserID      node_id = pTimeInquireInd->time_is_conference_wide ?
                                    0 : pTimeInquireInd->requesting_node_id;
    GCCError    GCCrc = g_pIT120ControlSap->ConfTimeRemainingRequest(
                                    pTimeInquireInd->conference_id,
                                    60*60,
                                    node_id);
    TRACE_OUT(("HandleTimeInquireIndication: Failed to return Time Remaining, gcc_rc=%u", (UINT) GCCrc));

    DebugExitVOID(HandleTimeInquireIndication);
}


BOOL DCRNCConferenceManager::
FindSocketNumber
(
    GCCNodeID           nid,
    SOCKET              *socket_number
)
{
    // Currently we are relying on the fact there is only one conference at a time.
    PCONFERENCE pConf = m_ConfList.PeekHead();
    if (NULL != pConf)
    {
        return pConf->FindSocketNumber(nid, socket_number);
    }
    return FALSE;
}


/*  H A N D L E  A P P L I C A T I O N  I N V O K E  I N D I C A T I O N */
/*----------------------------------------------------------------------------
    %%Function: HandleApplicationInvokeIndication

    TODO: use GCC_OBJECT_KEY instead of GCC_H221_NONSTANDARD_KEY
----------------------------------------------------------------------------*/
#define NUMBER_OF_INTERNAL_STD_APPLETS        2
typedef struct
{
    ULONG        cNodes;
    const ULONG  *aNodes;
    APPLET_ID     eAppletId;
}
    INTERNAL_STD_INVOKE_APPLET;


static const ULONG c_T126ObjectID[] = {0,0,20,126,0,1}; // Whiteboard
static const ULONG c_T127ObjectID[] = {0,0,20,127,0,1}; // File Transfer

static INTERNAL_STD_INVOKE_APPLET s_aStdAppletInvokeInfo[NUMBER_OF_INTERNAL_STD_APPLETS] =
{
    {    // T.126 Whiteboard
        sizeof(c_T126ObjectID) / sizeof(c_T126ObjectID[0]),
        &c_T126ObjectID[0],
        APPLET_ID_WB
    },
    {    // T.127 File Transfer
        sizeof(c_T127ObjectID) / sizeof(c_T127ObjectID[0]),
        &c_T127ObjectID[0],
        APPLET_ID_FT
    },
};

void InvokeAppletEntity(GCCConfID, GCCNodeID, GCCAppProtocolEntity*);
int  GetInternalStandardAppletInvokeFunction(ULONG, ULONG*);


void HandleApplicationInvokeIndication ( ApplicationInvokeIndicationMessage * pInvokeMessage )
{
    DebugEntry(HandleApplicationInvokeIndication);

    for (ULONG i = 0; i < pInvokeMessage->number_of_app_protocol_entities; i++)
    {
        InvokeAppletEntity(pInvokeMessage->conference_id,
                           pInvokeMessage->invoking_node_id,
                           pInvokeMessage->app_protocol_entity_list[i]);
    }

    DebugExitVOID(HandleApplicationInvokeIndication);
}


int GetInternalStandardAppletInvokeFunction(ULONG cNodes, ULONG aNodes[])
{
    for (ULONG i = 0; i < sizeof(s_aStdAppletInvokeInfo) / sizeof(s_aStdAppletInvokeInfo[0]); i++)
    {
        INTERNAL_STD_INVOKE_APPLET *p = &s_aStdAppletInvokeInfo[i];
        if (cNodes == p->cNodes)
        {
            if (0 == memcmp(aNodes, p->aNodes, cNodes * sizeof(ULONG)))
            {
                return (int)p->eAppletId;
            }
        }
    }
    return -1;
}


void InvokeAppletEntity
(
    GCCConfID                   nConfID,
    GCCNodeID                   nidInitiator,
    GCCAppProtocolEntity       *pAppEntity
)
{
    DebugEntry(InvokeAppletEntity);

    int   iAppletId;
    HKEY  hkey;
    ULONG cNodes, cbDataSize, i;
    ULONG *pNodeID;
    LPOSTR postrNonStdKey;
    LPBYTE pbData;
    GCCSessionID sidApplet = pAppEntity->session_key.session_id;
    CApplet *pApplet;
    char szGuid[LENGTH_SZGUID_FORMATTED];
    char szKey[MAX_PATH];
    szKey[0] = '\0'; // safety net

    //    if (!pAppEntity->must_be_invoked)
    //    return; // this is optional and can fail

    switch (pAppEntity->session_key.application_protocol_key.key_type)
    {
    case GCC_OBJECT_KEY:
        //
        // Standard object key
        //
        cNodes = pAppEntity->session_key.application_protocol_key.object_id.long_string_length;
        pNodeID = pAppEntity->session_key.application_protocol_key.object_id.long_string;

        // check if it is an internal standard applet
        iAppletId = GetInternalStandardAppletInvokeFunction(cNodes, pNodeID);
        if (iAppletId >= 0)
        {
            // Invoke the internal applet
            WARNING_OUT(("Find internal standard applet %s.\n",
                        iAppletId?"File Transfer":"White Board"));
            T120_LoadApplet((APPLET_ID)iAppletId, FALSE, 0, FALSE, NULL);
            return;
        }

        // ok, it is not an internal applet, convert it to hexa-dot string to look for
        // a registered third-party applet
        // Format:  T120_APPLET_KEY\T120_STD_KEY\{hex-dot string} '\0'
        if (0 < cNodes && NULL != pNodeID &&
            (cNodes << 2) + sizeof(T120_APPLET_KEY) + sizeof(T120_STD_KEY) < MAX_PATH - 2)
        {
            ::wsprintfA(szKey, "%s\\%s\\%s", T120_APPLET_KEY, T120_STD_KEY, "{");
            LPSTR pszKey = szKey + ::lstrlenA(szKey);
            for (i = 0; i < cNodes; i++, pNodeID++)
            {
                ::wsprintf(pszKey, "%08X.", (UINT) *pNodeID);
                pszKey += ::lstrlenA(pszKey);
            }
                strcpy(pszKey-1, "}"); // remove the last dot character
                WARNING_OUT(("Find standard applet: %s\n", szKey));
        }
        else
        {
            ERROR_OUT(("InvokeAppletEntity: cannot handle standard key size=%u", cNodes));
            return;
        }
        break;

    case GCC_H221_NONSTANDARD_KEY:
        //
        // Non-standard object key
        //
        postrNonStdKey = &pAppEntity->session_key.application_protocol_key.h221_non_standard_id;
        if (GetGuidFromH221AppKey(szGuid, postrNonStdKey))
        {
            //
            // Microsoft non-standard object key
            // NetMeeting's DataChannel
            //
            ::wsprintfA(szKey, "%s\\%s", GUID_KEY, szGuid);
            WARNING_OUT(("Find Microsoft non-standard applet: %s\n", szKey));
        }
        else
        {
            //
            // Non-Microsoft non-standard object key
            //

            // Third-party's non-standard object key.
            // In this case, we convert the octet string into dotted decimal string,
            // like an IP address.
            // Each byte can take four characters in the dotted decimal string.
            // Format:  T120_APPLET_KEY\T120_NONSTD_KEY\{hex-dot string}'\0'
            cbDataSize = postrNonStdKey->length;
            pbData = postrNonStdKey->value;
            if (0 < cbDataSize && NULL != pbData &&
                (cbDataSize << 2) + sizeof(T120_APPLET_KEY) + sizeof(T120_NONSTD_KEY) < MAX_PATH - 2)
            {
                ::wsprintfA(szKey, "%s\\%s\\%s", T120_APPLET_KEY, T120_NONSTD_KEY, "{");
                LPSTR pszKey = szKey + ::lstrlenA(szKey);
                for (i = 0; i < cbDataSize; i++, pbData++)
                {
                    ::wsprintfA(pszKey, "%02X.", (UINT) *pbData);
                    pszKey += ::lstrlenA(pszKey);
                }
                strcpy(pszKey-1, "}"); // remove the last dot character
                WARNING_OUT(("Find third party non-standard applet: %s\n", szKey));
            }
            else
            {
                ERROR_OUT(("InvokeAppletEntity: cannot handle non-std key size=%u", cbDataSize));
                return;
            }
        }
        break;

    default:
        ERROR_OUT(("InvokeAppletEntity: invalid object key type=%u", pAppEntity->session_key.application_protocol_key.key_type));
        return;
    }

    // Look for the registry key. open the registry now
    RegEntry GuidKey(szKey, HKEY_LOCAL_MACHINE, FALSE, KEY_READ);
    if (NO_ERROR == GuidKey.GetError())
    {
        LPSTR szAppName = ::My_strdupA(GuidKey.GetString(REGVAL_GUID_APPNAME));
        LPSTR szCmdLine = ::My_strdupA(GuidKey.GetString(REGVAL_GUID_CMDLINE));
        LPSTR szCurrDir = ::My_strdupA(GuidKey.GetString(REGVAL_GUID_CURRDIR));

        if ((NULL != szAppName) || (NULL != szCmdLine))
        {
            LPSTR lpEnv;
            STARTUPINFO startupInfo;
            PROCESS_INFORMATION processInfo;
            char szEnv[32];

            ::ZeroMemory(&processInfo, sizeof(processInfo));
            ::ZeroMemory(&startupInfo, sizeof(startupInfo));
            startupInfo.cb = sizeof(startupInfo);

            // set the special environment variables
            ::wsprintfA(szEnv, "%u", nConfID);
            SetEnvironmentVariable(ENV_CONFID, szEnv);
            ::wsprintfA(szEnv, "%u", nidInitiator);
            SetEnvironmentVariable(ENV_NODEID, szEnv);

            lpEnv = ::GetEnvironmentStrings();

            ::CreateProcess(
                szAppName,      // pointer to name of executable module
                szCmdLine,      // pointer to command line string
                NULL,           // pointer to process security attributes
                NULL,           // pointer to thread security attributes
                FALSE,          // handle inheritance flag
                0,              // creation flags
                lpEnv,          // pointer to new environment block
                szCurrDir,      // pointer to current directory name
                &startupInfo,   // pointer to STARTUPINFO
                &processInfo);  // pointer to PROCESS_INFORMATION

            if (NULL != lpEnv)
            {
                ::FreeEnvironmentStrings(lpEnv);
            }
        }

        delete szAppName;
        delete szCmdLine;
        delete szCurrDir;
    }
    else
    {
        WARNING_OUT(("InvokeAppletEntity: no such registry=[%s]", szKey));
    }

    DebugExitVOID(InvokeAppletEntity);
}


LPWSTR GetNodeName(void)
{
    LPWSTR      pwszName;
    LPSTR       pszName;
    RegEntry    NameKey(ISAPI_KEY "\\" REGKEY_USERDETAILS);

    if (g_bRDS) // Running as service?
    {
        char szName[MAX_COMPUTERNAME_LENGTH+2] = "";
        DWORD dwBuf = sizeof(szName);
        if ( !GetComputerName((LPSTR)szName,&dwBuf) )
        {
            ERROR_OUT(("GetNameName: GetComputerName failed"));
        }
        pwszName = ::AnsiToUnicode(szName);
    }
    else
    {
        pszName = NameKey.GetString(REGVAL_ULS_NAME);
        pwszName = ::AnsiToUnicode(pszName);
    }

    if (::IsEmptyStringW(pwszName))
    {
        WARNING_OUT(("GetNodeName: No node name"));
        delete pwszName;
        pwszName = NULL;
    }

//    TRACE_OUT(("GetNodeName: pszName=%s", pszName));
    return pwszName;
}


// Update <NodeId,Name> pair
void DCRNCConferenceManager::
UpdateNodeIdNameListAndUserData(GCCMessage * pGCCMessage)
{
    GCCConfID  ConfId = pGCCMessage->nConfID;
    PCONFERENCE pConf = GetConferenceFromID(ConfId);
    if (pConf)
        pConf->UpdateNodeIdNameListAndUserData(pGCCMessage);
}


// Query node name
ULONG DCRNCConferenceManager::
GetNodeName(GCCConfID  ConfId,  GCCNodeID   NodeId,
            LPSTR  pszBuffer, ULONG  cbBufSize)
{
    PCONFERENCE  pConf = GetConferenceFromID(ConfId);
    if (pConf)
        return pConf->GetNodeName(NodeId, pszBuffer, cbBufSize);
    return 0;
}

// Query user data
ULONG DCRNCConferenceManager::
GetUserGUIDData(GCCConfID  ConfId,  GCCNodeID   NodeId,
                GUID  *pGuid,  LPBYTE  pbBuffer, ULONG  cbBufSize)
{
    PCONFERENCE  pConf = GetConferenceFromID(ConfId);
    if (pConf)
        return pConf->GetUserGUIDData(NodeId, pGuid, pbBuffer, cbBufSize);
    return 0;
}


ULONG WINAPI T120_GetNodeName(GCCConfID  ConfId,  GCCNodeID   NodeId,
                                LPSTR  pszBuffer, ULONG  cbBufSize)
{
    return g_pNCConfMgr->GetNodeName(ConfId, NodeId, pszBuffer, cbBufSize);
}

ULONG WINAPI T120_GetUserData(GCCConfID  ConfId,  GCCNodeID   NodeId,
                                GUID  *pGuid,     LPBYTE pbBuffer,
                                ULONG  cbBufSize)
{
    return g_pNCConfMgr->GetUserGUIDData(ConfId, NodeId, pGuid, pbBuffer, cbBufSize);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\ernccm.hpp ===
/****************************************************************************/
/*                                                                          */
/* ERNCCM.HPP                                                               */
/*                                                                          */
/* Conference Manager class for the Reference System Node Controller.       */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  16Jun95 NFC             Created.                                        */
/*                                                                          */
/****************************************************************************/

#ifndef __ERNCCM_HPP_
#define __ERNCCM_HPP_

#include "events.hpp"
#include "erncconf.hpp"
#include "inodecnt.h"
#include "csap.h"


class DCRNCConference;
class CLogicalConnection;
extern INodeControllerEvents  *g_pCallbackInterface;
extern BOOL g_bRDS;


/****************************************************************************/
/* Values for CM state.                                                     */
/****************************************************************************/
typedef enum
{
    CM_ST_UNINITIALIZED,
    CM_ST_CPI_INITIALIZED,
    CM_ST_GCC_INITIALIZED,
    CM_ST_STARTING_CMP,
    CM_ST_CMP_STARTED,
}
    NC_CONF_MGR_STATE;

class CNCConfList : public CList
{
    DEFINE_CLIST(CNCConfList, DCRNCConference*)
};

class DCRNCConferenceManager : public INodeController, public CRefCount
{
    friend class DCRNCConference;
    friend class CInviteIndWork;

public:

	//
	// INodeController Methods:
	//
	STDMETHODIMP_(void) ReleaseInterface(void);
	STDMETHODIMP CheckVersion(          PT120PRODUCTVERSION pRemoteVersion);
	STDMETHODIMP QueryRemote(           LPVOID              pCallerContext,
										LPCSTR              pcszAddress,
                                        BOOL                fSecure,
										BOOL                fIsConferenceActive);
	STDMETHOD(CancelQueryRemote)(       LPVOID              pCallerContext);
	STDMETHODIMP CreateConference(      LPCWSTR             pcwszConferenceName,
										LPCWSTR             pcwszPassword,
										PBYTE               pbHashedPassword,
										DWORD		    cbHashedPassword,
										BOOL				fSecure,
										PCONF_HANDLE        phConference);
	STDMETHODIMP JoinConference(        LPCWSTR             pcwszConferenceName,
										LPCWSTR             pcwszPassword,
										LPCSTR              pcszAddress,
										BOOL				fSecure,
										PUSERDATAINFO       pUserDataInfoEntries,
										UINT                cUserDataEntries,
										PCONF_HANDLE        phConference);
    STDMETHODIMP GetUserData(           ROSTER_DATA_HANDLE  hUserData, 
										const GUID*         pcGUID, 
										PUINT               pcbData, 
										LPVOID*             ppvData);

    STDMETHODIMP_(UINT) GetPluggableConnID (LPCSTR pcszNodeAddress);

public:

    DCRNCConferenceManager(INodeControllerEvents *pCallback, HRESULT * pStatus);
    virtual ~DCRNCConferenceManager(void);

    void WndMsgHandler(UINT uMsg, LPARAM lParam);
    void PostWndMsg(UINT uMsg, LPARAM lParam)
    {
        ::PostMessage(g_pControlSap->GetHwnd(), uMsg, (WPARAM) this, lParam);
    }


    void NotifyConferenceComplete(PCONFERENCE  pConference,
                                  BOOL       bIncoming,
                                  HRESULT     result);

    PCONFERENCE GetConferenceFromName(LPCWSTR pcwszConfName);
    PCONFERENCE GetConferenceFromNumber(GCCNumericString NumericName);

    CLogicalConnection * GetConEntryFromConnectionHandle(ConnectionHandle hInviteIndConn);

    static void CALLBACK GCCCallBackHandler (GCCMessage * gcc_message);

    void AddInviteIndWorkItem(CInviteIndWork * pWorkItem) { m_InviteIndWorkList.AddWorkItem(pWorkItem); }

    void RemoveInviteIndWorkItem(CInviteIndWork * pWorkItem) { m_InviteIndWorkList.RemoveWorkItem(pWorkItem); }
    void RemoveJoinIndWorkItem(CJoinIndWork * pWorkItem) { m_JoinIndWorkList.RemoveWorkItem(pWorkItem); }

    CJoinIndWork *PeekFirstJoinIndWorkItem(void) { return m_JoinIndWorkList.PeekHead(); }

    BOOL FindSocketNumber(GCCNodeID nid, SOCKET * socket_number);

    /************************************************************************/
    /* RemoveConference() - remove the conference from the conference list. */
    /************************************************************************/
    void RemoveConference(PCONFERENCE pConf, BOOL fDontCheckList = FALSE, BOOL fReleaseNow = FALSE);
	ULONG GetNodeName(GCCConfID,  GCCNodeID, LPSTR, ULONG);
	ULONG GetUserGUIDData(GCCConfID,  GCCNodeID, GUID*, LPBYTE, ULONG);

protected:

    void GCCCreateResponse(
    					   HRESULT				rc,
    					   GCCConferenceID		conference_id,
    					   GCCConferenceName *	pGCCName);
    HRESULT CreateNewConference(PCWSTR				wszconferenceName,
    							 GCCConferenceID	conferenceID,
    							 PCONFERENCE *		ppConference,
    							 BOOL   fFindExistingConf,
    							 BOOL	fSecure);

    PCONFERENCE  GetConferenceFromID(GCCConferenceID conferenceID);

    void HandleGCCCallback(GCCMessage * pGCCMessage);
    void BroadcastGCCCallback(GCCMessage FAR * pGCCMessage);

    void HandleJoinConfirm(JoinConfirmMessage * pJoinConfirm);

#ifdef ENABLE_START_REMOTE
    void HandleCreateIndication(CreateIndicationMessage * pCreateMessage);
#else
    void HandleCreateIndication(CreateIndicationMessage *pMsg)
    {
        GCCCreateResponse(UI_RC_USER_REJECTED, pMsg->conference_id, &pMsg->conference_name);
    }
#endif // ENABLE_START_REMOTE

    void HandleInviteIndication(InviteIndicationMessage * pInviteMessage);

    void HandleJoinInd(JoinIndicationMessage * pJoinInd);

    /************************************************************************/
    /* MapConftoCMRC - map a CONFERENCE return code to a CM return code.    */
    /************************************************************************/
    HRESULT MapConftoCMRC(HRESULT confrc);

	void UpdateNodeIdNameListAndUserData(GCCMessage * pGCCMessage);

private:

    /************************************************************************/
    /* State of the conference manager.                                     */
    /************************************************************************/
    NC_CONF_MGR_STATE       m_eState;

    /************************************************************************/
    /* Sequential lists of work to give to UI/receive answers from          */
    /************************************************************************/
    CInviteIndWorkList      m_InviteIndWorkList;
    CJoinIndWorkList        m_JoinIndWorkList;

    /************************************************************************/
    /* The list of active conferences.                                      */
    /************************************************************************/
    CNCConfList             m_ConfList;
};

extern DCRNCConferenceManager *g_pNCConfMgr;



/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Return codes                                                             */
/****************************************************************************/
#define CM_RC_UNKNOWN_CONFERENCE			1
#define CM_RC_INTERNAL_ERROR				2
#define CM_RC_NOT_SUPPORTED_IN_BACKLEVEL	3

/****************************************************************************/
/* Constants for SetAutoAcceptMode().                                       */
/****************************************************************************/
#define CM_AUTO_JOIN       0
#define CM_DONT_AUTO_JOIN  1

// Get a name in Unicode from either an ANSII numeric name or
// a Unicode text name, and allocate memory for result.

HRESULT GetUnicodeFromGCC(PCSTR	szGCCNumeric, 
						   PCWSTR	wszGCCUnicode,
						   PWSTR *	pwszText);

// Do the reverse of GetUnicodeFromGCC, and reuse the Unicode text name,
// (i.e. do not allocate), and only allocate a ANSI numeric name if needed.

HRESULT GetGCCFromUnicode(PCWSTR   wszText,
                           GCCNumericString *	pGCCNumeric, 
                           LPWSTR			 *	pGCCUnicode);

HRESULT GCCJoinResponseWrapper(GCCResponseTag					join_response_tag,
                                GCCChallengeRequestResponse *	password_challenge,
                                GCCResult						result,
                                GCCConferenceID					conferenceID,
                                UINT						   	nUserData = 0,
                                GCCUserData					**  ppUserData = NULL);

GCCConferenceID GetConfIDFromMessage(GCCMessage *pGCCMessage);

#endif /* __ERNCCM_HPP_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\erncconf.hpp ===
/****************************************************************************/
/*                                                                          */
/* ERNCCONF.HPP                                                             */
/*                                                                          */
/* Base Conference class for the Reference System Node Controller.          */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  12Jul95 NFC             Created.                                        */
/*                                                                          */
/****************************************************************************/

#ifndef __ERNCCONF_HPP_
#define __ERNCCONF_HPP_

extern "C"
{
    #include "T120.h"
}
#include "events.hpp"
#include <cuserdta.hpp>
#include "inodecnt.h"


extern IT120ControlSAP *g_pIT120ControlSap;

class CNodeIdNameList2 : public CList2
{
	DEFINE_CLIST2_(CNodeIdNameList2,  LPSTR,  T120NodeID)
};

class CUserDataList2 : public CList2
{
	DEFINE_CLIST2_(CUserDataList2, CNCUserDataList*, T120NodeID)
};

class DCRNCConference;


/****************************************************************************/
/*                                                                          */
/* Structures                                                               */
/*                                                                          */
/****************************************************************************/

// List of local addresses in the conference
// LONCHANC: This class is insane. We should fix it.
class CLocalAddress : public CRefCount
{
    friend class CLocalAddressList;

public:
    CLocalAddress(PCSTR szLocalAddress);
    ~CLocalAddress(void) { delete m_pszLocalAddress; }
    PCSTR GetLocalAddress(void) { return m_pszLocalAddress; }

private:
    LPSTR     m_pszLocalAddress;
};

class CLocalAddressList : private CList
{
    DEFINE_CLIST(CLocalAddressList, CLocalAddress*)

public:

    ~CLocalAddressList(void) { ASSERT(IsEmpty()); }

    HRESULT AddLocalAddress(ConnectionHandle  connection_handle,
                    BOOL *            pbNewAddress,
                    CLocalAddress **  ppLocalAddr);
    HRESULT GetLocalAddressList(UINT * pnAddresses, LPCSTR** ppaAddresses);
    void EndReference(CLocalAddress *pLocalAddr);
};


/****************************************************************************/
/* Values for connection state field.                                       */
/****************************************************************************/
typedef enum
{
    CONF_CON_PENDING_START,
    CONF_CON_PENDING_INVITE,
    CONF_CON_PENDING_JOIN,
    CONF_CON_CONNECTED,
    CONF_CON_PENDING_PASSWORD,
    CONF_CON_INVITED,
    CONF_CON_JOINED,
    CONF_CON_ERROR,
}
    LOGICAL_CONN_STATE;


/****************************************************************************/
/* An entry in the connection list.                                         */
/****************************************************************************/
class CLogicalConnection : public CRefCount
{
public:

    CLogicalConnection
    (
        PCONFERENCE             pConf,
        LOGICAL_CONN_STATE      eAction,
        ConnectionHandle        hConnection,
        PUSERDATAINFO           pInfo,
        UINT                    nInfo,
        BOOL                    fSecure
    );
    ~CLogicalConnection(void);

    BOOL NewLocalAddress(void);
    void Delete(HRESULT hrReason);
    HRESULT InviteConnectResult(HRESULT hr);
    void InviteComplete(HRESULT hrStatus, PT120PRODUCTVERSION pVersion = NULL);

    void SetState(LOGICAL_CONN_STATE eState) { m_eState = eState; }
    LOGICAL_CONN_STATE GetState(void) { return m_eState; }

    LPSTR GetNodeAddress(void) { return m_pszNodeAddress; }
    void SetNodeAddress(LPSTR psz) { m_pszNodeAddress = psz; }

    UserID GetConnectionNodeID(void) { return m_nidConnection; }
    void SetConnectionNodeID(GCCNodeID nidConn) { m_nidConnection = nidConn; }

    ConnectionHandle GetInviteReqConnHandle(void) { return m_hInviteReqConn; }
    void SetInviteReqConnHandle(ConnectionHandle hConnReq) { m_hInviteReqConn = hConnReq; }

    ConnectionHandle GetConnectionHandle(void) { return m_hConnection; }
    void SetConnectionHandle(ConnectionHandle hConn) { m_hConnection = hConn; }

    CNCUserDataList *GetUserDataList(void) { return &m_UserDataInfoList; }

    void ReArm(void) { m_fEventGrabbed = FALSE; }

    BOOL Grab(void)
    {
        // For this function to work, it relies upon the fact
        // that the thread executing it will not be interrupted
        // and reenter this function on the same thread.
        BOOL fGrabbedByMe = ! m_fEventGrabbed;
        m_fEventGrabbed = TRUE;
        return fGrabbedByMe;
    }

    BOOL IsConnectionSecure(void) { return m_fSecure; };


private:

    LOGICAL_CONN_STATE          m_eState;
    LPSTR                       m_pszNodeAddress;
    PCONFERENCE                 m_pConf;
    ConnectionHandle            m_hInviteReqConn;     // for invite request/indication
    ConnectionHandle            m_hConnection;
    GCCNodeID                   m_nidConnection;
    CLocalAddress              *m_pLocalAddress;
    CNCUserDataList             m_UserDataInfoList;
    BOOL                        m_fSecure;

    BOOL                        m_fEventGrabbed;
}; 


class CNCConfConnList : public CList
{
    DEFINE_CLIST(CNCConfConnList, CLogicalConnection*)
};


/****************************************************************************/
/* States                                                                   */
/****************************************************************************/
typedef enum
{
    CONF_ST_UNINITIALIZED,
    CONF_ST_PENDING_CONNECTION,
    CONF_ST_LOCAL_PENDING_RECREATE,
    CONF_ST_PENDING_T120_START_LOCAL,
// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
    CONF_ST_PENDING_START_REMOTE_FIRST,
    CONF_ST_PENDING_START_REMOTE_SECOND,
#endif
    CONF_ST_STARTED,
}
    NC_CONF_STATE;


typedef enum
{
    T120C_ST_IDLE,
    T120C_ST_PENDING_START_CONFIRM,
    T120C_ST_PENDING_JOIN_CONFIRM,
    T120C_ST_PENDING_ROSTER_ENTRY,
    T120C_ST_PENDING_ROSTER_MESSAGE,
    T120C_ST_PENDING_ANNOUNCE_PERMISSION,
    T120C_ST_CONF_STARTED,
    T120C_ST_PENDING_DISCONNECT,
    T120C_ST_PENDING_TERMINATE,
}
    NC_T120_CONF_STATE;



class DCRNCConference : public IDataConference, public CRefCount
{
    friend class CLogicalConnection;
    friend class CInviteIndWork;

public:

    //
    // IDataConference Interface
    //

    STDMETHODIMP_(void) ReleaseInterface(void);
    STDMETHODIMP_(UINT_PTR) GetConferenceID(void);
    STDMETHODIMP Leave(void);
    STDMETHODIMP EjectUser ( UINT nidEjected );
    STDMETHODIMP Invite ( LPCSTR pcszNodeAddress, USERDATAINFO aInfo[], UINT cInfo, REQUEST_HANDLE *phRequest );
    STDMETHODIMP InviteResponse ( BOOL fResponse );
    STDMETHODIMP JoinResponse ( BOOL fResponse );
    STDMETHODIMP LaunchGuid ( const GUID *pcGUID, UINT auNodeIDs[], UINT cNodes );
    STDMETHODIMP SetUserData ( const GUID *pcGUID, UINT cbData, LPVOID pData );
    STDMETHODIMP_(BOOL) IsSecure(void);
    STDMETHODIMP UpdateUserData(void);
    STDMETHODIMP GetLocalAddressList ( LPWSTR pwszBuffer, UINT cchBuffer );
    STDMETHODIMP CancelInvite ( REQUEST_HANDLE hRequest );
    STDMETHODIMP SetSecurity ( BOOL fSecure );
    STDMETHODIMP GetCred ( PBYTE *ppbCred, DWORD *pcbCred );
    STDMETHODIMP_(UINT) GetParentNodeID(void);

public:

    // Various ways to get a connection entry.
    // Based upon a current pending event (request).
    CLogicalConnection *  GetConEntry(ConnectionHandle hInviteIndConn);
    CLogicalConnection *  GetConEntry(LPSTR pszNodeAddress);
    CLogicalConnection *  GetConEntryByNodeID(GCCNodeID nid);

	ULONG GetNodeName(GCCNodeID  NodeId,  LPSTR  pszBuffer,  ULONG  cbBufSize);
	ULONG GetUserGUIDData(GCCNodeID  NodeId,  GUID  *pGuid,
							LPBYTE  pbBuffer,  ULONG  cbBufSize);

    /************************************************************************/
    /* FUNCTION: DCRNCConference Constructor.                               */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This is the constructor for the conference class.                    */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* conferenceName - name of the conference.                             */
    /* pStatus        - pointer to hold result on return.                   */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /*                                                                      */
    /************************************************************************/
    DCRNCConference(LPCWSTR     pwszConfName,
                    GCCConfID   nConfID,
                    BOOL		fSecure,
                    HRESULT    *pStatus);


    /************************************************************************/
    /* FUNCTION: DCRNCConference Destructor.                                */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This is the destructor for the conference class.                     */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* None.                                                                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* Nothing.                                                             */
    /*                                                                      */
    /************************************************************************/
    ~DCRNCConference(void);
    void OnRemoved(BOOL fReleaseNow = FALSE);
#ifdef _DEBUG
    void OnAppended(void) { m_fAppendedToConfList = TRUE; }
#endif


    /************************************************************************/
    /* FUNCTION: GetID().                                                   */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function returns the ID for this conference.                    */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* none.                                                                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /************************************************************************/
    GCCConferenceID GetID(void) { return m_nConfID; }
    void SetID(GCCConfID nConfID) { m_nConfID = nConfID; }

    void SetActive(BOOL _bActive) { m_fActive = _bActive; }
    BOOL IsActive(void) { return m_fActive; }
    void FirstRoster(void);

    /************************************************************************/
    /* FUNCTION: GetName().                                                 */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function returns the actual name of this conference.  For GCC   */
    /* this is the text part of the conference name.                        */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* none.                                                                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /************************************************************************/
    LPCWSTR GetName(void) { return m_pwszConfName; }
    LPSTR GetNumericName(void) { return m_ConfName.numeric_string; }

    /************************************************************************/
    /* FUNCTION: HandleGCCCallback().                                       */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called by the conference manager when               */
    /* GCC calls back with an event for this conference.                    */
    /* The events handled by this function are:                             */
    /*                                                                      */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pGCCMessage - pointer to the GCC message.                            */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /*   Nothing.                                                           */
    /*                                                                      */
    /************************************************************************/
    void HandleGCCCallback(GCCMessage *pGCCMessage);
    void HandleJoinConfirm(JoinConfirmMessage * pJoinConfirm);

    HRESULT RefreshRoster(void);

    /************************************************************************/
    /* FUNCTION: ValidatePassword()                                         */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is used to verify the password supplied with a			*/
    /*	GCC-Conference-Join indication.                                     */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pPasswordChallenge - Pointer to the GCC structure containing the		*/
    /*						supplied password								*/
    /*                                                                      */
    /* RETURNS:                                                             */
    /*  TRUE, if the join is authorized, FALSE, otherwise.					*/
    /*                                                                      */
    /************************************************************************/	
    BOOL ValidatePassword (GCCChallengeRequestResponse *pPasswordChallenge);

    /************************************************************************/
    /* FUNCTION: Invite()                                                   */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to invite a remote node into the conference. */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pNodeDetails - details of the address of the node to invite into the */
    /*                conference.                                           */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.  CONF_RC_BAD_STATE                                      */
    /*                                                                      */
    /************************************************************************/
    HRESULT InviteResponse ( HRESULT hrResponse );
    void InviteComplete(ConnectionHandle hInviteReqConn,
                        HRESULT result,
                        PT120PRODUCTVERSION pVersion);

    /************************************************************************/
    /* FUNCTION: Leave()                                                    */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to leave the conference.                     */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* None.                                                                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* CONF_RC_BAD_STATE                                                    */
    /*                                                                      */
    /************************************************************************/
    // HRESULT Leave(void);

    /************************************************************************/
    /* FUNCTION: Terminate().                                               */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to terminate the conference.                 */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* None.                                                                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* CONF_RC_BAD_STATE                                                    */
    /*                                                                      */
    /************************************************************************/
    // HRESULT Terminate(void);

    /************************************************************************/
    /* FUNCTION: Eject().                                                   */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to eject an user from the conference.        */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* User ID.                                                             */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* UI_RC_T120_FAILURE                                                   */
    /*                                                                      */
    /************************************************************************/
    HRESULT Eject(GCCNodeID nidEjected);

    /************************************************************************/
    /* FUNCTION: SendText().                                                */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to send text to users in the conference.     */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* User ID -> If user id is 0 it sends the text to all participants.    */
    /* Text Mesage.                                                         */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* UI_RC_T120_FAILURE                                                   */
    /*                                                                      */
    /************************************************************************/
    // HRESULT SendText(LPWSTR pwszTextMsg, GCCNodeID node_id);

    /************************************************************************/
    /* FUNCTION: TimeRemaining().                                           */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to send the time remaining in the conference.*/
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* Time remaining in seconds.                                           */
    /* User ID -> If user id is 0 it sends the text to all participants.    */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* UI_RC_T120_FAILURE                                                   */
    /*                                                                      */
    /************************************************************************/
    // HRESULT TimeRemaining(UINT time_remaining, GCCNodeID nidDestination);

    /************************************************************************/
    /* FUNCTION: Join()                                                     */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to join a conference at a remote node.       */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pNodeDetails - details of the address of the node at which to join   */
    /*                the conference.                                       */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* CONF_RC_BAD_STATE                                                    */
    /*                                                                      */
    /************************************************************************/
    HRESULT Join(LPSTR          pszNodeAddress,
                 PUSERDATAINFO     pInfo,
                 UINT              nInfo,
                 PCWSTR			_wszPassword);

    HRESULT JoinWrapper(CLogicalConnection * pConEntry,
                        PCWSTR				 	_wszPassword);

    /************************************************************************/
    /* FUNCTION: NotifyConferenceComplete()                                 */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called the generic conference when it has           */
    /* finished its attempt to start.                                       */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* result - result of the attempt to connect.                           */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* Nothing.                                                             */
    /*                                                                      */
    /************************************************************************/
    void NotifyConferenceComplete(HRESULT result);

    /************************************************************************/
    /* FUNCTION: NotifyConnectionComplete()                                 */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called by an instance of a PHYSICAL_CONNECTION when */
    /* it has finished its attempt to establish a connection.               */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /*                                                                      */
    /* pConnection - ptr to the connection which has started.               */
    /* result - result of the attempt to connect.                           */
    /*          One of                                                      */
    /*           CONF_CONNECTION_START_PRIMARY                              */
    /*           CONF_CONNECTION_START_ALTERNATE                            */
    /*           CONF_CONNECTION_START_FAIL                                 */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* CONF_RC_BAD_STATE                                                    */
    /*                                                                      */
    /************************************************************************/
    HRESULT NotifyConnectionComplete(CLogicalConnection * pConEntry,
                                     HRESULT               result);

    /************************************************************************/
    /* FUNCTION: NotifyRosterChanged().                                     */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called by the generic conference when its           */
    /* conference roster has been updated.                                  */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pRoster - pointer to the new roster.                                 */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* Nothing.                                                             */
    /*                                                                      */
    /************************************************************************/
    void NotifyRosterChanged(PNC_ROSTER roster);

    /************************************************************************/
    /* FUNCTION: StartLocal()                                               */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to start a local conference.                 */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* _wszPassword: The local conference's password (used to validate		*/
    /*					GCC-Conference-Join indications.					*/
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* CONF_RC_BAD_STATE                                                    */
    /*                                                                      */
    /************************************************************************/
    HRESULT StartLocal(PCWSTR	_wszPassword, PBYTE pbHashedPassword, DWORD cbHashedPassword);

    /************************************************************************/
    /* FUNCTION: StartRemote()                                              */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to start a conference with a remote node.    */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /* pNodeDetails - details of the address of the node with which to      */
    /*                start the conference.                                 */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* CONF_RC_BAD_STATE                                                    */
    /*                                                                      */
    /************************************************************************/
// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
    HRESULT StartRemote(LPSTR pszNodeAddress);
#endif

    /************************************************************************/
    /* FUNCTION: StartIncoming()                                            */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to start an incoming conference.             */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* CONF_RC_BAD_STATE                                                    */
    /*                                                                      */
    /************************************************************************/
    HRESULT StartIncoming(void);

    BOOL GetNotifyToDo(void) { return m_fNotifyToDo; }
    void SetNotifyToDo(BOOL fNotifyToDo) { m_fNotifyToDo = fNotifyToDo; }

    /************************************************************************/
    /* MapPCMtoConfError - map a PCM return code to a Conference return     */
    /* code.                                                                */
    /************************************************************************/
    HRESULT MapPCMtoConfError(HRESULT PCMrc);
    
    CLogicalConnection *NewLogicalConnection
    (
        LOGICAL_CONN_STATE     eAction,
        ConnectionHandle       hConnection,
        PUSERDATAINFO          pInfo = NULL,
        UINT                   nInfo = 0,
        BOOL                   fSecure = FALSE
    )
    {
        CLogicalConnection *pConEntry;
        pConEntry = new CLogicalConnection(this, eAction, hConnection, pInfo, nInfo, fSecure);
        if (NULL != pConEntry)
        {
            m_ConnList.Append(pConEntry);
        }
        return pConEntry;
    }

    /************************************************************************/
    /* StartConnection - add a new connection to our connection list.       */
    /************************************************************************/
    HRESULT StartConnection(LPSTR       pszNodeAddress,
                             LOGICAL_CONN_STATE action,
                             PUSERDATAINFO		pInfo = NULL,
                             UINT	            nInfo = 0,
                             BOOL               fSecure = FALSE,
                             REQUEST_HANDLE *	phRequest = NULL);


// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
    /************************************************************************/
    /* StartFirstConference() - start the first attempt to create a         */
    /* conference.                                                          */
    /************************************************************************/
    void StartFirstConference();

    /************************************************************************/
    /* StartSecondConference() - start the second attempt to create a       */
    /* conference.                                                          */
    /************************************************************************/
    void StartSecondConference(HRESULT FirstConferenceStatus);
#endif // ENABLE_START_REMOTE

    // Local address list wrappers
    HRESULT AddLocalAddress(ConnectionHandle hConn, BOOL *pbNewAddr, CLocalAddress **ppLocalAddrToRet)
    {
        return m_LocalAddressList.AddLocalAddress(hConn, pbNewAddr, ppLocalAddrToRet);
    }
    void EndReference(CLocalAddress *pLocalAddr)
    {
        m_LocalAddressList.EndReference(pLocalAddr);
    }

    // Connection list
    BOOL IsConnListEmpty(void) { return m_ConnList.IsEmpty(); }
    CLogicalConnection *PeekConnListHead(void) { return m_ConnList.PeekHead(); }

    // Invite indication work item
    CInviteIndWork *GetInviteIndWork(void) { return m_pInviteUI; }
    void SetInviteIndWork(CInviteIndWork *p) { m_pInviteUI = p; }

    BOOL FindSocketNumber(GCCNodeID, SOCKET *);
	void UpdateNodeIdNameListAndUserData(PGCCMessage  message);

    UINT InvalidPwdCount(void) { return m_nInvalidPasswords; };
    VOID IncInvalidPwdCount(void) { m_nInvalidPasswords++; };
    VOID ResetInvalidPwdCount(void) { m_nInvalidPasswords = 0; };

private: // Generic Conference

    /************************************************************************/
    /* State of this conference.                                            */
    /************************************************************************/
    NC_CONF_STATE       m_eState;

    /************************************************************************/
    /* ID of this conference.                                               */
    /************************************************************************/
    GCCConferenceID     m_nConfID;

    /************************************************************************/
    /* List of connections in use by this conference.                       */
    /************************************************************************/
    CNCConfConnList     m_ConnList;

    /************************************************************************/
    /* Name of this conference.                                             */
    /************************************************************************/
    LPWSTR              m_pwszConfName;

    /************************************************************************/
    /* Details of the first node we try to connect to.                      */
    /************************************************************************/
    LPSTR               m_pszFirstRemoteNodeAddress;

    /************************************************************************/
    /* Are we incoming or outgoing?                                         */
    /************************************************************************/
    BOOL                m_fIncoming;

    /************************************************************************/
    /*	Conference passwords												*/
    /************************************************************************/
    PBYTE               m_pbHashedPassword;
    DWORD		m_cbHashedPassword;
    LPWSTR              m_pwszPassword;
    LPSTR               m_pszNumericPassword;

    /************************************************************************/
    /*	Security Setting	    											*/
    /************************************************************************/
    BOOL		m_fSecure;

    /************************************************************************/
    /*	Number of invalid passwords attempts                                */  
    /************************************************************************/
    BOOL		m_nInvalidPasswords;

    /************************************************************************/
    /* Remember the invite indication work item if being invited            */
    /************************************************************************/
    CInviteIndWork     *m_pInviteUI;

    /************************************************************************/
    /* List of local addresses                                              */
    /************************************************************************/
    CLocalAddressList   m_LocalAddressList;

    /************************************************************************/
    /* Miscellaneous states                                                 */
    /************************************************************************/
    BOOL                m_fNotifyToDo;
    BOOL                m_fActive;    // Whether a placeholder or counted as a real conference.
#ifdef _DEBUG
    BOOL                m_fAppendedToConfList; // TRUE when this object is in NC Mgr's list
#endif

private: // T120 Conference

    /************************************************************************/
    /* Pointer to base conference                                           */
    /************************************************************************/
    PCONFERENCE pBase;

    /************************************************************************/
    /* State.                                                               */
    /************************************************************************/
    NC_T120_CONF_STATE      m_eT120State;

    /************************************************************************/
    /* Conference name structure to pass to GCC.                            */
    /************************************************************************/
    GCCConferenceName       m_ConfName;

    /************************************************************************/
    /* Nodes ID.                                                            */
    /************************************************************************/
    GCCNodeID               m_nidMyself;

    /************************************************************************/
    /* The user data for the local member in the conference.                */
    /************************************************************************/
    CNCUserDataList         m_LocalUserData;
	CNodeIdNameList2		m_NodeIdNameList;
	CUserDataList2			m_UserDataList;

    PBYTE                   m_pbCred;
    DWORD                   m_cbCred;

public: // T120 Conference

    /****************************************************************************/
    /* AnnouncePresence() - announce this nodes participation in the            */
    /* conference.                                                              */
    /****************************************************************************/
    HRESULT AnnouncePresence(void);

    void SetT120State(NC_T120_CONF_STATE eState) { m_eT120State = eState; }

protected: // T120 Conference

    /************************************************************************/
    /* FUNCTION: T120Invite()                                                   */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to invite a remote node into the conference. */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pNodeDetails - the connection to invite the node over.                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.  UI_RC_T120_FAILURE                                      */
    /*                                                                      */
    /************************************************************************/
    HRESULT T120Invite(LPSTR pszNodeAddress,
                   BOOL fSecure,
                   CNCUserDataList *  pUserDataInfoList,
                   ConnectionHandle * phInviteReqConn);

    /************************************************************************/
    /* FUNCTION: T120Join()                                                 */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to join a conference at a remote node.       */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pNodeDetails - the connection to join the conference over.           */
    /* conferenceName - name of the conference to join.                     */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* UI_RC_T120_FAILURE                                                   */
    /*                                                                      */
    /************************************************************************/
    HRESULT T120Join(LPSTR              pszNodeAddress,
                     BOOL				fSecure,
                     LPCWSTR            conferenceName,
                     CNCUserDataList   *pUserDataInfoList,
                     LPCWSTR            pwszPassword);
//                   REQUEST_HANDLE    *phRequest);

private: // T120 Conference

    // The original constructor of T120 Conference
    HRESULT NewT120Conference(void);

    /************************************************************************/
    /* FUNCTION: StartLocal()                                               */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to start a local conference.                 */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* None.                                                                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* UI_RC_T120_FAILURE                                                    */
    /*                                                                      */
    /************************************************************************/
    HRESULT T120StartLocal(BOOL fSecure);

    /************************************************************************/
    /* FUNCTION: T120StartRemote()                                          */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to start a conference with a remote node.    */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pNodeDetails - connection to establish the conference with.           */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* UI_RC_T120_FAILURE                                                    */
    /*                                                                      */
    /************************************************************************/
// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
    HRESULT T120StartRemote(LPSTR pszNodeAddress);
#endif

    // Handle a GCC_CONNECTION_BROKEN_INDICATION message.
    void HandleConnectionBrokenIndication(ConnectionBrokenIndicationMessage *);

    /************************************************************************/
    /* HandleAddConfirm - handle a GCC_ADD_CONFIRM message                  */
    /************************************************************************/
    void HandleAddConfirm(AddConfirmMessage * pAddConf)
    {
        ERROR_OUT(("HandleAddConfirm: Not supported yet..."));
    }

    /************************************************************************/
    /* HandleAnnounceConfirm - handle a GCC_ANNOUNCE_PRESENCE_CONFIRM       */
    /* message                                                              */
    /************************************************************************/
    void HandleAnnounceConfirm(AnnouncePresenceConfirmMessage * pGCCMessage);

    /************************************************************************/
    /* HandleCreateConfirm - handle a GCC_CREATE_CONFIRM message.           */
    /************************************************************************/
    void HandleCreateConfirm(CreateConfirmMessage * pCreateConfirm);

    /************************************************************************/
    /* HandleDisconnectConfirm - handle a GCC_DISCONNECT_CONFIRM message.   */
    /************************************************************************/
    void HandleDisconnectConfirm(DisconnectConfirmMessage * pDiscConf);

    /************************************************************************/
    /* HandleDisconnectInd - handle a GCC_DISCONNECT_INDICATION message.    */
    /************************************************************************/
    void HandleDisconnectInd(DisconnectIndicationMessage * pDiscInd);

    /************************************************************************/
    /* HandleEjectUser - handle a GCC_EJECT_USER_INDICATION message.        */
    /************************************************************************/
    void HandleEjectUser(EjectUserIndicationMessage * pEjectInd);

    /************************************************************************/
    /* HandleInviteConfirm - handle a GCC_INVITE_CONFIRM message.           */
    /************************************************************************/
    void HandleInviteConfirm(InviteConfirmMessage * pInviteConf);

    /************************************************************************/
    /* HandlePermitToAnnounce - handle a GCC_PERMIT_TO_ANNOUNCE_PRESENCE    */
    /* message.                                                             */
    /************************************************************************/
    void HandlePermitToAnnounce(PermitToAnnouncePresenceMessage * pAnnounce);

    // Handle a GCC_ROSTER_REPORT_INDICATION or a GCC_ROSTER_INQUIRE_CONFIRM.
    void HandleRosterReport(GCCConferenceRoster * pConferenceRoster);

    /************************************************************************/
    /* HandleTerminateConfirm - handle a GCC_TERMINATE_CONFIRM message.     */
    /************************************************************************/
    void HandleTerminateConfirm(TerminateConfirmMessage * pTermConf);

    /************************************************************************/
    /* HandleTerminateInd - handle a GCC_TERMINATE_INDICATION message.      */
    /************************************************************************/
    void HandleTerminateInd(TerminateIndicationMessage * pTermInd);
};

void LoadAnnouncePresenceParameters(
                        GCCNodeType        *   nodeType,
                        GCCNodeProperties  *   nodeProperties,
                        LPWSTR             *   nodeName,
                        LPWSTR             *   siteInformation);

void BuildAddressFromNodeDetails(LPSTR pszNodeAddress, LPSTR pszDstAddress);


#endif /* __ERNCCONF_HPP_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\erncconf.cpp ===
/****************************************************************************/
/*                                                                          */
/* ERNCCONF.CPP                                                             */
/*                                                                          */
/* Base Conference class for the Reference System Node Controller.          */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  12Jul95 NFC             Created.                                        */
/*  05Oct95 NFC SFR 6206    Treat a "Join" as an incoming call.             */
/*  11Oct95 PM              Relax checks on conference termination to       */
/*                          prevent "no win" situations                     */
/*                          Support START_ALTERNATE from TPhys API          */
/*                                                                          */
/****************************************************************************/
#include "precomp.h"
DEBUG_FILEZONE(ZONE_GCC_NC);
#include "ernccons.h"
#include "nccglbl.hpp"
#include "erncvrsn.hpp"
#include <cuserdta.hpp>

#include "connect.h"
#include "erncconf.hpp"
#include "ernctrc.h"
#include "ernccm.hpp"
#include <iappldr.h>
#include "plgxprt.h"
#include "nmremote.h"


extern PController  g_pMCSController;

DCRNCConference::
DCRNCConference
(
    LPCWSTR     pwcszConfName,
    GCCConfID   nConfID,
    BOOL        fSecure,
    HRESULT    *pRetCode
)
:
    CRefCount(MAKE_STAMP_ID('N','C','C','F')),
    m_fNotifyToDo(FALSE),
    m_fActive(TRUE),
#ifdef _DEBUG
    m_fAppendedToConfList(FALSE),
#endif
    m_pInviteUI(NULL),
    m_pszFirstRemoteNodeAddress(NULL),
    m_nConfID(nConfID),
    m_eState(CONF_ST_UNINITIALIZED),
    m_fIncoming(FALSE),
    m_pbHashedPassword(NULL),
    m_cbHashedPassword(0),
    m_pwszPassword(NULL),
    m_pszNumericPassword(NULL),
    // T120 conference
    m_eT120State(T120C_ST_IDLE),
    m_nidMyself(0),
    m_fSecure(fSecure),
    m_nInvalidPasswords(0)
{
    DebugEntry(DCRNCConference::DCRNCConference);

    // Save the conference name.
    DBG_SAVE_FILE_LINE
    m_pwszConfName = ::My_strdupW(pwcszConfName);
    if (! ::IsEmptyStringW(m_pwszConfName))
    {
        *pRetCode = NO_ERROR;
    }
    else
    {
        *pRetCode = (NULL == m_pwszConfName) ? UI_RC_OUT_OF_MEMORY :
                                               UI_RC_NO_CONFERENCE_NAME;
    }

    // T120 conference
    m_ConfName.numeric_string = NULL;
    m_ConfName.text_string = NULL;

    DebugExitVOID(DCRNCConference::DCRNCConference);
}

/****************************************************************************/
/* Destructor - see erncconf.h                                              */
/****************************************************************************/
DCRNCConference::
~DCRNCConference(void)
{
    DebugEntry(DCRNCConference::~DCRNCConference);

    ASSERT(! m_fAppendedToConfList);

    // delete all the name strings
    LPSTR  pszStr;
    while (NULL != (pszStr = m_NodeIdNameList.Get()))
    {
        delete [] pszStr;
    }

    // Delete all the usr data
    CNCUserDataList *pUserDataList;
    while (NULL != (pUserDataList = m_UserDataList.Get()))
    {
        delete pUserDataList;
    }

    delete m_pwszConfName;

    // If there is a password, delete it.
    delete []m_pbHashedPassword;
    delete m_pwszPassword;
    delete m_pszNumericPassword;

    delete m_pszFirstRemoteNodeAddress;

    // T120 conference
    delete m_ConfName.numeric_string;

    DebugExitVOID(DCRNCConference::~DCRNCConference);
}


void DCRNCConference::
OnRemoved(BOOL fReleaseNow)
{
    DebugEntry(DCRNCConference::OnRemoved);

    CLogicalConnection *pConEntry;

#ifdef _DEBUG
    m_fAppendedToConfList = FALSE;
#endif

    // Issue a request to leave the conference.
    // This request may fail, but may as well let leave validate
    // itself, rather than put an extra check in here.
    // See comments in RemoveConference() and Leave() for more details
    // if interested.
    if (T120C_ST_PENDING_DISCONNECT != m_eT120State &&
        T120C_ST_PENDING_TERMINATE != m_eT120State)
    {
        Leave();
    }

    // Take the conference out of the list of pending invites.
    g_pNCConfMgr->RemoveInviteIndWorkItem(m_pInviteUI);

    // End all physical connections in use by this conference,
    // and inform the user of the results of pending events.
    while (NULL != (pConEntry = m_ConnList.Get()))
    {
        pConEntry->Delete(UI_RC_CONFERENCE_GOING_DOWN);
    }

    //
    // LONCHANC: This destructor may be called inside
    // ConfMgr::ReleaseInterface(). As a result, the global pointer
    // to the callback interface may already be nulled out.
    // Check it before use it.
    //

    // ASSERT(2 == GetRefCount());

    // Tell UI its handle to conference is no longer valid.
    if (NULL != g_pCallbackInterface)
    {
        g_pCallbackInterface->OnConferenceEnded((CONF_HANDLE) this);
    }
    else
    {
        ERROR_OUT(("DCRNCConference::OnRemoved: g_pCallbackInterface is null"));
    }

    // ASSERT(1 == GetRefCount());

    if (fReleaseNow)
    {
        ReleaseNow();
    }
    else
    {
        Release();
    }

    DebugExitVOID(DCRNCConference::OnRemoved);
}


//
// IDataConference Interface
//


STDMETHODIMP_(void) DCRNCConference::
ReleaseInterface(void)
{
    DebugEntry(DCRNCConference::ReleaseInterface);
    InterfaceEntry();

    Release();

    DebugExitVOID(DCRNCConference::ReleaseInterface);
}


STDMETHODIMP_(UINT_PTR) DCRNCConference::
GetConferenceID(void)
{
    DebugEntry(DCRNCConference::GetConferenceID);
    InterfaceEntry();

    DebugExitINT(DCRNCConference::GetConferenceID, (UINT) m_nConfID);
    return m_nConfID;
}


STDMETHODIMP DCRNCConference::
Leave(void)
{
    DebugEntry(DCRNCConference::Leave);
    InterfaceEntry();

    GCCError        GCCrc;
    HRESULT         hr;

    switch (m_eT120State)
    {
    // LONCHANC: Added the following two cases for cancellation.
    case T120C_ST_PENDING_START_CONFIRM:
    case T120C_ST_PENDING_JOIN_CONFIRM:

    case T120C_ST_PENDING_ROSTER_ENTRY:
    case T120C_ST_PENDING_ROSTER_MESSAGE:
    case T120C_ST_PENDING_ANNOUNCE_PERMISSION:

        // User has called leave on a conference when it is being brought up.
        // Drop through to issue a disconnect request to T120.

    case T120C_ST_CONF_STARTED:

        // Set the state of the conference to note that we are
        // disconnecting from T120.
        // LONCHANC: this is a must to avoid reentrance of this Leave()
        // when direct InviteConfirm hits Node Controller later.
        m_eT120State = T120C_ST_PENDING_DISCONNECT;

        // User has requested to leave the conference after it has been
        // started as a T120 conference, so ask T120 to end the conference
        // before removing internal data structures.
        GCCrc = g_pIT120ControlSap->ConfDisconnectRequest(m_nConfID);
        hr = ::GetGCCRCDetails(GCCrc);
        TRACE_OUT(("GCC call:  g_pIT120ControlSap->ConfDisconnectRequest, rc=%d", GCCrc));
        if (NO_ERROR == hr)
        {
            break;
        }

        // T120 won't let us leave a conference that we think we are in.
        // Take this to mean that T120 doesn't know about the conference
        // anymore and just destroy our own knowledge of the conference.
        WARNING_OUT(("DCRNCConference::Leave: Failed to leave conference, GCC error %d", GCCrc));

        // Drop through to destroy our references.

    case T120C_ST_IDLE:

        // User has requested to leave a conference that has not been
        // started.
        // This should only happen when told that a conference join
        // request supplied an invalid password and the user gives up
        // on attempting to join the conference (or shuts down conferencing).
        // Just do the same processing as would be done when a T120
        // disconnect confirmation fires.
        g_pNCConfMgr->RemoveConference(this);
        hr = NO_ERROR;
        break;

    case T120C_ST_PENDING_DISCONNECT:
    case T120C_ST_PENDING_TERMINATE:

        // User has requested to leave a conference that is already
        // going down (most likely because of a prior request to leave).
        hr = UI_RC_CONFERENCE_GOING_DOWN;
        WARNING_OUT(("DCRNCConference::Leave: conference already going down, state=%d", m_eT120State));
        break;

    default:

        // User has called leave on a conference when he shouldn't
        // (e.g. when it is being brought up).
        // This is very unlikely to happen as the user doesn't know
        // the conference handle at this point.
        hr = UI_RC_INVALID_REQUEST;
        ERROR_OUT(("DCRNCConference::Leave: invalid state=%d", m_eT120State));
        break;
    }

    DebugExitHRESULT(DCRNCConference::Leave, hr);
    return hr;
}


STDMETHODIMP DCRNCConference::
EjectUser ( UINT nidEjected )
{
    DebugEntry(DCRNCConference::EjectUser);
    InterfaceEntry();

    GCCError GCCrc = g_pIT120ControlSap->ConfEjectUserRequest(m_nConfID, (UserID) nidEjected, GCC_REASON_USER_INITIATED);
    HRESULT hr = ::GetGCCRCDetails(GCCrc);
    if (NO_ERROR != hr)
    {
        ERROR_OUT(("DCRNCConference::EjectUser: Failed to eject user conference, GCC error %d", GCCrc));
    }

    CLogicalConnection *pConEntry = GetConEntryByNodeID((GCCNodeID) nidEjected);
    if (NULL != pConEntry)
    {
        pConEntry->Delete(UI_RC_USER_DISCONNECTED);
    }

    DebugExitHRESULT(DCRNCConference::EjectUser, hr);
    return hr;
}


STDMETHODIMP DCRNCConference::
Invite
(
    LPCSTR              pcszNodeAddress,
    USERDATAINFO        aInfo[],
    UINT                cInfo,
    REQUEST_HANDLE *    phRequest
)
{
    DebugEntry(DCRNCConference::Invite);
    InterfaceEntry();

    HRESULT hr;

#if defined(TEST_PLUGGABLE) && defined(_DEBUG)
    if (g_fWinsockDisabled)
    {
        pcszNodeAddress = ::FakeNodeAddress(pcszNodeAddress);
    }
#endif

    if (NULL != pcszNodeAddress && NULL != phRequest)
    {
        // if winsock is disabled, block any IP address or machine name
        if (g_fWinsockDisabled)
        {
            if (! IsValidPluggableTransportName(pcszNodeAddress))
            {
                return UI_RC_NO_WINSOCK;
            }
        }

        // Check that person is not already in the conference.
        if (GetConEntry((LPSTR) pcszNodeAddress))
        {
            hr = UI_RC_ALREADY_IN_CONFERENCE;
        }
        else
        {
            hr = StartConnection((LPSTR) pcszNodeAddress,
                                 CONF_CON_PENDING_INVITE,
                                 aInfo,
                                 cInfo,
                                 m_fSecure,
                                 phRequest);
        }

        if (NO_ERROR != hr)
        {
            ERROR_OUT(("Error adding connection"));
        }
    }
    else
    {
        hr = (pcszNodeAddress == NULL) ? UI_RC_NO_ADDRESS : UI_RC_BAD_PARAMETER;
        ERROR_OUT(("DCRNCConference::Invite: invalid parameters, hr=0x%x", (UINT) hr));
    }

    // Sit and wait for the connection to complete before continuing.
    DebugExitHRESULT(DCRNCConference::Invite, hr);
    return hr;
}


STDMETHODIMP DCRNCConference::
CancelInvite ( REQUEST_HANDLE hRequest )
{
    DebugEntry(DCRNCConference::CancelInvite);
    InterfaceEntry();

    HRESULT     hr;
    CLogicalConnection *pConEntry = (CLogicalConnection *) hRequest;

    if (NULL != pConEntry)
    {
        ConnectionHandle hConn = pConEntry->GetInviteReqConnHandle();
        ASSERT(NULL != hConn);
        g_pIT120ControlSap->CancelInviteRequest(m_nConfID, hConn);
        hr = NO_ERROR;
    }
    else
    {
        hr = UI_RC_BAD_PARAMETER;
    }

    DebugExitHRESULT(DCRNCConference::CancelInvite, hr);
    return hr;
}


STDMETHODIMP DCRNCConference::
GetCred ( PBYTE *ppbCred, DWORD *pcbCred )
{
    DebugEntry(DCRNCConference::GetCred);
    HRESULT hr = UI_RC_INTERNAL_ERROR;
    if (m_pbCred)
    {
        *ppbCred = m_pbCred;
        *pcbCred = m_cbCred;
        hr = NO_ERROR;
    }
    DebugExitHRESULT(DCRNCConference::GetCred, hr);
    return hr;
}

STDMETHODIMP DCRNCConference::
InviteResponse ( BOOL fResponse )
{
    DebugEntry(DCRNCConference::InviteResponse);
    InterfaceEntry();

    HRESULT hrResponse = fResponse ? NO_ERROR : UI_RC_USER_REJECTED;

    HRESULT hr = InviteResponse(hrResponse);

    DebugExitHRESULT(DCRNCConferenceManager::InviteResponse, hr);
    return hr;
}


HRESULT DCRNCConference::
InviteResponse ( HRESULT hrResponse )
{
    DebugEntry(DCRNCConference::InviteResponse);
    InterfaceEntry();

    GCCResult Result = ::MapRCToGCCResult(hrResponse);
    GCCError GCCrc = g_pIT120ControlSap->ConfInviteResponse(
                            m_nConfID,
                            NULL,
                            m_fSecure,
                            NULL,               //  domain parms
                            0,                  //  number_of_network_addresses
                            NULL,               //  local_network_address_list
                            g_nVersionRecords,    //  number_of_user_data_members
                            g_ppVersionUserData,  //  user_data_list
                            Result);
    if ((GCCrc == GCC_RESULT_SUCCESSFUL) && (Result == GCC_RESULT_SUCCESSFUL))
    {
        // Have successfully posted an invite response acceptance.
        // Note that the conference is expecting permission to
        // announce its presence.
        m_eT120State = T120C_ST_PENDING_ANNOUNCE_PERMISSION;
    }
    else
    {
        // Have rejected/failed a request to be invited into a conference.
        // Remove the references that were created to track the potential
        // new conference.
        g_pNCConfMgr->RemoveConference(this);
    }

    HRESULT hr = ::GetGCCRCDetails(GCCrc);

    DebugExitHRESULT(DCRNCConferenceManager::InviteResponse, hr);
    return hr;
}


STDMETHODIMP DCRNCConference::
JoinResponse ( BOOL fResponse )
{
    DebugEntry(DCRNCConference::JoinResponse);
    InterfaceEntry();

    HRESULT         hr;

    CJoinIndWork *pJoinUI = g_pNCConfMgr->PeekFirstJoinIndWorkItem();
    if (NULL != pJoinUI)
    {
        if (pJoinUI->GetConference() == this)
        {
            if (fResponse && pJoinUI->GetConEntry()->NewLocalAddress())
            {
                AnnouncePresence();
            }
            hr = pJoinUI->Respond(fResponse ? GCC_RESULT_SUCCESSFUL : GCC_RESULT_USER_REJECTED);
            // Done responding to event, so can now remove from list and process
            // another pending event.
            // Note: since the handling of the previous event is still
            // potentially on the stack, this can cause the stack to grow,
            // but this should not be a problem for Win32.
            g_pNCConfMgr->RemoveJoinIndWorkItem(pJoinUI);
        }
        else
        {
            hr = UI_RC_BAD_PARAMETER;
        }
    }
    else
    {
        ERROR_OUT(("DCRNCConference::JoinResponse: Empty m_JoinIndWorkList, fResponse=%u", fResponse));
        hr = UI_RC_INTERNAL_ERROR;
    }

    DebugExitHRESULT(DCRNCConference::JoinResponse, hr);
    return hr;
}


STDMETHODIMP DCRNCConference::
LaunchGuid
(
    const GUID         *pcGUID,
    UINT                auNodeIDs[],
    UINT                cNodes
)
{
    DebugEntry(DCRNCConference::LaunchGuid);
    InterfaceEntry();

    HRESULT hr;

    if (NULL != pcGUID)
    {
        //
        // We probably should support conference-wide app invoke by
        // cNodes==0 and auNodeIDs==NULL.
        // Implement it later...
        //
        if ((0 != cNodes) || (NULL != auNodeIDs))
        {
            // UserID is a short. We have to translate these UserID to a new array.
            // Try not to allocate memory for small array.
            UserID *pNodeIDs;
            const UINT c_cRemote = 16;
            UserID auidRemote[c_cRemote];
            if (cNodes <= c_cRemote)
            {
                pNodeIDs = auidRemote;
            }
            else
            {
                pNodeIDs = new UserID[cNodes];
                if (NULL == pNodeIDs)
                {
                    hr = UI_RC_OUT_OF_MEMORY;
                    goto MyExit;
                }
            }

            // Copy all the node IDs.
            for (UINT i = 0; i < cNodes; i++)
            {
                pNodeIDs[i] = (UserID)auNodeIDs[i];
            }

            // Construct the key
            GCCError GCCrc;
            GCCObjectKey * pAppKey;
            GCCAppProtocolEntity   AppEntity;
            GCCAppProtocolEntity * pAppEntity;

            BYTE h221Key[CB_H221_GUIDKEY];
            ::CreateH221AppKeyFromGuid(h221Key, (GUID *) pcGUID);

            ::ZeroMemory(&AppEntity, sizeof(AppEntity));
            pAppKey = &AppEntity.session_key.application_protocol_key;
            pAppKey->key_type = GCC_H221_NONSTANDARD_KEY;
            pAppKey->h221_non_standard_id.length = sizeof(h221Key);
            pAppKey->h221_non_standard_id.value = h221Key;

            // AppEntity.session_key.session_id = 0;           // default session
            // AppEntity.number_of_expected_capabilities = 0;  // no capabilities
            // AppEntity.expected_capabilities_list = NULL;
            AppEntity.startup_channel_type = MCS_NO_CHANNEL_TYPE_SPECIFIED;
            AppEntity.must_be_invoked = TRUE;

            pAppEntity = &AppEntity;

            GCCrc = g_pIT120ControlSap->AppletInvokeRequest(m_nConfID, 1, &pAppEntity, cNodes, pNodeIDs);

            hr = ::GetGCCRCDetails(GCCrc);
            if (NO_ERROR != hr)
            {
                ERROR_OUT(("DCRNCConference::LaunchGuid: AppletInvokeRequest failed, GCCrc=%u", GCCrc));
            }

            if (pNodeIDs != auidRemote)
            {
                delete [] pNodeIDs;
            }
        }
        else
        {
            hr = UI_RC_BAD_PARAMETER;
            ERROR_OUT(("DCRNCConference::LaunchGuid: invalid combination, cNodes=%u. auNodeIDs=0x%p", cNodes, auNodeIDs));
        }
    }
    else
    {
        hr = UI_RC_BAD_PARAMETER;
        ERROR_OUT(("DCRNCConference::LaunchGuid: null pcGUID"));
    }

MyExit:

    DebugExitHRESULT(DCRNCConference::LaunchGuid, hr);
    return hr;
}


STDMETHODIMP DCRNCConference::
SetUserData
(
    const GUID         *pcGUID,
    UINT                cbData,
    LPVOID              pData
)
{
    DebugEntry(DCRNCConference::SetUserData);
    InterfaceEntry();

    HRESULT hr;

    if (0 != cbData || NULL != pData)
    {
        hr = m_LocalUserData.AddUserData((GUID *) pcGUID, cbData, pData);
    }
    else
    {
        hr = UI_RC_BAD_PARAMETER;
        ERROR_OUT(("DCRNCConference::SetUserData: invalid combination, cbData=%u. pData=0x%p", cbData, pData));
    }

    DebugExitHRESULT(DCRNCConference::SetUserData, hr);
    return hr;
}

STDMETHODIMP_(BOOL) DCRNCConference::
IsSecure ()
{
    return m_fSecure;
}

STDMETHODIMP DCRNCConference::
SetSecurity ( BOOL fSecure )
{
    m_fSecure = fSecure;
    return S_OK;
}

STDMETHODIMP DCRNCConference::
UpdateUserData(void)
{
    DebugEntry(DCRNCConference::UpdateUserData);
    InterfaceEntry();

    HRESULT hr = AnnouncePresence();

    DebugExitHRESULT(DCRNCConference::UpdateUserData, hr);
    return hr;
}


STDMETHODIMP DCRNCConference::
GetLocalAddressList
(
    LPWSTR              pwszBuffer,
    UINT                cchBuffer
)
{
    DebugEntry(DCRNCConference::GetLocalAddressList);
    InterfaceEntry();

    HRESULT     hr;
    UINT        cAddrs;
    LPCSTR     *pAddresses = NULL;

    ASSERT(cchBuffer > 1); // buffer should have enough room for a double NULL terminator

    hr = m_LocalAddressList.GetLocalAddressList(&cAddrs, &pAddresses);
    if (NO_ERROR == hr)
    {
        LPWSTR pwszPos = pwszBuffer;
        for (UINT i = 0; i < cAddrs; i++)
        {
            ASSERT(pAddresses[i]);
            LPWSTR pwszAddress = ::AnsiToUnicode(pAddresses[i]);
            UINT cchAddress = ::My_strlenW(pwszAddress);
            if ((cchBuffer - (pwszPos - pwszBuffer)) <
                    (RNC_GCC_TRANSPORT_AND_SEPARATOR_LENGTH + cchAddress + 2))
            {
                // NOTE: +2 insures room for the two '\0' chars
                // If there isn't room, break out here:
                delete [] pwszAddress;
                break;
            }
            LStrCpyW(pwszPos, RNC_GCC_TRANSPORT_AND_SEPARATOR_UNICODE);
            pwszPos += RNC_GCC_TRANSPORT_AND_SEPARATOR_LENGTH;
            LStrCpyW(pwszPos, pwszAddress);
            pwszPos += cchAddress;
            *pwszPos = L'\0';
            pwszPos++;
            delete [] pwszAddress;
        }
        if ((UINT)(pwszPos - pwszBuffer) < cchBuffer)
        {
            *pwszPos = L'\0';
        }
        if (0 == cAddrs)
        {
            // No addresses in the string, so insure that the string returned is L"\0\0"
            pwszPos[1] = L'\0';
        }
        delete [] pAddresses;
    }
    else
    {
        ERROR_OUT(("DCRNCConference::GetLocalAddressList: GetLocalAddressList failed, hr=0x%x", (UINT) hr));
    }

    DebugExitHRESULT(DCRNCConference::GetLocalAddressList, hr);
    return hr;
}


STDMETHODIMP_(UINT) DCRNCConference::
GetParentNodeID(void)
{
    DebugEntry(DCRNCConference::GetConferenceID);
    InterfaceEntry();

    GCCNodeID nidParent = 0;
    g_pIT120ControlSap->GetParentNodeID(m_nConfID, &nidParent);

    DebugExitINT(DCRNCConference::GetConferenceID, (UINT) nidParent);
    return (UINT) nidParent;
}






CLogicalConnection *  DCRNCConference::
GetConEntry ( ConnectionHandle hInviteIndConn )
{
    CLogicalConnection *pConEntry = NULL;
    m_ConnList.Reset();
    while (NULL != (pConEntry = m_ConnList.Iterate()))
    {
        if (pConEntry->GetInviteReqConnHandle() == hInviteIndConn)
        {
            break;
        }
    }
    return pConEntry;
}


CLogicalConnection *  DCRNCConference::
GetConEntry ( LPSTR pszNodeAddress )
{
    CLogicalConnection *pConEntry = NULL;
    m_ConnList.Reset();
    while (NULL != (pConEntry = m_ConnList.Iterate()))
    {
        if (0 == ::lstrcmpA(pConEntry->GetNodeAddress(), pszNodeAddress))
        {
            break;
        }
    }
    return pConEntry;
}


CLogicalConnection *  DCRNCConference::
GetConEntryByNodeID ( GCCNodeID nid )
{
    CLogicalConnection *pConEntry = NULL;
    m_ConnList.Reset();
    while (NULL != (pConEntry = m_ConnList.Iterate()))
    {
        if (nid == pConEntry->GetConnectionNodeID())
        {
            break;
        }
    }
    return pConEntry;
}



void DCRNCConference::
FirstRoster(void)
{
    DebugEntry(DCRNCConference::FirstRoster);

    // Great! We are now in a conference and outside of any
    // T120 callback, so that calling back into T120 will not
    // deadlock applications.
    // Let the applications know about the conference,
    // and then ask for a roster update.
    if (m_eT120State == T120C_ST_PENDING_ROSTER_MESSAGE)
    {
        m_eT120State = T120C_ST_CONF_STARTED;
        NotifyConferenceComplete(NO_ERROR);
        RefreshRoster();
    }

    DebugExitVOID(DCRNCConference::FirstRoster);
}


/****************************************************************************/
/* HandleGCCCallback() - see erncconf.h                                     */
/****************************************************************************/
// LONCHANC: Merged to T120 Conference.


/****************************************************************************/
/* ValidatePassword() - Validates a join request by checking the supplied    */
/*            password with the one set when the conference was setup.        */
/****************************************************************************/
BOOL DCRNCConference::
ValidatePassword ( GCCChallengeRequestResponse *pPasswordChallenge )
{
    PBYTE pbPasswordChallenge = NULL;
    DWORD cbPasswordChallenge = 0;
    CHash hashObj;
    OSVERSIONINFO           osvi;
    BOOL bSuccess = FALSE;
    HANDLE hToken = 0;

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (FALSE == ::GetVersionEx (&osvi))
    {
        ERROR_OUT(("GetVersionEx() failed!"));
    }

    if (!(VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && g_bRDS) &&
        (NULL == m_pbHashedPassword) && (NULL == m_pszNumericPassword) && (NULL == m_pwszPassword))
    {
        bSuccess = TRUE;
        goto Cleanup;
    }
    if ((pPasswordChallenge == NULL) ||
        (pPasswordChallenge->password_challenge_type != GCC_PASSWORD_IN_THE_CLEAR))
    {
        bSuccess = FALSE;
        goto Cleanup;
    }

    //
    // We are going to verify the password as a logon
    //

    if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && g_bRDS)
    {
        BYTE InfoBuffer[1024];
        PTOKEN_GROUPS ptgGroups = (PTOKEN_GROUPS)InfoBuffer;
        DWORD dwInfoBufferSize;
        PSID psidAdministrators;
        SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;

        CHAR lpszBuf[1024];

        ASSERT(NULL != pPasswordChallenge->u.password_in_the_clear.text_string);

        WideCharToMultiByte( CP_ACP, 0,
            pPasswordChallenge->u.password_in_the_clear.text_string,
            -1,lpszBuf,256,NULL,NULL);

        CHAR* lp = (CHAR *)_StrChr(lpszBuf, ':');

        if (NULL == lp)
        {
            ERROR_OUT(("Expected separator in logon pwd"));
            bSuccess = FALSE;
            goto Cleanup;
        }

        *lp++ = '\0';

        CHAR* lpPw = (CHAR *)_StrChr(lp, ':');

        if (NULL == lpPw)
        {
            ERROR_OUT(("Expected 2nd separator in logon pwd"));
            bSuccess = FALSE;
            goto Cleanup;
        }

        *lpPw++ = '\0';

        if (0 == strlen(lpPw))
        {
            WARNING_OUT(("Short password in logon pwd"));
            bSuccess = FALSE;
            goto Cleanup;
        }

        bSuccess = LogonUser(lpszBuf, lp, lpPw, LOGON32_LOGON_NETWORK,
                            LOGON32_PROVIDER_DEFAULT, &hToken);

        if (!bSuccess)
        {
            WARNING_OUT(("LogonUser failed %d", GetLastError()));
            goto Cleanup;
        }

        if( !AllocateAndInitializeSid(&siaNtAuthority, 2,
            SECURITY_BUILTIN_DOMAIN_RID,DOMAIN_ALIAS_RID_ADMINS,
            0,0,0,0,0,0, &psidAdministrators ))
        {
            ERROR_OUT(("Error getting admin group sid: %d", GetLastError()));
            bSuccess = FALSE;
            goto Cleanup;
        }

        // assume that we don't find the admin SID.
        bSuccess = FALSE;

        if (!CheckTokenMembership(hToken, psidAdministrators, &bSuccess))
        {
            ERROR_OUT(("Error checking token membership: %d", GetLastError()));
            bSuccess = FALSE;
        }
        FreeSid(psidAdministrators);

        //
        // If this worked there is no need to go on
        //

        if ( bSuccess )
        {
            bSuccess = TRUE;
            goto Cleanup;
        }

        //
        // Check for group membership in the RDS users group on
        // the local machine.
        //

    ASSERT(FALSE == bSuccess);

        DWORD cbSid = 0;
        DWORD cbDomain = 0;
        SID_NAME_USE SidNameUse = SidTypeGroup;

        if ( LookupAccountName ( NULL, SZRDSGROUP, NULL, &cbSid,
                                NULL, &cbDomain, &SidNameUse )
            || ERROR_INSUFFICIENT_BUFFER == GetLastError() )
        {
            PSID pSid = new BYTE[cbSid];
            LPTSTR lpszDomain = new TCHAR[cbDomain];

            if ( pSid && lpszDomain )
            {
                if ( LookupAccountName ( NULL, SZRDSGROUP, pSid,
                                &cbSid, lpszDomain, &cbDomain, &SidNameUse ))
                {
                    //
                    // Make sure what we found is a group
                    //

                    if ( SidTypeGroup == SidNameUse ||
                        SidTypeAlias == SidNameUse )
                    {
                        if (!CheckTokenMembership(hToken, pSid, &bSuccess))
                        {
                             ERROR_OUT(("Error checking token membership: %d", GetLastError()));
                             bSuccess = FALSE;
                        }
                    }
                    else
                    {
                        WARNING_OUT(("SZRDSGROUP was not a group or alias? its a %d",
                            SidNameUse ));
                    }
                }
                else
                {
                    ERROR_OUT(("LookupAccountName (2) failed: %d",
                                            GetLastError()));
                }
            }
            else
            {
                ERROR_OUT(("Alloc of sid or domain failed"));
            }

            delete [] pSid;
            delete [] lpszDomain;
        }
        else
        {
            WARNING_OUT(("LookupAccountName (1) failed: %d", GetLastError()));
        }

        return bSuccess;
    }

    //
    // We are going to hash the password and compare it to the
    // stored hash
    //

    if (m_pbHashedPassword != NULL)
    {
        if (NULL != pPasswordChallenge->u.password_in_the_clear.text_string)
        {
            cbPasswordChallenge = hashObj.GetHashedData((LPBYTE)pPasswordChallenge->u.password_in_the_clear.text_string,
                                                        sizeof(WCHAR)*lstrlenW(pPasswordChallenge->u.password_in_the_clear.text_string),
                                                        (void **) &pbPasswordChallenge);
        }
        else if (NULL != pPasswordChallenge->u.password_in_the_clear.numeric_string)
        {
            int cch = lstrlenA((PSTR)pPasswordChallenge->u.password_in_the_clear.numeric_string);
            LPWSTR lpwszNumPassword = new WCHAR[cch+1];
            MultiByteToWideChar(CP_ACP, 0, (PSTR)pPasswordChallenge->u.password_in_the_clear.numeric_string,
                                -1, lpwszNumPassword, cch+1);
            int cwch = lstrlenW(lpwszNumPassword);
            cbPasswordChallenge = hashObj.GetHashedData((LPBYTE)lpwszNumPassword, sizeof(WCHAR)*lstrlenW(lpwszNumPassword), (void **) &pbPasswordChallenge);
            delete []lpwszNumPassword;
        }
        else
        {
            bSuccess = FALSE;
            goto Cleanup;
        }

        if (m_cbHashedPassword != cbPasswordChallenge)
        {
            bSuccess = FALSE;
            goto Cleanup;
        }

        if (0 == memcmp(m_pbHashedPassword, pbPasswordChallenge, cbPasswordChallenge))
        {
            bSuccess = TRUE;
            goto Cleanup;
        }
        else
        {
            bSuccess = FALSE;
            goto Cleanup;
        }
    }
    else if (m_pwszPassword != NULL)
    {
        // We have a text password
        if ((pPasswordChallenge->u.password_in_the_clear.text_string == NULL) ||
            (0 != ::My_strcmpW(m_pwszPassword,
                    pPasswordChallenge->u.password_in_the_clear.text_string)))
        {
            bSuccess = FALSE;
            goto Cleanup;
        }
        else
        {
            bSuccess = TRUE;
            goto Cleanup;
        }
    }
    else
    {
        // We have a numeric password
        if ((pPasswordChallenge->u.password_in_the_clear.numeric_string == NULL) ||
            (::lstrcmpA(m_pszNumericPassword,
                      (PSTR) pPasswordChallenge->u.password_in_the_clear.numeric_string)))
        {
            bSuccess = FALSE;
            goto Cleanup;
        }
        else
        {
            bSuccess = TRUE;
            goto Cleanup;
        }
    }

Cleanup:

    if(hToken)
    {
        CloseHandle(hToken);
    }
    return bSuccess;
    
}


/****************************************************************************/
/* Join() - see erncconf.h                                                  */
/****************************************************************************/
HRESULT DCRNCConference::
Join
(
    LPSTR               pszNodeAddress,
    PUSERDATAINFO       pInfo,
    UINT                nInfo,
    LPCWSTR             _wszPassword
)
{
    HRESULT hr = NO_ERROR;

    DebugEntry(DCRNCConference::Join);

    /*
     *    Set the password that will be used by the JoinWrapper() method.
     *    The password will be deleted after the Join is complete.
     *    The m_pwszPassword member is only set for the top providers
     *    protecting conferences.
     */
    if (! ::IsEmptyStringW (_wszPassword))
    {
        // Store the password; we will need it later
        m_pwszPassword = ::My_strdupW(_wszPassword);
        if (NULL == m_pwszPassword)
        {
            hr = UI_RC_OUT_OF_MEMORY;
        }
    }

    /************************************************************************/
    /* SFR 6206.  The apps treat joining a conference at a remote site as   */
    /* an "incoming" call.  (i.e they discard any local data and accept the */
    /* msgs/WB contents from the conference we are joining).                */
    /************************************************************************/
    if (NO_ERROR == hr)
    {
        m_fIncoming = TRUE;
        hr = StartConnection(pszNodeAddress,
                             CONF_CON_PENDING_JOIN,
                             pInfo,
                             nInfo,
                             m_fSecure);
    }

    if (NO_ERROR != hr)
    {
        ERROR_OUT(("Error starting connection"));
    }

    /************************************************************************/
    /* We now sit and wait for the connection to complete before            */
    /* continuing.                                                          */
    /************************************************************************/
    DebugExitHRESULT(DCRNCConference::Join, hr);
    return hr;
}


/****************************************************************************/
/* NotifyConferenceComplete() - the generic conference has finished its     */
/* attempt to start.                                                        */
/****************************************************************************/
void DCRNCConference::
NotifyConferenceComplete ( HRESULT hr )
{
    DebugEntry(DCRNCConference::NotifyConferenceComplete);

    /************************************************************************/
    /* If the attempt fails, action depends on whether this is the first or */
    /* second attempt.                                                       */
    /************************************************************************/
    if (NO_ERROR != hr)
    {
        TRACE_OUT(("Attempt to start failed"));
// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
        if (m_eState == CONF_ST_PENDING_START_REMOTE_FIRST)
        {
            TRACE_OUT(("Try second conference type"));
            StartSecondConference(hr);
            return;
        }
#endif // ENABLE_START_REMOTE
    }
    else
    {
        TRACE_OUT(("Conference started OK."));
        m_eState = CONF_ST_STARTED;
    }
    g_pNCConfMgr->NotifyConferenceComplete(this, m_fIncoming, hr);

    DebugExitVOID(DCRNCConference::NotifyConferenceComplete);
}


/****************************************************************************/
/* NotifyConnectionComplete() - see erncconf.h                              */
/****************************************************************************/
HRESULT DCRNCConference::
NotifyConnectionComplete
(
    CLogicalConnection          *pConEntry,
    HRESULT                     hr
)
{
    DebugEntry(DCRNCConference::NotifyConnectionComplete);

    // This function is the state machine
    // for bringing up a conferencing protocol.
    // It manages getting the physical connection and trying
    // T120 and R1.1.

    // A connection has started.
    // Subsequent action depends on the pending state for the connection.

    // First filter out internal (success) return codes.
    if (NO_ERROR != hr)
    {
        // Failed to get a physical connection.
        WARNING_OUT(("Failed to start connection"));
        if (pConEntry->GetState() != CONF_CON_PENDING_INVITE)
        {

            // Put the connection in a failed state before notifying the user.
            // This is because notifying the user can cause GCC events to fire,
            // and, in particular, a JoinRequest failure which must be ignored.

            pConEntry->SetState(CONF_CON_ERROR);

            g_pNCConfMgr->NotifyConferenceComplete(this, m_fIncoming, hr);
            goto MyExit;
        }
        // Drop through for invite failures.
    }

    switch (pConEntry->GetState())
    {
// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
        case CONF_CON_PENDING_START:
            /****************************************************************/
            /* Check we are in the correct state.                           */
            /****************************************************************/
            if ( (m_eState != CONF_ST_PENDING_CONNECTION) &&
                 (m_eState != CONF_ST_LOCAL_PENDING_RECREATE))
            {
                ERROR_OUT(("Bad state to start in..."));
                goto MyExit;
            }

            pConEntry->SetState(CONF_CON_CONNECTED);

            /****************************************************************/
            /* The connection has started OK.  we now try to establish      */
            /* either a T120 or a backlevel conference, depending on the    */
            /* starting order.                                              */
            /****************************************************************/
            if (NO_ERROR == hr)
            {
                hr = StartFirstConference();
            }
            else
            {
                ERROR_OUT(("Invalid response in notify connection complete"));
            }
            break;
#endif // ENABLE_START_REMOTE

        case CONF_CON_PENDING_JOIN:
            // pConEntry->m_eState = CONF_CON_CONNECTED;

            // Joining a new conference.
            // Create a new generic conference and
            // call its Join() entry point.
            hr = NewT120Conference();
            if (NO_ERROR == hr)
            {

                hr = JoinWrapper(pConEntry, m_pwszPassword);
                // Delete the set password
                if (m_pwszPassword != NULL)
                {
                    delete m_pwszPassword;
                    m_pwszPassword = NULL;
                }
            }
            else
            {
                ERROR_OUT(("Error %d joining conference", hr));
                goto MyExit;
            }
            break;

        case CONF_CON_PENDING_INVITE:
            hr = pConEntry->InviteConnectResult(hr);
            break;

        default :
            ERROR_OUT(("Unknown action %d", pConEntry->GetState()));
            break;
    }

MyExit:
    DebugExitVOID(DCRNCConference::NotifyConnectionComplete);
    return hr;
}


HRESULT DCRNCConference::
JoinWrapper
(
    CLogicalConnection     *pConEntry,
    LPCWSTR                 _wszPassword
)
{
    DebugEntry(DCRNCConference::JoinWrapper);

    // Going asynchronous, so allow events to fire.
    pConEntry->ReArm();

    HRESULT hr = T120Join(pConEntry->GetNodeAddress(),
                          pConEntry->IsConnectionSecure(),
                          m_pwszConfName,
                          pConEntry->GetUserDataList(),
                          _wszPassword);
    if (NO_ERROR == hr)
    {
        m_eState = CONF_ST_STARTED;
    }
    else
    {
        pConEntry->Grab();
        ERROR_OUT(("Error %d joining conference", hr));
        g_pNCConfMgr->NotifyConferenceComplete(this, m_fIncoming, hr);
    }

    DebugExitHRESULT(DCRNCConference::JoinWrapper, hr);
    return hr;
}

/****************************************************************************/
/* NotifyRosterChanged() - see erncconf.hpp.                                */
/****************************************************************************/
void DCRNCConference::
NotifyRosterChanged ( PNC_ROSTER pRoster )
{
    DebugEntry(DCRNCConference::NotifyRosterChanged);

    // Add the conference name and ID to the roster.
    pRoster->pwszConferenceName = m_pwszConfName;
    pRoster->uConferenceID = m_nConfID;

    /************************************************************************/
    /* Pass the new roster up to the CM                                     */
    /************************************************************************/
    g_pCallbackInterface->OnRosterChanged((CONF_HANDLE) this, pRoster);

    DebugExitVOID(DCRNCConference::NotifyRosterChanged);
}


/****************************************************************************/
/* StartConnection - add a new connection to our connection list.           */
/****************************************************************************/
HRESULT DCRNCConference::
StartConnection
(
    LPSTR                   pszNodeAddress,
    LOGICAL_CONN_STATE      eAction,
    PUSERDATAINFO           pInfo,
    UINT                    nInfo,
    BOOL                    fSecure,
    REQUEST_HANDLE *        phRequest
)
{
    HRESULT             hr = NO_ERROR;
    CLogicalConnection *pConEntry = NULL;

    DebugEntry(DCRNCConference::StartConnection);

    DBG_SAVE_FILE_LINE
    pConEntry = NewLogicalConnection(eAction, NULL, pInfo, nInfo, fSecure);
    if (NULL != pConEntry)
    {
        // Set node address
        pConEntry->SetNodeAddress(::My_strdupA(pszNodeAddress));

        //
        // LONCHANC: Fire the conn-entry event.
        //
        hr = NotifyConnectionComplete(pConEntry, NO_ERROR);

        if( NO_ERROR != hr )
        {
            pConEntry->Delete( hr );
            pConEntry = NULL;
        }
    }
    else
    {
        hr = UI_RC_OUT_OF_MEMORY;
    }

    if (phRequest)
    {
        // Return context as the connection entry, if required.
        *phRequest = (REQUEST_HANDLE *)pConEntry;
    }

    DebugExitHRESULT(DCRNCConference::StartConnection, hr);
    return hr;
}


// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
/****************************************************************************/
/* StartFirstConference() - start the first attempt to create a conference. */
/****************************************************************************/
void DCRNCConference::
StartFirstConference(void)
{
    BOOL        result = FALSE;
    HRESULT     hr;

    DebugEntry(DCRNCConference::StartFirstConference);

    hr = NewT120Conference();
    if (NO_ERROR != hr)
    {
        ERROR_OUT(("Failed to create new conference"));
        m_eState = CONF_ST_UNINITIALIZED;
        goto MyExit;
    }

    /************************************************************************/
    /* Call the StartRemote() entry point.                                  */
    /************************************************************************/
    hr = T120StartRemote(m_pszFirstRemoteNodeAddress);
    if (hr)
    {
        WARNING_OUT(("Failed to start remote, rc %d", hr));
        goto MyExit;
    }
    m_eState = CONF_ST_PENDING_START_REMOTE_FIRST;
    result = TRUE;

MyExit:

    /************************************************************************/
    /* If we failed to start the first conference, try to start the second  */
    /* type of conference in the starting order.                            */
    /************************************************************************/
    if (!result)
    {
        TRACE_OUT(("Failed to start first conference."));
        StartSecondConference(hr);
    }

    DebugExitVOID(DCRNCConference::StartFirstConference);
}
#endif // ENABLE_START_REMOTE


// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
/****************************************************************************/
/* StartSecondConference() - start the second attempt to create a           */
/* conference.                                                              */
/****************************************************************************/
void DCRNCConference::
StartSecondConference ( HRESULT FirstConferenceStatus )
{
    BOOL        result = FALSE;
    HRESULT     hr = NO_ERROR;

    DebugEntry(DCRNCConference::StartSecondConference);

    hr = FirstConferenceStatus;
#if 0 // LONCHANC: very weird code
    goto MyExit;

    /************************************************************************/
    /* Call the StartRemote() entry point.                                  */
    /************************************************************************/
    hr = T120StartRemote(m_pszFirstRemoteNodeAddress);
    if (NO_ERROR != hr)
    {
        WARNING_OUT(("Failed to start remote, rc %d", hr));
        goto MyExit;
    }
    m_eState = CONF_ST_PENDING_START_REMOTE_SECOND;
    result = TRUE;

MyExit:
#endif // 0

    /************************************************************************/
    /* If we have failed to start any type of conference, tell CM about it. */
    /************************************************************************/
    if (!result)
    {
        TRACE_OUT(("Failed to start Second conference."));
        g_pNCConfMgr->NotifyConferenceComplete(this, m_fIncoming, hr);
    }

    DebugExitVOID(DCRNCConference::StartSecondConference);
}
#endif // ENABLE_START_REMOTE


/****************************************************************************/
/* StartLocal() - see erncconf.h                                            */
/****************************************************************************/
HRESULT DCRNCConference::
StartLocal ( LPCWSTR _wszPassword, PBYTE pbHashedPassword, DWORD cbHashedPassword)
{
    HRESULT hr = NO_ERROR;

    DebugEntry(DCRNCConference::StartLocal);

    /*
     *    Set the password that will be used to protect the conference.
     *    against unauthorized Join requests.
     *    The password is only set for the top providers
     *    protecting conferences.
     *    If the password is a number it will be stored in m_pszNumericPassword.
     *    Otherwise, it will be stored in m_pwszPassword.
     */
    if (NULL != pbHashedPassword)
    {
        m_pbHashedPassword = new BYTE[cbHashedPassword];
        if (NULL == m_pbHashedPassword)
        {
            hr = UI_RC_OUT_OF_MEMORY;
        }
        else
        {
            memcpy(m_pbHashedPassword, pbHashedPassword, cbHashedPassword);
        m_cbHashedPassword = cbHashedPassword;
        }
    }
    else if (! ::IsEmptyStringW(_wszPassword))
    {
        if (::UnicodeIsNumber(_wszPassword))
        {
            m_pszNumericPassword = ::UnicodeToAnsi(_wszPassword);
            if (m_pszNumericPassword == NULL)
            {
                hr = UI_RC_OUT_OF_MEMORY;
            }
        }
        else
        {
            m_pwszPassword = ::My_strdupW(_wszPassword);
            if (NULL == m_pwszPassword)
            {
                hr = UI_RC_OUT_OF_MEMORY;
            }
        }
    }

    /************************************************************************/
    /* Dont need to bother getting a physical connection.  Just create a    */
    /* new T120 conference and call its StartLocal() entry point            */
    /************************************************************************/
    if (NO_ERROR == hr)
    {
        hr = NewT120Conference();
        if (NO_ERROR == hr)
        {
            hr = T120StartLocal(m_fSecure);
            if (NO_ERROR == hr)
            {
                m_eState = CONF_ST_PENDING_T120_START_LOCAL;
            }
        }
    }

    DebugExitHRESULT(DCRNCConference::StartLocal, hr);
    return hr;
}


// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
/****************************************************************************/
/* StartRemote() - see erncconf.h                                           */
/****************************************************************************/
HRESULT DCRNCConference::
StartRemote ( LPSTR pszNodeAddress )
{
    HRESULT hr;

    DebugEntry(DCRNCConference::StartRemote);

    /************************************************************************/
    /* Store the node details                                               */
    /************************************************************************/
    m_pszFirstRemoteNodeAddress = ::My_strdupA(pszNodeAddress);
    if (NULL != m_pszFirstRemoteNodeAddress)
    {
        /************************************************************************/
        /* We need to set the conference state before trying to start a new     */
        /* connection - the connection may synchronously call us back and we    */
        /* want to be able to handle the callback correctly.                    */
        /************************************************************************/
        m_eState = CONF_ST_PENDING_CONNECTION;

        /************************************************************************/
        /* Start a new physical connection.                                     */
        /************************************************************************/
        hr = StartConnection(m_pszFirstRemoteNodeAddress, CONF_CON_PENDING_START, NULL, NULL);
        if (NO_ERROR != hr)
        {
            ERROR_OUT(("Error adding connection"));
            m_eState = CONF_ST_UNINITIALIZED;
        }

        /************************************************************************/
        /* We now sit and wait for the connection to complete before            */
        /* continuing.                                                          */
        /************************************************************************/
    }
    else
    {
        ERROR_OUT(("DCRNCConference::StartRemote: can't duplicate node address"));
        hr = UI_RC_OUT_OF_MEMORY;
        m_eState = CONF_ST_UNINITIALIZED;
    }

    DebugExitHRESULT(DCRNCConference::StartRemote, hr);
    return hr;
}
#endif // ENABLE_START_REMOTE


/****************************************************************************/
/* StartIncoming() - see erncconf.h                                          */
/****************************************************************************/
HRESULT DCRNCConference::
StartIncoming(void)
{
    DebugEntry(DCRNCConference::StartIncoming);

    /************************************************************************/
    /* Set the incoming flag.                                               */
    /************************************************************************/
    m_fIncoming = TRUE;

    /************************************************************************/
    /* Create a new T120 conference and call its StartIncoming entry point.  */
    /************************************************************************/
    HRESULT hr = NewT120Conference();
    if (NO_ERROR == hr)
    {
        m_eState = CONF_ST_STARTED;
    }
    else
    {
        WARNING_OUT(("Failed to create new local conference"));
    }

    DebugExitHRESULT(DCRNCConference::StartIncoming, hr);
    return hr;
}


CLogicalConnection::
CLogicalConnection
(
    PCONFERENCE             pConf,
    LOGICAL_CONN_STATE      eAction,
    ConnectionHandle        hConnection,
    PUSERDATAINFO           pInfo,
    UINT                    nInfo,
    BOOL                    fSecure
)
:
    CRefCount(MAKE_STAMP_ID('C','L','N','E')),
    m_pszNodeAddress(NULL),
    m_eState(eAction),
    m_pConf(pConf),
    m_nidConnection(0),
    m_hInviteReqConn(hConnection),
    m_hConnection(hConnection),
    m_pLocalAddress(NULL),
    m_fEventGrabbed(FALSE),
    m_fSecure(fSecure)
{
    DebugEntry(CLogicalConnection::CLogicalConnection);

    if(nInfo)
    {
        for (UINT i = 0 ; i < nInfo; i++, pInfo++)
        {
            m_UserDataInfoList.AddUserData(pInfo->pGUID, pInfo->cbData, pInfo->pData);
        }
    }

    if ((eAction == CONF_CON_INVITED) ||
        (eAction == CONF_CON_JOINED))
    {
        Grab();  // No events to fire.
    }

    DebugExitVOID(CLogicalConnection::CLogicalConnection);
}


CLogicalConnection::
~CLogicalConnection(void)
{
    DebugEntry(CLogicalConnection::~CLogicalConnection);

    ASSERT((m_eState == CONF_CON_CONNECTED) ||
           (m_eState == CONF_CON_ERROR));

    delete m_pszNodeAddress;

    DebugExitVOID(CLogicalConnection::~CLogicalConnection);
}


BOOL CLogicalConnection::
NewLocalAddress(void)
{
    BOOL bNewAddress;
    m_pConf->AddLocalAddress(m_hConnection, &bNewAddress, &m_pLocalAddress);
    return bNewAddress;
}


HRESULT CLogicalConnection::
InviteConnectResult ( HRESULT hr )
{
    DebugEntry(CLogicalConnection::InviteConnectResult);

    if (NO_ERROR == hr)
    {
        /****************************************************************/
        /* Check the state - we should be fully initialized and have a  */
        /* generic conference by this stage.                            */
        /****************************************************************/
        if (m_pConf->m_eState != CONF_ST_STARTED)
        {
            ERROR_OUT(("Bad state %d", m_pConf->m_eState));
            hr = UI_NO_SUCH_CONFERENCE;
        }
        else
        {
            // Now have a connection to the conference, so go do invite.
            // Note that this may not be the only invite if the user invites
            // several people into the conference before the connection is up.
            ReArm(); // So that connection going down fires off event handling
            hr = m_pConf->T120Invite(m_pszNodeAddress,
                                     m_fSecure,
                                     &m_UserDataInfoList,
                                     &m_hInviteReqConn);
            if (NO_ERROR != hr)
            {
                Grab();
            }
        }
    }

    if (NO_ERROR != hr)
    {
        InviteComplete(hr);
    }

    DebugExitHRESULT(CLogicalConnection::InviteConnectResult, hr);
    return hr;
}


void DCRNCConference::
InviteComplete
(
    ConnectionHandle        hInviteReqConn,
    HRESULT                 result,
    PT120PRODUCTVERSION     pVersion
)
{
    CLogicalConnection *  pConEntry;

    DebugEntry(DCRNCConference::InviteComplete);

    pConEntry = GetConEntry(hInviteReqConn);
    if (pConEntry == NULL)
    {
        ERROR_OUT(("Unable to match invite response with request"));
        return;
    }
    pConEntry->SetConnectionHandle(hInviteReqConn);
    pConEntry->InviteComplete(result, pVersion);

    DebugExitVOID(DCRNCConference::InviteComplete);
}


HRESULT CLocalAddressList::
AddLocalAddress
(
    ConnectionHandle    connection_handle,
    BOOL                *pbNewAddress,
    CLocalAddress       **ppLocalAddrToRet
)
{
    HRESULT             hr = UI_RC_OUT_OF_MEMORY;
    CLocalAddress *     pLocalAddress = NULL;
    char                szLocalAddress[64];
    int                 nLocalAddress = sizeof(szLocalAddress);

    DebugEntry(CLocalAddressList::AddLocalAddress);

    *pbNewAddress = FALSE;
    ASSERT (g_pMCSController != NULL);
    if (g_pMCSController->GetLocalAddress (connection_handle, szLocalAddress,
                                            &nLocalAddress)) {
        DBG_SAVE_FILE_LINE
        pLocalAddress = new CLocalAddress(szLocalAddress);
        if (pLocalAddress) {
            if (!IS_EMPTY_STRING(pLocalAddress->m_pszLocalAddress)) {
                BOOL             fFound = FALSE;
                CLocalAddress    *p;
                Reset();
                while (NULL != (p = Iterate()))
                {
                    if (0 == ::lstrcmpA(p->m_pszLocalAddress, szLocalAddress))
                    {
                        fFound = TRUE;
                        break;
                    }
                }

                if (! fFound)
                {
                    ASSERT(NULL == p);
                    Append(pLocalAddress);
                }
                else
                {
                    ASSERT(NULL != p);
                    pLocalAddress->Release();
                    (pLocalAddress = p)->AddRef();
                }
                hr = NO_ERROR;
            }
            else
            {
                pLocalAddress->Release(); // Remove when no longer referenced
                pLocalAddress = NULL;
            }
        }
    }

    *ppLocalAddrToRet = pLocalAddress;

    DebugExitHRESULT(CLocalAddressList::AddLocalAddress, hr);
    return hr;
}


HRESULT CLocalAddressList::
GetLocalAddressList
(
    UINT            *pnAddresses,
    LPCSTR          **ppaAddresses
)
{
    CLocalAddress *     pAddress;
    LPCSTR *            pConnection;
    LPCSTR *            apConn = NULL;
    HRESULT             hr = NO_ERROR;

    DebugEntry(CLocalAddressList::GetLocalAddressList);

    if (! IsEmpty())
    {
        DBG_SAVE_FILE_LINE
        if (NULL == (apConn = new LPCSTR[GetCount()]))
        {
            hr = UI_RC_OUT_OF_MEMORY;
        }
    }

    if (NULL == apConn)
    {
        *pnAddresses = 0;
    }
    else
    {
        hr = NO_ERROR;
        *pnAddresses = GetCount();
        pConnection = apConn;

        Reset();
        while (NULL != (pAddress = Iterate()))
        {
            *pConnection++ = pAddress->m_pszLocalAddress;
        }
    }
    *ppaAddresses = apConn;

    DebugExitHRESULT(CLocalAddressList::GetLocalAddressList, hr);
    return hr;
}


void CLocalAddressList::
EndReference ( CLocalAddress *pLocalAddress )
{
    DebugEntry(CLocalAddressList::EndReference);

    if (pLocalAddress->Release() == 0)
    {
        Remove(pLocalAddress);
    }

    DebugExitVOID(CLocalAddressList::EndReference);
}



CLocalAddress::CLocalAddress(PCSTR szLocalAddress)
:
    CRefCount(MAKE_STAMP_ID('L','A','D','R'))
{
    m_pszLocalAddress = ::My_strdupA(szLocalAddress);
}


void CLogicalConnection::
InviteComplete
(
    HRESULT                 hrStatus,
    PT120PRODUCTVERSION     pVersion
)
{
    DebugEntry(CLogicalConnection::InviteComplete);

    // Don't want user calling us back in
    // InviteConferenceResult to delete the conference
    // causing this object to be deleted whilst
    // in it.
    AddRef();

    // Should only handle an invite complete if there is one pending.
    // Otherwise, this is most likely the result of entering this function
    // after telling the user that the invite has failed for some other
    // reason (e.g. a physical connection going down).
    // In these cases, just ignore the invite complete event.

    if (m_eState == CONF_CON_PENDING_INVITE)
    {
        // Invite complete will generate an event, so grab it.

        Grab();

        if (hrStatus != NO_ERROR)
        {
            m_eState = CONF_CON_ERROR;
        }
        else
        {
            m_eState = CONF_CON_CONNECTED;
            if (NewLocalAddress())
            {
                m_pConf->AnnouncePresence();
            }
        }
        g_pCallbackInterface->OnInviteResult(
                            (CONF_HANDLE) m_pConf,
                            (REQUEST_HANDLE) this,
                            m_nidConnection,
                            hrStatus,
                            pVersion);
        if (hrStatus != NO_ERROR)
        {
            // Remove conentry from conference if invite fails.
            Delete(hrStatus);
        }
    }

    Release();

    DebugExitVOID(CLogicalConnection::InviteComplete);
}


void CLogicalConnection::
Delete ( HRESULT hrReason )
{
    DebugEntry(CLogicalConnection::Delete);

    // WARNING, WARNING, WARNING:
    // This method gets re-entered on the stack.
    // Note guards in code below.
    if (NULL != m_pConf)
    {
        PCONFERENCE pThisConf = m_pConf;
        PCONFERENCE pConfToFree = NULL;
        m_pConf = NULL;

        // The connection is going away, so remove the reference to the
        // associated local connection (if any).
        if (NULL != m_pLocalAddress)
        {
            pThisConf->EndReference(m_pLocalAddress);
            m_pLocalAddress = NULL;
        }

        if (m_eState == CONF_CON_INVITED)
        {
            // The conference associated with the entry was invited into the conference,
            // so remove the conference and all of its connections.

            m_eState = CONF_CON_ERROR;   // Only do this once
            pConfToFree = pThisConf;
        }

        // If there is a pending event on the connection,
        // then try to grab it and notify the requestor
        // that the request has failed.
        // Note that the event handler may itself end up
        // recalling this function, so it refcounts the
        // CLogicalConnection to prevent it from being destructed
        // too soon.

        if (Grab())
        {
            pThisConf->NotifyConnectionComplete(this, hrReason);
        }

        // Set the connection state to be in error.
        // Note that this is done after firing the event because
        // otherwise a failed connection attempt to a disabled transport
        // would cause the local conference to be destroyed by
        // NotifyConnectionComplete().
        m_eState = CONF_CON_ERROR;

        // Sever the connection entry with the conference record.
        pThisConf->m_ConnList.Remove(this);

        // Now destroy the conentry once any pending event has fired -
        // there is only a pending connection request or a pending
        // request to join/invite/create a conference, and never both.
        Release();

        if (NULL != pConfToFree)
        {
            g_pNCConfMgr->RemoveConference(pConfToFree);
        }
    }

    DebugExitVOID(CLogicalConnection::Delete);
}


BOOL FindSocketNumber(DWORD nid, SOCKET * socket_number)
{
    (*socket_number) = 0;
    ASSERT(g_pNCConfMgr != NULL);

    return g_pNCConfMgr->FindSocketNumber((GCCNodeID) nid, socket_number);
}

// DCRNCConference::FindSocketNumber
// Given a GCCNodeID, finds a socket number associated with that id.
// Returns TRUE if we are directly connected topology-wise to the node, FALSE if not.
BOOL DCRNCConference::
FindSocketNumber
(
    GCCNodeID           nid,
    SOCKET              *socket_number
)
{
    CLogicalConnection *pConEntry;
    m_ConnList.Reset();
    while (NULL != (pConEntry = m_ConnList.Iterate()))
    {
        if (pConEntry->GetConnectionNodeID() == nid)
        {
            // Found it!
            g_pMCSController->FindSocketNumber(pConEntry->GetConnectionHandle(), socket_number);
            return TRUE;
        }
    }

    return FALSE;
}



ULONG DCRNCConference::
GetNodeName(GCCNodeID  NodeId,  LPSTR   pszBuffer,  ULONG  cbBufSize)
{
    LPSTR   pszName = m_NodeIdNameList.Find(NodeId);
    if (pszName)
    {
        ::lstrcpynA(pszBuffer, pszName, cbBufSize);
        return lstrlenA(pszName);
    }
    return 0;
}



ULONG DCRNCConference::
GetUserGUIDData(GCCNodeID  NodeId,  GUID  *pGuid,
                LPBYTE   pbBuffer,  ULONG  cbBufSize)
{
    CNCUserDataList  *pUserDataList = m_UserDataList.Find(NodeId);
    GCCUserData       *pUserData;

    if (pUserDataList)
    {
        pUserData = pUserDataList->GetUserGUIDData(pGuid);
        if (pUserData)
        {
            if (pbBuffer)
            {
                ::CopyMemory(pbBuffer, pUserData->octet_string->value + sizeof(GUID),
                             min(cbBufSize, pUserData->octet_string->length - sizeof(GUID)));
            }
            return pUserData->octet_string->length - sizeof(GUID);
        }
        // The GUID is not found
    }
    // The NodeId is not found
    return 0;
}


void DCRNCConference::
UpdateNodeIdNameListAndUserData(PGCCMessage  message)
{
    GCCNodeID  NodeId;
    LPSTR       pszName;
    LPWSTR     pwszNodeName;
    GCCNodeRecord  *pNodeRecord;
    PGCCConferenceRoster pConfRost;
    USHORT     count;

    PGCCUserData         pGccUserData;
    USHORT        count2;
    CNCUserDataList      *pUserDataList;

    ASSERT (message->message_type == GCC_ROSTER_REPORT_INDICATION);

    pConfRost = message->u.conf_roster_report_indication.conference_roster;

    for (count = 0; count < pConfRost->number_of_records; count++)
    {
        pNodeRecord = pConfRost->node_record_list[count];
        NodeId  = pNodeRecord->node_id;
        pwszNodeName = pNodeRecord->node_name;

        pszName = m_NodeIdNameList.Find(NodeId);
        if (!pszName)
        {
            int ccnsize = (lstrlenW(pwszNodeName) + 1) * sizeof(WCHAR);
            DBG_SAVE_FILE_LINE
            pszName = new char[ccnsize];
            if (pszName)
            {
                if (WideCharToMultiByte(CP_ACP, 0, pwszNodeName, -1, pszName, ccnsize, NULL, NULL))
                {
                    m_NodeIdNameList.Append(NodeId, pszName);
                }
                else
                {
                    ERROR_OUT(("ConfMgr::UpdateNodeIdNameList: cannot convert unicode node name"));
                }
            }
            else
            {
                ERROR_OUT(("ConfMgr::UpdateNodeIdNameList: cannot duplicate unicode node name"));
            }
        }


        for (count2 = 0; count2 < pNodeRecord->number_of_user_data_members; count2++)
        {
            pGccUserData = pNodeRecord->user_data_list[count2];
            if (pGccUserData->octet_string->length <= sizeof(GUID))
                continue;  // not real user data

            pUserDataList = m_UserDataList.Find(NodeId);
            if (!pUserDataList)
            {
                DBG_SAVE_FILE_LINE
                pUserDataList = new CNCUserDataList;
                m_UserDataList.Append(NodeId, pUserDataList);
            }

            pUserDataList->AddUserData((GUID *)pGccUserData->octet_string->value,
                                    pGccUserData->octet_string->length - sizeof(GUID),
                                    pGccUserData->octet_string->value + sizeof(GUID));

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\erncglbl.cpp ===
/****************************************************************************/
/*                                                                          */
/* ERNCGLBL.CPP                                                             */
/*                                                                          */
/* RNC global functions.                                                    */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  11Sep95 NFC             Created.                                        */
/*  21Sep95 NFC             Initialize all combo boxes.                     */
/*  11Oct95 PM              Remove GCC_BAD_PASSWORD                         */
/*                                                                          */
/****************************************************************************/

#include "precomp.h"
#include "ms_util.h"
#include "ernccons.h"
#include "nccglbl.hpp"
#include "erncvrsn.hpp"
#include <cuserdta.hpp>

#include "erncconf.hpp"
#include "ernctrc.h"


/****************************************************************************/
/* GCC error table. This must macth exactly the enumeration in NCUI.H        */
/****************************************************************************/
const GCCResult rcGCCTable[] =
{
    GCC_RESULT_SUCCESSFUL,                //    NO_ERROR
    GCC_RESULT_ENTRY_ALREADY_EXISTS,    //    UI_RC_ALREADY_IN_CONFERENCE
    GCC_RESULT_ENTRY_ALREADY_EXISTS,    //    UI_RC_CONFERENCE_ALREADY_EXISTS
    GCC_RESULT_INVALID_PASSWORD,        //    UI_RC_INVALID_PASSWORD,
    GCC_RESULT_INVALID_CONFERENCE,        //    UI_RC_NO_CONFERENCE_NAME,
    GCC_RESULT_UNSPECIFIED_FAILURE,        //    UI_RC_T120_FAILURE,
    GCC_RESULT_INVALID_CONFERENCE,        //    UI_RC_UNKNOWN_CONFERENCE,
    GCC_RESULT_INCOMPATIBLE_PROTOCOL,    //    UI_RC_BAD_TRANSPORT_NAME
    GCC_RESULT_USER_REJECTED,            //    UI_RC_USER_REJECTED,

    GCC_RESULT_UNSPECIFIED_FAILURE        //  UI_RC_ERROR > LAST_RC_GCC_MAPPED_ERROR
};


/****************************************************************************/
/* GCC error table. This must macth exactly the enumeration in GCC.H        */
/****************************************************************************/
typedef struct
{
    GCCError    rc;
    HRESULT     hr;
}
    RC2HR;
    
const RC2HR c_aRc2Hr[] =
{
    { GCC_ALREADY_INITIALIZED,          UI_RC_T120_ALREADY_INITIALIZED },
    { GCC_INVALID_CONFERENCE,           UI_RC_UNKNOWN_CONFERENCE },
    { GCC_CONFERENCE_ALREADY_EXISTS,    UI_RC_CONFERENCE_ALREADY_EXISTS },
    { GCC_SECURITY_FAILED,                UI_RC_T120_SECURITY_FAILED },
};

/****************************************************************************/
/* GCC result table.This must macth exactly the enumeration in GCC.H        */
/****************************************************************************/
typedef struct
{
    GCCResult   result;
    HRESULT     hr;
}
    RESULT2HR;

const RESULT2HR c_aResult2Hr[] =
{
    { GCC_RESULT_INVALID_CONFERENCE,    UI_RC_UNKNOWN_CONFERENCE },
    { GCC_RESULT_INVALID_PASSWORD,      UI_RC_INVALID_PASSWORD },
    { GCC_RESULT_USER_REJECTED,         UI_RC_USER_REJECTED },
    { GCC_RESULT_ENTRY_ALREADY_EXISTS,  UI_RC_CONFERENCE_ALREADY_EXISTS },
    { GCC_RESULT_CANCELED,              UI_RC_T120_FAILURE },
    { GCC_RESULT_CONNECT_PROVIDER_REMOTE_NO_SECURITY, UI_RC_T120_REMOTE_NO_SECURITY },
    { GCC_RESULT_CONNECT_PROVIDER_REMOTE_DOWNLEVEL_SECURITY, UI_RC_T120_REMOTE_DOWNLEVEL_SECURITY },
    { GCC_RESULT_CONNECT_PROVIDER_REMOTE_REQUIRE_SECURITY, UI_RC_T120_REMOTE_REQUIRE_SECURITY },
	{ GCC_RESULT_CONNECT_PROVIDER_AUTHENTICATION_FAILED, UI_RC_T120_AUTHENTICATION_FAILED },
};


HRESULT GetGCCRCDetails(GCCError rc)
{
    if (GCC_NO_ERROR == rc)
    {
        return NO_ERROR;
    }

    for (int i = 0; i < sizeof(c_aRc2Hr) / sizeof(c_aRc2Hr[0]); i++)
    {
        if (c_aRc2Hr[i].rc == rc)
        {
            return c_aRc2Hr[i].hr;
        }
    }

    return UI_RC_T120_FAILURE;
}

HRESULT GetGCCResultDetails(GCCResult result)
{
    if (GCC_RESULT_SUCCESSFUL == result)
    {
        return NO_ERROR;
    }

    for (int i = 0; i < sizeof(c_aResult2Hr) / sizeof(c_aResult2Hr[0]); i++)
    {
        if (c_aResult2Hr[i].result == result)
        {
            return c_aResult2Hr[i].hr;
        }
    }

    return UI_RC_T120_FAILURE;
}

GCCResult MapRCToGCCResult(HRESULT rc)
{
    // Called to map an error code to a GCC result to give to GCC.

    TRACE_FN("MapRCToGCCResult");

    ASSERT(sizeof(rcGCCTable)/sizeof(rcGCCTable[0]) - (LAST_RC_GCC_MAPPED_ERROR & 0x00ff) - 2 == 0);

    return (rcGCCTable[(UINT) rc > (UINT) LAST_RC_GCC_MAPPED_ERROR ? (LAST_RC_GCC_MAPPED_ERROR & 0x00ff) + 1 : (rc & 0x00ff)]);
}


HRESULT GetUnicodeFromGCC(PCSTR    szGCCNumeric, 
                           PCWSTR    wszGCCUnicode,
                           PWSTR *    pwszText)
{
    // Obtain a Unicode string from a funky GCCString that may be 
    // ANSI numeric or Unicode text. Note that a new Unicode
    // string is always allocated or NULL returned.

    LPWSTR        wszText;
    HRESULT    Status = NO_ERROR;

    ASSERT(pwszText);

    if (! ::IsEmptyStringW(wszGCCUnicode))
    {
        wszText = ::My_strdupW(wszGCCUnicode);
    }
    else if (! ::IsEmptyStringA(szGCCNumeric))
    {
        wszText = ::AnsiToUnicode(szGCCNumeric);
    }
    else
    {
        *pwszText = NULL;
        return(Status);
    }
    if (!wszText)
    {
        Status = UI_RC_OUT_OF_MEMORY;
    }
    *pwszText = wszText;
    return(Status);
}


HRESULT GetGCCFromUnicode
(
    LPCWSTR              pcwszText,
    GCCNumericString *   pGCCNumeric, 
    LPWSTR           *   pGCCUnicode
)
{
    // Construct a funky GCCString that may be ANSI numeric or Unicode text
    // from a Unicode string. Note that only a new ANSI numeric string may
    // be constructed - the Unicode string passed is is used.
    HRESULT hr = NO_ERROR;
    if (! ::IsEmptyStringW(pcwszText) && ::UnicodeIsNumber(pcwszText))
    {
        *pGCCUnicode = NULL;
        if (NULL == (*pGCCNumeric = (GCCNumericString) ::UnicodeToAnsi(pcwszText)))
        {
            hr = UI_RC_OUT_OF_MEMORY;
        }
    }
    else
    {
        *pGCCUnicode = (LPWSTR) pcwszText;
        *pGCCNumeric = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\ernccons.h ===
/****************************************************************************/
/*                                                                          */
/* ERNCCONS.H                                                               */
/*                                                                          */
/* Global header for RNC.                                                   */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  16Jun95 NFC             Created.                                        */
/*  21Sep95 NFC             Increase number of saved nodes to 50.           */
/*                          Removed RNC_INI_NUM_NODES.                      */
/*                                                                          */
/****************************************************************************/

#ifndef __ERNCCONS_H_
#define __ERNCCONS_H_


/****************************************************************************/
/* #defines for pointers to the various objects.                            */
/****************************************************************************/
#define PCONFERENCE     DCRNCConference *

/****************************************************************************/
/* Max length of the RNC node details string                                */
/****************************************************************************/
#define RNC_MAX_NODE_STRING_LEN   512

/****************************************************************************/
/* The TCP transport name and separator, used to generate GCC addresses.    */
/****************************************************************************/
#define  RNC_GCC_TRANSPORT_AND_SEPARATOR 				"TCP:"
#define  RNC_GCC_TRANSPORT_AND_SEPARATOR_UNICODE		L"TCP:"
#define  RNC_GCC_TRANSPORT_AND_SEPARATOR_LENGTH			4

#endif /* __ERNCCONS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\erncpcm.hpp ===
#ifdef ENABLE_PC
/****************************************************************************/
/*                                                                          */
/* ERNCPCM.HPP                                                              */
/*                                                                          */
/* Physical Connection Manager class for the Reference System Node          */
/* Controller.                                                              */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  16Jun95 NFC             Created.                                        */
/*                                                                          */
/****************************************************************************/

#ifndef __ERNCPCM_HPP_
#define __ERNCPCM_HPP_

#include "erncpc.hpp"

class DCRNCConference;

class DCRNCPhysicalConnectionManager
{
friend class DCRNCConferenceManager;
public:
    /************************************************************************/
    /* FUNCTION: DCRNCPhysicalConnectionManager Constructor.                */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This is the constructor for the physical connection manager.         */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pSuccess - pointer to BOOL holding result of constructor on return.*/
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* Nothing (result is returned in the pSuccess parameter).              */
    /*                                                                      */
    /************************************************************************/
    DCRNCPhysicalConnectionManager(NCSTATUS * pStatus);

    /************************************************************************/
    /* FUNCTION: DCRNCPhysicalConnectionManager Destructor.                 */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This is the destructor for the physical conection manager class.     */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* None.                                                                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* Nothing.                                                             */
    /*                                                                      */
    /************************************************************************/
    virtual ~DCRNCPhysicalConnectionManager();

    /************************************************************************/
    /* FUNCTION: GetConnection().                                           */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function returns a physical connection to the calling           */
    /* conference.  In order to start the connection, the conference must   */
    /* call the connections Connect() entry point.                          */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* ppConnection - pointer to pointer to connection (returned).          */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* PCM_RC_NO_TRANSPORTS - there are no transports of the requested type */
    /*                         to create a connection with.                 */
    /* PCM_RC_INTERNAL_ERROR - an internal error occurred whilst trying     */
    /*                         to establish the connection.                 */
    /*                                                                      */
    /************************************************************************/
    NCSTATUS GetConnection(PRNC_NODE_DETAILS pNodeDetails,
                           PPHYSICAL_CONNECTION * ppConnection,
						   CEvent * pEvent,
						   BOOL bIsConferenceActive);

    /************************************************************************/
    /* FUNCTION: NotifyConnectionEnded()                                    */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called by an instance of a PHYSICAL_CONNECTION      */
    /* when it has ended/become redundant.                                  */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pConnection - pointer to connection which has ended.                 */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* Nothing.                                                             */
    /*                                                                      */
    /************************************************************************/
    void NotifyConnectionEnded(PPHYSICAL_CONNECTION  pConnection,
							   NCSTATUS Reason);

protected:

    /************************************************************************/
    /* Array of connections.                                                */
    /************************************************************************/
    COBLIST  connectionList;

};

extern DCRNCPhysicalConnectionManager   *g_pPhysConnManager;

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/


/****************************************************************************/
/* Return codes.                                                            */
/****************************************************************************/
#define PCM_RC_INTERNAL_ERROR              1
#define PCM_RC_NO_TRANSPORTS               2

#endif /* __ERNCPCM_HPP_  */
#endif // ENABLE_PC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\erncpc.hpp ===
#ifdef ENABLE_PC
/****************************************************************************/
/*                                                                          */
/* ERNCPC.HPP                                                               */
/*                                                                          */
/* Physical Connection class for the Reference System Node Controller.      */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  16Jun95 NFC             Created.                                        */
/*                                                                          */
/****************************************************************************/

#ifndef __ERNCPC_HPP_
#define __ERNCPC_HPP_

#include "events.hpp"

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* States                                                                   */
/****************************************************************************/
typedef enum
{
    PC_ST_UNINITIALIZED,
    PC_ST_CONNECTING,
    PC_ST_CONNECTED,
    PC_ST_DISCONNECTING,
    PC_ST_REMOVED,
}
    PC_STATE;

/****************************************************************************/
/* Return codes                                                             */
/****************************************************************************/
#define  PC_RC_BAD_STATE           1
#define  PC_RC_INTERNAL_ERROR      3


class CONFERENCE;
class PC_MANAGER;

class DCRNCPhysicalConnection : public CRefCount, public CPendingEventList
{
friend class PC_MANAGER;
friend class NCUI;

protected:

    /************************************************************************/
    /* State of this connection.                                            */
    /************************************************************************/
    PC_STATE conState;
	BOOL bDisconnectPending;

    /************************************************************************/
    /* Address we are calling/connected to.                                 */
    /************************************************************************/
    RNC_NODE_DETAILS UserNodeDetails;

	UINT asymmetry_type;

public:
    /************************************************************************/
    /* FUNCTION: DCRNCPhysicalConnection Constructor.                       */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This is the constructor for physical connection class.				*/
    /*                                                                      */
    /* This function                                                        */
    /* - saves the supplied transport drivers.                              */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pManager - pointer to the physical connection manager class.         */
    /*																		*/
    /* pSuccess - pointer to BOOL holding result of constructor on return.  */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* Nothing (result is returned in the pSuccess parameter).              */
    /*                                                                      */
    /************************************************************************/
    DCRNCPhysicalConnection(PRNC_NODE_DETAILS	pNodeDetails,
							UINT                _asymmetry_type,
							PBOOL				pSuccess);


    /************************************************************************/
    /* FUNCTION: DCRNCPhysicalConnection Destructor.                        */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This is the destructor for the transport driver wrapper clas.        */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* None.                                                                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* Nothing.                                                             */
    /*                                                                      */
    /************************************************************************/
    virtual ~DCRNCPhysicalConnection();

	void AddRefEvent(CEvent * pEvent);

	/*
	 *	The Core does not currently do anything with the status we report.
	 *	We leave the code though, in case it starts using the status info
	 *	we provide.  See file erncpc.cpp
	 */
	void ReportStatus(PC_STATE _conState, NCSTATUS Reason = NO_ERROR) { conState = _conState; };
	UINT AsymmetryType() {return asymmetry_type;};

    /************************************************************************/
    /* FUNCTION: Connect().                                                 */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to start this physical connection.           */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /************************************************************************/
    void Connect();

    /************************************************************************/
    /* FUNCTION: Disconnect().                                              */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to end this physical connection.             */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* None.                                                                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /************************************************************************/
    NCSTATUS Disconnect(void);

    /************************************************************************/
    /* FUNCTION: GetNodeDetails                                             */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function returns details of the node that this physical         */
    /* connection refers to.                                                */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* Pointer to hold the node details on return.                          */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* None.                                                                */
    /*                                                                      */
    /************************************************************************/
    PRNC_NODE_DETAILS GetUserNodeDetails();
    PRNC_NODE_DETAILS GetTransportNodeDetails() { return &UserNodeDetails; };
};

/****************************************************************************/
/* MACROS                                                                   */
/****************************************************************************/

#endif /* __ERNCPC_HPP_ */
#endif // ENABLE_PC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\erncgccc.cpp ===
/****************************************************************************/
/*                                                                          */
/* ERNCGCCC.CPP                                                             */
/*                                                                          */
/* T120 Conference class for the Reference System Node Controller.          */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  14Jul95 NFC             Created.                                        */
/*  13Sep95 NFC             Added handler for GCC_EJECT_USER_INDICATION     */
/*  26Sep95 NFC             Reset conference state in HandleEjectUser().    */
/*  11Oct95 PM              Relax conference termination checks to avoid    */
/*                          "no win" situations. The user wants it down     */
/*                          then bring it down, whatever the state!         */
/*                                                                          */
/****************************************************************************/
#include "precomp.h"
DEBUG_FILEZONE(ZONE_GCC_NC);
#include "ernccons.h"
#include "nccglbl.hpp"
#include "erncvrsn.hpp"
#include "cuserdta.hpp"

#include "ernccm.hpp"
#include "ernctrc.h"
#include "nmremote.h"


static UINT s_nNumericNameCounter = 0;
__inline UINT GetNewNumericNameCounter(void) { return ++s_nNumericNameCounter; }



HRESULT DCRNCConference::
NewT120Conference(void)
{
    DebugEntry(DCRNCConference::NewT120Conference);

    m_eT120State = T120C_ST_IDLE;

    HRESULT             hr;
    PCONFERENCE         pConf;
    GCCNumericString    pszNewNumericName;

    m_ConfName.numeric_string = NULL; // No numeric name yet.

    hr = ::GetGCCFromUnicode(m_pwszConfName, &pszNewNumericName, &m_ConfName.text_string);
    if (NO_ERROR == hr)
    {
        if (! ::IsEmptyStringA((LPCSTR) pszNewNumericName))
        {
            // Conference has a preassigned numeric name.
            // Validate that it does not conflict with another
            // conferences numeric name.
            pConf = g_pNCConfMgr->GetConferenceFromNumber(pszNewNumericName);
            if (NULL == pConf)
            {
                hr = NO_ERROR;
            }
            else
            {
                ERROR_OUT(("DCRNCConference::NewT120Conference: conference already exists"));
                hr = UI_RC_CONFERENCE_ALREADY_EXISTS;
            }
        }
        else
        {
            // Conference does not have a numeric name.
            // Go get it a unique one.
            DBG_SAVE_FILE_LINE
            pszNewNumericName = (GCCNumericString)new CHAR[10];
            if (NULL != pszNewNumericName)
            {
                do
                {
                    // Do not allocate a conference number that is the same as
                    // an existing conference.
                    // bugbug: T120 should really do this, but it doesn't.
                    ::wsprintfA((LPSTR) pszNewNumericName, "%u", ::GetNewNumericNameCounter());
                    pConf = g_pNCConfMgr->GetConferenceFromNumber(pszNewNumericName);
                    if (NULL == pConf)
                    {
                        hr = NO_ERROR; // Name good.
                        break;
                    }
                }
                while (TRUE); // Assumes not a DWORDs worth of conferences active.
            }
            else
            {
                ERROR_OUT(("DCRNCConference::NewT120Conference: can't create numeric name"));
                hr = UI_RC_OUT_OF_MEMORY;
            }
        }
    }
    else
    {
        ERROR_OUT(("DCRNCConference::NewT120Conference: GetGCCFromUnicode failed, hr=0x%x", (UINT) hr));
    }

    // Done looking for numeric name, so can now insert into list.
    m_ConfName.numeric_string = pszNewNumericName;

    // In case of failure, be sure to notify nmcom.
    if (NO_ERROR != hr)
    {
        g_pNCConfMgr->NotifyConferenceComplete(this, m_fIncoming, hr);
    }

    DebugExitHRESULT(DCRNCConference::NewT120Conference, hr);
    return hr;
}


/****************************************************************************/
/* AnnouncePresence() - announce this nodes participation in the            */
/* conference.                                                              */
/****************************************************************************/
HRESULT DCRNCConference::
AnnouncePresence(void)
{
    GCCError            GCCrc = GCC_INVALID_CONFERENCE;
    HRESULT             hr = UI_RC_OUT_OF_MEMORY;
    GCCNodeType         nodeType;
    GCCNodeProperties   nodeProperties;
    LPWSTR              nodeName;
    UINT                nRecords;
    GCCUserData **      ppUserData;

    DebugEntry(DCRNCConference::AnnouncePresence);

    if (0 != m_nConfID)
    {
        // bugbug: handle errors that cause failure to announce presence.

        // Obtain the local addresses for the local user and
        // publish them in the roster.
        g_pCallbackInterface->OnUpdateUserData(this);

        /************************************************************************/
        /* Load the node type, node properties and node name from the RNC INI   */
        /* file.                                                                */
        /************************************************************************/
        nodeName = NULL;
        ::LoadAnnouncePresenceParameters(
                            &nodeType,
                            &nodeProperties,
                            &nodeName,
                            NULL);            // &siteInfo)) : Not used right now.

        /************************************************************************/
        /* Announce our presence in the conference.                             */
        /************************************************************************/
        hr = m_LocalUserData.GetUserDataList(&nRecords, &ppUserData);
        if (NO_ERROR == hr)
        {
            GCCrc = g_pIT120ControlSap->AnnouncePresenceRequest(
                               m_nConfID,
                               nodeType,
                               nodeProperties,
                               nodeName,
                               0,    /* number_of_participants      */
                               NULL, //partNameList, /* participant_name_list       */
                               NULL, /* pwszSiteInfo            */
                               0,    /* number_of_network_addresses */
                               NULL, /* network_address_list        */
                               NULL, //pAltID, /* alternative_node_id         */
                               nRecords,/* number_of_user_data_members */
                               ppUserData  /* user_data_list              */
                               );
            hr = ::GetGCCRCDetails(GCCrc);
        }

        delete nodeName;
    }

    if (GCC_NO_ERROR != GCCrc)
    {
        if (GCC_CONFERENCE_NOT_ESTABLISHED == GCCrc ||
            GCC_INVALID_CONFERENCE == GCCrc)
        {
            TRACE_OUT(("DCRNCConference::AnnouncePresence: conf is gone."));
        }
        else
        {
            ERROR_OUT(("DCRNCConference::AnnouncePresence: failed, gcc_rc=%u", GCCrc));
        }
    }

    DebugExitHRESULT(DCRNCConference::AnnouncePresence, hr);
    return hr;
}


/****************************************************************************/
/* HandleGCCCallback() - see erncgccc.hpp                                   */
/****************************************************************************/
void DCRNCConference::
HandleGCCCallback ( GCCMessage *pGCCMessage )
{
    DebugEntry(DCRNCConference::HandleGCCCallback);

    TRACE_OUT(("DCRNCConference::HandleGCCCallback: msg id=%u", pGCCMessage->message_type));

    /************************************************************************/
    /* Note that GCC_CREATE_IND and GCC_INVITE_IND callbacks are handled    */
    /* higher up the stack by the conference manager and are not passed     */
    /* onto us.                                                             */
    /************************************************************************/
    switch (pGCCMessage->message_type)
    {
        case GCC_CREATE_CONFIRM:
            HandleCreateConfirm(&(pGCCMessage->u.create_confirm));
            break;

        case GCC_INVITE_CONFIRM:
            HandleInviteConfirm(&(pGCCMessage->u.invite_confirm));
            break;

        case GCC_ADD_CONFIRM:
            HandleAddConfirm(&(pGCCMessage->u.add_confirm));
            break;

        case GCC_DISCONNECT_INDICATION:
            HandleDisconnectInd(&(pGCCMessage->u.disconnect_indication));
            break;

        case GCC_DISCONNECT_CONFIRM:
            HandleDisconnectConfirm(
                                 &(pGCCMessage->u.disconnect_confirm));
            break;

        case GCC_TERMINATE_INDICATION:
            HandleTerminateInd(&(pGCCMessage->u.terminate_indication));
            break;

        case GCC_TERMINATE_CONFIRM:
            HandleTerminateConfirm(&(pGCCMessage->u.terminate_confirm));
            break;

        case GCC_ANNOUNCE_PRESENCE_CONFIRM:
            HandleAnnounceConfirm(&(pGCCMessage->u.announce_presence_confirm));
            break;

        case GCC_ROSTER_REPORT_INDICATION:
            HandleRosterReport(pGCCMessage->u.conf_roster_report_indication.conference_roster);
            break;

        case GCC_ROSTER_INQUIRE_CONFIRM:
            HandleRosterReport(pGCCMessage->u.conf_roster_inquire_confirm.conference_roster);
            break;

        case GCC_PERMIT_TO_ANNOUNCE_PRESENCE:
            HandlePermitToAnnounce(&(pGCCMessage->u.permit_to_announce_presence));
            break;

        case GCC_EJECT_USER_INDICATION:
            HandleEjectUser(&(pGCCMessage->u.eject_user_indication));
            break;

        case GCC_CONNECTION_BROKEN_INDICATION:
            HandleConnectionBrokenIndication(&(pGCCMessage->u.connection_broken_indication));
            break;

        default :
            WARNING_OUT(("Unrecognised event %d", pGCCMessage->message_type));
            break;
    }

    DebugExitVOID(DCRNCConference::HandleGCCCallback);
}


void DCRNCConference::
HandleConnectionBrokenIndication ( ConnectionBrokenIndicationMessage * pConnDownMsg )
{
    DebugEntry(DCRNCConference::HandleConnectionBrokenIndication);

    // A logical connection in a conference has gone away.
    // Find the associated logical connection (if it is still around)
    // and Delete() it.
    // This function is what causes a modem line to drop when someone
    // invited into a conference over a modem leaves the conference.
    CLogicalConnection *pConEntry = GetConEntry(pConnDownMsg->connection_handle);
    if (NULL != pConEntry)
    {
        pConEntry->Delete(UI_RC_USER_DISCONNECTED);
    }

    DebugExitVOID(DCRNCConference::HandleConnectionBrokenIndication);
}


/****************************************************************************/
/* HandleAddConfirm - handle a GCC_ADD_CONFIRM message                      */
/****************************************************************************/


/****************************************************************************/
/* HandleAnnounceConfirm - handle a GCC_ANNOUNCE_PRESENCE_CONFIRM message   */
/****************************************************************************/
void DCRNCConference::
HandleAnnounceConfirm ( AnnouncePresenceConfirmMessage * pAnnounceConf )
{
    DebugEntry(DCRNCConference::HandleAnnounceConfirm);

    /************************************************************************/
    /* Map the return code to a conference return code.                     */
    /************************************************************************/
    HRESULT hr = ::GetGCCResultDetails(pAnnounceConf->result);

    TRACE_OUT(("GCC event: GCC_ANNOUNCE_PRESENCE_CONFIRM"));
    TRACE_OUT(("Result=%u", pAnnounceConf->result));

    /************************************************************************/
    /* If this failed, tell the base conference that we failed to start.    */
    /************************************************************************/
    if (NO_ERROR != hr)
    {
        ERROR_OUT(("Failed to announce presence in conference"));
        NotifyConferenceComplete(hr);
        // bugbug: ??? Should we leave the conference here???
    }

    /************************************************************************/
    /* Now sit and wait for our entry to appear in the conference roster.   */
    /************************************************************************/

    DebugExitHRESULT(DCRNCConference::HandleAnnounceConfirm, hr);
}


/****************************************************************************/
/* HandleCreateConfirm - handle a GCC_CREATE_CONFIRM message.               */
/****************************************************************************/
void DCRNCConference::
HandleCreateConfirm ( CreateConfirmMessage * pCreateConfirm )
{
    DebugEntry(DCRNCConference::HandleCreateConfirm);

    /************************************************************************/
    /* Map the GCC result onto CONF_RC_ return code.                        */
    /************************************************************************/
    HRESULT hr = ::GetGCCResultDetails(pCreateConfirm->result);

    TRACE_OUT(("GCC event:  GCC_CREATE_CONFIRM"));
    TRACE_OUT(("Result=%u", pCreateConfirm->result));
    TRACE_OUT(("Conference ID %ld", pCreateConfirm->conference_id));

    /************************************************************************/
    /* Result of our attempt to start a new conference                      */
    /************************************************************************/
    if (NO_ERROR == hr)
    {
        /************************************************************************/
        /* Store the conference ID.                                             */
        /************************************************************************/
        m_nConfID = pCreateConfirm->conference_id;
    }
    else
    {
        ERROR_OUT(("Error %d creating new conference", hr));

        /************************************************************************/
        /* Pass any failure result onto the base conference.                    */
        /************************************************************************/
        NotifyConferenceComplete(hr);
    }

    DebugExitVOID(DCRNCConference::HandleCreateConfirm);
}


/****************************************************************************/
/* HandleDisconnectConfirm - handle a GCC_DISCONNECT_CONFIRM message.       */
/****************************************************************************/
void DCRNCConference::
HandleDisconnectConfirm ( DisconnectConfirmMessage * pDiscConf )
{
    DebugEntry(DCRNCConference::HandleDisconnectConfirm);

    /************************************************************************/
    /* Check the state.                                                     */
    /************************************************************************/
    if (m_eT120State != T120C_ST_PENDING_DISCONNECT)
    {
        WARNING_OUT(("Bad state %d, expecting %d",
                    T120C_ST_PENDING_DISCONNECT,
                    m_eT120State));
    }

    /************************************************************************/
    /* Map the GCC result onto CONF_RC_ return code.                        */
    /************************************************************************/
    TRACE_OUT(("GCC event: GCC_DISCONNECT_CONFIRM"));
    TRACE_OUT(("Result=%u", pDiscConf->result));
    TRACE_OUT(("Conference ID %ld", pDiscConf->conference_id));

    /************************************************************************/
    /* We have successsfully left the conference, so tell the base          */
    /* conference about it.                                                 */
    /************************************************************************/
    g_pNCConfMgr->RemoveConference(this);

    DebugExitVOID(DCRNCConference::HandleDisconnectConfirm);
}


/****************************************************************************/
/* HandleDisconnectInd - handle a GCC_DISCONNECT_INDICATION message.        */
/****************************************************************************/
void DCRNCConference::
HandleDisconnectInd ( DisconnectIndicationMessage * pDiscInd )
{
    DebugEntry(DCRNCConference::HandleDisconnectInd);

    /************************************************************************/
    /* Check the state.                                                     */
    /************************************************************************/
    TRACE_OUT(("GCC event: GCC_DISCONNECT_INDICATION"));
    TRACE_OUT(("Conference ID %d", pDiscInd->conference_id));
    TRACE_OUT(("Reason=%u", pDiscInd->reason));
    TRACE_OUT(("Disconnected Node ID %d", pDiscInd->disconnected_node_id));

    /************************************************************************/
    /* If this is our node ID, we have left the conference, tell the CM we  */
    /* are dead.                                                            */
    /************************************************************************/
    if (pDiscInd->disconnected_node_id == m_nidMyself)
    {
        WARNING_OUT(("We have been disconnected from conference"));
        // m_eT120State = T120C_ST_IDLE;
        g_pNCConfMgr->RemoveConference(this);
    }

    DebugExitVOID(DCRNCConference::HandleDisconnectInd);
}


/****************************************************************************/
/* HandleEjectUser - handle a GCC_EJECT_USER_INDICATION message.            */
/****************************************************************************/
void DCRNCConference::
HandleEjectUser ( EjectUserIndicationMessage * pEjectInd )
{
    DebugEntry(DCRNCConference::HandleEjectUser);

    TRACE_OUT(("GCC_EJECT_USER_INDICATION"));
    TRACE_OUT(("Conference ID %ld", pEjectInd->conference_id));
    TRACE_OUT(("Ejected node ID %d", pEjectInd->ejected_node_id));
    TRACE_OUT(("Reason=%u", pEjectInd->reason));

    /************************************************************************/
    /* If the ejected node ID is ours, we have been tossed out of the       */
    /* conference, so tell CM about it.                                     */
    /************************************************************************/
    if (pEjectInd->ejected_node_id == m_nidMyself)
    {
        /********************************************************************/
        /* Reset the conference state first.                                */
        /********************************************************************/
        m_eT120State = T120C_ST_IDLE;

        WARNING_OUT(("We have been thrown out of the conference"));
        g_pNCConfMgr->RemoveConference(this);
    }

    DebugExitVOID(DCRNCConference::HandleEjectUser);
}


/****************************************************************************/
/* HandleInviteConfirm - handle a GCC_INVITE_CONFIRM message.               */
/****************************************************************************/
void DCRNCConference::
HandleInviteConfirm ( InviteConfirmMessage * pInviteConf )
{
    PT120PRODUCTVERSION     pVersion;

    DebugEntry(DCRNCConference::HandleInviteConfirm);

    /************************************************************************/
    /* Map the GCC result onto CONF_RC_ return code.                        */
    /************************************************************************/
    TRACE_OUT(("GCC event: GCC_INVITE_CONFIRM"));
    TRACE_OUT(("Result=%u", pInviteConf->result));

    if (pInviteConf->result == GCC_RESULT_SUCCESSFUL)
    {
        TRACE_OUT(("New node successfully invited into conference"));
        ASSERT((ConnectionHandle)pInviteConf->connection_handle);
    }
    else
    {
        TRACE_OUT(("Error %d inviting new node into conference", pInviteConf->result));
    }

    // Notify the base conference that the invite has completed.
    pVersion = ::GetVersionData(pInviteConf->number_of_user_data_members,
                                pInviteConf->user_data_list);
    InviteComplete(pInviteConf->connection_handle,
                   ::GetGCCResultDetails(pInviteConf->result),
                   pVersion);

    DebugExitVOID(DCRNCConference::HandleInviteConfirm);
}


/****************************************************************************/
/* HandleJoinConfirm - handle a GCC_JOIN_CONFIRM message.                   */
/****************************************************************************/
void DCRNCConference::
HandleJoinConfirm ( JoinConfirmMessage * pJoinConf )
{
    DebugEntry(DCRNCConference::HandleJoinConfirm);

    m_nConfID = pJoinConf->conference_id;

    HRESULT                 hr;
    CLogicalConnection     *pConEntry;
    PT120PRODUCTVERSION     pVersion;

    hr = ::GetGCCResultDetails(pJoinConf->result);

    TRACE_OUT(("GCC event:  GCC_JOIN_CONFIRM"));
    TRACE_OUT(("Result=%u", pJoinConf->result));
    TRACE_OUT(("Conference ID %ld", pJoinConf->conference_id));
    TRACE_OUT(("Locked %d", pJoinConf->conference_is_locked));
    TRACE_OUT(("Listed %d", pJoinConf->conference_is_listed));
    TRACE_OUT(("Conductible %d", pJoinConf->conference_is_conductible));
    TRACE_OUT(("Connection Handle %d", pJoinConf->connection_handle));
    TRACE_OUT(("Termination method %d", pJoinConf->termination_method));

    pVersion = ::GetVersionData(pJoinConf->number_of_user_data_members,
                                pJoinConf->user_data_list);

    // Check the state.
    // If we are not expecting a join confirm at this point, then
    // it is most likely that the connection went down whilst we
    // were waiting for a join confirmation and we are in the middle of
    // telling the user. In this case, just ignore the event.
    if (m_eT120State != T120C_ST_PENDING_JOIN_CONFIRM)
    {
        WARNING_OUT(("Bad state %d, expecting %d",
                    T120C_ST_PENDING_JOIN_CONFIRM,
                    m_eT120State));
        return;
    }
    if (NULL == m_ConnList.PeekHead())
    {
        WARNING_OUT(("Join confirm without a connection"));
        return;
    }
    pConEntry = m_ConnList.PeekHead();
    if ((pConEntry->GetState() != CONF_CON_PENDING_JOIN) &&
        (pConEntry->GetState() != CONF_CON_PENDING_PASSWORD))
    {
        if (pConEntry->GetState() != CONF_CON_ERROR)
        {
            TRACE_OUT(("Join confirm indication ignored"));
        }
        return;
    }
    pConEntry->Grab(); // Grab the pending result to the user.

    pConEntry->SetConnectionHandle(pJoinConf->connection_handle);

    /************************************************************************/
    /* Expected result of our attempt to join a conference.                 */
    /*                                                                      */
    /* If it worked, save the conference ID, otherwise tell the base        */
    /* conference that our attempt to join has failed.                      */
    /************************************************************************/

    // There will always be a pConEntry when a JoinConfirm fires,
    // even if a physical disconnect is racing the JoinConfirm
    // because the physical disconnect handler will cause this code
    // to be entered before the physical connection is destroyed,
    // as this gives the most accurate return codes.
    if (NO_ERROR == hr)
    {
        TRACE_OUT(("Join worked"));
        pConEntry->SetState(CONF_CON_CONNECTED);
        m_nConfID = pJoinConf->conference_id;
    }

    // If the result is an invalid password, then tell the UI
    // so that it can put up an invalid password dialog.
    // The UI is then supposed to either reissue the join request
    // with a new password or end the conference.
    // It is done this way to keep the connection up whilst the
    // user is entering the password, and not re-connect.
    if (UI_RC_INVALID_PASSWORD == hr)
    {
        // Put the conference in the correct state for allowing
        // a second join attempt.
        pConEntry->SetState(CONF_CON_PENDING_PASSWORD);
        m_eT120State = T120C_ST_IDLE;
        m_pbCred = pJoinConf->pb_remote_cred;
        m_cbCred = pJoinConf->cb_remote_cred;

        // Now tell the user about the result.
        g_pCallbackInterface->OnConferenceStarted(this, hr);
    }
    else
    // If the result is an error, then end the conference.
    if (NO_ERROR != hr)
    {
        NotifyConferenceComplete(hr);
    }

    DebugExitVOID(DCRNCConference::HandleJoinConfirm);
}


/****************************************************************************/
/* HandlePermitToAnnounce - handle a GCC_PERMIT_TO_ANNOUNCE_PRESENCE        */
/* message.                                                                 */
/****************************************************************************/
void DCRNCConference::
HandlePermitToAnnounce ( PermitToAnnouncePresenceMessage * pAnnounce )
{
    DebugEntry(DCRNCConference::HandlePermitToAnnounce);

    TRACE_OUT(("GCC event:  GCC_PERMIT_TO_ANNOUNCE_PRESENCE"));
    TRACE_OUT(("Conference ID %ld", pAnnounce->conference_id));
    TRACE_OUT(("Node ID %d", pAnnounce->node_id));

    /************************************************************************/
    /* Store the node ID.                                                   */
    /************************************************************************/
    m_nidMyself = pAnnounce->node_id;

    // See if there is a new local connection that needs publishing in the roster.

    if (! m_ConnList.IsEmpty())
    {
       m_ConnList.PeekHead()->NewLocalAddress();
    }

    /************************************************************************/
    /* Announce our presence in the conference.                             */
    /************************************************************************/
    HRESULT hr = AnnouncePresence();
    if (NO_ERROR == hr)
    {
        m_eT120State = T120C_ST_PENDING_ROSTER_ENTRY;
    }
    else
    {
        ERROR_OUT(("Failed to announce presence in conference, error %d", hr));
        // bugbug: end conference?
    }

    DebugExitVOID(DCRNCConference::HandlePermitToAnnounce);
}


/****************************************************************************/
/* HandleRosterReportInd - handle a GCC_ROSTER_REPORT_INDICATION message.   */
/****************************************************************************/
void DCRNCConference::
HandleRosterReport ( GCCConferenceRoster * pConferenceRoster )
{
    PNC_ROSTER      pRoster;
    UINT            i;
    UINT            numRecords = pConferenceRoster->number_of_records;

    DebugEntry(DCRNCConference::HandleRosterReport);

    TRACE_OUT(("GCC event: GCC_ROSTER_REPORT_INDICATION"));
    TRACE_OUT(("Nodes added ? %d", pConferenceRoster->nodes_were_added));
    TRACE_OUT(("Nodes removed ? %d", pConferenceRoster->nodes_were_removed));
    TRACE_OUT(("Number of records %d", numRecords));

    /************************************************************************/
    /* If we are still setting up the conference, see whether we have       */
    /* appeared in the conference roster.                                   */
    /************************************************************************/
    if (m_eT120State == T120C_ST_PENDING_ROSTER_ENTRY)
    {
        for (i = 0; i < numRecords ; i++)
        {
            if (pConferenceRoster->node_record_list[i]->node_id == m_nidMyself)
            {
                TRACE_OUT(("Found our entry in the roster"));

                // We are in the roster!  The conference has been
                // successfully started so set the state and post
                // a message to continue processing.
                // This is so that callbacks can be made without getting
                // blocked in T120.

                m_eT120State = T120C_ST_PENDING_ROSTER_MESSAGE;
                g_pNCConfMgr->PostWndMsg(NCMSG_FIRST_ROSTER_RECVD, (LPARAM) this);
            }
        }
    }

    /************************************************************************/
    /* If we have successfully started, build an RNC roster from the        */
    /* conference roster and pass it up to the CM.                          */
    /************************************************************************/
    if (m_eT120State == T120C_ST_CONF_STARTED)
    {
        /********************************************************************/
        /* Allocate memory for a roster large enough to hold all the        */
        /* entries.                                                         */
        /********************************************************************/
        DBG_SAVE_FILE_LINE
        pRoster = (PNC_ROSTER) new BYTE[(sizeof(NC_ROSTER) +
                        ((numRecords - 1) * sizeof(NC_ROSTER_NODE_ENTRY)))];
        if (pRoster == NULL)
        {
            ERROR_OUT(("Failed to create new conference roster."));
        }
        else
        {
            pRoster->uNumNodes = numRecords;
            pRoster->uLocalNodeID = m_nidMyself;

            // Add the node details to the roster.
            for (i = 0; i < numRecords ; i++)
            {
                pRoster->nodes[i].uNodeID = pConferenceRoster->node_record_list[i]->node_id;
                pRoster->nodes[i].uSuperiorNodeID = pConferenceRoster->node_record_list[i]->superior_node_id;
                pRoster->nodes[i].fMCU = (pConferenceRoster->node_record_list[i]->node_type == GCC_MCU);
                pRoster->nodes[i].pwszNodeName = pConferenceRoster->node_record_list[i]->node_name;
                pRoster->nodes[i].hUserData = pConferenceRoster->node_record_list[i];
                // If we have been invited into the conference, then the CLogicalConnection
                // list maintained by the conference will not have our superior node's UserID,
                // so we need to fill that in here.
                if (pRoster->nodes[i].uNodeID == pRoster->uLocalNodeID &&
                    pRoster->nodes[i].uSuperiorNodeID != 0)
                {
                    // We do have a superior node, so find its CLogicalConnection and fill in the
                    // UserID.  It turns out that the UserIDs of subordinate nodes are filled in
                    // by another mechanism, so the superior node should be the only entry with
                    // zero for a UserID.
#ifdef DEBUG
                    int nSuperiorNode = 0;
#endif
                    CLogicalConnection * pConEntry;
                    m_ConnList.Reset();
                    while (NULL != (pConEntry = m_ConnList.Iterate()))
                    {
                        if (pConEntry->GetConnectionNodeID() == 0)
                        {
                            pConEntry->SetConnectionNodeID((GCCNodeID)pRoster->nodes[i].uSuperiorNodeID);
#ifdef DEBUG
                            nSuperiorNode++;
#else
                            break;
#endif
                        }
                    }
                    ASSERT (nSuperiorNode <= 1);
                }
            }
            NotifyRosterChanged(pRoster);
            delete [] pRoster;
        }
    }

    DebugExitVOID(DCRNCConference::HandleRosterReport);
}


/****************************************************************************/
/* HandleTerminateConfirm - handle a GCC_TERMINATE_CONFIRM message.         */
/****************************************************************************/
void DCRNCConference::
HandleTerminateConfirm ( TerminateConfirmMessage * pTermConf )
{
    DebugEntry(DCRNCConference::HandleTerminateConfirm);

    /************************************************************************/
    /* Check the state                                                      */
    /************************************************************************/
    if (m_eT120State != T120C_ST_PENDING_TERMINATE)
    {
        WARNING_OUT(("Bad state: unexpected terminate confirm")); // Go ahead anyway
    }

    /************************************************************************/
    /* Map the GCC result onto CONF_RC_ return code.                        */
    /************************************************************************/
    TRACE_OUT(("GCC event: GCC_TERMINATE_CONFIRM"));
    TRACE_OUT(("Result=%u", pTermConf->result));
    TRACE_OUT(("Conference ID %d", pTermConf->conference_id));

    /************************************************************************/
    /* If the request failed, reset our state and tell the FE?              */
    /************************************************************************/
    if (pTermConf->result != GCC_RESULT_SUCCESSFUL)
    {
        ERROR_OUT(("Error %d attempting to terminate conference", pTermConf->result));
        m_eT120State = T120C_ST_CONF_STARTED;
    }

    /************************************************************************/
    /* Our request to end the conference has worked - wait for the          */
    /* termination indication before telling the FE that we have died.      */
    /************************************************************************/

    DebugExitVOID(DCRNCConference::HandleTerminateConfirm);
}


/****************************************************************************/
/* HandleTerminateInd - handle a GCC_TERMINATE_INDICATION message.          */
/****************************************************************************/
void DCRNCConference::
HandleTerminateInd ( TerminateIndicationMessage * pTermInd )
{
    DebugEntry(DCRNCConference::HandleTerminateInd);

    TRACE_OUT(("GCC event: GCC_TERMINATE_INDICATION"));
    TRACE_OUT(("Conference ID %d", pTermInd->conference_id));
    TRACE_OUT(("Requesting node ID %d", pTermInd->requesting_node_id));
    TRACE_OUT(("Reason=%u", pTermInd->reason));

    /************************************************************************/
    /* The conference has ended beneath us.  Reset our internal state and   */
    /* tell the base conference about it.                                   */
    /************************************************************************/
    m_eT120State = T120C_ST_IDLE;
    g_pNCConfMgr->RemoveConference(this);

    DebugExitVOID(DCRNCConference::HandleTerminateInd);
}


HRESULT DCRNCConference::
RefreshRoster(void)
{
    DebugEntry(DCRNCConference::RefreshRoster);

    // Check the state.
    if (m_eT120State != T120C_ST_CONF_STARTED)
    {
        ERROR_OUT(("Bad state: refresh roster requested before conference up"));
        return(UI_RC_CONFERENCE_NOT_READY);
    }

    // Issue the request
    GCCError GCCrc = g_pIT120ControlSap->ConfRosterInqRequest(m_nConfID); // Conference ID

    // Handle the result
    HRESULT hr = ::GetGCCRCDetails(GCCrc);
    TRACE_OUT(("GCC call: g_pIT120ControlSap->ConfRosterInqRequest, rc=%d", GCCrc));

    DebugExitHRESULT(DCRNCConference::RefreshRoster, hr);
    return hr;
}


/****************************************************************************/
/* Invite() - see erncgccc.hpp                                              */
/****************************************************************************/
HRESULT DCRNCConference::
T120Invite
(
    LPSTR               pszNodeAddress,
    BOOL                fSecure,
    CNCUserDataList     *pUserDataInfoList,
    ConnectionHandle    *phInviteReqConn
)
{
    GCCError            GCCrc = GCC_NO_ERROR;
    HRESULT             hr;
    UINT                nUserDataRecords = 0;
    GCCUserData       **ppInfoUserData = NULL;
    UINT                nData;
    PVOID               pData;
    char                szAddress[RNC_MAX_NODE_STRING_LEN];

    DebugEntry(DCRNCConference::T120Invite);

    ASSERT(phInviteReqConn != NULL);

    /************************************************************************/
    /* Check the state.                                                     */
    /************************************************************************/
    if (m_eT120State != T120C_ST_CONF_STARTED)
    {
        ERROR_OUT(("Bad state: refresh roster requested before conference up"));
        return(UI_RC_CONFERENCE_NOT_READY);
    }

    /************************************************************************/
    /* Build the address from the node details.                             */
    /************************************************************************/
    ::BuildAddressFromNodeDetails(pszNodeAddress, &szAddress[0]);

    /************************************************************************/
    /* Invite the specified node into the conference.                       */
    /************************************************************************/
    LPWSTR pwszNodeName;

    // If there is any user data to be sent
    if (pUserDataInfoList)
    {
        // Add versioning data
        if (NO_ERROR == ::GetUserData(g_nVersionRecords, g_ppVersionUserData, &g_csguidVerInfo, &nData, &pData))
        {
            pUserDataInfoList->AddUserData(&g_csguidVerInfo, nData, pData);
        }

        pUserDataInfoList->GetUserDataList(&nUserDataRecords,&ppInfoUserData);
    }
    else
    {
        ppInfoUserData = g_ppVersionUserData;
        nUserDataRecords = g_nVersionRecords;
    }

    if (NULL != (pwszNodeName = ::GetNodeName()))
    {
        GCCrc = g_pIT120ControlSap->ConfInviteRequest(
                    m_nConfID,
                    pwszNodeName,                   // caller_identifier
                    NULL,                           // calling_address
                    &szAddress[0],                  // called_address
                    fSecure,                        // secure connection?
                    nUserDataRecords,               // number_of_user_data_members
                    ppInfoUserData,                 // user_data_list
                    phInviteReqConn                 // returned connection_handle
                    );

        hr = ::GetGCCRCDetails(GCCrc);
        TRACE_OUT(("GCC call: g_pIT120ControlSap->ConfInviteRequest, rc=%d", GCCrc));
        TRACE_OUT(("Transport handle %d", (UINT) *phInviteReqConn));
        TRACE_OUT(("Called address '%s'", &szAddress[0]));
        delete pwszNodeName;
    }
    else
    {
        hr = UI_RC_OUT_OF_MEMORY;
    }

    DebugExitHRESULT(DCRNCConference::T120Invite, hr);
    return hr;
}


/****************************************************************************/
/* Terminate() - see erncgccc.hpp                                           */
/****************************************************************************/
#if 0 // LONCHANC
HRESULT DCRNCConference::
Terminate(void)
{
    DebugEntry(DCRNCConference::Terminate);

    /************************************************************************/
    /* Request to terminate the conference.                                 */
    /************************************************************************/
    GCCError GCCrc = ::GCCConferenceTerminateRequest(m_nConfID, GCC_REASON_USER_INITIATED);
    HRESULT hr = ::GetGCCRCDetails(GCCrc);
    TRACE_OUT(("GCC call:  GCCConferenceTerminateRequest, rc=%d", GCCrc));
    if (NO_ERROR == hr)
    {
        // Set the state to show we are about to die.
        m_eT120State = T120C_ST_PENDING_TERMINATE;
    }
    else
    {
        ERROR_OUT(("Failed to terminate conference, GCC error %d", GCCrc));
    }

    DebugExitHRESULT(DCRNCConference::Terminate, hr);
    return hr;
}
#endif // 0


/****************************************************************************/
/* SendText() - see erncgccc.hpp                                               */
/****************************************************************************/
#if 0 // LONCHANC: not used
HRESULT DCRNCConference::
SendText
(
    LPWSTR          pwszTextMsg,
    GCCNodeID       node_id
)
{
    DebugEntry(DCRNCConference::SendText);

    /************************************************************************/
    /* Request to send text to node in the conference.                      */
    /************************************************************************/
    GCCError GCCrc = ::GCCTextMessageRequest(m_nConfID, pwszTextMsg, node_id);
    HRESULT hr = ::GetGCCRCDetails(GCCrc);
    TRACE_OUT(("GCC call:  GCCTextMessageRequest, rc=%d", GCCrc));
    if (NO_ERROR != hr)
    {
        ERROR_OUT(("Failed to send text to user, GCC error %d", GCCrc));
    }

    DebugExitHRESULT(DCRNCConference::SendText, hr);
    return hr;
}
#endif // 0


#if 0 // LONCHANC: not used
HRESULT DCRNCConference::
TimeRemaining
(
    UINT            nTimeRemaining,
    GCCNodeID       nidDestination
)
{
    DebugEntry(DCRNCConference::TimeRemaining);

    /************************************************************************/
    /* Request remaining time of the conference                             */
    /************************************************************************/
    GCCError GCCrc = g_pIT120ControlSap->ConfTimeRemainingRequest(m_nConfID, nTimeRemaining, nidDestination);
    HRESULT hr = ::GetGCCRCDetails(GCCrc);
    TRACE_OUT(("GCC call:  g_pIT120ControlSap->ConfTimeRemainingRequest, rc=%d", GCCrc));
    if (NO_ERROR != hr)
    {
        ERROR_OUT(("Failed to send the time remaining to user, GCC error %d", GCCrc));
    }

    DebugExitHRESULT(DCRNCConference::TimeRemaining, hr);
    return hr;
}
#endif // 0


/****************************************************************************/
/* Join() - see erncgccc.hpp                                                */
/****************************************************************************/
HRESULT DCRNCConference::
T120Join
(
    LPSTR               pszNodeAddress,
    BOOL                fSecure,
    LPCWSTR             conferenceName,
    CNCUserDataList    *pUserDataInfoList,
    LPCWSTR             wszPassword
//    REQUEST_HANDLE      *phRequest
)
{
    GCCError                        GCCrc = GCC_NO_ERROR;
    HRESULT                         hr = NO_ERROR;
    ConnectionHandle                connectionHandle = 0;
    GCCChallengeRequestResponse     Password_Challenge;
    GCCChallengeRequestResponse    *pPassword_Challenge = NULL;
    Password_Challenge.u.password_in_the_clear.numeric_string = NULL;

    UINT                            nUserDataRecords = 0;
    GCCUserData                   **ppInfoUserData = NULL;
    UINT                            nData;
    LPVOID                          pData;

    char                            szAddress[RNC_MAX_NODE_STRING_LEN];

    DebugEntry(DCRNCConference::T120Join);

    /************************************************************************/
    /* Check the state                                                      */
    /************************************************************************/
    ASSERT(m_eT120State == T120C_ST_IDLE);

    /************************************************************************/
    /* Build the address from the node details.                             */
    /************************************************************************/
    ::BuildAddressFromNodeDetails(pszNodeAddress, &szAddress[0]);

    // Set up password rubbish
    if (! ::IsEmptyStringW(wszPassword))
    {
        pPassword_Challenge = & Password_Challenge;
        Password_Challenge.password_challenge_type = GCC_PASSWORD_IN_THE_CLEAR;
        hr = ::GetGCCFromUnicode(wszPassword,
                                 &Password_Challenge.u.password_in_the_clear.numeric_string,
                                 &Password_Challenge.u.password_in_the_clear.text_string);
    }

    if (NO_ERROR == hr)
    {
        LPWSTR pwszNodeName;
        if (NULL != (pwszNodeName = ::GetNodeName()))
        {
            // Do not specify a numeric and text name when trying
            // to join a conference because if a numeric name was
            // autogenerated, rather than specified by the user,
            // then it will not be correct on the node being joined.
            // Consequently, remove the numeric name from the request
            // and rediscover it, if needed, from the GCC_JOIN_CONFIRM indication
            // (this is not currently done).
            if ((m_ConfName.numeric_string != NULL) && (m_ConfName.text_string != NULL))
            {
                delete m_ConfName.numeric_string;
                m_ConfName.numeric_string = NULL;
            }

            // If there is any user data to be sent
            if (pUserDataInfoList)
            {
                // Add versioning data
                if (NO_ERROR == ::GetUserData(g_nVersionRecords, g_ppVersionUserData, &g_csguidVerInfo, &nData, &pData))
                {
                    pUserDataInfoList->AddUserData(&g_csguidVerInfo, nData, pData);
                }

                pUserDataInfoList->GetUserDataList(&nUserDataRecords,&ppInfoUserData);
            }
            else
            {
                ppInfoUserData = g_ppVersionUserData;
                nUserDataRecords = g_nVersionRecords;
            }

            GCCrc = g_pIT120ControlSap->ConfJoinRequest(&m_ConfName,
                            NULL,                           // called_node_modifier
                            NULL,                           // calling_node_modifier
                            NULL,                           // convener_password
                            pPassword_Challenge,            // password_challenge
                            pwszNodeName,                   // caller_identifier
                            NULL,                           // calling_address
                            &szAddress[0],                  // called_address
                            fSecure,
                            NULL,                           // domain_parameters
                            0,                              // number_of_network_addresses
                            NULL,                           // local_network_address_list
                            nUserDataRecords,               // number_of_user_data_members
                            ppInfoUserData,                 // user_data_list
                            &connectionHandle,              // connection_handle
                            &m_nConfID
                            );
            delete pwszNodeName;
            hr = ::GetGCCRCDetails(GCCrc);
            TRACE_OUT(("GCC call:  g_pIT120ControlSap->ConfJoinRequest, rc=%d", GCCrc));
            TRACE_OUT(("Called address '%s'", &szAddress[0]));
            if (NO_ERROR == hr)
            {
                m_eT120State = T120C_ST_PENDING_JOIN_CONFIRM;
            }
        }
        else
        {
            hr = UI_RC_OUT_OF_MEMORY;
        }
    }
    delete Password_Challenge.u.password_in_the_clear.numeric_string;

    DebugExitHRESULT(DCRNCConference::T120Join, hr);
    return hr;
}

/****************************************************************************/
/* StartLocal() - see erncgccc.hpp                                          */
/****************************************************************************/
HRESULT DCRNCConference::
T120StartLocal(BOOL fSecure)
{
    GCCError                GCCrc;
    HRESULT                 hr;
    ConnectionHandle        hConnection = 0;
    GCCConferencePrivileges priv = {1,1,1,1,1};
    WCHAR                   pwszRDS[] = RDS_CONFERENCE_DESCRIPTOR;

    DebugEntry(DCRNCConference::T120StartLocal);

    /************************************************************************/
    /* Call GCC_Conference_Create_Request and wait for the confirmation     */
    /* event.                                                               */
    /************************************************************************/
    GCCConfCreateRequest ccr;
    ::ZeroMemory(&ccr, sizeof(ccr));
    ccr.Core.conference_name = &m_ConfName;
    // ccr.Core.conference_modifier = NULL;
    // ccr.Core.use_password_in_the_clear = 0;
    // ccr.Core.conference_is_locked = 0;
    ccr.Core.conference_is_listed = 1;
    // ccr.Core.conference_is_conductible = 0;
    ccr.Core.termination_method = GCC_MANUAL_TERMINATION_METHOD;
    ccr.Core.conduct_privilege_list = &priv; // Conductor priveleges
    ccr.Core.conduct_mode_privilege_list = &priv; // Member priveleges in conducted conference
    ccr.Core.non_conduct_privilege_list = &priv; // Member priveleges in non-conducted conference

    // ccr.Core.pwszConfDescriptor = NULL;
    OSVERSIONINFO           osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (FALSE == ::GetVersionEx (&osvi))
    {
        ERROR_OUT(("GetVersionEx() failed!"));
    }

    if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && g_bRDS)
    {
    	ccr.Core.pwszConfDescriptor = pwszRDS;
    }
    // ccr.Core.pwszCallerID = NULL;
    // ccr.Core.calling_address = NULL;
    // ccr.Core.called_address = NULL;
    // ccr.Core.domain_parameters = NULL;
    // ccr.Core.number_of_network_addresses = 0;
    // ccr.Core.network_address_list = NULL;
    ccr.Core.connection_handle = &hConnection;
    // ccr.convener_password = NULL;
    // ccr.password = NULL;
    // ccr.number_of_user_data_members = 0;
    // ccr.user_data_list = NULL;
    ccr.fSecure = fSecure;

    GCCrc = g_pIT120ControlSap->ConfCreateRequest(&ccr, &m_nConfID);

    hr = ::GetGCCRCDetails(GCCrc);
    TRACE_OUT(("GCC call: g_pIT120ControlSap->ConfCreateRequest"));
    TRACE_OUT(("LOCAL CONFERENCE"));
    TRACE_OUT(("Connection handle %d", (UINT) hConnection));

    /************************************************************************/
    /* Map the GCC return code to a conference return code.                 */
    /************************************************************************/
    if (NO_ERROR == hr)
    {
        // Set the state.
        m_eT120State = T120C_ST_PENDING_START_CONFIRM;
    }
    else
    {
        ERROR_OUT(("GCC Error %d starting local conference", GCCrc));
    }

    DebugExitHRESULT(DCRNCConference::T120StartLocal, hr);
    return hr;
}


// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
/****************************************************************************/
/* StartRemote() - see erncgccc.hpp                                         */
/****************************************************************************/
HRESULT DCRNCConference::
T120StartRemote ( LPSTR pszNodeAddress )
{
    // Do not allow attempts to create T120 conferences on remote nodes.
    // The code that was written to do this is left here in case someone
    // wants to resurrect this functionality in the future.
    GCCError                GCCrc;
    HRESULT                 hr;
    ConnectionHandle        connectionHandle = 0;
    GCCConferencePrivileges priv = {1,1,1,1,1};
    char                    szAddress[RNC_MAX_NODE_STRING_LEN];

    DebugEntry(DCRNCConference::T120StartRemote);

    /************************************************************************/
    /* Build the address from the node details.                             */
    /************************************************************************/
    ::BuildAddressFromNodeDetails(pszNodeAddress, &szAddress[0]);

    /************************************************************************/
    /* Call GCC_Conference_Create_Request and wait for the confirmation     */
    /* event.                                                               */
    /************************************************************************/
    TRACE_OUT(("Starting New Remote Conference..."));

    /************************************************************************/
    /* Call GCC_Conference_Create_Request and wait for the confirmation     */
    /* event.                                                               */
    /************************************************************************/
    GCCConfCreateRequest ccr;
    ::ZeroMemory(&ccr, sizeof(ccr));
    ccr.Core.conference_name = &m_ConfName;
    ccr.Core.conference_modifier = NULL;
    // ccr.Core.use_password_in_the_clear = 0;
    // ccr.Core.conference_is_locked = 0;
    ccr.Core.conference_is_listed = 1;
    ccr.Core.conference_is_conductible = 1;
    ccr.Core.termination_method = GCC_AUTOMATIC_TERMINATION_METHOD;
    ccr.Core.conduct_privilege_list = &priv; // Conductor priveleges
    ccr.Core.conduct_mode_privilege_list = &priv; // Member priveleges in conducted conference
    ccr.Core.non_conduct_privilege_list = &priv; // Member priveleges in non-conducted conference
    // ccr.Core.pwszConfDescriptor = NULL;
    // ccr.Core.pwszCallerID = NULL;
    // ccr.Core.calling_address = NULL;
    ccr.Core.called_address = &szAddress[0];
    // ccr.Core.domain_parameters = NULL;
    // ccr.Core.number_of_network_addresses = 0;
    // ccr.Core.network_address_list = NULL;
    ccr.Core.connection_handle = &connectionHandle;
    // ccr.convener_password = NULL;
    // ccr.password = NULL;
    // ccr.number_of_user_data_members = 0;
    // ccr.user_data_list = NULL;

    GCCrc = g_pIT120ControlSap->ConfCreateRequest(&ccr, &m_nConfID);

    hr = ::GetGCCRCDetails(GCCrc);
    TRACE_OUT(("GCC call: g_pIT120ControlSap->ConfCreateRequest"));
    TRACE_OUT(("Called address '%s'", &szAddress[0]));
    TRACE_OUT(("Connection handle %d", connectionHandle));

    /************************************************************************/
    /* Map the GCC return code to a conference return code.                 */
    /************************************************************************/
    if (NO_ERROR != hr)
    {
        ERROR_OUT(("GCC Error %d starting local conference", GCCrc));
    }
    else
    {
        // Set the state.
        m_eT120State = T120C_ST_PENDING_START_CONFIRM;
    }

    DebugExitHRESULT(DCRNCConference::T120StartRemote, hr);
    return hr;
}
#endif // ENABLE_START_REMOTE


void LoadAnnouncePresenceParameters
(
    GCCNodeType         *nodeType,
    GCCNodeProperties   *nodeProperties,
    LPWSTR              *ppwszNodeName,
    LPWSTR              *ppwszSiteInformation
)
{
    DebugEntry(LoadAnnouncePresenceParameters);

    /*     The following key does not currently exist.
     *    If we ever decide to use it, we should un-comment this call
     *    and following calls in this function, designed to access the
     *    registry entries under this key.
     *    Some of the rest of the registry calls are under #if 0, #else, #endif
     *    clauses.
     */
#if 0
    RegEntry    ConferenceKey(DATA_CONFERENCING_KEY, HKEY_LOCAL_MACHINE);
#endif  // 0

    // Get the type of node controller.

    if (nodeType)
    {
#if 0
        *nodeType = ConferenceKey.GetNumber(REGVAL_NODE_CONTROLLER_MODE, GCC_MULTIPORT_TERMINAL);
#else  // 0
        *nodeType = GCC_MULTIPORT_TERMINAL;
#endif  // 0
        TRACE_OUT(("Node type %d", *nodeType));
    }

    // Load the node properties.

    if (nodeProperties)
    {
#if 0
        *nodeProperties = ConferenceKey.GetNumber(REGVAL_NODE_CONTROLLER_PROPERTY,
                                        GCC_NEITHER_PERIPHERAL_NOR_MANAGEMENT);
#else  // 0
        *nodeProperties = GCC_NEITHER_PERIPHERAL_NOR_MANAGEMENT;
#endif  // 0
        TRACE_OUT(("Node properties %d", *nodeProperties));
    }

    // Get site information.
    // Ignore if no site info.
#if 0
    if (ppwszSiteInformation)
    {
        *ppwszSiteInformation = ::AnsiToUnicode(ConferenceKey.GetString(REGVAL_NODE_CONTROLLER_SITE_INFO));
    }
#endif  // 0

    if (ppwszNodeName)
    {
        // Rely upon GetNodeName returning NULL pointer if error.
        // Note that successful if got this, so no need to free on error.
        *ppwszNodeName = ::GetNodeName();
    }

    DebugExitVOID(LoadAnnouncePresenceParameters);
}


/****************************************************************************/
/* Build the address from the node details.                                 */
/****************************************************************************/
void BuildAddressFromNodeDetails
(
    LPSTR           pszNodeAddress,
    LPSTR           pszDstAddress
)
{
    DebugEntry(BuildAddressFromNodeDetails);

    /************************************************************************/
    /* GCC address take the form <transport type>:address.                  */
    /************************************************************************/
    TRACE_OUT(("BuildAddressFromNodeDetails:: TCP address '%s'", pszNodeAddress));

    /************************************************************************/
    /* Add the prefix for this transport type.                              */
    /************************************************************************/
    /************************************************************************/
    /* Add the separator followed by the actual address.                    */
    /************************************************************************/
    ::lstrcpyA(pszDstAddress, RNC_GCC_TRANSPORT_AND_SEPARATOR);
    ::lstrcatA(pszDstAddress, pszNodeAddress);

    DebugExitVOID(BuildAddressFromNodeDetails);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\ernctrc.h ===
/****************************************************************************/
/*                                                                          */
/* ERNCTRC.H                                                                */
/*                                                                          */
/* RNC trace macros.                                                        */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  16Jun95 NFC             Created.                                        */
/*  31Aug95 NFC             Removed TAB from TRC_MOD_FMT                    */
/*                                                                          */
/****************************************************************************/

#ifndef __ERNCTRC_H_
#define __ERNCTRC_H_

/****************************************************************************/
/* Trace macros - nicked from atrcapi.h.                                    */
/****************************************************************************/
/****************************************************************************/
/* Defines for the formats for printing the various parts of the trace      */
/* lines.                                                                   */
/*                                                                          */
/* TIME     is time in the form hours,mins,secs,100ths                      */
/* DATE     is the date in the form day,month,year                          */
/* MOD      is the module procedure name                                    */
/* LINE     is the line number within the source file                       */
/* TASK     is the task identifier                                          */
/* REG      is a machine level register                                     */
/****************************************************************************/
#define TRC_TIME_FMT "%02d:%02d:%02d.%02d"
#define TRC_DATE_FMT "%02d/%02d/%02d"
#define TRC_MOD_FMT  "%-12.12s"
#define TRC_LINE_FMT "%04d"
#define TRC_TASK_FMT "%04.4x"
#define TRC_REG_FMT "%04.4x"

/****************************************************************************/
/* Define various trace levels.                                             */
/****************************************************************************/
#define TRC_LEVEL_DEBUG     0
#define TRC_LEVEL           1
#define TRC_LEVEL_ALRT      2
#define TRC_LEVEL_EVT_DATA  3
#define TRC_LEVEL_RNC       4
#define TRC_LEVEL_ERROR     5

#ifdef TRACE_FILE
#define _file_name_ (char near *)__filename
static const char near __filename[] = TRACE_FILE;
#else
#define _file_name_ (char near *)__FILE__
#endif /* TRACE_FILE */

#define TRACE_FN(A)

#ifdef DEBUG
#define TRACE_GCC_RESULT(result,text)
#else
#define TRACE_GCC_RESULT(result,text)
#endif


#ifdef DEBUG
extern HDBGZONE ghZoneErn;

#define TRACEX(_tlvl, s)                                               \
    {                                                                  \
      if (GETZONEMASK(ghZoneErn) & (1<<_tlvl))                         \
      {                                                                \
          CHAR _szTrc[256];                                            \
          wsprintf s;                                                  \
		  DbgZPrintf(ghZoneErn, _tlvl, _szTrc);                        \
      }                                                                \
    }

#else
#define TRACEX(x,y)
#endif

/****************************************************************************/
/* PROTOTYPES                                                               */
/****************************************************************************/
#ifdef DEBUG
void RNCTrcOutput(UINT     trclvl,
                  LPSTR    trcmod,
                  UINT     line,
                  LPSTR    trcstr);
#endif /* ifdef DEBUG */

#endif /*__ERNCTRC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\erncvrsn.hpp ===
#ifndef	ERNCVRSN_INC
#define	ERNCVRSN_INC

/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1995-1996                    **/
/***************************************************************************/


/****************************************************************************

erncvrsn.hpp

Jun. 96		LenS

Versioning information.
Main information is in NCUI.H.

****************************************************************************/

#include "cuserdta.hpp"
#include <inodecnt.h>

// Don't accept builds before 1133.
#define VER_EARLIEST_COMPATIBLE_DW  DWVERSION_NM_1

// If we ever want to recommend an upgrade of 1.0 or 2.0, we need to set this
// difference number accordingly.
#define VER_MAX_DIFFERENCE    (DWVERSION_NM_CURRENT - DWVERSION_NM_1)

extern GUID                 g_csguidVerInfo;
extern UINT                 g_nVersionRecords;
extern GCCUserData **       g_ppVersionUserData;

HRESULT InitOurVersion(void);
BOOL TimeExpired(DWORD dwTime);
PT120PRODUCTVERSION GetVersionData(UINT nRecords, GCCUserData **ppUserData);
void ReleaseOurVersion(void);

#endif // #ifndef	ERNCVRSN_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\events.cpp ===
#include "precomp.h"
#include "events.hpp"
#include "ernccm.hpp"
#include "erncconf.hpp"
#include "erncvrsn.hpp"
#include "nccglbl.hpp"

extern PController  g_pMCSController;
GUID g_csguidSecurity = GUID_SECURITY;

CWorkItem::~CWorkItem(void) { } // pure virtual
BOOL GetSecurityInfo(ConnectionHandle connection_handle, PBYTE pInfo, PDWORD pcbInfo);


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Implementation of Methods for CInviteIndWork
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


CInviteIndWork::
CInviteIndWork
(
    PCONFERENCE             _pConference,
    LPCWSTR                 _wszCallerID,
    PT120PRODUCTVERSION     _pRequestorVersion,
    GCCUserData             **_ppUserData,
    UINT                    _nUserData,
    CLogicalConnection        * _pConEntry
)
:
    CWorkItem(_pConference),
    m_pConf(_pConference),
    m_pRequestorVersion(_pRequestorVersion),
    m_nUserData(_nUserData),
    m_fSecure(_pConEntry->IsConnectionSecure())
{
    DebugEntry(CInviteIndWork::CInviteIndWork);

    // If there is version information, then take a copy of it
    // as this is going asynchronous.
    if (m_pRequestorVersion)
    {
        m_RequestorVersion = *m_pRequestorVersion;
    }

    // Take copy of caller ID.
    // Note memory allocation failure proceeds with NULL ID.
    m_pwszCallerID = ::My_strdupW(_wszCallerID);

    // Create the user data list for the ui
    if(_nUserData)
    {
        DBG_SAVE_FILE_LINE
        m_pUserDataList = new USERDATAINFO[_nUserData];
        if (NULL != m_pUserDataList)
        {
            for (UINT i = 0; i < m_nUserData; i++)
            {
                if ((*_ppUserData)->octet_string->length < sizeof(GUID))
                {
                    // skip this user data
                    i--;
                    m_nUserData--;
                    _ppUserData++;
                    continue;
                }

                m_pUserDataList[i].pGUID = (GUID*)(*_ppUserData)->octet_string->value;
                m_pUserDataList[i].pData = (*_ppUserData)->octet_string->value + sizeof(GUID);
                m_pUserDataList[i].cbData = (*_ppUserData)->octet_string->length - sizeof(GUID);

                // Verify security data
                if (0 == CompareGuid(m_pUserDataList[i].pGUID, &g_csguidSecurity)) {

                    // Check data against transport level
                    PBYTE pbData = NULL;
                    DWORD cbData = 0;
                    BOOL fTrust = FALSE;

                    if (m_pUserDataList[i].cbData != 0 && GetSecurityInfo(_pConEntry->GetConnectionHandle(),NULL,&cbData)) {
                        if (cbData) {
                            // We are directly connected, so verify the information
                            pbData = new BYTE[cbData];
                            if (NULL != pbData) {
                                GetSecurityInfo(_pConEntry->GetConnectionHandle(),pbData,&cbData);
                                if ( m_pUserDataList[i].cbData != cbData ||
                                    memcmp(pbData, m_pUserDataList[i].pData,
                                                                    cbData)) {

                                    WARNING_OUT(("SECURITY MISMATCH: (%s) vs (%s)", pbData, m_pUserDataList[i].pData));
                                }
                                else {
                                    // Verification OK
                                    fTrust = TRUE;
                                }
                                delete [] pbData;
                            }
                            else {
                                ERROR_OUT(("Failed to alloc %d bytes for security data verification", cbData));
                            }
                        }
                    }

                    if (FALSE == fTrust) {
                        // Leave the security GUID in place, but NULL out the data to signal distrust.
                        WARNING_OUT(("CInviteIndWork: Nulling out security"));
                        m_pUserDataList[i].pData = NULL;
                        m_pUserDataList[i].cbData = 0;
                    }
                }

                
                _ppUserData++;
            }
        }
        else
        {
            ERROR_OUT(("CInviteIndWork::CInviteIndWork: Out of memory"));
            m_nUserData = 0;
        }
    }
    else
    {
        m_pUserDataList = NULL;
    }

    DebugExitVOID(CInviteIndWork::CInviteIndWork);
}


CInviteIndWork::
~CInviteIndWork(void)
{
    DebugEntry(CInviteIndWork::~CInviteIndWork);

    //
    // If we substituted transport security data for roster data,
    // free that buffer now
    //

    delete m_pwszCallerID;
    delete [] m_pUserDataList;

    DebugExitVOID(CInviteIndWork::~CInviteIndWork);
}


void CInviteIndWork::
DoWork(void)
{
    DebugEntry(CInviteIndWork::DoWork);

    // Now we are actually processing the invite, validate that there
    // are no other conferences of the same name, and, if not, block
    // a conference of the same name by setting the conference to be active,
    // and give invite request up to the UI.
    PCONFERENCE pOtherConf = g_pNCConfMgr->GetConferenceFromName(m_pConf->GetName());
    if (NULL == pOtherConf)
    {
        m_pConf->SetNotifyToDo(TRUE);
        g_pCallbackInterface->OnIncomingInviteRequest((CONF_HANDLE) m_pConf,
                                                      GetCallerID(),
                                                      m_pRequestorVersion,
                                                      m_pUserDataList,
                                                      m_nUserData,
                                                      m_fSecure);
    }
    else
    {
        m_pConf->InviteResponse(UI_RC_CONFERENCE_ALREADY_EXISTS);
    }

    DebugExitVOID(CInviteIndWork::DoWork);
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Implementation of Methods for CJoinIndWork
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


CJoinIndWork::
CJoinIndWork
(
    GCCResponseTag         Tag,
    PCONFERENCE            _pConference,
    LPCWSTR                _wszCallerID,
    CLogicalConnection    *_pConEntry,
    PT120PRODUCTVERSION    _pRequestorVersion,
    UINT                   _nUserData,
    GCCUserData          **_ppUserData,
    HRESULT               *pRetCode
)
:
    CWorkItem(_pConference),
    m_nResponseTag(Tag),
    m_pConf(_pConference),
    m_pConEntry(_pConEntry),
    m_pRequestorVersion(_pRequestorVersion),
    m_nUserData(_nUserData),
    m_pUserDataList(NULL),
    m_ppUserData(NULL)
{
    DebugEntry(CJoinIndWork::CJoinIndWork);

    *pRetCode = NO_ERROR;

#ifdef DEBUG
    SOCKET socket_number;
    g_pMCSController->FindSocketNumber(m_pConEntry->GetConnectionHandle(),&socket_number);
#endif
    // If there is version information, then take a copy of it
    // as this is going asynchronous.
    if (m_pRequestorVersion)
    {
        m_RequestorVersion = *m_pRequestorVersion;
    }

    // Take copy of caller ID because T120 
    // implementation is not keeping its copy valid
    // until the join response.
    // Note that memory allocation failure proceeds with 
    // NULL caller ID.
    m_pwszCallerID = ::My_strdupW(_wszCallerID);

    // Add the user data list for forwarded join requests and the UI.
    if (m_nUserData && NULL != _ppUserData)
    {
        DBG_SAVE_FILE_LINE
        m_pUserDataList = new USERDATAINFO[m_nUserData];
        if (NULL != m_pUserDataList)
        {
            ::ZeroMemory(m_pUserDataList, sizeof(USERDATAINFO) * m_nUserData);

            DBG_SAVE_FILE_LINE
            m_ppUserData = new GCCUserData * [m_nUserData];
            if (NULL != m_ppUserData)
            {
                ::ZeroMemory(m_ppUserData, sizeof(GCCUserData *) * m_nUserData);

                for (UINT i = 0; i < m_nUserData; i++)
                {
                    // Calculate the total size to allocate for this entry.
                    UINT cbUserDataStructSize = ROUNDTOBOUNDARY(sizeof(GCCUserData));
                    UINT cbNonStdIDSize = ROUNDTOBOUNDARY((* _ppUserData)->key.h221_non_standard_id.length);
                    UINT cbOctetStringSize = ROUNDTOBOUNDARY((* _ppUserData)->octet_string->length);
                    UINT cbTotalSize = cbUserDataStructSize + cbNonStdIDSize + sizeof(OSTR) + cbOctetStringSize;

                    // Allocate a single memory buffer
                    DBG_SAVE_FILE_LINE
                    LPBYTE pData = new BYTE[cbTotalSize];
                    if (NULL != pData)
                    {
                        // Set up pointers
                        GCCUserData *pUserData = (GCCUserData *) pData;
                        ::ZeroMemory(pUserData, sizeof(GCCUserData));
                        pUserData->key.h221_non_standard_id.value = (LPBYTE) (pData + cbUserDataStructSize);
                        pUserData->octet_string = (LPOSTR) (pData + cbUserDataStructSize + cbNonStdIDSize);
                        pUserData->octet_string->value = ((LPBYTE) pUserData->octet_string) + sizeof(OSTR);

                        // Copy user data to prevent it from being lost when callback message is freed.
                        m_ppUserData[i] = pUserData;

                        // Copy key
                        pUserData->key.key_type = (* _ppUserData)->key.key_type;
                        ASSERT(pUserData->key.key_type == GCC_H221_NONSTANDARD_KEY);
                        pUserData->key.h221_non_standard_id.length = (* _ppUserData)->key.h221_non_standard_id.length; 
                        ::CopyMemory(pUserData->key.h221_non_standard_id.value,
                                     (* _ppUserData)->key.h221_non_standard_id.value,
                                     pUserData->key.h221_non_standard_id.length);

                        // Copy data
                        pUserData->octet_string->length = (* _ppUserData)->octet_string->length;
                        ::CopyMemory(pUserData->octet_string->value,
                                     (* _ppUserData)->octet_string->value,
                                     pUserData->octet_string->length);

                        m_pUserDataList[i].pGUID = (GUID *)pUserData->octet_string->value;
                        m_pUserDataList[i].cbData = pUserData->octet_string->length - sizeof(GUID);
                        m_pUserDataList[i].pData = pUserData->octet_string->value + sizeof(GUID);

                        if (0 == CompareGuid(m_pUserDataList[i].pGUID, &g_csguidSecurity)) {

                            // Check data against transport level
                            PBYTE pbData = NULL;
                            DWORD cbData = 0;
                            BOOL fTrust = FALSE;

                            if (m_pUserDataList[i].cbData != 0 &&
                                GetSecurityInfo(m_pConEntry->GetConnectionHandle(),NULL,&cbData)) {
                                if (cbData == NOT_DIRECTLY_CONNECTED) {
                                    // This means we are not directly connected,
                                    // transitivity. so trust by
                                    fTrust = TRUE;
                                }
                                else {
                                    pbData = new BYTE[cbData];
                                    if (NULL != pbData) {
                                        GetSecurityInfo(m_pConEntry->GetConnectionHandle(),pbData,&cbData);
                                        // Does the data match?
                                        if (cbData != m_pUserDataList[i].cbData ||
                                            memcmp(pbData,
                                                m_pUserDataList[i].pData,
                                                                cbData)) {

                                            WARNING_OUT(("SECURITY MISMATCH: (%s) vs (%s)", pbData, m_pUserDataList[i].pData));

                                        }
                                        else {
                                            fTrust = TRUE;
                                        }
                                        delete [] pbData;
                                    }
                                    else {
                                        ERROR_OUT(("Failed to alloc %d bytes for security data verification", cbData));
                                    }
                                }
                            }

                            if (FALSE == fTrust) {
                                // Leave the security GUID in place, but NULL out the data to signal distrust.
                                m_pUserDataList[i].pData = NULL;
                                m_pUserDataList[i].cbData = 0;
                                pUserData->octet_string->length = sizeof(GUID);
                            }
                        }
                        _ppUserData++;
                    }
                    else
                    {
                        ERROR_OUT(("CJoinIndWork::CJoinIndWork: can't create pData, cbTotalSize=%u", cbTotalSize));
                        *pRetCode = UI_RC_OUT_OF_MEMORY;
                    }
                } // for
            }
            else
            {
                ERROR_OUT(("CJoinIndWork::CJoinIndWork: can't create m_ppUserData, m_nUserData=%u", m_nUserData));
                *pRetCode = UI_RC_OUT_OF_MEMORY;
            }
        }
        else
        {
            ERROR_OUT(("CJoinIndWork::CJoinIndWork: can't create m_pUserDataList, m_nUserData=%u", m_nUserData));
            *pRetCode = UI_RC_OUT_OF_MEMORY;
        }
    } // if

    DebugExitVOID(CJoinIndWork::CJoinIndWork);
}


CJoinIndWork::
~CJoinIndWork(void)
{
    DebugEntry(CJoinIndWork::~CJoinIndWork);

    delete m_pwszCallerID;

    for (UINT i = 0; i < m_nUserData; i++)
    {
        delete (LPBYTE) m_ppUserData[i]; // pData in the constructor
    }
    delete m_ppUserData;
    delete m_pUserDataList;

    DebugExitVOID(CJoinIndWork::~CJoinIndWork);
}


void CJoinIndWork::
DoWork(void)
{
    DebugEntry(CJoinIndWork::DoWork);

    // Notify the core.
    g_pCallbackInterface->OnIncomingJoinRequest((CONF_HANDLE) m_pConf,
                                                m_pwszCallerID,
                                                m_pRequestorVersion,
                                                m_pUserDataList,
                                                m_nUserData);
    DebugExitVOID(CJoinIndWork::DoWork);
}


HRESULT CJoinIndWork::
Respond ( GCCResult _Result )
{
    DebugEntry(CJoinIndWork::Respond);

    // It is a response from the core.
    HRESULT hr = ::GCCJoinResponseWrapper(m_nResponseTag,
                                          NULL,
                                          _Result,
                                          m_pConf->GetID(),
                                          m_nUserData,
                                          m_ppUserData);

    DebugExitHRESULT(CJoinIndWork::Respond, hr);
    return hr;
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Implementation of Methods for CSequentialWorkList
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


void CSequentialWorkList::
AddWorkItem ( CWorkItem *pWorkItem )
{
    DebugEntry(CSequentialWorkList::AddWorkItem);

    Append(pWorkItem);

    // If first entry in list, then kick off handler.
    if (1 == GetCount())
    {
        pWorkItem->DoWork();
    }

    DebugExitVOID(CSequentialWorkList::AddWorkItem);
}


void CSequentialWorkList::
RemoveWorkItem ( CWorkItem *pWorkItem )
{
    DebugEntry(CSequentialWorkList::RemoveWorkItem);

    if (pWorkItem)
    {
        // Make a note as to whether we are going to remove the head
        // work item in the list.
        BOOL bHeadItemRemoved = (pWorkItem == PeekHead());

        // Remove work item from list and destroy it.
        if (Remove(pWorkItem))
        {
            delete pWorkItem;

            // If there are more entries in the list, and we removed the
            // first one, then start the work of the next one in line.
            // Note that before doing this, the pointer to the workitem
            // was NULLed out (above) to prevent reentracy problems.
            if (bHeadItemRemoved && !IsEmpty())
            {
                PeekHead()->DoWork();
            }
        }
        else
        {
            ASSERT(! bHeadItemRemoved);
        }
    }

    DebugExitVOID(CSequentialWorkList::RemoveWorkItem);
}


void CSequentialWorkList::
PurgeListEntriesByOwner ( DCRNCConference *pOwner )
{
    CWorkItem   *pWorkItem;

    DebugEntry(CSequentialWorkList::PurgeListEntriesByOwner);

    if (NULL != pOwner)
    {
        // Note that head entry is removed last to stop work being started
        // on other entries in the list that are owned by pOwner.

        // Check to ensure there is a head item in the list.
        if (NULL != (pWorkItem = PeekHead()))
        {
            // Remember we are going to remove the head.
            BOOL    fHeadToRemove = pWorkItem->IsOwnedBy(pOwner);

            // Walk remaining entries in the list removing them.
            BOOL fMoreToRemove;
            do
            {
                fMoreToRemove = FALSE;
                Reset();
                while (NULL != (pWorkItem = Iterate()))
                {
                    if (pWorkItem->IsOwnedBy(pOwner))
                    {
                        Remove(pWorkItem);
                        delete pWorkItem;
                        fMoreToRemove = TRUE;
                        break;
                    }
                }
            }
            while (fMoreToRemove);

            // Now done removing all entries, including the head if needed...
            if (fHeadToRemove && ! IsEmpty())
            {
                PeekHead()->DoWork();
            }
        }
    }

    DebugExitVOID(CSequentialWorkList::PurgeListEntriesByOwner);
}


void CSequentialWorkList::
DeleteList(void)
{
    CWorkItem *pWorkItem;
    while (NULL != (pWorkItem = Get()))
    {
        delete pWorkItem;
    }
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Implementation of Methods for CQueryRemoteWork
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


CQueryRemoteWork::
CQueryRemoteWork
(
    LPVOID              pCallerContext,
    GCCAsymmetryType    eAsymType,
    LPCSTR              pcszNodeAddress,
	BOOL				fSecure,
    HRESULT             *pRetCode
)
: 
    CWorkItem(pCallerContext),
    m_hGCCConnHandle(NULL),
    m_apConfNames(NULL),
    m_fRemoteIsMCU(FALSE),
    m_eAsymType(eAsymType),
    m_pVersion(NULL),
    m_fSecure(fSecure),
    m_apConfDescriptors(NULL)
{
    DebugEntry(CQueryRemoteWork::CQueryRemoteWork);

    char szAddress[RNC_MAX_NODE_STRING_LEN];
    ::BuildAddressFromNodeDetails((LPSTR) pcszNodeAddress, &szAddress[0]);
    m_pszAddress = ::My_strdupA(&szAddress[0]);
    m_hr = (NULL != m_pszAddress) ? NO_ERROR : UI_RC_OUT_OF_MEMORY;
    *pRetCode = m_hr;
    
    DebugExitVOID(CQueryRemoteWork::CQueryRemoteWork);
}


CQueryRemoteWork::
~CQueryRemoteWork(void)
{
    LPWSTR *ppTempTargetName;
    LPWSTR *ppTempTargetDescriptor;

    DebugEntry(CQueryRemoteWork::~CQueryRemoteWork);

    // Clean up memory allocated.
    if (m_apConfNames)
    {
        ppTempTargetName = m_apConfNames;
        while (*ppTempTargetName)
        {
            delete *(ppTempTargetName++);
        }
        delete [] m_apConfNames;
    }

    if (m_apConfDescriptors)
    {
        ppTempTargetDescriptor = m_apConfDescriptors;
        while (*ppTempTargetDescriptor)
        {
            delete *(ppTempTargetDescriptor++);
        }
        delete [] m_apConfDescriptors;
    }   
    delete m_pszAddress;

    DebugExitVOID(CQueryRemoteWork::~CQueryRemoteWork);
}


void CQueryRemoteWork::
DoWork(void)
{
    GCCError                GCCrc;
    GCCNodeType             nodeType;
    GCCAsymmetryIndicator   asymmetry_indicator;

    DebugEntry(CQueryRemoteWork::DoWork);

    ::LoadAnnouncePresenceParameters(&nodeType, NULL, NULL, NULL);

    asymmetry_indicator.asymmetry_type = m_eAsymType;
    asymmetry_indicator.random_number = 0;
    if (asymmetry_indicator.asymmetry_type == GCC_ASYMMETRY_UNKNOWN)
    {
        m_nRandSeed = (int) ::GetTickCount();
        m_LocalAsymIndicator.random_number = ((GenerateRand() << 16) + GenerateRand());
        asymmetry_indicator.random_number = m_LocalAsymIndicator.random_number;
        m_LocalAsymIndicator.asymmetry_type = GCC_ASYMMETRY_UNKNOWN;
        m_fInUnknownQueryRequest = TRUE;
    }

    GCCrc = g_pIT120ControlSap->ConfQueryRequest(
                nodeType,
                &asymmetry_indicator,
                NULL,
                (TransportAddress) m_pszAddress,
				m_fSecure,
                g_nVersionRecords,
                g_ppVersionUserData,
                &m_hGCCConnHandle);
    TRACE_OUT(("GCC call: g_pIT120ControlSap->ConfQueryRequest, rc=%d", GCCrc));

    if (NO_ERROR != (m_hr = ::GetGCCRCDetails(GCCrc)))
    {
        AsyncQueryRemoteResult();
    }

    DebugExitHRESULT(CQueryRemoteWork::DoWork, m_hr);
}


void CQueryRemoteWork::
HandleQueryConfirmation ( QueryConfirmMessage * pQueryMessage )
{
    UINT                                   NumberOfConferences;
    GCCConferenceDescriptor             ** ppConferenceDescriptor;
    PWSTR *                                 ppTempTargetName;
    PWSTR                                   ConferenceTextName;
    GCCConferenceName *     pGCCConferenceName;
    PWSTR *                ppTempTargetDescriptor;
    PWSTR                  pwszConfDescriptor=NULL;
	HRESULT					hrTmp;

    DebugEntry(CQueryRemoteWork::HandleQueryConfirmation);

    // If no error, then package up information.
    m_hr = ::GetGCCResultDetails(pQueryMessage->result);
    if (NO_ERROR == m_hr)
    {
        m_fRemoteIsMCU = (pQueryMessage->node_type == GCC_MCU);
        NumberOfConferences = pQueryMessage->number_of_descriptors;
        DBG_SAVE_FILE_LINE
        m_apConfNames = new PWSTR[NumberOfConferences + 1];
        m_apConfDescriptors = new PWSTR[NumberOfConferences + 1];
        if (!m_apConfNames || !m_apConfDescriptors)
        {
            m_hr = UI_RC_OUT_OF_MEMORY;
        }
        else
        {
            ppConferenceDescriptor = pQueryMessage->conference_descriptor_list;
            ppTempTargetName = m_apConfNames;
            ppTempTargetDescriptor = m_apConfDescriptors;
            while (NumberOfConferences--)
            {
                pwszConfDescriptor = (*(ppConferenceDescriptor))->conference_descriptor;
                pGCCConferenceName = &(*(ppConferenceDescriptor++))->conference_name;

                if (pwszConfDescriptor != NULL)
                {
                    pwszConfDescriptor = ::My_strdupW(pwszConfDescriptor);
                }
                ConferenceTextName = pGCCConferenceName->text_string;
                if (ConferenceTextName != NULL)
                {
                    ConferenceTextName = ::My_strdupW(ConferenceTextName);
                    if (!ConferenceTextName)
                    {
                        // Out of memory, give back what we have.
                        m_hr = UI_RC_OUT_OF_MEMORY;
                        break;
                    }
                }
                else
                if (pGCCConferenceName->numeric_string != NULL)
                {
                    ConferenceTextName = ::AnsiToUnicode((PCSTR)pGCCConferenceName->numeric_string);
                    if (!ConferenceTextName)
                    {
                        // Out of memory, give back what we have.
                        m_hr = UI_RC_OUT_OF_MEMORY;
                        break;
                    }
                }
                if (ConferenceTextName)
                {
                    *(ppTempTargetName++) = ConferenceTextName;
                    *(ppTempTargetDescriptor++) = pwszConfDescriptor;
                }
            }
            *ppTempTargetName = NULL;
            *ppTempTargetDescriptor = NULL;
        }
    }

    // Copy version information out of message.

    m_pVersion = ::GetVersionData(pQueryMessage->number_of_user_data_members,
                                pQueryMessage->user_data_list);
    if (m_pVersion)
    {
        m_Version = *m_pVersion;
        m_pVersion = &m_Version;
    }

    m_fInUnknownQueryRequest = FALSE;

	hrTmp = m_hr;

    // Propagate the result directly without posting a message.
    SyncQueryRemoteResult();

    DebugExitHRESULT(CQueryRemoteWork::HandleQueryConfirmation, hrTmp);
}


void CQueryRemoteWork::
SyncQueryRemoteResult(void)
{
    DebugEntry(CQueryRemoteWork::SyncQueryRemoteResult);

    // Let the user know the result of his request.
    // The user is expected to call Release() after getting the result,
    // if he wants to drop the line - and should for errors.
    // Also, if the user is being called back before the inline code
    // has filled in the handle, then fill it in here - see comments in
    // DCRNCConferenceManager::QueryRemote for additional background.
    g_pCallbackInterface->OnQueryRemoteResult(
                                m_pOwner,
                                m_hr,
                                m_fRemoteIsMCU,
                                m_apConfNames,
                                m_pVersion,
                                m_apConfDescriptors);

    // If we are not inline, and this request made it into 
    // the sequential work item list,
    // then remove from list (which will cause item to be deleted),
    // otherwise, just delete item.
    g_pQueryRemoteList->RemoveWorkItem(this);

    DebugExitVOID(CQueryRemoteWork::SyncQueryRemoteResult);
}


void CQueryRemoteWork::
AsyncQueryRemoteResult(void)
{
    g_pNCConfMgr->PostWndMsg(NCMSG_QUERY_REMOTE_FAILURE, (LPARAM) this);
}

    
int CQueryRemoteWork::
GenerateRand(void)
{ // code from CRT
    return (((m_nRandSeed = m_nRandSeed * 214013L + 2531011L) >> 16) & 0x7fff);
}


HRESULT CQueryRemoteWorkList::
Cancel ( LPVOID pCallerContext )
{
    HRESULT hr = S_FALSE; // if not found
    CQueryRemoteWork *p;
    Reset();
    while (NULL != (p = Iterate()))
    {
        if (p->IsOwnedBy(pCallerContext))
        {
            // clean up the underlying plumbing.
            g_pIT120ControlSap->CancelConfQueryRequest(p->GetConnectionHandle());

            // clean up node controller data.
            RemoveWorkItem(p);
            hr = S_OK;
            break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\events.hpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1995-1996                    **/
/***************************************************************************/


/****************************************************************************

events.hpp

Nov. 95		LenS

Event handler infrastructure.

CSequentialEventList assumes that all activity occurs on a single thread.
It is the responsibility of the users to do the sychronization and thread
context switches for this to happen.
****************************************************************************/

#ifndef	EVENTS_INC
#define	EVENTS_INC

// #include <nmutil.h>
// #include <referenc.h>
#include <inodecnt.h>
#include "ernccons.h"
#include "cuserdta.hpp"


class DCRNCConference;
class CLogicalConnection;


#define QUERY_IND_WORK_OWNER        ((LPVOID) 1)


class CWorkItem
{
    friend class CSequentialWorkList;

public:

    CWorkItem(LPVOID pOwner) : m_pOwner(pOwner) { }
    virtual CWorkItem::~CWorkItem(void) = 0;

    virtual void DoWork(void) = 0;
    BOOL IsOwnedBy(LPVOID pOwner) { return (pOwner == m_pOwner);};

protected:

    LPVOID          m_pOwner;
};


// Invited by a remote node.
class CInviteIndWork : public CWorkItem
{
public:

    CInviteIndWork(PCONFERENCE         pConference,
                   LPCWSTR             wszCallerID,
                   PT120PRODUCTVERSION pRequestorVersion,
                   GCCUserData         **_ppUserData,
                   UINT                _nUserData,
                   CLogicalConnection  * _pConEntry);
    ~CInviteIndWork(void);

    void DoWork(void);
    LPWSTR GetCallerID(void) {return m_pwszCallerID;};

private:

    PCONFERENCE         m_pConf;
    LPWSTR              m_pwszCallerID;
    T120PRODUCTVERSION  m_RequestorVersion;
    PT120PRODUCTVERSION m_pRequestorVersion;
    PUSERDATAINFO       m_pUserDataList;
    UINT                m_nUserData;
    BOOL                m_fSecure;
};


// joined by a remote node
class CJoinIndWork : public CWorkItem
{
public:

    CJoinIndWork(GCCResponseTag            Tag, 
                 PCONFERENCE               pConference,
                 LPCWSTR                   wszCallerID,
                 CLogicalConnection       *pConEntry,
                 PT120PRODUCTVERSION       pRequestorVersion,
                 UINT                      _nUserData,
                 GCCUserData             **_ppUserData,
                 HRESULT                  *pRetCode);
    ~CJoinIndWork(void);

    BOOL AddUserData(UINT nUserData, GCCUserData ** ppUserData);
    void DoWork(void);
    HRESULT Respond(GCCResult Result);
    PCONFERENCE GetConference(void) { return m_pConf; };
    LPWSTR GetCallerID(void) { return m_pwszCallerID; };
    CLogicalConnection *GetConEntry(void) { return m_pConEntry; };

private:

    GCCResponseTag          m_nResponseTag;
    PCONFERENCE             m_pConf;
    LPWSTR                  m_pwszCallerID;
    CLogicalConnection     *m_pConEntry;
    T120PRODUCTVERSION      m_RequestorVersion;
    PT120PRODUCTVERSION     m_pRequestorVersion;
    PUSERDATAINFO           m_pUserDataList;
    GCCUserData           **m_ppUserData;
    UINT                    m_nUserData;
};


class CQueryRemoteWork : public CWorkItem
{
public:

    CQueryRemoteWork(LPVOID pContext, GCCAsymmetryType, LPCSTR pcszNodeAddr, BOOL fSecure, HRESULT *);
    ~CQueryRemoteWork(void);

    void DoWork(void);
    void HandleQueryConfirmation(QueryConfirmMessage * pQueryMessage);
    void SyncQueryRemoteResult(void);
    void AsyncQueryRemoteResult(void);
    int GenerateRand(void);
    void SetHr(HRESULT hr) { m_hr = hr; }
    BOOL IsInUnknownQueryRequest(void) { return m_fInUnknownQueryRequest; }
    ConnectionHandle GetConnectionHandle(void) { return m_hGCCConnHandle; }
    void GetAsymIndicator ( GCCAsymmetryIndicator *pIndicator )
    {
        pIndicator->asymmetry_type = m_LocalAsymIndicator.asymmetry_type;
        pIndicator->random_number = m_LocalAsymIndicator.random_number;
    }

private:

    ConnectionHandle        m_hGCCConnHandle;
    GCCAsymmetryType        m_eAsymType;
    LPSTR                   m_pszAddress;
    LPWSTR                 *m_apConfNames;
    HRESULT                 m_hr;
    BOOL                    m_fRemoteIsMCU;
    PT120PRODUCTVERSION     m_pVersion;
    T120PRODUCTVERSION      m_Version;
    GCCAsymmetryIndicator   m_LocalAsymIndicator;
    BOOL                    m_fInUnknownQueryRequest;
    int                     m_nRandSeed;
    BOOL                    m_fSecure;
    LPWSTR                  *m_apConfDescriptors;
}; 



// The CSequentialWorkList class is used to process a series 
// of asynchronous requests one at a time. 
// The user subclasses CWorkItem and puts the CWorkItem object into 
// the list by calling CSequentialWorkList::Add(). 
// When it is its turn to be processed (i.e. there are no pending requests),
// CWorkItem::Handle() is called. When the asynchonous work is done, 
// the user calls CSequentialWorkList::Remove which takes the CWorkItem 
// object out of the list, destroys it and calls CWorkItem::Handle() for
// the next CWorkItem in the list (if any).
class CSequentialWorkList : public CList
{
    DEFINE_CLIST(CSequentialWorkList, CWorkItem*)

public:

    ~CSequentialWorkList(void)
    {
        // Don't want to destroy an event list with pending events.
        // Codework: build I/O rundown into a generic event list,
        // and subclass.
        ASSERT(IsEmpty());
    }

    void AddWorkItem(CWorkItem * pWorkItem);
    void RemoveWorkItem(CWorkItem * pWorkItem);
    void PurgeListEntriesByOwner(DCRNCConference *pOwner);
    void DeleteList(void);
};


#define DEFINE_SEQ_WORK_LIST(_NewClass_,_PtrItemType_) \
            public: \
            _NewClass_(UINT cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CSequentialWorkList(cMaxItems) { ASSERT(sizeof(_PtrItemType_) == sizeof(CWorkItem*)); } \
            _NewClass_(_NewClass_ *pSrc) : CSequentialWorkList((CSequentialWorkList *) pSrc) { ASSERT(sizeof(_PtrItemType_) == sizeof(CWorkItem*)); } \
            _NewClass_(_NewClass_ &Src) : CSequentialWorkList((CSequentialWorkList *) &Src) { ASSERT(sizeof(_PtrItemType_) == sizeof(CWorkItem*)); } \
            BOOL Append(_PtrItemType_ pData) { return CSequentialWorkList::Append((CWorkItem*) pData); } \
            BOOL Prepend(_PtrItemType_ pData) { return CSequentialWorkList::Prepend((CWorkItem*) pData); } \
            BOOL Remove(_PtrItemType_ pData) { return CSequentialWorkList::Remove((CWorkItem*) pData); } \
            BOOL Find(_PtrItemType_ pData) { return CSequentialWorkList::Find((CWorkItem*) pData); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) CSequentialWorkList::Get(); } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) CSequentialWorkList::PeekHead(); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CSequentialWorkList::Iterate(); }



class CInviteIndWorkList : public CSequentialWorkList
{
    DEFINE_SEQ_WORK_LIST(CInviteIndWorkList, CInviteIndWork*)

public:

    void AddWorkItem(CInviteIndWork * pWorkItem)
    {
        CSequentialWorkList::AddWorkItem(pWorkItem);
    }
    void RemoveWorkItem(CInviteIndWork * pWorkItem)
    {
        CSequentialWorkList::RemoveWorkItem(pWorkItem);
    }
};


class CJoinIndWorkList : public CSequentialWorkList
{
    DEFINE_SEQ_WORK_LIST(CJoinIndWorkList, CJoinIndWork*)

public:

    void AddWorkItem(CJoinIndWork * pWorkItem)
    {
        CSequentialWorkList::AddWorkItem(pWorkItem);
    }
    void RemoveWorkItem(CJoinIndWork * pWorkItem)
    {
        CSequentialWorkList::RemoveWorkItem(pWorkItem);
    }
};


class CQueryRemoteWorkList : public CSequentialWorkList
{
    DEFINE_SEQ_WORK_LIST(CQueryRemoteWorkList, CQueryRemoteWork*)

public:

    void AddWorkItem(CQueryRemoteWork * pWorkItem)
    {
        CSequentialWorkList::AddWorkItem(pWorkItem);
    }
    void RemoveWorkItem(CQueryRemoteWork * pWorkItem)
    {
        CSequentialWorkList::RemoveWorkItem(pWorkItem);
    }

    HRESULT Cancel ( LPVOID pCallerContext );
};

extern CQueryRemoteWorkList *g_pQueryRemoteList;




#endif /* ndef EVENTS_INC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\erncvrsn.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1995-1996                    **/
/***************************************************************************/


/****************************************************************************

erncvrsn.hpp

Jun. 96		LenS

Versioning.
InitOurVersion() is called when constructing NCUI. After that local version
information is available in the static variables below.
GetVersionData() is used to extract versioning information from T120
messages received.

****************************************************************************/
#include "precomp.h"
#include "ernccons.h"
#include "nccglbl.hpp"
#include "erncvrsn.hpp"
#include <cuserdta.hpp>
#include <version.h>
#include "ernccm.hpp"


// INFO_NOT_RETAIL: Product is not a retail release.
#define INFO_NOT_RETAIL                     0x00000001


GUID g_csguidVerInfo = GUID_VERSION;

UINT                g_nVersionRecords;
GCCUserData **      g_ppVersionUserData;
T120PRODUCTVERSION  g_OurVersion;
CNCUserDataList    *g_pUserDataVersion = NULL;



HRESULT InitOurVersion(void)
{
    HRESULT    hr;

    ASSERT(NULL == g_pUserDataVersion);

    DBG_SAVE_FILE_LINE
    g_pUserDataVersion = new CNCUserDataList();
    if (NULL != g_pUserDataVersion)
    {
        // First get the entries that are in the binary.
        g_OurVersion.dwVersion = VER_PRODUCTVERSION_DW;
        g_OurVersion.dwExpirationDate = 0xffffffff;
    	g_OurVersion.dwInformation = 0;

        // We no longer go to the registry for these.  We just take the version
        // from the binaries. 
        g_OurVersion.dwEarliestPossibleVersion = VER_EARLIEST_COMPATIBLE_DW;
        g_OurVersion.dwMaxDifference = VER_MAX_DIFFERENCE;

        // Save our version info in a user data list structure, ready to distribute.
        hr = g_pUserDataVersion->AddUserData(&g_csguidVerInfo, sizeof(g_OurVersion), &g_OurVersion);
        if (NO_ERROR == hr)
        {
            hr = g_pUserDataVersion->GetUserDataList(&g_nVersionRecords, &g_ppVersionUserData);
        }
    }
    else
    {
        hr = UI_RC_OUT_OF_MEMORY;
    }

    return hr;
}


void ReleaseOurVersion(void)
{
    delete g_pUserDataVersion;
    g_pUserDataVersion = NULL;
}


PT120PRODUCTVERSION GetVersionData(UINT nRecords, GCCUserData **ppUserData)
{
    UINT            nData;
    LPVOID          pData;

    // If no version info or bad version info, then do not
    // return any version.

    if (NO_ERROR == ::GetUserData(nRecords, ppUserData, &g_csguidVerInfo, &nData, &pData))
    {
        if (nData >= sizeof(T120PRODUCTVERSION))
        {
            return (PT120PRODUCTVERSION) pData;
        }
    }
    return NULL;
}


BOOL TimeExpired(DWORD dwTime)
{
	SYSTEMTIME  st;
    DWORD       dwLocalTime;

	::GetLocalTime(&st);
    dwLocalTime = ((((unsigned long)st.wYear) << 16) |
                   (st.wMonth << 8) |
                   st.wDay);
    return (dwLocalTime >= dwTime);
}


STDMETHODIMP DCRNCConferenceManager::
CheckVersion ( PT120PRODUCTVERSION pRemoteVersion )
{
    DWORD   Status = NO_ERROR;

    // Don't bother with any checks if the versions are the same
    // or the remote site does not have versioning information.

    if ((NULL != pRemoteVersion) && (g_OurVersion.dwVersion != pRemoteVersion->dwVersion))
    {
        if (g_OurVersion.dwVersion < pRemoteVersion->dwVersion)
        {
            // Remote version is newer than local version.
            // Check to see if the local version is earlier than the mandatory and
            // recommended versions on the remote node.
            // Also, don't bother to check if the remote node has expired, because
            // if it has the local node will have also expired and the user will 
            // already have been bugged by the time-bomb.

            if (g_OurVersion.dwVersion < pRemoteVersion->dwEarliestPossibleVersion)
            {
                Status = UI_RC_VERSION_LOCAL_INCOMPATIBLE;
            }
            else if (((DWORD)(pRemoteVersion->dwVersion - g_OurVersion.dwVersion)) >
                     pRemoteVersion->dwMaxDifference)
            {
                Status = UI_RC_VERSION_LOCAL_UPGRADE_RECOMMENDED;
            }
            else
            {
                Status = UI_RC_VERSION_REMOTE_NEWER;
            }
        }
        else
        {
            // Local version is newer than remote version.
            // Check to see if the remote version is earlier than the mandatory and
            // recommended versions on the local node, and whether the remote node
            // has expired.

            if (pRemoteVersion->dwVersion < g_OurVersion.dwEarliestPossibleVersion)
            {
                Status = UI_RC_VERSION_REMOTE_INCOMPATIBLE;
            }
            else if (DWVERSION_NM_1 == pRemoteVersion->dwVersion)
            {
                // Unfortunately, v1.0 was marked as "pre-release" with a timebomb
                // of 10-15-96.  Special case this version and return a simpler error
                // message.
                Status = UI_RC_VERSION_REMOTE_OLDER;
            }
            else if (DWVERSION_NM_2 == pRemoteVersion->dwVersion)
            {
                // Unfortunately, v2.0 was marked with INFO_NOT_RETAIL and a timebomb
                // of 09-30-97. Special case this and return a simpler error message
                Status = UI_RC_VERSION_REMOTE_OLDER;
            }
            else if ((INFO_NOT_RETAIL & pRemoteVersion->dwInformation) &&
                     TimeExpired(pRemoteVersion->dwExpirationDate))
            {
                Status = UI_RC_VERSION_REMOTE_EXPIRED;
            }
            else if (((DWORD)(g_OurVersion.dwVersion - pRemoteVersion->dwVersion)) >
                     g_OurVersion.dwMaxDifference)
            {
                Status = UI_RC_VERSION_REMOTE_UPGRADE_RECOMMENDED;
            }
            else
            {
                Status = UI_RC_VERSION_REMOTE_OLDER;
            }
        }
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\gccpdu.c ===
#include <windows.h>
#include "gccpdu.h"

ASN1module_t GCCPDU_Module = NULL;

static int ASN1CALL ASN1Enc_ApplicationCapabilitiesList(ASN1encoding_t enc, ApplicationCapabilitiesList *val);
static int ASN1CALL ASN1Enc_ApplicationRecordList(ASN1encoding_t enc, ApplicationRecordList *val);
static int ASN1CALL ASN1Enc_HighLayerCompatibility(ASN1encoding_t enc, HighLayerCompatibility *val);
static int ASN1CALL ASN1Enc_TransferModes(ASN1encoding_t enc, TransferModes *val);
static int ASN1CALL ASN1Enc_TransportConnectionType(ASN1encoding_t enc, TransportConnectionType *val);
static int ASN1CALL ASN1Enc_AggregateChannel(ASN1encoding_t enc, AggregateChannel *val);
static int ASN1CALL ASN1Enc_NodeRecordList(ASN1encoding_t enc, NodeRecordList *val);
static int ASN1CALL ASN1Enc_WaitingList(ASN1encoding_t enc, PWaitingList *val);
static int ASN1CALL ASN1Enc_PermissionList(ASN1encoding_t enc, PPermissionList *val);
static int ASN1CALL ASN1Enc_SetOfDestinationNodes(ASN1encoding_t enc, PSetOfDestinationNodes *val);
static int ASN1CALL ASN1Enc_NodeInformation(ASN1encoding_t enc, NodeInformation *val);
static int ASN1CALL ASN1Enc_SetOfTransferringNodesIn(ASN1encoding_t enc, PSetOfTransferringNodesIn *val);
static int ASN1CALL ASN1Enc_SetOfTransferringNodesRs(ASN1encoding_t enc, PSetOfTransferringNodesRs *val);
static int ASN1CALL ASN1Enc_SetOfTransferringNodesRq(ASN1encoding_t enc, PSetOfTransferringNodesRq *val);
static int ASN1CALL ASN1Enc_RegistryEntryOwnerOwned(ASN1encoding_t enc, RegistryEntryOwnerOwned *val);
static int ASN1CALL ASN1Enc_ParticipantsList(ASN1encoding_t enc, PParticipantsList *val);
static int ASN1CALL ASN1Enc_Key(ASN1encoding_t enc, Key *val);
static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val);
static int ASN1CALL ASN1Enc_Password(ASN1encoding_t enc, Password *val);
static int ASN1CALL ASN1Enc_PasswordSelector(ASN1encoding_t enc, PasswordSelector *val);
static int ASN1CALL ASN1Enc_ChallengeResponseItem(ASN1encoding_t enc, ChallengeResponseItem *val);
static int ASN1CALL ASN1Enc_ChallengeResponseAlgorithm(ASN1encoding_t enc, ChallengeResponseAlgorithm *val);
static int ASN1CALL ASN1Enc_ChallengeItem(ASN1encoding_t enc, ChallengeItem *val);
static int ASN1CALL ASN1Enc_ChallengeRequest(ASN1encoding_t enc, ChallengeRequest *val);
static int ASN1CALL ASN1Enc_ChallengeResponse(ASN1encoding_t enc, ChallengeResponse *val);
static int ASN1CALL ASN1Enc_ConferenceName(ASN1encoding_t enc, ConferenceName *val);
static int ASN1CALL ASN1Enc_ConferenceNameSelector(ASN1encoding_t enc, ConferenceNameSelector *val);
static int ASN1CALL ASN1Enc_NodeProperties(ASN1encoding_t enc, NodeProperties *val);
static int ASN1CALL ASN1Enc_AsymmetryIndicator(ASN1encoding_t enc, AsymmetryIndicator *val);
static int ASN1CALL ASN1Enc_AlternativeNodeID(ASN1encoding_t enc, AlternativeNodeID *val);
static int ASN1CALL ASN1Enc_ConferenceDescriptor(ASN1encoding_t enc, ConferenceDescriptor *val);
static int ASN1CALL ASN1Enc_NodeRecord(ASN1encoding_t enc, NodeRecord *val);
static int ASN1CALL ASN1Enc_SessionKey(ASN1encoding_t enc, SessionKey *val);
static int ASN1CALL ASN1Enc_ApplicationRecord(ASN1encoding_t enc, ApplicationRecord *val);
static int ASN1CALL ASN1Enc_CapabilityID(ASN1encoding_t enc, CapabilityID *val);
static int ASN1CALL ASN1Enc_CapabilityClass(ASN1encoding_t enc, CapabilityClass *val);
static int ASN1CALL ASN1Enc_ApplicationInvokeSpecifier(ASN1encoding_t enc, ApplicationInvokeSpecifier *val);
static int ASN1CALL ASN1Enc_RegistryKey(ASN1encoding_t enc, RegistryKey *val);
static int ASN1CALL ASN1Enc_RegistryItem(ASN1encoding_t enc, RegistryItem *val);
static int ASN1CALL ASN1Enc_RegistryEntryOwner(ASN1encoding_t enc, RegistryEntryOwner *val);
static int ASN1CALL ASN1Enc_UserIDIndication(ASN1encoding_t enc, UserIDIndication *val);
static int ASN1CALL ASN1Enc_SetOfPrivileges(ASN1encoding_t enc, PSetOfPrivileges *val);
static int ASN1CALL ASN1Enc_ConferenceCreateRequest(ASN1encoding_t enc, ConferenceCreateRequest *val);
static int ASN1CALL ASN1Enc_ConferenceCreateResponse(ASN1encoding_t enc, ConferenceCreateResponse *val);
static int ASN1CALL ASN1Enc_ConferenceQueryRequest(ASN1encoding_t enc, ConferenceQueryRequest *val);
static int ASN1CALL ASN1Enc_ConferenceQueryResponse(ASN1encoding_t enc, ConferenceQueryResponse *val);
static int ASN1CALL ASN1Enc_ConferenceInviteRequest(ASN1encoding_t enc, ConferenceInviteRequest *val);
static int ASN1CALL ASN1Enc_ConferenceInviteResponse(ASN1encoding_t enc, ConferenceInviteResponse *val);
static int ASN1CALL ASN1Enc_ConferenceAddRequest(ASN1encoding_t enc, ConferenceAddRequest *val);
static int ASN1CALL ASN1Enc_ConferenceAddResponse(ASN1encoding_t enc, ConferenceAddResponse *val);
static int ASN1CALL ASN1Enc_ConferenceLockRequest(ASN1encoding_t enc, ConferenceLockRequest *val);
static int ASN1CALL ASN1Enc_ConferenceLockResponse(ASN1encoding_t enc, ConferenceLockResponse *val);
static int ASN1CALL ASN1Enc_ConferenceLockIndication(ASN1encoding_t enc, ConferenceLockIndication *val);
static int ASN1CALL ASN1Enc_ConferenceUnlockRequest(ASN1encoding_t enc, ConferenceUnlockRequest *val);
static int ASN1CALL ASN1Enc_ConferenceUnlockResponse(ASN1encoding_t enc, ConferenceUnlockResponse *val);
static int ASN1CALL ASN1Enc_ConferenceUnlockIndication(ASN1encoding_t enc, ConferenceUnlockIndication *val);
static int ASN1CALL ASN1Enc_ConferenceTerminateRequest(ASN1encoding_t enc, ConferenceTerminateRequest *val);
static int ASN1CALL ASN1Enc_ConferenceTerminateResponse(ASN1encoding_t enc, ConferenceTerminateResponse *val);
static int ASN1CALL ASN1Enc_ConferenceTerminateIndication(ASN1encoding_t enc, ConferenceTerminateIndication *val);
static int ASN1CALL ASN1Enc_ConferenceEjectUserRequest(ASN1encoding_t enc, ConferenceEjectUserRequest *val);
static int ASN1CALL ASN1Enc_ConferenceEjectUserResponse(ASN1encoding_t enc, ConferenceEjectUserResponse *val);
static int ASN1CALL ASN1Enc_ConferenceEjectUserIndication(ASN1encoding_t enc, ConferenceEjectUserIndication *val);
static int ASN1CALL ASN1Enc_ConferenceTransferRequest(ASN1encoding_t enc, ConferenceTransferRequest *val);
static int ASN1CALL ASN1Enc_ConferenceTransferResponse(ASN1encoding_t enc, ConferenceTransferResponse *val);
static int ASN1CALL ASN1Enc_ConferenceTransferIndication(ASN1encoding_t enc, ConferenceTransferIndication *val);
static int ASN1CALL ASN1Enc_RosterUpdateIndication(ASN1encoding_t enc, RosterUpdateIndication *val);
static int ASN1CALL ASN1Enc_ApplicationInvokeIndication(ASN1encoding_t enc, ApplicationInvokeIndication *val);
static int ASN1CALL ASN1Enc_RegistryRegisterChannelRequest(ASN1encoding_t enc, RegistryRegisterChannelRequest *val);
static int ASN1CALL ASN1Enc_RegistryAssignTokenRequest(ASN1encoding_t enc, RegistryAssignTokenRequest *val);
static int ASN1CALL ASN1Enc_RegistrySetParameterRequest(ASN1encoding_t enc, RegistrySetParameterRequest *val);
static int ASN1CALL ASN1Enc_RegistryRetrieveEntryRequest(ASN1encoding_t enc, RegistryRetrieveEntryRequest *val);
static int ASN1CALL ASN1Enc_RegistryDeleteEntryRequest(ASN1encoding_t enc, RegistryDeleteEntryRequest *val);
static int ASN1CALL ASN1Enc_RegistryMonitorEntryRequest(ASN1encoding_t enc, RegistryMonitorEntryRequest *val);
static int ASN1CALL ASN1Enc_RegistryMonitorEntryIndication(ASN1encoding_t enc, RegistryMonitorEntryIndication *val);
static int ASN1CALL ASN1Enc_RegistryAllocateHandleRequest(ASN1encoding_t enc, RegistryAllocateHandleRequest *val);
static int ASN1CALL ASN1Enc_RegistryAllocateHandleResponse(ASN1encoding_t enc, RegistryAllocateHandleResponse *val);
static int ASN1CALL ASN1Enc_RegistryResponse(ASN1encoding_t enc, RegistryResponse *val);
static int ASN1CALL ASN1Enc_ConductorAssignIndication(ASN1encoding_t enc, ConductorAssignIndication *val);
static int ASN1CALL ASN1Enc_ConductorReleaseIndication(ASN1encoding_t enc, ConductorReleaseIndication *val);
static int ASN1CALL ASN1Enc_ConductorPermissionAskIndication(ASN1encoding_t enc, ConductorPermissionAskIndication *val);
static int ASN1CALL ASN1Enc_ConductorPermissionGrantIndication(ASN1encoding_t enc, ConductorPermissionGrantIndication *val);
static int ASN1CALL ASN1Enc_ConferenceTimeRemainingIndication(ASN1encoding_t enc, ConferenceTimeRemainingIndication *val);
static int ASN1CALL ASN1Enc_ConferenceTimeInquireIndication(ASN1encoding_t enc, ConferenceTimeInquireIndication *val);
static int ASN1CALL ASN1Enc_ConferenceTimeExtendIndication(ASN1encoding_t enc, ConferenceTimeExtendIndication *val);
static int ASN1CALL ASN1Enc_ConferenceAssistanceIndication(ASN1encoding_t enc, ConferenceAssistanceIndication *val);
static int ASN1CALL ASN1Enc_TextMessageIndication(ASN1encoding_t enc, TextMessageIndication *val);
static int ASN1CALL ASN1Enc_NonStandardPDU(ASN1encoding_t enc, NonStandardPDU *val);
static int ASN1CALL ASN1Enc_ConnectData(ASN1encoding_t enc, ConnectData *val);
static int ASN1CALL ASN1Enc_IndicationPDU(ASN1encoding_t enc, IndicationPDU *val);
static int ASN1CALL ASN1Enc_ApplicationUpdate(ASN1encoding_t enc, ApplicationUpdate *val);
static int ASN1CALL ASN1Enc_RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set(ASN1encoding_t enc, RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set *val);
static int ASN1CALL ASN1Enc_RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set(ASN1encoding_t enc, RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set *val);
static int ASN1CALL ASN1Enc_RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set(ASN1encoding_t enc, RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set *val);
static int ASN1CALL ASN1Enc_NodeUpdate(ASN1encoding_t enc, NodeUpdate *val);
static int ASN1CALL ASN1Enc_RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set(ASN1encoding_t enc, RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set *val);
static int ASN1CALL ASN1Enc_RosterUpdateIndication_node_information_node_record_list_node_record_update_Set(ASN1encoding_t enc, RosterUpdateIndication_node_information_node_record_list_node_record_update_Set *val);
static int ASN1CALL ASN1Enc_SetOfApplicationRecordUpdates(ASN1encoding_t enc, PSetOfApplicationRecordUpdates *val);
static int ASN1CALL ASN1Enc_SetOfApplicationRecordRefreshes(ASN1encoding_t enc, PSetOfApplicationRecordRefreshes *val);
static int ASN1CALL ASN1Enc_SetOfApplicationCapabilityRefreshes(ASN1encoding_t enc, PSetOfApplicationCapabilityRefreshes *val);
static int ASN1CALL ASN1Enc_SetOfNodeRecordUpdates(ASN1encoding_t enc, PSetOfNodeRecordUpdates *val);
static int ASN1CALL ASN1Enc_SetOfNodeRecordRefreshes(ASN1encoding_t enc, PSetOfNodeRecordRefreshes *val);
static int ASN1CALL ASN1Enc_ApplicationRecord_non_collapsing_capabilities_Set(ASN1encoding_t enc, ApplicationRecord_non_collapsing_capabilities_Set *val);
static int ASN1CALL ASN1Enc_ApplicationInvokeSpecifier_expected_capability_set_Set(ASN1encoding_t enc, ApplicationInvokeSpecifier_expected_capability_set_Set *val);
static int ASN1CALL ASN1Enc_RosterUpdateIndication_application_information_Set(ASN1encoding_t enc, RosterUpdateIndication_application_information_Set *val);
static int ASN1CALL ASN1Enc_ApplicationProtocolEntityList(ASN1encoding_t enc, PApplicationProtocolEntityList *val);
static int ASN1CALL ASN1Enc_SetOfApplicationInformation(ASN1encoding_t enc, PSetOfApplicationInformation *val);
static int ASN1CALL ASN1Enc_SetOfConferenceDescriptors(ASN1encoding_t enc, PSetOfConferenceDescriptors *val);
static int ASN1CALL ASN1Enc_SetOfExpectedCapabilities(ASN1encoding_t enc, PSetOfExpectedCapabilities *val);
static int ASN1CALL ASN1Enc_SetOfNonCollapsingCapabilities(ASN1encoding_t enc, PSetOfNonCollapsingCapabilities *val);
static int ASN1CALL ASN1Enc_NetworkAddress(ASN1encoding_t enc, NetworkAddress *val);
static int ASN1CALL ASN1Enc_ChallengeRequestResponse(ASN1encoding_t enc, ChallengeRequestResponse *val);
static int ASN1CALL ASN1Enc_SetOfChallengeItems(ASN1encoding_t enc, PSetOfChallengeItems *val);
static int ASN1CALL ASN1Enc_UserData_Set(ASN1encoding_t enc, UserData_Set *val);
static int ASN1CALL ASN1Enc_SetOfUserData(ASN1encoding_t enc, PSetOfUserData *val);
static int ASN1CALL ASN1Enc_PasswordChallengeRequestResponse(ASN1encoding_t enc, PasswordChallengeRequestResponse *val);
static int ASN1CALL ASN1Enc_SetOfNetworkAddresses(ASN1encoding_t enc, PSetOfNetworkAddresses *val);
static int ASN1CALL ASN1Enc_ConferenceJoinRequest(ASN1encoding_t enc, ConferenceJoinRequest *val);
static int ASN1CALL ASN1Enc_ConferenceJoinResponse(ASN1encoding_t enc, ConferenceJoinResponse *val);
static int ASN1CALL ASN1Enc_ConnectGCCPDU(ASN1encoding_t enc, ConnectGCCPDU *val);
static int ASN1CALL ASN1Enc_RequestPDU(ASN1encoding_t enc, RequestPDU *val);
static int ASN1CALL ASN1Enc_FunctionNotSupportedResponse(ASN1encoding_t enc, FunctionNotSupportedResponse *val);
static int ASN1CALL ASN1Enc_ResponsePDU(ASN1encoding_t enc, ResponsePDU *val);
static int ASN1CALL ASN1Enc_GCCPDU(ASN1encoding_t enc, GCCPDU *val);
static int ASN1CALL ASN1Dec_ApplicationCapabilitiesList(ASN1decoding_t dec, ApplicationCapabilitiesList *val);
static int ASN1CALL ASN1Dec_ApplicationRecordList(ASN1decoding_t dec, ApplicationRecordList *val);
static int ASN1CALL ASN1Dec_HighLayerCompatibility(ASN1decoding_t dec, HighLayerCompatibility *val);
static int ASN1CALL ASN1Dec_TransferModes(ASN1decoding_t dec, TransferModes *val);
static int ASN1CALL ASN1Dec_TransportConnectionType(ASN1decoding_t dec, TransportConnectionType *val);
static int ASN1CALL ASN1Dec_AggregateChannel(ASN1decoding_t dec, AggregateChannel *val);
static int ASN1CALL ASN1Dec_NodeRecordList(ASN1decoding_t dec, NodeRecordList *val);
static int ASN1CALL ASN1Dec_WaitingList(ASN1decoding_t dec, PWaitingList *val);
static int ASN1CALL ASN1Dec_PermissionList(ASN1decoding_t dec, PPermissionList *val);
static int ASN1CALL ASN1Dec_SetOfDestinationNodes(ASN1decoding_t dec, PSetOfDestinationNodes *val);
static int ASN1CALL ASN1Dec_NodeInformation(ASN1decoding_t dec, NodeInformation *val);
static int ASN1CALL ASN1Dec_SetOfTransferringNodesIn(ASN1decoding_t dec, PSetOfTransferringNodesIn *val);
static int ASN1CALL ASN1Dec_SetOfTransferringNodesRs(ASN1decoding_t dec, PSetOfTransferringNodesRs *val);
static int ASN1CALL ASN1Dec_SetOfTransferringNodesRq(ASN1decoding_t dec, PSetOfTransferringNodesRq *val);
static int ASN1CALL ASN1Dec_RegistryEntryOwnerOwned(ASN1decoding_t dec, RegistryEntryOwnerOwned *val);
static int ASN1CALL ASN1Dec_ParticipantsList(ASN1decoding_t dec, PParticipantsList *val);
static int ASN1CALL ASN1Dec_Key(ASN1decoding_t dec, Key *val);
static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val);
static int ASN1CALL ASN1Dec_Password(ASN1decoding_t dec, Password *val);
static int ASN1CALL ASN1Dec_PasswordSelector(ASN1decoding_t dec, PasswordSelector *val);
static int ASN1CALL ASN1Dec_ChallengeResponseItem(ASN1decoding_t dec, ChallengeResponseItem *val);
static int ASN1CALL ASN1Dec_ChallengeResponseAlgorithm(ASN1decoding_t dec, ChallengeResponseAlgorithm *val);
static int ASN1CALL ASN1Dec_ChallengeItem(ASN1decoding_t dec, ChallengeItem *val);
static int ASN1CALL ASN1Dec_ChallengeRequest(ASN1decoding_t dec, ChallengeRequest *val);
static int ASN1CALL ASN1Dec_ChallengeResponse(ASN1decoding_t dec, ChallengeResponse *val);
static int ASN1CALL ASN1Dec_ConferenceName(ASN1decoding_t dec, ConferenceName *val);
static int ASN1CALL ASN1Dec_ConferenceNameSelector(ASN1decoding_t dec, ConferenceNameSelector *val);
static int ASN1CALL ASN1Dec_NodeProperties(ASN1decoding_t dec, NodeProperties *val);
static int ASN1CALL ASN1Dec_AsymmetryIndicator(ASN1decoding_t dec, AsymmetryIndicator *val);
static int ASN1CALL ASN1Dec_AlternativeNodeID(ASN1decoding_t dec, AlternativeNodeID *val);
static int ASN1CALL ASN1Dec_ConferenceDescriptor(ASN1decoding_t dec, ConferenceDescriptor *val);
static int ASN1CALL ASN1Dec_NodeRecord(ASN1decoding_t dec, NodeRecord *val);
static int ASN1CALL ASN1Dec_SessionKey(ASN1decoding_t dec, SessionKey *val);
static int ASN1CALL ASN1Dec_ApplicationRecord(ASN1decoding_t dec, ApplicationRecord *val);
static int ASN1CALL ASN1Dec_CapabilityID(ASN1decoding_t dec, CapabilityID *val);
static int ASN1CALL ASN1Dec_CapabilityClass(ASN1decoding_t dec, CapabilityClass *val);
static int ASN1CALL ASN1Dec_ApplicationInvokeSpecifier(ASN1decoding_t dec, ApplicationInvokeSpecifier *val);
static int ASN1CALL ASN1Dec_RegistryKey(ASN1decoding_t dec, RegistryKey *val);
static int ASN1CALL ASN1Dec_RegistryItem(ASN1decoding_t dec, RegistryItem *val);
static int ASN1CALL ASN1Dec_RegistryEntryOwner(ASN1decoding_t dec, RegistryEntryOwner *val);
static int ASN1CALL ASN1Dec_UserIDIndication(ASN1decoding_t dec, UserIDIndication *val);
static int ASN1CALL ASN1Dec_SetOfPrivileges(ASN1decoding_t dec, PSetOfPrivileges *val);
static int ASN1CALL ASN1Dec_ConferenceCreateRequest(ASN1decoding_t dec, ConferenceCreateRequest *val);
static int ASN1CALL ASN1Dec_ConferenceCreateResponse(ASN1decoding_t dec, ConferenceCreateResponse *val);
static int ASN1CALL ASN1Dec_ConferenceQueryRequest(ASN1decoding_t dec, ConferenceQueryRequest *val);
static int ASN1CALL ASN1Dec_ConferenceQueryResponse(ASN1decoding_t dec, ConferenceQueryResponse *val);
static int ASN1CALL ASN1Dec_ConferenceInviteRequest(ASN1decoding_t dec, ConferenceInviteRequest *val);
static int ASN1CALL ASN1Dec_ConferenceInviteResponse(ASN1decoding_t dec, ConferenceInviteResponse *val);
static int ASN1CALL ASN1Dec_ConferenceAddRequest(ASN1decoding_t dec, ConferenceAddRequest *val);
static int ASN1CALL ASN1Dec_ConferenceAddResponse(ASN1decoding_t dec, ConferenceAddResponse *val);
static int ASN1CALL ASN1Dec_ConferenceLockRequest(ASN1decoding_t dec, ConferenceLockRequest *val);
static int ASN1CALL ASN1Dec_ConferenceLockResponse(ASN1decoding_t dec, ConferenceLockResponse *val);
static int ASN1CALL ASN1Dec_ConferenceLockIndication(ASN1decoding_t dec, ConferenceLockIndication *val);
static int ASN1CALL ASN1Dec_ConferenceUnlockRequest(ASN1decoding_t dec, ConferenceUnlockRequest *val);
static int ASN1CALL ASN1Dec_ConferenceUnlockResponse(ASN1decoding_t dec, ConferenceUnlockResponse *val);
static int ASN1CALL ASN1Dec_ConferenceUnlockIndication(ASN1decoding_t dec, ConferenceUnlockIndication *val);
static int ASN1CALL ASN1Dec_ConferenceTerminateRequest(ASN1decoding_t dec, ConferenceTerminateRequest *val);
static int ASN1CALL ASN1Dec_ConferenceTerminateResponse(ASN1decoding_t dec, ConferenceTerminateResponse *val);
static int ASN1CALL ASN1Dec_ConferenceTerminateIndication(ASN1decoding_t dec, ConferenceTerminateIndication *val);
static int ASN1CALL ASN1Dec_ConferenceEjectUserRequest(ASN1decoding_t dec, ConferenceEjectUserRequest *val);
static int ASN1CALL ASN1Dec_ConferenceEjectUserResponse(ASN1decoding_t dec, ConferenceEjectUserResponse *val);
static int ASN1CALL ASN1Dec_ConferenceEjectUserIndication(ASN1decoding_t dec, ConferenceEjectUserIndication *val);
static int ASN1CALL ASN1Dec_ConferenceTransferRequest(ASN1decoding_t dec, ConferenceTransferRequest *val);
static int ASN1CALL ASN1Dec_ConferenceTransferResponse(ASN1decoding_t dec, ConferenceTransferResponse *val);
static int ASN1CALL ASN1Dec_ConferenceTransferIndication(ASN1decoding_t dec, ConferenceTransferIndication *val);
static int ASN1CALL ASN1Dec_RosterUpdateIndication(ASN1decoding_t dec, RosterUpdateIndication *val);
static int ASN1CALL ASN1Dec_ApplicationInvokeIndication(ASN1decoding_t dec, ApplicationInvokeIndication *val);
static int ASN1CALL ASN1Dec_RegistryRegisterChannelRequest(ASN1decoding_t dec, RegistryRegisterChannelRequest *val);
static int ASN1CALL ASN1Dec_RegistryAssignTokenRequest(ASN1decoding_t dec, RegistryAssignTokenRequest *val);
static int ASN1CALL ASN1Dec_RegistrySetParameterRequest(ASN1decoding_t dec, RegistrySetParameterRequest *val);
static int ASN1CALL ASN1Dec_RegistryRetrieveEntryRequest(ASN1decoding_t dec, RegistryRetrieveEntryRequest *val);
static int ASN1CALL ASN1Dec_RegistryDeleteEntryRequest(ASN1decoding_t dec, RegistryDeleteEntryRequest *val);
static int ASN1CALL ASN1Dec_RegistryMonitorEntryRequest(ASN1decoding_t dec, RegistryMonitorEntryRequest *val);
static int ASN1CALL ASN1Dec_RegistryMonitorEntryIndication(ASN1decoding_t dec, RegistryMonitorEntryIndication *val);
static int ASN1CALL ASN1Dec_RegistryAllocateHandleRequest(ASN1decoding_t dec, RegistryAllocateHandleRequest *val);
static int ASN1CALL ASN1Dec_RegistryAllocateHandleResponse(ASN1decoding_t dec, RegistryAllocateHandleResponse *val);
static int ASN1CALL ASN1Dec_RegistryResponse(ASN1decoding_t dec, RegistryResponse *val);
static int ASN1CALL ASN1Dec_ConductorAssignIndication(ASN1decoding_t dec, ConductorAssignIndication *val);
static int ASN1CALL ASN1Dec_ConductorReleaseIndication(ASN1decoding_t dec, ConductorReleaseIndication *val);
static int ASN1CALL ASN1Dec_ConductorPermissionAskIndication(ASN1decoding_t dec, ConductorPermissionAskIndication *val);
static int ASN1CALL ASN1Dec_ConductorPermissionGrantIndication(ASN1decoding_t dec, ConductorPermissionGrantIndication *val);
static int ASN1CALL ASN1Dec_ConferenceTimeRemainingIndication(ASN1decoding_t dec, ConferenceTimeRemainingIndication *val);
static int ASN1CALL ASN1Dec_ConferenceTimeInquireIndication(ASN1decoding_t dec, ConferenceTimeInquireIndication *val);
static int ASN1CALL ASN1Dec_ConferenceTimeExtendIndication(ASN1decoding_t dec, ConferenceTimeExtendIndication *val);
static int ASN1CALL ASN1Dec_ConferenceAssistanceIndication(ASN1decoding_t dec, ConferenceAssistanceIndication *val);
static int ASN1CALL ASN1Dec_TextMessageIndication(ASN1decoding_t dec, TextMessageIndication *val);
static int ASN1CALL ASN1Dec_NonStandardPDU(ASN1decoding_t dec, NonStandardPDU *val);
static int ASN1CALL ASN1Dec_ConnectData(ASN1decoding_t dec, ConnectData *val);
static int ASN1CALL ASN1Dec_IndicationPDU(ASN1decoding_t dec, IndicationPDU *val);
static int ASN1CALL ASN1Dec_ApplicationUpdate(ASN1decoding_t dec, ApplicationUpdate *val);
static int ASN1CALL ASN1Dec_RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set(ASN1decoding_t dec, RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set *val);
static int ASN1CALL ASN1Dec_RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set(ASN1decoding_t dec, RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set *val);
static int ASN1CALL ASN1Dec_RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set(ASN1decoding_t dec, RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set *val);
static int ASN1CALL ASN1Dec_NodeUpdate(ASN1decoding_t dec, NodeUpdate *val);
static int ASN1CALL ASN1Dec_RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set(ASN1decoding_t dec, RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set *val);
static int ASN1CALL ASN1Dec_RosterUpdateIndication_node_information_node_record_list_node_record_update_Set(ASN1decoding_t dec, RosterUpdateIndication_node_information_node_record_list_node_record_update_Set *val);
static int ASN1CALL ASN1Dec_SetOfApplicationRecordUpdates(ASN1decoding_t dec, PSetOfApplicationRecordUpdates *val);
static int ASN1CALL ASN1Dec_SetOfApplicationRecordRefreshes(ASN1decoding_t dec, PSetOfApplicationRecordRefreshes *val);
static int ASN1CALL ASN1Dec_SetOfApplicationCapabilityRefreshes(ASN1decoding_t dec, PSetOfApplicationCapabilityRefreshes *val);
static int ASN1CALL ASN1Dec_SetOfNodeRecordUpdates(ASN1decoding_t dec, PSetOfNodeRecordUpdates *val);
static int ASN1CALL ASN1Dec_SetOfNodeRecordRefreshes(ASN1decoding_t dec, PSetOfNodeRecordRefreshes *val);
static int ASN1CALL ASN1Dec_ApplicationRecord_non_collapsing_capabilities_Set(ASN1decoding_t dec, ApplicationRecord_non_collapsing_capabilities_Set *val);
static int ASN1CALL ASN1Dec_ApplicationInvokeSpecifier_expected_capability_set_Set(ASN1decoding_t dec, ApplicationInvokeSpecifier_expected_capability_set_Set *val);
static int ASN1CALL ASN1Dec_RosterUpdateIndication_application_information_Set(ASN1decoding_t dec, RosterUpdateIndication_application_information_Set *val);
static int ASN1CALL ASN1Dec_ApplicationProtocolEntityList(ASN1decoding_t dec, PApplicationProtocolEntityList *val);
static int ASN1CALL ASN1Dec_SetOfApplicationInformation(ASN1decoding_t dec, PSetOfApplicationInformation *val);
static int ASN1CALL ASN1Dec_SetOfConferenceDescriptors(ASN1decoding_t dec, PSetOfConferenceDescriptors *val);
static int ASN1CALL ASN1Dec_SetOfExpectedCapabilities(ASN1decoding_t dec, PSetOfExpectedCapabilities *val);
static int ASN1CALL ASN1Dec_SetOfNonCollapsingCapabilities(ASN1decoding_t dec, PSetOfNonCollapsingCapabilities *val);
static int ASN1CALL ASN1Dec_NetworkAddress(ASN1decoding_t dec, NetworkAddress *val);
static int ASN1CALL ASN1Dec_ChallengeRequestResponse(ASN1decoding_t dec, ChallengeRequestResponse *val);
static int ASN1CALL ASN1Dec_SetOfChallengeItems(ASN1decoding_t dec, PSetOfChallengeItems *val);
static int ASN1CALL ASN1Dec_UserData_Set(ASN1decoding_t dec, UserData_Set *val);
static int ASN1CALL ASN1Dec_SetOfUserData(ASN1decoding_t dec, PSetOfUserData *val);
static int ASN1CALL ASN1Dec_PasswordChallengeRequestResponse(ASN1decoding_t dec, PasswordChallengeRequestResponse *val);
static int ASN1CALL ASN1Dec_SetOfNetworkAddresses(ASN1decoding_t dec, PSetOfNetworkAddresses *val);
static int ASN1CALL ASN1Dec_ConferenceJoinRequest(ASN1decoding_t dec, ConferenceJoinRequest *val);
static int ASN1CALL ASN1Dec_ConferenceJoinResponse(ASN1decoding_t dec, ConferenceJoinResponse *val);
static int ASN1CALL ASN1Dec_ConnectGCCPDU(ASN1decoding_t dec, ConnectGCCPDU *val);
static int ASN1CALL ASN1Dec_RequestPDU(ASN1decoding_t dec, RequestPDU *val);
static int ASN1CALL ASN1Dec_FunctionNotSupportedResponse(ASN1decoding_t dec, FunctionNotSupportedResponse *val);
static int ASN1CALL ASN1Dec_ResponsePDU(ASN1decoding_t dec, ResponsePDU *val);
static int ASN1CALL ASN1Dec_GCCPDU(ASN1decoding_t dec, GCCPDU *val);
static void ASN1CALL ASN1Free_ApplicationCapabilitiesList(ApplicationCapabilitiesList *val);
static void ASN1CALL ASN1Free_ApplicationRecordList(ApplicationRecordList *val);
static void ASN1CALL ASN1Free_TransportConnectionType(TransportConnectionType *val);
static void ASN1CALL ASN1Free_AggregateChannel(AggregateChannel *val);
static void ASN1CALL ASN1Free_NodeRecordList(NodeRecordList *val);
static void ASN1CALL ASN1Free_WaitingList(PWaitingList *val);
static void ASN1CALL ASN1Free_PermissionList(PPermissionList *val);
static void ASN1CALL ASN1Free_SetOfDestinationNodes(PSetOfDestinationNodes *val);
static void ASN1CALL ASN1Free_NodeInformation(NodeInformation *val);
static void ASN1CALL ASN1Free_SetOfTransferringNodesIn(PSetOfTransferringNodesIn *val);
static void ASN1CALL ASN1Free_SetOfTransferringNodesRs(PSetOfTransferringNodesRs *val);
static void ASN1CALL ASN1Free_SetOfTransferringNodesRq(PSetOfTransferringNodesRq *val);
static void ASN1CALL ASN1Free_ParticipantsList(PParticipantsList *val);
static void ASN1CALL ASN1Free_Key(Key *val);
static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val);
static void ASN1CALL ASN1Free_Password(Password *val);
static void ASN1CALL ASN1Free_PasswordSelector(PasswordSelector *val);
static void ASN1CALL ASN1Free_ChallengeResponseItem(ChallengeResponseItem *val);
static void ASN1CALL ASN1Free_ChallengeResponseAlgorithm(ChallengeResponseAlgorithm *val);
static void ASN1CALL ASN1Free_ChallengeItem(ChallengeItem *val);
static void ASN1CALL ASN1Free_ChallengeRequest(ChallengeRequest *val);
static void ASN1CALL ASN1Free_ChallengeResponse(ChallengeResponse *val);
static void ASN1CALL ASN1Free_ConferenceName(ConferenceName *val);
static void ASN1CALL ASN1Free_ConferenceNameSelector(ConferenceNameSelector *val);
static void ASN1CALL ASN1Free_AlternativeNodeID(AlternativeNodeID *val);
static void ASN1CALL ASN1Free_ConferenceDescriptor(ConferenceDescriptor *val);
static void ASN1CALL ASN1Free_NodeRecord(NodeRecord *val);
static void ASN1CALL ASN1Free_SessionKey(SessionKey *val);
static void ASN1CALL ASN1Free_ApplicationRecord(ApplicationRecord *val);
static void ASN1CALL ASN1Free_CapabilityID(CapabilityID *val);
static void ASN1CALL ASN1Free_ApplicationInvokeSpecifier(ApplicationInvokeSpecifier *val);
static void ASN1CALL ASN1Free_RegistryKey(RegistryKey *val);
static void ASN1CALL ASN1Free_RegistryItem(RegistryItem *val);
static void ASN1CALL ASN1Free_SetOfPrivileges(PSetOfPrivileges *val);
static void ASN1CALL ASN1Free_ConferenceCreateRequest(ConferenceCreateRequest *val);
static void ASN1CALL ASN1Free_ConferenceCreateResponse(ConferenceCreateResponse *val);
static void ASN1CALL ASN1Free_ConferenceQueryRequest(ConferenceQueryRequest *val);
static void ASN1CALL ASN1Free_ConferenceQueryResponse(ConferenceQueryResponse *val);
static void ASN1CALL ASN1Free_ConferenceInviteRequest(ConferenceInviteRequest *val);
static void ASN1CALL ASN1Free_ConferenceInviteResponse(ConferenceInviteResponse *val);
static void ASN1CALL ASN1Free_ConferenceAddRequest(ConferenceAddRequest *val);
static void ASN1CALL ASN1Free_ConferenceAddResponse(ConferenceAddResponse *val);
static void ASN1CALL ASN1Free_ConferenceTransferRequest(ConferenceTransferRequest *val);
static void ASN1CALL ASN1Free_ConferenceTransferResponse(ConferenceTransferResponse *val);
static void ASN1CALL ASN1Free_ConferenceTransferIndication(ConferenceTransferIndication *val);
static void ASN1CALL ASN1Free_RosterUpdateIndication(RosterUpdateIndication *val);
static void ASN1CALL ASN1Free_ApplicationInvokeIndication(ApplicationInvokeIndication *val);
static void ASN1CALL ASN1Free_RegistryRegisterChannelRequest(RegistryRegisterChannelRequest *val);
static void ASN1CALL ASN1Free_RegistryAssignTokenRequest(RegistryAssignTokenRequest *val);
static void ASN1CALL ASN1Free_RegistrySetParameterRequest(RegistrySetParameterRequest *val);
static void ASN1CALL ASN1Free_RegistryRetrieveEntryRequest(RegistryRetrieveEntryRequest *val);
static void ASN1CALL ASN1Free_RegistryDeleteEntryRequest(RegistryDeleteEntryRequest *val);
static void ASN1CALL ASN1Free_RegistryMonitorEntryRequest(RegistryMonitorEntryRequest *val);
static void ASN1CALL ASN1Free_RegistryMonitorEntryIndication(RegistryMonitorEntryIndication *val);
static void ASN1CALL ASN1Free_RegistryResponse(RegistryResponse *val);
static void ASN1CALL ASN1Free_ConductorPermissionGrantIndication(ConductorPermissionGrantIndication *val);
static void ASN1CALL ASN1Free_ConferenceAssistanceIndication(ConferenceAssistanceIndication *val);
static void ASN1CALL ASN1Free_TextMessageIndication(TextMessageIndication *val);
static void ASN1CALL ASN1Free_NonStandardPDU(NonStandardPDU *val);
static void ASN1CALL ASN1Free_ConnectData(ConnectData *val);
static void ASN1CALL ASN1Free_IndicationPDU(IndicationPDU *val);
static void ASN1CALL ASN1Free_ApplicationUpdate(ApplicationUpdate *val);
static void ASN1CALL ASN1Free_RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set(RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set *val);
static void ASN1CALL ASN1Free_RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set(RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set *val);
static void ASN1CALL ASN1Free_RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set(RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set *val);
static void ASN1CALL ASN1Free_NodeUpdate(NodeUpdate *val);
static void ASN1CALL ASN1Free_RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set(RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set *val);
static void ASN1CALL ASN1Free_RosterUpdateIndication_node_information_node_record_list_node_record_update_Set(RosterUpdateIndication_node_information_node_record_list_node_record_update_Set *val);
static void ASN1CALL ASN1Free_SetOfApplicationRecordUpdates(PSetOfApplicationRecordUpdates *val);
static void ASN1CALL ASN1Free_SetOfApplicationRecordRefreshes(PSetOfApplicationRecordRefreshes *val);
static void ASN1CALL ASN1Free_SetOfApplicationCapabilityRefreshes(PSetOfApplicationCapabilityRefreshes *val);
static void ASN1CALL ASN1Free_SetOfNodeRecordUpdates(PSetOfNodeRecordUpdates *val);
static void ASN1CALL ASN1Free_SetOfNodeRecordRefreshes(PSetOfNodeRecordRefreshes *val);
static void ASN1CALL ASN1Free_ApplicationRecord_non_collapsing_capabilities_Set(ApplicationRecord_non_collapsing_capabilities_Set *val);
static void ASN1CALL ASN1Free_ApplicationInvokeSpecifier_expected_capability_set_Set(ApplicationInvokeSpecifier_expected_capability_set_Set *val);
static void ASN1CALL ASN1Free_RosterUpdateIndication_application_information_Set(RosterUpdateIndication_application_information_Set *val);
static void ASN1CALL ASN1Free_ApplicationProtocolEntityList(PApplicationProtocolEntityList *val);
static void ASN1CALL ASN1Free_SetOfApplicationInformation(PSetOfApplicationInformation *val);
static void ASN1CALL ASN1Free_SetOfConferenceDescriptors(PSetOfConferenceDescriptors *val);
static void ASN1CALL ASN1Free_SetOfExpectedCapabilities(PSetOfExpectedCapabilities *val);
static void ASN1CALL ASN1Free_SetOfNonCollapsingCapabilities(PSetOfNonCollapsingCapabilities *val);
static void ASN1CALL ASN1Free_NetworkAddress(NetworkAddress *val);
static void ASN1CALL ASN1Free_ChallengeRequestResponse(ChallengeRequestResponse *val);
static void ASN1CALL ASN1Free_SetOfChallengeItems(PSetOfChallengeItems *val);
static void ASN1CALL ASN1Free_UserData_Set(UserData_Set *val);
static void ASN1CALL ASN1Free_SetOfUserData(PSetOfUserData *val);
static void ASN1CALL ASN1Free_PasswordChallengeRequestResponse(PasswordChallengeRequestResponse *val);
static void ASN1CALL ASN1Free_SetOfNetworkAddresses(PSetOfNetworkAddresses *val);
static void ASN1CALL ASN1Free_ConferenceJoinRequest(ConferenceJoinRequest *val);
static void ASN1CALL ASN1Free_ConferenceJoinResponse(ConferenceJoinResponse *val);
static void ASN1CALL ASN1Free_ConnectGCCPDU(ConnectGCCPDU *val);
static void ASN1CALL ASN1Free_RequestPDU(RequestPDU *val);
static void ASN1CALL ASN1Free_FunctionNotSupportedResponse(FunctionNotSupportedResponse *val);
static void ASN1CALL ASN1Free_ResponsePDU(ResponsePDU *val);
static void ASN1CALL ASN1Free_GCCPDU(GCCPDU *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[3] = {
    (ASN1EncFun_t) ASN1Enc_ConnectData,
    (ASN1EncFun_t) ASN1Enc_ConnectGCCPDU,
    (ASN1EncFun_t) ASN1Enc_GCCPDU,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[3] = {
    (ASN1DecFun_t) ASN1Dec_ConnectData,
    (ASN1DecFun_t) ASN1Dec_ConnectGCCPDU,
    (ASN1DecFun_t) ASN1Dec_GCCPDU,
};
static const ASN1FreeFun_t freefntab[3] = {
    (ASN1FreeFun_t) ASN1Free_ConnectData,
    (ASN1FreeFun_t) ASN1Free_ConnectGCCPDU,
    (ASN1FreeFun_t) ASN1Free_GCCPDU,
};
static const ULONG sizetab[3] = {
    SIZE_GCCPDU_Module_PDU_0,
    SIZE_GCCPDU_Module_PDU_1,
    SIZE_GCCPDU_Module_PDU_2,
};

/* forward declarations of values: */
extern ASN1char32_t simpleTextFirstCharacter_chars[1];
extern ASN1char32_t simpleTextLastCharacter_chars[1];
/* definitions of value components: */
static const struct ASN1objectidentifier_s t124identifier_object_list[6] = {
    { (ASN1objectidentifier_t) &(t124identifier_object_list[1]), 0 },
    { (ASN1objectidentifier_t) &(t124identifier_object_list[2]), 0 },
    { (ASN1objectidentifier_t) &(t124identifier_object_list[3]), 20 },
    { (ASN1objectidentifier_t) &(t124identifier_object_list[4]), 124 },
    { (ASN1objectidentifier_t) &(t124identifier_object_list[5]), 0 },
    { NULL, 1 }
};
static ASN1objectidentifier_t t124identifier_object = (ASN1objectidentifier_t) t124identifier_object_list;
static ASN1char32_t simpleTextFirstCharacter_chars[1] = { 0x0 };
static ASN1char32_t simpleTextLastCharacter_chars[1] = { 0xff };
/* definitions of values: */
Key t124identifier = { 1 };
ASN1char32string_t simpleTextFirstCharacter = { 1, simpleTextFirstCharacter_chars };
ASN1char32string_t simpleTextLastCharacter = { 1, simpleTextLastCharacter_chars };

void ASN1CALL GCCPDU_Module_Startup(void)
{
    GCCPDU_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 3, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x636367);
    t124identifier.u.object = t124identifier_object;
}

void ASN1CALL GCCPDU_Module_Cleanup(void)
{
    ASN1_CloseModule(GCCPDU_Module);
    GCCPDU_Module = NULL;
}

static int ASN1CALL ASN1Enc_ApplicationCapabilitiesList(ASN1encoding_t enc, ApplicationCapabilitiesList *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_SetOfApplicationCapabilityRefreshes(enc, &(val)->u.application_capability_refresh))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ApplicationCapabilitiesList(ASN1decoding_t dec, ApplicationCapabilitiesList *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_SetOfApplicationCapabilityRefreshes(dec, &(val)->u.application_capability_refresh))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ApplicationCapabilitiesList(ApplicationCapabilitiesList *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_SetOfApplicationCapabilityRefreshes(&(val)->u.application_capability_refresh);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ApplicationRecordList(ASN1encoding_t enc, ApplicationRecordList *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_SetOfApplicationRecordRefreshes(enc, &(val)->u.application_record_refresh))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_SetOfApplicationRecordUpdates(enc, &(val)->u.application_record_update))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ApplicationRecordList(ASN1decoding_t dec, ApplicationRecordList *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_SetOfApplicationRecordRefreshes(dec, &(val)->u.application_record_refresh))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_SetOfApplicationRecordUpdates(dec, &(val)->u.application_record_update))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ApplicationRecordList(ApplicationRecordList *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_SetOfApplicationRecordRefreshes(&(val)->u.application_record_refresh);
	    break;
	case 3:
	    ASN1Free_SetOfApplicationRecordUpdates(&(val)->u.application_record_update);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_HighLayerCompatibility(ASN1encoding_t enc, HighLayerCompatibility *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->telephony3kHz))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->telephony7kHz))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videotelephony))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoconference))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audiographic))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audiovisual))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multimedia))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_HighLayerCompatibility(ASN1decoding_t dec, HighLayerCompatibility *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->telephony3kHz))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->telephony7kHz))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videotelephony))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoconference))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audiographic))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audiovisual))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multimedia))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TransferModes(ASN1encoding_t enc, TransferModes *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->speech))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->voice_band))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_56k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_64k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_128k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_192k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_256k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_320k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_384k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_512k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_768k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_1152k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_1472k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_1536k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_1920k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->packet_mode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->frame_mode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atm))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransferModes(ASN1decoding_t dec, TransferModes *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->speech))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->voice_band))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_56k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_64k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_128k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_192k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_256k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_320k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_384k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_512k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_768k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_1152k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_1472k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_1536k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_1920k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->packet_mode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->frame_mode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atm))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TransportConnectionType(ASN1encoding_t enc, TransportConnectionType *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->nsap_address, 1, 20, 5))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->transport_selector))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportConnectionType(ASN1decoding_t dec, TransportConnectionType *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->nsap_address, 1, 20, 5))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->transport_selector))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportConnectionType(TransportConnectionType *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->transport_selector);
	}
    }
}

static ASN1stringtableentry_t AggregateChannel_international_number_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t AggregateChannel_international_number_StringTable = {
    1, AggregateChannel_international_number_StringTableEntries
};

static ASN1stringtableentry_t AggregateChannel_sub_address_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t AggregateChannel_sub_address_StringTable = {
    1, AggregateChannel_sub_address_StringTableEntries
};

static ASN1stringtableentry_t AggregateChannel_extra_dialing_string_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 },
    { 48, 57, 3 },
};

static ASN1stringtable_t AggregateChannel_extra_dialing_string_StringTable = {
    4, AggregateChannel_extra_dialing_string_StringTableEntries
};

static int ASN1CALL ASN1Enc_AggregateChannel(ASN1encoding_t enc, AggregateChannel *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1Enc_TransferModes(enc, &(val)->transfer_modes))
	return 0;
    t = lstrlenA((val)->international_number);
    if (!ASN1PEREncBitVal(enc, 4, t - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->international_number, 4, &AggregateChannel_international_number_StringTable))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->sub_address);
	if (!ASN1PEREncBitVal(enc, 6, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->sub_address, 4, &AggregateChannel_sub_address_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 8, ((val)->extra_dialing_string).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableChar16String(enc, ((val)->extra_dialing_string).length, ((val)->extra_dialing_string).value, 4, &AggregateChannel_extra_dialing_string_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_HighLayerCompatibility(enc, &(val)->high_layer_compatibility))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AggregateChannel(ASN1decoding_t dec, AggregateChannel *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1Dec_TransferModes(dec, &(val)->transfer_modes))
	return 0;
    if (!ASN1PERDecU32Val(dec, 4, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
	/* Start of HANDCODED FIX FOR pdu security Issue */
	if (l >= sizeof((val)->international_number))
	{		
		ASN1DecSetError(dec, ASN1_ERR_LARGE);
		return 0; 
	}
	/* End of HANDCODED FIX FOR H225 security Issue */
    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->international_number, 4, &AggregateChannel_international_number_StringTable))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 6, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	/* Start of HANDCODED FIX FOR pdu security Issue */
	if (l >= sizeof((val)->sub_address))
	{		
		ASN1DecSetError(dec, ASN1_ERR_LARGE);
		return 0; 
	}
	/* End of HANDCODED FIX FOR pdu security Issue */
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->sub_address, 4, &AggregateChannel_sub_address_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 8, &((val)->extra_dialing_string).length))
	    return 0;
	((val)->extra_dialing_string).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecTableChar16String(dec, ((val)->extra_dialing_string).length, &((val)->extra_dialing_string).value, 4, &AggregateChannel_extra_dialing_string_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_HighLayerCompatibility(dec, &(val)->high_layer_compatibility))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AggregateChannel(AggregateChannel *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->extra_dialing_string);
	}
    }
}

static int ASN1CALL ASN1Enc_NodeRecordList(ASN1encoding_t enc, NodeRecordList *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_SetOfNodeRecordRefreshes(enc, &(val)->u.node_record_refresh))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_SetOfNodeRecordUpdates(enc, &(val)->u.node_record_update))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NodeRecordList(ASN1decoding_t dec, NodeRecordList *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_SetOfNodeRecordRefreshes(dec, &(val)->u.node_record_refresh))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_SetOfNodeRecordUpdates(dec, &(val)->u.node_record_update))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NodeRecordList(NodeRecordList *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_SetOfNodeRecordRefreshes(&(val)->u.node_record_refresh);
	    break;
	case 3:
	    ASN1Free_SetOfNodeRecordUpdates(&(val)->u.node_record_update);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_WaitingList(ASN1encoding_t enc, PWaitingList *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WaitingList_ElmFn);
}

static int ASN1CALL ASN1Enc_WaitingList_ElmFn(ASN1encoding_t enc, PWaitingList val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WaitingList(ASN1decoding_t dec, PWaitingList *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WaitingList_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WaitingList_ElmFn(ASN1decoding_t dec, PWaitingList val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1001;
    return 1;
}

static void ASN1CALL ASN1Free_WaitingList(PWaitingList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WaitingList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WaitingList_ElmFn(PWaitingList val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_PermissionList(ASN1encoding_t enc, PPermissionList *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PermissionList_ElmFn, 0, 65535, 16);
}

static int ASN1CALL ASN1Enc_PermissionList_ElmFn(ASN1encoding_t enc, PPermissionList val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PermissionList(ASN1decoding_t dec, PPermissionList *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PermissionList_ElmFn, sizeof(**val), 0, 65535, 16);
}

static int ASN1CALL ASN1Dec_PermissionList_ElmFn(ASN1decoding_t dec, PPermissionList val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1001;
    return 1;
}

static void ASN1CALL ASN1Free_PermissionList(PPermissionList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PermissionList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PermissionList_ElmFn(PPermissionList val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SetOfDestinationNodes(ASN1encoding_t enc, PSetOfDestinationNodes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfDestinationNodes_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfDestinationNodes_ElmFn(ASN1encoding_t enc, PSetOfDestinationNodes val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfDestinationNodes(ASN1decoding_t dec, PSetOfDestinationNodes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfDestinationNodes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfDestinationNodes_ElmFn(ASN1decoding_t dec, PSetOfDestinationNodes val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1001;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfDestinationNodes(PSetOfDestinationNodes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfDestinationNodes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfDestinationNodes_ElmFn(PSetOfDestinationNodes val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_NodeInformation(ASN1encoding_t enc, NodeInformation *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_NodeRecordList(enc, &(val)->node_record_list))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->roster_instance_number))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->nodes_are_added))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->nodes_are_removed))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NodeInformation(ASN1decoding_t dec, NodeInformation *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_NodeRecordList(dec, &(val)->node_record_list))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->roster_instance_number))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->nodes_are_added))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->nodes_are_removed))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NodeInformation(NodeInformation *val)
{
    if (val) {
	ASN1Free_NodeRecordList(&(val)->node_record_list);
    }
}

static int ASN1CALL ASN1Enc_SetOfTransferringNodesIn(ASN1encoding_t enc, PSetOfTransferringNodesIn *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfTransferringNodesIn_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfTransferringNodesIn_ElmFn(ASN1encoding_t enc, PSetOfTransferringNodesIn val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfTransferringNodesIn(ASN1decoding_t dec, PSetOfTransferringNodesIn *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfTransferringNodesIn_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfTransferringNodesIn_ElmFn(ASN1decoding_t dec, PSetOfTransferringNodesIn val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1001;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfTransferringNodesIn(PSetOfTransferringNodesIn *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfTransferringNodesIn_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfTransferringNodesIn_ElmFn(PSetOfTransferringNodesIn val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SetOfTransferringNodesRs(ASN1encoding_t enc, PSetOfTransferringNodesRs *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfTransferringNodesRs_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfTransferringNodesRs_ElmFn(ASN1encoding_t enc, PSetOfTransferringNodesRs val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfTransferringNodesRs(ASN1decoding_t dec, PSetOfTransferringNodesRs *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfTransferringNodesRs_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfTransferringNodesRs_ElmFn(ASN1decoding_t dec, PSetOfTransferringNodesRs val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1001;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfTransferringNodesRs(PSetOfTransferringNodesRs *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfTransferringNodesRs_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfTransferringNodesRs_ElmFn(PSetOfTransferringNodesRs val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SetOfTransferringNodesRq(ASN1encoding_t enc, PSetOfTransferringNodesRq *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfTransferringNodesRq_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfTransferringNodesRq_ElmFn(ASN1encoding_t enc, PSetOfTransferringNodesRq val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfTransferringNodesRq(ASN1decoding_t dec, PSetOfTransferringNodesRq *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfTransferringNodesRq_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfTransferringNodesRq_ElmFn(ASN1decoding_t dec, PSetOfTransferringNodesRq val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1001;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfTransferringNodesRq(PSetOfTransferringNodesRq *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfTransferringNodesRq_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfTransferringNodesRq_ElmFn(PSetOfTransferringNodesRq val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RegistryEntryOwnerOwned(ASN1encoding_t enc, RegistryEntryOwnerOwned *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_id - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryEntryOwnerOwned(ASN1decoding_t dec, RegistryEntryOwnerOwned *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_id))
	return 0;
    (val)->node_id += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ParticipantsList(ASN1encoding_t enc, PParticipantsList *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ParticipantsList_ElmFn);
}

static int ASN1CALL ASN1Enc_ParticipantsList_ElmFn(ASN1encoding_t enc, PParticipantsList val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val->value).length))
	return 0;
    if (!ASN1PEREncChar16String(enc, (val->value).length, (val->value).value, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ParticipantsList(ASN1decoding_t dec, PParticipantsList *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ParticipantsList_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ParticipantsList_ElmFn(ASN1decoding_t dec, PParticipantsList val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val->value).length))
	return 0;
    if (!ASN1PERDecChar16String(dec, (val->value).length, &(val->value).value, 16))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ParticipantsList(PParticipantsList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ParticipantsList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ParticipantsList_ElmFn(PParticipantsList val)
{
    if (val) {
	ASN1char16string_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Key(ASN1encoding_t enc, Key *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.h221_non_standard, 4, 255, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Key(ASN1decoding_t dec, Key *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.h221_non_standard, 4, 255, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Key(Key *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1objectidentifier_free(&(val)->u.object);
	    break;
	case 2:
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val)
{
    if (!ASN1Enc_Key(enc, &(val)->key))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val)
{
    if (!ASN1Dec_Key(dec, &(val)->key))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val)
{
    if (val) {
	ASN1Free_Key(&(val)->key);
	ASN1octetstring_free(&(val)->data);
    }
}

static ASN1stringtableentry_t Password_numeric_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t Password_numeric_StringTable = {
    1, Password_numeric_StringTableEntries
};

static ASN1stringtableentry_t Password_password_text_StringTableEntries[] = {
    { 0, 255, 0 },
};

static ASN1stringtable_t Password_password_text_StringTable = {
    1, Password_password_text_StringTableEntries
};

static int ASN1CALL ASN1Enc_Password(ASN1encoding_t enc, Password *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    t = lstrlenA((val)->numeric);
    if (!ASN1PEREncBitVal(enc, 8, t - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->numeric, 4, &Password_numeric_StringTable))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->password_text).length))
	    return 0;
	if (!ASN1PEREncTableChar16String(enc, ((val)->password_text).length, ((val)->password_text).value, 8, &Password_password_text_StringTable))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Password(ASN1decoding_t dec, Password *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 8, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
	/* Start of HANDCODED FIX FOR pdu security Issue */
	if (l >= sizeof((val)->numeric))
	{		
		ASN1DecSetError(dec, ASN1_ERR_LARGE);
		return 0; 
	}
	/* End of HANDCODED FIX FOR pdu security Issue */
    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->numeric, 4, &Password_numeric_StringTable))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->password_text).length))
	    return 0;
	if (!ASN1PERDecTableChar16String(dec, ((val)->password_text).length, &((val)->password_text).value, 8, &Password_password_text_StringTable))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Password(Password *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1char16string_free(&(val)->password_text);
	}
    }
}

static ASN1stringtableentry_t PasswordSelector_password_selector_numeric_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t PasswordSelector_password_selector_numeric_StringTable = {
    1, PasswordSelector_password_selector_numeric_StringTableEntries
};

static ASN1stringtableentry_t PasswordSelector_password_selector_text_StringTableEntries[] = {
    { 0, 255, 0 },
};

static ASN1stringtable_t PasswordSelector_password_selector_text_StringTable = {
    1, PasswordSelector_password_selector_text_StringTableEntries
};

static int ASN1CALL ASN1Enc_PasswordSelector(ASN1encoding_t enc, PasswordSelector *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	t = lstrlenA((val)->u.password_selector_numeric);
	if (!ASN1PEREncBitVal(enc, 8, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.password_selector_numeric, 4, &PasswordSelector_password_selector_numeric_StringTable))
	    return 0;
	break;
    case 2:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->u.password_selector_text).length))
	    return 0;
	if (!ASN1PEREncTableChar16String(enc, ((val)->u.password_selector_text).length, ((val)->u.password_selector_text).value, 8, &PasswordSelector_password_selector_text_StringTable))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PasswordSelector(ASN1decoding_t dec, PasswordSelector *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 8, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	/* Start of HANDCODED FIX FOR pdu security Issue */
	if (l >= sizeof((val)->u.password_selector_numeric))
	{		
		ASN1DecSetError(dec, ASN1_ERR_LARGE);
		return 0; 
	}
	/* End of HANDCODED FIX FOR pdu security Issue */
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.password_selector_numeric, 4, &PasswordSelector_password_selector_numeric_StringTable))
	    return 0;
	break;
    case 2:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->u.password_selector_text).length))
	    return 0;
	if (!ASN1PERDecTableChar16String(dec, ((val)->u.password_selector_text).length, &((val)->u.password_selector_text).value, 8, &PasswordSelector_password_selector_text_StringTable))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PasswordSelector(PasswordSelector *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	case 2:
	    ASN1char16string_free(&(val)->u.password_selector_text);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ChallengeResponseItem(ASN1encoding_t enc, ChallengeResponseItem *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_PasswordSelector(enc, &(val)->u.password_string))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_SetOfUserData(enc, &(val)->u.set_of_response_data))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ChallengeResponseItem(ASN1decoding_t dec, ChallengeResponseItem *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_PasswordSelector(dec, &(val)->u.password_string))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_SetOfUserData(dec, &(val)->u.set_of_response_data))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ChallengeResponseItem(ChallengeResponseItem *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_PasswordSelector(&(val)->u.password_string);
	    break;
	case 2:
	    ASN1Free_SetOfUserData(&(val)->u.set_of_response_data);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ChallengeResponseAlgorithm(ASN1encoding_t enc, ChallengeResponseAlgorithm *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.non_standard_algorithm))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ChallengeResponseAlgorithm(ASN1decoding_t dec, ChallengeResponseAlgorithm *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.non_standard_algorithm))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ChallengeResponseAlgorithm(ChallengeResponseAlgorithm *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_NonStandardParameter(&(val)->u.non_standard_algorithm);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ChallengeItem(ASN1encoding_t enc, ChallengeItem *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_ChallengeResponseAlgorithm(enc, &(val)->response_algorithm))
	return 0;
    if (!ASN1Enc_SetOfUserData(enc, &(val)->set_of_challenge_data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChallengeItem(ASN1decoding_t dec, ChallengeItem *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_ChallengeResponseAlgorithm(dec, &(val)->response_algorithm))
	return 0;
    if (!ASN1Dec_SetOfUserData(dec, &(val)->set_of_challenge_data))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ChallengeItem(ChallengeItem *val)
{
    if (val) {
	ASN1Free_ChallengeResponseAlgorithm(&(val)->response_algorithm);
	ASN1Free_SetOfUserData(&(val)->set_of_challenge_data);
    }
}

static int ASN1CALL ASN1Enc_ChallengeRequest(ASN1encoding_t enc, ChallengeRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncInteger(enc, (val)->challenge_tag))
	return 0;
    if (!ASN1Enc_SetOfChallengeItems(enc, &(val)->set_of_challenge_items))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChallengeRequest(ASN1decoding_t dec, ChallengeRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecInteger(dec, &(val)->challenge_tag))
	return 0;
    if (!ASN1Dec_SetOfChallengeItems(dec, &(val)->set_of_challenge_items))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ChallengeRequest(ChallengeRequest *val)
{
    if (val) {
	ASN1Free_SetOfChallengeItems(&(val)->set_of_challenge_items);
    }
}

static int ASN1CALL ASN1Enc_ChallengeResponse(ASN1encoding_t enc, ChallengeResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncInteger(enc, (val)->challenge_tag))
	return 0;
    if (!ASN1Enc_ChallengeResponseAlgorithm(enc, &(val)->response_algorithm))
	return 0;
    if (!ASN1Enc_ChallengeResponseItem(enc, &(val)->response_item))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChallengeResponse(ASN1decoding_t dec, ChallengeResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecInteger(dec, &(val)->challenge_tag))
	return 0;
    if (!ASN1Dec_ChallengeResponseAlgorithm(dec, &(val)->response_algorithm))
	return 0;
    if (!ASN1Dec_ChallengeResponseItem(dec, &(val)->response_item))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ChallengeResponse(ChallengeResponse *val)
{
    if (val) {
	ASN1Free_ChallengeResponseAlgorithm(&(val)->response_algorithm);
	ASN1Free_ChallengeResponseItem(&(val)->response_item);
    }
}

static ASN1stringtableentry_t ConferenceName_numeric_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t ConferenceName_numeric_StringTable = {
    1, ConferenceName_numeric_StringTableEntries
};

static ASN1stringtableentry_t ConferenceName_conference_name_text_StringTableEntries[] = {
    { 0, 255, 0 },
};

static ASN1stringtable_t ConferenceName_conference_name_text_StringTable = {
    1, ConferenceName_conference_name_text_StringTableEntries
};

static int ASN1CALL ASN1Enc_ConferenceName(ASN1encoding_t enc, ConferenceName *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    t = lstrlenA((val)->numeric);
    if (!ASN1PEREncBitVal(enc, 8, t - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->numeric, 4, &ConferenceName_numeric_StringTable))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->conference_name_text).length))
	    return 0;
	if (!ASN1PEREncTableChar16String(enc, ((val)->conference_name_text).length, ((val)->conference_name_text).value, 8, &ConferenceName_conference_name_text_StringTable))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceName(ASN1decoding_t dec, ConferenceName *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 8, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
	/* Start of HANDCODED FIX FOR pdu security Issue */
	if (l >= sizeof((val)->numeric))
	{		
		ASN1DecSetError(dec, ASN1_ERR_LARGE);
		return 0; 
	}
	/* End of HANDCODED FIX FOR pdu security Issue */
    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->numeric, 4, &ConferenceName_numeric_StringTable))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->conference_name_text).length))
	    return 0;
	if (!ASN1PERDecTableChar16String(dec, ((val)->conference_name_text).length, &((val)->conference_name_text).value, 8, &ConferenceName_conference_name_text_StringTable))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceName(ConferenceName *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1char16string_free(&(val)->conference_name_text);
	}
    }
}

static ASN1stringtableentry_t ConferenceNameSelector_name_selector_numeric_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t ConferenceNameSelector_name_selector_numeric_StringTable = {
    1, ConferenceNameSelector_name_selector_numeric_StringTableEntries
};

static ASN1stringtableentry_t ConferenceNameSelector_name_selector_text_StringTableEntries[] = {
    { 0, 255, 0 },
};

static ASN1stringtable_t ConferenceNameSelector_name_selector_text_StringTable = {
    1, ConferenceNameSelector_name_selector_text_StringTableEntries
};

static int ASN1CALL ASN1Enc_ConferenceNameSelector(ASN1encoding_t enc, ConferenceNameSelector *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	t = lstrlenA((val)->u.name_selector_numeric);
	if (!ASN1PEREncBitVal(enc, 8, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.name_selector_numeric, 4, &ConferenceNameSelector_name_selector_numeric_StringTable))
	    return 0;
	break;
    case 2:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->u.name_selector_text).length))
	    return 0;
	if (!ASN1PEREncTableChar16String(enc, ((val)->u.name_selector_text).length, ((val)->u.name_selector_text).value, 8, &ConferenceNameSelector_name_selector_text_StringTable))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceNameSelector(ASN1decoding_t dec, ConferenceNameSelector *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 8, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	/* Start of HANDCODED FIX FOR pdu security Issue */
	if (l >= sizeof((val)->u.name_selector_numeric))
	{		
		ASN1DecSetError(dec, ASN1_ERR_LARGE);
		return 0; 
	}
	/* End of HANDCODED FIX FOR pdu security Issue */
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.name_selector_numeric, 4, &ConferenceNameSelector_name_selector_numeric_StringTable))
	    return 0;
	break;
    case 2:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->u.name_selector_text).length))
	    return 0;
	if (!ASN1PERDecTableChar16String(dec, ((val)->u.name_selector_text).length, &((val)->u.name_selector_text).value, 8, &ConferenceNameSelector_name_selector_text_StringTable))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceNameSelector(ConferenceNameSelector *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	case 2:
	    ASN1char16string_free(&(val)->u.name_selector_text);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_NodeProperties(ASN1encoding_t enc, NodeProperties *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->device_is_manager))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->device_is_peripheral))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NodeProperties(ASN1decoding_t dec, NodeProperties *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->device_is_manager))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->device_is_peripheral))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_AsymmetryIndicator(ASN1encoding_t enc, AsymmetryIndicator *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	l = ASN1uint32_uoctets((val)->u.unknown);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->u.unknown))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AsymmetryIndicator(ASN1decoding_t dec, AsymmetryIndicator *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->u.unknown))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_AlternativeNodeID(ASN1encoding_t enc, AlternativeNodeID *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->u.h243_node_id, 2))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AlternativeNodeID(ASN1decoding_t dec, AlternativeNodeID *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->u.h243_node_id, 2))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AlternativeNodeID(AlternativeNodeID *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	}
    }
}

static ASN1stringtableentry_t ConferenceDescriptor_conference_name_modifier_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t ConferenceDescriptor_conference_name_modifier_StringTable = {
    1, ConferenceDescriptor_conference_name_modifier_StringTableEntries
};

static int ASN1CALL ASN1Enc_ConferenceDescriptor(ASN1encoding_t enc, ConferenceDescriptor *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1Enc_ConferenceName(enc, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->conference_name_modifier);
	if (!ASN1PEREncBitVal(enc, 8, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->conference_name_modifier, 4, &ConferenceDescriptor_conference_name_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->conference_description).length))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->conference_description).length, ((val)->conference_description).value, 16))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_locked))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->clear_password_required))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_SetOfNetworkAddresses(enc, &(val)->descriptor_net_address))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceDescriptor(ASN1decoding_t dec, ConferenceDescriptor *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1Dec_ConferenceName(dec, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 8, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	/* Start of HANDCODED FIX FOR pdu security Issue */
	if (l >= sizeof((val)->conference_name_modifier))
	{		
		ASN1DecSetError(dec, ASN1_ERR_LARGE);
		return 0; 
	}
	/* End of HANDCODED FIX FOR pdu security Issue */
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->conference_name_modifier, 4, &ConferenceDescriptor_conference_name_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->conference_description).length))
	    return 0;
	if (!ASN1PERDecChar16String(dec, ((val)->conference_description).length, &((val)->conference_description).value, 16))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_locked))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->clear_password_required))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_SetOfNetworkAddresses(dec, &(val)->descriptor_net_address))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceDescriptor(ConferenceDescriptor *val)
{
    if (val) {
	ASN1Free_ConferenceName(&(val)->conference_name);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->conference_description);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_SetOfNetworkAddresses(&(val)->descriptor_net_address);
	}
    }
}

static int ASN1CALL ASN1Enc_NodeRecord(ASN1encoding_t enc, NodeRecord *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->superior_node - 1001))
	    return 0;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->node_type))
	return 0;
    if (!ASN1Enc_NodeProperties(enc, &(val)->node_properties))
	return 0;
    if ((val)->o[0] & 0x40) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->node_name).length))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->node_name).length, ((val)->node_name).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_ParticipantsList(enc, &(val)->participants_list))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->site_information).length))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->site_information).length, ((val)->site_information).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_SetOfNetworkAddresses(enc, &(val)->record_net_address))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_AlternativeNodeID(enc, &(val)->alternative_node_id))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->record_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NodeRecord(ASN1decoding_t dec, NodeRecord *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->superior_node))
	    return 0;
	(val)->superior_node += 1001;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->node_type))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (!ASN1Dec_NodeProperties(dec, &(val)->node_properties))
	return 0;
    if ((val)->o[0] & 0x40) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->node_name).length))
	    return 0;
	if (!ASN1PERDecChar16String(dec, ((val)->node_name).length, &((val)->node_name).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_ParticipantsList(dec, &(val)->participants_list))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->site_information).length))
	    return 0;
	if (!ASN1PERDecChar16String(dec, ((val)->site_information).length, &((val)->site_information).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_SetOfNetworkAddresses(dec, &(val)->record_net_address))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_AlternativeNodeID(dec, &(val)->alternative_node_id))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->record_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NodeRecord(NodeRecord *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->node_name);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_ParticipantsList(&(val)->participants_list);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1char16string_free(&(val)->site_information);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_SetOfNetworkAddresses(&(val)->record_net_address);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_AlternativeNodeID(&(val)->alternative_node_id);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_SetOfUserData(&(val)->record_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_SessionKey(ASN1encoding_t enc, SessionKey *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_Key(enc, &(val)->application_protocol_key))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->session_id - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SessionKey(ASN1decoding_t dec, SessionKey *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_Key(dec, &(val)->application_protocol_key))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->session_id))
	    return 0;
	(val)->session_id += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SessionKey(SessionKey *val)
{
    if (val) {
	ASN1Free_Key(&(val)->application_protocol_key);
    }
}

static int ASN1CALL ASN1Enc_ApplicationRecord(ASN1encoding_t enc, ApplicationRecord *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->application_is_active))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->is_conducting_capable))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 2, (val)->record_startup_channel))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->application_user_id - 1001))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_SetOfNonCollapsingCapabilities(enc, &(val)->non_collapsing_capabilities))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ApplicationRecord(ASN1decoding_t dec, ApplicationRecord *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->application_is_active))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->is_conducting_capable))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->record_startup_channel))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->application_user_id))
	    return 0;
	(val)->application_user_id += 1001;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_SetOfNonCollapsingCapabilities(dec, &(val)->non_collapsing_capabilities))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ApplicationRecord(ApplicationRecord *val)
{
    if (val) {
	if ((val)->o[0] & 0x20) {
	    ASN1Free_SetOfNonCollapsingCapabilities(&(val)->non_collapsing_capabilities);
	}
    }
}

static int ASN1CALL ASN1Enc_CapabilityID(ASN1encoding_t enc, CapabilityID *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.standard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_Key(enc, &(val)->u.capability_non_standard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CapabilityID(ASN1decoding_t dec, CapabilityID *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.standard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_Key(dec, &(val)->u.capability_non_standard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CapabilityID(CapabilityID *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_Key(&(val)->u.capability_non_standard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CapabilityClass(ASN1encoding_t enc, CapabilityClass *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PEREncUnsignedInteger(enc, (val)->u.unsigned_minimum))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncUnsignedInteger(enc, (val)->u.unsigned_maximum))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CapabilityClass(ASN1decoding_t dec, CapabilityClass *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PERDecUnsignedInteger(dec, &(val)->u.unsigned_minimum))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecUnsignedInteger(dec, &(val)->u.unsigned_maximum))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ApplicationInvokeSpecifier(ASN1encoding_t enc, ApplicationInvokeSpecifier *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_SessionKey(enc, &(val)->session_key))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SetOfExpectedCapabilities(enc, &(val)->expected_capability_set))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 2, (val)->invoke_startup_channel))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->invoke_is_mandatory))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ApplicationInvokeSpecifier(ASN1decoding_t dec, ApplicationInvokeSpecifier *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_SessionKey(dec, &(val)->session_key))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_SetOfExpectedCapabilities(dec, &(val)->expected_capability_set))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->invoke_startup_channel))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->invoke_is_mandatory))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ApplicationInvokeSpecifier(ApplicationInvokeSpecifier *val)
{
    if (val) {
	ASN1Free_SessionKey(&(val)->session_key);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SetOfExpectedCapabilities(&(val)->expected_capability_set);
	}
    }
}

static int ASN1CALL ASN1Enc_RegistryKey(ASN1encoding_t enc, RegistryKey *val)
{
    if (!ASN1Enc_SessionKey(enc, &(val)->session_key))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->resource_id, 0, 64, 7))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryKey(ASN1decoding_t dec, RegistryKey *val)
{
    if (!ASN1Dec_SessionKey(dec, &(val)->session_key))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->resource_id, 0, 64, 7))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistryKey(RegistryKey *val)
{
    if (val) {
	ASN1Free_SessionKey(&(val)->session_key);
    }
}

static int ASN1CALL ASN1Enc_RegistryItem(ASN1encoding_t enc, RegistryItem *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.channel_id - 1001))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.token_id - 16384))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.parameter, 0, 64, 7))
	    return 0;
	break;
    case 4:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryItem(ASN1decoding_t dec, RegistryItem *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.channel_id))
	    return 0;
	(val)->u.channel_id += 1001;
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.token_id))
	    return 0;
	(val)->u.token_id += 16384;
	break;
    case 3:
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.parameter, 0, 64, 7))
	    return 0;
	break;
    case 4:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistryItem(RegistryItem *val)
{
    if (val) {
	switch ((val)->choice) {
	case 3:
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RegistryEntryOwner(ASN1encoding_t enc, RegistryEntryOwner *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_RegistryEntryOwnerOwned(enc, &(val)->u.owned))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryEntryOwner(ASN1decoding_t dec, RegistryEntryOwner *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_RegistryEntryOwnerOwned(dec, &(val)->u.owned))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UserIDIndication(ASN1encoding_t enc, UserIDIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
#ifndef _WIN64
    if (!ASN1PEREncInteger(enc, (val)->tag))
	return 0;
#endif
    return 1;
}

static int ASN1CALL ASN1Dec_UserIDIndication(ASN1decoding_t dec, UserIDIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
#ifndef _WIN64
    if (!ASN1PERDecInteger(dec, &(val)->tag))
	return 0;
#endif
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_SetOfPrivileges(ASN1encoding_t enc, PSetOfPrivileges *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfPrivileges_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfPrivileges_ElmFn(ASN1encoding_t enc, PSetOfPrivileges val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfPrivileges(ASN1decoding_t dec, PSetOfPrivileges *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfPrivileges_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfPrivileges_ElmFn(ASN1decoding_t dec, PSetOfPrivileges val)
{
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &val->value))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SetOfPrivileges(PSetOfPrivileges *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfPrivileges_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfPrivileges_ElmFn(PSetOfPrivileges val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceCreateRequest(ASN1encoding_t enc, ConferenceCreateRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 8, (val)->o))
	return 0;
    if (!ASN1Enc_ConferenceName(enc, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Password(enc, &(val)->ccrq_convener_password))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Password(enc, &(val)->ccrq_password))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_locked))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_listed))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_conductible))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->termination_method))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_SetOfPrivileges(enc, &(val)->ccrq_conductor_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_SetOfPrivileges(enc, &(val)->ccrq_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_SetOfPrivileges(enc, &(val)->ccrq_non_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->ccrq_description).length))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->ccrq_description).length, ((val)->ccrq_description).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->ccrq_caller_id).length))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->ccrq_caller_id).length, ((val)->ccrq_caller_id).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->ccrq_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceCreateRequest(ASN1decoding_t dec, ConferenceCreateRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 8, (val)->o))
	return 0;
    if (!ASN1Dec_ConferenceName(dec, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_Password(dec, &(val)->ccrq_convener_password))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_Password(dec, &(val)->ccrq_password))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_locked))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_listed))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_conductible))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->termination_method))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_SetOfPrivileges(dec, &(val)->ccrq_conductor_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_SetOfPrivileges(dec, &(val)->ccrq_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_SetOfPrivileges(dec, &(val)->ccrq_non_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->ccrq_description).length))
	    return 0;
	if (!ASN1PERDecChar16String(dec, ((val)->ccrq_description).length, &((val)->ccrq_description).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->ccrq_caller_id).length))
	    return 0;
	if (!ASN1PERDecChar16String(dec, ((val)->ccrq_caller_id).length, &((val)->ccrq_caller_id).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->ccrq_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceCreateRequest(ConferenceCreateRequest *val)
{
    if (val) {
	ASN1Free_ConferenceName(&(val)->conference_name);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Password(&(val)->ccrq_convener_password);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Password(&(val)->ccrq_password);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_SetOfPrivileges(&(val)->ccrq_conductor_privs);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_SetOfPrivileges(&(val)->ccrq_conducted_privs);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_SetOfPrivileges(&(val)->ccrq_non_conducted_privs);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1char16string_free(&(val)->ccrq_description);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1char16string_free(&(val)->ccrq_caller_id);
	}
	if ((val)->o[0] & 0x1) {
	    ASN1Free_SetOfUserData(&(val)->ccrq_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceCreateResponse(ASN1encoding_t enc, ConferenceCreateResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_id - 1001))
	return 0;
#ifndef _WIN64
    if (!ASN1PEREncInteger(enc, (val)->tag))
	return 0;
#endif
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->result))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->ccrs_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceCreateResponse(ASN1decoding_t dec, ConferenceCreateResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_id))
	return 0;
    (val)->node_id += 1001;
#ifndef _WIN64
    if (!ASN1PERDecInteger(dec, &(val)->tag))
	return 0;
#endif
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->ccrs_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceCreateResponse(ConferenceCreateResponse *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SetOfUserData(&(val)->ccrs_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceQueryRequest(ASN1encoding_t enc, ConferenceQueryRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->node_type))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_AsymmetryIndicator(enc, &(val)->cqrq_asymmetry_indicator))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->cqrq_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceQueryRequest(ASN1decoding_t dec, ConferenceQueryRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->node_type))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_AsymmetryIndicator(dec, &(val)->cqrq_asymmetry_indicator))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->cqrq_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceQueryRequest(ConferenceQueryRequest *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SetOfUserData(&(val)->cqrq_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceQueryResponse(ASN1encoding_t enc, ConferenceQueryResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->node_type))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_AsymmetryIndicator(enc, &(val)->cqrs_asymmetry_indicator))
	    return 0;
    }
    if (!ASN1Enc_SetOfConferenceDescriptors(enc, &(val)->conference_list))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->result))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->cqrs_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceQueryResponse(ASN1decoding_t dec, ConferenceQueryResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->node_type))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_AsymmetryIndicator(dec, &(val)->cqrs_asymmetry_indicator))
	    return 0;
    }
    if (!ASN1Dec_SetOfConferenceDescriptors(dec, &(val)->conference_list))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->cqrs_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceQueryResponse(ConferenceQueryResponse *val)
{
    if (val) {
	ASN1Free_SetOfConferenceDescriptors(&(val)->conference_list);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SetOfUserData(&(val)->cqrs_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceInviteRequest(ASN1encoding_t enc, ConferenceInviteRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1Enc_ConferenceName(enc, &(val)->conference_name))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_id - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->top_node_id - 1001))
	return 0;
#ifndef _WIN64
    if (!ASN1PEREncInteger(enc, (val)->tag))
	return 0;
#endif
    if (!ASN1PEREncBoolean(enc, (val)->clear_password_required))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_locked))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_listed))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_conductible))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->termination_method))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SetOfPrivileges(enc, &(val)->cirq_conductor_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SetOfPrivileges(enc, &(val)->cirq_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_SetOfPrivileges(enc, &(val)->cirq_non_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->cirq_description).length))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->cirq_description).length, ((val)->cirq_description).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->cirq_caller_id).length))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->cirq_caller_id).length, ((val)->cirq_caller_id).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->cirq_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceInviteRequest(ASN1decoding_t dec, ConferenceInviteRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1Dec_ConferenceName(dec, &(val)->conference_name))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_id))
	return 0;
    (val)->node_id += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->top_node_id))
	return 0;
    (val)->top_node_id += 1001;
#ifndef _WIN64
    if (!ASN1PERDecInteger(dec, &(val)->tag))
	return 0;
#endif
    if (!ASN1PERDecBoolean(dec, &(val)->clear_password_required))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_locked))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_listed))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_conductible))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->termination_method))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_SetOfPrivileges(dec, &(val)->cirq_conductor_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_SetOfPrivileges(dec, &(val)->cirq_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_SetOfPrivileges(dec, &(val)->cirq_non_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->cirq_description).length))
	    return 0;
	if (!ASN1PERDecChar16String(dec, ((val)->cirq_description).length, &((val)->cirq_description).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->cirq_caller_id).length))
	    return 0;
	if (!ASN1PERDecChar16String(dec, ((val)->cirq_caller_id).length, &((val)->cirq_caller_id).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->cirq_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceInviteRequest(ConferenceInviteRequest *val)
{
    if (val) {
	ASN1Free_ConferenceName(&(val)->conference_name);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SetOfPrivileges(&(val)->cirq_conductor_privs);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SetOfPrivileges(&(val)->cirq_conducted_privs);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_SetOfPrivileges(&(val)->cirq_non_conducted_privs);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1char16string_free(&(val)->cirq_description);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1char16string_free(&(val)->cirq_caller_id);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_SetOfUserData(&(val)->cirq_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceInviteResponse(ASN1encoding_t enc, ConferenceInviteResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->result))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->cirs_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceInviteResponse(ASN1decoding_t dec, ConferenceInviteResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->cirs_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceInviteResponse(ConferenceInviteResponse *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SetOfUserData(&(val)->cirs_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceAddRequest(ASN1encoding_t enc, ConferenceAddRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_SetOfNetworkAddresses(enc, &(val)->add_request_net_address))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requesting_node - 1001))
	return 0;
#ifndef _WIN64
    if (!ASN1PEREncInteger(enc, (val)->tag))
	return 0;
#endif
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->adding_mcu - 1001))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->carq_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceAddRequest(ASN1decoding_t dec, ConferenceAddRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_SetOfNetworkAddresses(dec, &(val)->add_request_net_address))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requesting_node))
	return 0;
    (val)->requesting_node += 1001;
#ifndef _WIN64
    if (!ASN1PERDecInteger(dec, &(val)->tag))
	return 0;
#endif
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->adding_mcu))
	    return 0;
	(val)->adding_mcu += 1001;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->carq_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceAddRequest(ConferenceAddRequest *val)
{
    if (val) {
	ASN1Free_SetOfNetworkAddresses(&(val)->add_request_net_address);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SetOfUserData(&(val)->carq_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceAddResponse(ASN1encoding_t enc, ConferenceAddResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
#ifndef _WIN64
    if (!ASN1PEREncInteger(enc, (val)->tag))
	return 0;
#endif
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->result))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->cars_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceAddResponse(ASN1decoding_t dec, ConferenceAddResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
#ifndef _WIN64
    if (!ASN1PERDecInteger(dec, &(val)->tag))
	return 0;
#endif
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->cars_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceAddResponse(ConferenceAddResponse *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SetOfUserData(&(val)->cars_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceLockRequest(ASN1encoding_t enc, ConferenceLockRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceLockRequest(ASN1decoding_t dec, ConferenceLockRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceLockResponse(ASN1encoding_t enc, ConferenceLockResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->result))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceLockResponse(ASN1decoding_t dec, ConferenceLockResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceLockIndication(ASN1encoding_t enc, ConferenceLockIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceLockIndication(ASN1decoding_t dec, ConferenceLockIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceUnlockRequest(ASN1encoding_t enc, ConferenceUnlockRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceUnlockRequest(ASN1decoding_t dec, ConferenceUnlockRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceUnlockResponse(ASN1encoding_t enc, ConferenceUnlockResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->result))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceUnlockResponse(ASN1decoding_t dec, ConferenceUnlockResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceUnlockIndication(ASN1encoding_t enc, ConferenceUnlockIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceUnlockIndication(ASN1decoding_t dec, ConferenceUnlockIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceTerminateRequest(ASN1encoding_t enc, ConferenceTerminateRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->reason))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceTerminateRequest(ASN1decoding_t dec, ConferenceTerminateRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->reason))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceTerminateResponse(ASN1encoding_t enc, ConferenceTerminateResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->result))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceTerminateResponse(ASN1decoding_t dec, ConferenceTerminateResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceTerminateIndication(ASN1encoding_t enc, ConferenceTerminateIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->reason))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceTerminateIndication(ASN1decoding_t dec, ConferenceTerminateIndication *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->reason))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceEjectUserRequest(ASN1encoding_t enc, ConferenceEjectUserRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_to_eject - 1001))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceEjectUserRequest(ASN1decoding_t dec, ConferenceEjectUserRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_to_eject))
	return 0;
    (val)->node_to_eject += 1001;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	(val)->reason = 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceEjectUserResponse(ASN1encoding_t enc, ConferenceEjectUserResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_to_eject - 1001))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->result))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceEjectUserResponse(ASN1decoding_t dec, ConferenceEjectUserResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_to_eject))
	return 0;
    (val)->node_to_eject += 1001;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceEjectUserIndication(ASN1encoding_t enc, ConferenceEjectUserIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_to_eject - 1001))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->reason))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceEjectUserIndication(ASN1decoding_t dec, ConferenceEjectUserIndication *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_to_eject))
	return 0;
    (val)->node_to_eject += 1001;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->reason))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static ASN1stringtableentry_t ConferenceTransferRequest_ctrq_conference_modifier_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t ConferenceTransferRequest_ctrq_conference_modifier_StringTable = {
    1, ConferenceTransferRequest_ctrq_conference_modifier_StringTableEntries
};

static int ASN1CALL ASN1Enc_ConferenceTransferRequest(ASN1encoding_t enc, ConferenceTransferRequest *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1Enc_ConferenceNameSelector(enc, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->ctrq_conference_modifier);
	if (!ASN1PEREncBitVal(enc, 8, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->ctrq_conference_modifier, 4, &ConferenceTransferRequest_ctrq_conference_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SetOfNetworkAddresses(enc, &(val)->ctrq_net_address))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_SetOfTransferringNodesRq(enc, &(val)->ctrq_transferring_nodes))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_PasswordSelector(enc, &(val)->ctrq_password))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceTransferRequest(ASN1decoding_t dec, ConferenceTransferRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1Dec_ConferenceNameSelector(dec, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 8, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	/* Start of HANDCODED FIX FOR pdu security Issue */
	if (l >= sizeof((val)->ctrq_conference_modifier))
	{		
		ASN1DecSetError(dec, ASN1_ERR_LARGE);
		return 0; 
	}
	/* End of HANDCODED FIX FOR pdu security Issue */
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->ctrq_conference_modifier, 4, &ConferenceTransferRequest_ctrq_conference_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_SetOfNetworkAddresses(dec, &(val)->ctrq_net_address))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_SetOfTransferringNodesRq(dec, &(val)->ctrq_transferring_nodes))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_PasswordSelector(dec, &(val)->ctrq_password))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceTransferRequest(ConferenceTransferRequest *val)
{
    if (val) {
	ASN1Free_ConferenceNameSelector(&(val)->conference_name);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SetOfNetworkAddresses(&(val)->ctrq_net_address);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_SetOfTransferringNodesRq(&(val)->ctrq_transferring_nodes);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PasswordSelector(&(val)->ctrq_password);
	}
    }
}

static ASN1stringtableentry_t ConferenceTransferResponse_ctrs_conference_modifier_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t ConferenceTransferResponse_ctrs_conference_modifier_StringTable = {
    1, ConferenceTransferResponse_ctrs_conference_modifier_StringTableEntries
};

static int ASN1CALL ASN1Enc_ConferenceTransferResponse(ASN1encoding_t enc, ConferenceTransferResponse *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_ConferenceNameSelector(enc, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->ctrs_conference_modifier);
	if (!ASN1PEREncBitVal(enc, 8, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->ctrs_conference_modifier, 4, &ConferenceTransferResponse_ctrs_conference_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SetOfTransferringNodesRs(enc, &(val)->ctrs_transferring_nodes))
	    return 0;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->result))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceTransferResponse(ASN1decoding_t dec, ConferenceTransferResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_ConferenceNameSelector(dec, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 8, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	/* Start of HANDCODED FIX FOR pdu security Issue */
	if (l >= sizeof((val)->ctrs_conference_modifier))
	{		
		ASN1DecSetError(dec, ASN1_ERR_LARGE);
		return 0; 
	}
	/* End of HANDCODED FIX FOR pdu security Issue */
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->ctrs_conference_modifier, 4, &ConferenceTransferResponse_ctrs_conference_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_SetOfTransferringNodesRs(dec, &(val)->ctrs_transferring_nodes))
	    return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceTransferResponse(ConferenceTransferResponse *val)
{
    if (val) {
	ASN1Free_ConferenceNameSelector(&(val)->conference_name);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SetOfTransferringNodesRs(&(val)->ctrs_transferring_nodes);
	}
    }
}

static ASN1stringtableentry_t ConferenceTransferIndication_ctin_conference_modifier_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t ConferenceTransferIndication_ctin_conference_modifier_StringTable = {
    1, ConferenceTransferIndication_ctin_conference_modifier_StringTableEntries
};

static int ASN1CALL ASN1Enc_ConferenceTransferIndication(ASN1encoding_t enc, ConferenceTransferIndication *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1Enc_ConferenceNameSelector(enc, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->ctin_conference_modifier);
	if (!ASN1PEREncBitVal(enc, 8, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->ctin_conference_modifier, 4, &ConferenceTransferIndication_ctin_conference_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SetOfNetworkAddresses(enc, &(val)->ctin_net_address))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_SetOfTransferringNodesIn(enc, &(val)->ctin_transferring_nodes))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_PasswordSelector(enc, &(val)->ctin_password))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceTransferIndication(ASN1decoding_t dec, ConferenceTransferIndication *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1Dec_ConferenceNameSelector(dec, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 8, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	/* Start of HANDCODED FIX FOR pdu security Issue */
	if (l >= sizeof((val)->ctin_conference_modifier))
	{		
		ASN1DecSetError(dec, ASN1_ERR_LARGE);
		return 0; 
	}
	/* End of HANDCODED FIX FOR pdu security Issue */
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->ctin_conference_modifier, 4, &ConferenceTransferIndication_ctin_conference_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_SetOfNetworkAddresses(dec, &(val)->ctin_net_address))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_SetOfTransferringNodesIn(dec, &(val)->ctin_transferring_nodes))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_PasswordSelector(dec, &(val)->ctin_password))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceTransferIndication(ConferenceTransferIndication *val)
{
    if (val) {
	ASN1Free_ConferenceNameSelector(&(val)->conference_name);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SetOfNetworkAddresses(&(val)->ctin_net_address);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_SetOfTransferringNodesIn(&(val)->ctin_transferring_nodes);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PasswordSelector(&(val)->ctin_password);
	}
    }
}

static int ASN1CALL ASN1Enc_RosterUpdateIndication(ASN1encoding_t enc, RosterUpdateIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->refresh_is_full))
	return 0;
    if (!ASN1Enc_NodeInformation(enc, &(val)->node_information))
	return 0;
    if (!ASN1Enc_SetOfApplicationInformation(enc, &(val)->application_information))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RosterUpdateIndication(ASN1decoding_t dec, RosterUpdateIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->refresh_is_full))
	return 0;
    if (!ASN1Dec_NodeInformation(dec, &(val)->node_information))
	return 0;
    if (!ASN1Dec_SetOfApplicationInformation(dec, &(val)->application_information))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RosterUpdateIndication(RosterUpdateIndication *val)
{
    if (val) {
	ASN1Free_NodeInformation(&(val)->node_information);
	ASN1Free_SetOfApplicationInformation(&(val)->application_information);
    }
}

static int ASN1CALL ASN1Enc_ApplicationInvokeIndication(ASN1encoding_t enc, ApplicationInvokeIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_ApplicationProtocolEntityList(enc, &(val)->application_protocol_entity_list))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SetOfDestinationNodes(enc, &(val)->destination_nodes))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ApplicationInvokeIndication(ASN1decoding_t dec, ApplicationInvokeIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_ApplicationProtocolEntityList(dec, &(val)->application_protocol_entity_list))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_SetOfDestinationNodes(dec, &(val)->destination_nodes))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ApplicationInvokeIndication(ApplicationInvokeIndication *val)
{
    if (val) {
	ASN1Free_ApplicationProtocolEntityList(&(val)->application_protocol_entity_list);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SetOfDestinationNodes(&(val)->destination_nodes);
	}
    }
}

static int ASN1CALL ASN1Enc_RegistryRegisterChannelRequest(ASN1encoding_t enc, RegistryRegisterChannelRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1Enc_RegistryKey(enc, &(val)->key))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryRegisterChannelRequest(ASN1decoding_t dec, RegistryRegisterChannelRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1Dec_RegistryKey(dec, &(val)->key))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistryRegisterChannelRequest(RegistryRegisterChannelRequest *val)
{
    if (val) {
	ASN1Free_RegistryKey(&(val)->key);
    }
}

static int ASN1CALL ASN1Enc_RegistryAssignTokenRequest(ASN1encoding_t enc, RegistryAssignTokenRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1Enc_RegistryKey(enc, &(val)->registry_key))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryAssignTokenRequest(ASN1decoding_t dec, RegistryAssignTokenRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1Dec_RegistryKey(dec, &(val)->registry_key))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistryAssignTokenRequest(RegistryAssignTokenRequest *val)
{
    if (val) {
	ASN1Free_RegistryKey(&(val)->registry_key);
    }
}

static int ASN1CALL ASN1Enc_RegistrySetParameterRequest(ASN1encoding_t enc, RegistrySetParameterRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1Enc_RegistryKey(enc, &(val)->key))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->registry_set_parameter, 0, 64, 7))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 2, (val)->parameter_modify_rights))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrySetParameterRequest(ASN1decoding_t dec, RegistrySetParameterRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1Dec_RegistryKey(dec, &(val)->key))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->registry_set_parameter, 0, 64, 7))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->parameter_modify_rights))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistrySetParameterRequest(RegistrySetParameterRequest *val)
{
    if (val) {
	ASN1Free_RegistryKey(&(val)->key);
    }
}

static int ASN1CALL ASN1Enc_RegistryRetrieveEntryRequest(ASN1encoding_t enc, RegistryRetrieveEntryRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1Enc_RegistryKey(enc, &(val)->key))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryRetrieveEntryRequest(ASN1decoding_t dec, RegistryRetrieveEntryRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1Dec_RegistryKey(dec, &(val)->key))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistryRetrieveEntryRequest(RegistryRetrieveEntryRequest *val)
{
    if (val) {
	ASN1Free_RegistryKey(&(val)->key);
    }
}

static int ASN1CALL ASN1Enc_RegistryDeleteEntryRequest(ASN1encoding_t enc, RegistryDeleteEntryRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1Enc_RegistryKey(enc, &(val)->key))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryDeleteEntryRequest(ASN1decoding_t dec, RegistryDeleteEntryRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1Dec_RegistryKey(dec, &(val)->key))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistryDeleteEntryRequest(RegistryDeleteEntryRequest *val)
{
    if (val) {
	ASN1Free_RegistryKey(&(val)->key);
    }
}

static int ASN1CALL ASN1Enc_RegistryMonitorEntryRequest(ASN1encoding_t enc, RegistryMonitorEntryRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1Enc_RegistryKey(enc, &(val)->key))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryMonitorEntryRequest(ASN1decoding_t dec, RegistryMonitorEntryRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1Dec_RegistryKey(dec, &(val)->key))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistryMonitorEntryRequest(RegistryMonitorEntryRequest *val)
{
    if (val) {
	ASN1Free_RegistryKey(&(val)->key);
    }
}

static int ASN1CALL ASN1Enc_RegistryMonitorEntryIndication(ASN1encoding_t enc, RegistryMonitorEntryIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_RegistryKey(enc, &(val)->key))
	return 0;
    if (!ASN1Enc_RegistryItem(enc, &(val)->item))
	return 0;
    if (!ASN1Enc_RegistryEntryOwner(enc, &(val)->owner))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 2, (val)->entry_modify_rights))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryMonitorEntryIndication(ASN1decoding_t dec, RegistryMonitorEntryIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_RegistryKey(dec, &(val)->key))
	return 0;
    if (!ASN1Dec_RegistryItem(dec, &(val)->item))
	return 0;
    if (!ASN1Dec_RegistryEntryOwner(dec, &(val)->owner))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->entry_modify_rights))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistryMonitorEntryIndication(RegistryMonitorEntryIndication *val)
{
    if (val) {
	ASN1Free_RegistryKey(&(val)->key);
	ASN1Free_RegistryItem(&(val)->item);
    }
}

static int ASN1CALL ASN1Enc_RegistryAllocateHandleRequest(ASN1encoding_t enc, RegistryAllocateHandleRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->number_of_handles - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryAllocateHandleRequest(ASN1decoding_t dec, RegistryAllocateHandleRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->number_of_handles))
	return 0;
    (val)->number_of_handles += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RegistryAllocateHandleResponse(ASN1encoding_t enc, RegistryAllocateHandleResponse *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->number_of_handles - 1))
	return 0;
    l = ASN1uint32_uoctets((val)->first_handle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->first_handle))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->result))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryAllocateHandleResponse(ASN1decoding_t dec, RegistryAllocateHandleResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->number_of_handles))
	return 0;
    (val)->number_of_handles += 1;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->first_handle))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RegistryResponse(ASN1encoding_t enc, RegistryResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->primitive_type))
	return 0;
    if (!ASN1Enc_RegistryKey(enc, &(val)->key))
	return 0;
    if (!ASN1Enc_RegistryItem(enc, &(val)->item))
	return 0;
    if (!ASN1Enc_RegistryEntryOwner(enc, &(val)->owner))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 2, (val)->response_modify_rights))
	    return 0;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->result))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryResponse(ASN1decoding_t dec, RegistryResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->primitive_type))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (!ASN1Dec_RegistryKey(dec, &(val)->key))
	return 0;
    if (!ASN1Dec_RegistryItem(dec, &(val)->item))
	return 0;
    if (!ASN1Dec_RegistryEntryOwner(dec, &(val)->owner))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->response_modify_rights))
	    return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistryResponse(RegistryResponse *val)
{
    if (val) {
	ASN1Free_RegistryKey(&(val)->key);
	ASN1Free_RegistryItem(&(val)->item);
    }
}

static int ASN1CALL ASN1Enc_ConductorAssignIndication(ASN1encoding_t enc, ConductorAssignIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->user_id - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorAssignIndication(ASN1decoding_t dec, ConductorAssignIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->user_id))
	return 0;
    (val)->user_id += 1001;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConductorReleaseIndication(ASN1encoding_t enc, ConductorReleaseIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorReleaseIndication(ASN1decoding_t dec, ConductorReleaseIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConductorPermissionAskIndication(ASN1encoding_t enc, ConductorPermissionAskIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->permission_is_granted))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorPermissionAskIndication(ASN1decoding_t dec, ConductorPermissionAskIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->permission_is_granted))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConductorPermissionGrantIndication(ASN1encoding_t enc, ConductorPermissionGrantIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_PermissionList(enc, &(val)->permission_list))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WaitingList(enc, &(val)->waiting_list))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorPermissionGrantIndication(ASN1decoding_t dec, ConductorPermissionGrantIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_PermissionList(dec, &(val)->permission_list))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WaitingList(dec, &(val)->waiting_list))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConductorPermissionGrantIndication(ConductorPermissionGrantIndication *val)
{
    if (val) {
	ASN1Free_PermissionList(&(val)->permission_list);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WaitingList(&(val)->waiting_list);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceTimeRemainingIndication(ASN1encoding_t enc, ConferenceTimeRemainingIndication *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->time_remaining + 2147483648);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->time_remaining + 2147483648))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->time_remaining_node_id - 1001))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceTimeRemainingIndication(ASN1decoding_t dec, ConferenceTimeRemainingIndication *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->time_remaining))
	return 0;
    (val)->time_remaining += 0 - 2147483648;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->time_remaining_node_id))
	    return 0;
	(val)->time_remaining_node_id += 1001;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceTimeInquireIndication(ASN1encoding_t enc, ConferenceTimeInquireIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->time_is_node_specific))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceTimeInquireIndication(ASN1decoding_t dec, ConferenceTimeInquireIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->time_is_node_specific))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceTimeExtendIndication(ASN1encoding_t enc, ConferenceTimeExtendIndication *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    l = ASN1uint32_uoctets((val)->time_to_extend + 2147483648);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->time_to_extend + 2147483648))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->time_is_node_specific))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceTimeExtendIndication(ASN1decoding_t dec, ConferenceTimeExtendIndication *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->time_to_extend))
	return 0;
    (val)->time_to_extend += 0 - 2147483648;
    if (!ASN1PERDecBoolean(dec, &(val)->time_is_node_specific))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceAssistanceIndication(ASN1encoding_t enc, ConferenceAssistanceIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->cain_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceAssistanceIndication(ASN1decoding_t dec, ConferenceAssistanceIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->cain_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceAssistanceIndication(ConferenceAssistanceIndication *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SetOfUserData(&(val)->cain_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_TextMessageIndication(ASN1encoding_t enc, TextMessageIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, ((val)->message).length))
	return 0;
    if (!ASN1PEREncChar16String(enc, ((val)->message).length, ((val)->message).value, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TextMessageIndication(ASN1decoding_t dec, TextMessageIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &((val)->message).length))
	return 0;
    if (!ASN1PERDecChar16String(dec, ((val)->message).length, &((val)->message).value, 16))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TextMessageIndication(TextMessageIndication *val)
{
    if (val) {
	ASN1char16string_free(&(val)->message);
    }
}

static int ASN1CALL ASN1Enc_NonStandardPDU(ASN1encoding_t enc, NonStandardPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardPDU(ASN1decoding_t dec, NonStandardPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->data))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardPDU(NonStandardPDU *val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&(val)->data);
    }
}

static int ASN1CALL ASN1Enc_ConnectData(ASN1encoding_t enc, ConnectData *val)
{
    if (!ASN1Enc_Key(enc, &(val)->t124_identifier))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->connect_pdu))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectData(ASN1decoding_t dec, ConnectData *val)
{
    if (!ASN1Dec_Key(dec, &(val)->t124_identifier))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->connect_pdu))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectData(ConnectData *val)
{
    if (val) {
	ASN1Free_Key(&(val)->t124_identifier);
	ASN1octetstring_free(&(val)->connect_pdu);
    }
}

static int ASN1CALL ASN1Enc_IndicationPDU(ASN1encoding_t enc, IndicationPDU *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 5))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_UserIDIndication(enc, &(val)->u.user_id_indication))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ConferenceLockIndication(enc, &(val)->u.conference_lock_indication))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ConferenceUnlockIndication(enc, &(val)->u.conference_unlock_indication))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ConferenceTerminateIndication(enc, &(val)->u.conference_terminate_indication))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_ConferenceEjectUserIndication(enc, &(val)->u.conference_eject_user_indication))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_ConferenceTransferIndication(enc, &(val)->u.conference_transfer_indication))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_RosterUpdateIndication(enc, &(val)->u.roster_update_indication))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_ApplicationInvokeIndication(enc, &(val)->u.application_invoke_indication))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_RegistryMonitorEntryIndication(enc, &(val)->u.registry_monitor_entry_indication))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_ConductorAssignIndication(enc, &(val)->u.conductor_assign_indication))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_ConductorReleaseIndication(enc, &(val)->u.conductor_release_indication))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_ConductorPermissionAskIndication(enc, &(val)->u.conductor_permission_ask_indication))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_ConductorPermissionGrantIndication(enc, &(val)->u.conductor_permission_grant_indication))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_ConferenceTimeRemainingIndication(enc, &(val)->u.conference_time_remaining_indication))
	    return 0;
	break;
    case 15:
	if (!ASN1Enc_ConferenceTimeInquireIndication(enc, &(val)->u.conference_time_inquire_indication))
	    return 0;
	break;
    case 16:
	if (!ASN1Enc_ConferenceTimeExtendIndication(enc, &(val)->u.conference_time_extend_indication))
	    return 0;
	break;
    case 17:
	if (!ASN1Enc_ConferenceAssistanceIndication(enc, &(val)->u.conference_assistance_indication))
	    return 0;
	break;
    case 18:
	if (!ASN1Enc_TextMessageIndication(enc, &(val)->u.text_message_indication))
	    return 0;
	break;
    case 19:
	if (!ASN1Enc_NonStandardPDU(enc, &(val)->u.non_standard_indication))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IndicationPDU(ASN1decoding_t dec, IndicationPDU *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 5))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_UserIDIndication(dec, &(val)->u.user_id_indication))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ConferenceLockIndication(dec, &(val)->u.conference_lock_indication))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ConferenceUnlockIndication(dec, &(val)->u.conference_unlock_indication))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ConferenceTerminateIndication(dec, &(val)->u.conference_terminate_indication))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_ConferenceEjectUserIndication(dec, &(val)->u.conference_eject_user_indication))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_ConferenceTransferIndication(dec, &(val)->u.conference_transfer_indication))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_RosterUpdateIndication(dec, &(val)->u.roster_update_indication))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_ApplicationInvokeIndication(dec, &(val)->u.application_invoke_indication))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_RegistryMonitorEntryIndication(dec, &(val)->u.registry_monitor_entry_indication))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_ConductorAssignIndication(dec, &(val)->u.conductor_assign_indication))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_ConductorReleaseIndication(dec, &(val)->u.conductor_release_indication))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_ConductorPermissionAskIndication(dec, &(val)->u.conductor_permission_ask_indication))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_ConductorPermissionGrantIndication(dec, &(val)->u.conductor_permission_grant_indication))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_ConferenceTimeRemainingIndication(dec, &(val)->u.conference_time_remaining_indication))
	    return 0;
	break;
    case 15:
	if (!ASN1Dec_ConferenceTimeInquireIndication(dec, &(val)->u.conference_time_inquire_indication))
	    return 0;
	break;
    case 16:
	if (!ASN1Dec_ConferenceTimeExtendIndication(dec, &(val)->u.conference_time_extend_indication))
	    return 0;
	break;
    case 17:
	if (!ASN1Dec_ConferenceAssistanceIndication(dec, &(val)->u.conference_assistance_indication))
	    return 0;
	break;
    case 18:
	if (!ASN1Dec_TextMessageIndication(dec, &(val)->u.text_message_indication))
	    return 0;
	break;
    case 19:
	if (!ASN1Dec_NonStandardPDU(dec, &(val)->u.non_standard_indication))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IndicationPDU(IndicationPDU *val)
{
    if (val) {
	switch ((val)->choice) {
	case 6:
	    ASN1Free_ConferenceTransferIndication(&(val)->u.conference_transfer_indication);
	    break;
	case 7:
	    ASN1Free_RosterUpdateIndication(&(val)->u.roster_update_indication);
	    break;
	case 8:
	    ASN1Free_ApplicationInvokeIndication(&(val)->u.application_invoke_indication);
	    break;
	case 9:
	    ASN1Free_RegistryMonitorEntryIndication(&(val)->u.registry_monitor_entry_indication);
	    break;
	case 13:
	    ASN1Free_ConductorPermissionGrantIndication(&(val)->u.conductor_permission_grant_indication);
	    break;
	case 17:
	    ASN1Free_ConferenceAssistanceIndication(&(val)->u.conference_assistance_indication);
	    break;
	case 18:
	    ASN1Free_TextMessageIndication(&(val)->u.text_message_indication);
	    break;
	case 19:
	    ASN1Free_NonStandardPDU(&(val)->u.non_standard_indication);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ApplicationUpdate(ASN1encoding_t enc, ApplicationUpdate *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ApplicationRecord(enc, &(val)->u.application_add_record))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ApplicationRecord(enc, &(val)->u.application_replace_record))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ApplicationUpdate(ASN1decoding_t dec, ApplicationUpdate *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ApplicationRecord(dec, &(val)->u.application_add_record))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ApplicationRecord(dec, &(val)->u.application_replace_record))
	    return 0;
	break;
    case 3:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ApplicationUpdate(ApplicationUpdate *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ApplicationRecord(&(val)->u.application_add_record);
	    break;
	case 2:
	    ASN1Free_ApplicationRecord(&(val)->u.application_replace_record);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set(ASN1encoding_t enc, RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_CapabilityID(enc, &(val)->capability_id))
	return 0;
    if (!ASN1Enc_CapabilityClass(enc, &(val)->capability_class))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, (val)->number_of_entities - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set(ASN1decoding_t dec, RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_CapabilityID(dec, &(val)->capability_id))
	return 0;
    if (!ASN1Dec_CapabilityClass(dec, &(val)->capability_class))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &(val)->number_of_entities))
	return 0;
    (val)->number_of_entities += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set(RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set *val)
{
    if (val) {
	ASN1Free_CapabilityID(&(val)->capability_id);
    }
}

static int ASN1CALL ASN1Enc_RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set(ASN1encoding_t enc, RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_id - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1Enc_ApplicationRecord(enc, &(val)->application_record))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set(ASN1decoding_t dec, RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_id))
	return 0;
    (val)->node_id += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1Dec_ApplicationRecord(dec, &(val)->application_record))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set(RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set *val)
{
    if (val) {
	ASN1Free_ApplicationRecord(&(val)->application_record);
    }
}

static int ASN1CALL ASN1Enc_RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set(ASN1encoding_t enc, RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_id - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1Enc_ApplicationUpdate(enc, &(val)->application_update))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set(ASN1decoding_t dec, RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_id))
	return 0;
    (val)->node_id += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1Dec_ApplicationUpdate(dec, &(val)->application_update))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set(RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set *val)
{
    if (val) {
	ASN1Free_ApplicationUpdate(&(val)->application_update);
    }
}

static int ASN1CALL ASN1Enc_NodeUpdate(ASN1encoding_t enc, NodeUpdate *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NodeRecord(enc, &(val)->u.node_add_record))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_NodeRecord(enc, &(val)->u.node_replace_record))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NodeUpdate(ASN1decoding_t dec, NodeUpdate *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NodeRecord(dec, &(val)->u.node_add_record))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_NodeRecord(dec, &(val)->u.node_replace_record))
	    return 0;
	break;
    case 3:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NodeUpdate(NodeUpdate *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NodeRecord(&(val)->u.node_add_record);
	    break;
	case 2:
	    ASN1Free_NodeRecord(&(val)->u.node_replace_record);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set(ASN1encoding_t enc, RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_id - 1001))
	return 0;
    if (!ASN1Enc_NodeRecord(enc, &(val)->node_record))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set(ASN1decoding_t dec, RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_id))
	return 0;
    (val)->node_id += 1001;
    if (!ASN1Dec_NodeRecord(dec, &(val)->node_record))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set(RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set *val)
{
    if (val) {
	ASN1Free_NodeRecord(&(val)->node_record);
    }
}

static int ASN1CALL ASN1Enc_RosterUpdateIndication_node_information_node_record_list_node_record_update_Set(ASN1encoding_t enc, RosterUpdateIndication_node_information_node_record_list_node_record_update_Set *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_id - 1001))
	return 0;
    if (!ASN1Enc_NodeUpdate(enc, &(val)->node_update))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RosterUpdateIndication_node_information_node_record_list_node_record_update_Set(ASN1decoding_t dec, RosterUpdateIndication_node_information_node_record_list_node_record_update_Set *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_id))
	return 0;
    (val)->node_id += 1001;
    if (!ASN1Dec_NodeUpdate(dec, &(val)->node_update))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RosterUpdateIndication_node_information_node_record_list_node_record_update_Set(RosterUpdateIndication_node_information_node_record_list_node_record_update_Set *val)
{
    if (val) {
	ASN1Free_NodeUpdate(&(val)->node_update);
    }
}

static int ASN1CALL ASN1Enc_SetOfApplicationRecordUpdates(ASN1encoding_t enc, PSetOfApplicationRecordUpdates *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfApplicationRecordUpdates_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfApplicationRecordUpdates_ElmFn(ASN1encoding_t enc, PSetOfApplicationRecordUpdates val)
{
    if (!ASN1Enc_RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfApplicationRecordUpdates(ASN1decoding_t dec, PSetOfApplicationRecordUpdates *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfApplicationRecordUpdates_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfApplicationRecordUpdates_ElmFn(ASN1decoding_t dec, PSetOfApplicationRecordUpdates val)
{
    if (!ASN1Dec_RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfApplicationRecordUpdates(PSetOfApplicationRecordUpdates *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfApplicationRecordUpdates_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfApplicationRecordUpdates_ElmFn(PSetOfApplicationRecordUpdates val)
{
    if (val) {
	ASN1Free_RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfApplicationRecordRefreshes(ASN1encoding_t enc, PSetOfApplicationRecordRefreshes *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfApplicationRecordRefreshes_ElmFn, 0, 65535, 16);
}

static int ASN1CALL ASN1Enc_SetOfApplicationRecordRefreshes_ElmFn(ASN1encoding_t enc, PSetOfApplicationRecordRefreshes val)
{
    if (!ASN1Enc_RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfApplicationRecordRefreshes(ASN1decoding_t dec, PSetOfApplicationRecordRefreshes *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfApplicationRecordRefreshes_ElmFn, sizeof(**val), 0, 65535, 16);
}

static int ASN1CALL ASN1Dec_SetOfApplicationRecordRefreshes_ElmFn(ASN1decoding_t dec, PSetOfApplicationRecordRefreshes val)
{
    if (!ASN1Dec_RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfApplicationRecordRefreshes(PSetOfApplicationRecordRefreshes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfApplicationRecordRefreshes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfApplicationRecordRefreshes_ElmFn(PSetOfApplicationRecordRefreshes val)
{
    if (val) {
	ASN1Free_RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfApplicationCapabilityRefreshes(ASN1encoding_t enc, PSetOfApplicationCapabilityRefreshes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfApplicationCapabilityRefreshes_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfApplicationCapabilityRefreshes_ElmFn(ASN1encoding_t enc, PSetOfApplicationCapabilityRefreshes val)
{
    if (!ASN1Enc_RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfApplicationCapabilityRefreshes(ASN1decoding_t dec, PSetOfApplicationCapabilityRefreshes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfApplicationCapabilityRefreshes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfApplicationCapabilityRefreshes_ElmFn(ASN1decoding_t dec, PSetOfApplicationCapabilityRefreshes val)
{
    if (!ASN1Dec_RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfApplicationCapabilityRefreshes(PSetOfApplicationCapabilityRefreshes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfApplicationCapabilityRefreshes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfApplicationCapabilityRefreshes_ElmFn(PSetOfApplicationCapabilityRefreshes val)
{
    if (val) {
	ASN1Free_RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfNodeRecordUpdates(ASN1encoding_t enc, PSetOfNodeRecordUpdates *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfNodeRecordUpdates_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfNodeRecordUpdates_ElmFn(ASN1encoding_t enc, PSetOfNodeRecordUpdates val)
{
    if (!ASN1Enc_RosterUpdateIndication_node_information_node_record_list_node_record_update_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfNodeRecordUpdates(ASN1decoding_t dec, PSetOfNodeRecordUpdates *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfNodeRecordUpdates_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfNodeRecordUpdates_ElmFn(ASN1decoding_t dec, PSetOfNodeRecordUpdates val)
{
    if (!ASN1Dec_RosterUpdateIndication_node_information_node_record_list_node_record_update_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfNodeRecordUpdates(PSetOfNodeRecordUpdates *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfNodeRecordUpdates_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfNodeRecordUpdates_ElmFn(PSetOfNodeRecordUpdates val)
{
    if (val) {
	ASN1Free_RosterUpdateIndication_node_information_node_record_list_node_record_update_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfNodeRecordRefreshes(ASN1encoding_t enc, PSetOfNodeRecordRefreshes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfNodeRecordRefreshes_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfNodeRecordRefreshes_ElmFn(ASN1encoding_t enc, PSetOfNodeRecordRefreshes val)
{
    if (!ASN1Enc_RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfNodeRecordRefreshes(ASN1decoding_t dec, PSetOfNodeRecordRefreshes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfNodeRecordRefreshes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfNodeRecordRefreshes_ElmFn(ASN1decoding_t dec, PSetOfNodeRecordRefreshes val)
{
    if (!ASN1Dec_RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfNodeRecordRefreshes(PSetOfNodeRecordRefreshes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfNodeRecordRefreshes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfNodeRecordRefreshes_ElmFn(PSetOfNodeRecordRefreshes val)
{
    if (val) {
	ASN1Free_RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ApplicationRecord_non_collapsing_capabilities_Set(ASN1encoding_t enc, ApplicationRecord_non_collapsing_capabilities_Set *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_CapabilityID(enc, &(val)->capability_id))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->application_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ApplicationRecord_non_collapsing_capabilities_Set(ASN1decoding_t dec, ApplicationRecord_non_collapsing_capabilities_Set *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_CapabilityID(dec, &(val)->capability_id))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->application_data))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ApplicationRecord_non_collapsing_capabilities_Set(ApplicationRecord_non_collapsing_capabilities_Set *val)
{
    if (val) {
	ASN1Free_CapabilityID(&(val)->capability_id);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->application_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ApplicationInvokeSpecifier_expected_capability_set_Set(ASN1encoding_t enc, ApplicationInvokeSpecifier_expected_capability_set_Set *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_CapabilityID(enc, &(val)->capability_id))
	return 0;
    if (!ASN1Enc_CapabilityClass(enc, &(val)->capability_class))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ApplicationInvokeSpecifier_expected_capability_set_Set(ASN1decoding_t dec, ApplicationInvokeSpecifier_expected_capability_set_Set *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_CapabilityID(dec, &(val)->capability_id))
	return 0;
    if (!ASN1Dec_CapabilityClass(dec, &(val)->capability_class))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ApplicationInvokeSpecifier_expected_capability_set_Set(ApplicationInvokeSpecifier_expected_capability_set_Set *val)
{
    if (val) {
	ASN1Free_CapabilityID(&(val)->capability_id);
    }
}

static int ASN1CALL ASN1Enc_RosterUpdateIndication_application_information_Set(ASN1encoding_t enc, RosterUpdateIndication_application_information_Set *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_SessionKey(enc, &(val)->session_key))
	return 0;
    if (!ASN1Enc_ApplicationRecordList(enc, &(val)->application_record_list))
	return 0;
    if (!ASN1Enc_ApplicationCapabilitiesList(enc, &(val)->application_capabilities_list))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->roster_instance_number))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->peer_entities_are_added))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->peer_entities_are_removed))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RosterUpdateIndication_application_information_Set(ASN1decoding_t dec, RosterUpdateIndication_application_information_Set *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_SessionKey(dec, &(val)->session_key))
	return 0;
    if (!ASN1Dec_ApplicationRecordList(dec, &(val)->application_record_list))
	return 0;
    if (!ASN1Dec_ApplicationCapabilitiesList(dec, &(val)->application_capabilities_list))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->roster_instance_number))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->peer_entities_are_added))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->peer_entities_are_removed))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RosterUpdateIndication_application_information_Set(RosterUpdateIndication_application_information_Set *val)
{
    if (val) {
	ASN1Free_SessionKey(&(val)->session_key);
	ASN1Free_ApplicationRecordList(&(val)->application_record_list);
	ASN1Free_ApplicationCapabilitiesList(&(val)->application_capabilities_list);
    }
}

static int ASN1CALL ASN1Enc_ApplicationProtocolEntityList(ASN1encoding_t enc, PApplicationProtocolEntityList *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ApplicationProtocolEntityList_ElmFn);
}

static int ASN1CALL ASN1Enc_ApplicationProtocolEntityList_ElmFn(ASN1encoding_t enc, PApplicationProtocolEntityList val)
{
    if (!ASN1Enc_ApplicationInvokeSpecifier(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ApplicationProtocolEntityList(ASN1decoding_t dec, PApplicationProtocolEntityList *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ApplicationProtocolEntityList_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ApplicationProtocolEntityList_ElmFn(ASN1decoding_t dec, PApplicationProtocolEntityList val)
{
    if (!ASN1Dec_ApplicationInvokeSpecifier(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ApplicationProtocolEntityList(PApplicationProtocolEntityList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ApplicationProtocolEntityList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ApplicationProtocolEntityList_ElmFn(PApplicationProtocolEntityList val)
{
    if (val) {
	ASN1Free_ApplicationInvokeSpecifier(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfApplicationInformation(ASN1encoding_t enc, PSetOfApplicationInformation *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfApplicationInformation_ElmFn, 0, 65535, 16);
}

static int ASN1CALL ASN1Enc_SetOfApplicationInformation_ElmFn(ASN1encoding_t enc, PSetOfApplicationInformation val)
{
    if (!ASN1Enc_RosterUpdateIndication_application_information_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfApplicationInformation(ASN1decoding_t dec, PSetOfApplicationInformation *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfApplicationInformation_ElmFn, sizeof(**val), 0, 65535, 16);
}

static int ASN1CALL ASN1Dec_SetOfApplicationInformation_ElmFn(ASN1decoding_t dec, PSetOfApplicationInformation val)
{
    if (!ASN1Dec_RosterUpdateIndication_application_information_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfApplicationInformation(PSetOfApplicationInformation *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfApplicationInformation_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfApplicationInformation_ElmFn(PSetOfApplicationInformation val)
{
    if (val) {
	ASN1Free_RosterUpdateIndication_application_information_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfConferenceDescriptors(ASN1encoding_t enc, PSetOfConferenceDescriptors *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfConferenceDescriptors_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfConferenceDescriptors_ElmFn(ASN1encoding_t enc, PSetOfConferenceDescriptors val)
{
    if (!ASN1Enc_ConferenceDescriptor(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfConferenceDescriptors(ASN1decoding_t dec, PSetOfConferenceDescriptors *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfConferenceDescriptors_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfConferenceDescriptors_ElmFn(ASN1decoding_t dec, PSetOfConferenceDescriptors val)
{
    if (!ASN1Dec_ConferenceDescriptor(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfConferenceDescriptors(PSetOfConferenceDescriptors *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfConferenceDescriptors_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfConferenceDescriptors_ElmFn(PSetOfConferenceDescriptors val)
{
    if (val) {
	ASN1Free_ConferenceDescriptor(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfExpectedCapabilities(ASN1encoding_t enc, PSetOfExpectedCapabilities *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfExpectedCapabilities_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfExpectedCapabilities_ElmFn(ASN1encoding_t enc, PSetOfExpectedCapabilities val)
{
    if (!ASN1Enc_ApplicationInvokeSpecifier_expected_capability_set_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfExpectedCapabilities(ASN1decoding_t dec, PSetOfExpectedCapabilities *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfExpectedCapabilities_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfExpectedCapabilities_ElmFn(ASN1decoding_t dec, PSetOfExpectedCapabilities val)
{
    if (!ASN1Dec_ApplicationInvokeSpecifier_expected_capability_set_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfExpectedCapabilities(PSetOfExpectedCapabilities *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfExpectedCapabilities_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfExpectedCapabilities_ElmFn(PSetOfExpectedCapabilities val)
{
    if (val) {
	ASN1Free_ApplicationInvokeSpecifier_expected_capability_set_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfNonCollapsingCapabilities(ASN1encoding_t enc, PSetOfNonCollapsingCapabilities *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfNonCollapsingCapabilities_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfNonCollapsingCapabilities_ElmFn(ASN1encoding_t enc, PSetOfNonCollapsingCapabilities val)
{
    if (!ASN1Enc_ApplicationRecord_non_collapsing_capabilities_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfNonCollapsingCapabilities(ASN1decoding_t dec, PSetOfNonCollapsingCapabilities *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfNonCollapsingCapabilities_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfNonCollapsingCapabilities_ElmFn(ASN1decoding_t dec, PSetOfNonCollapsingCapabilities val)
{
    if (!ASN1Dec_ApplicationRecord_non_collapsing_capabilities_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfNonCollapsingCapabilities(PSetOfNonCollapsingCapabilities *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfNonCollapsingCapabilities_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfNonCollapsingCapabilities_ElmFn(PSetOfNonCollapsingCapabilities val)
{
    if (val) {
	ASN1Free_ApplicationRecord_non_collapsing_capabilities_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_NetworkAddress(ASN1encoding_t enc, NetworkAddress *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_AggregateChannel(enc, &(val)->u.aggregated_channel))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_TransportConnectionType(enc, &(val)->u.transport_connection))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.address_non_standard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAddress(ASN1decoding_t dec, NetworkAddress *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_AggregateChannel(dec, &(val)->u.aggregated_channel))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_TransportConnectionType(dec, &(val)->u.transport_connection))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.address_non_standard))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NetworkAddress(NetworkAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_AggregateChannel(&(val)->u.aggregated_channel);
	    break;
	case 2:
	    ASN1Free_TransportConnectionType(&(val)->u.transport_connection);
	    break;
	case 3:
	    ASN1Free_NonStandardParameter(&(val)->u.address_non_standard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ChallengeRequestResponse(ASN1encoding_t enc, ChallengeRequestResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ChallengeRequest(enc, &(val)->challenge_request))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ChallengeResponse(enc, &(val)->challenge_response))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ChallengeRequestResponse(ASN1decoding_t dec, ChallengeRequestResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ChallengeRequest(dec, &(val)->challenge_request))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_ChallengeResponse(dec, &(val)->challenge_response))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ChallengeRequestResponse(ChallengeRequestResponse *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ChallengeRequest(&(val)->challenge_request);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_ChallengeResponse(&(val)->challenge_response);
	}
    }
}

static int ASN1CALL ASN1Enc_SetOfChallengeItems(ASN1encoding_t enc, PSetOfChallengeItems *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfChallengeItems_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfChallengeItems_ElmFn(ASN1encoding_t enc, PSetOfChallengeItems val)
{
    if (!ASN1Enc_ChallengeItem(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfChallengeItems(ASN1decoding_t dec, PSetOfChallengeItems *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfChallengeItems_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfChallengeItems_ElmFn(ASN1decoding_t dec, PSetOfChallengeItems val)
{
    if (!ASN1Dec_ChallengeItem(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfChallengeItems(PSetOfChallengeItems *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfChallengeItems_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfChallengeItems_ElmFn(PSetOfChallengeItems val)
{
    if (val) {
	ASN1Free_ChallengeItem(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UserData_Set(ASN1encoding_t enc, UserData_Set *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_Key(enc, &(val)->key))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->user_data_field))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserData_Set(ASN1decoding_t dec, UserData_Set *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_Key(dec, &(val)->key))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->user_data_field))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserData_Set(UserData_Set *val)
{
    if (val) {
	ASN1Free_Key(&(val)->key);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->user_data_field);
	}
    }
}

static int ASN1CALL ASN1Enc_SetOfUserData(ASN1encoding_t enc, PSetOfUserData *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfUserData_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfUserData_ElmFn(ASN1encoding_t enc, PSetOfUserData val)
{
    if (!ASN1Enc_UserData_Set(enc, &val->user_data_element))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfUserData(ASN1decoding_t dec, PSetOfUserData *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfUserData_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfUserData_ElmFn(ASN1decoding_t dec, PSetOfUserData val)
{
    if (!ASN1Dec_UserData_Set(dec, &val->user_data_element))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfUserData(PSetOfUserData *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfUserData_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfUserData_ElmFn(PSetOfUserData val)
{
    if (val) {
	ASN1Free_UserData_Set(&val->user_data_element);
    }
}

static int ASN1CALL ASN1Enc_PasswordChallengeRequestResponse(ASN1encoding_t enc, PasswordChallengeRequestResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_PasswordSelector(enc, &(val)->u.challenge_clear_password))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ChallengeRequestResponse(enc, &(val)->u.challenge_request_response))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PasswordChallengeRequestResponse(ASN1decoding_t dec, PasswordChallengeRequestResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_PasswordSelector(dec, &(val)->u.challenge_clear_password))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ChallengeRequestResponse(dec, &(val)->u.challenge_request_response))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PasswordChallengeRequestResponse(PasswordChallengeRequestResponse *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_PasswordSelector(&(val)->u.challenge_clear_password);
	    break;
	case 2:
	    ASN1Free_ChallengeRequestResponse(&(val)->u.challenge_request_response);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_SetOfNetworkAddresses(ASN1encoding_t enc, PSetOfNetworkAddresses *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfNetworkAddresses_ElmFn, 1, 64, 6);
}

static int ASN1CALL ASN1Enc_SetOfNetworkAddresses_ElmFn(ASN1encoding_t enc, PSetOfNetworkAddresses val)
{
    if (!ASN1Enc_NetworkAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfNetworkAddresses(ASN1decoding_t dec, PSetOfNetworkAddresses *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfNetworkAddresses_ElmFn, sizeof(**val), 1, 64, 6);
}

static int ASN1CALL ASN1Dec_SetOfNetworkAddresses_ElmFn(ASN1decoding_t dec, PSetOfNetworkAddresses val)
{
    if (!ASN1Dec_NetworkAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfNetworkAddresses(PSetOfNetworkAddresses *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfNetworkAddresses_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfNetworkAddresses_ElmFn(PSetOfNetworkAddresses val)
{
    if (val) {
	ASN1Free_NetworkAddress(&val->value);
    }
}

static ASN1stringtableentry_t ConferenceJoinRequest_cjrq_conference_modifier_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t ConferenceJoinRequest_cjrq_conference_modifier_StringTable = {
    1, ConferenceJoinRequest_cjrq_conference_modifier_StringTableEntries
};

static int ASN1CALL ASN1Enc_ConferenceJoinRequest(ASN1encoding_t enc, ConferenceJoinRequest *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ConferenceNameSelector(enc, &(val)->conference_name))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	t = lstrlenA((val)->cjrq_conference_modifier);
	if (!ASN1PEREncBitVal(enc, 8, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->cjrq_conference_modifier, 4, &ConferenceJoinRequest_cjrq_conference_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
#ifndef _WIN64
	if (!ASN1PEREncInteger(enc, (val)->tag))
	    return 0;
#endif
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_PasswordChallengeRequestResponse(enc, &(val)->cjrq_password))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_PasswordSelector(enc, &(val)->cjrq_convener_password))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->cjrq_caller_id).length))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->cjrq_caller_id).length, ((val)->cjrq_caller_id).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->cjrq_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceJoinRequest(ASN1decoding_t dec, ConferenceJoinRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ConferenceNameSelector(dec, &(val)->conference_name))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 8, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	/* Start of HANDCODED FIX FOR pdu security Issue */
	if (l >= sizeof((val)->cjrq_conference_modifier))
	{		
		ASN1DecSetError(dec, ASN1_ERR_LARGE);
		return 0; 
	}
	/* End of HANDCODED FIX FOR pdu security Issue */
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->cjrq_conference_modifier, 4, &ConferenceJoinRequest_cjrq_conference_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
#ifndef _WIN64
	if (!ASN1PERDecInteger(dec, &(val)->tag))
	    return 0;
#endif
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_PasswordChallengeRequestResponse(dec, &(val)->cjrq_password))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_PasswordSelector(dec, &(val)->cjrq_convener_password))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->cjrq_caller_id).length))
	    return 0;
	if (!ASN1PERDecChar16String(dec, ((val)->cjrq_caller_id).length, &((val)->cjrq_caller_id).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->cjrq_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceJoinRequest(ConferenceJoinRequest *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ConferenceNameSelector(&(val)->conference_name);
	}
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PasswordChallengeRequestResponse(&(val)->cjrq_password);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_PasswordSelector(&(val)->cjrq_convener_password);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1char16string_free(&(val)->cjrq_caller_id);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_SetOfUserData(&(val)->cjrq_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceJoinResponse(ASN1encoding_t enc, ConferenceJoinResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 8, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->cjrs_node_id - 1001))
	    return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->top_node_id - 1001))
	return 0;
#ifndef _WIN64
    if (!ASN1PEREncInteger(enc, (val)->tag))
	return 0;
#endif
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ConferenceNameSelector(enc, &(val)->conference_name_alias))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->clear_password_required))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_locked))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_listed))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_conductible))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->termination_method))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_SetOfPrivileges(enc, &(val)->cjrs_conductor_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_SetOfPrivileges(enc, &(val)->cjrs_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_SetOfPrivileges(enc, &(val)->cjrs_non_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->cjrs_description).length))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->cjrs_description).length, ((val)->cjrs_description).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_PasswordChallengeRequestResponse(enc, &(val)->cjrs_password))
	    return 0;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->result))
	return 0;
    if ((val)->o[0] & 0x1) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->cjrs_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceJoinResponse(ASN1decoding_t dec, ConferenceJoinResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 8, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->cjrs_node_id))
	    return 0;
	(val)->cjrs_node_id += 1001;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->top_node_id))
	return 0;
    (val)->top_node_id += 1001;
#ifndef _WIN64
    if (!ASN1PERDecInteger(dec, &(val)->tag))
	return 0;
#endif
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_ConferenceNameSelector(dec, &(val)->conference_name_alias))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->clear_password_required))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_locked))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_listed))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_conductible))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->termination_method))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_SetOfPrivileges(dec, &(val)->cjrs_conductor_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_SetOfPrivileges(dec, &(val)->cjrs_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_SetOfPrivileges(dec, &(val)->cjrs_non_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->cjrs_description).length))
	    return 0;
	if (!ASN1PERDecChar16String(dec, ((val)->cjrs_description).length, &((val)->cjrs_description).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_PasswordChallengeRequestResponse(dec, &(val)->cjrs_password))
	    return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->cjrs_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceJoinResponse(ConferenceJoinResponse *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_ConferenceNameSelector(&(val)->conference_name_alias);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_SetOfPrivileges(&(val)->cjrs_conductor_privs);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_SetOfPrivileges(&(val)->cjrs_conducted_privs);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_SetOfPrivileges(&(val)->cjrs_non_conducted_privs);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1char16string_free(&(val)->cjrs_description);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_PasswordChallengeRequestResponse(&(val)->cjrs_password);
	}
	if ((val)->o[0] & 0x1) {
	    ASN1Free_SetOfUserData(&(val)->cjrs_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConnectGCCPDU(ASN1encoding_t enc, ConnectGCCPDU *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ConferenceCreateRequest(enc, &(val)->u.conference_create_request))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ConferenceCreateResponse(enc, &(val)->u.conference_create_response))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ConferenceQueryRequest(enc, &(val)->u.conference_query_request))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ConferenceQueryResponse(enc, &(val)->u.conference_query_response))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_ConferenceJoinRequest(enc, &(val)->u.connect_join_request))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_ConferenceJoinResponse(enc, &(val)->u.connect_join_response))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_ConferenceInviteRequest(enc, &(val)->u.conference_invite_request))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_ConferenceInviteResponse(enc, &(val)->u.conference_invite_response))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectGCCPDU(ASN1decoding_t dec, ConnectGCCPDU *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ConferenceCreateRequest(dec, &(val)->u.conference_create_request))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ConferenceCreateResponse(dec, &(val)->u.conference_create_response))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ConferenceQueryRequest(dec, &(val)->u.conference_query_request))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ConferenceQueryResponse(dec, &(val)->u.conference_query_response))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_ConferenceJoinRequest(dec, &(val)->u.connect_join_request))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_ConferenceJoinResponse(dec, &(val)->u.connect_join_response))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_ConferenceInviteRequest(dec, &(val)->u.conference_invite_request))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_ConferenceInviteResponse(dec, &(val)->u.conference_invite_response))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConnectGCCPDU(ConnectGCCPDU *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ConferenceCreateRequest(&(val)->u.conference_create_request);
	    break;
	case 2:
	    ASN1Free_ConferenceCreateResponse(&(val)->u.conference_create_response);
	    break;
	case 3:
	    ASN1Free_ConferenceQueryRequest(&(val)->u.conference_query_request);
	    break;
	case 4:
	    ASN1Free_ConferenceQueryResponse(&(val)->u.conference_query_response);
	    break;
	case 5:
	    ASN1Free_ConferenceJoinRequest(&(val)->u.connect_join_request);
	    break;
	case 6:
	    ASN1Free_ConferenceJoinResponse(&(val)->u.connect_join_response);
	    break;
	case 7:
	    ASN1Free_ConferenceInviteRequest(&(val)->u.conference_invite_request);
	    break;
	case 8:
	    ASN1Free_ConferenceInviteResponse(&(val)->u.conference_invite_response);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RequestPDU(ASN1encoding_t enc, RequestPDU *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ConferenceJoinRequest(enc, &(val)->u.conference_join_request))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ConferenceAddRequest(enc, &(val)->u.conference_add_request))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ConferenceLockRequest(enc, &(val)->u.conference_lock_request))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ConferenceUnlockRequest(enc, &(val)->u.conference_unlock_request))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_ConferenceTerminateRequest(enc, &(val)->u.conference_terminate_request))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_ConferenceEjectUserRequest(enc, &(val)->u.conference_eject_user_request))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_ConferenceTransferRequest(enc, &(val)->u.conference_transfer_request))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_RegistryRegisterChannelRequest(enc, &(val)->u.registry_register_channel_request))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_RegistryAssignTokenRequest(enc, &(val)->u.registry_assign_token_request))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_RegistrySetParameterRequest(enc, &(val)->u.registry_set_parameter_request))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_RegistryRetrieveEntryRequest(enc, &(val)->u.registry_retrieve_entry_request))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_RegistryDeleteEntryRequest(enc, &(val)->u.registry_delete_entry_request))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_RegistryMonitorEntryRequest(enc, &(val)->u.registry_monitor_entry_request))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_RegistryAllocateHandleRequest(enc, &(val)->u.registry_allocate_handle_request))
	    return 0;
	break;
    case 15:
	if (!ASN1Enc_NonStandardPDU(enc, &(val)->u.non_standard_request))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestPDU(ASN1decoding_t dec, RequestPDU *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ConferenceJoinRequest(dec, &(val)->u.conference_join_request))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ConferenceAddRequest(dec, &(val)->u.conference_add_request))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ConferenceLockRequest(dec, &(val)->u.conference_lock_request))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ConferenceUnlockRequest(dec, &(val)->u.conference_unlock_request))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_ConferenceTerminateRequest(dec, &(val)->u.conference_terminate_request))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_ConferenceEjectUserRequest(dec, &(val)->u.conference_eject_user_request))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_ConferenceTransferRequest(dec, &(val)->u.conference_transfer_request))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_RegistryRegisterChannelRequest(dec, &(val)->u.registry_register_channel_request))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_RegistryAssignTokenRequest(dec, &(val)->u.registry_assign_token_request))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_RegistrySetParameterRequest(dec, &(val)->u.registry_set_parameter_request))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_RegistryRetrieveEntryRequest(dec, &(val)->u.registry_retrieve_entry_request))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_RegistryDeleteEntryRequest(dec, &(val)->u.registry_delete_entry_request))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_RegistryMonitorEntryRequest(dec, &(val)->u.registry_monitor_entry_request))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_RegistryAllocateHandleRequest(dec, &(val)->u.registry_allocate_handle_request))
	    return 0;
	break;
    case 15:
	if (!ASN1Dec_NonStandardPDU(dec, &(val)->u.non_standard_request))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestPDU(RequestPDU *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ConferenceJoinRequest(&(val)->u.conference_join_request);
	    break;
	case 2:
	    ASN1Free_ConferenceAddRequest(&(val)->u.conference_add_request);
	    break;
	case 7:
	    ASN1Free_ConferenceTransferRequest(&(val)->u.conference_transfer_request);
	    break;
	case 8:
	    ASN1Free_RegistryRegisterChannelRequest(&(val)->u.registry_register_channel_request);
	    break;
	case 9:
	    ASN1Free_RegistryAssignTokenRequest(&(val)->u.registry_assign_token_request);
	    break;
	case 10:
	    ASN1Free_RegistrySetParameterRequest(&(val)->u.registry_set_parameter_request);
	    break;
	case 11:
	    ASN1Free_RegistryRetrieveEntryRequest(&(val)->u.registry_retrieve_entry_request);
	    break;
	case 12:
	    ASN1Free_RegistryDeleteEntryRequest(&(val)->u.registry_delete_entry_request);
	    break;
	case 13:
	    ASN1Free_RegistryMonitorEntryRequest(&(val)->u.registry_monitor_entry_request);
	    break;
	case 15:
	    ASN1Free_NonStandardPDU(&(val)->u.non_standard_request);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_FunctionNotSupportedResponse(ASN1encoding_t enc, FunctionNotSupportedResponse *val)
{
    if (!ASN1Enc_RequestPDU(enc, &(val)->request))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FunctionNotSupportedResponse(ASN1decoding_t dec, FunctionNotSupportedResponse *val)
{
    if (!ASN1Dec_RequestPDU(dec, &(val)->request))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_FunctionNotSupportedResponse(FunctionNotSupportedResponse *val)
{
    if (val) {
	ASN1Free_RequestPDU(&(val)->request);
    }
}

static int ASN1CALL ASN1Enc_ResponsePDU(ASN1encoding_t enc, ResponsePDU *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ConferenceJoinResponse(enc, &(val)->u.conference_join_response))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ConferenceAddResponse(enc, &(val)->u.conference_add_response))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ConferenceLockResponse(enc, &(val)->u.conference_lock_response))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ConferenceUnlockResponse(enc, &(val)->u.conference_unlock_response))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_ConferenceTerminateResponse(enc, &(val)->u.conference_terminate_response))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_ConferenceEjectUserResponse(enc, &(val)->u.conference_eject_user_response))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_ConferenceTransferResponse(enc, &(val)->u.conference_transfer_response))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_RegistryResponse(enc, &(val)->u.registry_response))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_RegistryAllocateHandleResponse(enc, &(val)->u.registry_allocate_handle_response))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_FunctionNotSupportedResponse(enc, &(val)->u.function_not_supported_response))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_NonStandardPDU(enc, &(val)->u.non_standard_response))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ResponsePDU(ASN1decoding_t dec, ResponsePDU *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ConferenceJoinResponse(dec, &(val)->u.conference_join_response))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ConferenceAddResponse(dec, &(val)->u.conference_add_response))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ConferenceLockResponse(dec, &(val)->u.conference_lock_response))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ConferenceUnlockResponse(dec, &(val)->u.conference_unlock_response))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_ConferenceTerminateResponse(dec, &(val)->u.conference_terminate_response))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_ConferenceEjectUserResponse(dec, &(val)->u.conference_eject_user_response))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_ConferenceTransferResponse(dec, &(val)->u.conference_transfer_response))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_RegistryResponse(dec, &(val)->u.registry_response))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_RegistryAllocateHandleResponse(dec, &(val)->u.registry_allocate_handle_response))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_FunctionNotSupportedResponse(dec, &(val)->u.function_not_supported_response))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_NonStandardPDU(dec, &(val)->u.non_standard_response))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ResponsePDU(ResponsePDU *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ConferenceJoinResponse(&(val)->u.conference_join_response);
	    break;
	case 2:
	    ASN1Free_ConferenceAddResponse(&(val)->u.conference_add_response);
	    break;
	case 7:
	    ASN1Free_ConferenceTransferResponse(&(val)->u.conference_transfer_response);
	    break;
	case 8:
	    ASN1Free_RegistryResponse(&(val)->u.registry_response);
	    break;
	case 10:
	    ASN1Free_FunctionNotSupportedResponse(&(val)->u.function_not_supported_response);
	    break;
	case 11:
	    ASN1Free_NonStandardPDU(&(val)->u.non_standard_response);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_GCCPDU(ASN1encoding_t enc, GCCPDU *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_RequestPDU(enc, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ResponsePDU(enc, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_IndicationPDU(enc, &(val)->u.indication))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GCCPDU(ASN1decoding_t dec, GCCPDU *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_RequestPDU(dec, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ResponsePDU(dec, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_IndicationPDU(dec, &(val)->u.indication))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GCCPDU(GCCPDU *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_RequestPDU(&(val)->u.request);
	    break;
	case 2:
	    ASN1Free_ResponsePDU(&(val)->u.response);
	    break;
	case 3:
	    ASN1Free_IndicationPDU(&(val)->u.indication);
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\gcclog.cpp ===
#include "precomp.h"
/**********************************************************************
 * File:     gcclog.h
 * Abstract: public function definitions for protocol logging functions 
 * added into GCCNC.DLL to read the contents of GCC and MCS PDU
 * contents going over the wire.
 * Created:  12/21/95, Venkatesh Gopalakrishnan
 * Copyright (c) 1995 Microsoft Corpration
 ******************************************************************** */


 /** Note: the contents of this file are only included if the constant
  ** PDULOG is defined.  PDULOG is defined by default ONLY in the 
  ** Win32 Diagnostic build configuration of GCCNC.DLL
  **/
#ifdef PDULOG

#include "ms_util.h"
#include <ctype.h>
#include <windows.h>

#include "pdutypes.h"
#include "gcclog.h"


#define outdeb //OutputDebugString 
 
 /**
  ** Maintainance Functions for the Protocol Logging Mechanism
  **/

 /*********************************************************************/
 int InitializeGCCLog()
 {
    FILE *logfile;
    
    /* this should just reset the file pointer */    
    logfile = fopen(LOG_FILE_NAME,"w");

	// this "fake" starting PDU is put in so that the Intel Protocol Browser
	// dosen't go nuts if it is reading dynamically.
    pduLog(logfile,"START_PDU: ============================== START PDU ===========================\n");
    pduLog(logfile,"TIMESTAMP: %s\n",pszTimeStamp());
    pduLog(logfile,"LAYER:     GCC\n");
    pduLog(logfile,"DIRECTION: None\n");
    pduLog(logfile,"RAW_PDU: -   -   -   -   -   -   -   -   RAW PDU  -   -   -   -   -   -   -   -\n");
    pduLog(logfile,"DECODED_PDU: -   -   -   -   -   -   -  DECODED PDU   -   -   -   -   -   -   -\n");
    pduLog(logfile,"PDU_TYPE:  Bogus PDU to start the logging.\n");
	pduLog(logfile,"END_PDU: ================================ END PDU =============================\n");
	
	fclose(logfile);
    return(0);
 }

 /*********************************************************************/
 char *pszTimeStamp()
 {
    char *timestring;
    timestring = (char *) malloc (13*sizeof(char));
    _strtime(timestring);
    return(timestring);
 }

 /*********************************************************************/
 void pduFragmentation(FILE *logfile,unsigned int i)
 {
    pduLog(logfile,"  PDU Fragmentation: ");
    if(i==1) 
    {
	pduLog(logfile,"Complete PDU\n");
    }
    else
    {
	pduLog(logfile,"!!!! Icomplete PDU !!!!\n");
    }
 }

 /*********************************************************************/
 void  pduRawOutput (FILE *logfile,unsigned char *data, unsigned long length) 
 {
       unsigned int i=0,j=0;
       
       pduLog(logfile,"        ");
       for (i=0; i<length; i++) 
       {
	    pduLog(logfile,"%02x ",*(data+i));
	    j++;
	    if (j >= 16) 
	    {
		pduLog(logfile,"\n        ");
		j=0;
	    }
       }
       pduLog(logfile,"\n");
 }

 /*********************************************************************/
 void gccLog(PPacket packet, PGCCPDU gcc_pdu, unsigned int direction, int mcs_pdu) 
 {
    FILE *logfile;   
    logfile = fopen(LOG_FILE_NAME,"a+");
    
    pduLog(logfile,"START_PDU: ============================== START PDU ===========================\n");
    pduLog(logfile,"TIMESTAMP: %s\n",pszTimeStamp());
    pduLog(logfile,"LAYER:     GCC\n");
    pduDirection(logfile,direction);
    pduLog(logfile,"RAW_PDU: -   -   -   -   -   -   -   -   RAW PDU  -   -   -   -   -   -   -   -\n");
    pduLog(logfile,"      %d octets (hex output):\n",packet->GetEncodedDataLength());
    pduRawOutput(logfile,packet->GetEncodedData(1),packet->GetEncodedDataLength());
    pduLog(logfile,"DECODED_PDU: -   -   -   -   -   -   -  DECODED PDU   -   -   -   -   -   -   -\n");
    pduFragmentation(logfile,packet->IsValid());
    pduLogGCCInformation(logfile,gcc_pdu);
    pduLog(logfile,"END_PDU: ================================ END PDU =============================\n");
 
    fclose(logfile);
 }

 /*********************************************************************/
 void gccConnectLog(PPacket packet, PConnectGCCPDU connect_pdu, unsigned int direction, int mcs_pdu)
 {
    FILE *logfile;   
    logfile = fopen(LOG_FILE_NAME,"a+");

    pduLog(logfile,"START_PDU: ============================== START PDU ===========================\n");
    pduLog(logfile,"TIMESTAMP: %s\n",pszTimeStamp());
    pduLog(logfile,"LAYER:     GCC\n");
    pduDirection(logfile,direction);
    pduLog(logfile,"RAW_PDU: -   -   -   -   -   -   -   -   RAW PDU  -   -   -   -   -   -   -   -\n");
    pduLog(logfile,"      %d octets (hex output):\n",packet->GetEncodedDataLength());
    if(direction==RECEIVED)
    pduRawOutput(logfile,packet->GetEncodedData(1),packet->GetEncodedDataLength());
    pduLog(logfile,"DECODED_PDU: -   -   -   -   -   -   -  DECODED PDU   -   -   -   -   -   -   -\n");
    pduFragmentation(logfile,packet->IsValid());
    pduLogGCCConnectInfo(logfile,connect_pdu);
    pduLog(logfile,"END_PDU: ================================ END PDU =============================\n");
 
    fclose(logfile);
 }


/*********************************************************************/
void pduDirection(FILE *logfile,unsigned int direction)
 {
    switch(direction)
    {
	case SENT:
	    pduLog(logfile,"DIRECTION: Sent\n");
	    break;
	case RECEIVED:
	    pduLog(logfile,"DIRECTION: Received\n");
	    break;
	case FORWARDED:
	    pduLog(logfile,"DIRECTION: Forwarded\n");
	    break;
	default:
	    pduLog(logfile,"DIRECTION: Unknown\n");
	    break;
     }
 }

 /*********************************************************************/
 void   pduLog (FILE *pFile, char * format,...)
 {
    char        *argument_ptr;
    
    argument_ptr = (char *) &format + sizeof (format);
    vfprintf (pFile, format, argument_ptr);
 }

 /*********************************************************************/
 void pduLogUserIDIndication(FILE *logfile,PGCCPDU gcc_pdu)
 {
    pduLog(logfile,"PDU_TYPE: GCC_UserIDIndication\n");
    pduLog(logfile,"          Tag: %d\n",gcc_pdu->u.indication.u.user_id_indication.tag);
 }
 
 /*********************************************************************/
 void pduLogRosterUpdateIndication(FILE *logfile, PGCCPDU gcc_pdu)
 {
    pduLog(logfile,"PDU_TYPE: GCC_RosterUpdateIndication\n");
    pduLog(logfile,"Conference Information\n");
    pduLog(logfile,"\tFull refresh flag: %d\n",
	    gcc_pdu->u.indication.u.roster_update_indication.refresh_is_full);
    PrintConferenceRoster(logfile,gcc_pdu->u.indication.u.roster_update_indication.node_information);
	PrintApplicationRoster(logfile,gcc_pdu->u.indication.u.roster_update_indication.application_information);
 }

 /*********************************************************************/
 void pduLogTextMessageIndication(FILE *logfile, PGCCPDU gcc_pdu)
 {
    Char print_buffer[255];
	pduLog(logfile,"PDU_TYPE: GCC_TextMessageIndication\n");
    pduLog(logfile,"Message: %d octets (hex output) \n",
	    gcc_pdu->u.indication.u.text_message_indication.message.length);
    pduRawOutput(logfile,
		 (unsigned char *) gcc_pdu->u.indication.u.text_message_indication.message.value,
		 gcc_pdu->u.indication.u.text_message_indication.message.length);
	if(CopyTextToChar(print_buffer,gcc_pdu->u.indication.u.text_message_indication.message))
		pduLog(logfile,"Text: %s\n",print_buffer);

 }
 
 /*********************************************************************/
 void pduLogConferenceTerminateIndication(FILE *logfile, PGCCPDU gcc_pdu)
 {
    char szReason[255];
    pduLog(logfile,"PDU_TYPE: GCC_ConferenceTerminateIndication\n");
    if(gcc_pdu->u.indication.u.conference_terminate_indication.reason == 0)
	strcpy(szReason,"User Initiated");
    else
	strcpy(szReason,"Terminated Confernece");
     
    pduLog(logfile,"\tReason: %s\n",szReason);
 }

 /*********************************************************************/
 void pduLogConferenceEjectUserIndication(FILE *logfile, PGCCPDU gcc_pdu)
 {
    pduLog(logfile,"PDU_TYPE: GCC_ConferenceEjectUserIndication\n");
    pduLog(logfile,"\tNode to Eject: %u\n",
	    gcc_pdu->u.indication.u.conference_eject_user_indication.node_to_eject);
	   
    switch(gcc_pdu->u.indication.u.conference_eject_user_indication.reason)
    {
	case 0:
	    pduLog(logfile,"\tReason: USER_INITIATED\n");
	    break;
	case 1:
	    pduLog(logfile,"\tReason: HIGHER_NODE_DISCONNECTED\n");
	    break;
	case 2:
	    pduLog(logfile,"\tReason: HIGHER_NODE_EJECTED\n");
	    break;
	default:
	    pduLog(logfile,"\tReason: >>> Unkown Reason for Ejection <<<\n");
    }
 }

 /*********************************************************************/
 void pduLogConferenceJoinRequest(FILE *logfile, PGCCPDU gcc_pdu)
 {
	 outdeb("TOP: pduLogConferenceJoinRequest\n");
     pduLog(logfile,"PDU_TYPE: GCC_ConferenceJoinRequest\n");
	 PrintConferenceName(logfile,
		    gcc_pdu->u.request.u.conference_join_request.conference_name);
     
	 pduLog(logfile,"\tTag: %u\n",
	     gcc_pdu->u.request.u.conference_join_request.tag);
     
	 if(gcc_pdu->u.request.u.conference_join_request.bit_mask & 0x10)
	 {
		PrintPasswordChallengeRequestResponse(logfile,
				gcc_pdu->u.request.u.conference_join_request.cjrq_password);
	 }
	 if(gcc_pdu->u.request.u.conference_join_request.bit_mask & 0x08)
	 {
		pduLog(logfile,"\tConvener ");
		PrintPasswordSelector(logfile,
				   gcc_pdu->u.request.u.conference_join_request.cjrq_convener_password);
	 }
     //insert caller id here.
	 outdeb("Botton: pduLogConferenceJoinRequest\n");
 }

 /*********************************************************************/
 void pduLogConnectJoinRequest(FILE *logfile, PConnectGCCPDU connect_pdu)
 {
     outdeb("TOP: pduLogConnectJoinRequest\n");
	 pduLog(logfile,"PDU_TYPE: GCC_ConferenceJoinRequest\n");
     PrintConferenceName(logfile,
						 connect_pdu->u.connect_join_request.conference_name);
     pduLog(logfile,"\tTag: %u\n",
	    connect_pdu->u.connect_join_request.tag);
     if(connect_pdu->u.connect_join_request.bit_mask & 0x10)
	 {
		PrintPasswordChallengeRequestResponse(logfile,
					connect_pdu->u.connect_join_request.cjrq_password);
	 }
	 if(connect_pdu->u.connect_join_request.bit_mask & 0x10)
	 {
		pduLog(logfile,"\tConvener ");
		PrintPasswordSelector(logfile,
			      connect_pdu->u.connect_join_request.cjrq_convener_password);
	 }
      //insert caller id here.
	 outdeb("BOTTOM: pduLogConnectJoinRequest\n");
 }

 /*********************************************************************/
 void pduLogQueryResponse(FILE *logfile, PConnectGCCPDU connect_pdu)
 {
	UShort                                                  i=0;
	SetOfConferenceDescriptors      * conference_list;
	CHAR                                                    print_buffer[255] = " ";

	pduLog(logfile,"PDU_TYPE: GCC_ConferenceQueryResponse\n");
	pduLog(logfile,"Node Query Information:\n");
	switch(connect_pdu->u.conference_query_response.node_type)
    {
		case GCC_TERMINAL:
			pduLog( logfile, "\tnode_type = GCC_TERMINAL\n");
			break;
		case GCC_MULTIPORT_TERMINAL:
			pduLog( logfile,
					"\tnode_type = GCC_MULTIPORT_TERMINAL\n");
			break;
		case GCC_MCU:
			pduLog( logfile, "\tnode_type = GCC_MCU\n");
			break;
		default:
			pduLog( logfile,                                                                   
					"\tGCCNODE: ERROR: UNKNOWN NODE TYPE\n");
			break;
	}

	// get a pointer to the returned conference list
	conference_list = connect_pdu->u.conference_query_response.conference_list;

	for(i=0;conference_list != NULL;i++)
	{
		pduLog(logfile,"\t**** Conference Record %u ****\n",i);
		pduLog(logfile,"\tConference Numeric Name: %s\n",
				conference_list->value.conference_name.numeric);
		CopySimpleTextToChar(print_buffer,
							 conference_list->value.conference_name.conference_name_text);
	    pduLog(logfile,"\tConference Text Name: %s\n",print_buffer);

		PrintT120Boolean(logfile,"conference_is_locked = ",
							conference_list->value.conference_is_locked);
		PrintT120Boolean(logfile,"clear_password_required = ",
							conference_list->value.clear_password_required);
		conference_list = conference_list->next;
	}

 }
 
 /*********************************************************************/
 void pduLogConferenceCreateRequest(FILE *logfile, PConnectGCCPDU connect_pdu)
 {
    char print_buffer[255] = "";
    
    pduLog(logfile,"PDU_TYPE: GCC_ConferenceCreateRequest\n");
    pduLog(logfile,"\tConference Numeric Name: %s\n",
	    connect_pdu->u.conference_create_request.conference_name.numeric);
    CopySimpleTextToChar(print_buffer,
	    connect_pdu->u.conference_create_request.conference_name.conference_name_text);
    pduLog(logfile,"\tConference Text Name: %s\n",print_buffer);
    PrintT120Boolean(logfile,
		     "\tConference Is Locked: ",
		     connect_pdu->u.conference_create_request.conference_is_locked);
    PrintT120Boolean(logfile,
		     "\tConference Is Listed: ",
		     connect_pdu->u.conference_create_request.conference_is_locked);
    PrintT120Boolean(logfile,
		     "\tConference Is Conductible: ",
		     connect_pdu->u.conference_create_request.conference_is_conductible);
    switch(connect_pdu->u.conference_create_request.termination_method)
    {
	case 0:
	    pduLog(logfile,"\tTermination Method: AUTOMATIC\n");
	    break;
	case 1:
	    pduLog(logfile,"\tTermination Method: MANUAL \n");
	    break;
	default:
	    pduLog(logfile,"\tTermination Method: UNKOWN \n");
	    break;
    }
    
    CopyTextToChar(print_buffer,
		    connect_pdu->u.conference_create_request.ccrq_caller_id);
    pduLog(logfile,"\tCaller ID: %s\n",print_buffer);
    
 }

 /*********************************************************************/
 void pduLogConferenceCreateResponse(FILE *logfile, PConnectGCCPDU connect_pdu)
 {
    pduLog(logfile,"PDU_TYPE: GCC_ConferenceCreateResponse\n");
    pduLog(logfile,"\tNode ID: %u\n",
	   connect_pdu->u.conference_create_response.node_id);
    pduLog(logfile,"\tTag: %d\n",connect_pdu->u.conference_create_response.tag);
    
    switch(connect_pdu->u.conference_create_response.result)
    {
	case 0:
	    pduLog(logfile,"\tResult: SUCCESS\n");
	    break;
	case 1:
	    pduLog(logfile,"\tResult: USER_REJECTED\n");
	    break;
	case 2:
	    pduLog(logfile,"\tResult: LOW_RESOURCES\n");
	    break;
	case 3:
	    pduLog(logfile,"\tResult: REJECTED_FOR_BREAKING_SYMMETRY\n");
	    break;
	case 4:
	    pduLog(logfile,"\tResult: LOCKED_CONFERENCE_NOT_SUPPORTED\n");
	    break;
	default:
	    pduLog(logfile,"\tResult: >>> Unkown Result Type\n");
	    break;
    }
 }

 /*********************************************************************/
 void pduLogConnectJoinResponse(FILE *logfile, PConnectGCCPDU connect_pdu)
 {
    pduLog(logfile,"PDU_TYPE: GCC_ConferenceJoinResponse\n");
    pduLog(logfile,"\tcjrs_node_id [%u]\n",
	    connect_pdu->u.connect_join_response.cjrs_node_id);
    pduLog(logfile,"\ttop_node_id [%u]\n",
	    connect_pdu->u.connect_join_response.top_node_id);
    PrintConferenceName(logfile,
			connect_pdu->u.connect_join_response.conference_name_alias);
    PrintT120Boolean(logfile,"\tclear_password_required = ",
			connect_pdu->u.connect_join_response.clear_password_required);
    PrintT120Boolean(logfile,"\tconference_is_locked = ",
			connect_pdu->u.connect_join_response.conference_is_locked);
    PrintT120Boolean(logfile,"\tconference_is_listed = ",
			connect_pdu->u.connect_join_response.conference_is_listed);
    PrintT120Boolean(logfile,"\tconference_is_conductible = ",
			connect_pdu->u.connect_join_response.conference_is_conductible);
    
    switch(connect_pdu->u.connect_join_response.termination_method)
    {
       case 0:
	    pduLog(logfile,"\tTermination Method: AUTOMATIC\n");
	    break;
	case 1:
	    pduLog(logfile,"\tTermination Method: MANUAL \n");
	    break;
	default:
	    pduLog(logfile,"\tTermination Method: UNKOWN \n");
	    break;
    }
    
    switch(connect_pdu->u.connect_join_response.result)
    {
	case 0:
	    pduLog(logfile,"\tResult: RESULT_SUCESS\n");
	    break;
	case 1:
	    pduLog(logfile,"\tResult: USER_REJECTED\n");
	    break;
	case 2:
	    pduLog(logfile,"\tResult: INVALID_CONFERENCE\n");
	    break;
	case 3:
	    pduLog(logfile,"\tResult: INALID_PASSWORD\n");
	    break;
	case 4:
	    pduLog(logfile,"\tResult: INVALID_CONVENER_PASSWORD\n");
	    break;
	case 5:
	    pduLog(logfile,"\tResult: CHALLENGE_RESPONSE_REQUIRED\n");
	    break;
	case 6:
	    pduLog(logfile,"\tResult: INVALID_CHALLENGE_RESPONSE\n");
	    break;
	default:
	    pduLog(logfile,"\tResult: >>>> Unkown Result <<<< \n");
	    break;
     }
 }

 /*********************************************************************/
 void pduLogConferenceJoinResponse(FILE *logfile, PGCCPDU gcc_pdu)
 {
    pduLog(logfile,"PDU_TYPE: GCC_ConferenceJoinResponse\n");
    pduLog(logfile,"\tcjrs_node_id [%u]\n",
	    gcc_pdu->u.response.u.conference_join_response.cjrs_node_id);
    pduLog(logfile,"\ttop_node_id [%u]\n",
	    gcc_pdu->u.response.u.conference_join_response.top_node_id);
    PrintConferenceName(logfile,
			gcc_pdu->u.response.u.conference_join_response.conference_name_alias);
    PrintT120Boolean(logfile,"\tclear_password_required = ",
			gcc_pdu->u.response.u.conference_join_response.clear_password_required);
    PrintT120Boolean(logfile,"\tconference_is_locked = ",
			gcc_pdu->u.response.u.conference_join_response.conference_is_locked);
    PrintT120Boolean(logfile,"\tconference_is_listed = ",
			gcc_pdu->u.response.u.conference_join_response.conference_is_listed);
    PrintT120Boolean(logfile,"\tconference_is_conductible = ",
			gcc_pdu->u.response.u.conference_join_response.conference_is_conductible);
    
    switch(gcc_pdu->u.response.u.conference_join_response.termination_method)
    {
       case 0:
	    pduLog(logfile,"\tTermination Method: AUTOMATIC\n");
	    break;
	case 1:
	    pduLog(logfile,"\tTermination Method: MANUAL \n");
	    break;
	default:
	    pduLog(logfile,"\tTermination Method: UNKOWN \n");
	    break;
    }
    
    switch(gcc_pdu->u.response.u.conference_join_response.result)
    {
	case 0:
	    pduLog(logfile,"\tResult: RESULT_SUCESS\n");
	    break;
	case 1:
	    pduLog(logfile,"\tResult: USER_REJECTED\n");
	    break;
	case 2:
	    pduLog(logfile,"\tResult: INVALID_CONFERENCE\n");
	    break;
	case 3:
	    pduLog(logfile,"\tResult: INALID_PASSWORD\n");
	    break;
	case 4:
	    pduLog(logfile,"\tResult: INVALID_CONVENER_PASSWORD\n");
	    break;
	case 5:
	    pduLog(logfile,"\tResult: CHALLENGE_RESPONSE_REQUIRED\n");
	    break;
	case 6:
	    pduLog(logfile,"\tResult: INVALID_CHALLENGE_RESPONSE\n");
	    break;
	default:
	    pduLog(logfile,"\tResult: >>>> Unkown Result <<<< \n");
	    break;
     }
 }


 /*********************************************************************/
 void pduLogConferenceInviteRequest(FILE *logfile, PConnectGCCPDU connect_pdu)
 {
    char print_buffer[255] = " ";
    
    pduLog(logfile,"PDU_TYPE: GCC_ConferenceInviteRequest\n");
    pduLog(logfile,"\tConference Numeric Name: %s\n",
	    connect_pdu->u.conference_invite_request.conference_name.numeric);
    CopySimpleTextToChar(print_buffer,
	    connect_pdu->u.conference_invite_request.conference_name.conference_name_text);
    pduLog(logfile,"\tConference Text Name: %s\n",print_buffer);
    pduLog(logfile,"\tnode_id [%u]\n",
	    connect_pdu->u.conference_invite_request.node_id);
    pduLog(logfile,"\top_node_id [%u]\n",
	    connect_pdu->u.conference_invite_request.top_node_id);
    PrintT120Boolean(logfile,"\tclear_password_required = ",
		     connect_pdu->u.conference_invite_request.clear_password_required);
    PrintT120Boolean(logfile,"\tconference_is_locked = ",
		     connect_pdu->u.conference_invite_request.conference_is_locked);
    PrintT120Boolean(logfile,"\tconference_is_conductible = ",
		     connect_pdu->u.conference_invite_request.conference_is_conductible);
 
    switch(connect_pdu->u.conference_invite_request.termination_method)
    {
       case 0:
	    pduLog(logfile,"\tTermination Method: AUTOMATIC\n");
	    break;
	case 1:
	    pduLog(logfile,"\tTermination Method: MANUAL \n");
	    break;
	default:
	    pduLog(logfile,"\tTermination Method: UNKOWN \n");
	    break;
    }
 }    
    
 
 /*********************************************************************/
 void pduLogConferenceInviteResponse(FILE *logfile, PConnectGCCPDU connect_pdu)
 {
    pduLog(logfile,"PDU_TYPE: GCC_ConferenceInviteResponse\n");
    
    switch(connect_pdu->u.conference_invite_response.result)
    {
	case 0:
	    pduLog(logfile,"\tResult: RESULT_SUCCESS\n");
	    break;
	case 1:
	    pduLog(logfile,"\tResult: USER_REJECTED\n");
	    break;
	default:
	    pduLog(logfile,"\t>>>> Unkonw Result <<<<\n");
	    break;
    }
 }

 /*********************************************************************/
 void pduLogConferenceAddRequest(FILE *logfile, PGCCPDU gcc_pdu)
 {
	 pduLog(logfile,"PDU_TYPE: GCC_ConferenceAddRequest\n");
	 pduLog(logfile,"\tNot printing add_request_net_address -- todo later\n");
	 pduLog(logfile,"\trequesting_node = [%u]\n",gcc_pdu->u.request.u.conference_add_request.requesting_node);
	 pduLog(logfile,"\ttag = [%l]\n",gcc_pdu->u.request.u.conference_add_request.tag);
	 if(gcc_pdu->u.request.u.conference_add_request.bit_mask & 0x80) // adding mcu presnt
	 {
		 pduLog(logfile,"\tadding_mcu = [%u]\n",
						gcc_pdu->u.request.u.conference_add_request.adding_mcu);
	 }
 }

 /*********************************************************************/
 void pduLogConferenceAddResponse(FILE *logfile, PGCCPDU gcc_pdu)
 {
	 pduLog(logfile,"PDU_TYPE: GCC_ConferenceAddResponse\n");
	 pduLog(logfile,"\ttag = [%l]\n",gcc_pdu->u.response.u.conference_add_response.tag);
	 PrintConferenceAddResult(logfile,gcc_pdu->u.response.u.conference_add_response.result);
	 // user data is optional.
 }
 /*********************************************************************/
 void   pduLogGCCConnectInfo(FILE *logfile, PConnectGCCPDU connect_pdu)
 {
    switch(connect_pdu->choice)
    {
	case CONFERENCE_CREATE_REQUEST_CHOSEN:
	    {
		pduLogConferenceCreateRequest(logfile,connect_pdu);
	    }
	    break;
	case CONFERENCE_CREATE_RESPONSE_CHOSEN:
	    {
		pduLogConferenceCreateResponse(logfile, connect_pdu);
	    }
	    break;
	case CONFERENCE_QUERY_REQUEST_CHOSEN:
	    {
		pduLog(logfile,"PDU_TYPE: GCC_ConferenceQueryRequest\n");
	    }
	    break;
	case CONFERENCE_QUERY_RESPONSE_CHOSEN:
	    {
		pduLogQueryResponse(logfile,connect_pdu);
				//pduLog(logfile,"PDU_TYPE: GCC_ConferenceQueryResponse\n");
	    }
	    break;
	case CONNECT_JOIN_REQUEST_CHOSEN:
	    {
		pduLogConnectJoinRequest(logfile,connect_pdu);                  
	    }
	    break;
	case CONNECT_JOIN_RESPONSE_CHOSEN:
	    {
		 pduLogConnectJoinResponse(logfile,connect_pdu);
	    }
	    break;
	case CONFERENCE_INVITE_REQUEST_CHOSEN:
	    {
		pduLogConferenceInviteRequest(logfile,connect_pdu);
	    }
	    break;
	case CONFERENCE_INVITE_RESPONSE_CHOSEN:
	    {
		pduLogConferenceInviteResponse(logfile,connect_pdu);
	    }
	    break;
	default:
	    {
		pduLog(logfile,"PDU_TYPE: ERROR -- Cannot decode the ConnectGCCPDU\n");
	    }
	    break;
     }
 }

 /*********************************************************************/
 void   pduLogGCCInformation(FILE *logfile, PGCCPDU gcc_pdu)
 {
    switch(gcc_pdu->choice)
    {
	case INDICATION_CHOSEN:
	    {
		switch(gcc_pdu->u.indication.choice)
		{
		    case USER_ID_INDICATION_CHOSEN:
			{
			    pduLogUserIDIndication(logfile,gcc_pdu);
			}
			break;
		    case ROSTER_UPDATE_INDICATION_CHOSEN:
			{
			    pduLogRosterUpdateIndication(logfile,gcc_pdu);
			}
			break;
		    case TEXT_MESSAGE_INDICATION_CHOSEN:
			{
			    pduLogTextMessageIndication(logfile,gcc_pdu);
			}
			break;
		    case CONFERENCE_LOCK_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceLockIndication\n");
			}
			break;
		    case CONFERENCE_UNLOCK_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceUnlockIndication\n");
			}
			break;
		    case CONDUCTOR_RELEASE_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConductorRelaseIndication\n");
			}
			break;
		    case CONFERENCE_TERMINATE_INDICATION_CHOSEN:
			{
			    pduLogConferenceTerminateIndication(logfile,gcc_pdu);
			}     
			break;
		    case CONDUCTOR_ASSIGN_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConductorAssignIndication\n");
			    pduLog(logfile,"   User ID: %d\n",
				    gcc_pdu->u.indication.u.conductor_assign_indication.user_id);
			}
			break;
		    case CONDUCTOR_PERMISSION_ASK_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConductorPermissionAskIndication\n");
			    pduLog(logfile,"   Permission Granted Flag: %d\n",
				    gcc_pdu->u.indication.u.conductor_permission_ask_indication.permission_is_granted);
			}
			break;
		    case CONDUCTOR_PERMISSION_GRANT_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConductorPermissionGrantIndication\n");
			}
			break;
		    case APPLICATION_INVOKE_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ApplicationInvokeIndication\n");
			}
			break;
		    case CONFERENCE_TRANSFER_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceTransferIndication\n");
			}
			break;
		    case REGISTRY_MONITOR_ENTRY_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_RegistryMonitorEntryIndication\n");
			}
			break;
		    case CONFERENCE_TIME_REMAINING_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceTimeRemainingIndication\n");
			}
			break;
		    case CONFERENCE_TIME_INQUIRE_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceTimeInquireIndication\n");
			}
			break;
		    case CONFERENCE_TIME_EXTEND_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceTimeExtendIndication\n");
			}
			break;
		    case CONFERENCE_EJECT_USER_INDICATION_CHOSEN:
			{
			    pduLogConferenceEjectUserIndication(logfile,gcc_pdu);
			}
			break;
		    case NON_STANDARD_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_NonStandardPDU\n");
			}
			break;
		    default:
			{
			    pduLog(logfile,"PDU_TYPE: ERROR -- Cannot decode the Indication GCCPDU\n");
			}
			break;
		}
	    }
	    break;
	case RESPONSE_CHOSEN:
	    {
		switch(gcc_pdu->u.response.choice)
		{
		    case CONFERENCE_JOIN_RESPONSE_CHOSEN:
			{
			    pduLogConferenceJoinResponse(logfile,gcc_pdu);
			}
			break;
		    case CONFERENCE_ADD_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceAddResponse\n");
			}
			break;
		    case CONFERENCE_LOCK_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceLockResponse\n");
			}
			break;
		    case CONFERENCE_UNLOCK_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceUnlockResponse\n");
			}
		    case CONFERENCE_TERMINATE_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceTerminateResponse\n");
			    switch(gcc_pdu->u.response.u.conference_terminate_response.result)
			    {
				case 0:
				    pduLog(logfile,"\tResult: RESULT_SUCESS\n");
				    break;
				case 1:
				    pduLog(logfile,"\tResult: INVALID_REQUESTOR\n");
				    break;
				default:
				    pduLog(logfile,"\tResult: >>> Unknown Result <<<\n");
				    break;
			     }
			}
			break;
		    case CONFERENCE_EJECT_USER_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_EjectUserResponse\n");
			    pduLog(logfile,"\tnode_to_eject: [%u]\n",
				    gcc_pdu->u.response.u.conference_eject_user_response.node_to_eject);
			    switch(gcc_pdu->u.response.u.conference_eject_user_response.result)
			    {
				case 0:
				    pduLog(logfile,"\tResult: RESULT_SUCCESS\n");
				    break;
				case 1:
				    pduLog(logfile,"\tResult: INVALID_REQUESTER\n");
				    break;
				default:
				    pduLog(logfile,"\tResult: >>> Unkown Result <<<\n");
				    break;
			    }
			}
			break;
		    case CONFERENCE_TRANSFER_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceTransferResponse\n");
			}
			break;
		    case REGISTRY_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_RegistryResponse\n");
			}
			break;
		    case REGISTRY_ALLOCATE_HANDLE_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_RegistryAllocateHandleResponse\n");
			}
			break;
		    case FUNCTION_NOT_SUPPORTED_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_FunctionNotSupported\n");
			}
			break;
		    case NON_STANDARD_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_NonStandardResponse\n");
			}
			break;
		    default:
		    {
			pduLog(logfile,"PDU_TYPE: ERROR -- Cannot decode Response GCC PDU\n");
		    }
		    break;
		}
	    }
	    break;
	case REQUEST_CHOSEN:
	    {
		switch(gcc_pdu->u.request.choice)
		{
		    case CONFERENCE_JOIN_REQUEST_CHOSEN:
			{
			    pduLogConferenceJoinRequest(logfile,gcc_pdu);
			}
			break;
		    case CONFERENCE_ADD_REQUEST_CHOSEN:
			{
			    //pduLog(logfile,"PDU_TYPE: GCC_ConferenceAddRequest\n");
							pduLogConferenceAddRequest(logfile,gcc_pdu);
			}
			break;
		    case CONFERENCE_LOCK_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceLockRequest\n");
			}
			break;
		    case CONFERENCE_UNLOCK_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceUnlockRequest\n");
			}
			break;
		    case CONFERENCE_TERMINATE_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceTerminateRequest\n");
			    switch(gcc_pdu->u.request.u.conference_terminate_request.reason)
			    {
				case 0:
				    pduLog(logfile,"\tReason: USER_INITIATED\n");
				    break;
				case 1:
				    pduLog(logfile,"\tReason: CONFERENCE_TERMINATED\n");
				    break;
				default:
				    pduLog(logfile,"\tReason: >>> Unkown Reason <<<\n");
				    break;
			     }
			}
			break;
		    case CONFERENCE_EJECT_USER_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_EjectUserRequest\n");
			    pduLog(logfile,"\tnode_to_eject: [%u]\n",
				    gcc_pdu->u.request.u.conference_eject_user_request.node_to_eject);
			    pduLog(logfile,"\tReason: USER_INITIATED\n");
			    // Note there is only one reason for a eject request
			}
			break;
		    case CONFERENCE_TRANSFER_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceTransferRequest\n");
			}
			break;
		    case REGISTRY_REGISTER_CHANNEL_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_RegistryRegisterChannelRequest\n");
			}
			break;
		    case REGISTRY_ASSIGN_TOKEN_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_AssignTokenRequest\n");
			}
			break;
		    case REGISTRY_SET_PARAMETER_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_RegistrySetParameterRequest\n");
			}
			break;
		    case REGISTRY_RETRIEVE_ENTRY_REQUEST_CHOSEN: 
			{
			    pduLog(logfile,"PDU_TYPE: GCC_RegistryRetrieveEntryRequest\n");
			}
			break;
		    case REGISTRY_DELETE_ENTRY_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_RegistryDeleteEntryRequest\n");
			}
			break;
		    case REGISTRY_MONITOR_ENTRY_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_RegistryMonitorEntryRequest\n");
			}
			break;
		    case REGISTRY_ALLOCATE_HANDLE_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_RegistryAllocateHandleRequest\n");
			}
			break;
		    case NON_STANDARD_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_NonStandardRequest\n");
			}
			break;
		    default:
			{
			    pduLog(logfile,"PDU_TYPE: ERROR  Cannot decode the Request GCC PDU\n");
			}
			break;
		}
	    }
	    break;
	default: 
	    {
		// write something, just so we know we got a PDU.
		pduLog(logfile,"PDU_TYPE: ERROR -- Cannot decode unkown PDU");
	    }
	    break;
    }
 }






/// ********************************************************************************
/// PDU PRINTING FUNCTIONS
/// ********************************************************************************

/*********************************************************************/
T120Boolean CopyCharToNumeric(  GCCNumericString        numeric_string,
				Char *                          temp_buffer )
{ 
	if( strcpy((Char *)numeric_string, (const Char *) temp_buffer ) == NULL )
		return(FALSE);
	else
		return(TRUE);
}

/*********************************************************************/
T120Boolean CopyCharToText(LPWSTR text_string, Char *temp_buffer )
{
	UShort  length;
	UShort  i;
	
	length = strlen( temp_buffer );
	
	for(i=0;i < length;i++)
	{
		text_string[i] = (UShort) temp_buffer[i];
	}
	text_string[length] = 0x0000;


	return( TRUE );
}

/*********************************************************************/
T120Boolean CompareTextToNULL( LPWSTR unicode_string )
{
	/*
	 *      If the entry from GCCNODE.INI is the text string NULL, then we will
	 *      pass NULL for this parameter.  A LPWSTR is a UShort array.
	 */
	 //TODO: resolve this and remove
	 if( unicode_string == 0x0000 )
		return( FALSE );
	if(     ( unicode_string[0] == 0x004E ) &&      
		( unicode_string[1] == 0x0055 ) &&      
		( unicode_string[2] == 0x004C ) &&      
		( unicode_string[3] == 0x004C ) )       
		return( TRUE );
	else
		return( FALSE );
}

/*********************************************************************/
T120Boolean CompareNumericToNULL( GCCNumericString numeric_string )
{
	/*
	 *      If the entry from GCCNODE.INI is the text string NULL, then we will
	 *      pass NULL for this parameter.  A GCCNumericString is an array of UChar.
	 */
	 //TODO: resolve this and remove
	 if( numeric_string == NULL )
		return( FALSE );
	 if( strcmp( (const Char *) numeric_string, "NULL" ) == 0 )
		return( TRUE );
	else
		return( FALSE );
}

/*********************************************************************/
T120Boolean CopySimpleTextToChar (Char * print_string,
				    SimpleTextString text_string)
{
	UShort  i;
    UShort text_string_length;
    LPWSTR text_string_value;
	
	text_string_length = text_string.length;
    text_string_value  = text_string.value;

	//TODO: clean the next few lines up -- its a temp workaround
	//      because databeam does not initialize the length field to 0
	//      when there is no string.
	if(print_string==NULL)
		return(FALSE);

	if((text_string_length<=0)||(text_string_value == NULL))
		return(FALSE);
	
	if((*text_string_value == 0x0000))
		return (FALSE);

	for(i=0; i<text_string_length;i++)
	{
		if( ((text_string_value+i)==NULL) || (*(text_string_value+i) == 0x0000) )
			break;  
		print_string[i] = (Char) text_string_value[i];
	}
	print_string[i] = 0;
	
	return(TRUE);
}

/*********************************************************************/
T120Boolean CopyTextToChar(Char * print_string,
					   TextString text_string)
{
	UShort  i;
    UShort text_string_length;
    LPWSTR text_string_value;         
	
	outdeb("TOP: CopyTextToChar\n");
	if(print_string==NULL)
		return(FALSE);

	text_string_length = text_string.length;
    text_string_value  = text_string.value;

	outdeb("CopyTextToChar: length and values copied\n");

	if((text_string_length <= 0)||(text_string_value == NULL))
		return( FALSE );
	outdeb("length is not 0 && value is not NULL\n");

	if (*text_string_value == 0x0000)
		return (FALSE);
	outdeb("content is not empty\n");

	for(i=0;i < text_string_length;i++)
	{
		if( ((text_string_value+i)==NULL) || (*(text_string_value+i) == 0x0000))
			break;
		print_string[i] = (Char) text_string_value[i];
		outdeb(print_string);
		outdeb("..copied\n");
	
	}
	print_string[i] = 0;
	
	return(TRUE);
}

/*********************************************************************/
T120Boolean CopyUnicodeToChar(Char *print_string, LPWSTR text_string)
{
	UShort  i;
    UShort text_string_length;
	
	if( text_string == NULL )
		return( FALSE );
	else
	{
	      text_string_length = 0;
	      while(text_string[text_string_length] != 0x0000)
		text_string_length++;
		
	      for(i=0;i < text_string_length;i++)
		{
			print_string[i] = (Char) text_string[i];
		}
		print_string[text_string_length] = 0;
	}
	
	return( TRUE );
}




/**
 **     These functions print common sturcture entries.
 */
/*********************************************************************/
Void PrintPrivilegeList(
			GCCConferencePrivileges FAR *   privilege_list,
			Char FAR *                                              print_text,
			FILE *                                                  logfile )
{
	if( privilege_list->terminate_is_allowed )
		pduLog( logfile,
					"%sterminate_is_allowed = TRUE",
					print_text);
	else
		pduLog( logfile,
					"%sterminate_is_allowed = FALSE",
					print_text);
					
	if( privilege_list->eject_user_is_allowed  )
		pduLog( logfile,
					"%seject_user_is_allowed = TRUE",
					print_text);
	else
		pduLog( logfile,
					"%seject_user_is_allowed = FALSE",
					print_text);
					
	if( privilege_list->add_is_allowed  )
		pduLog( logfile,
					"%sadd_is_allowed = TRUE",
					print_text);
	else
		pduLog( logfile,
					"%sadd_is_allowed = FALSE",
					print_text);
					
	if( privilege_list->lock_unlock_is_allowed  )
		pduLog( logfile,
					"%slock_unlock_is_allowed = TRUE",
					print_text);
	else
		pduLog( logfile,
					"%slock_unlock_is_allowed = FALSE",
					print_text);
					
	if( privilege_list->transfer_is_allowed  )
		pduLog( logfile,
					"%stransfer_is_allowed = TRUE",
					print_text);
	else
		pduLog( logfile,
					"%stransfer_is_allowed = FALSE",
					print_text);
					
}


/*********************************************************************/
Void PrintPasswordChallengeRequestResponse(FILE * logfile, 
				PasswordChallengeRequestResponse chrqrs_password)       
{
	switch(chrqrs_password.choice)
	{
	case CHALLENGE_CLEAR_PASSWORD_CHOSEN:
		pduLog(logfile,"\tClear ");
		PrintPasswordSelector(logfile,chrqrs_password.u.challenge_clear_password);
		break;
	case CHALLENGE_REQUEST_RESPONSE_CHOSEN:
		pduLog(logfile,"\t Challenge Request Response Password not implemented\n");
		break;
	default:
		pduLog(logfile,"\t Conference Password is NULL\n");
		break;
	}
}

/*********************************************************************/
Void PrintConferenceName(FILE * logfile,
			     ConferenceNameSelector     conference_name )
{
	Char print_buffer[255] = "";

    switch(conference_name.choice)
    {
		case NAME_SELECTOR_NUMERIC_CHOSEN:
			pduLog(logfile,
		   "\tNumeric Name Selector: [%s]\n",
		   conference_name.u.name_selector_numeric);
	    break;
		case NAME_SELECTOR_TEXT_CHOSEN:
			CopySimpleTextToChar(print_buffer,
				 conference_name.u.name_selector_text);
	    pduLog(logfile,
		   "\tText Name Selector: [%s]\n",
		   print_buffer);
	    break;
	}
}


/*********************************************************************/
Void PrintPasswordSelector(FILE *logfile, PasswordSelector password_selector)
{
	Char print_buffer[255] = "";

	switch(password_selector.choice)
	{
	case PASSWORD_SELECTOR_NUMERIC_CHOSEN:
		pduLog(logfile,
				"Numeric Password Selector: [%s]\n",
				password_selector.u.password_selector_numeric);
		break;
	case PASSWORD_SELECTOR_TEXT_CHOSEN:
		CopySimpleTextToChar(print_buffer,
							 password_selector.u.password_selector_text);
		pduLog(logfile,
				"Text Password Selector: [%s]\n",
				print_buffer);
		break;
	default:
		pduLog(logfile,"\tPassword Selector: [none]\n");
		break;
	}
}


/*********************************************************************/
int PrintObjectID(FILE *logfile, ObjectID object_id)
{
	if((object_id==NULL)||(logfile==NULL))
		return FALSE;

	pduLog(logfile,"\tObject ID = { ");
	for(; object_id != NULL; object_id = object_id->next)
	{
		pduLog(logfile,"%ul ",object_id->value);
	}
	pduLog(logfile,"}\n");
	return TRUE;
}

/*********************************************************************/
void PrintH221NonStandardIdentifier(FILE *logfile, H221NonStandardIdentifier h221_id)
{
	char print_buffer[255];
	strncpy(print_buffer,(char *)h221_id.value,h221_id.length);
	pduLog(logfile,"\t\tH221_Non_Standard_Identifier = [%s]\n",print_buffer);
}

/*********************************************************************/
void PrintKey(FILE *logfile, Key key)
{
	switch(key.choice)
	{
	case OBJECT_CHOSEN:
		PrintObjectID(logfile,key.u.object);
		break;
	case H221_NON_STANDARD_CHOSEN:
		PrintH221NonStandardIdentifier(logfile,key.u.h221_non_standard);
		break;
	default:
		pduLog(logfile,"\t\t>>>> Cannot print Key\n");
		break;
	}
}

/*********************************************************************/
void PrintChannelType(FILE *logfile, ChannelType channel_type)
{
	pduLog(logfile,"\t\tChannel Type = ");
	switch(channel_type)
	{
	case 0:
		pduLog(logfile,"CHANNEL_TYPE_STATIC\n");
		break;
	case 1:
		pduLog(logfile,"DYNAMIC_MULTICAST\n");
		break;
	case 2:
		pduLog(logfile,"DYNAMIC_PRIVATE\n");
		break;
	case 3:
		pduLog(logfile,"DYNAMIC_USERID\n");
		break;
	default:
		pduLog(logfile,"ERROR: cannot determinte channel type \n");
		break;
	}
}

/*********************************************************************/
void PrintSessionKey(FILE *logfile, SessionKey session_key)
{
	PrintKey(logfile, session_key.application_protocol_key);
	if(session_key.bit_mask & 0x80)
		pduLog(logfile,"\t\tsession_id = [%u]\n",session_key.session_id);
}

/*********************************************************************/
void PrintCapabilityID(FILE *logfile, CapabilityID capability_id)
{
	switch(capability_id.choice)
	{
	case STANDARD_CHOSEN:
		pduLog(logfile,"\t\tCapability ID:  standard = [%u]\n",
				capability_id.u.standard);
		break;
	case CAPABILITY_NON_STANDARD_CHOSEN:
		pduLog(logfile,"\t\tNon Stnadard Capability Key:\n");
		PrintKey(logfile,capability_id.u.capability_non_standard);
		break;
	default:
		pduLog(logfile,"ERROR: cannot determine capability id\n");
	}
}
		
/*********************************************************************/
Void PrintApplicationRecord(FILE *logfile, ApplicationRecord application_record)
{
	unsigned int i=0;
	char print_buffer[255];

	PrintT120Boolean(logfile,
					"\t\tapplication_is_active = ",
					application_record.application_is_active);
	PrintT120Boolean(logfile,
					"\t\tis_conducting_capable = ",
					application_record.is_conducting_capable);
	if(application_record.bit_mask & RECORD_STARTUP_CHANNEL_PRESENT)
	{
		PrintChannelType(logfile, application_record.record_startup_channel);
	}
	if(application_record.bit_mask & APPLICATION_USER_ID_PRESENT)
	{
		pduLog(logfile,"\t\tapplication_user_id = [%u] \n",
				application_record.application_user_id);
	}
	if(application_record.bit_mask & NON_COLLAPSING_CAPABILITIES_PRESENT)
	{
		for(i=0;application_record.non_collapsing_capabilities != NULL; i++)
		{
			pduLog(logfile,"\t**** non collapsing capabilities record [%u] ****\n",i);
			PrintCapabilityID(logfile,application_record.non_collapsing_capabilities->value.capability_id);
			if((application_record.non_collapsing_capabilities->value.bit_mask & APPLICATION_DATA_PRESENT) &&
			   (application_record.non_collapsing_capabilities->value.application_data.value != NULL))
			{
				pduLog(logfile,"\tApplication Data :\n");
				pduRawOutput(logfile,application_record.non_collapsing_capabilities->value.application_data.value,
							 application_record.non_collapsing_capabilities->value.application_data.length);
				strncpy(print_buffer, (char *) application_record.non_collapsing_capabilities->value.application_data.value,
						   application_record.non_collapsing_capabilities->value.application_data.length);
				pduLog(logfile,"\tApplication Data (text): %s\n",print_buffer);

			}
			application_record.non_collapsing_capabilities = 
				application_record.non_collapsing_capabilities->next;
		}
	}
} 

/*********************************************************************/
void PrintCapabilityClass(FILE *logfile, CapabilityClass capability_class)
{
	pduLog(logfile,"\t\tCapability Class: ");
	switch(capability_class.choice)
	{
	case LOGICAL_CHOSEN:
		pduLog(logfile,"Logical.\n");
		break;
	case UNSIGNED_MINIMUM_CHOSEN:
		pduLog(logfile,"unsigned_minimum = [%u]\n",capability_class.u.unsigned_minimum);
		break;
	case UNSIGNED_MAXIMUM_CHOSEN:
		pduLog(logfile,"unsigned_maximum = [%u]\n",capability_class.u.unsigned_maximum);
		break;
	default:
		pduLog(logfile,"ERROR: unable to decode capability class\n");
		break;
	}
}


/*********************************************************************/
void PrintApplicationUpdate(FILE *logfile, ApplicationUpdate application_update)
{
	pduLog(logfile,"*** Application Update ***\n");
	
	switch(application_update.choice)
	{
	case APPLICATION_ADD_RECORD_CHOSEN:
		pduLog(logfile,"Update Type = application_add_record\n");
		PrintApplicationRecord(logfile, application_update.u.application_add_record);
		break;
	case APPLICATION_REPLACE_RECORD_CHOSEN:
		pduLog(logfile,"Update Type = application_replace_record\n");
		PrintApplicationRecord(logfile, application_update.u.application_replace_record);
		break;
	case APPLICATION_REMOVE_RECORD_CHOSEN:
		pduLog(logfile,"Update Type = application_remove_record\n");
		pduLog(logfile,"\tApplication is removed\n");
		break;
	default:
		pduLog(logfile,"ERROR: Cannot decode Application Update\n");
		break;
	}
}

/*********************************************************************/
void PrintApplicationRecordList(FILE *logfile, ApplicationRecordList application_record_list)
{
	int i = 0;
	switch(application_record_list.choice)
	{
	case APPLICATION_NO_CHANGE_CHOSEN:
		pduLog(logfile,"No Change in Application Record List\n");
		break;
	case APPLICATION_RECORD_REFRESH_CHOSEN:
		pduLog(logfile,"Application Record Refresh:\n");
		for(i=0; application_record_list.u.application_record_refresh !=NULL; i++)
		{
			pduLog(logfile,"\t**** Application record refresh [%u] ***\n",i);
			pduLog(logfile,"\t\tnode_id = [%u]\n",
					application_record_list.u.application_record_refresh->value.node_id);
			pduLog(logfile,"\t\tentity_id = [%u]\n",
					application_record_list.u.application_record_refresh->value.entity_id);
			PrintApplicationRecord(logfile,application_record_list.u.application_record_refresh->value.application_record);

			application_record_list.u.application_record_refresh = 
				application_record_list.u.application_record_refresh->next;
		}
		break;
	case APPLICATION_RECORD_UPDATE_CHOSEN:
		pduLog(logfile,"Application Record Update:\n");
		for(i=0; application_record_list.u.application_record_update !=NULL; i++)
		{
			pduLog(logfile,"\t**** Application record update [%u] ***\n",i);
			pduLog(logfile,"\t\tnode_id = [%u]\n",
				application_record_list.u.application_record_update->value.node_id);
			pduLog(logfile,"\t\tentity_id = [%u]\n",
				application_record_list.u.application_record_update->value.entity_id);
			PrintApplicationUpdate(logfile,application_record_list.u.application_record_update->value.application_update);

			application_record_list.u.application_record_refresh =
				application_record_list.u.application_record_refresh->next;
		}
		break;
	default:
		pduLog(logfile,"ERROR: Application Record List could not be decoded\n");
		break;
	}
}

/*********************************************************************/
void PrintApplicationCapabilitiesList(FILE *logfile, ApplicationCapabilitiesList application_capabilities_list)
{
	unsigned int i = 0;

	pduLog(logfile,"Application Capabilities List\n");
	switch(application_capabilities_list.choice)
	{
	case CAPABILITY_NO_CHANGE_CHOSEN:
		pduLog(logfile,"\tNo change in capabilities\n");
		break;
	case APPLICATION_CAPABILITY_REFRESH_CHOSEN:
		pduLog(logfile,"\tCapability Refreshes:\n");
		for(i=0; application_capabilities_list.u.application_capability_refresh != NULL; i++)
		{
			pduLog(logfile,"\t**** capability refresh [%u] ****\n",i);
			PrintCapabilityID(logfile,application_capabilities_list.u.application_capability_refresh->value.capability_id);
			PrintCapabilityClass(logfile,application_capabilities_list.u.application_capability_refresh->value.capability_class);
			pduLog(logfile,"\t\tnumber_of_entities = [%u]\n",
					application_capabilities_list.u.application_capability_refresh->value.number_of_entities);

			application_capabilities_list.u.application_capability_refresh = 
				application_capabilities_list.u.application_capability_refresh->next;
		}
		break;
	default:
		pduLog(logfile,"ERROR: Cannot decode capabilities list\n");
	}
}

/*********************************************************************/
void PrintConferenceAddResult(FILE *logfile, ConferenceAddResult result)
{
	pduLog(logfile,"\tResult = ");
	switch(result)
	{
	case 0:
		pduLog(logfile,"SUCCESS\n");
		break;
	case 1:
		pduLog(logfile,"INVALID_REQUESTER\n");
		break;
	case 2:
		pduLog(logfile,"INVALID_NETWORK_ADDRESS\n");
		break;
	case 3:
		pduLog(logfile,"ADDED_NODE_BUSY\n");
		break;
	case 4:
		pduLog(logfile,"NETWORK_BUSY\n");
		break;
	case 5:
		pduLog(logfile,"NO_PORTS_AVAILABLE\n");
		break;
	case 6:
		pduLog(logfile,"CONNECTION_UNSUCCESSFUL\n");
		break;
	default:
		pduLog(logfile,">>> undecodable result <<<\n");
		break;
	}
}

/*********************************************************************/
Void PrintConferenceRoster(FILE *logfile, NodeInformation node_information)
{
	UShort                                                  i;
	NodeRecordList                  node_record_list;
	Char                                                    print_buffer[255] =  "";
	
	outdeb("TOP: PrintConferenceRoster\n");

	pduLog(logfile,
			"\tinstance_number [%u]\n",
			node_information.roster_instance_number );
			
	PrintT120Boolean(logfile,
					 "\tnodes_are_added",
					 node_information.nodes_are_added);

	PrintT120Boolean(logfile,
					 "\tnodes_are_removed",
					 node_information.nodes_are_removed );
				
	/*
	 *      Extract the node_information_list pointer from the
	 *      conf_roster structure.
	 */
	node_record_list = node_information.node_record_list;
	
	switch (node_record_list.choice)
	{
	    case NODE_NO_CHANGE_CHOSEN:
		{
		    pduLog(logfile,"\tConference Roster: No Change\n");
		}
		break;
	    case NODE_RECORD_REFRESH_CHOSEN:
		{
		    outdeb("Node record refresh chosen \n");
					for(i=0; node_record_list.u.node_record_refresh != NULL; i++)
		    {
			pduLog( logfile,"\tConference Refresh Record [%u]************************\n", i );
						pduLog( logfile,
								"\t\tnode_id [%u]\n", 
				node_record_list.u.node_record_refresh->value.node_id );  
			pduLog( logfile,
				"\t\tsuperior_node_id [%u]\n",
				node_record_list.u.node_record_refresh->value.node_record.superior_node);

						/* figure out the node type */
						switch( node_record_list.u.node_record_refresh->value.node_record.node_type)
						{
							case GCC_TERMINAL:
								pduLog( logfile, "\t\tnode_type = GCC_TERMINAL\n");
								break;
							case GCC_MULTIPORT_TERMINAL:
								pduLog( logfile,
										"\t\tnode_type = GCC_MULTIPORT_TERMINAL\n");
							break;
							case GCC_MCU:
								pduLog( logfile, "\t\tnode_type = GCC_MCU\n");
								break;
							default:
								pduLog( logfile,
										"\t\tGCCNODE: ERROR: UNKNOWN NODE TYPE\n");
								break;
						}
				
						pduLog(logfile,"\t\tdevice_is_manager: [%u]\n",
								node_record_list.u.node_record_refresh->value.node_record.node_properties.device_is_manager); 
		     
			pduLog(logfile,"\t\tdevice_is_peripheral: [%u] \n",
			       node_record_list.u.node_record_refresh->value.node_record.node_properties.device_is_peripheral);
			
			/* print the node_name field */
						if(CopyTextToChar(print_buffer, 
					  node_record_list.u.node_record_refresh->value.node_record.node_name))
							pduLog( logfile, "\t\tnode_name is [%s]\n", print_buffer );
						else                                            
							pduLog( logfile, "\t\tnode_name is NULL\n");

						print_buffer[0] = 0;

						/* print the participants_list fields */
						if((node_record_list.u.node_record_refresh->value.node_record.participants_list != NULL)
						   && (node_record_list.u.node_record_refresh->value.node_record.bit_mask & 0x20))
						{
							for(i=0;node_record_list.u.node_record_refresh->value.node_record.participants_list->next!=NULL;i++)
							{
								if(CopyTextToChar(print_buffer,node_record_list.u.node_record_refresh->value.node_record.participants_list->value))
									pduLog(logfile, "\t\tparticipant %u is: [%s]\n", print_buffer);
								else
									pduLog(logfile, "\t\tparticipant_list record is NULL\n");       
								
								node_record_list.u.node_record_refresh->value.node_record.participants_list =
									node_record_list.u.node_record_refresh->value.node_record.participants_list->next;
							}
						}

											
						/* print the site_information field */
						outdeb("printing site information\n");
						if(node_record_list.u.node_record_refresh->value.node_record.bit_mask & 0x10)
						{
							if(CopyTextToChar(print_buffer,
									      node_record_list.u.node_record_refresh->value.node_record.site_information))
								pduLog( logfile,
										"\t\tsite_information is [%s]\n",
										print_buffer ); 
				else
								pduLog( logfile, "\t\tsite_information is NULL\n");
						}
		    
			node_record_list.u.node_record_refresh =
			    node_record_list.u.node_record_refresh->next;
		    } // end of for loop
		}       
		break;
	    case NODE_RECORD_UPDATE_CHOSEN:
		{
		    outdeb("Node Record Update Chosen\n");
		    for(i=0;node_record_list.u.node_record_update!=NULL;i++)
		    {
			pduLog(logfile,"\t**********Conference Update Record [%u] **********\n",i);
			pduLog(logfile,"\t\tnode_id [%u]\n",
				node_record_list.u.node_record_update->value.node_id);
			switch(node_record_list.u.node_record_update->value.node_update.choice)
			{
							case NODE_ADD_RECORD_CHOSEN:
								outdeb("Node Add Record Chosen\n");
								pduLog(logfile,"\t\t*** Node is Added ***\n");
				pduLog(logfile,
				       "\t\tsuperior_node_id [%u]\n",
				       node_record_list.u.node_record_update->value.node_update.u.node_add_record.superior_node); 
							
				switch( node_record_list.u.node_record_update->value.node_update.u.node_add_record.node_type)
				{
				    case GCC_TERMINAL:
										pduLog( logfile, "\t\tnode_type = GCC_TERMINAL\n");
										break;
				    case GCC_MULTIPORT_TERMINAL:
										pduLog(logfile,"\t\tnode_type = GCC_MULTIPORT_TERMINAL\n");
										break;
				    case GCC_MCU:
										pduLog(logfile, "\t\tnode_type = GCC_MCU\n");
										break;
									default:
										pduLog(logfile,"\t\tGCCNODE: ERROR: UNKNOWN NODE TYPE\n");
										break;
								}
				
								pduLog(logfile,"\t\tdevice_is_manager: [%u]\n",
									       node_record_list.u.node_record_update->value.node_update.u.node_add_record.node_properties.device_is_manager); 
		     
				pduLog(logfile,"\t\tdevice_is_peripheral: [%u] \n",
				    node_record_list.u.node_record_update->value.node_update.u.node_add_record.node_properties.device_is_peripheral);
			
				
								/* print the node_name */
								outdeb("Printing node name\n");
								
								if(CopyTextToChar(print_buffer, 
						node_record_list.u.node_record_update->value.node_update.u.node_add_record.node_name))
									pduLog( logfile, "\t\tnode_name is [%s]\n", print_buffer ); 
								else                                            
									pduLog( logfile, "\t\tnode_name is NULL\n");

					/* print the participants_list fields */
								outdeb("Printing participants list fields\n");
								if((node_record_list.u.node_record_update->value.node_update.u.node_add_record.participants_list != NULL)
									&& (node_record_list.u.node_record_update->value.node_update.u.node_add_record.bit_mask & 0x20))
								{
									outdeb("participants list is not NULL\n");
									for(i=0;node_record_list.u.node_record_update->value.node_update.u.node_add_record.participants_list->next!=NULL;i++)
									{
										outdeb("participants_list->next is not NULL\n");
										if(CopyTextToChar(print_buffer,
											node_record_list.u.node_record_update->value.node_update.u.node_add_record.participants_list->value))
											pduLog(logfile, "\t\tparticipant %u is: [%s]\n", print_buffer);
										else
											pduLog(logfile, "\t\tparticipant_list record is NULL\n");

										outdeb("incrementing participant list node\n");
										node_record_list.u.node_record_update->value.node_update.u.node_add_record.participants_list =
											node_record_list.u.node_record_update->value.node_update.u.node_add_record.participants_list->next;
									}
								}

								/* print the site information */
								outdeb("printing site information\n");
								if(node_record_list.u.node_record_update->value.node_update.u.node_add_record.bit_mask & 0x10)
								{
									if(CopyTextToChar(print_buffer,
											node_record_list.u.node_record_update->value.node_update.u.node_add_record.site_information))
										pduLog(logfile,"\t\tsite_information is [%s]\n",print_buffer ); 
									else
										 pduLog( logfile, "\t\tsite_information is NULL\n");
								}
				break;
				
			    case NODE_REPLACE_RECORD_CHOSEN:
								outdeb("Node Replace Record Chosen\n");

				pduLog(logfile,"\t\t*** Node is Replaced ***\n");
				pduLog(logfile,
				       "\t\tsuperior_node_id [%u]\n",
				       node_record_list.u.node_record_update->value.node_update.u.node_replace_record.superior_node); 
							
				switch( node_record_list.u.node_record_update->value.node_update.u.node_replace_record.node_type)
				{
				    case GCC_TERMINAL:
										pduLog( logfile, "\t\tnode_type = GCC_TERMINAL\n");
										break;
				    case GCC_MULTIPORT_TERMINAL:
										pduLog(logfile,"\t\tnode_type = GCC_MULTIPORT_TERMINAL\n");
										break;
				    case GCC_MCU:
										pduLog(logfile, "\t\tnode_type = GCC_MCU\n");
										break;
									default:
									pduLog(logfile,"\t\tGCCNODE: ERROR: UNKNOWN NODE TYPE\n");
										break;
								}
				
								pduLog(logfile,"\t\tdevice_is_manager: [%u]\n",
									      node_record_list.u.node_record_update->value.node_update.u.node_replace_record.node_properties.device_is_manager); 
		     
				pduLog(logfile,"\t\tdevice_is_peripheral: [%u] \n",
				    node_record_list.u.node_record_update->value.node_update.u.node_replace_record.node_properties.device_is_peripheral);
			
				/* print the node name */
								outdeb("printing node name\n");
								if(CopyTextToChar(print_buffer, 
						  node_record_list.u.node_record_update->value.node_update.u.node_replace_record.node_name))
									pduLog( logfile, "\t\tnode_name is [%s]\n", print_buffer ); 
								else                                            
									pduLog( logfile, "\t\tnode_name is NULL\n");
								print_buffer[0] = 0;

								/* print the participant list */
								outdeb("printing participants list info\n");

								if((node_record_list.u.node_record_update->value.node_update.u.node_replace_record.participants_list != NULL)
									&& (node_record_list.u.node_record_update->value.node_update.u.node_replace_record.bit_mask & 0x20))
								{
									for(i=0;node_record_list.u.node_record_update->value.node_update.u.node_replace_record.participants_list->next!=NULL;i++)
									{
										if(CopyTextToChar(print_buffer,
											node_record_list.u.node_record_update->value.node_update.u.node_replace_record.participants_list->value))
											pduLog(logfile, "\t\tparticipant %u is: [%s]\n", print_buffer);
										else
											pduLog(logfile, "\t\tparticipant_list record is NULL\n");       
										
										node_record_list.u.node_record_update->value.node_update.u.node_replace_record.participants_list =
											node_record_list.u.node_record_update->value.node_update.u.node_replace_record.participants_list->next;
									}
								}

								print_buffer[0] = 0;
				/* print the site information */
								outdeb("printing site information\n");
								if(node_record_list.u.node_record_update->value.node_update.u.node_replace_record.bit_mask & 0x10)
								{
									if( CopyTextToChar(print_buffer,
											node_record_list.u.node_record_update->value.node_update.u.node_replace_record.site_information))
										pduLog(logfile,"\t\tsite_information is [%s]\n",print_buffer ); 
									else
										pduLog( logfile, "\t\tsite_information is NULL\n");
								}
								break;
			    
							case NODE_REMOVE_RECORD_CHOSEN:
				outdeb("Node remove record chosen\n");
								pduLog(logfile,"\t\t*** UPDATE: Node is REMOVED ***\n");
				break;
			    
							default:
				pduLog(logfile,"\t\t>>>>ERROR: UNKNOWN UPDATE ACTION\n");
				break;

			}
			node_record_list.u.node_record_update =
			    node_record_list.u.node_record_update->next;
		    }
		}
		break;
	    default:
		pduLog(logfile,">>>> Unknown Roster Update Type\n");
		break;
	}
    
}


/****************************************************************/
void PrintApplicationRoster(FILE *logfile, SetOfApplicationInformation *application_information)
{
	int i = 0;

	pduLog(logfile,"Application Information: \n");

	for(i=0; application_information != NULL; i++)
	{
		pduLog(logfile,"\t*** application information record [%u] ***\n",i);
		PrintSessionKey(logfile,application_information->value.session_key);
		PrintApplicationRecordList(logfile,application_information->value.application_record_list);
		PrintApplicationCapabilitiesList(logfile,application_information->value.application_capabilities_list);
		pduLog(logfile,"\t\troster_instance_number = %u\n",application_information->value.roster_instance_number);
		PrintT120Boolean(logfile,"\t\tpeer_entities_are_added",application_information->value.peer_entities_are_added);
		PrintT120Boolean(logfile,"\t\tpeer_entities_are_removed",application_information->value.peer_entities_are_removed);
	
		application_information = application_information->next;
	}

}


/****************************************************************/
void PrintT120Boolean(FILE *    logfile,
						Char *  print_text,
						T120Boolean     T120Boolean)
{
	if( T120Boolean == FALSE )
		pduLog( logfile, "%s = FALSE\n", print_text );
	else
		pduLog( logfile, "%s = TRUE\n", print_text );
}



#endif /// PDULOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\gcclog.h ===
/**********************************************************************
 * File:     gcclog.h
 * Abstract: Function heders for protocol logging functions added
 * into GCCNC.DLL to read the contents of GCC  PDU sent to and 
 * received from 
 * Created:  12/21/95, Venkatesh Gopalakrishnan
 * Copyright (c) 1995 Microsoft Corpration
 ******************************************************************** */


 /* Note: the contents of this file are only included IFF PDULOG
  * is a defined constant.  PDULOG is defined in the DIAGNOSTIC
  * build configuration of GCCNC.DLL
  */

#ifdef PDULOG

#ifndef _PROTLOG_H
#define _PROTLOG_H

#include <windows.h>
#include <time.h>
#include <stdio.h>
 


#define MAXIMUM_PRINT_LENGTH 256
#define LOG_FILE_NAME "gcclog.txt"
#define SENT 0
#define RECEIVED 1
#define FORWARDED 2

/* mcs transport type definitions for gcc pdus */
#define MCS_SEND_DATA_REQUEST_PDU 1
#define MCS_SEND_DATA_INDICATION_PDU 2
#define MCS_UNIFORM_SEND_DATA_REQUEST_PDU 3
#define MCS_UNIFORM_SEND_DATA_INDICATION_PDU 4
#define MCS_CONNECT_PROVIDER_REQUEST_PDU 5
#define MCS_CONNECT_PROVIDER_RESPONSE_PDU 6
#define MCS_CONNECT_PROVIDER_CONFIRM_PDU 7
#define MCS_CONNECT_PROVIDER_INDICATION_PDU 8
 

/* miscellaneous constants used in databeam code */
#define MAX_CONFERENCE_NAME_LENGTH                      128
#define MAX_CONFERENCE_MODIFIER_LENGTH          128
#define MAX_CONFERENCE_DESCRIPTOR_LENGTH        128
#define MAX_NUMBER_OF_NETWORK_ADDRESSES         128
#define MAX_PASSWORD_LENGTH                                     128
#define MAX_ADDRESS_SIZE                                        128
#define MAX_CALLER_IDENTIFIER_LENGTH            128
#define MAX_TRANSPORT_ADDRESS_LENGTH            40
#define MAX_NUMBER_OF_TRANSPORTS_LISTED         20
#define MAX_OCTET_STRING_LENGTH                         128
#define MAX_HEX_STRING_LENGTH                           128
#define MAX_NUMBER_OF_USER_DATA_MEMBERS         65535
#define MAX_NUMBER_OF_TRANSPORT_HANDLES         128
#define MAX_NODE_NAME_LENGTH                            128
#define MAX_NUMBER_OF_PARTICIPANTS                      128
#define MAX_PARTICPANT_NAME_LENGTH                      128
#define MAX_ERROR_STRING_LENGTH                         40
#define MAX_REASON_STRING_LENGTH                        40
#define MAX_RESULT_STRING_LENGTH                        40
#define MAX_NUMBER_OF_CONF_IDS                          15
#define MAX_NUMBER_OF_NODE_IDS                          10
#define MAX_SUB_ADDRESS_STRING_LENGTH           128
#define MAX_NUMBER_OF_ACTIVE_CONFERENCES        100
#define MAX_NUMBER_OF_PENDING_CREATES           15
#define GCCAPP_SAP_NOT_REGISTERED                       0
#define GCCAPP_NOT_ENROLLED                                     1
#define GCCAPP_WAITING_ON_ATTACH_CONFIRM        2
#define GCCAPP_ATTACHED                                         3
#define GCCAPP_JOINED_CHANNEL_ID                        4
#define GCCAPP_ENROLLED_INACTIVELY                      5
#define GCCAPP_LISTED_IN_ROSTER_INACTIVE        6
#define GCCAPP_WAITING_ON_JOIN_CONFIRM          7
#define GCCAPP_JOINED_INITIAL_CHANNEL           8
#define GCCAPP_JOINED_REQUIRED_CHANNELS         9
#define GCCAPP_ASSIGNED_REQUIRED_TOKENS         10
#define GCCAPP_ENROLLED_ACTIVELY                        11
#define GCCAPP_LISTED_IN_ROSTER_ACTIVE          12
#define ENROLL_MODE_START_MULTICAST                     0
#define ENROLL_MODE_JOIN_MULTICAST                      1
#define JOIN_DO_NOT_MOVE                                        0
#define JOIN_INTERMIDIATE_MOVE                          1
#define JOIN_TOP_MOVE                                           2
#define JOIN_INTERMIDIATE_AND_TOP_MOVE          3



/**
 ** Service functions for the PDU logging mechanism
 **/

 int InitializeGCCLog();
 /* Description:
  *         Function that resets the gcc protocol log file and reads any
  *         ini file parameters
  */
  

 char *pszTimeStamp(); 
 /* Desicription:
  *         This function is an easy interfact to getting the time the
  *         PDU was encoded or decoded from GCC to MCS or vice versa.
  */
  
 void pduLog(FILE *file, char * format_string,...);
 /* Description:
  *         This function is used to place PDU information in a protocol
  *         log file.  There is currently no return value.  This may change.
  */       

 void pduFragmentation(FILE *logfile, unsigned int i);
 /* Description:
  *         This function logs weather or not the PDU is complete
  *         or fragmented.
  */

 void pduRawOutput(FILE *logfile, unsigned char * data, unsigned long length);
 /* Description:
  *         This function logs a hex dump of the raw encoded GCC PDU that
  *         is sent over the wire via MCS.
  */
  
 void gccLog(PPacket packet, PGCCPDU gcc_pdu, unsigned int direction, int mcs_pdu = 0);
 /* Description:
  *         This function takes care of the log headers and footers to 
  *         attempt at compatibility with a certain third party gcc log
  *         reader.
  */
 void gccConnectLog(PPacket packet, PConnectGCCPDU connect_pdu, unsigned int direction, int mcs_pdu = 0);
 
 void pduDirection(FILE *logfile,unsigned int direction);
 /* Description:
  *         This function logs information whether the gcc pdu was sent
  *         or received.
  */

 void mcsPduType(FILE *logfile, int mcs_pdu);
 /* Description:
  *     This function prints out the type of MCS pdu that is being used to
  *     transport the GCC PDU.
  */

  void pduLogGCCInformation(FILE *file, PGCCPDU gcc_pdu);
 /* Description:
  *         This function takes the gcc pdu structure, and based on
  *         Which type of GCC PDU that it is, logs internal information
  *         in the PDU.
  */
 void pduLogGCCConnectInfo(FILE *file, PConnectGCCPDU connect_pdu);
 /* same as above, but for GCC Connect PDUs */ 

 
/** 
 ** Functions for logging the specific contents of individual GCC
 ** PDUs.  TODO:  Only GCC PDUs that are used by MS Conferencing 
 ** right now -- eventually we'll include all GCC PDUs.
 **/
 
 void pduLogUserIDIndication(FILE *file, PGCCPDU gcc_pdu);
 /* Description:
  *         This function takes the gcc_pdu and writes the component parts
  *         of the gcc userID indication.
  */
 void pduLogConnectJoinRequest(FILE *logfile, PConnectGCCPDU connect_pdu);
 void pduLogConnectJoinResponse(FILE *logfile, PConnectGCCPDU connect_pdu);
 void pduLogConferenceCreateRequest(FILE *logfile, PConnectGCCPDU connect_pdu);
 void pduLogConferenceCreateResponse(FILE *logfile, PConnectGCCPDU connect_pdu);
 void pduLogConferenceInviteRequest(FILE *logfile, PConnectGCCPDU connect_pdu);
 void pduLogConferenceInviteResponse(FILE *logfile, PConnectGCCPDU connect_pdu);
 void pduLogQueryResponse(FILE *logfile, PConnectGCCPDU connect_pdu);

 void pduLogRosterUpdateIndication(FILE *file, PGCCPDU gcc_pdu);
 void pduLogTextMessageIndication(FILE *file, PGCCPDU gcc_pdu);
 void pduLogConferenceTerminateIndication(FILE *logfile, PGCCPDU gcc_pdu);
 void pduLogConferenceEjectUserIndication(FILE *logfile, PGCCPDU gcc_pdu);
 void pduLogConferenceTransferIndication(FILE *logfile, PGCCPDU gcc_pdu);
 void pduLogApplicationInvokeIndication(FILE *logfile, PGCCPDU gcc_pdu);
 void pduLogRegistryMonitorEntryIndication(FILE *logfile, PGCCPDU gcc_pdu);
 void pduLogConferenceTimeRemainingIndication(FILE *logfile, PGCCPDU gcc_pdu);
 void pduLogConferenceTimeInquireIndication(FILE *logfile, PGCCPDU gcc_pdu);
 void pduLogConferenceTimeExtendIndication(FILE *logfile, PGCCPDU gcc_pdu);

 

/******************************
 PDU Printing Functions
 *****************************/
 
 Void           PrintNonStandardParameter(FILE * logfile,
									  GCCNonStandardParameter FAR * non_standard_parameter);

 Void           PrintDomainParameters(FILE * logfile,
								  Char * print_text,
								  DomainParameters FAR * domain_parameters);
 
 Void           PrintPassword(FILE *    logfile,
						  GCCPassword FAR *     password);
 
 //TODO: Change the parameter order here.
 Void           PrintPrivilegeList(GCCConferencePrivileges      FAR *   privilege_list,
							   Char FAR * print_text,
							   FILE * logfile );
 
 Void           PrintConferenceName(FILE *      logfile,
								ConferenceNameSelector conference_name);

 Void           PrintPasswordSelector(FILE *logfile,
								PasswordSelector password_selector);

 Void           PrintConferenceAddResult(FILE *logfile,
								ConferenceAddResult result);

 Void           PrintPasswordChallengeRequestResponse(FILE *logfile,
												  PasswordChallengeRequestResponse chrqrs_password);

 Void           PrintNetworkAddressList(FILE * logfile,
									Char * print_text,
									unsigned int number_of_network_addresses,
									GCCNetworkAddress ** network_address_list );
					 
 Void           PrintT120Boolean(FILE * logfile, 
			     Char *     print_text,
							 T120Boolean T120Boolean);

 Void           PrintOssBoolean(FILE * logfile,
							Char  * print_text,
							ossBoolean OssBoolean);
	
 Void           PrintConferenceRoster(FILE * logfile,
								  NodeInformation node_information);
 
 Void           PrintApplicationRoster(FILE *logfile,
								  SetOfApplicationInformation *application_information);

 Void           PrintAppProtocolEntityList(FILE * logfile,
									   UShort number_of_app_protocol_entities,
									   GCCAppProtocolEntity FAR *
									   FAR * app_protocol_entity_list );
 
 Void           PrintOctetString(FILE * logfile,
							 Char * print_text,
					 GCCOctetString FAR * octet_string );
 
 Void           PrintHexString( FILE *           logfile,
							Char *           print_text,
							GCCHexString hex_string );
 
 Void           PrintSessionKey(FILE *                  logfile,
							Char *                  print_text,
							GCCSessionKey   session_key );
 
 
 Void           PrintNodeList(  FILE *                  logfile,
							Char *                  print_text,
							UShort                  number_of_nodes,
							UserID FAR *    node_list );
 
 Void           PrintCapabilityList(FILE *              logfile,
								Char *          print_text,
								UShort          number_of_capabilities,
								GCCApplicationCapability        FAR *
				FAR *   capabilities_list );
 
 Void           PrintPasswordChallenge(FILE *           logfile,
								   GCCChallengeRequestResponse  
								   FAR *        password_challenge );
 
 Void           PrintTransferModes(FILE *       logfile,
							   Char *       print_text,
							   GCCTransferModes     transfer_modes );
 
 Void           PrintHigherLayerCompatibility(FILE *    logfile,
										  Char * print_text,
										  GCCHighLayerCompatibility 
										  FAR * higher_layer_compatiblity );
	
 Void           PrintApplicationRecordList(     FILE *          logfile,
											Char *          print_text,
											UShort          number_of_records,
											GCCApplicationRecord FAR * 
											FAR *   application_record_list );


 T120Boolean CopyTextToChar ( Char * print_string,
			      TextString text_string);

 T120Boolean CopySimpleTextToChar (Char * print_string,
				   SimpleTextString text_string);

 T120Boolean CompareTextToNULL( LPWSTR unicode_string );

 T120Boolean CompareNumericToNULL( GCCNumericString numeric_string );


 #endif  // <<<<<<<<<<<< _PROTLOG_H
 #endif  // <<<<<<<<<<<< PDULOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\gcontrol.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	gcontrol.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This module manages the creation and deletion of various objects
 *		within GCC.  This includes the Control SAP, the Application SAPs, the
 *		Conference objectis indexed by the Conference ID.  Primitives are
 *		routed to the as and the MCS interface.  Conferences are maintained
 *		in a list that ppropriate conference object based on the Conference ID.
 *		The controller module is also responsible for routing Connect Provider 
 *		indications to the appropriate destination.
 *
 *		SEE THE INTERFACE FILE FOR A MORE DETAILED EXPLANATION OF THIS CLASS
 *
 *	Portable:
 *		Not Completely
 *
 *	Protected Instance Variables:
 *		None.
 *
 *	Private Instance Variables:
 *		g_pMCSIntf  				-	Pointer to the MCS Interface object.
 *										All request to MCS and all callbacks
 *										received from MCS travel through this
 *										interface.
 *		m_ConfList2 				-	This list maintains the active 
 *										conference objects.
 *		m_ConfPollList      		-	The conference poll list is used when
 *										polling the conference objects.  A
 *										seperate poll list is needed from the
 *										conference list to avoid any changes
 *										to the rogue wave list while it is
 *										being iterated on.
 *		m_AppSapList           		-	This list maintains all the registered
 *										application SAP objects.
 *		m_PendingCreateConfList2	-	This list is used to maintain
 *										conference information for pending
 *										conference objects that have not
 *										yet been created (i.e. CreateRequest
 *										has been received but not the Create
 *										Response).
 *		m_PendingJoinConfList2		-	This list is used to maintain  the
 *										join information for pending
 *										conference joins that have not
 *										yet been accepted (i.e. JoinRequest
 *										has been received but not the Join
 *										Response).
 *		m_ConfDeleteList    		-	This list contains any conference 
 *										objects that have been marked for
 *										deletion.  Once a conference object is
 *										put into this list on the next call to
 *										PollCommDevices it will be deleted.
 *		m_fConfListChangePending    	This flag is used to inform when the
 *										m_ConfList2 changes.  This includes
 *										when items are added as well as deleted.
 *		m_ConfIDCounter     		-	This instance variable is used to
 *										generate Conference IDs.
 *		m_QueryIDCounter			-	This instance variable is used to 
 *										generate the DomainSelector used in the
 *										query request.
 *		m_PendingQueryConfList2 	-	This list contains the query id (used
 *										for the domain selector in the query
 *										request).  This query id needs to be
 *										kept around so that the domain selector
 *										can be deleted when the query response
 *										comes back in (or if the controller is
 *										deleted before the confirm comes back).
 *
 *
 *	WIN32 related instance variables:
 *
 *		g_hevGCCOutgoingPDU			-	This is a Windows handle to an event
 *										object that signals a GCC PDU being 
 *										queued and ready to send on to MCS.
 *
 *	WIN16 related instance variables:
 *
 *		Timer_Procedure				-	This is the Process Instance of the
 *										timer procedure used in the Win16
 *										environment to get an internal 
 *										heartbeat.
 *		Timer_ID					-	This is the timer id of the timer that
 *										may be allocated in the Win16 
 *										constructor.
 *
 *	Caveats:		
 *		None.
 *
 *	Author:
 *		blp
 */
#include <stdio.h>

#include "gcontrol.h"
#include "ogcccode.h"
#include "translat.h"
#include "appldr.h"

/*
**	These ID ranges are used for conferences and queries.  Note that 
**	conference ID's and query ID's can never conflict.  These ID's are
**	used to create the MCS domains.
*/  
#define	MINIMUM_CONFERENCE_ID_VALUE		0x00000001L
#define	MAXIMUM_CONFERENCE_ID_VALUE		0x10000000L
#define	MINIMUM_QUERY_ID_VALUE			0x10000001L
#define	MAXIMUM_QUERY_ID_VALUE			0xffffffffL

/* ------ local data strctures ------ */

/*
**	The join information structure is used to temporarily store
**	information needed to join a conference after the join response is
**	issued.
*/
PENDING_JOIN_CONF::PENDING_JOIN_CONF(void)
:
	convener_password(NULL),
	password_challenge(NULL),
	pwszCallerID(NULL)
{
}

PENDING_JOIN_CONF::~PENDING_JOIN_CONF(void)
{
	if (NULL != convener_password)
	{
	    convener_password->Release();
	}
	if (NULL != password_challenge)
	{
	    password_challenge->Release();
	}
	delete pwszCallerID;
}


/*
**	The conference information structure is used to temporarily store
**	information needed to create a conference while waiting for a
**	conference create response.
*/
PENDING_CREATE_CONF::PENDING_CREATE_CONF(void)
:
	pszConfNumericName(NULL),
	pwszConfTextName(NULL),
	conduct_privilege_list(NULL),
	conduct_mode_privilege_list(NULL),
	non_conduct_privilege_list(NULL),
	pwszConfDescription(NULL)
{
}

PENDING_CREATE_CONF::~PENDING_CREATE_CONF(void)
{
	delete pszConfNumericName;
	delete pwszConfTextName;
	delete conduct_privilege_list;
	delete conduct_mode_privilege_list;
	delete non_conduct_privilege_list;
	delete pwszConfDescription;
}



// The DLL's HINSTANCE.
extern HINSTANCE            g_hDllInst;

MCSDLLInterface             *g_pMCSIntf;
CRITICAL_SECTION            g_csGCCProvider;

DWORD                       g_dwNCThreadID;
HANDLE                      g_hevGCCOutgoingPDU;


/*
 *	This is a global variable that has a pointer to the one GCC coder that
 *	is instantiated by the GCC Controller.  Most objects know in advance 
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
extern CGCCCoder	*g_GCCCoder;

/*
 *	GCCController::GCCController ()
 *
 *	Public Function Description
 *		This is the Win32 controller constructor. It is responsible for
 *		creating the application interface and the mcs interface.
 *		It also creates up the memory manager, the packet coder etc.
 */
GCCController::GCCController(PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('C','t','r','l')),
    m_ConfIDCounter(MAXIMUM_CONFERENCE_ID_VALUE),
	m_QueryIDCounter(MAXIMUM_QUERY_ID_VALUE),
	m_fConfListChangePending(FALSE),
    m_PendingQueryConfList2(CLIST_DEFAULT_MAX_ITEMS),
    m_PendingCreateConfList2(CLIST_DEFAULT_MAX_ITEMS),
    m_PendingJoinConfList2(CLIST_DEFAULT_MAX_ITEMS),
    m_AppSapList(DESIRED_MAX_APP_SAP_ITEMS),
    m_ConfList2(DESIRED_MAX_CONFS),
    m_ConfPollList(DESIRED_MAX_CONFS)
{
    GCCError        rc = GCC_ALLOCATION_FAILURE;
	MCSError		mcs_rc;
    //WNDCLASS        wc;

	DebugEntry(GCCController::GCCController);

    g_dwNCThreadID = ::GetCurrentThreadId();

    g_pMCSIntf = NULL;
    g_GCCCoder = NULL;
    g_hevGCCOutgoingPDU = NULL;

	/*
	 *	The allocation of the critical section succeeded, but we must
	 *	initialize it before we can use it.
	 */
    ::InitializeCriticalSection(&g_csGCCProvider);

	DBG_SAVE_FILE_LINE
	g_GCCCoder = new CGCCCoder ();
	if (g_GCCCoder == NULL)
	{
		/*
		 *	If the packet coder could not be created then report the error.
		 *	This IS a fatal error, so the faulty controller should be
		 *	destroyed and never used.
		 */
		ERROR_OUT(("GCCController::GCCController: failure creating packet coder"));
		// rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
	}

	/*
	 *	We must allocate an event object that will used to notify the
	 *	controller when messages are ready to be processed within the shared
	 *	memory application interface.
	 */
    g_hevGCCOutgoingPDU = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	if (g_hevGCCOutgoingPDU == NULL)
	{
		/*
		 *	Were unable to allocate an event object for this task, so we
		 *	must fail the creation of this controller.
		 */
		ERROR_OUT(("GCCController::GCCController: failure allocating mcs pdu event object"));
		// rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
	}

	DBG_SAVE_FILE_LINE
	g_pMCSIntf = new MCSDLLInterface(&mcs_rc);
	if ((NULL == g_pMCSIntf) || (mcs_rc != MCS_NO_ERROR))
	{
	    if (NULL != g_pMCSIntf)
	    {
    		ERROR_OUT(("GCCController: Error creating MCS Interface, mcs_rc=%u", (UINT) mcs_rc));
	    	rc = g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_rc);
	    }
	    else
	    {
    		ERROR_OUT(("GCCController: can't create MCSDLLInterface"));
	        // rc = GCC_ALLOCATION_FAILURE;
	    }
        goto MyExit;
	}

    rc = GCC_NO_ERROR;

MyExit:

    *pRetCode = rc;
	DebugExitVOID(GCCController::GCCController);
}


/*
 *	GCCController::~GCCController ()
 *
 *	Public Function Description
 *		This is the controller destructor. It takes care of freeing up
 *		many of the objects this class creates.
 */
GCCController::~GCCController(void)
{
	GCCConfID   		query_id;
	PENDING_JOIN_CONF	*lpJoinInfo;
	//PConference			lpConf;
	//CAppSap             *lpAppSap;
	PENDING_CREATE_CONF	*lpConfInfo;
	ConnectionHandle    hConn;

	DebugEntry(GCCController::~GCCController);

	/*
	 *	We need to enter the critical section before attempting to clean out
	 *	all of this stuff (if there is a critical section).
	 */
    ::EnterCriticalSection(&g_csGCCProvider);

    //
    // No one should use this global pointer any more.
    //
    ASSERT(this == g_pGCCController);
    g_pGCCController = NULL;

	//	Free up any outstanding join info
	while (NULL != (lpJoinInfo = m_PendingJoinConfList2.Get(&hConn)))
	{
        FailConfJoinIndResponse(lpJoinInfo->nConfID, hConn);
		delete lpJoinInfo;
	}

	//	Clean up any outstanding query request
	while (GCC_INVALID_CID != (query_id = m_PendingQueryConfList2.Get()))
	{
		g_pMCSIntf->DeleteDomain(&query_id);
	}

	//	Delete any conferences that are left around
	m_ConfList2.DeleteList();

    //	Delete any application SAPs the are left around
	m_AppSapList.DeleteList();

	//	Delete any outstanding conference information
	while (NULL != (lpConfInfo = m_PendingCreateConfList2.Get()))
	{
		delete lpConfInfo;
	}

	/*
	**	If a conference list change is pending we must delete any outstanding
	**	conference. 
	*/
	if (m_fConfListChangePending)
	{
		//	Delete any outstanding conference objects
		m_ConfDeleteList.DeleteList();
		m_fConfListChangePending = FALSE;
	}

	/*
	 *	We can now leave the critical section.
	 */
    ::LeaveCriticalSection(&g_csGCCProvider);

	delete g_pMCSIntf;
	g_pMCSIntf = NULL;

    ::DeleteCriticalSection(&g_csGCCProvider);

    ::My_CloseHandle(g_hevGCCOutgoingPDU);

	delete g_GCCCoder;
	g_GCCCoder = NULL; // do we really need to set it to NULL?
}

void GCCController::RegisterAppSap(CAppSap *pAppSap)
{
	CConf *pConf;

	DebugEntry(GCCController::RegisterAppSap);

	//	Update the application SAP list with the new SAP.
	pAppSap->AddRef();
	m_AppSapList.Append(pAppSap);

    /*
	**	Here we are registering the SAP with the conference.  A permit
	**	to enroll indication is also sent here for all the available
	**	conferences.
	*/
	m_ConfList2.Reset();
	while (NULL != (pConf = m_ConfList2.Iterate()))
	{
		/*
		**	Only register and send the permit for conferences that are
		**	established.
		*/
		if (pConf->IsConfEstablished())
		{
			//	Register the application SAP with the conference.
			pConf->RegisterAppSap(pAppSap);
		}
	}

	DebugExitVOID(GCCController::RegisterAppSap);
}

void GCCController::UnRegisterAppSap(CAppSap *pAppSap)
{
	DebugEntry(GCCController::UnRegisterAppSap);

	if (m_AppSapList.Find(pAppSap))
	{
		CConf *pConf;

		m_ConfPollList.Reset();
		while (NULL != (pConf = m_ConfPollList.Iterate()))
		{
			//	This routine takes care of all the necessary unenrollments.
            pConf->UnRegisterAppSap(pAppSap);
		}

		/*
		**	Here we remove the application SAP object from the list of valid
		**	application SAPs and insert it into the list of Application SAPs
		**	to be deleted.  On the next call to PollCommDevices this 
		**	SAP object will be deleted.
		*/
		m_AppSapList.Remove(pAppSap);
		pAppSap->Release();
    }
    else
    {
    	ERROR_OUT(("GCCController::UnRegisterAppSap: bad app sap"));
    }
	
	DebugExitVOID(GCCController::UnRegisterAppSap);
}


//	Calls received from the Control SAP

/*
 *	GCCController::ConfCreateRequest()
 *
 *	Private Function Description
 *		This routine is called when the node controller request that
 *		a conference is created. The conference object is instantiated in
 *		this routine.
 *
 *	Formal Parameters:
 *		conf_create_request_info -	(i)	Information structure that holds
 *										all the info necessary to create
 *										a conference.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_BAD_NETWORK_ADDRESS			-	Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad network address type passed in.
 *		GCC_CONFERENCE_ALREADY_EXISTS	-	Conference specified already exists.
 *		GCC_INVALID_TRANSPORT			-	Cannot find specified transport.
 *		GCC_INVALID_ADDRESS_PREFIX		-	Bad transport address passed in.
 *		GCC_INVALID_TRANSPORT_ADDRESS	- 	Bad transport address
 *		GCC_INVALID_PASSWORD			-	Invalid password passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	- 	Failure creating MCS user attachment
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		In the Win32 world we pass in a shared memory manager to the 
 *		conference object to use for the message memory manager. This is
 *		not necessary in the Win16 world since shared memory is not used.
 */
GCCError GCCController::
ConfCreateRequest
(
    CONF_CREATE_REQUEST        *pCCR,
    GCCConfID                  *pnConfID
)
{
	GCCError			rc;
	PConference			new_conference;
	GCCConfID   		conference_id;
	CONF_SPEC_PARAMS	csp;

	DebugEntry(GCCController: ConfCreateRequest);

	/*
	**	We must first check all the existing conferences to make sure that this
	**	conference name is not already in use. We will use an empty conference
	**	modifier here for our comparision.  Note that this returns immediatly
	**	if a conference by the same name alreay exists. Conference names
	**	must be unique at a node.
	*/
	conference_id = GetConferenceIDFromName(
							pCCR->Core.conference_name,
							pCCR->Core.conference_modifier);

	if (conference_id != 0)
	{
		ERROR_OUT(("GCCController:ConfCreateRequest: Conference exists."));
		return (GCC_CONFERENCE_ALREADY_EXISTS);
	}

	/*
	**	Here we are allocating a conference ID.  In most cases this ID
	**	will be the same as the conference name.  Only if a conference
	**	name is passed in that already exists will the name and ID
	**	be different.  In this case, a modifier will be appended to the
	**	conference name to create the conference ID.
	*/
	conference_id = AllocateConferenceID();

	// set up conference specification parameters
	csp.fClearPassword = pCCR->Core.use_password_in_the_clear;
	csp.fConfLocked = pCCR->Core.conference_is_locked;
	csp.fConfListed = pCCR->Core.conference_is_listed;
	csp.fConfConductable = pCCR->Core.conference_is_conductible;
	csp.eTerminationMethod = pCCR->Core.termination_method;
	csp.pConductPrivilege = pCCR->Core.conduct_privilege_list;
	csp.pConductModePrivilege = pCCR->Core.conduct_mode_privilege_list;
	csp.pNonConductPrivilege = pCCR->Core.non_conduct_privilege_list;
	csp.pwszConfDescriptor = pCCR->Core.pwszConfDescriptor;

	DBG_SAVE_FILE_LINE
	new_conference= new CConf(pCCR->Core.conference_name,
								pCCR->Core.conference_modifier,
								conference_id,
								&csp,
								pCCR->Core.number_of_network_addresses,
								pCCR->Core.network_address_list,
								&rc);
	if ((new_conference != NULL) && (rc == GCC_NO_ERROR))
	{
		rc = new_conference->ConfCreateRequest
						(
						pCCR->Core.calling_address,
						pCCR->Core.called_address,
						pCCR->fSecure,
						pCCR->convener_password,
						pCCR->password,
						pCCR->Core.pwszCallerID,
						pCCR->Core.domain_parameters,
						pCCR->user_data_list,
						pCCR->Core.connection_handle
						);

		if (rc == GCC_NO_ERROR)
		{
			m_fConfListChangePending = TRUE;
			if (NULL != pnConfID)
			{
			    *pnConfID = conference_id;
			}
			m_ConfList2.Append(conference_id, new_conference);
			PostMsgToRebuildConfPollList();
		}
		else
        {
			new_conference->Release();
        }
	}
	else
	{
		ERROR_OUT(("GCCController:ConfCreateRequest: Error occured creating conference"));
		if (new_conference != NULL)
        {
			new_conference->Release();
        }
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}

	DebugExitINT(GCCController: ConfCreateRequest, rc);
	return rc;
}

/*
 *	GCCController::ConfCreateResponse ()
 *
 *	Private Function Description
 *		This routine is called when the node controller responds to
 *		a conference create indication. It is responsible for
 *		creating the conference object.
 *
 *	Formal Parameters:
 *		conf_create_response_info -	(i)	Information structure that holds
 *										all the info necessary to respond to
 *										a conference create request.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_CONFERENCE			-	An invalid conference was passed in.
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_CONFERENCE_ALREADY_EXISTS	-	Conference specified already exists.
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	-	Failure creating MCS user attachment
 *		
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		In the Win32 world we pass in a shared memory manager to the 
 *		conference object to use for the message memory manager. This is
 *		not necessary in the Win16 world since shared memory is not used.
 */
GCCError GCCController::
ConfCreateResponse ( PConfCreateResponseInfo conf_create_response_info )
{
	GCCConferenceName				conference_name;
	PENDING_CREATE_CONF				*conference_info;
	PConference						new_conference;
	GCCError						rc = GCC_NO_ERROR;
	GCCConfID   					conference_id;
	ConnectGCCPDU					connect_pdu;
	LPBYTE							encoded_pdu;
	UINT							encoded_pdu_length;
	MCSError						mcsif_error;
	LPWSTR							pwszConfDescription = NULL;
	PGCCConferencePrivileges		conduct_privilege_list_ptr = NULL;
	PGCCConferencePrivileges		conduct_mode_privilege_list_ptr = NULL;
	PGCCConferencePrivileges		non_conduct_privilege_list_ptr = NULL;
	CONF_SPEC_PARAMS				csp;

	DebugEntry(GCCController::ConfCreateResponse);

	//	Is the conference create info structure in the rogue wave list
	if (NULL != (conference_info = m_PendingCreateConfList2.Find(conf_create_response_info->conference_id)))
	{
	 	if (conf_create_response_info->result == GCC_RESULT_SUCCESSFUL)
	 	{
			//	First set up the conference name.
			conference_name.numeric_string = (GCCNumericString) conference_info->pszConfNumericName;

			conference_name.text_string = conference_info->pwszConfTextName;

			/*
			**	If the conference name is valid check all the existing 
			**	conferences to make sure that this conference name is not 
			*	already in use. 
			*/
			conference_id = GetConferenceIDFromName(	
							&conference_name,
							conf_create_response_info->conference_modifier);

			if (conference_id != 0)
			{
				WARNING_OUT(("GCCController:ConfCreateResponse: Conference exists"));
				rc = GCC_CONFERENCE_ALREADY_EXISTS;
			}
			else
			{
				/*
				**	Now set up the real conference ID from the conference id
				**	that was generated when the create request came in.
				*/
				conference_id = conf_create_response_info->conference_id;
			}

			/*
			**	If everything is OK up to here go ahead and process the
			**	create request.
			*/
			if (rc == GCC_NO_ERROR)
			{	
				//	Set up the privilege list pointers for the list that exists
				if (conference_info->conduct_privilege_list != NULL)
				{
					conference_info->conduct_privilege_list->
						GetPrivilegeListData(&conduct_privilege_list_ptr);
				}
			
				if (conference_info->conduct_mode_privilege_list != NULL)
				{
					conference_info->conduct_mode_privilege_list->
						GetPrivilegeListData(&conduct_mode_privilege_list_ptr);
				}

				if (conference_info->non_conduct_privilege_list != NULL)
				{
					conference_info->non_conduct_privilege_list->
						GetPrivilegeListData(&non_conduct_privilege_list_ptr);
				}

				//	Set up the conference description pointer if one exists
				pwszConfDescription = conference_info->pwszConfDescription;

				// set up conference specification parameters
				csp.fClearPassword = conf_create_response_info->use_password_in_the_clear,
				csp.fConfLocked = conference_info->conference_is_locked,
				csp.fConfListed = conference_info->conference_is_listed,
				csp.fConfConductable = conference_info->conference_is_conductible,
				csp.eTerminationMethod = conference_info->termination_method,
				csp.pConductPrivilege = conduct_privilege_list_ptr,
				csp.pConductModePrivilege = conduct_mode_privilege_list_ptr,
				csp.pNonConductPrivilege = non_conduct_privilege_list_ptr,
				csp.pwszConfDescriptor = pwszConfDescription,

				//	Here we instantiate the conference object
				DBG_SAVE_FILE_LINE
				new_conference = new CConf(&conference_name,
											conf_create_response_info->conference_modifier,
											conference_id,
											&csp,
											conf_create_response_info->number_of_network_addresses,
											conf_create_response_info->network_address_list,
											&rc);
				if ((new_conference != NULL) &&
					(rc == GCC_NO_ERROR))
				{
					//	Here we actually issue the create response.
					rc = new_conference->ConfCreateResponse(
								conference_info->connection_handle,
								conf_create_response_info->domain_parameters,
								conf_create_response_info->user_data_list);
					if (rc == GCC_NO_ERROR)
					{
						//	Add the new conference to the Conference List
						m_fConfListChangePending = TRUE;
						m_ConfList2.Append(conference_id, new_conference);
            			PostMsgToRebuildConfPollList();
					}
					else
                    {
						new_conference->Release();
                    }
				}
				else
				{
					if (new_conference != NULL)
                    {
						new_conference->Release();
                    }
					else
                    {
						rc = GCC_ALLOCATION_FAILURE;
                    }
				}
			}
		}
		else
		{
			/*
			**	This section of the code is sending back the failed result.
			**	Note that no conference object is instantiated when the
			**	result is something other than success.
			*/
			connect_pdu.choice = CONFERENCE_CREATE_RESPONSE_CHOSEN;
			connect_pdu.u.conference_create_response.bit_mask = 0;
			
			//	This must be set to satisfy ASN.1 restriction
			connect_pdu.u.conference_create_response.node_id = 1001;
			connect_pdu.u.conference_create_response.tag = 0;
			
			if (conf_create_response_info->user_data_list != NULL)
			{
				connect_pdu.u.conference_create_response.bit_mask = 
													CCRS_USER_DATA_PRESENT;
				
				conf_create_response_info->user_data_list->GetUserDataPDU(
					&connect_pdu.u.conference_create_response.ccrs_user_data);		
			}
		
			//	We always send a user rejected result here.
			connect_pdu.u.conference_create_response.result = 
					::TranslateGCCResultToCreateResult(
            			GCC_RESULT_USER_REJECTED);

			if (g_GCCCoder->Encode((LPVOID) &connect_pdu,
										CONNECT_GCC_PDU,
										PACKED_ENCODING_RULES,
										&encoded_pdu,
										&encoded_pdu_length))
			{
				mcsif_error = g_pMCSIntf->ConnectProviderResponse( 
										conference_info->connection_handle,
										NULL,
										NULL,
										RESULT_USER_REJECTED,
										encoded_pdu,
										encoded_pdu_length);
											
				rc = g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcsif_error);
				g_GCCCoder->FreeEncoded(encoded_pdu);
			}
			else
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}

		if (rc == GCC_NO_ERROR)
		{
			/*
			**	Remove the conference information structure from the rogue
			**	wave list.
			*/
			delete conference_info;

			m_PendingCreateConfList2.Remove(conf_create_response_info->conference_id);
		}
	}
	else
		rc = GCC_INVALID_CONFERENCE;

	DebugExitINT(GCCController::ConfCreateResponse, rc);
	return rc;
}

/*
 *	GCCController::ConfQueryRequest ()
 *
 *	Private Function Description
 *		This routine is called when the node controller makes a 
 *		conference query request.  This routine is responsible for
 *		creating the MCS domain used to send the request and is also
 *		responsible for issuing the ConnectProvider request.
 *
 *	Formal Parameters:
 *		conf_query_request_info -	(i)	Information structure that holds
 *										all the info necessary to issue
 *										a conference query request.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_ADDRESS_PREFIX		-	Bad transport address passed in.
 *		GCC_INVALID_TRANSPORT			-	Bad transport address passed in.
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *		GCC_INVALID_TRANSPORT_ADDRESS	- 	Bad transport address
 *		
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError GCCController::
ConfQueryRequest ( PConfQueryRequestInfo  conf_query_request_info )
{
	MCSError				mcs_error;
	GCCError				rc = GCC_NO_ERROR;
	ConnectGCCPDU			connect_pdu;
	LPBYTE					encoded_pdu;
	UINT					encoded_pdu_length;
	GCCConfID   			query_id;

	DebugEntry(GCCController::ConfQueryRequest);

	//	Get the query id used to create the query domain
	query_id = AllocateQueryID ();
	
	/*
	**	Create the MCS domain used by the query.  Return an error if the 
	**	domain already exists.
	*/
	mcs_error = g_pMCSIntf->CreateDomain(&query_id);
	if (mcs_error != MCS_NO_ERROR)
	{
		if (mcs_error == MCS_DOMAIN_ALREADY_EXISTS)
			return (GCC_QUERY_REQUEST_OUTSTANDING);
		else
			return (GCC_ALLOCATION_FAILURE);
	}
	

	//	Encode the Query Request PDU
	connect_pdu.choice = CONFERENCE_QUERY_REQUEST_CHOSEN;
	connect_pdu.u.conference_query_request.bit_mask = 0;

	//	Translate the node type
	connect_pdu.u.conference_query_request.node_type = 
								(NodeType)conf_query_request_info->node_type;

	//	Set up asymetry indicator if it exists
	if (conf_query_request_info->asymmetry_indicator != NULL)
	{
		connect_pdu.u.conference_query_request.bit_mask |=
											CQRQ_ASYMMETRY_INDICATOR_PRESENT;
											
		connect_pdu.u.conference_query_request.cqrq_asymmetry_indicator.choice =
			(USHORT)conf_query_request_info->
				asymmetry_indicator->asymmetry_type;
			
		connect_pdu.u.conference_query_request.
				cqrq_asymmetry_indicator.u.unknown =	
					conf_query_request_info->asymmetry_indicator->random_number;
	}
	
	//	Set up the user data if it exists
	if (conf_query_request_info->user_data_list != NULL)
	{
		rc = conf_query_request_info->user_data_list->
							GetUserDataPDU (
								&connect_pdu.u.conference_query_request.
									cqrq_user_data);
									
		if (rc == GCC_NO_ERROR)
		{
			connect_pdu.u.conference_query_request.bit_mask |=
														CQRQ_USER_DATA_PRESENT;
		}
	}

	if (g_GCCCoder->Encode((LPVOID) &connect_pdu,
								CONNECT_GCC_PDU,
								PACKED_ENCODING_RULES,
								&encoded_pdu,
								&encoded_pdu_length))
	{
		//	Here we create the logical connection used for the query.
		mcs_error = g_pMCSIntf->ConnectProviderRequest (
					&query_id,      // calling domain selector
					&query_id,      // called domain selector
					conf_query_request_info->calling_address,
					conf_query_request_info->called_address,
					conf_query_request_info->fSecure,
					TRUE,	//	Upward connection
					encoded_pdu,
					encoded_pdu_length,
					conf_query_request_info->connection_handle,
					NULL,	//	Domain Parameters
					NULL);

		g_GCCCoder->FreeEncoded(encoded_pdu);
		if (mcs_error == MCS_NO_ERROR)
		{
			/*
			**	Add the connection and domain name to the outstanding
			**	query request list.
			*/
			m_PendingQueryConfList2.Append(*conf_query_request_info->connection_handle, query_id);
			rc = GCC_NO_ERROR;
		}
		else
		{
			g_pMCSIntf->DeleteDomain(&query_id);
			/*
			**	DataBeam's current implementation of MCS returns
			**	MCS_INVALID_PARAMETER when something other than
			**	the transport prefix is wrong with the specified
			**	transport address.
			*/
			if (mcs_error == MCS_INVALID_PARAMETER)
				rc = GCC_INVALID_TRANSPORT_ADDRESS;		  
			else
			{
				rc = g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
			}
		}
	}
	else
	{
		rc = GCC_ALLOCATION_FAILURE;
	}

	DebugExitINT(GCCController::ConfQueryRequest, rc);
	return rc;
}

/*
 *	GCCController::ConfQueryResponse ()
 *
 *	Private Function Description
 *		This routine is called when the node controller makes a 
 *		conference query response.  This routine uses a conference
 *		descriptor list object to build the PDU associated with the
 *		query response.
 *
 *	Formal Parameters:
 *		conf_query_response_info -	(i)	Information structure that holds
 *										all the info necessary to issue
 *										a conference query response.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_BAD_NETWORK_ADDRESS			-	Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad network address type passed in.
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *		
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError GCCController::
ConfQueryResponse ( PConfQueryResponseInfo conf_query_response_info )
{
	GCCError					rc = GCC_NO_ERROR;
	ConnectGCCPDU				connect_pdu;
	LPBYTE						encoded_pdu;
	UINT						encoded_pdu_length;
	ConnectionHandle			connection_handle;
	MCSError					mcs_error;
	CConfDescriptorListContainer *conference_list = NULL;

	DebugEntry(GCCController::ConfQueryResponse);

	connection_handle = (ConnectionHandle)conf_query_response_info->
													query_response_tag;

	//	Encode the Query Response PDU
	connect_pdu.choice = CONFERENCE_QUERY_RESPONSE_CHOSEN;
	connect_pdu.u.conference_query_response.bit_mask = 0;
	
	connect_pdu.u.conference_query_response.node_type =  
								(NodeType)conf_query_response_info->node_type;

	//	Set up asymmetry indicator if it exists
	if (conf_query_response_info->asymmetry_indicator != NULL)
	{
		connect_pdu.u.conference_query_response.bit_mask |= 
											CQRS_ASYMMETRY_INDICATOR_PRESENT;
											
		connect_pdu.u.conference_query_response.
			cqrs_asymmetry_indicator.choice = 
				conf_query_response_info->asymmetry_indicator->asymmetry_type;	
	
		connect_pdu.u.conference_query_response.
			cqrs_asymmetry_indicator.u.unknown =
				conf_query_response_info->asymmetry_indicator->random_number;
	}
	
	//	Set up the user data if it exists
	if (conf_query_response_info->user_data_list != NULL)
	{
		rc = conf_query_response_info->user_data_list->
							GetUserDataPDU (
								&connect_pdu.u.conference_query_response.
									cqrs_user_data);
									
		if (rc == GCC_NO_ERROR)
		{
			connect_pdu.u.conference_query_response.bit_mask |=
														CQRS_USER_DATA_PRESENT;
		}
	}

	//	Translate the result
	connect_pdu.u.conference_query_response.result =  
						::TranslateGCCResultToQueryResult(
										conf_query_response_info->result);

	/*
	**	We only create a conference descriptor list if the returned result 
	**	is success.
	*/
	if (conf_query_response_info->result == GCC_RESULT_SUCCESSFUL)
	{
		//	Create a new conference descriptor list and check it for validity.
		DBG_SAVE_FILE_LINE
		conference_list = new CConfDescriptorListContainer();
		if (conference_list != NULL)
		{
			PConference			lpConf;

			//	Here we build the set of conference descriptor list					
			m_ConfList2.Reset();
			while (NULL != (lpConf = m_ConfList2.Iterate()))
			{
				//	Only show established conferences
				if (lpConf->IsConfEstablished())
				{
			        if (lpConf->IsConfListed())
					{
						conference_list->AddConferenceDescriptorToList (
								lpConf->GetNumericConfName(),
								lpConf->GetTextConfName(),
								lpConf->GetConfModifier(),
								lpConf->IsConfLocked(),
								lpConf->IsConfPasswordInTheClear(),
								lpConf->GetConfDescription(),
								lpConf->GetNetworkAddressList());
					}
				}
			}
				
			//	Get the pointer to the set of conference descriptors
			conference_list->GetConferenceDescriptorListPDU (
					&(connect_pdu.u.conference_query_response.conference_list));
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		//	No conference list is sent in this case
		connect_pdu.u.conference_query_response.conference_list = NULL;
	}
	
	if (rc == GCC_NO_ERROR)
	{
		if (g_GCCCoder->Encode((LPVOID) &connect_pdu,
									CONNECT_GCC_PDU,
									PACKED_ENCODING_RULES,
									&encoded_pdu,
									&encoded_pdu_length))
		{
			mcs_error = g_pMCSIntf->ConnectProviderResponse(
													connection_handle,
													NULL,
													NULL,
													RESULT_USER_REJECTED,
													encoded_pdu,
													encoded_pdu_length);
			g_GCCCoder->FreeEncoded(encoded_pdu);

			if (mcs_error == MCS_NO_ERROR)
				rc = GCC_NO_ERROR;
			else if (mcs_error == MCS_NO_SUCH_CONNECTION)
				rc = GCC_INVALID_QUERY_TAG;
			else
			{
				rc = g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
			}
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	//	Free up the conference list allocated above to create the PDU.	
    if (NULL != conference_list)
    {
        conference_list->Release();
    }
	

	DebugExitINT(GCCController::ConfQueryResponse, rc);
	return rc;
}



/*
 *	GCCController::ConfJoinRequest ()
 *
 *	Private Function Description
 *		This routine is called when the node controller makes a request
 *		to join an existing conference.	It is responsible for
 *		creating the conference object.
 *
 *	Formal Parameters:
 *		conf_join_request_info -	(i)	Information structure that holds
 *										all the info necessary to issue
 *										a conference join request.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_BAD_NETWORK_ADDRESS			-	Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad network address type passed in.
 *		GCC_CONFERENCE_ALREADY_EXISTS	-	Conference specified already exists.
 *		GCC_INVALID_ADDRESS_PREFIX		-	Bad transport address passed in.
 *		GCC_INVALID_TRANSPORT			-	Bad transport address passed in.
 *		GCC_INVALID_PASSWORD			-	Invalid password passed in.
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	-	Failure creating MCS user attachment
 *		
 *  Side Effects
 *		None
 *
 *	Caveats
 *		In the Win32 world we pass in a shared memory manager to the 
 *		conference object to use for the message memory manager. This is
 *		not necessary in the Win16 world since shared memory is not used.
 */
GCCError GCCController::
ConfJoinRequest
(
    PConfJoinRequestInfo        conf_join_request_info,
    GCCConfID                  *pnConfID
)
{
	PConference					new_conference;
	GCCError					rc;
	GCCConfID   				conference_id;

	DebugEntry(GCCController::ConfJoinRequest);

	/*
	**	We must first check all the existing conferences to make sure that this
	**	conference name is not already in use. Note that this returns immediatly
	**	if a conference by the same name alreay exists. Conference names
	**	must be unique at a node.
	*/
	conference_id = GetConferenceIDFromName(	
								conf_join_request_info->conference_name,
								conf_join_request_info->calling_node_modifier);

	if (conference_id != 0)
	{
		WARNING_OUT(("GCCController:ConfJoinRequest: Conference exists."));
		return (GCC_CONFERENCE_ALREADY_EXISTS);
	}

	/*
	**	Here we are allocating a conference ID.  In most cases this ID
	**	will be the same as the conference name.  Only if a conference
	**	name is passed in that already exists will the name and ID
	**	be different.  In this case, a modifier will be appended to the
	**	conference name to create the conference ID.
	*/
	conference_id = AllocateConferenceID ();

	DBG_SAVE_FILE_LINE
	new_conference = new CConf(conf_join_request_info->conference_name,
								conf_join_request_info->calling_node_modifier,
								conference_id,
								NULL,
								conf_join_request_info->number_of_network_addresses,
								conf_join_request_info->local_network_address_list,
								&rc);
	if ((new_conference != NULL) && (rc == GCC_NO_ERROR))
	{
		rc = new_conference->ConfJoinRequest(
							conf_join_request_info->called_node_modifier,
							conf_join_request_info->convener_password,
							conf_join_request_info->password_challenge,
							conf_join_request_info->pwszCallerID,
							conf_join_request_info->calling_address,
							conf_join_request_info->called_address,
							conf_join_request_info->fSecure,
							conf_join_request_info->domain_parameters,
							conf_join_request_info->user_data_list,
							conf_join_request_info->connection_handle);
		if (rc == GCC_NO_ERROR)
		{
			m_fConfListChangePending = TRUE;
			if (NULL != pnConfID)
			{
			    *pnConfID = conference_id;
			}
			m_ConfList2.Append(conference_id, new_conference);
			PostMsgToRebuildConfPollList();
		}
		else
        {
			new_conference->Release();
        }
	}
	else
	{
		if (new_conference != NULL)
        {
			new_conference->Release();
        }
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}

	DebugExitINT(GCCController::ConfJoinRequest, rc);
	return rc;
}



/*
 *	GCCController::ConfJoinIndResponse ()
 *
 *	Private Function Description
 *		This routine is called when the node controller responds
 *		to a join indication.  If the result is success, we check to make sure 
 *		that the conference	exist before proceeding.  If it is not success, we
 *		send back the rejected request. 
 *
 *	Formal Parameters:
 *		conf_join_response_info -	(i)	Information structure that holds
 *										all the info necessary to issue
 *										a conference join response.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_JOIN_RESPONSE_TAG	-	No match found for join response tag
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_CONFERENCE_ALREADY_EXISTS	-	Conference specified already exists.
 *		GCC_INVALID_PASSWORD			-	Invalid password passed in.
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *		GCC_INVALID_CONFERENCE			-	Invalid conference ID passed in.
 *		
 *  Side Effects
 *		None
 *
 *	Caveats
 *		If this node is not the Top Provider and the result is success, we
 *		go ahead and forward the request on up to the top provider.
 */
GCCError GCCController::
ConfJoinIndResponse ( PConfJoinResponseInfo conf_join_response_info )
{
	PConference					joined_conference;
	PENDING_JOIN_CONF			*join_info_ptr;
	BOOL    					convener_is_joining;
	GCCError                    rc = GCC_NO_ERROR;
    GCCResult                   gcc_result = GCC_RESULT_SUCCESSFUL;
    BOOL                        fForwardJoinReq = FALSE;

	DebugEntry(GCCController::ConfJoinIndResponse);

	if (NULL != (join_info_ptr = m_PendingJoinConfList2.Find(conf_join_response_info->connection_handle)))
	{
    	/*
    	**	If the result is success, we must first check all the existing 
    	**	conferences to make sure that this conference exist.
    	*/
    	if (conf_join_response_info->result == GCC_RESULT_SUCCESSFUL)
    	{
    		if (NULL != (joined_conference = m_ConfList2.Find(conf_join_response_info->conference_id)))
    		{
    			/*
    			**	If the node for this conference is not the top provider we
    			**	must forward the join request on up to the Top Provider.
    			*/
    			if (! joined_conference->IsConfTopProvider())
    			{
    				rc = joined_conference->ForwardConfJoinRequest(
    								join_info_ptr->convener_password,
    								join_info_ptr->password_challenge,
    								join_info_ptr->pwszCallerID,
    								conf_join_response_info->user_data_list,
    								join_info_ptr->numeric_name_present,
    								conf_join_response_info->connection_handle);
    				if (GCC_NO_ERROR == rc)
    				{
    				    fForwardJoinReq = TRUE;
    				}
    			}
    			else
    			{
    				/*
    				**	If a convener password exists we must inform the conference
    				**	object that this is a convener that is trying to rejoin
    				**	the conference.
    				*/
    				if (join_info_ptr->convener_password != NULL)
    					convener_is_joining = TRUE;
    				else
    					convener_is_joining = FALSE;

    				rc = joined_conference->ConfJoinIndResponse(
    									conf_join_response_info->connection_handle,
    									conf_join_response_info->password_challenge,
    									conf_join_response_info->user_data_list,
    									join_info_ptr->numeric_name_present,
    									convener_is_joining,
    									conf_join_response_info->result);
    			}
    			if (GCC_NO_ERROR != rc)
    			{
    			    gcc_result = GCC_RESULT_UNSPECIFIED_FAILURE;
    			}
    		}
    		else
    		{
    			rc = GCC_INVALID_CONFERENCE;
    		    gcc_result = GCC_RESULT_INVALID_CONFERENCE;
    		}
    	}
    	else
    	{
    	    gcc_result = conf_join_response_info->result;
    	}
	}
	else
	{
		rc = GCC_INVALID_JOIN_RESPONSE_TAG;
	    gcc_result = GCC_RESULT_INVALID_CONFERENCE;
	}

    if (GCC_RESULT_SUCCESSFUL != gcc_result)
	{
	    conf_join_response_info->result = gcc_result;
	    FailConfJoinIndResponse(conf_join_response_info);
	}
	
	/*
	**	Cleanup the join info list if the join was succesful or if the
	**	Domain Parameters were unacceptable.  The connection is automatically
	**	rejected by MCS if the domain parameters are found to be unacceptable.
	*/
//	if ((rc == GCC_NO_ERROR) ||
//		(rc == GCC_DOMAIN_PARAMETERS_UNACCEPTABLE))
    if (NULL != join_info_ptr && (! fForwardJoinReq))
	{
		RemoveConfJoinInfo(conf_join_response_info->connection_handle);
	}

	DebugExitINT(GCCController::ConfJoinIndResponse, rc);
	return rc;
}


GCCError GCCController::
FailConfJoinIndResponse
(
    GCCConfID           nConfID,
    ConnectionHandle    hConn
)
{
    ConfJoinResponseInfo    cjri;
    cjri.result = GCC_RESULT_RESOURCES_UNAVAILABLE;
    cjri.conference_id = nConfID;
    cjri.password_challenge = NULL;
    cjri.user_data_list = NULL;
    cjri.connection_handle = hConn;
    return FailConfJoinIndResponse(&cjri);
}


GCCError GCCController::
FailConfJoinIndResponse ( PConfJoinResponseInfo conf_join_response_info )
{
    GCCError        rc = GCC_NO_ERROR;
    ConnectGCCPDU   connect_pdu;
    LPBYTE          encoded_pdu;
    UINT            encoded_pdu_length;

    // Send back the failed response with the specified result
    DebugEntry(GCCController::FailConfJoinIndResponse);

    // Encode the Join Response PDU
    connect_pdu.choice = CONNECT_JOIN_RESPONSE_CHOSEN;
    connect_pdu.u.connect_join_response.bit_mask = 0;

    // Get the password challenge if one exists
    if (conf_join_response_info->password_challenge != NULL)
    {
        connect_pdu.u.connect_join_response.bit_mask |= CJRS_PASSWORD_PRESENT;
        rc = conf_join_response_info->password_challenge->GetPasswordChallengeResponsePDU(
                &connect_pdu.u.connect_join_response.cjrs_password);
    }

    // Get the user data
    if ((conf_join_response_info->user_data_list != NULL) && (rc == GCC_NO_ERROR))
    {
        connect_pdu.u.connect_join_response.bit_mask |= CJRS_USER_DATA_PRESENT;
        rc = conf_join_response_info->user_data_list->GetUserDataPDU(
                &connect_pdu.u.connect_join_response.cjrs_user_data);
    }

    if (rc == GCC_NO_ERROR)
    {
        connect_pdu.u.connect_join_response.top_node_id = 1001;
        connect_pdu.u.connect_join_response.tag = 0;
        connect_pdu.u.connect_join_response.conference_is_locked = 0;
        connect_pdu.u.connect_join_response.conference_is_listed = 0;
        connect_pdu.u.connect_join_response.conference_is_conductible = 0;
        connect_pdu.u.connect_join_response.termination_method = AUTOMATIC;
        connect_pdu.u.connect_join_response.clear_password_required = FALSE;

        connect_pdu.u.connect_join_response.result =
            ::TranslateGCCResultToJoinResult(conf_join_response_info->result);

        if (g_GCCCoder->Encode((LPVOID) &connect_pdu,
                                CONNECT_GCC_PDU,
                                PACKED_ENCODING_RULES,
                                &encoded_pdu,
                                &encoded_pdu_length))
        {
            g_pMCSIntf->ConnectProviderResponse(
                                conf_join_response_info->connection_handle,
                                NULL,
                                NULL,
                                RESULT_USER_REJECTED,
                                encoded_pdu,
                                encoded_pdu_length);
            g_GCCCoder->FreeEncoded(encoded_pdu);
        }
        else
        {
            ERROR_OUT(("GCCController:FailConfJoinIndResponse: can't encode"));
            rc = GCC_ALLOCATION_FAILURE;
        }
    }

    DebugExitINT(GCCController::FailConfJoinIndResponse, rc);
    return rc;
}


/*
 *	GCCController::ConfInviteResponse ()
 *
 *	Private Function Description
 *		This routine is called when the node controller responds to
 *		a conference invite indication. It is responsible for
 *		creating the conference object.
 *
 *	Formal Parameters:
 *		conf_invite_response_info -	(i)	Information structure that holds
 *										all the info necessary to issue
 *										a conference invite response.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_CONFERENCE_ALREADY_EXISTS	-	Conference specified already exists.
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *		GCC_INVALID_CONFERENCE			-	Invalid conference ID passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	-	Failure creating MCS user attachment
 *		
 *  Side Effects
 *		None
 *
 *	Caveats
 *		In the Win32 world we pass in a shared memory manager to the 
 *		conference object to use for the message memory manager. This is
 *		not necessary in the Win16 world since shared memory is not used.
 */
GCCError GCCController::
ConfInviteResponse ( PConfInviteResponseInfo conf_invite_response_info )
{
	GCCError						rc = GCC_NO_ERROR;
	PENDING_CREATE_CONF				*conference_info;
	PConference						new_conference;
	GCCConferenceName				conference_name;
	LPWSTR							pwszConfDescription = NULL;
	PGCCConferencePrivileges		conduct_privilege_list_ptr = NULL;
	PGCCConferencePrivileges		conduct_mode_privilege_list_ptr = NULL;
	PGCCConferencePrivileges		non_conduct_privilege_list_ptr = NULL;
	GCCConfID   					conference_id;
	ConnectGCCPDU					connect_pdu;
	LPBYTE							encoded_pdu;
	UINT							encoded_pdu_length;
	MCSError						mcsif_error;
	CONF_SPEC_PARAMS				csp;
    GCCResult                       gcc_result = GCC_RESULT_SUCCESSFUL;

	DebugEntry(GCCController::ConfInviteResponse);

	if (NULL != (conference_info = m_PendingCreateConfList2.Find(conf_invite_response_info->conference_id)))
	{
		//	Is the conference create handle in the rogue wave list
		if (conf_invite_response_info->result == GCC_RESULT_SUCCESSFUL)
		{
			/*
			**	We must first check all the existing conferences to make sure 
			**	that this conference name is not already in use. Note that this 
			**	returns immediatly if a conference by the same name alreay 
			**	exists. Conference names must be unique at a node.
			*/
			//	Set up the conference name
			conference_name.numeric_string = (GCCNumericString) conference_info->pszConfNumericName;

			conference_name.text_string = conference_info->pwszConfTextName;

			conference_id = GetConferenceIDFromName(
								&conference_name,
								conf_invite_response_info->conference_modifier);

			if (conference_id == 0)
			{
				//	Set up the privilege list pointers for the list that exists
				if (conference_info->conduct_privilege_list != NULL)
				{
					conference_info->conduct_privilege_list->
						GetPrivilegeListData(&conduct_privilege_list_ptr);
				}
			
				if (conference_info->conduct_mode_privilege_list != NULL)
				{
					conference_info->conduct_mode_privilege_list->
						GetPrivilegeListData(&conduct_mode_privilege_list_ptr);
				}
			
				if (conference_info->non_conduct_privilege_list != NULL)
				{
					conference_info->non_conduct_privilege_list->
						GetPrivilegeListData(&non_conduct_privilege_list_ptr);
				}

				//	Set up the conference description pointer if one exists
				pwszConfDescription = conference_info->pwszConfDescription;

				//	Now set up the real conference ID
				conference_id = conf_invite_response_info->conference_id;

				// set up conference specification parameters
				csp.fClearPassword = conference_info->password_in_the_clear,
				csp.fConfLocked = conference_info->conference_is_locked,
				csp.fConfListed = conference_info->conference_is_listed,
				csp.fConfConductable = conference_info->conference_is_conductible,
				csp.eTerminationMethod = conference_info->termination_method,
				csp.pConductPrivilege = conduct_privilege_list_ptr,
				csp.pConductModePrivilege = conduct_mode_privilege_list_ptr,
				csp.pNonConductPrivilege = non_conduct_privilege_list_ptr,
				csp.pwszConfDescriptor = pwszConfDescription,

				DBG_SAVE_FILE_LINE
				new_conference = new CConf(&conference_name,
											conf_invite_response_info->conference_modifier,
											conference_id,
											&csp,
											conf_invite_response_info->number_of_network_addresses,
											conf_invite_response_info->local_network_address_list,
											&rc);
				if ((new_conference != NULL) &&
					(rc == GCC_NO_ERROR))
				{
					rc = new_conference->ConfInviteResponse(
								conference_info->parent_node_id,
								conference_info->top_node_id,
								conference_info->tag_number,
								conference_info->connection_handle,
								conf_invite_response_info->fSecure,
								conf_invite_response_info->domain_parameters,
								conf_invite_response_info->user_data_list);
					if (rc == GCC_NO_ERROR)
					{
						//	Add the new conference to the Conference List
						m_fConfListChangePending = TRUE;
						m_ConfList2.Append(conference_id, new_conference);
            			PostMsgToRebuildConfPollList();
					}
					else
                    {
						new_conference->Release();
						gcc_result = GCC_RESULT_UNSPECIFIED_FAILURE;
                    }
				}
				else
				{
					if (new_conference != NULL)
                    {
						new_conference->Release();
                    }
					else
                    {
						rc = GCC_ALLOCATION_FAILURE;
                    }
					gcc_result = GCC_RESULT_RESOURCES_UNAVAILABLE;
				}
			}
			else
			{
				WARNING_OUT(("GCCController::ConfInviteResponse: Conference exists."));
				rc = GCC_CONFERENCE_ALREADY_EXISTS;
				gcc_result = GCC_RESULT_ENTRY_ALREADY_EXISTS;
			}
		}
		else
		{
			WARNING_OUT(("GCCController: ConfInviteResponse: User Rejected"));
            gcc_result = conf_invite_response_info->result;
        }

        // Let's send a user reject response if any error or reject
        if (GCC_RESULT_SUCCESSFUL != gcc_result)
        {
            GCCError    rc2;

			//	Encode the Invite Response PDU
			connect_pdu.choice = CONFERENCE_INVITE_RESPONSE_CHOSEN;
			connect_pdu.u.conference_invite_response.bit_mask = 0;

			if (conf_invite_response_info->user_data_list != NULL)
			{
				rc2 = conf_invite_response_info->
								user_data_list->GetUserDataPDU(
									&connect_pdu.u.
									conference_invite_response.cirs_user_data);
				if (rc2 == GCC_NO_ERROR)
				{
					connect_pdu.u.conference_invite_response.bit_mask |= 
													CIRS_USER_DATA_PRESENT;
				}
				else
				{
    			    ERROR_OUT(("GCCController::ConfInviteResponse: GetUserDataPDU failed"));
				}
			}

			// connect_pdu.u.conference_invite_response.result = ::TranslateGCCResultToInviteResult(gcc_result);
			connect_pdu.u.conference_invite_response.result = CIRS_USER_REJECTED;

			if (g_GCCCoder->Encode((LPVOID) &connect_pdu,
										CONNECT_GCC_PDU,
										PACKED_ENCODING_RULES,
										&encoded_pdu,
										&encoded_pdu_length))
			{
				mcsif_error = g_pMCSIntf->ConnectProviderResponse(
										conference_info->connection_handle,
										NULL,
										NULL,
										RESULT_USER_REJECTED,
										encoded_pdu,
										encoded_pdu_length);
							
				rc2 = g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcsif_error);
				g_GCCCoder->FreeEncoded(encoded_pdu);
			}
			else
			{
			    // nothing we can do right now.
			    ERROR_OUT(("GCCController::ConfInviteResponse: encode failed"));
				rc2 = GCC_ALLOCATION_FAILURE;
			}

            // Update the error code. If rc is no error, which means the result
            // was passed in by the caller, then we should use the rc2 for
            // the return value.
			if (GCC_NO_ERROR == rc)
			{
			    rc = rc2;
			}
		}

		/*
		**	Remove the conference information structure from the rogue
		**	wave list.  Also cleanup all the containers needed to store
		**	the conference information.
		*/
		delete conference_info;
		m_PendingCreateConfList2.Remove(conf_invite_response_info->conference_id);
	}
	else
	{
		rc = GCC_INVALID_CONFERENCE;
	}

	DebugExitINT(GCCController::ConfInviteResponse, rc);
	return rc;
}



//	Calls received through the owner callback from a conference.


/*
 *	GCCController::ProcessConfEstablished ()
 *
 *	Private Function Description
 *		This owner callback is called when the conference has stabalized
 *		after creation.  This routine takes care of registering all the
 *		available application saps with the conference which then kicks off the 
 *		sending of permission to enrolls to all the applications that have 
 *		registered a service access point.
 *
 *	Formal Parameters:
 *		conference_id			-	(i)	The conference ID of the conference
 *										object that is now established.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError GCCController::
ProcessConfEstablished ( GCCConfID nConfID )
{
	CConf  *pConf;

	DebugEntry(GCCController:ProcessConfEstablished);

	/*
	**	Here we make a copy of the SAP list to use in case some kind of
	**	resource error occurs when calling RegisterAppSap that
	**	would cause a SAP to be deleted from the list.
	*/
	CAppSapList AppSapList(m_AppSapList);

	/*
	**	Here we register all the available SAPs with the newly available 
	**	conference and then we send a permit to enroll indication on to all the 
	**	application SAPs.
	*/
	if (NULL != (pConf = m_ConfList2.Find(nConfID)))
	{
		CAppSap *pAppSap;
		AppSapList.Reset();
		while (NULL != (pAppSap = AppSapList.Iterate()))
		{
			//	Register the Application SAP with the conference
			pConf->RegisterAppSap(pAppSap);
		}
	}

#if 0 // use it when merging CApplet and CAppSap
    // notify permit-to-enroll callbacks
    CApplet *pApplet;
    m_AppletList.Reset();
    while (NULL != (pApplet = m_AppletList.Iterate()))
    {
        ASSERT(0 != nConfID);
        T120AppletMsg Msg;
        Msg.eMsgType = GCC_PERMIT_TO_ENROLL_INDICATION;
        Msg.PermitToEnrollInd.nConfID = nConfID;
        Msg.PermitToEnrollInd.fPermissionGranted = TRUE;
        pApplet->SendCallbackMessage(&Msg);
    }
#endif // 0

	DebugExitINT(GCCController:ProcessConfEstablished, GCC_NO_ERROR);
	return (GCC_NO_ERROR);
}


void GCCController::RegisterApplet
(
    CApplet     *pApplet
)
{
    pApplet->AddRef();
    m_AppletList.Append(pApplet);

#if 0 // use it when merging CApplet and CAppSap
    // notify of existing conferences
    CConf      *pConf;
    GCCConfID   nConfID;
    m_ConfList2.Reset();
    while (NULL != (pConf = m_ConfList2.Iterate(&nConfID)))
    {
        ASSERT(0 != nConfID);
        T120AppletMsg Msg;
        Msg.eMsgType = GCC_PERMIT_TO_ENROLL_INDICATION;
        Msg.PermitToEnrollInd.nConfID = nConfID;
        Msg.PermitToEnrollInd.fPermissionGranted = TRUE;
        pApplet->SendCallbackMessage(&Msg);
    }
#endif // 0
}


void GCCController::UnregisterApplet
(
    CApplet     *pApplet
)
{
    m_AppletList.Remove(pApplet);
    pApplet->Release();
}


/*
 *	GCCController::ProcessConfTerminated ()
 *
 *	Private Function Description
 *		This owner callback is called when the conference has terminated
 *		itself.  Termination can occur due because of an error or it can
 *		terminate for normal reasons.
 *
 *	Formal Parameters:
 *		conference_id			-	(i)	The conference ID of the conference
 *										object that wants to terminate.
 *		gcc_reason				-	(i)	Reason the conference was terminated.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError GCCController::
ProcessConfTerminated
(
	GCCConfID   			conference_id,
	GCCReason				gcc_reason
)
{
	CConf *pConf;
    PENDING_JOIN_CONF *pJoinInfo;
    ConnectionHandle hConn;
    BOOL    fMoreToFlush;

	DebugEntry(GCCController::ProcessConfTerminated);

	if (NULL != (pConf = m_ConfList2.Find(conference_id)))
	{
		/*
		**	The conference object will be deleted the next time a 
		**	heartbeat occurs.
		*/
		m_fConfListChangePending = TRUE;
		m_ConfDeleteList.Append(pConf);
		m_ConfList2.Remove(conference_id);
		PostMsgToRebuildConfPollList();

        // flush any pending join requests from remote
        do
        {
            fMoreToFlush = FALSE;
            m_PendingJoinConfList2.Reset();
            while (NULL != (pJoinInfo = m_PendingJoinConfList2.Iterate(&hConn)))
            {
                if (pJoinInfo->nConfID == conference_id)
                {
                    FailConfJoinIndResponse(pJoinInfo->nConfID, hConn);
                    m_PendingJoinConfList2.Remove(hConn);
                    delete pJoinInfo;
                    fMoreToFlush = TRUE;
                    break;
                }
            }
        }
        while (fMoreToFlush);

#ifdef TSTATUS_INDICATION
		/*
		**	Here we inform the node controller of any resource errors that
		**	occured by sending a status message.
		*/
		if ((gcc_reason == GCC_REASON_ERROR_LOW_RESOURCES) ||
			(gcc_reason == GCC_REASON_MCS_RESOURCE_FAILURE))
		{
			g_pControlSap->StatusIndication(
											GCC_STATUS_CONF_RESOURCE_ERROR,
											(UINT)conference_id);
		}
#endif // TSTATUS_INDICATION
	}

	DebugExitINT(GCCController::ProcessConfTerminated, GCC_NO_ERROR);
	return (GCC_NO_ERROR);
}

//	Calls received from the MCS interface

void GCCController::RemoveConfJoinInfo(ConnectionHandle hConn)
{
    PENDING_JOIN_CONF *pJoinInfo = m_PendingJoinConfList2.Remove(hConn);
    delete pJoinInfo;
}


/*
 *	GCCController::ProcessConnectProviderIndication ()
 *
 *	Private Function Description
 *		This routine is called when the controller receives a Connect
 *		Provider Indication.  All connect provider indications are
 *		initially directed to the controller.  They may then be routed
 *		to the Control SAP (for a create, query, join or an invite).  
 *
 *	Formal Parameters:
 *		connect_provider_indication	-	(i)	This is the connect provider
 *											indication structure received
 *											from MCS.
 *
 *	Return Value
 *		MCS_NO_ERROR	-	No error occured.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		Note that MCS_NO_ERROR is always returned from this routine.
 *		This ensures that the MCS will not resend this message.
 */
GCCError GCCController::
ProcessConnectProviderIndication
(
    PConnectProviderIndication      connect_provider_indication
)
{
	GCCError				error_value = GCC_NO_ERROR;
	PPacket					packet;
	PConnectGCCPDU			connect_pdu;
	PacketError				packet_error;
	Result					mcs_result = RESULT_UNSPECIFIED_FAILURE;

	DebugEntry(GCCController::ProcessConnectProviderIndication);

	//	Decode the PDU type and switch appropriatly
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
					 	PACKED_ENCODING_RULES,
						connect_provider_indication->user_data,
						connect_provider_indication->user_data_length,
						CONNECT_GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		//	Only connect PDUs should be processed here
		connect_pdu = (PConnectGCCPDU)packet->GetDecodedData();

		/*
		**	Here we determine what type of GCC connect packet this is and
		**	the request is passed on to the appropriate routine to process
		**	the request.
		*/
		switch (connect_pdu->choice)
		{
		case CONFERENCE_CREATE_REQUEST_CHOSEN:
				error_value = ProcessConferenceCreateRequest(	
								&(connect_pdu->u.conference_create_request),
								connect_provider_indication);
				break;

		case CONFERENCE_QUERY_REQUEST_CHOSEN:
				error_value = ProcessConferenceQueryRequest(	
							&(connect_pdu->u.conference_query_request),
							connect_provider_indication);
				break;
				
		case CONNECT_JOIN_REQUEST_CHOSEN:
				error_value = ProcessConferenceJoinRequest(
							&(connect_pdu->u.connect_join_request),
							connect_provider_indication);
				break;
				
		case CONFERENCE_INVITE_REQUEST_CHOSEN:
				error_value = ProcessConferenceInviteRequest(	
							&(connect_pdu->u.conference_invite_request),
							connect_provider_indication);
				break;
				
		default:
				WARNING_OUT(("GCCController::ProcessConnectProviderIndication: connect pdu not supported"));
				error_value = GCC_COMMAND_NOT_SUPPORTED;
				break;
		}
		packet->Unlock();
	}
	else
	{
		if (packet != NULL)
		{
			/*
			**	Here we send a status indication to inform the node controller
			**	that someone attempted to call us with an incompatible protocol.
			*/
			if (packet_error == PACKET_INCOMPATIBLE_PROTOCOL)
			{
#ifdef TSTATUS_INDICATION
				g_pControlSap->StatusIndication(GCC_STATUS_INCOMPATIBLE_PROTOCOL, 0);
#endif // TSTATUS_INDICATION
				mcs_result = RESULT_PARAMETERS_UNACCEPTABLE;
			}
			
			packet->Unlock();
		}
		error_value = GCC_ALLOCATION_FAILURE;
	}

	/*
	**	Here, if an error occured, we send back the connect provider response 
	**	showing that a failure occured.  We use the 
	**	RESULT_PARAMETERS_UNACCEPTABLE to indicate that an
	**	incompatible protocol occured.  Otherwise, we return a result of
	**	RESULT_UNSPECIFIED_FAILURE.
	*/
	if (error_value != GCC_NO_ERROR)
	{
		WARNING_OUT(("GCCController:ProcessConnectProviderIndication: "
					"Error occured processing connect provider: error = %d", error_value));

		g_pMCSIntf->ConnectProviderResponse(
						connect_provider_indication->connection_handle,
						NULL,
						&(connect_provider_indication->domain_parameters),
						mcs_result,
						NULL, 0);
	}

	DebugExitINT(GCCController::ProcessConnectProviderIndication, error_value);
	return error_value;
}


/*
 *	GCCController::ProcessConferenceCreateRequest ()
 *
 *	Private Function Description
 *		This routine processes a GCC conference create request "connect"
 *		PDU structure.  Note that the PDU has already been decoded by
 *		the time it reaches this routine.
 *
 *	Formal Parameters:
 *		create_request				-	(i)	This is a pointer to a structure 
 *											that holds a GCC conference create 
 *											request connect PDU.
 *		connect_provider_indication	-	(i)	This is the connect provider
 *											indication structure received
 *											from MCS.	
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PASSWORD			-	Invalid password in the PDU.
 *		GCC_BAD_USER_DATA				-	Invalid user data in the PDU.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError	GCCController::ProcessConferenceCreateRequest(	
						PConferenceCreateRequest	create_request,
						PConnectProviderIndication	connect_provider_indication)
{
	GCCError					rc = GCC_NO_ERROR;
	PENDING_CREATE_CONF			*conference_info;

	GCCConferenceName			conference_name;
	GCCConfID   				conference_id;

	CPassword                   *convener_password_ptr = NULL;
	CPassword                   *password_ptr = NULL;

	LPWSTR						pwszConfDescription = NULL;
	LPWSTR						pwszCallerID = NULL;

	CUserDataListContainer	    *user_data_list = NULL;

	DebugEntry(GCCController::ProcessConferenceCreateRequest);

	DBG_SAVE_FILE_LINE
	conference_info = new PENDING_CREATE_CONF;
	if (conference_info != NULL)
	{
		/*
		**	This section of the code deals with the conference name
		*/
		conference_name.numeric_string = (GCCNumericString)create_request->
														conference_name.numeric;
												
		//	Set up the numeric name portion of the conference info structure.		
		conference_info->pszConfNumericName = ::My_strdupA(create_request->conference_name.numeric);

		//	Next get the text conference name if one exists
		if (create_request->conference_name.bit_mask & 
												CONFERENCE_NAME_TEXT_PRESENT)
		{
			//	Save the unicode string object in the conference info structure.
			if (NULL != (conference_info->pwszConfTextName = ::My_strdupW2(
							create_request->conference_name.conference_name_text.length,
							create_request->conference_name.conference_name_text.value)))
			{
				conference_name.text_string = conference_info->pwszConfTextName;
			}
			else
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			conference_name.text_string = NULL;
			ASSERT(NULL == conference_info->pwszConfTextName);
		}

		//	Unpack the convener password
		if ((create_request->bit_mask & CCRQ_CONVENER_PASSWORD_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			convener_password_ptr = new CPassword(
										&create_request->ccrq_convener_password,
										&rc);

			if (convener_password_ptr == NULL)
				rc = GCC_ALLOCATION_FAILURE;
		}

		//	Unpack the password
		if ((create_request->bit_mask & CCRQ_PASSWORD_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			password_ptr = new CPassword(&create_request->ccrq_password, &rc);
			if (password_ptr == NULL)
				rc = GCC_ALLOCATION_FAILURE;
        }

		//	Unpack the privilege list that exists
		conference_info->conduct_privilege_list = NULL;
		conference_info->conduct_mode_privilege_list = NULL;
		conference_info->non_conduct_privilege_list = NULL;

		if ((create_request->bit_mask & CCRQ_CONDUCTOR_PRIVS_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			conference_info->conduct_privilege_list = new PrivilegeListData (
										create_request->ccrq_conductor_privs);
			if (conference_info->conduct_privilege_list == NULL)
				rc = GCC_ALLOCATION_FAILURE;
		}

		if ((create_request->bit_mask & CCRQ_CONDUCTED_PRIVS_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			conference_info->conduct_mode_privilege_list = 
				new PrivilegeListData (create_request->ccrq_conducted_privs);
			if (conference_info->conduct_mode_privilege_list == NULL)
				rc = GCC_ALLOCATION_FAILURE;
		}

		if ((create_request->bit_mask & CCRQ_NON_CONDUCTED_PRIVS_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			conference_info->non_conduct_privilege_list =
				new PrivilegeListData(create_request->ccrq_non_conducted_privs);
			if (conference_info->non_conduct_privilege_list == NULL)
				rc = GCC_ALLOCATION_FAILURE;
		}

		//	Unpack the conference description if one exists
		if ((create_request->bit_mask & CCRQ_DESCRIPTION_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			pwszConfDescription = create_request->ccrq_description.value;

			/*	Save conference description data in info for later use.  This
			**	constructor will automatically append a NULL terminator to the
			**	end of the string.
			*/
			if (NULL == (conference_info->pwszConfDescription = ::My_strdupW2(
								create_request->ccrq_description.length,
								create_request->ccrq_description.value)))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == conference_info->pwszConfDescription);
		}

		//	Unpack the caller identifier if one exists
		if ((create_request->bit_mask & CCRQ_CALLER_ID_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			/*
			 * Use a temporary UnicodeString object in order to append a NULL
			 * terminator to the end of the string.
			 */
			if (NULL == (pwszCallerID = ::My_strdupW2(
							create_request->ccrq_caller_id.length,
							create_request->ccrq_caller_id.value)))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}

		//	Unpack the user data list if it exists
		if ((create_request->bit_mask & CCRQ_USER_DATA_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			user_data_list = new CUserDataListContainer(create_request->ccrq_user_data, &rc);
			if (user_data_list == NULL)
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
		}

		if (rc == GCC_NO_ERROR)
		{
			//	Build the conference information structure
			conference_info->connection_handle =
							connect_provider_indication->connection_handle;

			conference_info->conference_is_locked =
									create_request->conference_is_locked;
			conference_info->conference_is_listed =
									create_request->conference_is_listed;
			conference_info->conference_is_conductible =
									create_request->conference_is_conductible;
			conference_info->termination_method =
									(GCCTerminationMethod)
										create_request->termination_method;

			/*
			**	Add the conference information to the conference
			**	info list.  This will be accessed again on a
			**	conference create response.
			*/
			conference_id =	AllocateConferenceID();
			m_PendingCreateConfList2.Append(conference_id, conference_info);

			g_pControlSap->ConfCreateIndication
							(
							&conference_name,
							conference_id,
							convener_password_ptr,
							password_ptr,
							conference_info->conference_is_locked,
							conference_info->conference_is_listed,
							conference_info->conference_is_conductible,
							conference_info->termination_method,
							conference_info->conduct_privilege_list,
							conference_info->conduct_mode_privilege_list,
							conference_info->non_conduct_privilege_list,
							pwszConfDescription,
							pwszCallerID,
							NULL,		//	FIX: When supported by MCS
							NULL,		//	FIX: When supported by MCS
							&(connect_provider_indication->domain_parameters),
							user_data_list,
							connect_provider_indication->connection_handle);

            //
			// LONCHANC: Who is going to delete conference_info?
			//
		}

		if( NULL != convener_password_ptr )
            delete convener_password_ptr;
        if( NULL != password_ptr )
            delete password_ptr;
        if( NULL != conference_info )
			delete conference_info;

		//	Free up the user data list
		if (user_data_list != NULL)
		{
			user_data_list->Release();
		}
	}
	else
	{
		rc = GCC_ALLOCATION_FAILURE;
	}

	DebugExitINT(GCCController::ProcessConferenceCreateRequest, rc);
	return (rc);
}



/*
 *	GCCController::ProcessConferenceQueryRequest ()
 *
 *	Private Function Description
 *		This routine processes a GCC conference query request "connect"
 *		PDU structure.  Note that the PDU has already been decoded by
 *		the time it reaches this routine.
 *
 *	Formal Parameters:
 *		query_request				-	(i)	This is a pointer to a structure 
 *											that holds a GCC conference query 
 *											request connect PDU.
 *		connect_provider_indication	-	(i)	This is the connect provider
 *											indication structure received
 *											from MCS.	
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_BAD_USER_DATA				-	Invalid user data in the PDU.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError	GCCController::ProcessConferenceQueryRequest (
						PConferenceQueryRequest		query_request,
						PConnectProviderIndication	connect_provider_indication)
{
	GCCError					rc = GCC_NO_ERROR;
	GCCNodeType					node_type;
	GCCAsymmetryIndicator		asymmetry_indicator;
	PGCCAsymmetryIndicator		asymmetry_indicator_ptr = NULL;
	CUserDataListContainer	    *user_data_list = NULL;
	
	DebugEntry(GCCController::ProcessConferenceQueryRequest);

	node_type = (GCCNodeType)query_request->node_type;
	
	//	First get the asymmetry indicator if it exists
	if (query_request->bit_mask & CQRQ_ASYMMETRY_INDICATOR_PRESENT)
	{
		asymmetry_indicator.asymmetry_type = 
			(GCCAsymmetryType)query_request->cqrq_asymmetry_indicator.choice;
	
		asymmetry_indicator.random_number = 
						query_request->cqrq_asymmetry_indicator.u.unknown;
	
		asymmetry_indicator_ptr = &asymmetry_indicator; 
	}

	//	Next get the user data if it exists
	if (query_request->bit_mask & CQRQ_USER_DATA_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		user_data_list = new CUserDataListContainer(query_request->cqrq_user_data, &rc);
		if (user_data_list == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}

	if (rc == GCC_NO_ERROR)
	{
		g_pControlSap->ConfQueryIndication(
					(GCCResponseTag)connect_provider_indication->
															connection_handle,
					node_type,
					asymmetry_indicator_ptr,
					NULL,	//	FIX: When transport address supported by MCS
					NULL,	//	FIX: When transport address supported by MCS
					user_data_list,
					connect_provider_indication->connection_handle);
	}

	//	Free the user data list container
	if (user_data_list != NULL)
	{
		user_data_list->Release();
	}

	DebugExitINT(GCCController::ProcessConferenceQueryRequest, rc);
	return (rc);
}



/*
 *	GCCController::ProcessConferenceJoinRequest ()
 *
 *	Private Function Description
 *		This routine processes a GCC conference join request "connect"
 *		PDU structure.  Note that the PDU has already been decoded by
 *		the time it reaches this routine.
 *
 *		If the conference conference exist and this node is the Top 
 *		Provider for the conference we allow the join request to propogate 
 *		up to the node controller so that the decision about how to proceed is 
 *		made there.
 *  
 *		If the conference exist and this is not the Top Provider we
 *		still send the join indication to the intermediate node controller 
 *		so that this node has a chance to reject it before the join request is 
 *		passed on up to the top provider.  
 *
 *		If the conference does not currently exist at this node 
 *		we immediately reject the request and send a status indication to
 *		the local node controller to inform it of the failed join attempt.
 *
 *	Formal Parameters:
 *		join_request				-	(i)	This is a pointer to a structure 
 *											that holds a GCC conference join 
 *											request connect PDU.
 *		connect_provider_indication	-	(i)	This is the connect provider
 *											indication structure received
 *											from MCS.	
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_BAD_USER_DATA				-	Invalid user data in the PDU.
 *		GCC_INVALID_PASSWORD			-	Invalid password in the PDU.
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name in PDU.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError	GCCController::ProcessConferenceJoinRequest(
						PConferenceJoinRequest		join_request,
						PConnectProviderIndication	connect_provider_indication)
{
	GCCError				rc = GCC_NO_ERROR;
	GCCConfID   			conference_id = 0;
	GCCConferenceName		conference_name;
	GCCNumericString		conference_modifier = NULL;
	PConference				conference_ptr = NULL;
	CUserDataListContainer  *user_data_list;
	BOOL    				intermediate_node = FALSE;
	PENDING_JOIN_CONF		*join_info_ptr;
	BOOL    				convener_exists = FALSE;
	BOOL    				conference_is_locked = FALSE;
	GCCStatusMessageType	status_message_type;
	CPassword               *convener_password = NULL;
	CPassword               *password_challenge = NULL;
	PConference				lpConf;
    GCCResult               gcc_result = GCC_RESULT_SUCCESSFUL;

	DebugEntry(GCCController::ProcessConferenceJoinRequest);

	DBG_SAVE_FILE_LINE
	join_info_ptr = new PENDING_JOIN_CONF;
	if (join_info_ptr != NULL)
	{
		//	Get the conference name
		if (join_request->bit_mask & CONFERENCE_NAME_PRESENT)
		{
			if (join_request->conference_name.choice == NAME_SELECTOR_NUMERIC_CHOSEN)
			{
				conference_name.numeric_string = 
							(GCCNumericString)join_request->conference_name.u.name_selector_numeric;
				conference_name.text_string = NULL;
				join_info_ptr->numeric_name_present = TRUE;
			}
			else
			{
				conference_name.numeric_string = NULL;

				/*
				 * Use a temporary UnicodeString object in order to append a 
				 * NULL	terminator to the end of the string.
				 */
				if (NULL == (conference_name.text_string = ::My_strdupW2(
						join_request->conference_name.u.name_selector_text.length,
						join_request->conference_name.u.name_selector_text.value)))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}

				join_info_ptr->numeric_name_present = FALSE;
			}
		}
		else
			rc = GCC_INVALID_CONFERENCE_NAME;

		//	Get the conference modifier
		if (join_request->bit_mask & CJRQ_CONFERENCE_MODIFIER_PRESENT)
			conference_modifier = (GCCNumericString)join_request->cjrq_conference_modifier;

		//	Get the convener password if one exist
		if ((join_request->bit_mask & CJRQ_CONVENER_PASSWORD_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			//	First allocate the convener password for the join info structure
			DBG_SAVE_FILE_LINE
			join_info_ptr->convener_password = new CPassword(
										&join_request->cjrq_convener_password,
										&rc);

			if (join_info_ptr->convener_password == NULL)
				rc = GCC_ALLOCATION_FAILURE;
			else if (rc == GCC_NO_ERROR)
			{
				//	Now allocate the convener password to send in the indication
				DBG_SAVE_FILE_LINE
				convener_password = new CPassword(
										&join_request->cjrq_convener_password,
										&rc);

				if (convener_password == NULL)
					rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == join_info_ptr->convener_password);
		}

		//	Get the password challange if one exist
		if ((join_request->bit_mask & CJRQ_PASSWORD_PRESENT) &&
      		(rc == GCC_NO_ERROR))
		{
			//	First allocate the password for the join info structure
			DBG_SAVE_FILE_LINE
			join_info_ptr->password_challenge = new CPassword(
										&join_request->cjrq_password,
										&rc);

			if (join_info_ptr->password_challenge == NULL)
				rc = GCC_ALLOCATION_FAILURE;
			else if (rc == GCC_NO_ERROR)
			{
				//	Now allocate the password to send in the indication
				DBG_SAVE_FILE_LINE
				password_challenge = new CPassword(
											&join_request->cjrq_password,
											&rc);

				if (password_challenge == NULL)
					rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == join_info_ptr->password_challenge);
		}

		//	Get the caller identifier
		if ((join_request->bit_mask & CJRQ_CALLER_ID_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			/*
			 * Use a temporary UnicodeString object in order to append a 
			 * NULL	terminator to the end of the string.
			 */
			if (NULL == (join_info_ptr->pwszCallerID = ::My_strdupW2(
								join_request->cjrq_caller_id.length,
								join_request->cjrq_caller_id.value)))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}

		//	Get the user data if it exists
		if ((join_request->bit_mask & CJRQ_USER_DATA_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			user_data_list = new CUserDataListContainer(join_request->cjrq_user_data, &rc);
			if (user_data_list == NULL)
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
		}
		else
        {
			user_data_list = NULL;
        }

		if (rc == GCC_NO_ERROR)
		{
			/*
			**	We must query each conference to determine if the name
			**	matches the name recevied from the joining node.
			*/	                       
			conference_id = GetConferenceIDFromName(&conference_name,
													conference_modifier);

			//	Determine if this is an intermediate node
			if (conference_id == 0)
			{
				/*
				**	If the conference_id equals zero then the conference 
				**	specified in the join request does not exists and the 
				**	request is automatically rejected.  We send a GCC status 
				**	indication to the control sap to indicate that someone 
				**	tried to join with a bad conference name.
				*/
				gcc_result = GCC_RESULT_INVALID_CONFERENCE;

				//	Set up the status message
				status_message_type = GCC_STATUS_JOIN_FAILED_BAD_CONF_NAME;
			}
			else if (NULL != (lpConf = m_ConfList2.Find(conference_id)) &&
					 lpConf->IsConfEstablished() == FALSE)
			{
				/*
				**	If the conference is not established then the conference 
				**	specified in the join request does not exists and the 
				**	request is automatically rejected.  We send a GCC status 
				**	indication to the control sap to indicate that someone 
				**	tried to join with a bad conference name.
				*/
				gcc_result = GCC_RESULT_INVALID_CONFERENCE;
				
				//	Set up the status message
				status_message_type = GCC_STATUS_JOIN_FAILED_BAD_CONF_NAME;
			}
			else if (NULL != (lpConf = m_ConfList2.Find(conference_id)) &&
			 lpConf->IsConfSecure() != connect_provider_indication->fSecure )
			{
				/*
				**  If the conference security does not match the security
				**  setting of the connection underlying the join then the
				**  join is rejected
				*/

				WARNING_OUT(("JOIN REJECTED: %d joins %d",
					connect_provider_indication->fSecure,
					lpConf->IsConfSecure() ));

				//
				// Make sure that we really compared 2 booleans
				//
				ASSERT(FALSE == lpConf->IsConfSecure() ||
						TRUE == lpConf->IsConfSecure() );
				ASSERT(FALSE == connect_provider_indication->fSecure ||
					TRUE == connect_provider_indication->fSecure );

				// BUGBUG - these don't map to good UI errors
				gcc_result = lpConf->IsConfSecure() ?
					GCC_RESULT_CONNECT_PROVIDER_REMOTE_REQUIRE_SECURITY :
					GCC_RESULT_CONNECT_PROVIDER_REMOTE_NO_SECURITY ;
				
				//	Set up the status message
				status_message_type = GCC_STATUS_INCOMPATIBLE_PROTOCOL;
			}
			else
			{
				conference_ptr = m_ConfList2.Find(conference_id);

				if (! conference_ptr->IsConfTopProvider())
					intermediate_node = TRUE;

				convener_exists = conference_ptr->DoesConvenerExists();
				conference_is_locked = conference_ptr->IsConfLocked();

				/*
				**	This logic takes care of the convener password.  If the
				**	convener password exists we must make sure that the 
				**	conference does not already have a convener, that this is 
				**	not an intermediate node within the conference.
				*/
				if (((join_info_ptr->convener_password == NULL) &&
					 (conference_is_locked == FALSE)) ||
					((join_info_ptr->convener_password != NULL) &&
					 (convener_exists == FALSE) &&
					 (intermediate_node == FALSE)))
				{
					gcc_result = GCC_RESULT_SUCCESSFUL;
				}
				else
				{
					if (join_info_ptr->convener_password != NULL)
					{
						/*
						**	We must send a rejection here informing the 
						**	requester that this was an illegal join attempt due 
						**	to the presence of a convener password.
						*/
						gcc_result = GCC_RESULT_INVALID_CONVENER_PASSWORD;

						//	Set up the status message
						status_message_type = GCC_STATUS_JOIN_FAILED_BAD_CONVENER;
				 	}
					else
					{
						/*
						**	We must send a rejection here informing the 
						**	requester that the conference was locked.  
						*/
						gcc_result = GCC_RESULT_INVALID_CONFERENCE;

						//	Set up the status message
						status_message_type = GCC_STATUS_JOIN_FAILED_LOCKED;
					}
				}
			}

			/*
			**	Here we either send the conference join indication to the
			**	control sap or send back a response specifying a failed
			**	join attempt with the result code.  If the response is sent
			**	here we send a status indication to the control sap informing
			**	of the failed join attempt.
			*/
			if (gcc_result == GCC_RESULT_SUCCESSFUL)
			{
    			/*
    			**	Add the join info structure to the list of outstanding 
    			**	join request.
    			*/
    			join_info_ptr->nConfID = conference_id;
    			m_PendingJoinConfList2.Append(connect_provider_indication->connection_handle, join_info_ptr);

				//	All join request are passed to the Node Controller.
				g_pControlSap->ConfJoinIndication(
								conference_id,
								convener_password,
								password_challenge,
								join_info_ptr->pwszCallerID,
								NULL,	//	FIX: Support when added to MCS
								NULL,	//	FIX: Support when added to MCS
								user_data_list,
								intermediate_node,
								connect_provider_indication->connection_handle);
			}
			else
			{
                ConfJoinResponseInfo    cjri;
#ifdef TSTATUS_INDICATION
				/*
				**	This status message is used to inform the node controller
				**	of the failed join.
				*/
				g_pControlSap->StatusIndication(
								status_message_type, conference_id);
#endif // TSTATUS_INDICATION

				//	Send back the failed response with the result 
				cjri.result = gcc_result;
				cjri.conference_id = conference_id;
				cjri.password_challenge = NULL;
				cjri.user_data_list = NULL;
				cjri.connection_handle = connect_provider_indication->connection_handle;

				/*
				**	The join response takes care of freeing up the join
				**	info structure.
				*/
				ConfJoinIndResponse(&cjri);
				delete join_info_ptr;
			}
		}
		else
		{
			//	Clean up the join info data when an error occurs.
			delete join_info_ptr;
		}

		//	Free up any containers that are no longer needed
		if (user_data_list != NULL)
		{
			user_data_list->Release();
		}

		if (convener_password != NULL)
		{
			convener_password->Release();
		}

		if (password_challenge != NULL)
		{
			password_challenge->Release();
		}

		delete conference_name.text_string;
	}
	else
	{
		rc = GCC_ALLOCATION_FAILURE;
	}

    // in case of error, we have to flush response PDU in order to unblock the remote node
    if (GCC_NO_ERROR != rc)
    {
        FailConfJoinIndResponse(conference_id, connect_provider_indication->connection_handle);
    }

	DebugExitINT(GCCController::ProcessConferenceJoinRequest, rc);
	return (rc);
}


/*
 *	GCCController::ProcessConferenceInviteRequest ()
 *
 *	Private Function Description
 *		This routine processes a GCC conference invite request "connect"
 *		PDU structure.  Note that the PDU has already been decoded by
 *		the time it reaches this routine.
 *
 *	Formal Parameters:
 *		invite_request				-	(i)	This is a pointer to a structure 
 *											that holds a GCC conference invite 
 *											request connect PDU.
 *		connect_provider_indication	-	(i)	This is the connect provider
 *											indication structure received
 *											from MCS.	
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_BAD_USER_DATA				-	Invalid user data in the PDU.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError	GCCController::ProcessConferenceInviteRequest(	
						PConferenceInviteRequest	invite_request,
						PConnectProviderIndication	connect_provider_indication)
{
	GCCError				rc = GCC_NO_ERROR;
	PENDING_CREATE_CONF		*conference_info;
	GCCConfID   			conference_id;
	LPWSTR					pwszCallerID = NULL;
	CUserDataListContainer  *user_data_list = NULL;
	GCCConferenceName		conference_name;
	LPWSTR					pwszConfDescription = NULL;

	DBG_SAVE_FILE_LINE
	conference_info = new PENDING_CREATE_CONF;
	if (conference_info != NULL)
	{
		//	First make copies of the conference name
		conference_info->pszConfNumericName = ::My_strdupA(invite_request->conference_name.numeric);

		if (invite_request->conference_name.bit_mask & CONFERENCE_NAME_TEXT_PRESENT)
		{
			if (NULL == (conference_info->pwszConfTextName = ::My_strdupW2(
							invite_request->conference_name.conference_name_text.length,
							invite_request->conference_name.conference_name_text.value)))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == conference_info->pwszConfTextName);
		}

		//	Fill in the GCC Conference Name
		conference_name.numeric_string = (GCCNumericString) conference_info->pszConfNumericName;

		conference_name.text_string = conference_info->pwszConfTextName;

		//	Now get the privilege lists
		if (invite_request->bit_mask & CIRQ_CONDUCTOR_PRIVS_PRESENT)
		{
			DBG_SAVE_FILE_LINE
			conference_info->conduct_privilege_list = new PrivilegeListData (
										invite_request->cirq_conductor_privs);
			if (conference_info->conduct_privilege_list == NULL)
				rc = GCC_ALLOCATION_FAILURE;
		}
		else
		{
			ASSERT(NULL == conference_info->conduct_privilege_list);
		}

		if (invite_request->bit_mask & CIRQ_CONDUCTED_PRIVS_PRESENT)
		{
			DBG_SAVE_FILE_LINE
			conference_info->conduct_mode_privilege_list =
				new PrivilegeListData(invite_request->cirq_conducted_privs);
			if (conference_info->conduct_mode_privilege_list == NULL)
				rc = GCC_ALLOCATION_FAILURE;
		}
		else
		{
			ASSERT(NULL == conference_info->conduct_mode_privilege_list);
		}

		if (invite_request->bit_mask & CIRQ_NON_CONDUCTED_PRIVS_PRESENT)
		{
			DBG_SAVE_FILE_LINE
			conference_info->non_conduct_privilege_list =
				new PrivilegeListData(invite_request->cirq_non_conducted_privs);
			if (conference_info->non_conduct_privilege_list == NULL)
				rc = GCC_ALLOCATION_FAILURE;
		}
		else
		{
			ASSERT(NULL == conference_info->non_conduct_privilege_list);
		}

		//	Get the conference description of one exists
		if (invite_request->bit_mask & CIRQ_DESCRIPTION_PRESENT)
		{
			if (NULL == (conference_info->pwszConfDescription = ::My_strdupW2(
									invite_request->cirq_description.length,
									invite_request->cirq_description.value)))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
			else
			{
				pwszConfDescription = conference_info->pwszConfDescription;
			}
		}
		else
		{
			ASSERT(NULL == conference_info->pwszConfDescription);
		}

		//	Get the caller identifier
		if (invite_request->bit_mask & CIRQ_CALLER_ID_PRESENT)
		{
			/*
			 * Use a temporary UnicodeString object in order to append a 
			 * NULL	terminator to the end of the string.
			 */
			if (NULL == (pwszCallerID = ::My_strdupW2(
								invite_request->cirq_caller_id.length,
								invite_request->cirq_caller_id.value)))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}

		//	Get the user data if any exists
		if ((invite_request->bit_mask & CIRQ_USER_DATA_PRESENT) &&
				(rc == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			user_data_list = new CUserDataListContainer(invite_request->cirq_user_data, &rc);
			if (user_data_list == NULL)
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
		}

		if (rc == GCC_NO_ERROR)
		{
			//	Build the conference information structure
			conference_info->connection_handle =
								connect_provider_indication->connection_handle;

			conference_info->password_in_the_clear = 
									invite_request->clear_password_required;
			conference_info->conference_is_listed = 
									invite_request->conference_is_listed;
			conference_info->conference_is_locked = 
									invite_request->conference_is_locked;
			conference_info->conference_is_conductible = 
									invite_request->conference_is_conductible;
			conference_info->termination_method =
					(GCCTerminationMethod)invite_request->termination_method;

			conference_info->top_node_id = (UserID)invite_request->top_node_id;
			conference_info->parent_node_id = (UserID)invite_request->node_id;
			conference_info->tag_number = invite_request->tag;

			/*
			**	Add the conference information to the conference
			**	info list.  This will be accessed again on a 
			**	conference create response.
			*/
			conference_id =	AllocateConferenceID();
			m_PendingCreateConfList2.Append(conference_id, conference_info);

			g_pControlSap->ConfInviteIndication(
							conference_id,
							&conference_name,
							pwszCallerID,
							NULL,	//	FIX : When supported by MCS
							NULL,	//	FIX : When supported by MCS
							connect_provider_indication->fSecure,
							&(connect_provider_indication->domain_parameters),
							conference_info->password_in_the_clear,
							conference_info->conference_is_locked, 
							conference_info->conference_is_listed, 
							conference_info->conference_is_conductible, 
					   		conference_info->termination_method,
							conference_info->conduct_privilege_list,
							conference_info->conduct_mode_privilege_list,
							conference_info->non_conduct_privilege_list,
							pwszConfDescription,
							user_data_list,
							connect_provider_indication->connection_handle);
            //
			// LONCHANC: Who will free conference_info?
			//
		}
		else
		{
			delete conference_info;
		}

		//	Free up the user data list
		if (user_data_list != NULL)
		{
			user_data_list->Release();
		}

		delete pwszCallerID;
	}
	else
	{
		rc = GCC_ALLOCATION_FAILURE;
	}

	return (rc);
}



/*
 *	GCCController::ProcessConnectProviderConfirm ()
 *
 *	Private Function Description
 *		This routine is called when the controller receives a Connect Provider
 *		confirm from the MCS interface.  This will occur after a conference
 *		query request is issued. All other connect provider confirms should
 *		be directly handled by the conference object.
 *
 *	Formal Parameters:
 *		connect_provider_confirm	-	(i)	This is the connect provider
 *											confirm structure received
 *											from MCS.	
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError GCCController::
ProcessConnectProviderConfirm
(
    PConnectProviderConfirm     connect_provider_confirm
)
{
	GCCError				error_value = GCC_NO_ERROR;
	PPacket					packet;
	PConnectGCCPDU			connect_pdu;
	PacketError				packet_error;

	/*
	**	If the user data length is zero then the GCC request to MCS to
	**	connect provider failed (probably do to a bad address).  If this
	**	happens we will check the connection handle to determine what
	**	request to match the failed confirm with.
	*/
	if (connect_provider_confirm->user_data_length != 0)
	{
		//	Decode the PDU type and switch appropriatly
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
						 	PACKED_ENCODING_RULES,
							connect_provider_confirm->user_data,
							connect_provider_confirm->user_data_length,
							CONNECT_GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			//	Only connect PDUs should be processed here
			connect_pdu = (PConnectGCCPDU)packet->GetDecodedData();

			switch (connect_pdu->choice)
			{
				case CONFERENCE_QUERY_RESPONSE_CHOSEN:
						ProcessConferenceQueryResponse(
								&(connect_pdu->u.conference_query_response),
								connect_provider_confirm);
						break;

				default:
						error_value = GCC_COMMAND_NOT_SUPPORTED;
						break;
			}
			packet->Unlock();

		}
		else
		{
			if (packet != NULL)
				packet->Unlock();

			error_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
		error_value = GCC_ALLOCATION_FAILURE;
	
	if (error_value != GCC_NO_ERROR)
	{
		/*
		**	Since we are only processing conference query responses here
		**	we know that any failure must be associated with one of these
		**	request.  
		*/
		ProcessConferenceQueryResponse(	NULL,
										connect_provider_confirm);
	}

	return error_value;
}



/*
 *	GCCController::ProcessConferenceQueryResponse ()
 *
 *	Private Function Description
 *		This routine processes a GCC conference query response "connect"
 *		PDU structure.  Note that the PDU has already been decoded by
 *		the time it reaches this routine.
 *
 *	Formal Parameters:
 *		query_response				-	(i)	This is a pointer to a structure 
 *											that holds a GCC conference query 
 *											response connect PDU.
 *		connect_provider_confirm	-	(i)	This is the connect provider
 *											confirm structure received
 *											from MCS.	
 *
 *	Return Value
 *		None
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError GCCController::
ProcessConferenceQueryResponse
(
    PConferenceQueryResponse    query_response,
    PConnectProviderConfirm     connect_provider_confirm
)
{
	CConfDescriptorListContainer *conference_list;
	GCCError					error_value = GCC_NO_ERROR;
    GCCResult					result;
	GCCConfID   				query_id;
	GCCNodeType					node_type;
	GCCAsymmetryIndicator		asymmetry_indicator;
	PGCCAsymmetryIndicator		asymmetry_indicator_ptr = NULL;
	CUserDataListContainer	    *user_data_list = NULL;

	if (GCC_INVALID_CID != (query_id = m_PendingQueryConfList2.Remove(connect_provider_confirm->connection_handle)))
	{
		//	Clean up the query connection and domain used to perform query
		g_pMCSIntf->DeleteDomain(&query_id);

		if (query_response != NULL)
		{
			//	Create a new conference list
			DBG_SAVE_FILE_LINE
			conference_list = new CConfDescriptorListContainer(query_response->conference_list, &error_value);
			if ((conference_list != NULL) && (error_value == GCC_NO_ERROR))
			{
				node_type = (GCCNodeType)query_response->node_type;
				
				//	First get the asymmetry indicator if it exists
				if (query_response->bit_mask & CQRS_ASYMMETRY_INDICATOR_PRESENT)
				{
					asymmetry_indicator.asymmetry_type = 
							(GCCAsymmetryType)query_response->
									cqrs_asymmetry_indicator.choice;
				
					asymmetry_indicator.random_number = 
							query_response->cqrs_asymmetry_indicator.u.unknown;
				
					asymmetry_indicator_ptr = &asymmetry_indicator; 
				}
				
				//	Next get the user data if it exists
				if (query_response->bit_mask & CQRS_USER_DATA_PRESENT)
				{
					DBG_SAVE_FILE_LINE
					user_data_list = new CUserDataListContainer(query_response->cqrs_user_data, &error_value);
					if (user_data_list == NULL)
                    {
						error_value = GCC_ALLOCATION_FAILURE;
                    }
				}

				result = ::TranslateQueryResultToGCCResult(query_response->result);

				if (error_value == GCC_NO_ERROR)
				{
					g_pControlSap->ConfQueryConfirm(
									node_type,
									asymmetry_indicator_ptr,
									conference_list,
									user_data_list,
									result,
									connect_provider_confirm->connection_handle);
				}
				
				/*
				**	Here we call free so that the conference list container
				**	object will be freed up when its lock count goes to zero.
				*/
				conference_list->Release();
			}
			else
			{
                if (NULL != conference_list)
                {
                    conference_list->Release();
                }
                else
                {
				    error_value = GCC_ALLOCATION_FAILURE;
                }
			}
		}
		else
		{
			switch (connect_provider_confirm->result) 
			{
			case RESULT_PARAMETERS_UNACCEPTABLE :
				result = GCC_RESULT_INCOMPATIBLE_PROTOCOL;
				break;

			case RESULT_REMOTE_NO_SECURITY :
			    	result = GCC_RESULT_CONNECT_PROVIDER_REMOTE_NO_SECURITY;
			    	break;

			case RESULT_REMOTE_DOWNLEVEL_SECURITY :
			    	result = GCC_RESULT_CONNECT_PROVIDER_REMOTE_DOWNLEVEL_SECURITY;
			    	break;
			    	
			case RESULT_REMOTE_REQUIRE_SECURITY :
				result = GCC_RESULT_CONNECT_PROVIDER_REMOTE_REQUIRE_SECURITY;
				break;
				
			case RESULT_AUTHENTICATION_FAILED :
				result = GCC_RESULT_CONNECT_PROVIDER_AUTHENTICATION_FAILED;
				break;

			default:
			    	result = GCC_RESULT_CONNECT_PROVIDER_FAILED;
			    	break;
			}

			//	Send back a failed result
			g_pControlSap->ConfQueryConfirm(
									GCC_TERMINAL,
									NULL,
									NULL,
									NULL,
									result,
									connect_provider_confirm->connection_handle);
		}
	}
	else
	{
		WARNING_OUT(("GCCController:ProcessConferenceQueryResponse: invalid conference"));
	}

	if (NULL != user_data_list)
	{
	    user_data_list->Release();
	}

	return error_value;
}


void GCCController::
CancelConfQueryRequest ( ConnectionHandle hQueryReqConn )
{
    GCCConfID       nQueryID;
    if (GCC_INVALID_CID != (nQueryID = m_PendingQueryConfList2.Remove(hQueryReqConn)))
    {
        // Clean up the query connection and domain used to perform query
        g_pMCSIntf->DeleteDomain(&nQueryID);

        // Send back a failed result
        g_pControlSap->ConfQueryConfirm(GCC_TERMINAL, NULL, NULL, NULL,
                                        GCC_RESULT_CANCELED,
                                        hQueryReqConn);
    }
}




/*
 *	GCCController::ProcessDisconnectProviderIndication ()
 *
 *	Private Function Description
 *		This routine is called when the controller receives a Disconnect
 *		Provider Indication.  All disconnect provider indications are
 *		initially directed to the controller.  They may then be routed
 *		to a conference. 
 *
 *	Formal Parameters:
 *		connection_handle		-	(i)	Logical connection that has been
 *										disconnected.
 *
 *	Return Value
 *		MCS_NO_ERROR	-	Always return MCS no error so that the
 *									message wont be delivered again.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError GCCController::
ProcessDisconnectProviderIndication
(
    ConnectionHandle        connection_handle
)
{
	GCCError				error_value = GCC_NO_ERROR;
	PConference				lpConf;

	m_ConfPollList.Reset();
	while (NULL != (lpConf = m_ConfPollList.Iterate()))
	{
		error_value = lpConf->DisconnectProviderIndication (connection_handle);

		/*
		**	Once a conference deletes a connection handle there is no
		**	need to continue in the iterator.  Connection Handles
		**	are specific to only one conference. We decided not to
		**	keep a connection handle list in both the controller and
		**	conference for resource reasons.
		*/
		if (error_value == GCC_NO_ERROR)
			break;
	}

	TRACE_OUT(("Controller::ProcessDisconnectProviderIndication: "
				"Sending ConnectionBrokenIndication"));
	g_pControlSap->ConnectionBrokenIndication(connection_handle);

	return error_value;
}

//	Utility functions used by the controller class


/*
 *	GCCController::AllocateConferenceID()	
 *
 *	Private Function Description
 *		This routine is used to generate a unique Conference ID.
 *
 *	Formal Parameters:
 *		None
 *
 *	Return Value
 *		The generated unique conference ID.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCConfID GCCController::AllocateConferenceID(void)
{
	/*
	 *	This loop simply increments a rolling number, looking for the next
	 *	one that is not already in use.
	 */

	do
	{
		m_ConfIDCounter = ((m_ConfIDCounter + 1) % MAXIMUM_CONFERENCE_ID_VALUE) + MINIMUM_CONFERENCE_ID_VALUE;
    }
        while (NULL != m_ConfList2.Find(m_ConfIDCounter));

	return m_ConfIDCounter;
}


/*
 *	GCCController::AllocateQueryID()	
 *
 *	Private Function Description
 *		This routine is used to generate a unique Query ID
 *
 *	Formal Parameters:
 *		None
 *
 *	Return Value
 *		The generated unique query ID.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCConfID GCCController::AllocateQueryID()
{
	GCCConfID   test_query_id, nConfID;
	
	/*
	 *	This loop simply increments a rolling number, looking for the next
	 *	one that is not already in use.
	 */

	while (1)
	{
        m_QueryIDCounter = ((m_QueryIDCounter + 1) % MAXIMUM_QUERY_ID_VALUE) + MINIMUM_QUERY_ID_VALUE;

		// If this handle is not in use, break from the loop and use it.
		m_PendingQueryConfList2.Reset();
		
		/*
		**	Check the outstanding query request list to make sure that no
		**	queries are using this ID.
		*/
		test_query_id = 0;													
		while (GCC_INVALID_CID != (nConfID = m_PendingQueryConfList2.Iterate()))
		{
			if (nConfID == m_QueryIDCounter)
			{
				test_query_id = nConfID;
				break;
			}
		}
		
		//	Break if the ID is not in use.
		if (test_query_id == 0)
			break;
	}

	return m_QueryIDCounter;
}



/*
 *	GCCController::GetConferenceIDFromName()
 *
 *	Private Function Description
 *		This call returns the conference Id associated with a conference
 *		name and modifier.
 *
 *	Formal Parameters:
 *		conference_name		-	(i)	Pointer to conference name structure to
 *									search on.
 *		conference_modifier	-	(i)	The conference name modifier to search on.
 *
 *	Return Value
 *		The conference ID associated with the specified name.
 *		0 if the name does not exists.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		We must iterate on the m_ConfList2 instead of the 
 *		m_ConfPollList here to insure that the list is accurate.  It
 *		is possible for the m_ConfList2 to change while the 
 *		m_ConfPollList is being iterated on followed by something like
 *		a join request.  If you don't use the m_ConfList2 here the name
 *		would still show up even after it had been terminated.
 */
GCCConfID GCCController::GetConferenceIDFromName(
									PGCCConferenceName 		conference_name,
									GCCNumericString		conference_modifier)
{
	GCCConfID   			conference_id = 0;
	LPSTR					pszNumericName;
	LPWSTR					text_name_ptr;
	LPSTR					pszConfModifier;
	PConference				lpConf;

	m_ConfList2.Reset();
	while (NULL != (lpConf = m_ConfList2.Iterate()))
	{
		pszNumericName = lpConf->GetNumericConfName();
		text_name_ptr = lpConf->GetTextConfName();
		pszConfModifier = lpConf->GetConfModifier();

		/*
		**	First check the conference name.  If both names are used we must
		**	determine if there is a match on either name.  If so the 
		**	conference is a match.  We do this because having either correct
		**	name will be interpreted as a match in a join request.
		**		
		*/
		if ((conference_name->numeric_string != NULL) &&
			(conference_name->text_string != NULL))
		{
			if (text_name_ptr != NULL)
			{
				if ((0 != lstrcmpA(pszNumericName, conference_name->numeric_string)) &&
					(0 != My_strcmpW(text_name_ptr, conference_name->text_string)))
					continue;
			}
			else
				continue;
		}
		else if (conference_name->numeric_string != NULL)
		{
			if (0 != lstrcmpA(pszNumericName, conference_name->numeric_string))
				continue;
		}
		else
		{
			if (text_name_ptr != NULL)
			{
				if (0 != My_strcmpW(text_name_ptr, conference_name->text_string))
					continue;
			}
			else
			{
				TRACE_OUT(("GCCController: GetConferenceIDFromName: Text Conference Name is NULL: No Match"));
				continue;
			}
		}

		//	Next check the conference modifier
		TRACE_OUT(("GCCController: GetConferenceIDFromName: Before Modifier Check"));
		if (conference_modifier != NULL)
		{
			if (pszConfModifier != NULL)
			{
				if (0 != lstrcmpA(pszConfModifier, conference_modifier))
				{
					TRACE_OUT(("GCCController: GetConferenceIDFromName: After Modifier Check"));
					continue;
				}
				else
				{
					TRACE_OUT(("GCCController: GetConferenceIDFromName: Name match was found"));
				}
			}
			else
			{
				TRACE_OUT(("GCCController: GetConferenceIDFromName: Conference Modifier is NULL: No Match"));
				continue;
			}
		}
		else if (pszConfModifier != NULL)
			continue;
		
		/*
		**	If we get this far then we have found the correct conference.
		**	Go ahead and get the conference id and then break out of the
		**	search loop.
		*/
		conference_id = lpConf->GetConfID();
		break;
	}

	return (conference_id);
}


//
// Called from the SAP window procedure.
//
void GCCController::
WndMsgHandler ( UINT uMsg )
{
    if (GCTRL_REBUILD_CONF_POLL_LIST == uMsg)
    {
        if (m_fConfListChangePending)
        {
            CConf *pConf;

            m_fConfListChangePending = FALSE;
            m_ConfPollList.Clear();

            //	Delete any outstanding conference objects
            m_ConfDeleteList.DeleteList();

            //	Create a new conference poll list		
            m_ConfList2.Reset();
            while (NULL != (pConf = m_ConfList2.Iterate()))
            {
                m_ConfPollList.Append(pConf);
            }
        }

        //
        // Flush any pending PDU.
        //
        FlushOutgoingPDU();
    }
    else
    {
        ERROR_OUT(("GCCController::WndMsgHandler: invalid msg=%u", uMsg));
    }
}


//
// Rebuild the conf poll list in the next tick.
//
void GCCController::
PostMsgToRebuildConfPollList ( void )
{
    if (NULL != g_pControlSap)
    {
        ::PostMessage(g_pControlSap->GetHwnd(), GCTRL_REBUILD_CONF_POLL_LIST, 0, (LPARAM) this);
    }
    else
    {
        ERROR_OUT(("GCCController::PostMsgToRebuildConfPollList: invalid control sap"));
    }
}


//
// Enumerate all conferences and flush their pending outgoing PDUs to MCS.
//
BOOL GCCController::
FlushOutgoingPDU ( void )
{
    BOOL    fFlushMoreData = FALSE;
    CConf   *pConf;

    m_ConfPollList.Reset();
    while (NULL != (pConf = m_ConfPollList.Iterate()))
    {
        fFlushMoreData |= pConf->FlushOutgoingPDU();
    }

    return fFlushMoreData;
}


//
// Called from MCS work thread.
//
BOOL GCCRetryFlushOutgoingPDU ( void )
{
    BOOL    fFlushMoreData = FALSE;

    //
    // Normally, we should get to here because it is very rarely
    // that there is a backlog in MCS SendData. We are using local memory.
    // It will be interesting to note that we are having a backlog here.
    //
    TRACE_OUT(("GCCRetryFlushOutgoingPDU: ============"));

    //
    // We have to enter GCC critical section because
    // we are called from MCS work thread.
    //
    ::EnterCriticalSection(&g_csGCCProvider);
    if (NULL != g_pGCCController)
    {
        fFlushMoreData = g_pGCCController->FlushOutgoingPDU();
    }
    ::LeaveCriticalSection(&g_csGCCProvider);

    return fFlushMoreData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\mcsber.c ===
#include <windows.h>
#include <msber.h>
#include "mcspdu.h"

#ifndef ASSERT
#ifdef _DEBUG
#define ASSERT(flag) if (!(flag)) DebugBreak()
#else
#define ASSERT(flag)
#endif /* _DEBUG */
#endif /* ! ASSERT */


__inline int ASN1API ASN1BEREncSimpleOSTR(ASN1encoding_t enc, ASN1uint32_t len, ASN1octet_t *val)
{
    return ASN1BEREncOctetString(enc, 0x4, len, val);
}
__inline int ASN1API ASN1BERDecSimpleOSTR(ASN1decoding_t dec, ASN1octetstring_t *val)
{
    return ASN1BERDecOctetString(dec, 0x4, val);
}

__inline int ASN1API ASN1BEREncSimpleU32(ASN1encoding_t enc, ASN1uint32_t val)
{
    return ASN1BEREncU32(enc, 0x02, val);
}
__inline int ASN1API ASN1BERDecSimpleU32Val(ASN1decoding_t dec, ASN1uint32_t *val)
{
    return ASN1BERDecU32Val(dec, 0x02, val);
}

__inline int ASN1API ASN1BEREncEnum(ASN1encoding_t enc, ASN1uint32_t val)
{
    return ASN1BEREncU32(enc, 0x0a, val);
}
__inline int ASN1API ASN1BERDecEnum(ASN1decoding_t dec, ASN1uint32_t *val)
{
    return ASN1BERDecU32Val(dec, 0x0a, val);
}


// THE FOLLOWING IS GENERATED BY THE TELES COMPILER PLUS MANUAL CHANGES

ASN1int32_t ASN1CALL ASN1Enc_PDUDomainParameters(ASN1encoding_t enc, PDUDomainParameters *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->max_channel_ids))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->max_user_ids))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->max_token_ids))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->number_priorities))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->min_throughput))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->max_height))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->max_mcspdu_size))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->protocol_version))
        return 0;
    return ASN1BEREncEndOfContents(enc, nLenOff);
}

ASN1int32_t ASN1CALL ASN1Dec_PDUDomainParameters(ASN1decoding_t dec, PDUDomainParameters *val)
{
    ASN1octet_t *pBufEnd;
    if (!ASN1BERDecExplicitTag(dec, 0x10, NULL, &pBufEnd))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->max_channel_ids))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->max_user_ids))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->max_token_ids))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->number_priorities))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->min_throughput))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->max_height))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->max_mcspdu_size))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->protocol_version))
        return 0;
    return ASN1BERDecEndOfContents(dec, NULL, pBufEnd);
}

ASN1int32_t ASN1CALL ASN1Enc_ConnectInitialPDU(ASN1encoding_t enc, ConnectInitialPDU *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, 0x40000065, &nLenOff))
        return 0;
    if (!ASN1BEREncSimpleOSTR(enc, ((val)->calling_domain_selector).length, ((val)->calling_domain_selector).value))
        return 0;
    if (!ASN1BEREncSimpleOSTR(enc, ((val)->called_domain_selector).length, ((val)->called_domain_selector).value))
        return 0;
    if (!ASN1BEREncBool(enc, 0x01, (val)->upward_flag))
        return 0;
    if (!ASN1Enc_PDUDomainParameters(enc, &(val)->target_parameters))
        return 0;
    if (!ASN1Enc_PDUDomainParameters(enc, &(val)->minimum_parameters))
        return 0;
    if (!ASN1Enc_PDUDomainParameters(enc, &(val)->maximum_parameters))
        return 0;
    if (!ASN1BEREncSimpleOSTR(enc, ((val)->user_data).length, ((val)->user_data).value))
        return 0;
    return ASN1BEREncEndOfContents(enc, nLenOff);
}

ASN1int32_t ASN1CALL ASN1Dec_ConnectInitialPDU(ASN1decoding_t dec, ConnectInitialPDU *val)
{
    ASN1octet_t *pBufEnd;
    if (!ASN1BERDecExplicitTag(dec, 0x40000065, NULL, &pBufEnd))
        return 0;
    if (!ASN1BERDecSimpleOSTR(dec, &(val)->calling_domain_selector))
        return 0;
    if (!ASN1BERDecSimpleOSTR(dec, &(val)->called_domain_selector))
        return 0;
    if (!ASN1BERDecBool(dec, 0x01, &(val)->upward_flag))
        return 0;
    if (!ASN1Dec_PDUDomainParameters(dec, &(val)->target_parameters))
        return 0;
    if (!ASN1Dec_PDUDomainParameters(dec, &(val)->minimum_parameters))
        return 0;
    if (!ASN1Dec_PDUDomainParameters(dec, &(val)->maximum_parameters))
        return 0;
    if (!ASN1BERDecSimpleOSTR(dec, &(val)->user_data))
        return 0;
    return ASN1BERDecEndOfContents(dec, NULL, pBufEnd);
}

ASN1int32_t ASN1CALL ASN1Enc_ConnectResponsePDU(ASN1encoding_t enc, ConnectResponsePDU *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, 0x40000066, &nLenOff))
        return 0;
    if (!ASN1BEREncEnum(enc, (val)->result))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->called_connect_id))
        return 0;
    if (!ASN1Enc_PDUDomainParameters(enc, &(val)->domain_parameters))
        return 0;
    if (!ASN1BEREncSimpleOSTR(enc, ((val)->user_data).length, ((val)->user_data).value))
        return 0;
    return ASN1BEREncEndOfContents(enc, nLenOff);
}

ASN1int32_t ASN1CALL ASN1Dec_ConnectResponsePDU(ASN1decoding_t dec, ConnectResponsePDU *val)
{
    ASN1octet_t *pBufEnd;
    if (!ASN1BERDecExplicitTag(dec, 0x40000066, NULL, &pBufEnd))
        return 0;
    if (!ASN1BERDecEnum(dec, (ASN1uint32_t *) &(val)->result))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->called_connect_id))
        return 0;
    if (!ASN1Dec_PDUDomainParameters(dec, &(val)->domain_parameters))
        return 0;
    if (!ASN1BERDecSimpleOSTR(dec, &(val)->user_data))
        return 0;
    return ASN1BERDecEndOfContents(dec, NULL, pBufEnd);
}

ASN1int32_t ASN1CALL ASN1Enc_ConnectAdditionalPDU(ASN1encoding_t enc, ConnectAdditionalPDU *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, 0x40000067, &nLenOff))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->called_connect_id))
        return 0;
    if (!ASN1BEREncEnum(enc, (val)->data_priority))
        return 0;
    return ASN1BEREncEndOfContents(enc, nLenOff);
}

ASN1int32_t ASN1CALL ASN1Dec_ConnectAdditionalPDU(ASN1decoding_t dec, ConnectAdditionalPDU *val)
{
    ASN1octet_t *pBufEnd;
    if (!ASN1BERDecExplicitTag(dec, 0x40000067, NULL, &pBufEnd))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->called_connect_id))
        return 0;
    if (!ASN1BERDecEnum(dec, (ASN1uint32_t *) &(val)->data_priority))
        return 0;
    return ASN1BERDecEndOfContents(dec, NULL, pBufEnd);
}

ASN1int32_t ASN1CALL ASN1Enc_ConnectResultPDU(ASN1encoding_t enc, ConnectResultPDU *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, 0x40000068, &nLenOff))
        return 0;
    if (!ASN1BEREncEnum(enc, (val)->result))
        return 0;
    return ASN1BEREncEndOfContents(enc, nLenOff);
}

ASN1int32_t ASN1CALL ASN1Dec_ConnectResultPDU(ASN1decoding_t dec, ConnectResultPDU *val)
{
    ASN1octet_t *pBufEnd;
    if (!ASN1BERDecExplicitTag(dec, 0x40000068, NULL, &pBufEnd))
        return 0;
    if (!ASN1BERDecEnum(dec, (ASN1uint32_t *) &(val)->result))
        return 0;
    return ASN1BERDecEndOfContents(dec, NULL, pBufEnd);
}

ASN1int32_t ASN1CALL ASN1Enc_ConnectMCSPDU(ASN1encoding_t enc, ConnectMCSPDU *val)
{
    switch ((val)->choice) {
    case 1:
        if (!ASN1Enc_ConnectInitialPDU(enc, &(val)->u.connect_initial))
            return 0;
        break;
    case 2:
        if (!ASN1Enc_ConnectResponsePDU(enc, &(val)->u.connect_response))
            return 0;
        break;
    case 3:
        if (!ASN1Enc_ConnectAdditionalPDU(enc, &(val)->u.connect_additional))
            return 0;
        break;
    case 4:
        if (!ASN1Enc_ConnectResultPDU(enc, &(val)->u.connect_result))
            return 0;
        break;
    default:
        ASSERT(0);
        return 0;
    }
    return 1;
}

ASN1int32_t ASN1CALL ASN1Dec_ConnectMCSPDU(ASN1decoding_t dec, ConnectMCSPDU *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
        return 0;
    switch (t) {
    case 0x40000065:
        (val)->choice = 1;
        if (!ASN1Dec_ConnectInitialPDU(dec, &(val)->u.connect_initial))
            return 0;
        break;
    case 0x40000066:
        (val)->choice = 2;
        if (!ASN1Dec_ConnectResponsePDU(dec, &(val)->u.connect_response))
            return 0;
        break;
    case 0x40000067:
        (val)->choice = 3;
        if (!ASN1Dec_ConnectAdditionalPDU(dec, &(val)->u.connect_additional))
            return 0;
        break;
    case 0x40000068:
        (val)->choice = 4;
        if (!ASN1Dec_ConnectResultPDU(dec, &(val)->u.connect_result))
            return 0;
        break;
    default:
        (val)->choice = -1;
        ASSERT(0);
        return 0;
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\mcsdllif.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	mcsdllif.cpp
 *
 *	Copyright (c) 1993 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the MCAT MCS DLL interface class.
 *		This class is designed to work with Microsoft's implementation of the
 *		MCS DLL. All access by GCC to and from this DLL should pass through
 *		this class.
 *
 *		MCS interface objects represent the Service Access Point (SAP)
 *		between GCC and MCS.  Exactly how the interface works is an
 *		implementation matter for those classes that inherit from this one.
 *		This class defines the public member functions that GCC expects to be
 *		able to call upon to utilize MCS.
 *
 *		The public member functions defined here can be broken into two
 *		categories: those that are part of T.122; and those that are not.
 *		The T.122 functions include connect provider request, connect
 *		provider response, disconnect provider request, create domain, delete
 *		domain, send data request, etc.  All other member functions are
 *		considered a local matter from a standards point-of-view.  These
 *		functions include support for initialization and setup, as well as
 *		functions allowing GCC to poll MCS for activity.
 *
 *		This class contains a number of virtual functions which GCC needs to
 *		operate.  Making these functions virtual in the base class allows the
 *		MCS interface to be portable to most any platform.  All the platform
 *		specific code required to access MCS is contained in classes that will
 *		inherit from this one.
 *
 *		Note that this class also handles the connect provider confirms by
 *		keeping a list of all the objects with outstanding connect provider
 *		request.  These are held in the ConfirmObjectList.
 *
 *	Portable
 *		No
 *
 *	Author:
 *		Christos Tsollis
 */

#include "mcsdllif.h"
#include "mcsuser.h"
#include "gcontrol.h"


extern CRITICAL_SECTION g_csGCCProvider;

/*
 *	g_pMCSController
 *		This is a pointer to the one-and-only controller created within the
 *		MCS system.  This object is created during MCSInitialize by the process
 *		that is taking on the responsibilities of the node controller.
 */
extern PController		g_pMCSController;

void CALLBACK	MCSCallBackProcedure (UINT, LPARAM, PVoid);


//	MACROS used with the packet rebuilder
#define		SEND_DATA_PACKET			0
#define		UNIFORM_SEND_DATA_PACKET	1


extern MCSDLLInterface      *g_pMCSIntf;

/*
 *	MCSDLLInterface ( )
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the MCS Interface class. It is responsible
 *		for initializing the MCAT MCS DLL.  Any errors that occur during
 *		initialization are returned in the error_value provided.
 */
MCSDLLInterface::MCSDLLInterface(PMCSError	error_value)
:
	m_ConfirmConnHdlConfList2(),
	m_MCSUserList()
{	
	/*
	**	Create/initialize the MCS Controller object.
	*/
	DBG_SAVE_FILE_LINE
	g_pMCSController = new Controller (error_value);
	
	if (g_pMCSController == NULL) {
		/*
		 *	The allocation of the controller failed.  Report and return
		 *	the appropriate error.
		 */
		WARNING_OUT (("MCSDLLInterface::MCSDLLInterface: controller creation failed"));
		*error_value = MCS_ALLOCATION_FAILURE;
	}
#ifdef _DEBUG
	else if (*error_value != MCS_NO_ERROR) {
		WARNING_OUT (("MCSDLLInterface::MCSDLLInterface: MCS controller is faulty."));
	}
#endif // _DEBUG
}


/*
 *	~MCSDLLInterface ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the MCS Interface class. It is responsible
 *		for cleaning up both itself and the MCAT MCS DLL.
 */
MCSDLLInterface::~MCSDLLInterface ()
{
	/*
	 *	Destroy the controller, which will clean up all resources
	 *	in use at this time.  Then reset the flag indicating that
	 *	MCS is initialized (since it no longer is).
	 */
	TRACE_OUT (("MCSDLLInterface::~MCSDLLInterface: deleting controller"));
	if (NULL != g_pMCSController) {
		g_pMCSController->Release();
	}
 }

/*
 *	MCSError	ConnectProviderRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This T.122 primitive is used to connect two domains. This request
 *		should always be followed by a connect provider confirm.  The
 *		confirm will be sent to be object specified by the confirm object
 *		the is passed into this routine.
 */
MCSError	MCSDLLInterface::ConnectProviderRequest (
							GCCConfID          *calling_domain,
							GCCConfID          *called_domain,
							TransportAddress	calling_address,
							TransportAddress	called_address,
							BOOL				fSecure,
							DBBoolean			upward_connection,
							PUChar				user_data,
							ULong				user_data_length,
							PConnectionHandle	connection_handle,
							PDomainParameters	domain_parameters,
							CConf		        *confirm_object)
{
	MCSError			mcs_error;
	ConnectRequestInfo	connect_request_info;

	/*
	 *	Pack all necessary information into a structure, since it will not
	 *	all fit into the 4 byte parameter that is sent with the message.
	 */
	connect_request_info.calling_domain = calling_domain;
	connect_request_info.called_domain = called_domain;
	connect_request_info.calling_address = calling_address;
	connect_request_info.called_address = called_address;
	connect_request_info.fSecure = fSecure;
	connect_request_info.upward_connection = upward_connection;
	connect_request_info.domain_parameters = domain_parameters;
	connect_request_info.user_data = user_data;
	connect_request_info.user_data_length = user_data_length;
	connect_request_info.connection_handle = connection_handle;

	/*
	 *	Send a connect provider request message to the controller through its
	 *	owner callback function.
	 */
	ASSERT (g_pMCSController);
	mcs_error = g_pMCSController->HandleAppletConnectProviderRequest(&connect_request_info);

	if (mcs_error == MCS_NO_ERROR)
	{
		/*
		**	The confirm object list maintains a list of object
		**	pointers that have outstanding request. When the confirms
		**	come back in, they will be routed to the appropriate object
		**	based on the connection handle.
		*/
		mcs_error = AddObjectToConfirmList (confirm_object,
											*connection_handle);
	}
	else
	{
		WARNING_OUT(("MCSDLLInterface::ConnectProviderRequest: error = %d", mcs_error));
	}

	return (mcs_error);
}

MCSError MCSDLLInterface::ConnectProviderResponse (
					ConnectionHandle	connection_handle,
					GCCConfID          *domain_selector,
					PDomainParameters	domain_parameters,
					Result				result,
					PUChar				user_data,
					ULong				user_data_length)
{
	ConnectResponseInfo		connect_response_info;

	/*
	 *	Pack all necessary information into a structure, since it will not
	 *	all fit into the 4 byte parameter that is sent with the message.
	 */
	connect_response_info.connection_handle = connection_handle;
	connect_response_info.domain_selector = domain_selector;
	connect_response_info.domain_parameters = domain_parameters;
	connect_response_info.result = result;
	connect_response_info.user_data = user_data;
	connect_response_info.user_data_length = user_data_length;

	ASSERT (g_pMCSController);
	/*
	 *	Send a connect provider response message to the controller through its
	 *	owner callback function.
	 */
	return g_pMCSController->HandleAppletConnectProviderResponse(&connect_response_info);
}

/*
 *	MCSError	DisconnectProviderRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to disconnect a node from a particular connection.
 *		This can be either an upward or downward connection
 */
MCSError	MCSDLLInterface::DisconnectProviderRequest (
							ConnectionHandle	connection_handle)
{
	ASSERT (g_pMCSController);
	m_ConfirmConnHdlConfList2.Remove(connection_handle);
	return g_pMCSController->HandleAppletDisconnectProviderRequest(connection_handle);
}

/*
 *	MCSError	AttachUserRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to create a user attachment to MCS. It will result
 *		in an attach user confirm.
 */
MCSError	MCSDLLInterface::AttachUserRequest
(
    GCCConfID          *domain_selector,
    PIMCSSap           *ppMCSSap,
    MCSUser            *user_object
)
{
	MCSError	mcs_error;

	mcs_error = MCS_AttachRequest (ppMCSSap,
									(DomainSelector) domain_selector,
									sizeof(GCCConfID),
									MCSCallBackProcedure,
									(PVoid) user_object,
									ATTACHMENT_DISCONNECT_IN_DATA_LOSS |
									ATTACHMENT_MCS_FREES_DATA_IND_BUFFER);

	if (mcs_error == MCS_NO_ERROR)
		m_MCSUserList.Append(user_object);
	
	return (mcs_error);
}

/*
 *	MCSError	DetachUserRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used when a user of MCS whishes to detach itself from
 *		a domain.
 */
MCSError	MCSDLLInterface::DetachUserRequest (PIMCSSap pMCSSap,
												PMCSUser pMCSUser)
{
	MCSError	mcs_error;
#ifdef DEBUG
	UINT_PTR	storing = (UINT_PTR) this;
#endif // DEBUG
	
	mcs_error = pMCSSap->ReleaseInterface();
	ASSERT ((UINT_PTR) this == storing);
	m_MCSUserList.Remove(pMCSUser);

	return (mcs_error);
}

/*
 *	void	ProcessCallback ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called whenever a callback message is received by
 *		the "C" callback routine. It is responsible for both processing
 *		callback messages and forwarding callback messages on to the
 *		appropriate object.
 */
void	MCSDLLInterface::ProcessCallback (unsigned int	message,
												LPARAM	parameter,
												PVoid	object_ptr)
{
	ConnectionHandle		connection_handle;
	CConf					*pConf;

	/*
	**	Before processing any callbacks from MCS we must enter a critical
	**	section to gaurantee that we do not attempt to process a message
	**	in GCC while its own thread is running.
	*/
	EnterCriticalSection (&g_csGCCProvider);

    if (MCS_SEND_DATA_INDICATION         == message ||
        MCS_UNIFORM_SEND_DATA_INDICATION == message) {

        /*
        **	First check the segmentation flag to make sure we have the
        **	entire packet.  If not we must give the partial packet to
        **	the packet rebuilder and wait for the remainder of the data.
        */
        ASSERT(((PSendData)parameter)->segmentation == (SEGMENTATION_BEGIN | SEGMENTATION_END));

    	if (IsUserAttachmentVaid ((PMCSUser)object_ptr)) {
    		//	Process the entire packet
    		if (message == MCS_SEND_DATA_INDICATION)
    		{
    		    ((PMCSUser)object_ptr)->ProcessSendDataIndication((PSendData) parameter);
    		}
    		else
    		{
    		    ((PMCSUser)object_ptr)->ProcessUniformSendDataIndication((PSendData) parameter);
    		}
    	}
    }
    else {
        //
        // Non-Send-Data callbacks.
        //
        WORD    wHiWordParam = HIWORD(parameter);
        WORD    wLoWordParam = LOWORD(parameter);

        switch (message)
        {
            /*
            **	These messages are handled by the object passed in through
            **	the user data field.
            */
            case MCS_DETACH_USER_INDICATION:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr))
            	{
            		((PMCSUser)object_ptr)->ProcessDetachUserIndication(
            	                                (Reason) wHiWordParam,
            	                                (UserID) wLoWordParam);
            	}
            	break;

            case MCS_ATTACH_USER_CONFIRM:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr))
            	{
            		((PMCSUser)object_ptr)->ProcessAttachUserConfirm(
            	                                (Result) wHiWordParam,
            	                                (UserID) wLoWordParam);
            	}
            	break;

            case MCS_CHANNEL_JOIN_CONFIRM:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr))
            	{
            		((PMCSUser)object_ptr)->ProcessChannelJoinConfirm(
            	                                (Result) wHiWordParam,
            	                                (ChannelID) wLoWordParam);
            	}
            	break;

            case MCS_CHANNEL_LEAVE_INDICATION:
#if 0 // LONCHANC: MCSUser does not handle this message.
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr))
            	{
            		((PMCSUser)object_ptr)->OwnerCallback(CHANNEL_LEAVE_INDICATION,
            											 NULL,
            											 parameter);
            	}
#endif // 0
            	break;

            case MCS_TOKEN_GRAB_CONFIRM:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr) )
            	{
            		((PMCSUser)object_ptr)->ProcessTokenGrabConfirm(
                                                (TokenID) wLoWordParam,
                                                (Result) wHiWordParam);
            	}
            	break;

            case MCS_TOKEN_GIVE_INDICATION:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr) )
            	{
            		((PMCSUser)object_ptr)->ProcessTokenGiveIndication(
                                                (TokenID) wLoWordParam,
                                                (UserID) wHiWordParam);
            	}
            	break;

            case MCS_TOKEN_GIVE_CONFIRM:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr) )
            	{
            		((PMCSUser)object_ptr)->ProcessTokenGiveConfirm(
                                                (TokenID) wLoWordParam,
                                                (Result) wHiWordParam);
            	}
            	break;

            case MCS_TOKEN_PLEASE_INDICATION:
#ifdef JASPER
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr) )
            	{
            		((PMCSUser)object_ptr)->ProcessTokenPleaseIndication(
                                                (TokenID) wLoWordParam,
                                                (UserID) wHiWordParam);
            	}
#endif // JASPER
            	break;

            case MCS_TOKEN_RELEASE_CONFIRM:
#ifdef JASPER
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr) )
            	{
            		((PMCSUser)object_ptr)->ProcessTokenReleaseConfirm(
                                                (TokenID) wLoWordParam,
                                                (Result) wHiWordParam);
            	}
#endif // JASPER
            	break;

            case MCS_TOKEN_TEST_CONFIRM:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr) )
            	{
            		((PMCSUser)object_ptr)->ProcessTokenTestConfirm(
                                                (TokenID) wLoWordParam,
                                                (TokenStatus) wHiWordParam);
            	}
            	break;

            /*
            **	These messages are handled by the object that created the
            **	MCS DLL interface.
            */
#ifdef TSTATUS_INDICATION
            case MCS_TRANSPORT_STATUS_INDICATION:
            	if (g_pControlSap != NULL)
            	{
            		g_pControlSap->TransportStatusIndication((PTransportStatus) parameter);
            	}
            	break;
#endif

            case MCS_CONNECT_PROVIDER_INDICATION:
            	g_pGCCController->ProcessConnectProviderIndication((PConnectProviderIndication) parameter);
            	// Cleanup the controller message.
            	delete (PConnectProviderIndication) parameter;
            	break;


            case MCS_DISCONNECT_PROVIDER_INDICATION:
            	connection_handle = (ConnectionHandle) parameter;

                g_pGCCController->ProcessDisconnectProviderIndication(connection_handle);

            	/*
            	**	If no entry exists in the confirm object list, there
            	**	is a problem. All confirms must have an associated
            	**	response.
            	*/
            	if (m_ConfirmConnHdlConfList2.Remove(connection_handle))
            	{
            		DisconnectProviderRequest(connection_handle);
            	}
            	break;

            /*
            **	All connect provider confirms must be matched up with the
            **	connect provider request to determine where to route the
            **	message.
            */
            case MCS_CONNECT_PROVIDER_CONFIRM:
            	connection_handle = ((PConnectProviderConfirm)parameter)->connection_handle;

            	/*
            	**	If no entry exists in the confirm object list, there
            	**	is a problem. All confirms must have an associated
            	**	response.
            	*/
            	if (NULL != (pConf = m_ConfirmConnHdlConfList2.Remove(connection_handle)))
            	{
            		//	Send the confirm to the appropriate object
            		if ((LPVOID) pConf != (LPVOID) LPVOID_NULL)
            		{
            			// confirm_object is a CConf.
            			pConf->ProcessConnectProviderConfirm((PConnectProviderConfirm) parameter);
            		}
            		else
            		{
            			// confirm_object is the GCC Controller.
            			g_pGCCController->ProcessConnectProviderConfirm((PConnectProviderConfirm)parameter);
            		}
            	}
            	else
            	{
            		WARNING_OUT(("MCSDLLInterface: ProcessCallback: Bad Connect"
            					" Provider Confirm received"));
            	}
            	
            	// Cleanup the controller message.
                CoTaskMemFree( ((PConnectProviderConfirm) parameter)->pb_cred );
            	delete (PConnectProviderConfirm) parameter;
            	break;
            	
            default:
            	WARNING_OUT(("MCSDLLInterface: ProcessCallback: Unsupported message"
            				" received from MCS = %d",message));
            	break;
    	}
    }

	//	Leave the critical section after the callback is processed.
	LeaveCriticalSection (&g_csGCCProvider);
}

/*
 *	void CALLBACK	MCSCallBackProcedure (	unsigned int message,
 *												LPARAM		 parameter,
 *												PVoid		 user_defined)
 *
 *	Functional Description:
 *		This routine receives callback messages directly from the MCAT MCS
 *		DLL.
 *
 *	Formal Parameters:
 *		message	(i)
 *			This is the mcs message to be processed
 *		parameter (i)
 *			Varies according to the message. See the MCAT programmers manual
 *		object_ptr (i)
 *			This is the user defined field that was passed to MCS on
 *			initialization.
 *
 *	Return Value:
 *		See ProcessCallback
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CALLBACK	MCSCallBackProcedure (unsigned int message,
										LPARAM		 parameter,
										PVoid		 user_defined)
{
	if (g_pMCSIntf != NULL)
		g_pMCSIntf->ProcessCallback (message, parameter, user_defined);
}


/*
 *	TranslateMCSResultToGCCResult ()
 *
 *	Public Function Description
 *		This routine translate a standard MCS result to a GCC result.
 */
GCCResult
TranslateMCSResultToGCCResult ( Result mcs_result )
{
	GCCResult	gcc_result;

    switch (mcs_result)
    {
    	case RESULT_SUCCESSFUL:
        	gcc_result = GCC_RESULT_SUCCESSFUL;
            break;

        case RESULT_PARAMETERS_UNACCEPTABLE:
        	gcc_result = GCC_RESULT_DOMAIN_PARAMETERS_UNACCEPTABLE;
            break;

        case RESULT_USER_REJECTED:
        	gcc_result = GCC_RESULT_USER_REJECTED;
        	break;

		/*
		**	Note that we are making the assumption here that the only token
		**	that GCC deals with is a conductor token.
		*/
	    case RESULT_TOKEN_NOT_AVAILABLE:
			gcc_result = GCC_RESULT_IN_CONDUCTED_MODE;
			break;
			
	    case RESULT_TOKEN_NOT_POSSESSED:
			gcc_result = GCC_RESULT_NOT_THE_CONDUCTOR;
			break;
	
		/****************************************************************/
			
        case RESULT_UNSPECIFIED_FAILURE:
        default:
        	gcc_result = GCC_RESULT_UNSPECIFIED_FAILURE;
        	break;
    }

    return (gcc_result);
}

/*
 *	MCSError	AddObjectToConfirmList ()
 *
 *	Functional Description:
 *		This function is used to add information about an object to the list
 *		which holds all information required to send connect provider confirms.
 *
 *	Formal Parameters:
 *		confirm_object (i)
 *			This is a pointer to the object the made the connect provider
 *			request.
 *		connection_handle (i)
 *			This is the connection handle returned from the connect provider
 *			request.
 *
 *	Return Value:
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
MCSError	MCSDLLInterface::AddObjectToConfirmList (
									CConf		        *pConf,
									ConnectionHandle	connection_handle)
{
	MCSError			return_value;

	/*
	**	First check to make sure that the list doesn't already contain the
	**	connection.
	*/
	if (m_ConfirmConnHdlConfList2.Find(connection_handle) == FALSE)
	{
		//	Add it to the list
		m_ConfirmConnHdlConfList2.Append(connection_handle, pConf ? pConf : (CConf *) LPVOID_NULL);
		return_value = MCS_NO_ERROR;
	}
	else
		return_value = MCS_INVALID_PARAMETER;

	return (return_value);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\mcspdu.c ===
#include <windows.h>
#include "mcspdu.h"

ASN1module_t MCSPDU_Module = NULL;

static int ASN1CALL ASN1Enc_Given(ASN1encoding_t enc, Given *val);
static int ASN1CALL ASN1Enc_Ungivable(ASN1encoding_t enc, Ungivable *val);
static int ASN1CALL ASN1Enc_Giving(ASN1encoding_t enc, Giving *val);
static int ASN1CALL ASN1Enc_Inhibited(ASN1encoding_t enc, Inhibited *val);
static int ASN1CALL ASN1Enc_Grabbed(ASN1encoding_t enc, Grabbed *val);
static int ASN1CALL ASN1Enc_ChannelAttributesAssigned(ASN1encoding_t enc, ChannelAttributesAssigned *val);
static int ASN1CALL ASN1Enc_ChannelAttributesPrivate(ASN1encoding_t enc, ChannelAttributesPrivate *val);
static int ASN1CALL ASN1Enc_ChannelAttributesUserID(ASN1encoding_t enc, ChannelAttributesUserID *val);
static int ASN1CALL ASN1Enc_ChannelAttributesStatic(ASN1encoding_t enc, ChannelAttributesStatic *val);
extern int ASN1CALL ASN1Enc_PDUDomainParameters(ASN1encoding_t enc, PDUDomainParameters *val);
extern int ASN1CALL ASN1Enc_ConnectInitialPDU(ASN1encoding_t enc, ConnectInitialPDU *val);
extern int ASN1CALL ASN1Enc_ConnectResponsePDU(ASN1encoding_t enc, ConnectResponsePDU *val);
extern int ASN1CALL ASN1Enc_ConnectAdditionalPDU(ASN1encoding_t enc, ConnectAdditionalPDU *val);
extern int ASN1CALL ASN1Enc_ConnectResultPDU(ASN1encoding_t enc, ConnectResultPDU *val);
static int ASN1CALL ASN1Enc_PlumbDomainIndicationPDU(ASN1encoding_t enc, PlumbDomainIndicationPDU *val);
static int ASN1CALL ASN1Enc_ErectDomainRequestPDU(ASN1encoding_t enc, ErectDomainRequestPDU *val);
static int ASN1CALL ASN1Enc_PDUChannelAttributes(ASN1encoding_t enc, PDUChannelAttributes *val);
static int ASN1CALL ASN1Enc_MergeChannelsRequestPDU(ASN1encoding_t enc, MergeChannelsRequestPDU *val);
static int ASN1CALL ASN1Enc_MergeChannelsConfirmPDU(ASN1encoding_t enc, MergeChannelsConfirmPDU *val);
static int ASN1CALL ASN1Enc_PurgeChannelIndicationPDU(ASN1encoding_t enc, PurgeChannelIndicationPDU *val);
static int ASN1CALL ASN1Enc_PDUTokenAttributes(ASN1encoding_t enc, PDUTokenAttributes *val);
static int ASN1CALL ASN1Enc_SetOfUserIDs(ASN1encoding_t enc, PSetOfUserIDs *val);
static int ASN1CALL ASN1Enc_SetOfPDUChannelAttributes(ASN1encoding_t enc, PSetOfPDUChannelAttributes *val);
static int ASN1CALL ASN1Enc_SetOfChannelIDs(ASN1encoding_t enc, PSetOfChannelIDs *val);
static int ASN1CALL ASN1Enc_SetOfPDUTokenAttributes(ASN1encoding_t enc, PSetOfPDUTokenAttributes *val);
static int ASN1CALL ASN1Enc_SetOfTokenIDs(ASN1encoding_t enc, PSetOfTokenIDs *val);
static int ASN1CALL ASN1Enc_MergeTokensRequestPDU(ASN1encoding_t enc, MergeTokensRequestPDU *val);
static int ASN1CALL ASN1Enc_MergeTokensConfirmPDU(ASN1encoding_t enc, MergeTokensConfirmPDU *val);
static int ASN1CALL ASN1Enc_PurgeTokenIndicationPDU(ASN1encoding_t enc, PurgeTokenIndicationPDU *val);
static int ASN1CALL ASN1Enc_DisconnectProviderUltimatumPDU(ASN1encoding_t enc, DisconnectProviderUltimatumPDU *val);
static int ASN1CALL ASN1Enc_RejectUltimatumPDU(ASN1encoding_t enc, RejectUltimatumPDU *val);
static int ASN1CALL ASN1Enc_AttachUserConfirmPDU(ASN1encoding_t enc, AttachUserConfirmPDU *val);
static int ASN1CALL ASN1Enc_DetachUserRequestPDU(ASN1encoding_t enc, DetachUserRequestPDU *val);
static int ASN1CALL ASN1Enc_DetachUserIndicationPDU(ASN1encoding_t enc, DetachUserIndicationPDU *val);
static int ASN1CALL ASN1Enc_ChannelJoinRequestPDU(ASN1encoding_t enc, ChannelJoinRequestPDU *val);
static int ASN1CALL ASN1Enc_ChannelJoinConfirmPDU(ASN1encoding_t enc, ChannelJoinConfirmPDU *val);
static int ASN1CALL ASN1Enc_ChannelLeaveRequestPDU(ASN1encoding_t enc, ChannelLeaveRequestPDU *val);
static int ASN1CALL ASN1Enc_ChannelConveneRequestPDU(ASN1encoding_t enc, ChannelConveneRequestPDU *val);
static int ASN1CALL ASN1Enc_ChannelConveneConfirmPDU(ASN1encoding_t enc, ChannelConveneConfirmPDU *val);
static int ASN1CALL ASN1Enc_ChannelDisbandRequestPDU(ASN1encoding_t enc, ChannelDisbandRequestPDU *val);
static int ASN1CALL ASN1Enc_ChannelDisbandIndicationPDU(ASN1encoding_t enc, ChannelDisbandIndicationPDU *val);
static int ASN1CALL ASN1Enc_ChannelAdmitRequestPDU(ASN1encoding_t enc, ChannelAdmitRequestPDU *val);
static int ASN1CALL ASN1Enc_ChannelAdmitIndicationPDU(ASN1encoding_t enc, ChannelAdmitIndicationPDU *val);
static int ASN1CALL ASN1Enc_ChannelExpelRequestPDU(ASN1encoding_t enc, ChannelExpelRequestPDU *val);
static int ASN1CALL ASN1Enc_ChannelExpelIndicationPDU(ASN1encoding_t enc, ChannelExpelIndicationPDU *val);
static int ASN1CALL ASN1Enc_TokenGrabRequestPDU(ASN1encoding_t enc, TokenGrabRequestPDU *val);
static int ASN1CALL ASN1Enc_TokenGrabConfirmPDU(ASN1encoding_t enc, TokenGrabConfirmPDU *val);
static int ASN1CALL ASN1Enc_TokenInhibitRequestPDU(ASN1encoding_t enc, TokenInhibitRequestPDU *val);
static int ASN1CALL ASN1Enc_TokenInhibitConfirmPDU(ASN1encoding_t enc, TokenInhibitConfirmPDU *val);
static int ASN1CALL ASN1Enc_TokenGiveRequestPDU(ASN1encoding_t enc, TokenGiveRequestPDU *val);
static int ASN1CALL ASN1Enc_TokenGiveIndicationPDU(ASN1encoding_t enc, TokenGiveIndicationPDU *val);
static int ASN1CALL ASN1Enc_TokenGiveResponsePDU(ASN1encoding_t enc, TokenGiveResponsePDU *val);
static int ASN1CALL ASN1Enc_TokenGiveConfirmPDU(ASN1encoding_t enc, TokenGiveConfirmPDU *val);
static int ASN1CALL ASN1Enc_TokenPleaseRequestPDU(ASN1encoding_t enc, TokenPleaseRequestPDU *val);
static int ASN1CALL ASN1Enc_TokenPleaseIndicationPDU(ASN1encoding_t enc, TokenPleaseIndicationPDU *val);
static int ASN1CALL ASN1Enc_TokenReleaseRequestPDU(ASN1encoding_t enc, TokenReleaseRequestPDU *val);
static int ASN1CALL ASN1Enc_TokenReleaseConfirmPDU(ASN1encoding_t enc, TokenReleaseConfirmPDU *val);
static int ASN1CALL ASN1Enc_TokenTestRequestPDU(ASN1encoding_t enc, TokenTestRequestPDU *val);
static int ASN1CALL ASN1Enc_TokenTestConfirmPDU(ASN1encoding_t enc, TokenTestConfirmPDU *val);
extern int ASN1CALL ASN1Enc_ConnectMCSPDU(ASN1encoding_t enc, ConnectMCSPDU *val);
static int ASN1CALL ASN1Enc_DomainMCSPDU(ASN1encoding_t enc, DomainMCSPDU *val);
static int ASN1CALL ASN1Dec_Given(ASN1decoding_t dec, Given *val);
static int ASN1CALL ASN1Dec_Ungivable(ASN1decoding_t dec, Ungivable *val);
static int ASN1CALL ASN1Dec_Giving(ASN1decoding_t dec, Giving *val);
static int ASN1CALL ASN1Dec_Inhibited(ASN1decoding_t dec, Inhibited *val);
static int ASN1CALL ASN1Dec_Grabbed(ASN1decoding_t dec, Grabbed *val);
static int ASN1CALL ASN1Dec_ChannelAttributesAssigned(ASN1decoding_t dec, ChannelAttributesAssigned *val);
static int ASN1CALL ASN1Dec_ChannelAttributesPrivate(ASN1decoding_t dec, ChannelAttributesPrivate *val);
static int ASN1CALL ASN1Dec_ChannelAttributesUserID(ASN1decoding_t dec, ChannelAttributesUserID *val);
static int ASN1CALL ASN1Dec_ChannelAttributesStatic(ASN1decoding_t dec, ChannelAttributesStatic *val);
extern int ASN1CALL ASN1Dec_PDUDomainParameters(ASN1decoding_t dec, PDUDomainParameters *val);
extern int ASN1CALL ASN1Dec_ConnectInitialPDU(ASN1decoding_t dec, ConnectInitialPDU *val);
extern int ASN1CALL ASN1Dec_ConnectResponsePDU(ASN1decoding_t dec, ConnectResponsePDU *val);
extern int ASN1CALL ASN1Dec_ConnectAdditionalPDU(ASN1decoding_t dec, ConnectAdditionalPDU *val);
extern int ASN1CALL ASN1Dec_ConnectResultPDU(ASN1decoding_t dec, ConnectResultPDU *val);
static int ASN1CALL ASN1Dec_PlumbDomainIndicationPDU(ASN1decoding_t dec, PlumbDomainIndicationPDU *val);
static int ASN1CALL ASN1Dec_ErectDomainRequestPDU(ASN1decoding_t dec, ErectDomainRequestPDU *val);
static int ASN1CALL ASN1Dec_PDUChannelAttributes(ASN1decoding_t dec, PDUChannelAttributes *val);
static int ASN1CALL ASN1Dec_MergeChannelsRequestPDU(ASN1decoding_t dec, MergeChannelsRequestPDU *val);
static int ASN1CALL ASN1Dec_MergeChannelsConfirmPDU(ASN1decoding_t dec, MergeChannelsConfirmPDU *val);
static int ASN1CALL ASN1Dec_PurgeChannelIndicationPDU(ASN1decoding_t dec, PurgeChannelIndicationPDU *val);
static int ASN1CALL ASN1Dec_PDUTokenAttributes(ASN1decoding_t dec, PDUTokenAttributes *val);
static int ASN1CALL ASN1Dec_SetOfUserIDs(ASN1decoding_t dec, PSetOfUserIDs *val);
static int ASN1CALL ASN1Dec_SetOfPDUChannelAttributes(ASN1decoding_t dec, PSetOfPDUChannelAttributes *val);
static int ASN1CALL ASN1Dec_SetOfChannelIDs(ASN1decoding_t dec, PSetOfChannelIDs *val);
static int ASN1CALL ASN1Dec_SetOfPDUTokenAttributes(ASN1decoding_t dec, PSetOfPDUTokenAttributes *val);
static int ASN1CALL ASN1Dec_SetOfTokenIDs(ASN1decoding_t dec, PSetOfTokenIDs *val);
static int ASN1CALL ASN1Dec_MergeTokensRequestPDU(ASN1decoding_t dec, MergeTokensRequestPDU *val);
static int ASN1CALL ASN1Dec_MergeTokensConfirmPDU(ASN1decoding_t dec, MergeTokensConfirmPDU *val);
static int ASN1CALL ASN1Dec_PurgeTokenIndicationPDU(ASN1decoding_t dec, PurgeTokenIndicationPDU *val);
static int ASN1CALL ASN1Dec_DisconnectProviderUltimatumPDU(ASN1decoding_t dec, DisconnectProviderUltimatumPDU *val);
static int ASN1CALL ASN1Dec_RejectUltimatumPDU(ASN1decoding_t dec, RejectUltimatumPDU *val);
static int ASN1CALL ASN1Dec_AttachUserConfirmPDU(ASN1decoding_t dec, AttachUserConfirmPDU *val);
static int ASN1CALL ASN1Dec_DetachUserRequestPDU(ASN1decoding_t dec, DetachUserRequestPDU *val);
static int ASN1CALL ASN1Dec_DetachUserIndicationPDU(ASN1decoding_t dec, DetachUserIndicationPDU *val);
static int ASN1CALL ASN1Dec_ChannelJoinRequestPDU(ASN1decoding_t dec, ChannelJoinRequestPDU *val);
static int ASN1CALL ASN1Dec_ChannelJoinConfirmPDU(ASN1decoding_t dec, ChannelJoinConfirmPDU *val);
static int ASN1CALL ASN1Dec_ChannelLeaveRequestPDU(ASN1decoding_t dec, ChannelLeaveRequestPDU *val);
static int ASN1CALL ASN1Dec_ChannelConveneRequestPDU(ASN1decoding_t dec, ChannelConveneRequestPDU *val);
static int ASN1CALL ASN1Dec_ChannelConveneConfirmPDU(ASN1decoding_t dec, ChannelConveneConfirmPDU *val);
static int ASN1CALL ASN1Dec_ChannelDisbandRequestPDU(ASN1decoding_t dec, ChannelDisbandRequestPDU *val);
static int ASN1CALL ASN1Dec_ChannelDisbandIndicationPDU(ASN1decoding_t dec, ChannelDisbandIndicationPDU *val);
static int ASN1CALL ASN1Dec_ChannelAdmitRequestPDU(ASN1decoding_t dec, ChannelAdmitRequestPDU *val);
static int ASN1CALL ASN1Dec_ChannelAdmitIndicationPDU(ASN1decoding_t dec, ChannelAdmitIndicationPDU *val);
static int ASN1CALL ASN1Dec_ChannelExpelRequestPDU(ASN1decoding_t dec, ChannelExpelRequestPDU *val);
static int ASN1CALL ASN1Dec_ChannelExpelIndicationPDU(ASN1decoding_t dec, ChannelExpelIndicationPDU *val);
static int ASN1CALL ASN1Dec_TokenGrabRequestPDU(ASN1decoding_t dec, TokenGrabRequestPDU *val);
static int ASN1CALL ASN1Dec_TokenGrabConfirmPDU(ASN1decoding_t dec, TokenGrabConfirmPDU *val);
static int ASN1CALL ASN1Dec_TokenInhibitRequestPDU(ASN1decoding_t dec, TokenInhibitRequestPDU *val);
static int ASN1CALL ASN1Dec_TokenInhibitConfirmPDU(ASN1decoding_t dec, TokenInhibitConfirmPDU *val);
static int ASN1CALL ASN1Dec_TokenGiveRequestPDU(ASN1decoding_t dec, TokenGiveRequestPDU *val);
static int ASN1CALL ASN1Dec_TokenGiveIndicationPDU(ASN1decoding_t dec, TokenGiveIndicationPDU *val);
static int ASN1CALL ASN1Dec_TokenGiveResponsePDU(ASN1decoding_t dec, TokenGiveResponsePDU *val);
static int ASN1CALL ASN1Dec_TokenGiveConfirmPDU(ASN1decoding_t dec, TokenGiveConfirmPDU *val);
static int ASN1CALL ASN1Dec_TokenPleaseRequestPDU(ASN1decoding_t dec, TokenPleaseRequestPDU *val);
static int ASN1CALL ASN1Dec_TokenPleaseIndicationPDU(ASN1decoding_t dec, TokenPleaseIndicationPDU *val);
static int ASN1CALL ASN1Dec_TokenReleaseRequestPDU(ASN1decoding_t dec, TokenReleaseRequestPDU *val);
static int ASN1CALL ASN1Dec_TokenReleaseConfirmPDU(ASN1decoding_t dec, TokenReleaseConfirmPDU *val);
static int ASN1CALL ASN1Dec_TokenTestRequestPDU(ASN1decoding_t dec, TokenTestRequestPDU *val);
static int ASN1CALL ASN1Dec_TokenTestConfirmPDU(ASN1decoding_t dec, TokenTestConfirmPDU *val);
extern int ASN1CALL ASN1Dec_ConnectMCSPDU(ASN1decoding_t dec, ConnectMCSPDU *val);
static int ASN1CALL ASN1Dec_DomainMCSPDU(ASN1decoding_t dec, DomainMCSPDU *val);
static void ASN1CALL ASN1Free_Inhibited(Inhibited *val);
static void ASN1CALL ASN1Free_ChannelAttributesPrivate(ChannelAttributesPrivate *val);
static void ASN1CALL ASN1Free_ConnectInitialPDU(ConnectInitialPDU *val);
static void ASN1CALL ASN1Free_ConnectResponsePDU(ConnectResponsePDU *val);
static void ASN1CALL ASN1Free_PDUChannelAttributes(PDUChannelAttributes *val);
static void ASN1CALL ASN1Free_MergeChannelsRequestPDU(MergeChannelsRequestPDU *val);
static void ASN1CALL ASN1Free_MergeChannelsConfirmPDU(MergeChannelsConfirmPDU *val);
static void ASN1CALL ASN1Free_PurgeChannelIndicationPDU(PurgeChannelIndicationPDU *val);
static void ASN1CALL ASN1Free_PDUTokenAttributes(PDUTokenAttributes *val);
static void ASN1CALL ASN1Free_SetOfUserIDs(PSetOfUserIDs *val);
static void ASN1CALL ASN1Free_SetOfPDUChannelAttributes(PSetOfPDUChannelAttributes *val);
static void ASN1CALL ASN1Free_SetOfChannelIDs(PSetOfChannelIDs *val);
static void ASN1CALL ASN1Free_SetOfPDUTokenAttributes(PSetOfPDUTokenAttributes *val);
static void ASN1CALL ASN1Free_SetOfTokenIDs(PSetOfTokenIDs *val);
static void ASN1CALL ASN1Free_MergeTokensRequestPDU(MergeTokensRequestPDU *val);
static void ASN1CALL ASN1Free_MergeTokensConfirmPDU(MergeTokensConfirmPDU *val);
static void ASN1CALL ASN1Free_PurgeTokenIndicationPDU(PurgeTokenIndicationPDU *val);
static void ASN1CALL ASN1Free_RejectUltimatumPDU(RejectUltimatumPDU *val);
static void ASN1CALL ASN1Free_DetachUserRequestPDU(DetachUserRequestPDU *val);
static void ASN1CALL ASN1Free_DetachUserIndicationPDU(DetachUserIndicationPDU *val);
static void ASN1CALL ASN1Free_ChannelLeaveRequestPDU(ChannelLeaveRequestPDU *val);
static void ASN1CALL ASN1Free_ChannelAdmitRequestPDU(ChannelAdmitRequestPDU *val);
static void ASN1CALL ASN1Free_ChannelAdmitIndicationPDU(ChannelAdmitIndicationPDU *val);
static void ASN1CALL ASN1Free_ChannelExpelRequestPDU(ChannelExpelRequestPDU *val);
static void ASN1CALL ASN1Free_ChannelExpelIndicationPDU(ChannelExpelIndicationPDU *val);
static void ASN1CALL ASN1Free_ConnectMCSPDU(ConnectMCSPDU *val);
static void ASN1CALL ASN1Free_DomainMCSPDU(DomainMCSPDU *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[2] = {
    (ASN1EncFun_t) ASN1Enc_ConnectMCSPDU,
    (ASN1EncFun_t) ASN1Enc_DomainMCSPDU,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[2] = {
    (ASN1DecFun_t) ASN1Dec_ConnectMCSPDU,
    (ASN1DecFun_t) ASN1Dec_DomainMCSPDU,
};
static const ASN1FreeFun_t freefntab[2] = {
    (ASN1FreeFun_t) ASN1Free_ConnectMCSPDU,
    (ASN1FreeFun_t) ASN1Free_DomainMCSPDU,
};
static const ULONG sizetab[2] = {
    SIZE_MCSPDU_Module_PDU_0,
    SIZE_MCSPDU_Module_PDU_1,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */
void ASN1CALL MCSPDU_Module_Startup(void)
{
    MCSPDU_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 2, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x73636d);
}
void ASN1CALL MCSPDU_Module_Cleanup(void)
{
    ASN1_CloseModule(MCSPDU_Module);
    MCSPDU_Module = NULL;
}

static int ASN1CALL ASN1Enc_Given(ASN1encoding_t enc, Given *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->recipient - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Given(ASN1decoding_t dec, Given *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->recipient))
	return 0;
    (val)->recipient += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_Ungivable(ASN1encoding_t enc, Ungivable *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->grabber - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Ungivable(ASN1decoding_t dec, Ungivable *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->grabber))
	return 0;
    (val)->grabber += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_Giving(ASN1encoding_t enc, Giving *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->grabber - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->recipient - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Giving(ASN1decoding_t dec, Giving *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->grabber))
	return 0;
    (val)->grabber += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->recipient))
	return 0;
    (val)->recipient += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_Inhibited(ASN1encoding_t enc, Inhibited *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->inhibitors))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Inhibited(ASN1decoding_t dec, Inhibited *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->inhibitors))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Inhibited(Inhibited *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->inhibitors);
    }
}

static int ASN1CALL ASN1Enc_Grabbed(ASN1encoding_t enc, Grabbed *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->grabber - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Grabbed(ASN1decoding_t dec, Grabbed *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->grabber))
	return 0;
    (val)->grabber += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelAttributesAssigned(ASN1encoding_t enc, ChannelAttributesAssigned *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelAttributesAssigned(ASN1decoding_t dec, ChannelAttributesAssigned *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelAttributesPrivate(ASN1encoding_t enc, ChannelAttributesPrivate *val)
{
    if (!ASN1PEREncBoolean(enc, (val)->joined))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->manager - 1001))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->admitted))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelAttributesPrivate(ASN1decoding_t dec, ChannelAttributesPrivate *val)
{
    if (!ASN1PERDecBoolean(dec, &(val)->joined))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->manager))
	return 0;
    (val)->manager += 1001;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->admitted))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ChannelAttributesPrivate(ChannelAttributesPrivate *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->admitted);
    }
}

static int ASN1CALL ASN1Enc_ChannelAttributesUserID(ASN1encoding_t enc, ChannelAttributesUserID *val)
{
    if (!ASN1PEREncBoolean(enc, (val)->joined))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->user_id - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelAttributesUserID(ASN1decoding_t dec, ChannelAttributesUserID *val)
{
    if (!ASN1PERDecBoolean(dec, &(val)->joined))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->user_id))
	return 0;
    (val)->user_id += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelAttributesStatic(ASN1encoding_t enc, ChannelAttributesStatic *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelAttributesStatic(ASN1decoding_t dec, ChannelAttributesStatic *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectInitialPDU(ConnectInitialPDU *val)
{
    if (val) {
        ASN1octetstring_free(&(val)->calling_domain_selector);
        ASN1octetstring_free(&(val)->called_domain_selector);
        ASN1octetstring_free(&(val)->user_data);
    }
}

static void ASN1CALL ASN1Free_ConnectResponsePDU(ConnectResponsePDU *val)
{
    if (val) {
        ASN1octetstring_free(&(val)->user_data);
    }
}

static int ASN1CALL ASN1Enc_PlumbDomainIndicationPDU(ASN1encoding_t enc, PlumbDomainIndicationPDU *val)
{
    if (!ASN1PEREncUnsignedInteger(enc, (val)->height_limit))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PlumbDomainIndicationPDU(ASN1decoding_t dec, PlumbDomainIndicationPDU *val)
{
    if (!ASN1PERDecUnsignedInteger(dec, &(val)->height_limit))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ErectDomainRequestPDU(ASN1encoding_t enc, ErectDomainRequestPDU *val)
{
#ifndef _WIN64
    if (!ASN1PEREncUnsignedInteger(enc, (val)->sub_height))
#endif
	return 0;
    if (!ASN1PEREncUnsignedInteger(enc, (val)->sub_interval))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ErectDomainRequestPDU(ASN1decoding_t dec, ErectDomainRequestPDU *val)
{
#ifndef _WIN64
    if (!ASN1PERDecUnsignedInteger(dec, &(val)->sub_height))
#endif
	return 0;
    if (!ASN1PERDecUnsignedInteger(dec, &(val)->sub_interval))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_PDUChannelAttributes(ASN1encoding_t enc, PDUChannelAttributes *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ChannelAttributesStatic(enc, &(val)->u.channel_attributes_static))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ChannelAttributesUserID(enc, &(val)->u.channel_attributes_user_id))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ChannelAttributesPrivate(enc, &(val)->u.channel_attributes_private))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ChannelAttributesAssigned(enc, &(val)->u.channel_attributes_assigned))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PDUChannelAttributes(ASN1decoding_t dec, PDUChannelAttributes *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ChannelAttributesStatic(dec, &(val)->u.channel_attributes_static))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ChannelAttributesUserID(dec, &(val)->u.channel_attributes_user_id))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ChannelAttributesPrivate(dec, &(val)->u.channel_attributes_private))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ChannelAttributesAssigned(dec, &(val)->u.channel_attributes_assigned))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PDUChannelAttributes(PDUChannelAttributes *val)
{
    if (val) {
        switch ((val)->choice) {
        case 3:
            ASN1Free_ChannelAttributesPrivate(&(val)->u.channel_attributes_private);
            break;
        }
    }
}

static int ASN1CALL ASN1Enc_MergeChannelsRequestPDU(ASN1encoding_t enc, MergeChannelsRequestPDU *val)
{
    if (!ASN1Enc_SetOfPDUChannelAttributes(enc, &(val)->merge_channels))
	return 0;
    if (!ASN1Enc_SetOfChannelIDs(enc, &(val)->purge_channel_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MergeChannelsRequestPDU(ASN1decoding_t dec, MergeChannelsRequestPDU *val)
{
    if (!ASN1Dec_SetOfPDUChannelAttributes(dec, &(val)->merge_channels))
	return 0;
    if (!ASN1Dec_SetOfChannelIDs(dec, &(val)->purge_channel_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MergeChannelsRequestPDU(MergeChannelsRequestPDU *val)
{
    if (val) {
        ASN1Free_SetOfPDUChannelAttributes(&(val)->merge_channels);
        ASN1Free_SetOfChannelIDs(&(val)->purge_channel_ids);
    }
}

static int ASN1CALL ASN1Enc_MergeChannelsConfirmPDU(ASN1encoding_t enc, MergeChannelsConfirmPDU *val)
{
    if (!ASN1Enc_SetOfPDUChannelAttributes(enc, &(val)->merge_channels))
	return 0;
    if (!ASN1Enc_SetOfChannelIDs(enc, &(val)->purge_channel_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MergeChannelsConfirmPDU(ASN1decoding_t dec, MergeChannelsConfirmPDU *val)
{
    if (!ASN1Dec_SetOfPDUChannelAttributes(dec, &(val)->merge_channels))
	return 0;
    if (!ASN1Dec_SetOfChannelIDs(dec, &(val)->purge_channel_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MergeChannelsConfirmPDU(MergeChannelsConfirmPDU *val)
{
    if (val) {
        ASN1Free_SetOfPDUChannelAttributes(&(val)->merge_channels);
        ASN1Free_SetOfChannelIDs(&(val)->purge_channel_ids);
    }
}

static int ASN1CALL ASN1Enc_PurgeChannelIndicationPDU(ASN1encoding_t enc, PurgeChannelIndicationPDU *val)
{
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->detach_user_ids))
	return 0;
    if (!ASN1Enc_SetOfChannelIDs(enc, &(val)->purge_channel_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PurgeChannelIndicationPDU(ASN1decoding_t dec, PurgeChannelIndicationPDU *val)
{
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->detach_user_ids))
	return 0;
    if (!ASN1Dec_SetOfChannelIDs(dec, &(val)->purge_channel_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PurgeChannelIndicationPDU(PurgeChannelIndicationPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->detach_user_ids);
        ASN1Free_SetOfChannelIDs(&(val)->purge_channel_ids);
    }
}

static int ASN1CALL ASN1Enc_PDUTokenAttributes(ASN1encoding_t enc, PDUTokenAttributes *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_Grabbed(enc, &(val)->u.grabbed))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_Inhibited(enc, &(val)->u.inhibited))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_Giving(enc, &(val)->u.giving))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_Ungivable(enc, &(val)->u.ungivable))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_Given(enc, &(val)->u.given))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PDUTokenAttributes(ASN1decoding_t dec, PDUTokenAttributes *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_Grabbed(dec, &(val)->u.grabbed))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_Inhibited(dec, &(val)->u.inhibited))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_Giving(dec, &(val)->u.giving))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_Ungivable(dec, &(val)->u.ungivable))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_Given(dec, &(val)->u.given))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PDUTokenAttributes(PDUTokenAttributes *val)
{
    if (val) {
        switch ((val)->choice) {
        case 2:
            ASN1Free_Inhibited(&(val)->u.inhibited);
            break;
        }
    }
}

static int ASN1CALL ASN1Enc_SetOfUserIDs(ASN1encoding_t enc, PSetOfUserIDs *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfUserIDs_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfUserIDs_ElmFn(ASN1encoding_t enc, PSetOfUserIDs val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfUserIDs(ASN1decoding_t dec, PSetOfUserIDs *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfUserIDs_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfUserIDs_ElmFn(ASN1decoding_t dec, PSetOfUserIDs val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1001;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfUserIDs(PSetOfUserIDs *val)
{
    if (val) {
        ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfUserIDs_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfUserIDs_ElmFn(PSetOfUserIDs val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SetOfPDUChannelAttributes(ASN1encoding_t enc, PSetOfPDUChannelAttributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfPDUChannelAttributes_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfPDUChannelAttributes_ElmFn(ASN1encoding_t enc, PSetOfPDUChannelAttributes val)
{
    if (!ASN1Enc_PDUChannelAttributes(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfPDUChannelAttributes(ASN1decoding_t dec, PSetOfPDUChannelAttributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfPDUChannelAttributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfPDUChannelAttributes_ElmFn(ASN1decoding_t dec, PSetOfPDUChannelAttributes val)
{
    if (!ASN1Dec_PDUChannelAttributes(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfPDUChannelAttributes(PSetOfPDUChannelAttributes *val)
{
    if (val) {
        ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfPDUChannelAttributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfPDUChannelAttributes_ElmFn(PSetOfPDUChannelAttributes val)
{
    if (val) {
        ASN1Free_PDUChannelAttributes(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfChannelIDs(ASN1encoding_t enc, PSetOfChannelIDs *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfChannelIDs_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfChannelIDs_ElmFn(ASN1encoding_t enc, PSetOfChannelIDs val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfChannelIDs(ASN1decoding_t dec, PSetOfChannelIDs *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfChannelIDs_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfChannelIDs_ElmFn(ASN1decoding_t dec, PSetOfChannelIDs val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfChannelIDs(PSetOfChannelIDs *val)
{
    if (val) {
        ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfChannelIDs_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfChannelIDs_ElmFn(PSetOfChannelIDs val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SetOfPDUTokenAttributes(ASN1encoding_t enc, PSetOfPDUTokenAttributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfPDUTokenAttributes_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfPDUTokenAttributes_ElmFn(ASN1encoding_t enc, PSetOfPDUTokenAttributes val)
{
    if (!ASN1Enc_PDUTokenAttributes(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfPDUTokenAttributes(ASN1decoding_t dec, PSetOfPDUTokenAttributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfPDUTokenAttributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfPDUTokenAttributes_ElmFn(ASN1decoding_t dec, PSetOfPDUTokenAttributes val)
{
    if (!ASN1Dec_PDUTokenAttributes(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfPDUTokenAttributes(PSetOfPDUTokenAttributes *val)
{
    if (val) {
        ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfPDUTokenAttributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfPDUTokenAttributes_ElmFn(PSetOfPDUTokenAttributes val)
{
    if (val) {
        ASN1Free_PDUTokenAttributes(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfTokenIDs(ASN1encoding_t enc, PSetOfTokenIDs *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfTokenIDs_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfTokenIDs_ElmFn(ASN1encoding_t enc, PSetOfTokenIDs val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfTokenIDs(ASN1decoding_t dec, PSetOfTokenIDs *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfTokenIDs_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfTokenIDs_ElmFn(ASN1decoding_t dec, PSetOfTokenIDs val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfTokenIDs(PSetOfTokenIDs *val)
{
    if (val) {
        ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfTokenIDs_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfTokenIDs_ElmFn(PSetOfTokenIDs val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MergeTokensRequestPDU(ASN1encoding_t enc, MergeTokensRequestPDU *val)
{
    if (!ASN1Enc_SetOfPDUTokenAttributes(enc, &(val)->merge_tokens))
	return 0;
    if (!ASN1Enc_SetOfTokenIDs(enc, &(val)->purge_token_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MergeTokensRequestPDU(ASN1decoding_t dec, MergeTokensRequestPDU *val)
{
    if (!ASN1Dec_SetOfPDUTokenAttributes(dec, &(val)->merge_tokens))
	return 0;
    if (!ASN1Dec_SetOfTokenIDs(dec, &(val)->purge_token_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MergeTokensRequestPDU(MergeTokensRequestPDU *val)
{
    if (val) {
        ASN1Free_SetOfPDUTokenAttributes(&(val)->merge_tokens);
        ASN1Free_SetOfTokenIDs(&(val)->purge_token_ids);
    }
}

static int ASN1CALL ASN1Enc_MergeTokensConfirmPDU(ASN1encoding_t enc, MergeTokensConfirmPDU *val)
{
    if (!ASN1Enc_SetOfPDUTokenAttributes(enc, &(val)->merge_tokens))
	return 0;
    if (!ASN1Enc_SetOfTokenIDs(enc, &(val)->purge_token_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MergeTokensConfirmPDU(ASN1decoding_t dec, MergeTokensConfirmPDU *val)
{
    if (!ASN1Dec_SetOfPDUTokenAttributes(dec, &(val)->merge_tokens))
	return 0;
    if (!ASN1Dec_SetOfTokenIDs(dec, &(val)->purge_token_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MergeTokensConfirmPDU(MergeTokensConfirmPDU *val)
{
    if (val) {
        ASN1Free_SetOfPDUTokenAttributes(&(val)->merge_tokens);
        ASN1Free_SetOfTokenIDs(&(val)->purge_token_ids);
    }
}

static int ASN1CALL ASN1Enc_PurgeTokenIndicationPDU(ASN1encoding_t enc, PurgeTokenIndicationPDU *val)
{
    if (!ASN1Enc_SetOfTokenIDs(enc, &(val)->purge_token_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PurgeTokenIndicationPDU(ASN1decoding_t dec, PurgeTokenIndicationPDU *val)
{
    if (!ASN1Dec_SetOfTokenIDs(dec, &(val)->purge_token_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PurgeTokenIndicationPDU(PurgeTokenIndicationPDU *val)
{
    if (val) {
        ASN1Free_SetOfTokenIDs(&(val)->purge_token_ids);
    }
}

static int ASN1CALL ASN1Enc_DisconnectProviderUltimatumPDU(ASN1encoding_t enc, DisconnectProviderUltimatumPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 3, (val)->reason))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisconnectProviderUltimatumPDU(ASN1decoding_t dec, DisconnectProviderUltimatumPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->reason))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RejectUltimatumPDU(ASN1encoding_t enc, RejectUltimatumPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->diagnostic))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->initial_octets))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RejectUltimatumPDU(ASN1decoding_t dec, RejectUltimatumPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->diagnostic))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->initial_octets))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RejectUltimatumPDU(RejectUltimatumPDU *val)
{
    if (val) {
        ASN1octetstring_free(&(val)->initial_octets);
    }
}

static int ASN1CALL ASN1Enc_AttachUserConfirmPDU(ASN1encoding_t enc, AttachUserConfirmPDU *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AttachUserConfirmPDU(ASN1decoding_t dec, AttachUserConfirmPDU *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	    return 0;
	(val)->initiator += 1001;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_DetachUserRequestPDU(ASN1encoding_t enc, DetachUserRequestPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 3, (val)->reason))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->user_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DetachUserRequestPDU(ASN1decoding_t dec, DetachUserRequestPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->reason))
	return 0;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->user_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DetachUserRequestPDU(DetachUserRequestPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->user_ids);
    }
}

static int ASN1CALL ASN1Enc_DetachUserIndicationPDU(ASN1encoding_t enc, DetachUserIndicationPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 3, (val)->reason))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->user_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DetachUserIndicationPDU(ASN1decoding_t dec, DetachUserIndicationPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->reason))
	return 0;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->user_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DetachUserIndicationPDU(DetachUserIndicationPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->user_ids);
    }
}

static int ASN1CALL ASN1Enc_ChannelJoinRequestPDU(ASN1encoding_t enc, ChannelJoinRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelJoinRequestPDU(ASN1decoding_t dec, ChannelJoinRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelJoinConfirmPDU(ASN1encoding_t enc, ChannelJoinConfirmPDU *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requested))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->join_channel_id))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelJoinConfirmPDU(ASN1decoding_t dec, ChannelJoinConfirmPDU *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requested))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->join_channel_id))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelLeaveRequestPDU(ASN1encoding_t enc, ChannelLeaveRequestPDU *val)
{
    if (!ASN1Enc_SetOfChannelIDs(enc, &(val)->channel_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelLeaveRequestPDU(ASN1decoding_t dec, ChannelLeaveRequestPDU *val)
{
    if (!ASN1Dec_SetOfChannelIDs(dec, &(val)->channel_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ChannelLeaveRequestPDU(ChannelLeaveRequestPDU *val)
{
    if (val) {
        ASN1Free_SetOfChannelIDs(&(val)->channel_ids);
    }
}

static int ASN1CALL ASN1Enc_ChannelConveneRequestPDU(ASN1encoding_t enc, ChannelConveneRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelConveneRequestPDU(ASN1decoding_t dec, ChannelConveneRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelConveneConfirmPDU(ASN1encoding_t enc, ChannelConveneConfirmPDU *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->convene_channel_id - 1001))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelConveneConfirmPDU(ASN1decoding_t dec, ChannelConveneConfirmPDU *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->convene_channel_id))
	    return 0;
	(val)->convene_channel_id += 1001;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelDisbandRequestPDU(ASN1encoding_t enc, ChannelDisbandRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelDisbandRequestPDU(ASN1decoding_t dec, ChannelDisbandRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelDisbandIndicationPDU(ASN1encoding_t enc, ChannelDisbandIndicationPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelDisbandIndicationPDU(ASN1decoding_t dec, ChannelDisbandIndicationPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelAdmitRequestPDU(ASN1encoding_t enc, ChannelAdmitRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->user_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelAdmitRequestPDU(ASN1decoding_t dec, ChannelAdmitRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->user_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ChannelAdmitRequestPDU(ChannelAdmitRequestPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->user_ids);
    }
}

static int ASN1CALL ASN1Enc_ChannelAdmitIndicationPDU(ASN1encoding_t enc, ChannelAdmitIndicationPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->user_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelAdmitIndicationPDU(ASN1decoding_t dec, ChannelAdmitIndicationPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->user_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ChannelAdmitIndicationPDU(ChannelAdmitIndicationPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->user_ids);
    }
}

static int ASN1CALL ASN1Enc_ChannelExpelRequestPDU(ASN1encoding_t enc, ChannelExpelRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->user_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelExpelRequestPDU(ASN1decoding_t dec, ChannelExpelRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->user_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ChannelExpelRequestPDU(ChannelExpelRequestPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->user_ids);
    }
}

static int ASN1CALL ASN1Enc_ChannelExpelIndicationPDU(ASN1encoding_t enc, ChannelExpelIndicationPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->user_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelExpelIndicationPDU(ASN1decoding_t dec, ChannelExpelIndicationPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->user_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ChannelExpelIndicationPDU(ChannelExpelIndicationPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->user_ids);
    }
}

static int ASN1CALL ASN1Enc_TokenGrabRequestPDU(ASN1encoding_t enc, TokenGrabRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenGrabRequestPDU(ASN1decoding_t dec, TokenGrabRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenGrabConfirmPDU(ASN1encoding_t enc, TokenGrabConfirmPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenGrabConfirmPDU(ASN1decoding_t dec, TokenGrabConfirmPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenInhibitRequestPDU(ASN1encoding_t enc, TokenInhibitRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenInhibitRequestPDU(ASN1decoding_t dec, TokenInhibitRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenInhibitConfirmPDU(ASN1encoding_t enc, TokenInhibitConfirmPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenInhibitConfirmPDU(ASN1decoding_t dec, TokenInhibitConfirmPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenGiveRequestPDU(ASN1encoding_t enc, TokenGiveRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->recipient - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenGiveRequestPDU(ASN1decoding_t dec, TokenGiveRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->recipient))
	return 0;
    (val)->recipient += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenGiveIndicationPDU(ASN1encoding_t enc, TokenGiveIndicationPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->recipient - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenGiveIndicationPDU(ASN1decoding_t dec, TokenGiveIndicationPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->recipient))
	return 0;
    (val)->recipient += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenGiveResponsePDU(ASN1encoding_t enc, TokenGiveResponsePDU *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->recipient - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenGiveResponsePDU(ASN1decoding_t dec, TokenGiveResponsePDU *val)
{
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->recipient))
	return 0;
    (val)->recipient += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenGiveConfirmPDU(ASN1encoding_t enc, TokenGiveConfirmPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenGiveConfirmPDU(ASN1decoding_t dec, TokenGiveConfirmPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenPleaseRequestPDU(ASN1encoding_t enc, TokenPleaseRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenPleaseRequestPDU(ASN1decoding_t dec, TokenPleaseRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenPleaseIndicationPDU(ASN1encoding_t enc, TokenPleaseIndicationPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenPleaseIndicationPDU(ASN1decoding_t dec, TokenPleaseIndicationPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenReleaseRequestPDU(ASN1encoding_t enc, TokenReleaseRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenReleaseRequestPDU(ASN1decoding_t dec, TokenReleaseRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenReleaseConfirmPDU(ASN1encoding_t enc, TokenReleaseConfirmPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenReleaseConfirmPDU(ASN1decoding_t dec, TokenReleaseConfirmPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenTestRequestPDU(ASN1encoding_t enc, TokenTestRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenTestRequestPDU(ASN1decoding_t dec, TokenTestRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenTestConfirmPDU(ASN1encoding_t enc, TokenTestConfirmPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenTestConfirmPDU(ASN1decoding_t dec, TokenTestConfirmPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->token_status))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectMCSPDU(ConnectMCSPDU *val)
{
    if (val) {
        switch ((val)->choice) {
        case 1:
        ASN1Free_ConnectInitialPDU(&(val)->u.connect_initial);
        break;
        case 2:
        ASN1Free_ConnectResponsePDU(&(val)->u.connect_response);
        break;
        }
    }
}

static int ASN1CALL ASN1Enc_DomainMCSPDU(ASN1encoding_t enc, DomainMCSPDU *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_PlumbDomainIndicationPDU(enc, &(val)->u.plumb_domain_indication))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ErectDomainRequestPDU(enc, &(val)->u.erect_domain_request))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_MergeChannelsRequestPDU(enc, &(val)->u.merge_channels_request))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_MergeChannelsConfirmPDU(enc, &(val)->u.merge_channels_confirm))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_PurgeChannelIndicationPDU(enc, &(val)->u.purge_channel_indication))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_MergeTokensRequestPDU(enc, &(val)->u.merge_tokens_request))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_MergeTokensConfirmPDU(enc, &(val)->u.merge_tokens_confirm))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_PurgeTokenIndicationPDU(enc, &(val)->u.purge_token_indication))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_DisconnectProviderUltimatumPDU(enc, &(val)->u.disconnect_provider_ultimatum))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_RejectUltimatumPDU(enc, &(val)->u.reject_user_ultimatum))
	    return 0;
	break;
    case 11:
	break;
    case 12:
	if (!ASN1Enc_AttachUserConfirmPDU(enc, &(val)->u.attach_user_confirm))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_DetachUserRequestPDU(enc, &(val)->u.detach_user_request))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_DetachUserIndicationPDU(enc, &(val)->u.detach_user_indication))
	    return 0;
	break;
    case 15:
	if (!ASN1Enc_ChannelJoinRequestPDU(enc, &(val)->u.channel_join_request))
	    return 0;
	break;
    case 16:
	if (!ASN1Enc_ChannelJoinConfirmPDU(enc, &(val)->u.channel_join_confirm))
	    return 0;
	break;
    case 17:
	if (!ASN1Enc_ChannelLeaveRequestPDU(enc, &(val)->u.channel_leave_request))
	    return 0;
	break;
    case 18:
	if (!ASN1Enc_ChannelConveneRequestPDU(enc, &(val)->u.channel_convene_request))
	    return 0;
	break;
    case 19:
	if (!ASN1Enc_ChannelConveneConfirmPDU(enc, &(val)->u.channel_convene_confirm))
	    return 0;
	break;
    case 20:
	if (!ASN1Enc_ChannelDisbandRequestPDU(enc, &(val)->u.channel_disband_request))
	    return 0;
	break;
    case 21:
	if (!ASN1Enc_ChannelDisbandIndicationPDU(enc, &(val)->u.channel_disband_indication))
	    return 0;
	break;
    case 22:
	if (!ASN1Enc_ChannelAdmitRequestPDU(enc, &(val)->u.channel_admit_request))
	    return 0;
	break;
    case 23:
	if (!ASN1Enc_ChannelAdmitIndicationPDU(enc, &(val)->u.channel_admit_indication))
	    return 0;
	break;
    case 24:
	if (!ASN1Enc_ChannelExpelRequestPDU(enc, &(val)->u.channel_expel_request))
	    return 0;
	break;
    case 25:
	if (!ASN1Enc_ChannelExpelIndicationPDU(enc, &(val)->u.channel_expel_indication))
	    return 0;
	break;
    case 26:
    case 27:
    case 28:
    case 29:
        return 0;
    case 30:
	if (!ASN1Enc_TokenGrabRequestPDU(enc, &(val)->u.token_grab_request))
	    return 0;
	break;
    case 31:
	if (!ASN1Enc_TokenGrabConfirmPDU(enc, &(val)->u.token_grab_confirm))
	    return 0;
	break;
    case 32:
	if (!ASN1Enc_TokenInhibitRequestPDU(enc, &(val)->u.token_inhibit_request))
	    return 0;
	break;
    case 33:
	if (!ASN1Enc_TokenInhibitConfirmPDU(enc, &(val)->u.token_inhibit_confirm))
	    return 0;
	break;
    case 34:
	if (!ASN1Enc_TokenGiveRequestPDU(enc, &(val)->u.token_give_request))
	    return 0;
	break;
    case 35:
	if (!ASN1Enc_TokenGiveIndicationPDU(enc, &(val)->u.token_give_indication))
	    return 0;
	break;
    case 36:
	if (!ASN1Enc_TokenGiveResponsePDU(enc, &(val)->u.token_give_response))
	    return 0;
	break;
    case 37:
	if (!ASN1Enc_TokenGiveConfirmPDU(enc, &(val)->u.token_give_confirm))
	    return 0;
	break;
    case 38:
	if (!ASN1Enc_TokenPleaseRequestPDU(enc, &(val)->u.token_please_request))
	    return 0;
	break;
    case 39:
	if (!ASN1Enc_TokenPleaseIndicationPDU(enc, &(val)->u.token_please_indication))
	    return 0;
	break;
    case 40:
	if (!ASN1Enc_TokenReleaseRequestPDU(enc, &(val)->u.token_release_request))
	    return 0;
	break;
    case 41:
	if (!ASN1Enc_TokenReleaseConfirmPDU(enc, &(val)->u.token_release_confirm))
	    return 0;
	break;
    case 42:
	if (!ASN1Enc_TokenTestRequestPDU(enc, &(val)->u.token_test_request))
	    return 0;
	break;
    case 43:
	if (!ASN1Enc_TokenTestConfirmPDU(enc, &(val)->u.token_test_confirm))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DomainMCSPDU(ASN1decoding_t dec, DomainMCSPDU *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_PlumbDomainIndicationPDU(dec, &(val)->u.plumb_domain_indication))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ErectDomainRequestPDU(dec, &(val)->u.erect_domain_request))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_MergeChannelsRequestPDU(dec, &(val)->u.merge_channels_request))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_MergeChannelsConfirmPDU(dec, &(val)->u.merge_channels_confirm))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_PurgeChannelIndicationPDU(dec, &(val)->u.purge_channel_indication))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_MergeTokensRequestPDU(dec, &(val)->u.merge_tokens_request))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_MergeTokensConfirmPDU(dec, &(val)->u.merge_tokens_confirm))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_PurgeTokenIndicationPDU(dec, &(val)->u.purge_token_indication))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_DisconnectProviderUltimatumPDU(dec, &(val)->u.disconnect_provider_ultimatum))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_RejectUltimatumPDU(dec, &(val)->u.reject_user_ultimatum))
	    return 0;
	break;
    case 11:
	break;
    case 12:
	if (!ASN1Dec_AttachUserConfirmPDU(dec, &(val)->u.attach_user_confirm))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_DetachUserRequestPDU(dec, &(val)->u.detach_user_request))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_DetachUserIndicationPDU(dec, &(val)->u.detach_user_indication))
	    return 0;
	break;
    case 15:
	if (!ASN1Dec_ChannelJoinRequestPDU(dec, &(val)->u.channel_join_request))
	    return 0;
	break;
    case 16:
	if (!ASN1Dec_ChannelJoinConfirmPDU(dec, &(val)->u.channel_join_confirm))
	    return 0;
	break;
    case 17:
	if (!ASN1Dec_ChannelLeaveRequestPDU(dec, &(val)->u.channel_leave_request))
	    return 0;
	break;
    case 18:
	if (!ASN1Dec_ChannelConveneRequestPDU(dec, &(val)->u.channel_convene_request))
	    return 0;
	break;
    case 19:
	if (!ASN1Dec_ChannelConveneConfirmPDU(dec, &(val)->u.channel_convene_confirm))
	    return 0;
	break;
    case 20:
	if (!ASN1Dec_ChannelDisbandRequestPDU(dec, &(val)->u.channel_disband_request))
	    return 0;
	break;
    case 21:
	if (!ASN1Dec_ChannelDisbandIndicationPDU(dec, &(val)->u.channel_disband_indication))
	    return 0;
	break;
    case 22:
	if (!ASN1Dec_ChannelAdmitRequestPDU(dec, &(val)->u.channel_admit_request))
	    return 0;
	break;
    case 23:
	if (!ASN1Dec_ChannelAdmitIndicationPDU(dec, &(val)->u.channel_admit_indication))
	    return 0;
	break;
    case 24:
	if (!ASN1Dec_ChannelExpelRequestPDU(dec, &(val)->u.channel_expel_request))
	    return 0;
	break;
    case 25:
	if (!ASN1Dec_ChannelExpelIndicationPDU(dec, &(val)->u.channel_expel_indication))
	    return 0;
	break;
    case 26:
    case 27:
    case 28:
    case 29:
        return 0;
    case 30:
	if (!ASN1Dec_TokenGrabRequestPDU(dec, &(val)->u.token_grab_request))
	    return 0;
	break;
    case 31:
	if (!ASN1Dec_TokenGrabConfirmPDU(dec, &(val)->u.token_grab_confirm))
	    return 0;
	break;
    case 32:
	if (!ASN1Dec_TokenInhibitRequestPDU(dec, &(val)->u.token_inhibit_request))
	    return 0;
	break;
    case 33:
	if (!ASN1Dec_TokenInhibitConfirmPDU(dec, &(val)->u.token_inhibit_confirm))
	    return 0;
	break;
    case 34:
	if (!ASN1Dec_TokenGiveRequestPDU(dec, &(val)->u.token_give_request))
	    return 0;
	break;
    case 35:
	if (!ASN1Dec_TokenGiveIndicationPDU(dec, &(val)->u.token_give_indication))
	    return 0;
	break;
    case 36:
	if (!ASN1Dec_TokenGiveResponsePDU(dec, &(val)->u.token_give_response))
	    return 0;
	break;
    case 37:
	if (!ASN1Dec_TokenGiveConfirmPDU(dec, &(val)->u.token_give_confirm))
	    return 0;
	break;
    case 38:
	if (!ASN1Dec_TokenPleaseRequestPDU(dec, &(val)->u.token_please_request))
	    return 0;
	break;
    case 39:
	if (!ASN1Dec_TokenPleaseIndicationPDU(dec, &(val)->u.token_please_indication))
	    return 0;
	break;
    case 40:
	if (!ASN1Dec_TokenReleaseRequestPDU(dec, &(val)->u.token_release_request))
	    return 0;
	break;
    case 41:
	if (!ASN1Dec_TokenReleaseConfirmPDU(dec, &(val)->u.token_release_confirm))
	    return 0;
	break;
    case 42:
	if (!ASN1Dec_TokenTestRequestPDU(dec, &(val)->u.token_test_request))
	    return 0;
	break;
    case 43:
	if (!ASN1Dec_TokenTestConfirmPDU(dec, &(val)->u.token_test_confirm))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DomainMCSPDU(DomainMCSPDU *val)
{
    if (val) {
        switch ((val)->choice) {
        case 3:
        ASN1Free_MergeChannelsRequestPDU(&(val)->u.merge_channels_request);
        break;
        case 4:
        ASN1Free_MergeChannelsConfirmPDU(&(val)->u.merge_channels_confirm);
        break;
        case 5:
        ASN1Free_PurgeChannelIndicationPDU(&(val)->u.purge_channel_indication);
        break;
        case 6:
        ASN1Free_MergeTokensRequestPDU(&(val)->u.merge_tokens_request);
        break;
        case 7:
        ASN1Free_MergeTokensConfirmPDU(&(val)->u.merge_tokens_confirm);
        break;
        case 8:
        ASN1Free_PurgeTokenIndicationPDU(&(val)->u.purge_token_indication);
        break;
        case 10:
        ASN1Free_RejectUltimatumPDU(&(val)->u.reject_user_ultimatum);
        break;
        case 13:
        ASN1Free_DetachUserRequestPDU(&(val)->u.detach_user_request);
        break;
        case 14:
        ASN1Free_DetachUserIndicationPDU(&(val)->u.detach_user_indication);
        break;
        case 17:
        ASN1Free_ChannelLeaveRequestPDU(&(val)->u.channel_leave_request);
        break;
        case 22:
        ASN1Free_ChannelAdmitRequestPDU(&(val)->u.channel_admit_request);
        break;
        case 23:
        ASN1Free_ChannelAdmitIndicationPDU(&(val)->u.channel_admit_indication);
        break;
        case 24:
        ASN1Free_ChannelExpelRequestPDU(&(val)->u.channel_expel_request);
        break;
        case 25:
        ASN1Free_ChannelExpelIndicationPDU(&(val)->u.channel_expel_indication);
        break;
        case 26:
        case 27:
        case 28:
        case 29:
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\invoklst.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	invoklst.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class
 *		CInvokeSpecifierListContainer.  This class manages the data associated
 *		with an Application Invoke Request or Indication.  This includes a list
 *		of applications to be invoked.  The CInvokeSpecifierListContainer data
 *		container utilizes a CSessKeyContainer container to buffer part of the data
 *		associated with each application invoke specifier.  Each application
 *		invoke specifier also includes a capability ID whose data is buffered
 *		internally by the using a CCapIDContainer container.  The list
 *		of application invoke specifiers is maintained internally by the class
 *		through the use of a Rogue Wave list container.
 *
 *	Protected Instance Variables:
 *		m_InvokeSpecifierList
 *			List of structures used to hold the container data internally.
 *		m_pAPEListPDU
 *			Storage for the "PDU" form of the invoke data.
 *		m_fValidAPEListPDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" invoke data.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */

#include "ms_util.h"
#include "invoklst.h"

/*
 *	CInvokeSpecifierListContainer ()
 *
 *	Public Function Description:
 *		This constructor is used to create an CInvokeSpecifierListContainer
 * 		object from a list of "API" application protocol entities.
 */
CInvokeSpecifierListContainer::CInvokeSpecifierListContainer(	
						UINT						number_of_protocol_entities,
						PGCCAppProtocolEntity *	 	app_protocol_entity_list,
						PGCCError					pRetCode)
:
    CRefCount(MAKE_STAMP_ID('I','S','L','C')),
    m_fValidAPEListPDU(FALSE),
    m_cbDataSize(0)
{
	UINT					i;
	PGCCAppProtocolEntity	ape;
	INVOKE_SPECIFIER        *specifier_info;

	/*
	 * Initialize instance variables.
	 */
	GCCError rc = GCC_NO_ERROR;

	/*
	 * Go through the list of application protocol entities (APE's), saving the
	 * necessary information in the internal list of info. structures.
	 */
	for (i = 0; i < number_of_protocol_entities; i++)
	{
		/*
		 * Create a new INVOKE_SPECIFIER structure to hold the data for this
		 * APE.  Check to make sure it was successfully created.
		 */
		DBG_SAVE_FILE_LINE
		specifier_info = new INVOKE_SPECIFIER;
		if (specifier_info != NULL)
		{
			/*
			 * Get the APE from the list.
			 */
			ape = app_protocol_entity_list[i];

			/*
			 * Create a new CSessKeyContainer object to hold the session key.
			 * Check to	make sure construction was successful.
			 */
			DBG_SAVE_FILE_LINE
			specifier_info->session_key = new CSessKeyContainer(&ape->session_key, &rc);
			if ((specifier_info->session_key != NULL) && (rc == GCC_NO_ERROR))
			{
				/*
				 * Save the startup channel type and "invoke" flag.
				 */
				specifier_info->startup_channel_type =ape->startup_channel_type;
				specifier_info->must_be_invoked = ape->must_be_invoked;

				/*
				 * Save the capabilities list for this APE in the internal info.
				 * structure.
				 */
				rc = SaveAPICapabilities(specifier_info,
										ape->number_of_expected_capabilities,
										ape->expected_capabilities_list);

				/*
				 * Insert the new invoke specifier info structure pointer into
				 * the internal list if no error condition exists.
				 */
				if (rc == GCC_NO_ERROR)
				{
					m_InvokeSpecifierList.Append(specifier_info);
				}
				else
				{
					ERROR_OUT(("CInvokeSpecifierListContainer::Construc1: Error saving caps"));
					break;
				}
			}
			else if (specifier_info->session_key == NULL)
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::Construc1: Error creating CSessKeyContainer"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
			else
			{
				break;
			}
		}
		else
		{
			ERROR_OUT(("CInvokeSpecifierListContainer::Construc1: Error creating INVOKE_SPECIFIER"));
			break;
		}
	}

	if(rc != GCC_NO_ERROR)
	{
		if(specifier_info)
		{
			ERROR_OUT(("CInvokeSpecifierListContainer::Construc1: Error creating CSessKeyContainer"));
			if(specifier_info->session_key)
			{
				specifier_info->session_key->Release();
			}
			delete specifier_info;
		}
	}

	*pRetCode = rc;
}

/*
 *	CInvokeSpecifierListContainer ()
 *
 *	Public Function Description:
 *		This constructor is used to create an CInvokeSpecifierListContainer
 *		object from	a "PDU" ApplicationProtocolEntityList.
 */
CInvokeSpecifierListContainer::CInvokeSpecifierListContainer (
					PApplicationProtocolEntityList	 	protocol_entity_list,
					PGCCError							pRetCode)
:
    CRefCount(MAKE_STAMP_ID('I','S','L','C')),
    m_fValidAPEListPDU(FALSE),
    m_cbDataSize(0)
{
    ApplicationInvokeSpecifier      specifier;
    INVOKE_SPECIFIER                *specifier_info;

    GCCError rc = GCC_NO_ERROR;

    while (protocol_entity_list != NULL)
    {
        /*
         * Create a new INVOKE_SPECIFIER structure to hold the data for this
         * APE.  Check to make sure it was successfully created.
         */
        DBG_SAVE_FILE_LINE
        specifier_info = new INVOKE_SPECIFIER;
        if (specifier_info != NULL)
        {
            specifier = protocol_entity_list->value;

            /*
             * Create a CSessKeyContainer object to hold the session key
             * internally.  Check to make sure the object is successfully
             * created.
             */
            DBG_SAVE_FILE_LINE
            specifier_info->session_key = new CSessKeyContainer(&specifier.session_key, &rc);
            if ((specifier_info->session_key != NULL) && (rc == GCC_NO_ERROR))
            {
                /*
                 * The session key was saved correctly so check to see if a list
                 * of expected capabilities is present and save them if so.
                 */
                if (specifier.bit_mask & EXPECTED_CAPABILITY_SET_PRESENT)
                {
                    rc = SavePDUCapabilities(specifier_info, specifier.expected_capability_set);
                    if (rc != GCC_NO_ERROR)
                    {
                        specifier_info->session_key->Release();
                        specifier_info->ExpectedCapItemList.DeleteList();
                        delete specifier_info;
                        break;
                    }
                }

                /*
                 * Save the startup channel type.  If the channel type is not
                 * present in the PDU then set the channel type in the info
                 * strucuture equal to MCS_NO_CHANNEL_TYPE_SPECIFIED;
                 */
                if (specifier.bit_mask & INVOKE_STARTUP_CHANNEL_PRESENT)
                {
                    switch (specifier.invoke_startup_channel)
                    {
                    case CHANNEL_TYPE_STATIC:
                        specifier_info->startup_channel_type = MCS_STATIC_CHANNEL;
                        break;
                    case DYNAMIC_MULTICAST:
                        specifier_info->startup_channel_type = MCS_DYNAMIC_MULTICAST_CHANNEL;
                        break;
                    case DYNAMIC_PRIVATE:
                        specifier_info->startup_channel_type = MCS_DYNAMIC_PRIVATE_CHANNEL;
                        break;
                    case DYNAMIC_USER_ID:
                        specifier_info->startup_channel_type = MCS_DYNAMIC_USER_ID_CHANNEL;
                        break;
                    }
                }
                else
                {
                    specifier_info->startup_channel_type = MCS_NO_CHANNEL_TYPE_SPECIFIED;
                }

                /*
                 * Insert the new invoke specifier info structure pointer into
                 * the internal list if no error condition exists.
                 */
                m_InvokeSpecifierList.Append(specifier_info);
            }
            else if (specifier_info->session_key == NULL)
            {
                ERROR_OUT(("CInvokeSpecifierListContainer::Construc2: Error creating CSessKeyContainer"));
                rc = GCC_ALLOCATION_FAILURE;
                break;
            }
            else
            {
                ERROR_OUT(("CInvokeSpecifierListContainer::Construc2: Error creating CSessKeyContainer"));
                break;
            }

            /*
             * Retrieve the next APE in the list.
             */
            protocol_entity_list = protocol_entity_list->next;
        }
        else
        {
            ERROR_OUT(("CInvokeSpecifierListContainer::Construc2: Error creating INVOKE_SPECIFIER"));
            break;
        }
    }

    if(rc != GCC_NO_ERROR && specifier_info != NULL)
    {
            if(specifier_info->session_key != NULL)
            {
                specifier_info->session_key->Release();
            }

            specifier_info->ExpectedCapItemList.DeleteList();
            delete specifier_info;
    }

    *pRetCode = rc;
}

/*
 *	~CInvokeSpecifierListContainer	()
 *
 *	Public Function Description
 *		The CInvokeSpecifierListContainer destructor is responsible for
 *		freeing any memory allocated to hold the invoke data.
 *
 */
CInvokeSpecifierListContainer::~CInvokeSpecifierListContainer(void)
{
	INVOKE_SPECIFIER *lpInvSpecInfo;

    /*
	 * If "PDU" data has been allocated for this object, free it now.
	 */
	if (m_fValidAPEListPDU)
		FreeApplicationInvokeSpecifierListPDU ();

	/*
	 * Delete any data containers held internally in the list of info.
	 * structures by iterating through the internal list.
	 */
	m_InvokeSpecifierList.Reset();
 	while (NULL != (lpInvSpecInfo = m_InvokeSpecifierList.Iterate()))
	{
		/*
		 * Delete any CSessKeyContainer objects in the INVOKE_SPECIFIER list.
		 */
		if (NULL != lpInvSpecInfo->session_key)
		{
		    lpInvSpecInfo->session_key->Release();
		}

		/*
		 * Iterate through the capabilities list held in the INVOKE_SPECIFIER
		 * structure.
		 */
		lpInvSpecInfo->ExpectedCapItemList.DeleteList();

		/*
		 * Delete the INVOKE_SPECIFIER structure.
		 */
		delete lpInvSpecInfo;
	}
}

/*
 *	LockApplicationInvokeSpecifierList ()
 *
 *	Public Function Description:
 *		This routine locks the invoke specifier data and determines the amount
 *		of memory necessary to hold the associated data.
 */
UINT CInvokeSpecifierListContainer::LockApplicationInvokeSpecifierList(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of
	 * the memory required to hold the data for the application invoke
	 * specifier.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		INVOKE_SPECIFIER            *lpInvSpecInfo;
		APP_CAP_ITEM                *pExpCapData;

		/*
		 * Set aside memory to hold the pointers to the GCCAppProtocolEntity
		 * structures as well as the structures themselves.  The "sizeof" the
		 * structure must be rounded to an even four-byte boundary.
		 */
		m_cbDataSize = m_InvokeSpecifierList.GetCount() *
				(sizeof(PGCCAppProtocolEntity) + ROUNDTOBOUNDARY(sizeof(GCCAppProtocolEntity)));

		m_InvokeSpecifierList.Reset();
	 	while (NULL != (lpInvSpecInfo = m_InvokeSpecifierList.Iterate()))
		{
			/*
			 * Lock the data for the session keys, adding the amount of memory
			 * necessary to hold the session key data to the total memory size.
			 */
			m_cbDataSize += lpInvSpecInfo->session_key->LockSessionKeyData();

			lpInvSpecInfo->ExpectedCapItemList.Reset();

			/*
			 * Set aside memory to hold the pointers to the
			 * GCCApplicationCabability	structures as well as the structures
			 * themselves.  The "sizeof" the structure must be rounded to an
			 * even four-byte boundary.
			 */
			m_cbDataSize += lpInvSpecInfo->ExpectedCapItemList.GetCount() *
					( sizeof(PGCCApplicationCapability) + ROUNDTOBOUNDARY (sizeof(GCCApplicationCapability)) );

			/*
			 * Lock the data for the capability ID's, adding the amount of
			 * memory necessary to hold the capability ID data to the total
			 * memory size.
			 */
			while (NULL != (pExpCapData = lpInvSpecInfo->ExpectedCapItemList.Iterate()))
			{
				m_cbDataSize += pExpCapData->pCapID->LockCapabilityIdentifierData();
			}
		}
	}

	return m_cbDataSize;
}

/*
 *	GetApplicationInvokeSpecifierList ()
 *
 *	Public Function Description:
 *		This routine retrieves the invoke specifier data in the form of a
 *		list of application protocol entities which are written into the memory
 *		provided.  This routine is called after "locking" the data.
 */
UINT CInvokeSpecifierListContainer::GetApplicationInvokeSpecifierList(
									USHORT		*number_of_protocol_entities,
									LPBYTE		memory)
{
	PGCCAppProtocolEntity *			ape_list_ptr;
	PGCCAppProtocolEntity 			ape_ptr;
	PGCCApplicationCapability 		capability_ptr;
	UINT							data_length = 0;
	Int								ape_counter = 0;
	Int								capability_counter = 0;
	UINT							cbDataSizeToRet = 0;
	INVOKE_SPECIFIER                *lpInvSpecInfo;
	APP_CAP_ITEM                    *pExpCapData;
	
	/*
	 * If the object has been locked, fill in the output structure and
	 * the data referenced by the structure.  Otherwise, report that the object
	 * key has yet to be locked into the "API" form.
	 */
	if (GetLockCount() > 0)
	{
		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.  This value was
		 * calculated on the call to "Lock".
		 */
		cbDataSizeToRet = m_cbDataSize;

		/*
		 * Fill in the number of protocol entities and save a pointer to
		 * the memory location passed in.  This is where the pointers to
		 * the GCCAppProtocolEntity	structures will be written.  The actual
		 * structures will be written into memory immediately following the list
		 * of pointers.
		 */
		*number_of_protocol_entities = (USHORT) m_InvokeSpecifierList.GetCount();

		ape_list_ptr = (PGCCAppProtocolEntity *)memory;

		/*
		 * Save the amount of memory needed to hold the list of structure
		 * pointers.
		 */
		data_length = m_InvokeSpecifierList.GetCount() * sizeof(PGCCAppProtocolEntity);

		/*
		 * Move the memory pointer past the list of APE pointers.  This is where
		 * thefirst APE structure will be written.
		 */
		memory += data_length;

		/*
		 * Iterate through the internal list of INVOKE_SPECIFIER structures,
		 * building "API" GCCAppProtocolEntity structures in memory.
		 */
		m_InvokeSpecifierList.Reset();
	 	while (NULL != (lpInvSpecInfo = m_InvokeSpecifierList.Iterate()))
		{
			/*
			 * Save the pointer to the APE structure in the list of pointers.
			 */
			ape_ptr = (PGCCAppProtocolEntity)memory;
			ape_list_ptr[ape_counter++] = ape_ptr;

			/*
			 * Move the memory pointer past the APE structure.  This is where
			 * thesession key data will be written.
			 */
			memory += ROUNDTOBOUNDARY(sizeof(GCCAppProtocolEntity));

			/*
			 * Fill in the APE structure starting with the session key.
			 */
			data_length = lpInvSpecInfo->session_key->GetGCCSessionKeyData(&ape_ptr->session_key, memory);

			/*
			 * Move the memory pointer past the session key data.  This is
			 * where the list of pointers to the GCCApplicationCapability
			 * structures will be written so save the pointer in the APE
			 * structure's capabilities list pointer.
			 */
			memory += data_length;

			ape_ptr->expected_capabilities_list = (PGCCApplicationCapability *)memory;

			/*
			 * Go ahead and fill in the APE's channel type and invoke flag.
			 */
			ape_ptr->must_be_invoked = lpInvSpecInfo->must_be_invoked;
			ape_ptr->startup_channel_type = lpInvSpecInfo->startup_channel_type;
			ape_ptr->number_of_expected_capabilities = (USHORT) lpInvSpecInfo->ExpectedCapItemList.GetCount();

			/*
			 * Move the memory pointer past the list of GCCApplicationCapability
			 * pointers.  This is where the first GCCApplicationCapability
			 * structure will be written.
			 */
			memory += (lpInvSpecInfo->ExpectedCapItemList.GetCount() *
					    sizeof(PGCCApplicationCapability));

			/*
			 * Iterate through the list of capabilities, writing the
			 * GCCApplicationCapability structures into memory.
			 */
			capability_counter = 0;
			lpInvSpecInfo->ExpectedCapItemList.Reset();
			while (NULL != (pExpCapData = lpInvSpecInfo->ExpectedCapItemList.Iterate()))
			{
				/*
				 * Save the pointer to the capability structure in the list of
				 * pointers.  Move the memory pointer past the capability
				 * structure.  This is where the data associated with the
				 * capability ID will be written.
				 */
				capability_ptr = (PGCCApplicationCapability)memory;
				ape_ptr->expected_capabilities_list[capability_counter++] = capability_ptr;

				memory += ROUNDTOBOUNDARY(sizeof(GCCApplicationCapability));

				/*
				 * Fill in the capability structure and add the amount of data
				 * written into memory to the total data length.
				 */
				data_length = GetApplicationCapability(pExpCapData, capability_ptr, memory);

				/*
				 * Move the	memory pointer past the capability data.
				 */
				memory += data_length;
			}
		}
	}
	else
	{
		number_of_protocol_entities = 0;
		ERROR_OUT(("CInvokeSpecifierListContainer::GetAppInvokeSpecList: Error Data Not Locked"));
	}

	return cbDataSizeToRet;
}

/*
 *	UnLockApplicationInvokeSpecifierList ()
 *
 *	Public Function Description:
 *		This routine decrements the lock count and frees the memory associated
 *		with the "API" invoke specifier list once the lock count reaches zero.
 */
void CInvokeSpecifierListContainer::UnLockApplicationInvokeSpecifierList(void)
{
	if (Unlock(FALSE) == 0)
	{
		INVOKE_SPECIFIER            *lpInvSpecInfo;
		APP_CAP_ITEM                *pExpCapData;

		/*
		 * Unlock any container data held internally in the list of info.
		 * structures by iterating through the internal list.
		 */
		m_InvokeSpecifierList.Reset();
	 	while (NULL != (lpInvSpecInfo = m_InvokeSpecifierList.Iterate()))
		{
			/*
			 * Unlock any CSessKeyContainer objects.
			 */
			lpInvSpecInfo->session_key->UnLockSessionKeyData();

			/*
			 * Iterate through the capabilities list held in the
			 * INVOKE_SPECIFIER structure.
			 */
			lpInvSpecInfo->ExpectedCapItemList.Reset();
			while (NULL != (pExpCapData = lpInvSpecInfo->ExpectedCapItemList.Iterate()))
			{
				/*
				 * Unlock the CCapIDContainer objects.
				 */
				pExpCapData->pCapID->UnLockCapabilityIdentifierData();
			}
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}


/*
 *	GetApplicationInvokeSpecifierListPDU ()
 *
 *	Public Function Description:
 *		This routine retrieves the "PDU" form of an
 * 		ApplicationProtocolEntityList.
 */
GCCError CInvokeSpecifierListContainer::GetApplicationInvokeSpecifierListPDU(
								PApplicationProtocolEntityList	*protocol_entity_list)
{
	GCCError								rc = GCC_NO_ERROR;
	PApplicationProtocolEntityList			new_pdu_ape_list_ptr;
	PApplicationProtocolEntityList			old_pdu_ape_list_ptr = NULL;
	
	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the input parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * input parameter.
	 */
	if (m_fValidAPEListPDU == FALSE)
	{
		INVOKE_SPECIFIER *lpInvSpecInfo;

		m_fValidAPEListPDU = TRUE;

		/*
		 * Initialize the output parameter to NULL so that the first time
		 * through the loop it will be set equal to the first new APE list
		 * created in the iterator loop.
		 */
		m_pAPEListPDU = NULL;

		/*
		 * Iterate through the list of "INVOKE_SPECIFIER" structures,
		 * converting each into "PDU" form and saving the pointers in the
		 * "ApplicationProtocolEntityList" which is a linked list of
		 * "ApplicationInvokeSpecifiers".
		 */
		m_InvokeSpecifierList.Reset();
	 	while (NULL != (lpInvSpecInfo = m_InvokeSpecifierList.Iterate()))
		{
			DBG_SAVE_FILE_LINE
			new_pdu_ape_list_ptr = new ApplicationProtocolEntityList;

			/*
			 * If an allocation failure occurs, call the routine which will
			 * iterate through the list freeing any data which had been
			 * allocated.
			 */
			if (new_pdu_ape_list_ptr == NULL)
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::GetApplicationInvokeSpecifierListPDU: can't allocate ApplicationProtocolEntityList"));
				rc = GCC_ALLOCATION_FAILURE;
				FreeApplicationInvokeSpecifierListPDU ();
				break;
			}

			/*
			 * The first time through, set the PDU structure pointer equal
			 * to the first ApplicationProtocolEntityList created.  On
			 * subsequent loops, set the structure's "next" pointer equal to
			 * the new structure.
			 */
			if (m_pAPEListPDU == NULL)
			{
				m_pAPEListPDU = new_pdu_ape_list_ptr;
			}
			else
			{
				old_pdu_ape_list_ptr->next = new_pdu_ape_list_ptr;
			}

			old_pdu_ape_list_ptr = new_pdu_ape_list_ptr;

			/*
			 * Initialize the new "next" pointer to NULL.
			 */
			new_pdu_ape_list_ptr->next = NULL;

			if (ConvertInvokeSpecifierInfoToPDU (lpInvSpecInfo, new_pdu_ape_list_ptr) !=
																		GCC_NO_ERROR)
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::GetApplicationInvokeSpecifierListPDU: can't convert UserDataInfo to PDU"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * input parameter.
	 */
	*protocol_entity_list = m_pAPEListPDU;

	return rc;
}

/*
 *	FreeApplicationInvokeSpecifierListPDU ()
 *
 *	Public Function Description:
 *		This routine is used to free the invoke specifier data held internally
 *		in the "PDU" form of a "ApplicationProtocolEntityList".
 */
void CInvokeSpecifierListContainer::FreeApplicationInvokeSpecifierListPDU(void)
{
	PApplicationProtocolEntityList  pCurr, pNext;
	INVOKE_SPECIFIER                *lpInvSpecInfo;
	APP_CAP_ITEM                    *pExpCapData;

	if (m_pAPEListPDU != NULL)
	{
		m_fValidAPEListPDU = FALSE;

		/*
		 * Loop through the list, freeing the data associated with
		 * each structure contained in the list.
		 */
        for (pCurr = m_pAPEListPDU; NULL != pCurr; pCurr = pNext)
        {
            pNext = pCurr->next;
            delete pCurr;
		}
	}

	/*
	 * Iterate through the internal list, telling each data container object
	 * to free any PDU data which it has allocated.
	 */
	m_InvokeSpecifierList.Reset();
	while (NULL != (lpInvSpecInfo = m_InvokeSpecifierList.Iterate()))
	{
		if (lpInvSpecInfo->session_key != NULL)
        {
			lpInvSpecInfo->session_key->FreeSessionKeyDataPDU();
        }

		/*
		 * Iterate through the
		 * list, freeing the PDU data for the capability ID's.
		 */
		lpInvSpecInfo->ExpectedCapItemList.Reset();
		while (NULL != (pExpCapData = lpInvSpecInfo->ExpectedCapItemList.Iterate()))
		{
			pExpCapData->pCapID->FreeCapabilityIdentifierDataPDU();
		}
	}
}

/*
 *	GCCError	CInvokeSpecifierListContainer::SaveAPICapabilities (
 *						INVOKE_SPECIFIER                *invoke_specifier,
 *						UINT							number_of_capabilities,
 *						PGCCApplicationCapability	* 	capabilities_list)
 *
 *	Private member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 * 		This routine is used to save the list of application capabilities passed
 * 		in as "API" data in the internal list of expected capability data
 *		which is held in the internal info structure.
 *
 *	Formal Parameters:
 *		invoke_specifier		(i) Internal structure used to hold invoke data.
 *		number_of_capabilities	(i) Number of capabilities in list.
 *		capabilities_list		(i) List of API capabilities to save.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CInvokeSpecifierListContainer::SaveAPICapabilities(
						INVOKE_SPECIFIER                *invoke_specifier,
						UINT							number_of_capabilities,
						PGCCApplicationCapability	* 	capabilities_list)
{
	GCCError		rc = GCC_NO_ERROR;
	APP_CAP_ITEM    *pExpCapData;
	UINT			i;

	for (i = 0; i < number_of_capabilities; i++)
	{
		/*
		 * For each capability, create an APP_CAP_ITEM structure
		 * to hold all the necessary data.  This structure will be inserted into
		 * the list held by the internal info. structure.
		 */
		DBG_SAVE_FILE_LINE
		pExpCapData = new APP_CAP_ITEM((GCCCapabilityType) capabilities_list[i]->capability_class.eType);
		if (pExpCapData != NULL)
		{
			/*
			 * Create a new CCapIDContainer object to hold the
			 * identifier data.
			 */
			DBG_SAVE_FILE_LINE
			pExpCapData->pCapID = new CCapIDContainer(&capabilities_list[i]->capability_id, &rc);
			if ((pExpCapData->pCapID != NULL) && (rc == GCC_NO_ERROR))
			{
				/*
				 * The identifier object was successfully created so fill in the
				 * rest of the ApplicationCapabilityData structure.
				 */
                switch (pExpCapData->eCapType)
                {
                case GCC_UNSIGNED_MINIMUM_CAPABILITY:
					pExpCapData->nUnsignedMinimum = capabilities_list[i]->capability_class.nMinOrMax;
                    break;
                case GCC_UNSIGNED_MAXIMUM_CAPABILITY:
					pExpCapData->nUnsignedMaximum = capabilities_list[i]->capability_class.nMinOrMax;
                    break;
				}

				/*
				 * Add this expected capability to the list.
				 */
				invoke_specifier->ExpectedCapItemList.Append(pExpCapData);
			}
			else
            {
				delete pExpCapData;
				rc = GCC_ALLOCATION_FAILURE;
                break;
			}
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
            break;
        }
	}

	return rc;
}

/*
 *	GCCError	CInvokeSpecifierListContainer::SavePDUCapabilities (
 *						INVOKE_SPECIFIER                *invoke_specifier,
 *						PSetOfExpectedCapabilities	 	capabilities_set)
 *
 *	Private member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 * 		This routine is used to save the list of application capabilities passed
 * 		in as "PDU" data in the internal list of expected capability data
 *		which is held in the internal info. structure.
 *
 *	Formal Parameters:
 *		invoke_specifier		(i) Internal structure used to hold invoke data.
 *		capabilities_set		(i) List of PDU capabilities to save.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CInvokeSpecifierListContainer::SavePDUCapabilities(
						INVOKE_SPECIFIER                *invoke_specifier,
						PSetOfExpectedCapabilities	 	capabilities_set)
{
	GCCError		rc = GCC_NO_ERROR;
	APP_CAP_ITEM    *pExpCapData;

	while ((capabilities_set != NULL) && (rc == GCC_NO_ERROR))
	{
		/*
		 * Create and fill in the new expected capability.
		 */
		DBG_SAVE_FILE_LINE
		pExpCapData = new APP_CAP_ITEM((GCCCapabilityType) capabilities_set->value.capability_class.choice);
		if (pExpCapData != NULL)
		{
			/*
			 * Create the CCapIDContainer object used to hold the
			 * capability ID data internally.  Make sure creation is successful.
			 */
			DBG_SAVE_FILE_LINE
			pExpCapData->pCapID = new CCapIDContainer(&capabilities_set->value.capability_id, &rc);
			if	(pExpCapData->pCapID == NULL || rc != GCC_NO_ERROR)
			{
				rc = GCC_ALLOCATION_FAILURE;
				delete pExpCapData;
			}
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
        }

		/*
		 * The capability ID was saved successfully, so go ahead and insert
		 * the expected capability data structure into the internal list.
		 * Fill in the capability class data.
		 */
		if (rc == GCC_NO_ERROR)
		{
			invoke_specifier->ExpectedCapItemList.Append(pExpCapData);

			/*
			 * Save the capability type and value.
			 */
            switch (capabilities_set->value.capability_class.choice)
            {
            case UNSIGNED_MINIMUM_CHOSEN:
				pExpCapData->nUnsignedMinimum = capabilities_set->value.capability_class.u.unsigned_minimum;
                break;
            case UNSIGNED_MAXIMUM_CHOSEN:
				pExpCapData->nUnsignedMaximum = capabilities_set->value.capability_class.u.unsigned_maximum;
                break;
			}
		}

        capabilities_set = capabilities_set->next;
	}

	return rc;
}

/*
 *	UINT	CInvokeSpecifierListContainer::GetApplicationCapability (
 *					APP_CAP_ITEM			        *capability_info_data,
 *					PGCCApplicationCapability		api_capability,
 *					LPSTR							memory)
 *
 *	Private member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 * 		This routine is used to fill in an API GCCApplicationCapability
 *		structure from an internal info structure.
 *
 *	Formal Parameters:
 *		capability_info_data	(i) Internal capability data to convert into
 *										API data.
 *		api_capability			(o) Structure to hold data in API form.
 *		memory					(o) Memory used to hold bulk data referenced by
 *										the API structure.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
UINT CInvokeSpecifierListContainer::GetApplicationCapability(
					APP_CAP_ITEM                    *pExpCapData,
					PGCCApplicationCapability		api_capability,
					LPBYTE							memory)
{
	UINT		data_length = 0;

	/*
	 * Call the CapabilityID object to retrieve the capability ID data.
	 */
	data_length = pExpCapData->pCapID->GetGCCCapabilityIDData(
												&api_capability->capability_id,
												memory);

	/*
	 * Fill in the remaining fields for the GCCApplicationCapability structure.
	 */
	api_capability->capability_class.eType = pExpCapData->eCapType;
    switch (pExpCapData->eCapType)
    {
    case GCC_UNSIGNED_MINIMUM_CAPABILITY:
		api_capability->capability_class.nMinOrMax = pExpCapData->nUnsignedMinimum;
        break;
    case GCC_UNSIGNED_MAXIMUM_CAPABILITY:
		api_capability->capability_class.nMinOrMax = pExpCapData->nUnsignedMaximum;
        break;
	}

	/*
	 * Fill in the number of entities.  Note, however, that this field will not
	 * be used in this context.
	 */
	api_capability->number_of_entities = 0;

	return (data_length);
}

/*
 *	GCCError	CInvokeSpecifierListContainer::ConvertInvokeSpecifierInfoToPDU(	
 *						INVOKE_SPECIFIER                    *specifier_info_ptr,
 *						PApplicationProtocolEntityList		ape_list_ptr)
 *
 *	Private member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine converts the invoke specifier from the internal form which
 *		is an "INVOKE_SPECIFIER" structure into the "PDU" structure form of
 *		a "ApplicationInvokeSpecifier".
 *
 *	Formal Parameters:
 *		specifier_info_ptr	(i) Internal structure holding data to convert.
 *		ape_list_ptr		(o) PDU structure to hold converted data.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CInvokeSpecifierListContainer::ConvertInvokeSpecifierInfoToPDU (	
						INVOKE_SPECIFIER                    *specifier_info_ptr,
						PApplicationProtocolEntityList		ape_list_ptr)
{
	GCCError						rc = GCC_NO_ERROR;
	PSetOfExpectedCapabilities		new_capability_set_ptr;
	PSetOfExpectedCapabilities		old_capability_set_ptr = NULL;

	/*
	 * Initialize the invoke specifier bit mask to zero.
	 */
	ape_list_ptr->value.bit_mask = 0;

	/*
	 * Fill in the session key PDU data using the CSessKeyContainer object.
	 */
	rc = specifier_info_ptr->session_key->GetSessionKeyDataPDU(&ape_list_ptr->value.session_key);

	/*
	 * Fill in the capabilities list if any exist.
	 */
	if ((rc == GCC_NO_ERROR) && (specifier_info_ptr->ExpectedCapItemList.GetCount() != 0))
	{
		APP_CAP_ITEM *pExpCapData;

		ape_list_ptr->value.bit_mask |= EXPECTED_CAPABILITY_SET_PRESENT;

		/*
		 * Set the pointer to the capability set to NULL so that it will be
		 * set equal to the first SetOfExpectedCapabilities created inside the
		 * iterator loop.
		 */
		ape_list_ptr->value.expected_capability_set = NULL;

		/*
		 * Iterate through the list of APP_CAP_ITEM structures,
		 * converting each into "PDU" form and saving the pointers in the
		 * "SetOfExpectedCapabilities.
		 */
		specifier_info_ptr->ExpectedCapItemList.Reset();
		while (NULL != (pExpCapData = specifier_info_ptr->ExpectedCapItemList.Iterate()))
		{
			DBG_SAVE_FILE_LINE
			new_capability_set_ptr = new SetOfExpectedCapabilities;

			/*
			 * If an allocation failure occurs, call the routine which will
			 * iterate through the list freeing any data which had been
			 * allocated.
			 */
			if (new_capability_set_ptr == NULL)
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::ConvertToPDU: alloc error, cleaning up"));
				rc = GCC_ALLOCATION_FAILURE;
				FreeApplicationInvokeSpecifierListPDU();
				break;
			}

			/*
			 * The first time through, set the PDU structure pointer equal
			 * to the first SetOfExpectedCapabilities created.  On
			 * subsequent loops, set the structure's "next" pointer equal to
			 * the new structure.
			 */
			if (ape_list_ptr->value.expected_capability_set == NULL)
			{
				ape_list_ptr->value.expected_capability_set = new_capability_set_ptr;
			}
			else
            {
				old_capability_set_ptr->next = new_capability_set_ptr;
            }

			old_capability_set_ptr = new_capability_set_ptr;

			/*
			 * Initialize the new "next" pointer to NULL.
			 */
			new_capability_set_ptr->next = NULL;

			if (ConvertExpectedCapabilityDataToPDU(pExpCapData, new_capability_set_ptr) != GCC_NO_ERROR)
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::ConvertToPDU: Error converting Capability to PDU"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
		}
	}

	/*
	 * Fill in the channel type if one is specified.
	 */
	if (specifier_info_ptr->startup_channel_type != MCS_NO_CHANNEL_TYPE_SPECIFIED)
	{
		ape_list_ptr->value.bit_mask |= INVOKE_STARTUP_CHANNEL_PRESENT;
	
        switch (specifier_info_ptr->startup_channel_type)
        {
        case MCS_STATIC_CHANNEL:
			ape_list_ptr->value.invoke_startup_channel = CHANNEL_TYPE_STATIC;
            break;
        case MCS_DYNAMIC_MULTICAST_CHANNEL:
			ape_list_ptr->value.invoke_startup_channel = DYNAMIC_MULTICAST;
            break;
        case MCS_DYNAMIC_PRIVATE_CHANNEL:
			ape_list_ptr->value.invoke_startup_channel = DYNAMIC_PRIVATE;
            break;
        case MCS_DYNAMIC_USER_ID_CHANNEL:
			ape_list_ptr->value.invoke_startup_channel = DYNAMIC_USER_ID;
            break;
		}
	}

	/*
	 * Fill in the invoke flag.
	 */
	ape_list_ptr->value.invoke_is_mandatory = (ASN1bool_t)specifier_info_ptr->must_be_invoked;

	return rc;
}

/*
 *	GCCError CInvokeSpecifierListContainer::ConvertExpectedCapabilityDataToPDU(	
 *						APP_CAP_ITEM				        *info_ptr,
 *						PSetOfExpectedCapabilities			pdu_ptr)
 *
 *	Private member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine converts the capability ID from the internal form which
 *		is an APP_CAP_ITEM structure into the "PDU" structure form
 *		of a "SetOfExpectedCapabilities".
 *
 *	Formal Parameters:
 *		info_ptr	(i) Internal structure holding data to convert.
 *		pdu_ptr		(o) PDU structure to hold converted data.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CInvokeSpecifierListContainer::ConvertExpectedCapabilityDataToPDU (	
						APP_CAP_ITEM				        *pExpCapData,
						PSetOfExpectedCapabilities			pdu_ptr)
{
	GCCError		rc = GCC_NO_ERROR;

	/*
	 * Retrieve the capability ID data from the internal
	 * CCapIDContainer object.
	 */
	rc = pExpCapData->pCapID->GetCapabilityIdentifierDataPDU(&pdu_ptr->value.capability_id);

	/*
	 * Fill in the capability class.
	 */
	if (rc == GCC_NO_ERROR)
	{
        switch (pExpCapData->eCapType)
        {
        case GCC_LOGICAL_CAPABILITY:
			pdu_ptr->value.capability_class.choice = LOGICAL_CHOSEN;
            break;
        case GCC_UNSIGNED_MINIMUM_CAPABILITY:
			pdu_ptr->value.capability_class.choice = UNSIGNED_MINIMUM_CHOSEN;
			pdu_ptr->value.capability_class.u.unsigned_minimum = pExpCapData->nUnsignedMinimum;
            break;
        case GCC_UNSIGNED_MAXIMUM_CAPABILITY:
			pdu_ptr->value.capability_class.choice = UNSIGNED_MAXIMUM_CHOSEN;
			pdu_ptr->value.capability_class.u.unsigned_maximum = pExpCapData->nUnsignedMaximum;
            break;
		}
	}

	return rc;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\mcslog.h ===
/**********************************************************************
 * File:     mcslog.h
 * Abstract: Function headers for protocol logging functions added
 * into MCSNC.DLL to read the contents of MCS PDU contents
 * sent and received from the T.123 layer.
 * Created:  2/18/96, Venkatesh Gopalakrishnan
 * Copyright (c) 1996 Microsoft Corpration
 ******************************************************************** */
 
 /* NOTE:  The contents of this file are only included IFF PDULOG is a
  * defined constant.  This constant will be defined in the Win32 Diagnostic
  * build configuration of MCSNC.DLL 
  */

 #ifdef PDULOG

 #ifndef _PROTLOG_H
 #define _PROTLOG_H
 

 #include <windows.h>
 #include <time.h>
 #include <stdio.h>
 
 #include "mpdutype.h"
 #include "mcspdu.h"
 
 #define MAXIMUM_PRINT_LENGTH 256
 #define LOG_FILE_NAME "mcslog.txt"
 #define SENT 0
 #define RECEIVED 1


 /* Enumerated Data types and corresponding strings used in
  * MCS PDUs.
  */

#define NOT_IN_USE			0
#define SELF_GRABBED		1
#define OTHER_GRABBED		2
#define SELF_INHIBITED		3
#define OTHER_INHIBITED		4
#define SELF_RECIPIENT		5
#define SELF_GIVING			6
#define OTHER_GIVING		7

#define NOT_IN_USE_STR			"NOT_IN_USE"
#define SELF_GRABBED_STR		"SELF_GRABBED"
#define OTHER_GRABBED_STR		"OTHER_GRABBED"
#define SELF_INHIBITED_STR		"SELF_INHIBITED"
#define OTHER_INHIBITED_STR		"OTHER_INHIBITED"
#define SELF_RECPIENT_STR		"SELF_RECIPIENT"
#define SELF_GIVING_STR			"SELF_GIVING"
#define OTHER_GIVING_STR		"OTHER_GIVING"

#define TOP_PRI			0
#define HIGH_PRI		1
#define MEDIUM_PRI		2
#define LOW_PRI			3

#define TOP_STR					"TOP_PRIORITY\n"
#define HIGH_STR				"HIGH_PRIORITY\n"
#define MEDIUM_STR				"MEDIUM_PRIORITY\n"
#define LOW_STR					"LOW_PRIORITY\n"

#define RT_SUCCESSFUL					0
#define RT_DOMAIN_MERGING				1
#define RT_DOMAIN_NOT_HIERARCHICAL		2
#define RT_NO_SUCH_CHANNEL				3
#define	RT_NO_SUCH_DOMAIN				4
#define RT_NO_SUCH_USER					5
#define RT_NOT_ADMITTED					6
#define RT_OTHER_USER					7
#define	RT_PARAMETERS_UNACCEPTABLE		8
#define RT_TOKEN_NOT_AVAILABLE			9
#define RT_TOKEN_NOT_POSESSED			10
#define RT_TOO_MANY_CHANNELS			11
#define RT_TOO_MANY_TOKENS				12
#define RT_TOO_MANY_USERS				13
#define RT_UNSPECIFIED_FAILURE			14
#define RT_USER_REJECTED				15


/*** 
**** The following function headers are for service functions
**** for logging the value(s) of typical data types found in 
**** several MCS PDU structures.
****/ 
void PrintPDUResult(FILE *logfile, unsigned int result);
void PrintPDUPriority(FILE *logfile, unsigned int priority);
void PrintTokenStatus(FILE *logfile, unsigned int token_status);
void PrintPDUReason(FILE *logfile, unsigned int reason);
void PrintDiagnostic(FILE *logfile, unsigned int diagnostic);
void PrintPDUSegmentation(FILE *logfile, unsigned char segmentation);


void PrintSetOfChannelIDs(FILE *logfile, PSetOfChannelIDs channel_ids);
void PrintSetOfUserIDs(FILE *logfile, PSetOfUserIDs user_ids);
void PrintSetOfTokenIDs(FILE *logfile, PSetOfTokenIDs token_ids);
void PrintSetOfTokenAttributes(FILE *logfile, 
							PSetOfPDUTokenAttributes token_attribute_obj);

void PrintPDUDomainParameters(FILE *logfile, PDUDomainParameters domain_params);
void PrintT120Boolean(FILE *logfile, char * string, BOOL boolean);
void PrintCharData(FILE *logfile, unsigned char *string, unsigned int length);

void PrintChannelAttributes(FILE *logfile, PDUChannelAttributes channel_attributes);
void PrintTokenAttributes(FILE *logfile, PDUTokenAttributes token_attributes);

int InitializeMCSLog();
 /* Description:
  *         Resets the mcs protocol log file and reads any
  *         ini file parameters
  */
  

char *pszTimeStamp(); 
 /* Desicription:
  *         This function is an easy interfact to getting the time the
  *         PDU was encoded or decoded from MCS to T.123 or vice versa.
  */
  
void pduLog(FILE *file, char * format_string,...);
 /* Description:
  *         This function is used to place PDU information in a protocol
  *         log file.  There is currently no return value.  This may change.
  */       

void pduFragmentation(FILE *logfile, unsigned int i);
 /* Description:
  *         This function logs weather or not the PDU is complete
  *         or fragmented.
  */

void pduRawOutput(FILE *logfile, unsigned char * data, unsigned long length);
 /* Description:
  *         This function logs a hex dump of the raw encoded MCS PDU that
  *         is sent over the wire via MCS.
  */
  

void mcsLog(PPacket packet,  PDomainMCSPDU domain_pdu, unsigned int direction);
 /* Description:
  *         This function takes care of the log headers and footers to 
  *         attempt at compatibility with a certain third party mcs log
  *         reader.
  */
void mcsConnectLog(PPacket packet, PConnectMCSPDU connect_pdu, unsigned int direction);
 /* same as above, but for Connect PDUs */

void pduLogMCSDomainInfo(FILE *file, PDomainMCSPDU domain_pdu);
/* Description:
 *         This function takes the mcs pdu structure, and based on
 *         Which type of MCSPDU that it is, logs internal information
 *         in the PDU.
 */
void pduLogMCSConnectInfo(FILE *file, PConnectMCSPDU connect_pdu);
 /* same as above but for Connect PDUs */

void pduDirection(FILE *logfile,unsigned int direction);
 /* Description:
  *         This function logs information whether the mcs pdu was sent
  *         or received.
  */



/*****
 ***** The following headers are for functions that log the output of
 ***** each different type of MCS PDU.  Every MCS PDU is covered here.
 *****/

void pduLogConnectInitial(FILE *file, PConnectMCSPDU connect_pdu);
 /* Description:
  *         This function takes the connect_pdu and writes the component parts
  *         of the mcs ConnectInitial PDU.
  */
void pduLogConnectResponse(FILE *file, PConnectMCSPDU connect_pdu);
void pduLogConnectAdditional(FILE *file, PConnectMCSPDU connect_pdu);
void pduLogConnectResult(FILE *file, PConnectMCSPDU connect_pdu);
void pduLogPlumbDomainIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogErectDomainRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogMergeChannelsRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogMergeChannelsConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogPurgeChannelIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogMergeTokensRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogMergeTokensConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogPurgeTokenIndication(FILE *file, PDomainMCSPDU domain_pdu); 
void pduLogDisconnectProviderUltimatum(FILE *file, PDomainMCSPDU domain_pdu); 
void pduLogRejectUltimatum(FILE *logfile, PDomainMCSPDU domain_pdu);
void pduLogAttachUserRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogAttachUserConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogDetachUserRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogDetachUserIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelJoinRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelJoinConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelLeaveRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelConveneRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelConveneConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelDisbandRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelDisbandIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelAdmitRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelAdmitIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelExpelRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelExpelIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogSendDataRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogSendDataIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogUniformSendDataRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogUniformSendDataIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenGrabRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenGrabConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenInhibitRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenInhibitConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenGiveRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenGiveIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenGiveResponse(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenGiveConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenPleaseRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenPleaseIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenReleaseRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenReleaseConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenTestRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenTestConfirm(FILE *file, PDomainMCSPDU domain_pdu);
 
 
BOOL CopyTextToChar(char * print_string, 
						   unsigned short *text_string_value, 
						   unsigned int text_string_length);

 


 #endif  // <<<<<<<<<<<< _PROTLOG_H
 #endif  // <<<<<<<<<<<< PDULOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\mcslog.cpp ===
#include "precomp.h"
/**********************************************************************
 * File:     mcslog.c
 * Abstract: global function definitions for protocol logging functions 
 * added into MCSNC.DLL to read the contents of MCS PDU
 * contents sent and received from the T.123 layer.
 * Created:  2/18/96, Venkatesh Gopalakrishnan
 * Copyright (c) 1996 Microsoft Corpration
 ******************************************************************** */

 /* NOTE:  The contents of this file are only included IFF PDULOG is a
  * defined constant.  This constant will be defined in the Win32 Diagnostic
  * build configuration of MCSNC.DLL 
  */

 #ifdef PDULOG
 
 #include "mcslog.h"
 
 /* just threw these in to keep a total count of the number of bytes
  * of ASN.1 coded data sent and received.
  */
 long int recv_pdu_log = 0;
 long int sent_pdu_log = 0;

 /***********************************************************************/
 int InitializeMCSLog()
 {
    FILE *logfile;

	/* this should just reset the file pointer */    
    logfile = fopen(LOG_FILE_NAME,"w");

	// this "fake" starting PDU is put in so that the Intel Protocol Browser
	// dosen't go nuts if it is reading dynamically.
    pduLog(logfile,"START_PDU: ============================== START PDU ===========================\n");
    pduLog(logfile,"TIMESTAMP: %s\n",pszTimeStamp());
    pduLog(logfile,"LAYER:     MCS\n");
    pduLog(logfile,"DIRECTION: None\n");
    pduLog(logfile,"RAW_PDU: -   -   -   -   -   -   -   -   RAW PDU  -   -   -   -   -   -   -   -\n");
    pduLog(logfile,"DECODED_PDU: -   -   -   -   -   -   -  DECODED PDU   -   -   -   -   -   -   -\n");
    pduLog(logfile,"PDU_TYPE:  Bogus_PDU_to_start_the_logging.\n");
	pduLog(logfile,"END_PDU: ================================ END PDU =============================\n");
	
	fclose(logfile);
    return(0);
 }

 /**************************************************************************/
 char *pszTimeStamp()
 {
    char *timestring;
    timestring = (char *) malloc (13*sizeof(char));
    _strtime(timestring);
    return(timestring);
 }

 /**************************************************************************/
 void pduFragmentation(FILE *logfile,unsigned int i)
 {
    pduLog(logfile,"  PDU Fragmentation: ");
    if(i==1) 
    {
        pduLog(logfile,"Complete PDU\n");
    }
    else
    {
        pduLog(logfile,"!!!! Icomplete PDU !!!!\n");
    }
 }

 /**************************************************************************/
 void  pduRawOutput (FILE *logfile,unsigned char *data, unsigned long length) 
 {
       unsigned int i=0,j=0;
       
       pduLog(logfile,"        ");
       for (i=0; i<length; i++) 
       {
            pduLog(logfile,"%02x ",*(data+i));
            j++;
            if (j >= 16) 
            {
                pduLog(logfile,"\n        ");
                j=0;
            }
       }
       pduLog(logfile,"\n");
 }

 /**************************************************************************/ 
 void PrintCharData(FILE *logfile, unsigned char *data, unsigned int length)
 {
	 char print_buffer[255];

	 //strncpy(print_buffer,(const char *) data, length);
	 //CopyTextToChar(print_buffer, (unsigned short *) data, length);
	 //pduLog(logfile,"\tlength = [%d] ; ",length);
	 //pduLog(logfile,"\ttext = %s\n",print_buffer);
	 pduRawOutput(logfile,data,length);
 }

 /**************************************************************************/
 void pduDirection(FILE *logfile,unsigned int direction)
 {
    switch(direction)
    {
        case SENT:
            pduLog(logfile,"DIRECTION: Sent\n");
            break;
        case RECEIVED:
            pduLog(logfile,"DIRECTION: Received\n");
            break;
        default:
            pduLog(logfile,"DIRECTION: Unknown\n");
            break;
     }
 }


/**************************************************************************/
void	pduLog (FILE *pFile, char * format,...)
 {
    char	*argument_ptr;
    
    argument_ptr = (char *) &format + sizeof (format);
    vfprintf (pFile, format, argument_ptr);
 }


 /**************************************************************************/  
 void mcsLog(PPacket packet, PDomainMCSPDU domain_pdu, unsigned int direction)
 {
    FILE *logfile;   
    logfile = fopen(LOG_FILE_NAME,"a+");
    
    pduLog(logfile,"START_PDU: ============================== START PDU ===========================\n");
    pduLog(logfile,"TIMESTAMP: %s\n",pszTimeStamp());
    pduLog(logfile,"LAYER:     MCS\n");
    pduDirection(logfile,direction);
    pduLog(logfile,"RAW_PDU: -   -   -   -   -   -   -   -   RAW PDU  -   -   -   -   -   -   -   -\n");
    pduLog(logfile,"      %d octets (hex output):\n",packet->GetEncodedDataLength());
    if(direction==RECEIVED)
        recv_pdu_log = recv_pdu_log + packet->GetEncodedDataLength();
    else
        sent_pdu_log = sent_pdu_log + packet->GetEncodedDataLength();
    pduLog(logfile,"      Total Data:  sent = %ld    recv = %ld\n",sent_pdu_log,recv_pdu_log);
    pduRawOutput(logfile,packet->GetEncodedData(1),packet->GetEncodedDataLength());
    pduLog(logfile,"DECODED_PDU: -   -   -   -   -   -   -  DECODED PDU   -   -   -   -   -   -   -\n");
    pduFragmentation(logfile,packet->IsValid());
    pduLogMCSDomainInfo(logfile,domain_pdu);
    pduLog(logfile,"END_PDU: ================================ END PDU =============================\n");
 
    fclose(logfile);
 }

 /**************************************************************************/
 void mcsConnectLog(PPacket packet, PConnectMCSPDU connect_pdu, unsigned int direction)
 {
    FILE *logfile;   
    logfile = fopen(LOG_FILE_NAME,"a+");

    pduLog(logfile,"START_PDU: ============================== START PDU ===========================\n");
    pduLog(logfile,"TIMESTAMP: %s\n",pszTimeStamp());
    pduLog(logfile,"LAYER:     MCS\n");
    pduDirection(logfile,direction);
    pduLog(logfile,"RAW_PDU: -   -   -   -   -   -   -   -   RAW PDU  -   -   -   -   -   -   -   -\n");
    pduLog(logfile,"      %d octets (hex output):\n",packet->GetEncodedDataLength());
    if(direction==RECEIVED)
        recv_pdu_log = recv_pdu_log + packet->GetEncodedDataLength();
    else
        sent_pdu_log = sent_pdu_log + packet->GetEncodedDataLength();
    pduLog(logfile,"      Total Data:  sent = %ld    recv = %ld\n",sent_pdu_log,recv_pdu_log);
    pduRawOutput(logfile,packet->GetEncodedData(1),packet->GetEncodedDataLength());
    pduLog(logfile,"DECODED_PDU: -   -   -   -   -   -   -  DECODED PDU   -   -   -   -   -   -   -\n");
    pduFragmentation(logfile,packet->IsValid());
    pduLogMCSConnectInfo(logfile,connect_pdu);
    pduLog(logfile,"END_PDU: ================================ END PDU =============================\n");
 
    fclose(logfile);
 }


 ////////////////////////////////////////////////////////////////////////////
 // Switch cases for MCS Connect PDUs
 ////////////////////////////////////////////////////////////////////////////
 /**************************************************************************/ 
 void   pduLogMCSConnectInfo(FILE *logfile, PConnectMCSPDU connect_pdu)
 {
    switch(connect_pdu->choice)
    {
		case CONNECT_INITIAL_CHOSEN:
            {
                pduLog(logfile,"PDU_TYPE: MCS_ConnectInitialPDU\n");
				pduLogConnectInitial(logfile,connect_pdu);
			}
            break;
		case CONNECT_RESPONSE_CHOSEN:
            {
                pduLog(logfile, "PDU_TYPE: MCS_ConnectResponsePDU\n");
				pduLogConnectResponse(logfile, connect_pdu);
			}
            break;
        case CONNECT_ADDITIONAL_CHOSEN:
            {
                pduLog(logfile,"PDU_TYPE: MCS_ConnectAdditionalPDU\n");
				pduLogConnectAdditional(logfile, connect_pdu);
            }
            break;
        case CONNECT_RESULT_CHOSEN:
            {
				pduLog(logfile,"PDU_TYPE: MCS_ConnectResultPDU\n");
				pduLogConnectResult(logfile, connect_pdu);
            }
            break;
        default:
            {
                pduLog(logfile,"ERROR: Unknown MCS Connect PDU !! << \n");
            }
            break;
	}
 }

 /**************************************************************************/
 void   pduLogMCSDomainInfo(FILE *logfile, PDomainMCSPDU domain_pdu)
 {
    switch(domain_pdu->choice)
    {
        case PLUMB_DOMAIN_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_PlumbDomainIndication\n");
				pduLogPlumbDomainIndication(logfile, domain_pdu);
			}
			break;
		case ERECT_DOMAIN_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ErectDomainIndication\n");
				pduLogErectDomainRequest(logfile, domain_pdu);
			}
			break;
		case MERGE_CHANNELS_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_MergeChannelsRequest\n");
				pduLogMergeChannelsRequest(logfile, domain_pdu);
			}
			break;
		case MERGE_CHANNELS_CONFIRM_CHOSEN:	
			{
				pduLog(logfile,"PDU_TYPE: MCS_MergeChannelsConfirm\n");
				pduLogMergeChannelsConfirm(logfile,domain_pdu);
			}
			break;
		case PURGE_CHANNEL_INDICATION_CHOSEN:	
			{
				pduLog(logfile,"PDU_TYPE: MCS_PurgeChannelIndication\n");
				pduLogPurgeChannelIndication(logfile,domain_pdu);
			}
			break;
		case MERGE_TOKENS_REQUEST_CHOSEN:		
			{
				pduLog(logfile,"PDU_TYPE: MCS_MergeTokensRequest\n");
				pduLogMergeTokensRequest(logfile,domain_pdu);
			}
			break;
		case MERGE_TOKENS_CONFIRM_CHOSEN:		
			{
				pduLog(logfile,"PDU_TYPE: MCS_MergeTokensConfirm\n");
				pduLogMergeTokensConfirm(logfile,domain_pdu);
			}
			break;
		case PURGE_TOKEN_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_PurgeTokenIndication\n");
				pduLogPurgeTokenIndication(logfile,domain_pdu);
			}
			break;
		case DISCONNECT_PROVIDER_ULTIMATUM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_DisconnectProviderUltimatum\n");
				pduLogDisconnectProviderUltimatum(logfile,domain_pdu);
			}
			break;
		case REJECT_ULTIMATUM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_RejectUltimatum\n");
				pduLogRejectUltimatum(logfile,domain_pdu);
			}
			break;
		case ATTACH_USER_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_AttachUserRequest\n");
				pduLogAttachUserRequest(logfile,domain_pdu);
			}
			break;
		case ATTACH_USER_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_AttachUserConfirm\n");
				pduLogAttachUserConfirm(logfile,domain_pdu);
			}
			break;
		case DETACH_USER_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_DetachUserRequest\n");
				pduLogDetachUserRequest(logfile,domain_pdu);
			}
			break;
		case DETACH_USER_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_DetachUserIndication\n");
				pduLogDetachUserIndication(logfile,domain_pdu);
			}
			break;
		case CHANNEL_JOIN_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelJoinRequest\n");
				pduLogChannelJoinRequest(logfile,domain_pdu);
			}
			break;
		case CHANNEL_JOIN_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelJoinConfirm\n");
				pduLogChannelJoinConfirm(logfile,domain_pdu);
			}
			break;
		case CHANNEL_LEAVE_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelLeaveRequest\n");
				pduLogChannelLeaveRequest(logfile,domain_pdu);
			}
			break;
		case CHANNEL_CONVENE_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelConveneRequest\n");
				pduLogChannelConveneRequest(logfile,domain_pdu);
			}
			break;
		case CHANNEL_CONVENE_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelConveneConfirm\n");
				pduLogChannelConveneConfirm(logfile,domain_pdu);
			}
			break;
		case CHANNEL_DISBAND_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelDisbandRequest\n");
				pduLogChannelDisbandRequest(logfile,domain_pdu);
			}
			break;
		case CHANNEL_DISBAND_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelDisbandIndication\n");
				pduLogChannelDisbandIndication(logfile,domain_pdu);
			}
			break;
		case CHANNEL_ADMIT_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelAdmitRequest\n");
				pduLogChannelAdmitRequest(logfile,domain_pdu);
			}
			break;
		case CHANNEL_ADMIT_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelAdmitIndication\n");
				pduLogChannelAdmitIndication(logfile,domain_pdu);
			}
			break;
		case CHANNEL_EXPEL_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelExpelRequest\n");
				pduLogChannelExpelRequest(logfile,domain_pdu);
			}
			break;
		case CHANNEL_EXPEL_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelExpelIndication\n");
				pduLogChannelExpelIndication(logfile,domain_pdu);
			}
			break;
		case SEND_DATA_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_SendDataRequest\n");
				pduLogSendDataRequest(logfile,domain_pdu);
			}
			break;
		case SEND_DATA_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_SendDataIndication\n");
				pduLogSendDataIndication(logfile,domain_pdu);
			}
			break;
		case UNIFORM_SEND_DATA_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_UniformSendDataRequest\n");
				pduLogUniformSendDataRequest(logfile,domain_pdu);
			}
			break;
		case UNIFORM_SEND_DATA_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_UniformSendDataIndication\n");
				pduLogUniformSendDataIndication(logfile,domain_pdu);
			}
			break;
		case TOKEN_GRAB_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenGrabRequest\n");
				pduLogTokenGrabRequest(logfile,domain_pdu);
			}
			break;
		case TOKEN_GRAB_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenGrabConfirm\n");
				pduLogTokenGrabConfirm(logfile,domain_pdu);
			}
			break;
		case TOKEN_INHIBIT_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenInhibitRequest\n");
				pduLogTokenInhibitRequest(logfile,domain_pdu);
			}
			break;
		case TOKEN_INHIBIT_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenInhibitConfirm\n");
				pduLogTokenInhibitConfirm(logfile,domain_pdu);
			}
			break;
		case TOKEN_GIVE_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenGiveRequest\n");
				pduLogTokenGiveRequest(logfile,domain_pdu);
			}
			break;
		case TOKEN_GIVE_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenGiveIndication\n");
				pduLogTokenGiveIndication(logfile,domain_pdu);
			}
			break;
		case TOKEN_GIVE_RESPONSE_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenGiveResponse\n");
				pduLogTokenGiveResponse(logfile,domain_pdu);
			}
			break;
		case TOKEN_GIVE_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenGiveConfirm\n");
				pduLogTokenGiveConfirm(logfile,domain_pdu);
			}
			break;
		case TOKEN_PLEASE_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenPleaseRequest\n");
				pduLogTokenPleaseRequest(logfile,domain_pdu);
			}
			break;
		case TOKEN_PLEASE_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenPleaseIndication\n");
				pduLogTokenPleaseIndication(logfile,domain_pdu);
			}
			break;
		case TOKEN_RELEASE_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenReleaseRequest\n");
				pduLogTokenReleaseRequest(logfile,domain_pdu);
			}
			break;
		case TOKEN_RELEASE_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenReleseConfirm\n");
				pduLogTokenReleaseConfirm(logfile,domain_pdu);
			}
			break;
		case TOKEN_TEST_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenTestRequest\n");
				pduLogTokenTestRequest(logfile,domain_pdu);
			}
			break;
		case TOKEN_TEST_CONFIRM_CHOSEN:
            {
				pduLog(logfile,"PDU_TYPE: MCS_TokenTestConfirm\n");	   
				pduLogTokenTestConfirm(logfile,domain_pdu);
			}
            break;
        default: 
            {
                // write something, just so we know we got a PDU.
                pduLog(logfile,"ERROR: we got a MCS PDU, just don't know what it is");
			}
            break;
	}					
}



///////////////////////////////////////////////////////////////////////
// constant string returns
//////////////////////////////////////////////////////////////////////
/**************************************************************************/
void PrintPDUResult(FILE *logfile, unsigned int result)
{
	switch(result)
	{
	case RT_SUCCESSFUL:
		pduLog(logfile,"RT_SUCCESSFUL\n");	
		break;
	case RT_DOMAIN_MERGING:
		pduLog(logfile,"RT_DOMAIN_MERGING\n");
		break;
	case RT_DOMAIN_NOT_HIERARCHICAL:
		pduLog(logfile,"RT_DOMAIN_NOT_HIERARCHICAL\n");
		break;
	case RT_NO_SUCH_CHANNEL:
		pduLog(logfile,"RT_NO_SUCH_CHANNEL\n");
		break;
	case RT_NO_SUCH_DOMAIN:
		pduLog(logfile,"RT_NO_SUCH_DOMAIN\n");
		break;
	case RT_NO_SUCH_USER:	
		pduLog(logfile,"RT_NO_SUCH_USER\n");
		break;
	case RT_NOT_ADMITTED:
		pduLog(logfile,"RT_NOT_ADMITTED\n");
		break;
	case RT_OTHER_USER:
		pduLog(logfile,"RT_OTHER_USER\n");
		break;
	case RT_PARAMETERS_UNACCEPTABLE:
		pduLog(logfile,"RT_PARAMETERS_UNACCEPTABLE\n");
		break;
	case RT_TOKEN_NOT_AVAILABLE:
		pduLog(logfile,"RT_TOKEN_NOT_AVAILABLE\n");
		break;
	case RT_TOKEN_NOT_POSESSED:
		pduLog(logfile,"RT_TOKEN_NOT_POSESSED\n");
		break;
	case RT_TOO_MANY_CHANNELS:
		pduLog(logfile,"RT_TOO_MANY_CHANNELS\n");
		break;
	case RT_TOO_MANY_TOKENS:
		pduLog(logfile,"RT_TOO_MANY_TOKENS\n");
		break;
	case RT_TOO_MANY_USERS:		
		pduLog(logfile,"RT_TOO_MANY_USERS\n");
		break;
	case RT_UNSPECIFIED_FAILURE:
		pduLog(logfile,"RT_UNSPECIFIED_FAILURE\n");
		break;
	case RT_USER_REJECTED:
		pduLog(logfile,"RT_USER_REJECTED\n");
		break;
	default:
		pduLog(logfile,"ERROR: UNKOWN RETURN TYPE <<<\n");
		break;
	}
}

/**************************************************************************/
void PrintPDUPriority(FILE *logfile, unsigned int priority)
{
	switch(priority)
	{
	case TOP_PRI:	
		pduLog(logfile,TOP_STR);
		break;
	case HIGH_PRI:
		pduLog(logfile,HIGH_STR);
		break;
	case MEDIUM_PRI:
		pduLog(logfile,MEDIUM_STR);
		break;
	case LOW_PRI:
		pduLog(logfile,LOW_STR);
		break;
	default:
		pduLog(logfile," >>>> UNKNOWN PRIORITY <<<\n");
		break;
	}
}

/**************************************************************************/
void PrintPDUSegmentation(FILE *logfile, unsigned char segmentation)
{
	if(segmentation==0x80)
		pduLog(logfile,"\tSegmentation: Begin\n");
	else if (segmentation==0x40)
		pduLog(logfile,"\tSegmentation: End\n");
	else
		pduLog(logfile,"\tSegmentation: Unknown\n");
}

/**************************************************************************/
void PrintTokenStatus(FILE *logfile, unsigned int status)
{
	switch(status)
	{
	case 0:
		pduLog(logfile,"\ttoken_status = NOT_IN_USE\n");
		break;
	case 1:
		pduLog(logfile,"\ttoken_status = SELF_GRABBED\n");
		break;
	case 2:
		pduLog(logfile,"\ttoken_status = OTHER_GRABBED\n");
		break;
	case 3:
		pduLog(logfile,"\ttoken_status = SELF_INHIBITED\n");
		break;
	case 4:
		pduLog(logfile,"\ttoken_status = OTHER_INHIBITED\n");
		break;
	case 5:
		pduLog(logfile,"\ttoken_status = SELF_RECIPIENT\n");
		break;
	case 6: 
		pduLog(logfile,"\ttoken_status = SELF_GIVING\n");
		break;
	case 7: 
		pduLog(logfile,"\ttoken_status = OTHER_GIVING\n");
		break;
	default:
		pduLog(logfile,"\tERROR: unknown token status\n");
		break;
	}
}


/**************************************************************************/
void PrintPDUReason(FILE *logfile, unsigned int reason)
{
	pduLog(logfile,"\t\tReason:   ");
	switch(reason)
	{
	case 0:
		pduLog(logfile,"RN_DOMAIN_DISCONNECTED\n");
		break;
	case 1:
		pduLog(logfile,"RN_PROVIDER_INITIATED\n");
		break;
	case 2:
		pduLog(logfile,"RN_TOKEN_PURGED\n");
		break;
	case 3: 
		pduLog(logfile,"RN_USER_REQUESTED\n");
		break;
	case 4: 
		pduLog(logfile,"RN_CHANNEL_PURGED\n");
		break;
	}
}

/**************************************************************************/
void PrintDiagnostic(FILE *logfile, unsigned int diagnostic)
{
	pduLog(logfile,"\t\tDiagnostic:   ");
	switch(diagnostic)
	{
	case 0:
		pduLog(logfile,"dc_inconsistent_merge\n");
		break;
	case 1:
		pduLog(logfile,"dc_forbidden_pdu_downward\n");
		break;
	case 2:
		pduLog(logfile,"dc_forbidden_pdu_upward\n");
		break;
	case 3:
		pduLog(logfile,"dc_invalid_ber_encoding\n");
		break;
	case 4:
		pduLog(logfile,"dc_invalid_per_encoding\n");
		break;
	case 5:
		pduLog(logfile,"dc_misrouted_user\n");
		break;
	case 6:
		pduLog(logfile,"dc_unrequested_confirm\n");
		break;
	case 7:
		pduLog(logfile,"dc_wrong_transport_priority\n");
		break;
	case 8:
		pduLog(logfile,"dc_channel_id_conflict\n");
		break;
	case 9:
		pduLog(logfile,"dc_token_id_conflict\n");
		break;
	case 10:
		pduLog(logfile,"dc_not_user_id_channel\n");
		break;
	case 11:
		pduLog(logfile,"dc_too_many_channels\n");
		break;
	case 12:
		pduLog(logfile,"dc_too_many_tokens\n");
		break;
	case 13:
		pduLog(logfile,"dc_too_many_users\n");
		break;
	default:
		pduLog(logfile,"ERROR: unknown diagnostic\n");
		break;
	}
}



/*****
 ***** Logging functions for individual MCS PDU contents
 *****/
/**************************************************************************/
void pduLogConnectInitial(FILE *logfile, PConnectMCSPDU connect_pdu)
{
	pduLog(logfile,"\tCalling Domain Selector:");
	PrintCharData(logfile,connect_pdu->u.connect_initial.calling_domain_selector.value,
						 connect_pdu->u.connect_initial.calling_domain_selector.length);
	pduLog(logfile,"\tCalled Domain Selector:");
	PrintCharData(logfile,connect_pdu->u.connect_initial.called_domain_selector.value,
						 connect_pdu->u.connect_initial.called_domain_selector.length);
	PrintT120Boolean(logfile,"\tupward_flag = ",
						 (BOOL) connect_pdu->u.connect_initial.upward_flag);
	pduLog(logfile,"\tTarget Parameters: \n");
	PrintPDUDomainParameters(logfile, connect_pdu->u.connect_initial.target_parameters);
	pduLog(logfile,"\tMinimum Parameters: \n");
	PrintPDUDomainParameters(logfile, connect_pdu->u.connect_initial.minimum_parameters);
	pduLog(logfile,"\tMaximum Parameters: \n");
	PrintPDUDomainParameters(logfile, connect_pdu->u.connect_initial.maximum_parameters);
	pduLog(logfile,"\tUser Data: \n");
	pduRawOutput(logfile,connect_pdu->u.connect_initial.user_data.value,
						 connect_pdu->u.connect_initial.user_data.length);

}

/**************************************************************************/
void pduLogConnectResponse(FILE *logfile, PConnectMCSPDU connect_pdu)
{
	pduLog(logfile, "\tResult: ");
	PrintPDUResult(logfile, connect_pdu->u.connect_response.result);
	pduLog(logfile, "\tcalled_connect_id = %u \n",
			connect_pdu->u.connect_response.called_connect_id);
	pduLog(logfile, "\tDomain Parameters: \n");
	PrintPDUDomainParameters(logfile, connect_pdu->u.connect_response.domain_parameters);
	pduLog(logfile, "\tUser Data: \n");
	pduRawOutput(logfile,connect_pdu->u.connect_response.user_data.value,
						 connect_pdu->u.connect_response.user_data.length);
}

/**************************************************************************/
void pduLogConnectAdditional(FILE *logfile, PConnectMCSPDU connect_pdu)
{
	pduLog(logfile, "\tcalled_connect_id = %u\n",
			connect_pdu->u.connect_additional.called_connect_id);
	pduLog(logfile, "Priority: \n");
	PrintPDUPriority(logfile, connect_pdu->u.connect_additional.data_priority);
}

/**************************************************************************/
void pduLogConnectResult(FILE *logfile, PConnectMCSPDU connect_pdu)
{
	pduLog(logfile, "\tResult: ");
	PrintPDUResult(logfile, connect_pdu->u.connect_result.result);
}

/**************************************************************************/
void pduLogPlumbDomainIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile, "\theight_limit = %u\n",
			domain_pdu->u.plumb_domain_indication.height_limit);
}

/**************************************************************************/
void pduLogErectDomainRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile, "\tsub_height = %u\n",
			domain_pdu->u.erect_domain_request.sub_height);
	pduLog(logfile, "\tsub_interval = %u\n",
			domain_pdu->u.erect_domain_request.sub_interval);
}

/**************************************************************************/
void pduLogMergeChannelsRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	int i = 0;
	PSetOfPDUChannelAttributes  channel_attributes;
	PSetOfChannelIDs  channel_ids;

	channel_attributes = domain_pdu->u.merge_channels_request.merge_channels;
	channel_ids = domain_pdu->u.merge_channels_request.purge_channel_ids;

	pduLog(logfile, "  Merge Channels:\n");
	for(i=0; channel_attributes!=NULL; i++)
	{
		pduLog(logfile,"\t*** record [%u] ***\n",i);
		PrintChannelAttributes(logfile, channel_attributes->value);
		channel_attributes = channel_attributes->next;
	}
	pduLog(logfile, "  Purge Channel IDs:\n");
	for(i=0; channel_ids!=NULL; i++)
	{
		pduLog(logfile,"\t\trecord[%u] = %u\n",channel_ids->value);
		channel_ids = channel_ids->next;
	}
}

/**************************************************************************/
void pduLogMergeChannelsConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	unsigned int i = 0;
	PSetOfPDUChannelAttributes  channel_attributes;
	PSetOfChannelIDs  channel_ids;

	channel_attributes = domain_pdu->u.merge_channels_confirm.merge_channels;
	channel_ids = domain_pdu->u.merge_channels_confirm.purge_channel_ids;

	pduLog(logfile, "  Merge Channels:\n");
	for(i=0; channel_attributes!=NULL; i++)
	{
		pduLog(logfile,"\t*** record [%u] ***\n",i);
		PrintChannelAttributes(logfile, channel_attributes->value);
		channel_attributes = channel_attributes->next;
	}
	pduLog(logfile, "  Purge Channel IDs:\n");
	PrintSetOfChannelIDs(logfile,channel_ids);
}

/**************************************************************************/
void pduLogPurgeChannelIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PSetOfUserIDs	detach_user_ids;
	PSetOfChannelIDs	purge_channel_ids;

	detach_user_ids = domain_pdu->u.purge_channel_indication.detach_user_ids;
	purge_channel_ids = domain_pdu->u.purge_channel_indication.purge_channel_ids;

	pduLog(logfile, "  Detach User IDs: \n");
	PrintSetOfUserIDs(logfile, detach_user_ids);

	pduLog(logfile, "  Purge Channel IDs: \n");
	PrintSetOfChannelIDs(logfile, purge_channel_ids);
}

/**************************************************************************/
void pduLogMergeTokensRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PSetOfPDUTokenAttributes merge_tokens;
	PSetOfTokenIDs purge_token_ids;

	merge_tokens = domain_pdu->u.merge_tokens_request.merge_tokens;
	purge_token_ids = domain_pdu->u.merge_tokens_request.purge_token_ids;

	pduLog(logfile,"   Merge Tokens: \n");
	PrintSetOfTokenAttributes(logfile, merge_tokens);
	pduLog(logfile,"   Purge Token IDs: \n");
	PrintSetOfTokenIDs(logfile, purge_token_ids);
}

/**************************************************************************/
void pduLogMergeTokensConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PSetOfPDUTokenAttributes merge_tokens;
	PSetOfTokenIDs purge_token_ids;

	merge_tokens = domain_pdu->u.merge_tokens_request.merge_tokens;
	purge_token_ids = domain_pdu->u.merge_tokens_request.purge_token_ids;

	pduLog(logfile,"   Merge Tokens: \n");
	PrintSetOfTokenAttributes(logfile, merge_tokens);
	pduLog(logfile,"   Purge Token IDs: \n");
	PrintSetOfTokenIDs(logfile, purge_token_ids);
}

/**************************************************************************/
void pduLogPurgeTokenIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PSetOfTokenIDs purge_token_ids;

	purge_token_ids = domain_pdu->u.purge_token_indication.purge_token_ids;

	pduLog(logfile,"   Purge Token IDs: \n");
	PrintSetOfTokenIDs(logfile, purge_token_ids);
}

/**************************************************************************/
void pduLogDisconnectProviderUltimatum(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PrintPDUReason(logfile, domain_pdu->u.disconnect_provider_ultimatum.reason);
}

/**************************************************************************/           
void pduLogRejectUltimatum(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PrintDiagnostic(logfile, 
					domain_pdu->u.reject_user_ultimatum.diagnostic);
	pduLog(logfile,"\tInitial Octets: \n");
	pduRawOutput(logfile,
				 domain_pdu->u.reject_user_ultimatum.initial_octets.value,
				 domain_pdu->u.reject_user_ultimatum.initial_octets.length);
}

/**************************************************************************/
void pduLogAttachUserRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile, "placeholder = %c\n",
			domain_pdu->u.attach_user_request.placeholder);
}

/**************************************************************************/
void pduLogAttachUserConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.attach_user_confirm.result);
	pduLog(logfile,"\tinitiator = %u\n",
			domain_pdu->u.attach_user_confirm.initiator);
}

/**************************************************************************/
void pduLogDetachUserRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PrintPDUReason(logfile,domain_pdu->u.detach_user_request.reason);
	PrintSetOfUserIDs(logfile,
						domain_pdu->u.detach_user_request.user_ids);
}


/**************************************************************************/
void pduLogDetachUserIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PrintPDUReason(logfile,domain_pdu->u.detach_user_indication.reason);
	PrintSetOfUserIDs(logfile,
						domain_pdu->u.detach_user_indication.user_ids);
}

/**************************************************************************/
void pduLogChannelJoinRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\t\tuser_id = %u\n",
			domain_pdu->u.channel_join_request.initiator);
	pduLog(logfile,"\t\tchannel_id = %u\n",
			domain_pdu->u.channel_join_request.channel_id);
}

/**************************************************************************/
void pduLogChannelJoinConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult:  ");
	PrintPDUResult(logfile,domain_pdu->u.channel_join_confirm.result);
	pduLog(logfile,"\tinitiator userID = %u\n",
				domain_pdu->u.channel_join_confirm.initiator);
	pduLog(logfile,"\trequested channel ID = %u\n",
				domain_pdu->u.channel_join_confirm.requested);
	pduLog(logfile,"\tjoin channel ID = %u\n",
				domain_pdu->u.channel_join_confirm.join_channel_id);
}

/**************************************************************************/
void pduLogChannelLeaveRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tChannel IDs: \n");
	PrintSetOfChannelIDs(logfile, 
						 domain_pdu->u.channel_leave_request.channel_ids);
}

/**************************************************************************/
void pduLogChannelConveneRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator user ID = %u\n",
			domain_pdu->u.channel_convene_request.initiator);
}

/**************************************************************************/
void pduLogChannelConveneConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.channel_convene_confirm.result);
	pduLog(logfile,"\tInitiator user ID = %u\n",
			domain_pdu->u.channel_convene_confirm.initiator);
	pduLog(logfile,"\tPrivate channel ID = %u\n",
			domain_pdu->u.channel_convene_confirm.convene_channel_id);
}

/**************************************************************************/
void pduLogChannelDisbandRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.channel_disband_request.initiator);
	pduLog(logfile,"\tPrivate channel ID = %u\n",
			domain_pdu->u.channel_disband_request.channel_id);
}

/**************************************************************************/
void pduLogChannelDisbandIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tPrivate Channel ID = %u\n",
			domain_pdu->u.channel_disband_indication.channel_id);
}

/**************************************************************************/
void pduLogChannelAdmitRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.channel_admit_request.initiator);
	pduLog(logfile,"\tPrivate Channel ID = %u\n",
			domain_pdu->u.channel_admit_request.channel_id);
	pduLog(logfile,"\tUser IDs Admitted: \n");
	PrintSetOfUserIDs(logfile,domain_pdu->u.channel_admit_request.user_ids);
}

/**************************************************************************/
void pduLogChannelAdmitIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.channel_admit_indication.initiator);
	pduLog(logfile,"\tPrivate Channel ID = %u\n",
			domain_pdu->u.channel_admit_indication.channel_id);
	pduLog(logfile,"\tUser IDs Admitted: \n");
	PrintSetOfUserIDs(logfile,domain_pdu->u.channel_admit_indication.user_ids);
}

/**************************************************************************/
void pduLogChannelExpelRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.channel_expel_request.initiator);
	pduLog(logfile,"\tPrivate Channel ID = %u\n",
			domain_pdu->u.channel_expel_request.channel_id);
	pduLog(logfile,"\tUser IDs Admitted: \n");
	PrintSetOfUserIDs(logfile,domain_pdu->u.channel_expel_request.user_ids);
}

/**************************************************************************/
void pduLogChannelExpelIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tPrivate Channel ID = %u\n",
			domain_pdu->u.channel_expel_indication.channel_id);
	pduLog(logfile,"\tUser IDs Admitted: \n");
	PrintSetOfUserIDs(logfile,domain_pdu->u.channel_expel_indication.user_ids);
}

/**************************************************************************/
void pduLogSendDataRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.send_data_request.initiator);
	pduLog(logfile,"\tChannel ID = %u\n",
			domain_pdu->u.send_data_request.channel_id);
	pduLog(logfile,"\tPriority: ");
	PrintPDUPriority(logfile,domain_pdu->u.send_data_request.data_priority);
	pduLog(logfile,"\tSegmentation: ");
	PrintPDUSegmentation(logfile,domain_pdu->u.send_data_request.segmentation);
	pduLog(logfile,"\tUser Data (%u octets):\n",
			domain_pdu->u.send_data_request.user_data.length);
	pduRawOutput(logfile,
			domain_pdu->u.send_data_request.user_data.value,
			domain_pdu->u.send_data_request.user_data.length);
}

/**************************************************************************/
void pduLogSendDataIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.send_data_indication.initiator);
	pduLog(logfile,"\tChannel ID = %u\n",
			domain_pdu->u.send_data_indication.channel_id);
	pduLog(logfile,"\tPriority: ");
	PrintPDUPriority(logfile,domain_pdu->u.send_data_indication.data_priority);
	pduLog(logfile,"\tSegmentation: ");
	PrintPDUSegmentation(logfile,domain_pdu->u.send_data_indication.segmentation);
	pduLog(logfile,"\tUser Data (%u octets):\n",
			domain_pdu->u.send_data_indication.user_data.length);
	pduRawOutput(logfile,
			domain_pdu->u.send_data_indication.user_data.value,
			domain_pdu->u.send_data_indication.user_data.length);
}

/**************************************************************************/
void pduLogUniformSendDataRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.uniform_send_data_request.initiator);
	pduLog(logfile,"\tChannel ID = %u\n",
			domain_pdu->u.uniform_send_data_request.channel_id);
	pduLog(logfile,"\tPriority: ");
	PrintPDUPriority(logfile,domain_pdu->u.uniform_send_data_request.data_priority);
	pduLog(logfile,"\tSegmentation: ");
	PrintPDUSegmentation(logfile,domain_pdu->u.uniform_send_data_request.segmentation);
	pduLog(logfile,"\tUser Data (%u octets):\n",
			domain_pdu->u.uniform_send_data_request.user_data.length);
	pduRawOutput(logfile,
			domain_pdu->u.uniform_send_data_request.user_data.value,
			domain_pdu->u.uniform_send_data_request.user_data.length);
}

/**************************************************************************/
void pduLogUniformSendDataIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.uniform_send_data_indication.initiator);
	pduLog(logfile,"\tChannel ID = %u\n",
			domain_pdu->u.uniform_send_data_indication.channel_id);
	pduLog(logfile,"\tPriority: ");
	PrintPDUPriority(logfile,domain_pdu->u.uniform_send_data_indication.data_priority);
	pduLog(logfile,"\tSegmentation: ");
	PrintPDUSegmentation(logfile,domain_pdu->u.uniform_send_data_indication.segmentation);
	pduLog(logfile,"\tUser Data (%u octets):\n",
			domain_pdu->u.uniform_send_data_indication.user_data.length);
	pduRawOutput(logfile,
			domain_pdu->u.uniform_send_data_indication.user_data.value,
			domain_pdu->u.uniform_send_data_indication.user_data.length);
}

/**************************************************************************/
void pduLogTokenGrabRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_grab_request.initiator);
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_grab_request.token_id);
}

/**************************************************************************/
void pduLogTokenGrabConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.token_grab_confirm.result);
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_grab_confirm.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_grab_confirm.token_id);
	PrintTokenStatus(logfile,domain_pdu->u.token_grab_confirm.token_status);
}

/**************************************************************************/
void pduLogTokenInhibitRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_inhibit_request.initiator);
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_inhibit_request.token_id);
}

/**************************************************************************/
void pduLogTokenInhibitConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.token_inhibit_confirm.result);
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_inhibit_confirm.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_inhibit_confirm.token_id);
	PrintTokenStatus(logfile,domain_pdu->u.token_inhibit_confirm.token_status);
}

/**************************************************************************/
void pduLogTokenGiveRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_give_request.initiator);
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_give_request.token_id);
	pduLog(logfile,"\tRecipient User ID = %u\n",
			domain_pdu->u.token_give_request.recipient);
}

/**************************************************************************/
void pduLogTokenGiveIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_give_indication.initiator);
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_give_indication.token_id);
	pduLog(logfile,"\tRecipient User ID = %u\n",
			domain_pdu->u.token_give_indication.recipient);
}

/**************************************************************************/
void pduLogTokenGiveResponse(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.token_give_response.result);
	pduLog(logfile,"\tRecipient User ID = %u\n",
			domain_pdu->u.token_give_response.recipient);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_give_response.token_id);
}	

/**************************************************************************/
void pduLogTokenGiveConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.token_give_confirm.result);
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_give_confirm.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_give_confirm.token_id);
	PrintTokenStatus(logfile,domain_pdu->u.token_give_confirm.token_status);
}	

/**************************************************************************/
void pduLogTokenPleaseRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_please_request.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_please_request.token_id);
}

/**************************************************************************/
void pduLogTokenPleaseIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_please_indication.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_please_indication.token_id);
}

/**************************************************************************/
void pduLogTokenReleaseRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_release_request.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_release_request.token_id);
}

/**************************************************************************/
void pduLogTokenReleaseConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.token_release_confirm.result);
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_release_confirm.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_release_confirm.token_id);
	PrintTokenStatus(logfile,domain_pdu->u.token_release_confirm.token_status);
}

/**************************************************************************/
void pduLogTokenTestRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_test_request.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_test_request.token_id);
}

/**************************************************************************/
void pduLogTokenTestConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_test_confirm.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_test_confirm.token_id);
	PrintTokenStatus(logfile,domain_pdu->u.token_test_confirm.token_status);
}	


//****************************************************************/
/****
 **** Service Functions for logging PDU structures.
 ****/

/**************************************************************************/
void PrintSetOfUserIDs(FILE *logfile, PSetOfUserIDs user_ids)
{
	unsigned int i = 0;
	for(i=0; user_ids!=NULL; i++)
	{
		pduLog(logfile, "\t\trecord[%u] = %u\n",i,user_ids->value);
		user_ids = user_ids->next;
	}
}

/**************************************************************************/
void PrintSetOfTokenAttributes(FILE *logfile, 
							   PSetOfPDUTokenAttributes token_attribute_obj)
{
	unsigned int i = 0;
	for(i=0; token_attribute_obj!=NULL;i++)
	{
		pduLog(logfile,"\t**** record [%u] ****\n",i);
		PrintTokenAttributes(logfile, token_attribute_obj->value);
		token_attribute_obj = token_attribute_obj->next;
	}
}

/**************************************************************************/
void PrintSetOfChannelIDs(FILE *logfile, PSetOfChannelIDs channel_ids)
{
	unsigned int i = 0;
	for(i=0; channel_ids!=NULL; i++)
	{
		pduLog(logfile, "\t\trecord[%u] = %u\n",i,channel_ids->value);
		channel_ids = channel_ids->next;
	}
}

/**************************************************************************/
void PrintSetOfTokenIDs(FILE *logfile, PSetOfTokenIDs token_ids)
{
	unsigned int i = 0;
	for(i=0; token_ids!=NULL; i++)
	{
		pduLog(logfile, "\t\trecord[%u] = %u\n",i,token_ids->value);
		token_ids = token_ids->next;
	}
}

/**************************************************************************/
void PrintChannelAttributes(FILE *logfile, PDUChannelAttributes channel_attributes)
{
	switch(channel_attributes.choice)
	{
	case CHANNEL_ATTRIBUTES_STATIC_CHOSEN:
		pduLog(logfile, "\tStatic Channel Attributes:\n");
		pduLog(logfile, "\t\tchannel_id = %u\n",
					channel_attributes.u.channel_attributes_static.channel_id);
		break;
	case CHANNEL_ATTRIBUTES_USER_ID_CHOSEN: 
		pduLog(logfile, "\tUser ID Channel Attributes:\n");
		PrintT120Boolean(logfile, "\t\tjoined",
							(BOOL) channel_attributes.u.channel_attributes_user_id.joined);
		pduLog(logfile, "\t\tuser_id = %u\n",
							channel_attributes.u.channel_attributes_user_id.user_id);
		break;
	case CHANNEL_ATTRIBUTES_PRIVATE_CHOSEN:
		pduLog(logfile,"\tPrivate Channel Attributes:\n");
		PrintT120Boolean(logfile, "\t\tjoined",
							(BOOL) channel_attributes.u.channel_attributes_private.joined);
		pduLog(logfile,"\t\tchannel_id = %u\n",
							channel_attributes.u.channel_attributes_private.channel_id);
		pduLog(logfile,"\t\tmanager = %u\n",
							channel_attributes.u.channel_attributes_private.manager);
		PrintSetOfUserIDs(logfile, channel_attributes.u.channel_attributes_private.admitted);
		break;
	case CHANNEL_ATTRIBUTES_ASSIGNED_CHOSEN:
		pduLog(logfile,"\tAssigned Channel Attributes\n");
		pduLog(logfile,"\t\tchannel_id = %u\n",
						channel_attributes.u.channel_attributes_assigned.channel_id);
		break;
	default:
		pduLog(logfile,"\tERROR -- canot figure out channel attributes\n");
		break;
	}
}

/**************************************************************************/
void PrintTokenAttributes(FILE *logfile, PDUTokenAttributes token_attributes)
{
	switch(token_attributes.choice)
	{
	case GRABBED_CHOSEN:
		pduLog(logfile,"\tGrabbed Token Attributes:\n");
		pduLog(logfile,"\t\ttoken_id = %u\n",
				token_attributes.u.grabbed.token_id);
		pduLog(logfile,"\t\tgrabber = %u\n",
				token_attributes.u.grabbed.grabber);
		break;
	case INHIBITED_CHOSEN:
		pduLog(logfile,"\tInhibited Token Attributes:\n");
		pduLog(logfile,"\t\ttoken_id = %u\n",
				token_attributes.u.inhibited.token_id);
		pduLog(logfile,"\t\tInhibitors:\n");
		PrintSetOfUserIDs(logfile,token_attributes.u.inhibited.inhibitors);
		break;
	case GIVING_CHOSEN:
		pduLog(logfile,"\tGiving Token Attributes:\n");
		pduLog(logfile,"\t\ttoken_id = %u\n",
				token_attributes.u.giving.token_id);
		pduLog(logfile,"\t\tgrabber = %u\n",
				token_attributes.u.giving.grabber);
		pduLog(logfile,"\t\trecipient = %u\n",
				token_attributes.u.giving.recipient);
		break;
	case UNGIVABLE_CHOSEN:
		pduLog(logfile,"\tUngivable Token Attributes:\n");
		pduLog(logfile,"\t\ttoken_id = %u\n",
				token_attributes.u.ungivable.token_id);
		pduLog(logfile,"\t\tgrabber = %u\n",
				token_attributes.u.ungivable.grabber);
		break;
	case GIVEN_CHOSEN:
		pduLog(logfile,"\tGiven Token Attributes:\n");
		pduLog(logfile,"\t\ttoken_id = %u\n",
				token_attributes.u.given.token_id);
		pduLog(logfile,"\t\trecipient = %u\n",
				token_attributes.u.given.recipient);
		break;
	default:
		pduLog(logfile,"ERROR: cannot determine token attributes\n");
		break;
	}
}

/**************************************************************************/
void PrintPDUDomainParameters(FILE *logfile, PDUDomainParameters domain_params)
{
	pduLog(logfile,"\t\tmax_channel_ids = %u \n",domain_params.max_channel_ids);
	pduLog(logfile,"\t\tmax_user_ids = %u\n",domain_params.max_user_ids);
	pduLog(logfile,"\t\tmax_token_ids = %u\n",domain_params.max_token_ids);
	pduLog(logfile,"\t\tnumber_priorities = %u\n",domain_params.number_priorities);
	pduLog(logfile,"\t\tmin_throughput = %u\n",domain_params.min_throughput);
	pduLog(logfile,"\t\tmax_height = %u\n",domain_params.max_height);
	pduLog(logfile,"\t\tmax_mcspdu_size = %u\n",domain_params.max_mcspdu_size);
	pduLog(logfile,"\t\tprotocol_version = %u\n",domain_params.protocol_version);
}

/**************************************************************************/
void PrintT120Boolean(	FILE *	logfile,
						Char *	print_text,
						BOOL	T120Boolean)
{
	if( T120Boolean == FALSE )
		pduLog(	logfile, "%s = FALSE\n", print_text );
	else
		pduLog(	logfile, "%s = TRUE\n", print_text );
}

/************************************************************************/
BOOL CopyTextToChar(char * print_string,
					       unsigned short * text_string_value,
						   unsigned int text_string_length)
{
	UShort  i;
	
	if(print_string==NULL)
		return(FALSE);

	if((text_string_length <= 0)||(text_string_value == NULL))
		return( FALSE );

	if (*text_string_value == 0x0000)
		return (FALSE);

	for(i=0;i < text_string_length;i++)
	{
		//if((&text_string_value[i]==NULL) || (text_string_value[i]==0x0000))
		//	break;
		print_string[i] = (char) text_string_value[i];
	
	}
	print_string[text_string_length] = '\0';
	
	return(TRUE);
}
/********************************************************************/


#endif //// PDULOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\mcsuser.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	mcsuser.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implemntation file for the MCSUser class. It implements
 *		functions responsible for encoding out bound indirect conference
 *		join request and response PDUs, and also Send user ID Requests. All
 *		these PDUs are encapsulated in user data field of MCSSendDataRequest.
 *		Also this file implements functions that are responsible for decoding
 *		incoming indications and confirm PDUs which are encapsulated in the
 *		user data field of MCSSendDataIndication. Functions responsible for
 *		joining different channels are also implemented in this module.
 *
 *		SEE THE INTERFACE FILE FOR A MORE DETAILED DESCRIPTION OF THIS CLASS.
 *
 *	Private Instance Variables
 *		m_pMCSSap
 *			This is the MCS User handle handed back from the MCS Attache User
 *			Request.
 *		m_nidMyself
 *			The is the MCS User ID returned in the Attach User Confirm.  This
 *			is also refered to as the Node ID with in GCC.
 *		m_nidTopProvider
 *			This holds the MCS User ID (or Node ID) for the top Provider.
 *		m_nidParent
 *			This holds the MCS User ID (or Node ID) for this nodes parent node.
 *		m_fEjectionPending
 *			This flag indicates if an ejection of this node is pending.
 *		m_eEjectReason
 *			This variable holds the reason for ejection until the eject
 *			indication can be delivered after all child nodes have disconnected.
 *		m_pOwnerConf
 *			Pointer to the object that will receive all the owner callbacks
 *			from the user object (typically the conference object).
 *		m_ChannelJoinedFlags
 *			A structure of flags used to keep up with creation state machine.
 *			Basically, it keeps up with which channels have been joined and
 *			which ones have not.
 *		m_ChildUidConnHdlList2
 *			Keeps mapping of child Node IDs to child logical connection
 *			handles.
 *		m_OutgoingPDUQueue
 *			This is a rogue wave list used to queue up all outgoing PDUs.
 *		m_ConfJoinResponseList2
 *			This rogue wave list holds information needed to send back in a join
 *			response after the local node controller responds.
 *		m_EjectedNodeAlarmList2
 *			This list holds alarm objects for all the nodes that have been
 *			ejected and are directly connected to this node.  The alarm is
 *			used to disconnect any misbehaving nodes that do not disconnect
 *			after the EJECTED_NODE_TIMER_DURATION.
 *		m_EjectedNodeList
 *			This list keeps up with nodes that have been ejected but are NOT
 *			directly connected to this node.  We save these nodes so that
 *			a correct reason for disconnecting (user ejected) can be issued
 *			when the detch user indication comes in.
 * 		
 *	Author:
 *		blp
 */

#include "mcsuser.h"
#include "mcsdllif.h"
#include "ogcccode.h"
#include "conf.h"
#include "translat.h"
#include "gcontrol.h"

//	Static Channel and Token ID definitions used by the MCS user object.
#define		BROADCAST_CHANNEL_ID	1
#define		CONVENER_CHANNEL_ID 	2
#define		CONDUCTOR_TOKEN_ID		1

//	Time given to allow an ejected node to disconnect before it is disconnected
#define	EJECTED_NODE_TIMER_DURATION		10000	//	Duration in milliseconds


extern MCSDLLInterface     *g_pMCSIntf;

/*
 *	This is a global variable that has a pointer to the one GCC coder that
 *	is instantiated by the GCC Controller.  Most objects know in advance
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
extern CGCCCoder	*g_GCCCoder;

/*
 *	MCSUser ()
 *
 *	Public Function Description
 *		This is the MCSUser object constructor.  It is responsible for
 *		initializing all the instance variables used by this class.  The
 *		constructor is responsible for establishing the user attachment to
 *		the MCS domain defined by the conference ID.  It also kicks off the
 *		process of joining all the appropriate channels.
 */
MCSUser::
MCSUser(CConf                   *pConf,
		GCCNodeID				nidTopProvider,
		GCCNodeID				nidParent,
		PGCCError				return_value)
:
    CRefCount(MAKE_STAMP_ID('M','U','s','r')),
	m_ChildUidConnHdlList2(),
	m_EjectedNodeAlarmList2(),
	m_EjectedNodeList(),
	m_pConf(pConf),
	m_nidTopProvider(nidTopProvider),
	m_nidParent(nidParent),
	m_nidMyself(NULL),
	m_fEjectionPending(FALSE)
{
    MCSError        mcs_rc;
    GCCConfID       nConfID = pConf->GetConfID();

	//	No channels are joined initially
	m_ChannelJoinedFlags.user_channel_joined = FALSE;
	m_ChannelJoinedFlags.broadcast_channel_joined = FALSE;
	m_ChannelJoinedFlags.convener_channel_joined = FALSE;
	m_ChannelJoinedFlags.channel_join_error = FALSE;

	mcs_rc = g_pMCSIntf->AttachUserRequest(&nConfID, &m_pMCSSap, this);
    if (MCS_NO_ERROR != mcs_rc)
	{
		WARNING_OUT(("MCSUser::MCSUser: Failure in attach user req, "));
		*return_value = GCC_FAILURE_ATTACHING_TO_MCS;
	}
	else
    {
		*return_value = GCC_NO_ERROR;
    }
 }

/*
 *	~MCSUser ()
 *
 *	Public Function Description
 *		This is the user destructor. It takes care of leaving channels
 *		joined by the user object. Also it detaches the user attachment
 *	 	with MCS by issuing a detach user request.
 */
MCSUser::~MCSUser(void)
{
	//	Clean up the Ejected Node Alarm List
	PAlarm				lpAlarm;
	while (NULL != (lpAlarm = m_EjectedNodeAlarmList2.Get()))
    {
		delete lpAlarm;
    }

	if(m_ChannelJoinedFlags.user_channel_joined)
    {
		g_pMCSIntf->ChannelLeaveRequest(m_nidMyself, m_pMCSSap);
    }

	if(m_ChannelJoinedFlags.broadcast_channel_joined)
    {
		g_pMCSIntf->ChannelLeaveRequest(BROADCAST_CHANNEL_ID, m_pMCSSap);
    }

	if(m_ChannelJoinedFlags.convener_channel_joined)
    {
		g_pMCSIntf->ChannelLeaveRequest(CONVENER_CHANNEL_ID, m_pMCSSap);
    }

    //	Empty the queue of all PDUs
	SEND_DATA_REQ_INFO *pReqInfo;
	m_OutgoingPDUQueue.Reset();
	while (NULL != (pReqInfo = m_OutgoingPDUQueue.Iterate()))
	{
		pReqInfo->packet->Unlock();
		delete pReqInfo;
	}

	g_pMCSIntf->DetachUserRequest(m_pMCSSap, this);
}

/*
 *	UINT	ProcessAttachUserConfirm ()
 *
 *	Private Function Description
 *		This function is called when the user object gets an attach user
 *		confirm from MCS in response to an attach user request made by the
 *		user object in it's constructor. The function checks the result
 *		indicated in the confirm. If the result is a successful attachment, then
 *		different channels depending upon the type of the provider, are joined.
 *		Also this function reports failures in attach user (as indicated by
 *		result in attach user confirm) and channel joins, to the conference
 *		through an owner callback.
 *
 *	Formal Parameters:
 *		result		-	(i)	Result of the attach user request.
 *		user_id		-	(i)	This nodes user or Node ID if successful result.
 *
 *	Return Value
 *		MCS_NO_ERROR	-	No error is always returned.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
UINT MCSUser::ProcessAttachUserConfirm(Result result, UserID user_id)
{
	UINT					rc;

	if (result == RESULT_SUCCESSFUL)
	{
		m_nidMyself = user_id;

		/*
		**	After the attach confirm is received we go ahead and join the
		**	appropriate channel based on the conf node type. If this
		**	node is the yop provider we also set up the top provider user id,
		**	otherwise this gets set up in the constructor.
		*/
		switch (m_pConf->GetConfNodeType())
		{
		case TOP_PROVIDER_NODE:
            m_nidTopProvider = m_nidMyself;
			rc = JoinUserAndBroadCastChannels();
			break;

        case JOINED_CONVENER_NODE:
		case CONVENER_NODE:
			rc = JoinUserAndBroadCastChannels();
			if(rc == MCS_NO_ERROR)
            {
				rc = JoinConvenerChannel();
            }
			break;

        case TOP_PROVIDER_AND_CONVENER_NODE:
			m_nidTopProvider = m_nidMyself;
			rc = JoinUserAndBroadCastChannels();
			if(rc == MCS_NO_ERROR)
            {
				rc = JoinConvenerChannel();	
            }
			break;

        case JOINED_NODE:
		case INVITED_NODE:
			rc = JoinUserAndBroadCastChannels();
			break;

        default:
			ERROR_OUT(("User::ProcessAttachUserConfirm: Bad Node Type, %u", (UINT) m_pConf->GetConfNodeType()));
			break;
		}
		
		if (rc != MCS_NO_ERROR)
		{
			/*
			 * ChannelJoinRequestFailed at some level in MCS
			 * So this message tells the conferenceabout this
			 * failure. Conference will delete the user object
			 * as a result of this
			 */
			m_pConf->ProcessUserCreateConfirm(USER_CHANNEL_JOIN_FAILURE, m_nidMyself);
		}
	}
	else
	{
		/*
		 * Attach user request failed as indicated by the result field in the
		 * confirm message, because of any of the following causes:
		 * congested, domain disconnected, no such domain, too many channels,
		 * too many users, unspecified failure. In this case the user object
		 * just sends the conference a GCC_USER_ATTACH_FAILURE ( to be defined
		 * in command target.h) , which causes
		 * the conference object to delete the user attachment.
		 * UserCreateConfirm message is not corresponding exectly to a single
		 * primitive.
		 */
	    WARNING_OUT(("MCSUser::ProcessAttachUserConfirm: ATTACH FAILED"));
		m_pConf->ProcessUserCreateConfirm(USER_ATTACH_FAILURE, m_nidMyself);
	}

	return (MCS_NO_ERROR);
}

/*
 *	MCSError	JoinUserAndBroadCastChannels()
 *
 *	Private Function Description
 *		This function is called by user object when it gets a successful
 *		attach user confrim, to join user id and broadcast channels.
 *		If the channel join requests fail, it returns the appropriate MCS
 *		Error.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		See return values for mcs channel jon request.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

MCSError	MCSUser::JoinUserAndBroadCastChannels()
{
	MCSError		rc;

	rc = g_pMCSIntf->ChannelJoinRequest(m_nidMyself, m_pMCSSap);
	if(rc == MCS_NO_ERROR)

	{
		rc = g_pMCSIntf->ChannelJoinRequest(BROADCAST_CHANNEL_ID, m_pMCSSap);
	}

	return (rc);
}

/*
 *	MCSError	JoinUserAndBroadCastChannels()
 *
 *	Private Function Description
 *		This function is called by user object of a convener gcc provider
 *		when it gets a successful attach user confrim, to join convener
 *	 	channel. If the channel join requests fail, it returns the appropriate
 *		MCS	Error.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		See return values for mcs channel jon request.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
MCSError	MCSUser::JoinConvenerChannel()
{
	return g_pMCSIntf->ChannelJoinRequest(CONVENER_CHANNEL_ID, m_pMCSSap);
}

/*
 *	UINT	ProcessChannelJoinConfirm()
 *
 *	Private Function Description
 *		This function is called when the user object gets an channel join
 *		confirm from MCS in response to channel join requests made by the
 *		user object. If a channel is joined successfully as indicated by
 *		the result in the confirm, a channel joined flag corresponding to
 *		that channel id is set. This flag indicates as to which channels a
 *		user object is joined at any given time. Also after setting this
 *		flag the functions checks to see if all tke required channels based
 *		on the type of gcc provider, are joined. If all required channels are
 *		joined the conference object is informaed about it via an owner call-
 *		back (USER_CREATE_CONFIRM).	
 *
 *	Formal Parameters:
 *		result		-	(i)	Result of the channel join request.
 *		channel_id	-	(i)	Channel ID that this confirm pertains to.
 *
 *	Return Value
 *		MCS_NO_ERROR is always returned.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
UINT MCSUser::ProcessChannelJoinConfirm(Result result, ChannelID channel_id)
{
	if (m_ChannelJoinedFlags.channel_join_error == FALSE)
	{
		if (result == RESULT_SUCCESSFUL)
		{
			if( channel_id == m_nidMyself)
            {
				m_ChannelJoinedFlags.user_channel_joined = TRUE;
            }
			else
			{
				switch (channel_id)
				{	
				case CONVENER_CHANNEL_ID:
					m_ChannelJoinedFlags.convener_channel_joined = TRUE;
					break;	

                case BROADCAST_CHANNEL_ID:
					m_ChannelJoinedFlags.broadcast_channel_joined = TRUE;
					break;
				}
			}

			/*
			**	If all the channels are joined we inform the owner object that
			**	the user object was successfully created.
			*/
			if (AreAllChannelsJoined())
			{
				m_pConf->ProcessUserCreateConfirm(USER_RESULT_SUCCESSFUL, m_nidMyself);
			}
		}
		else
		{
			WARNING_OUT(("MCSUser::ProcessChannelJoinConfirm: Error joining channel, result=%u", (UINT) result));

			m_ChannelJoinedFlags.channel_join_error = TRUE ;

			m_pConf->ProcessUserCreateConfirm(USER_CHANNEL_JOIN_FAILURE, m_nidMyself);
		}
	}

	return (MCS_NO_ERROR);
}

/*
 *	BOOL	AreAllChannelsJoined()
 *
 *	Public Function Description
 *		This function is called to check if all tke required channels based
 *		on the type of gcc provider, are joined. It returns true if all
 *		required channels are joined and false otherwise. This function uses
 *		different channel joined flags to check which channels the given user
 *		object is joined to.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	If all channels are joined.
 *		FALSE	-	If all the channels are not joined.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
BOOL MCSUser::AreAllChannelsJoined(void)
{
	BOOL rc = FALSE;
	
	switch (m_pConf->GetConfNodeType())
	{
		case TOP_PROVIDER_NODE:
			if ((m_ChannelJoinedFlags.user_channel_joined) &&
				(m_ChannelJoinedFlags.broadcast_channel_joined))
			{
				rc = TRUE;
			}
			break;
			
		case JOINED_CONVENER_NODE:
		case CONVENER_NODE:
			if ((m_ChannelJoinedFlags.convener_channel_joined) &&
				(m_ChannelJoinedFlags.user_channel_joined) &&
				(m_ChannelJoinedFlags.broadcast_channel_joined))
			{
				rc = TRUE;
			}
			break;
							
		case TOP_PROVIDER_AND_CONVENER_NODE:
   			if ((m_ChannelJoinedFlags.convener_channel_joined) &&
				(m_ChannelJoinedFlags.user_channel_joined) &&
				(m_ChannelJoinedFlags.broadcast_channel_joined))
			{
				rc = TRUE;
			}
			break;
	
		case JOINED_NODE:
		case INVITED_NODE:
	   		if( (m_ChannelJoinedFlags.user_channel_joined) &&
				(m_ChannelJoinedFlags.broadcast_channel_joined))
			{
				rc = TRUE;
			}
			break;
	}

	return rc;
} 					

/*
 *	void	SendUserIDRequest()
 *
 *	Public Function Description:
 *		This request originates from the conference object. Conference object
 *		sends the sequence number obtained in the conference create confirm
 *		or conference join confirm to the parent GCC provider on the parent
 *		gcc provider's UserId channel. The pdu is encoded here and is
 *		queued to be sent during the next heartbeat.
 */
void MCSUser::SendUserIDRequest(TagNumber tag_number)
{
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the UserIDIndication pdu structure to be passed in the
	**	constructor of the packet class.
	*/

	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = USER_ID_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.user_id_indication.tag = tag_number;

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,					
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, m_nidParent, TOP_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
    }
}

/*
 *	GCCError	ConferenceJoinRequest()
 *
 *	Public Function Description:
 * 		This call is made by the conference object of the intermediate node
 *  	to forward the conference join request over to the top provider. This
 *		function encodes the conference join request pdu and queues it to be
 *		sent in the next heartbeat.
 *
 *	Caveats
 *		The connection handle is used here for a TAG and should be passed back
 *		to the owner object when the join response comes in.
 */
GCCError MCSUser::ConferenceJoinRequest(
									CPassword           *convener_password,
									CPassword           *password_challenge,
									LPWSTR				pwszCallerID,
									CUserDataListContainer *user_data_list,
									ConnectionHandle	connection_handle)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = CONFERENCE_JOIN_REQUEST_CHOSEN;
   	gcc_pdu.u.request.u.conference_join_request.tag = (TagNumber)connection_handle;
	gcc_pdu.u.request.u.conference_join_request.bit_mask = TAG_PRESENT;

	//	Insert the convener password into the ASN.1 structure
	if (convener_password != NULL)
	{
		rc = convener_password->GetPasswordSelectorPDU(
				&gcc_pdu.u.request.u.conference_join_request.cjrq_convener_password);
		if (rc == GCC_NO_ERROR)
		{
			gcc_pdu.u.request.u.conference_join_request.bit_mask |= CJRQ_CONVENER_PASSWORD_PRESENT;
		}
	}

    //	Insert the password challenge into the ASN.1 structure
	if (( password_challenge != NULL ) && (rc == GCC_NO_ERROR))
	{
		rc = password_challenge->GetPasswordChallengeResponsePDU (
								&gcc_pdu.u.request.u.conference_join_request.
									cjrq_password);
									
		if (rc == GCC_NO_ERROR)
		{
			gcc_pdu.u.request.u.conference_join_request.bit_mask |=
												CJRQ_PASSWORD_PRESENT;
		}
	}

	//	Insert the caller identifier into the ASN.1 structure
	UINT cchCallerID = ::My_strlenW(pwszCallerID);
	if ((cchCallerID != 0 ) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.request.u.conference_join_request.cjrq_caller_id.value = pwszCallerID;
		gcc_pdu.u.request.u.conference_join_request.cjrq_caller_id.length = cchCallerID;
		gcc_pdu.u.request.u.conference_join_request.bit_mask |= CJRQ_CALLER_ID_PRESENT;
	}
	
 	//	Insert the user data into the ASN.1 structure
	if (( user_data_list != NULL ) && (rc == GCC_NO_ERROR))
	{
		rc = user_data_list->GetUserDataPDU (
								&gcc_pdu.u.request.u.conference_join_request.cjrq_user_data);
		if (rc == GCC_NO_ERROR)
		{
			gcc_pdu.u.request.u.conference_join_request.bit_mask |= CJRQ_USER_DATA_PRESENT;
		}
	}

	if (rc == GCC_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					  		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
    		AddToMCSMessageQueue(packet, m_nidTopProvider, TOP_PRIORITY, FALSE);
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
		}
	}
	
	//	Cleanup after any errors
	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
	
	return rc;
}

/*
 *	GCCError	SendConferenceLockRequest()
 *
 *	Public Function Description:
 *		This function is invoked by the owner object to send a conference lock
 *		request PDU to the top provider.
 */
GCCError MCSUser::SendConferenceLockRequest()
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;

	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = CONFERENCE_LOCK_REQUEST_CHOSEN;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConferenceLockResponse()
 *
 *	Public Function Description:
 *		This function is invoked by the owner object to send a conference lock
 *		response PDU to the requesting node.
 */
GCCError	MCSUser::SendConferenceLockResponse (
									UserID		source_node,
									GCCResult	result)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;

	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = CONFERENCE_LOCK_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.conference_lock_response.result =
							::TranslateGCCResultToLockResult(result);

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, source_node, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConferenceUnlockRequest()
 *
 *	Public Function Description:
 *		This function is invoked by the owner object to send a conference unlock
 *		request PDU to the top provider.
 */
GCCError	MCSUser::SendConferenceUnlockRequest ()
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;

	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = CONFERENCE_UNLOCK_REQUEST_CHOSEN;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConferenceUnlockResponse()
 *
 *	Public Function Description:
 *		This function is invoked by the owner object to send a conference unlock
 *		response PDU to the requesting node.
 */
GCCError	MCSUser::SendConferenceUnlockResponse (
									UserID		source_node,
									GCCResult	result)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;

	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = CONFERENCE_UNLOCK_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.conference_unlock_response.result =
							::TranslateGCCResultToUnlockResult(result);

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, source_node, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConferenceLockIndication()
 *
 *	Public Function Description:
 *		This function is invoked by the owner object of the top provider
 *		to send a conference lock indication PDU to one or all other nodes
 *		that are registered in the conference.
 */
GCCError	MCSUser::SendConferenceLockIndication(
									BOOL		uniform_send,
									UserID		source_node)
{
	GCCError 				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_LOCK_INDICATION_CHOSEN;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(
			        packet,
			        uniform_send ? BROADCAST_CHANNEL_ID : source_node,
			        HIGH_PRIORITY,
			        uniform_send);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConferenceUnlockIndication()
 *
 *	Public Function Description:
 *		This function is invoked by the owner object of the top provider
 *		to send a conference unlock indication PDU to one or all other nodes
 *		that are registered in the conference.
 */
GCCError MCSUser::SendConferenceUnlockIndication(
									BOOL		uniform_send,
									UserID		source_node)
{
	GCCError 				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_UNLOCK_INDICATION_CHOSEN;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(
                    packet,
                    uniform_send ? BROADCAST_CHANNEL_ID : source_node,
                    HIGH_PRIORITY,
                    uniform_send);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/******************************* Registry Calls ******************************/

/*
 *	void	RegistryRegisterChannelRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to register a channel in
 *		the application registry.
 */
void	MCSUser::RegistryRegisterChannelRequest(
									CRegKeyContainer        *registry_key_data,
									ChannelID				channel_id,
									EntityID				entity_id)
{
	GCCError				error_value;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_REGISTER_CHANNEL_REQUEST_CHOSEN;

	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    					&gcc_pdu.u.request.u.
			    						registry_register_channel_request.key);
							
	if (error_value == GCC_NO_ERROR)
	{
		gcc_pdu.u.request.u.registry_register_channel_request.channel_id =
																	channel_id;
		gcc_pdu.u.request.u.registry_register_channel_request.entity_id =
																	entity_id;

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					  		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
		{
			ERROR_OUT(("MCSUser::RegistryRegisterChannelRequest: Error creating packet"));
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
		}

		registry_key_data->FreeRegistryKeyDataPDU();
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	MCSUser::RegistryAssignTokenRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to register a token in
 *		the application registry.  Note that there is no token ID included in
 *		this request.  The token ID is allocated at the top provider.
 */
void	MCSUser::RegistryAssignTokenRequest (	
										CRegKeyContainer    *registry_key_data,
										EntityID			entity_id)
{
	GCCError				error_value;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
		
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_ASSIGN_TOKEN_REQUEST_CHOSEN;
	
	
	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    					&gcc_pdu.u.request.u.
			    					registry_assign_token_request.registry_key);
							
	if (error_value == GCC_NO_ERROR)
	{
		gcc_pdu.u.request.u.registry_assign_token_request.entity_id = entity_id;

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					 		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
		{
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
		}

		registry_key_data->FreeRegistryKeyDataPDU();
	}
		
	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	RegistrySetParameterRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to register a parameter in
 *		the application registry.  Note that parameter to be registered is
 *		included in this request.
 */
void	MCSUser::RegistrySetParameterRequest (
							CRegKeyContainer        *registry_key_data,
							LPOSTR			        parameter_value,
							GCCModificationRights	modification_rights,
							EntityID				entity_id)
{
	GCCError				error_value;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_SET_PARAMETER_REQUEST_CHOSEN;
	gcc_pdu.u.request.u.registry_set_parameter_request.bit_mask = 0;
	
	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    			&gcc_pdu.u.request.u.
			    				registry_set_parameter_request.key);

	if (error_value == GCC_NO_ERROR)
	{
		if (parameter_value != NULL)
		{
			gcc_pdu.u.request.u.registry_set_parameter_request.
				registry_set_parameter.length =
					parameter_value->length;
					
			memcpy (gcc_pdu.u.request.u.registry_set_parameter_request.
						registry_set_parameter.value,
					parameter_value->value,
					parameter_value->length);
		}
		else
		{
			gcc_pdu.u.request.u.registry_set_parameter_request.
				registry_set_parameter.length = 0;
		}

		gcc_pdu.u.request.u.registry_set_parameter_request.entity_id =
																	entity_id;

		//	Set up the modification rights here if it exists
		if (modification_rights != GCC_NO_MODIFICATION_RIGHTS_SPECIFIED)
		{
			gcc_pdu.u.request.u.registry_set_parameter_request.bit_mask |=
											PARAMETER_MODIFY_RIGHTS_PRESENT;
			
			gcc_pdu.u.request.u.registry_set_parameter_request.
						parameter_modify_rights =
							(RegistryModificationRights)modification_rights;
		}

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					 		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
		{
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
		}

		registry_key_data->FreeRegistryKeyDataPDU();
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	RegistryRetrieveEntryRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to retrieve an registry item
 *		from the registry.
 */
void	MCSUser::RegistryRetrieveEntryRequest (
										CRegKeyContainer    *registry_key_data,
										EntityID			entity_id)
{
	GCCError				error_value;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_RETRIEVE_ENTRY_REQUEST_CHOSEN;
	
	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    					&gcc_pdu.u.request.u.
			    						registry_retrieve_entry_request.key);
	if (error_value == GCC_NO_ERROR)
	{
		gcc_pdu.u.request.u.registry_retrieve_entry_request.entity_id =
																	entity_id;

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					  		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
		{
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
		}
	
		registry_key_data->FreeRegistryKeyDataPDU();
	}
	else
		error_value = GCC_ALLOCATION_FAILURE;

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
    }
}

/*
 *	void	RegistryDeleteEntryRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to delete a registry item
 *		from the registry.
 */
void	MCSUser::RegistryDeleteEntryRequest (	
										CRegKeyContainer    *registry_key_data,
										EntityID			entity_id)
{
	GCCError				error_value;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_DELETE_ENTRY_REQUEST_CHOSEN;

	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    					&gcc_pdu.u.request.u.
			    						registry_delete_entry_request.key);

	if (error_value == GCC_NO_ERROR)
	{
		gcc_pdu.u.request.u.registry_delete_entry_request.entity_id = entity_id;

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					   		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
		{
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
		}

		registry_key_data->FreeRegistryKeyDataPDU();
	}
	
	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	RegistryMonitorRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to monitor a registry item
 *		in the registry.
 */
void		MCSUser::RegistryMonitorRequest (	
						CRegKeyContainer        *registry_key_data,
						EntityID				entity_id)
{
	GCCError				error_value;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_MONITOR_ENTRY_REQUEST_CHOSEN;
	
	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    					&gcc_pdu.u.request.u.
			    						registry_monitor_entry_request.key);
							
	if (error_value == GCC_NO_ERROR)
	{
		gcc_pdu.u.request.u.registry_monitor_entry_request.entity_id= entity_id;

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					   		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
		{
			error_value = GCC_ALLOCATION_FAILURE; 	
		    delete packet;
		}

		registry_key_data->FreeRegistryKeyDataPDU();
	}
	
	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	RegistryAllocateHandleRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to allocate a number of
 *		handles from the application registry.
 */
void MCSUser::RegistryAllocateHandleRequest(
						UINT					number_of_handles,
						EntityID				entity_id )
{
	GCCError				error_value = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_ALLOCATE_HANDLE_REQUEST_CHOSEN;
	
	gcc_pdu.u.request.u.registry_allocate_handle_request.number_of_handles = (USHORT) number_of_handles;
	gcc_pdu.u.request.u.registry_allocate_handle_request.entity_id= entity_id;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
					   	PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
	}
	else
	{
		error_value = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	RegistryAllocateHandleResponse()
 *
 *	Public Function Description:
 *		This routine is used by the Top Provider to respond to an allocate
 *		handle request from an APE at a remote node.  The allocated handles
 *		are passed back here.
 */
void	MCSUser::RegistryAllocateHandleResponse (
						UINT					number_of_handles,
						UINT					registry_handle,
						EntityID				requester_entity_id,
						UserID					requester_node_id,
						GCCResult				result)
{
	GCCError				error_value = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = REGISTRY_ALLOCATE_HANDLE_RESPONSE_CHOSEN;

	gcc_pdu.u.response.u.registry_allocate_handle_response.number_of_handles = (USHORT) number_of_handles;
	gcc_pdu.u.response.u.registry_allocate_handle_response.entity_id = requester_entity_id;
	gcc_pdu.u.response.u.registry_allocate_handle_response.first_handle = (Handle) registry_handle;

	if (result == GCC_RESULT_SUCCESSFUL)
	{
		gcc_pdu.u.response.u.registry_allocate_handle_response.result = RARS_RESULT_SUCCESS;
	}
	else
	{
		gcc_pdu.u.response.u.registry_allocate_handle_response.result = NO_HANDLES_AVAILABLE;
	}

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
					   	PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, requester_node_id, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		error_value = GCC_ALLOCATION_FAILURE;
		delete packet;
	}
}

/*
 *	void	RegistryResponse()
 *
 *	Public Function Description:
 *		This routine is used to respond to all the registry request except
 *		allocate handle.  It formulates the response PDU and queues it for
 *		delivery.
 */
void	MCSUser::RegistryResponse (
						RegistryResponsePrimitiveType	primitive_type,
						UserID							requester_owner_id,
						EntityID						requester_entity_id,
						CRegKeyContainer                *registry_key_data,
						CRegItem                        *registry_item_data,
						GCCModificationRights			modification_rights,
						UserID							entry_owner_id,
						EntityID						entry_entity_id,
						GCCResult						result)
{
	GCCError				error_value;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;

	DebugEntry(MCSUser::RegistryResponse);

	/*
	**	Encode the conference join response PDU, along with the sequence
	**	number.
	*/
	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = REGISTRY_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.registry_response.bit_mask = 0;

	error_value = registry_key_data->GetRegistryKeyDataPDU(&gcc_pdu.u.response.u.registry_response.key);
	if (error_value == GCC_NO_ERROR)
	{
		if (registry_item_data != NULL)
		{
			registry_item_data->GetRegistryItemDataPDU(&gcc_pdu.u.response.u.registry_response.item);
		}
		else
        {
			gcc_pdu.u.response.u.registry_response.item.choice = VACANT_CHOSEN;
        }

		TRACE_OUT(("MCSUser: RegistryResponse: item_type=%d", (UINT) gcc_pdu.u.response.u.registry_response.item.choice));

		//	Set up the entry owner
		if (entry_owner_id != 0)
		{
			gcc_pdu.u.response.u.registry_response.owner.choice = OWNED_CHOSEN;
			gcc_pdu.u.response.u.registry_response.owner.u.owned.node_id = entry_owner_id;
			gcc_pdu.u.response.u.registry_response.owner.u.owned.entity_id = entry_entity_id;
		}
		else
		{
			gcc_pdu.u.response.u.registry_response.owner.choice = NOT_OWNED_CHOSEN;
		}

		//	Set up the requesters entity ID
		gcc_pdu.u.response.u.registry_response.entity_id = requester_entity_id;

		//	Set up the primitive type
		gcc_pdu.u.response.u.registry_response.primitive_type = primitive_type;

		gcc_pdu.u.response.u.registry_response.result =
						::TranslateGCCResultToRegistryResp(result);

		if (modification_rights != GCC_NO_MODIFICATION_RIGHTS_SPECIFIED)
		{
			gcc_pdu.u.response.u.registry_response.bit_mask |=
										RESPONSE_MODIFY_RIGHTS_PRESENT;

			gcc_pdu.u.response.u.registry_response.response_modify_rights =
						(RegistryModificationRights)modification_rights;
		}

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, requester_owner_id, HIGH_PRIORITY, FALSE);
		}
		else
        {
            ResourceFailureHandler();
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
        }
	}

	DebugExitVOID(MCSUser::RegistryResponse);
}

/*
 *	void	RegistryMonitorEntryIndication()
 *
 *	Public Function Description:
 *		This routine is used by the top provider to issue a monitor
 *		indication anytime a registry entry that is being monitored changes.
 */
void	MCSUser::RegistryMonitorEntryIndication ( 	
						CRegKeyContainer	            *registry_key_data,
						CRegItem                        *registry_item_data,
						UserID							entry_owner_id,
						EntityID						entry_entity_id,
						GCCModificationRights			modification_rights)
{
	GCCError				error_value;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;

	/*
	**	Encode the conference join response PDU, along with the sequence
	**	number.
	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = REGISTRY_MONITOR_ENTRY_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.registry_monitor_entry_indication.bit_mask = 0;
	
	
	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    			&gcc_pdu.u.indication.u.
			    					registry_monitor_entry_indication.key);
							
	if (error_value == GCC_NO_ERROR)
	{
		registry_item_data->GetRegistryItemDataPDU(&gcc_pdu.u.indication.u.registry_monitor_entry_indication.item);

        //	Set up the entry owner
		if (entry_owner_id != 0)
		{
			gcc_pdu.u.indication.u.registry_monitor_entry_indication.owner.choice = OWNED_CHOSEN;
			gcc_pdu.u.indication.u.registry_monitor_entry_indication.owner.u.owned.node_id = entry_owner_id;
			gcc_pdu.u.indication.u.registry_monitor_entry_indication.owner.u.owned.entity_id = entry_entity_id;
		}
		else
		{
			gcc_pdu.u.indication.u.registry_monitor_entry_indication.owner.choice = NOT_OWNED_CHOSEN;
		}
		
		if (modification_rights != GCC_NO_MODIFICATION_RIGHTS_SPECIFIED)
		{
			gcc_pdu.u.indication.u.registry_monitor_entry_indication.bit_mask |= RESPONSE_MODIFY_RIGHTS_PRESENT;
			
			gcc_pdu.u.indication.u.registry_monitor_entry_indication.entry_modify_rights =
						(RegistryModificationRights)modification_rights;
		}

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
		}
		else
        {
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
		}
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}


/************************************************************************/

/*
 *	GCCError	AppInvokeIndication()
 *
 *	Public Function Description:
 *		This routine is used to send an application invoke indication to
 *		every node in the conference.
 */
GCCError 	MCSUser::AppInvokeIndication(
					CInvokeSpecifierListContainer	*invoke_specifier_list,
                    GCCSimpleNodeList               *pNodeList)
{
	GCCError								rc = GCC_NO_ERROR;
	PPacket									packet;
	GCCPDU									gcc_pdu;
	PacketError								packet_error;
	PSetOfDestinationNodes					new_destination_node;
	PSetOfDestinationNodes					old_destination_node = NULL;
	PSetOfDestinationNodes					pDstNodesToFree = NULL;
	UINT									i;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = APPLICATION_INVOKE_INDICATION_CHOSEN;

	gcc_pdu.u.indication.u.application_invoke_indication.bit_mask = 0;
	gcc_pdu.u.indication.u.application_invoke_indication.destination_nodes = NULL;
	gcc_pdu.u.indication.u.application_invoke_indication.application_protocol_entity_list = NULL;

	//	First, set up the destination node list
	if (pNodeList->cNodes != 0)
	{
		gcc_pdu.u.indication.u.application_invoke_indication.bit_mask |=
													DESTINATION_NODES_PRESENT;

		for (i = 0; i < pNodeList->cNodes; i++)
		{
			DBG_SAVE_FILE_LINE
			new_destination_node = new SetOfDestinationNodes;
			if (new_destination_node != NULL)
			{
				if (gcc_pdu.u.indication.u.application_invoke_indication.
													destination_nodes == NULL)
				{
					gcc_pdu.u.indication.u.application_invoke_indication.
									destination_nodes = new_destination_node;
					pDstNodesToFree = new_destination_node;
				}
				else
				{
					old_destination_node->next = new_destination_node;
				}

				old_destination_node = new_destination_node;
				new_destination_node->next = NULL;
				new_destination_node->value = pNodeList->aNodeIDs[i];
			}
			else
			{
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
		}
	}

	if (rc == GCC_NO_ERROR)
	{
		rc = invoke_specifier_list->GetApplicationInvokeSpecifierListPDU(
					&gcc_pdu.u.indication.u.application_invoke_indication.
						application_protocol_entity_list);
	}

	if (rc == GCC_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					   		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
        }
	}

    if (NULL != pDstNodesToFree)
    {
        PSetOfDestinationNodes p;
        while (NULL != (p = pDstNodesToFree))
        {
            pDstNodesToFree = pDstNodesToFree->next;
            delete p;
        }
    }

	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}

   return rc;
}

/*
 *	GCCError	TextMessageIndication()
 *
 *	Public Function Description:
 *		This routine is used to send a text message to either a specific node
 *		or to every node in the conference.
 */
GCCError 	MCSUser::TextMessageIndication (
						LPWSTR						pwszTextMsg,
						UserID						destination_node )
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;
	LPWSTR					pwszMsg;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = TEXT_MESSAGE_INDICATION_CHOSEN;

	if (NULL != (pwszMsg = ::My_strdupW(pwszTextMsg)))
	{
		gcc_pdu.u.indication.u.text_message_indication.message.length = ::lstrlenW(pwszMsg);
		gcc_pdu.u.indication.u.text_message_indication.message.value = pwszMsg;

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					   		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(
				        packet,
				        (destination_node == 0) ? BROADCAST_CHANNEL_ID : destination_node,
				        HIGH_PRIORITY,
				        FALSE);
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
        }

		delete pwszMsg;
	}
	else
	{
		rc = GCC_ALLOCATION_FAILURE;
	}

	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}

	return rc;
}

/*
 *	GCCError	ConferenceAssistanceIndication()
 *
 *	Public Function Description:
 *		This routine is used to send a conference assistance indication to
 *		every node in the conference.
 */
GCCError		MCSUser::ConferenceAssistanceIndication (
						UINT						number_of_user_data_members,
						PGCCUserData		*		user_data_list)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;
	CUserDataListContainer  *user_data_record;

 	DebugEntry(MCSUser::ConferenceAssistanceIndication);

	//	Encode the PDU
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_ASSISTANCE_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conference_assistance_indication.bit_mask = 0;

	//	Construct the user data list container
	if ((number_of_user_data_members != 0) && (rc == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		user_data_record = new CUserDataListContainer(number_of_user_data_members, user_data_list, &rc);
		if (user_data_record == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		user_data_record = NULL;
    }

	if ((user_data_record != NULL) && (rc == GCC_NO_ERROR))
	{
		rc = user_data_record->GetUserDataPDU(
			&gcc_pdu.u.indication.u.conference_assistance_indication.
									cain_user_data);

		gcc_pdu.u.indication.u.conference_assistance_indication.bit_mask
									|= CAIN_USER_DATA_PRESENT;
	}

	if (rc == GCC_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
		}
	}

	// Clean up containers
	if (user_data_record != NULL)
	{
		user_data_record->Release();
	}

	return (rc);
}



/*
 *	GCCError	ConferenceTransferRequest()
 *
 *	Public Function Description:
 *		This routine is used to send a conference transfer request to the
 *		top provider in the conference.
 */
GCCError	MCSUser::ConferenceTransferRequest (
				PGCCConferenceName		destination_conference_name,
				GCCNumericString		destination_conference_modifier,
				CNetAddrListContainer   *destination_address_list,
				UINT					number_of_destination_nodes,
				PUserID					destination_node_list,
				CPassword               *password)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;
	UINT						string_length;
	PSetOfTransferringNodesRq	new_set_of_nodes;
	PSetOfTransferringNodesRq	old_set_of_nodes;
	UINT						i;

	DebugEntry(MCSUser::ConferenceTransferRequest);

	//	Encode the PDU
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = CONFERENCE_TRANSFER_REQUEST_CHOSEN;
	gcc_pdu.u.request.u.conference_transfer_request.bit_mask = 0;
	
	//	First get the conference name (either numeric or text).
	if (destination_conference_name->numeric_string != NULL)
	{
		gcc_pdu.u.request.u.conference_transfer_request.conference_name.choice =
											NAME_SELECTOR_NUMERIC_CHOSEN;
		
		lstrcpy (gcc_pdu.u.request.u.conference_transfer_request.
					conference_name.u.name_selector_numeric,
				(LPSTR)destination_conference_name->numeric_string);
	}
	else
	{
		//	Use a unicode string to determine the length
		gcc_pdu.u.request.u.conference_transfer_request.conference_name.choice =
											NAME_SELECTOR_TEXT_CHOSEN;

		string_length = ::My_strlenW(destination_conference_name->text_string);

		gcc_pdu.u.request.u.conference_transfer_request.
					conference_name.u.name_selector_text.length = string_length;
		
		gcc_pdu.u.request.u.conference_transfer_request.
					conference_name.u.name_selector_text.value =
							destination_conference_name->text_string;
	}
	

	//	Next get the conference name modifier if it exists
	if (destination_conference_modifier != NULL)
	{
		gcc_pdu.u.request.u.conference_transfer_request.bit_mask |=
											CTRQ_CONFERENCE_MODIFIER_PRESENT;
	
		lstrcpy (gcc_pdu.u.request.u.conference_transfer_request.
					ctrq_conference_modifier,
				(LPSTR)destination_conference_modifier);
	}

	//	Get the network address list if it exist
	if (destination_address_list != NULL)
	{
		gcc_pdu.u.request.u.conference_transfer_request.bit_mask |=
											CTRQ_NETWORK_ADDRESS_PRESENT;
		
		rc = destination_address_list->GetNetworkAddressListPDU (
						&gcc_pdu.u.request.u.conference_transfer_request.
							ctrq_net_address);
	}

	//	Get the destination node list if it exists
	if ((number_of_destination_nodes != 0) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.request.u.conference_transfer_request.bit_mask |=
											CTRQ_TRANSFERRING_NODES_PRESENT;
											
		old_set_of_nodes = NULL;
		gcc_pdu.u.request.u.conference_transfer_request.
									ctrq_transferring_nodes = NULL;
									
		for (i = 0; i <	number_of_destination_nodes; i++)
		{
			DBG_SAVE_FILE_LINE
			new_set_of_nodes = new SetOfTransferringNodesRq;
			if (new_set_of_nodes == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				break;	
			}
			else
				new_set_of_nodes->next = NULL;

			if (old_set_of_nodes == NULL)
			{
				gcc_pdu.u.request.u.conference_transfer_request.
									ctrq_transferring_nodes = new_set_of_nodes;
			}
			else
				old_set_of_nodes->next = new_set_of_nodes;

			old_set_of_nodes = new_set_of_nodes;
			new_set_of_nodes->value = destination_node_list[i];
		}
	}

	//	Get the password if it exists
	if ((password != NULL) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.request.u.conference_transfer_request.bit_mask |=
													CTRQ_PASSWORD_PRESENT;
		
		rc = password->GetPasswordSelectorPDU (
				&gcc_pdu.u.request.u.conference_transfer_request.ctrq_password);
	}
	
	//	Encode the PDU
	if (rc == GCC_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
        }
	}

	// Clean up the node list if it was created
	if (gcc_pdu.u.request.u.conference_transfer_request.bit_mask &
											CTRQ_TRANSFERRING_NODES_PRESENT)
	{
		old_set_of_nodes = gcc_pdu.u.request.u.conference_transfer_request.
									ctrq_transferring_nodes;
		while (old_set_of_nodes != NULL)
		{
			new_set_of_nodes = old_set_of_nodes->next;
			delete old_set_of_nodes;
			old_set_of_nodes = new_set_of_nodes;
		}
	}

	return rc;
}


/*
 *	GCCError	ConferenceTransferIndication()
 *
 *	Public Function Description:
 *		This routine is used by the top provider to send out the transfer
 *		indication to every node in the conference.  It is each nodes
 *		responsiblity to search the destination node list to see if
 *		it should transfer.
 */
GCCError	MCSUser::ConferenceTransferIndication (
				PGCCConferenceName		destination_conference_name,
				GCCNumericString		destination_conference_modifier,
				CNetAddrListContainer   *destination_address_list,
				UINT					number_of_destination_nodes,
				PUserID					destination_node_list,
				CPassword               *password)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;
	UINT						string_length;
	PSetOfTransferringNodesIn	new_set_of_nodes;
	PSetOfTransferringNodesIn	old_set_of_nodes;
	UINT						i;

	DebugEntry(MCSUser::ConferenceTransferIndication);

	//	Encode the PDU
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_TRANSFER_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conference_transfer_indication.bit_mask = 0;
	
	//	First get the conference name (either numeric or text).
	if (destination_conference_name->numeric_string != NULL)
	{
		gcc_pdu.u.indication.u.conference_transfer_indication.
									conference_name.choice =
											NAME_SELECTOR_NUMERIC_CHOSEN;
		
		lstrcpy (gcc_pdu.u.indication.u.conference_transfer_indication.
					conference_name.u.name_selector_numeric,
				(LPSTR)destination_conference_name->numeric_string);
	}
	else
	{
		//	Use a unicode string to determine the length
		gcc_pdu.u.indication.u.conference_transfer_indication.
									conference_name.choice =
											NAME_SELECTOR_TEXT_CHOSEN;

		string_length = ::My_strlenW(destination_conference_name->text_string);

		gcc_pdu.u.indication.u.conference_transfer_indication.
					conference_name.u.name_selector_text.length = string_length;
		
		gcc_pdu.u.indication.u.conference_transfer_indication.
					conference_name.u.name_selector_text.value =
							destination_conference_name->text_string;
	}
	

	//	Next get the conference name modifier if it exists
	if (destination_conference_modifier != NULL)
	{
		gcc_pdu.u.indication.u.conference_transfer_indication.bit_mask |=
											CTIN_CONFERENCE_MODIFIER_PRESENT;
	
		lstrcpy (gcc_pdu.u.indication.u.conference_transfer_indication.
					ctin_conference_modifier,
				(LPSTR)destination_conference_modifier);
	}

	//	Get the network address list if it exist
	if (destination_address_list != NULL)
	{
		gcc_pdu.u.indication.u.conference_transfer_indication.bit_mask |=
											CTIN_NETWORK_ADDRESS_PRESENT;
		
		rc = destination_address_list->GetNetworkAddressListPDU (
						&gcc_pdu.u.indication.u.conference_transfer_indication.
							ctin_net_address);
	}

	//	Get the destination node list if it exists
	if ((number_of_destination_nodes != 0) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.indication.u.conference_transfer_indication.bit_mask |=
											CTIN_TRANSFERRING_NODES_PRESENT;
											
		old_set_of_nodes = NULL;
		gcc_pdu.u.indication.u.conference_transfer_indication.
									ctin_transferring_nodes = NULL;
									
		for (i = 0; i <	number_of_destination_nodes; i++)
		{
			DBG_SAVE_FILE_LINE
			new_set_of_nodes = new SetOfTransferringNodesIn;
			if (new_set_of_nodes == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				break;	
			}
			else
				new_set_of_nodes->next = NULL;

			if (old_set_of_nodes == NULL)
			{
				gcc_pdu.u.indication.u.conference_transfer_indication.
									ctin_transferring_nodes = new_set_of_nodes;
			}
			else
				old_set_of_nodes->next = new_set_of_nodes;

			old_set_of_nodes = new_set_of_nodes;
			new_set_of_nodes->value = destination_node_list[i];
		}
	}

	//	Get the password if it exists
	if ((password != NULL) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.indication.u.conference_transfer_indication.bit_mask |=
													CTIN_PASSWORD_PRESENT;
		
		rc = password->GetPasswordSelectorPDU (
						&gcc_pdu.u.indication.u.conference_transfer_indication.
							ctin_password);
	}
	
	//	Encode the PDU
	if (rc == GCC_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
        }
	}

	// Clean up the node list if it was created
	if (gcc_pdu.u.indication.u.conference_transfer_indication.bit_mask &
											CTIN_TRANSFERRING_NODES_PRESENT)
	{
		old_set_of_nodes = gcc_pdu.u.indication.u.
						conference_transfer_indication.ctin_transferring_nodes;
		while (old_set_of_nodes != NULL)
		{
			new_set_of_nodes = old_set_of_nodes->next;
			delete old_set_of_nodes;
			old_set_of_nodes = new_set_of_nodes;
		}
	}

	DebugExitINT(MCSUser::ConferenceTransferIndication, rc);
	return rc;
}


/*
 *	GCCError	ConferenceTransferResponse()
 *
 *	Public Function Description:
 *		This routine is used by the top provider to send back a response to
 *		the node that made a transfer request.  The info specified in the
 *		request is included in the response to match request to response.
 */
GCCError	MCSUser::ConferenceTransferResponse (
				UserID					requesting_node_id,
				PGCCConferenceName		destination_conference_name,
				GCCNumericString		destination_conference_modifier,
				UINT					number_of_destination_nodes,
 				PUserID					destination_node_list,
				GCCResult				result)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;
	UINT						string_length;
	PSetOfTransferringNodesRs	new_set_of_nodes;
	PSetOfTransferringNodesRs	old_set_of_nodes;
	UINT						i;

	DebugEntry(MCSUser::ConferenceTransferResponse);

	//	Encode the PDU
	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = CONFERENCE_TRANSFER_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.conference_transfer_response.bit_mask = 0;
	
	//	First get the conference name (either numeric or text).
	if (destination_conference_name->numeric_string != NULL)
	{
		gcc_pdu.u.response.u.conference_transfer_response.
									conference_name.choice =
											NAME_SELECTOR_NUMERIC_CHOSEN;
		
        ::lstrcpyA(gcc_pdu.u.response.u.conference_transfer_response.
					conference_name.u.name_selector_numeric,
				(LPSTR)destination_conference_name->numeric_string);
	}
	else
	{
		//	Use a unicode string to determine the length
		gcc_pdu.u.response.u.conference_transfer_response.
									conference_name.choice =
											NAME_SELECTOR_TEXT_CHOSEN;

		string_length = ::My_strlenW(destination_conference_name->text_string);

		gcc_pdu.u.response.u.conference_transfer_response.
					conference_name.u.name_selector_text.length = string_length;
		
		gcc_pdu.u.response.u.conference_transfer_response.
					conference_name.u.name_selector_text.value =
							destination_conference_name->text_string;
	}
	

	//	Next get the conference name modifier if it exists
	if (destination_conference_modifier != NULL)
	{
		gcc_pdu.u.response.u.conference_transfer_response.bit_mask |=
											CTRS_CONFERENCE_MODIFIER_PRESENT;
	
        ::lstrcpyA(gcc_pdu.u.response.u.conference_transfer_response.
					ctrs_conference_modifier,
				(LPSTR)destination_conference_modifier);
	}

	//	Get the destination node list if it exists
	if ((number_of_destination_nodes != 0) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.response.u.conference_transfer_response.bit_mask |=
											CTRS_TRANSFERRING_NODES_PRESENT;
											
		old_set_of_nodes = NULL;
		gcc_pdu.u.response.u.conference_transfer_response.
									ctrs_transferring_nodes = NULL;
									
		for (i = 0; i <	number_of_destination_nodes; i++)
		{
			DBG_SAVE_FILE_LINE
			new_set_of_nodes = new SetOfTransferringNodesRs;
			if (new_set_of_nodes == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				break;	
			}
			else
				new_set_of_nodes->next = NULL;

			if (old_set_of_nodes == NULL)
			{
				gcc_pdu.u.response.u.conference_transfer_response.
									ctrs_transferring_nodes = new_set_of_nodes;
			}
			else
				old_set_of_nodes->next = new_set_of_nodes;

			old_set_of_nodes = new_set_of_nodes;
			new_set_of_nodes->value = destination_node_list[i];
		}
	}

	//	Set up the result
	if (result == GCC_RESULT_SUCCESSFUL)
	{
		gcc_pdu.u.response.u.conference_transfer_response.result =
														CTRANS_RESULT_SUCCESS;
	}
	else
	{
		gcc_pdu.u.response.u.conference_transfer_response.result =
												CTRANS_RESULT_INVALID_REQUESTER;
	}

	//	Encode the PDU
	if (rc == GCC_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, requesting_node_id, HIGH_PRIORITY, FALSE);
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
        }
	}

	// Clean up the node list if it was created
	if (gcc_pdu.u.response.u.conference_transfer_response.bit_mask &
											CTRS_TRANSFERRING_NODES_PRESENT)
	{
		old_set_of_nodes = gcc_pdu.u.response.u.
						conference_transfer_response.ctrs_transferring_nodes;
		while (old_set_of_nodes != NULL)
		{
			new_set_of_nodes = old_set_of_nodes->next;
			delete old_set_of_nodes;
			old_set_of_nodes = new_set_of_nodes;
		}
	}

	DebugExitINT(MCSUser::ConferenceTransferResponse, rc);
	return rc;
}


/*
 *	GCCError	ConferenceAddRequest()
 *
 *	Public Function Description:
 *		This routine is used to send a conference add request to the appropriate
 *		node.  This call can be made by the requesting node or by the top
 *		provider to pass the add request on to the adding node.
 */
GCCError	MCSUser::ConferenceAddRequest (
						TagNumber				conference_add_tag,
						UserID					requesting_node,
						UserID					adding_node,
						UserID					target_node,
						CNetAddrListContainer   *network_address_container,
						CUserDataListContainer  *user_data_container)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;

	DebugEntry(MCSUser::ConferenceAddRequest);

	//	Encode the PDU
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = CONFERENCE_ADD_REQUEST_CHOSEN;
	gcc_pdu.u.request.u.conference_add_request.bit_mask = 0;
	
	//	Get the network address list if it exist
	if (network_address_container != NULL)
	{
		//	Set up the network address portion of the pdu
		rc = network_address_container->GetNetworkAddressListPDU (
						&gcc_pdu.u.request.u.conference_add_request.
							add_request_net_address);
		
		//	Set up the user data container
		if ((rc == GCC_NO_ERROR) && (user_data_container != NULL))
		{
			rc = user_data_container->GetUserDataPDU (
				&gcc_pdu.u.request.u.conference_add_request.carq_user_data);
								
			if (rc == GCC_NO_ERROR)
			{
				gcc_pdu.u.request.u.conference_add_request.bit_mask |=
														CARQ_USER_DATA_PRESENT;
			}
		}
	
		//	Encode the PDU
		if (rc == GCC_NO_ERROR)
		{
			//	specify the requesting node					
			gcc_pdu.u.request.u.conference_add_request.requesting_node =
															requesting_node;
		
			if (adding_node != 0)
			{
				gcc_pdu.u.request.u.conference_add_request.bit_mask |=
															ADDING_MCU_PRESENT;
				gcc_pdu.u.request.u.conference_add_request.adding_mcu =
															adding_node;
			}

			gcc_pdu.u.request.u.conference_add_request.tag = conference_add_tag;

			DBG_SAVE_FILE_LINE
			packet = new Packet((PPacketCoder) g_GCCCoder,
								PACKED_ENCODING_RULES,
								&gcc_pdu,
								GCC_PDU,
								TRUE,
								&packet_error);
			if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
			{
				AddToMCSMessageQueue(packet, target_node, HIGH_PRIORITY, FALSE);
			}
			else
            {
				rc = GCC_ALLOCATION_FAILURE;
				delete packet;
            }
		}
	}
	else
    {
		rc = GCC_BAD_NETWORK_ADDRESS;
    }

	DebugExitINT(MCSUser::ConferenceAddRequest, rc);
	return rc;
}


/*
 *	GCCError	ConferenceAddResponse()
 *
 *	Public Function Description:
 *		This routine is used to send a conference add request to the appropriate
 *		node.  This call can be made by the requesting node or by the top
 *		provider to pass the add request on to the adding node.
 */
GCCError	MCSUser::ConferenceAddResponse(
						TagNumber				add_request_tag,
						UserID					requesting_node,
						CUserDataListContainer  *user_data_container,
						GCCResult				result)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;

	DebugEntry(MCSUser::ConferenceAddResponse);

	//	Encode the PDU
	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = CONFERENCE_ADD_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.conference_add_response.bit_mask = 0;
	
	//	Set up the user data container
	if ((rc == GCC_NO_ERROR) && (user_data_container != NULL))
	{
		rc = user_data_container->GetUserDataPDU (
			&gcc_pdu.u.response.u.conference_add_response.cars_user_data);
							
		if (rc == GCC_NO_ERROR)
		{
			gcc_pdu.u.response.u.conference_add_response.bit_mask |=
													CARS_USER_DATA_PRESENT;
		}
	}

	//	Encode the PDU
	if (rc == GCC_NO_ERROR)
	{
		gcc_pdu.u.response.u.conference_add_response.tag = add_request_tag;
		
		gcc_pdu.u.response.u.conference_add_response.result =
						::TranslateGCCResultToAddResult(result);

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, requesting_node, HIGH_PRIORITY, FALSE);
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
        }
	}

	DebugExitINT(MCSUser::ConferenceAddResponse, rc);
	return rc;
}


/************************* Conductorship Calls ***********************/
/*
 *	GCCError	ConductorTokenGrab()
 *
 *	Public Function Description:
 *		This routine makes the MCS calls to grab the conductor token.
 */
GCCError	MCSUser::ConductorTokenGrab()
{
	MCSError	mcs_error;
	
	mcs_error = g_pMCSIntf->TokenGrabRequest(m_pMCSSap, CONDUCTOR_TOKEN_ID);
											
	return (g_pMCSIntf->TranslateMCSIFErrorToGCCError (mcs_error));
}

/*
 *	GCCError	ConductorTokenRelease()
 *
 *	Public Function Description:
 *		This routine makes the MCS calls to release the conductor token.
 */
GCCError	MCSUser::ConductorTokenRelease()
{
	MCSError	mcs_error;
	
	mcs_error = g_pMCSIntf->TokenReleaseRequest(m_pMCSSap, CONDUCTOR_TOKEN_ID);
											
	return (g_pMCSIntf->TranslateMCSIFErrorToGCCError (mcs_error));
}
/*
 *	GCCError	ConductorTokenPlease()
 *
 *	Public Function Description:
 *		This routine makes the MCS calls to request the conductor token from
 *		the current conductor.
 */
GCCError	MCSUser::ConductorTokenPlease()
{
	MCSError	mcs_error;

	mcs_error = g_pMCSIntf->TokenPleaseRequest(m_pMCSSap, CONDUCTOR_TOKEN_ID);

	return (g_pMCSIntf->TranslateMCSIFErrorToGCCError (mcs_error));
}

/*
 *	GCCError	ConductorTokenGive ()
 *
 *	Public Function Description:
 *		This routine makes the MCS calls to give the conductor token to the
 *		specified node.
 */
GCCError	MCSUser::ConductorTokenGive(UserID recipient_user_id)
{
	MCSError	mcs_error;

	mcs_error = g_pMCSIntf->TokenGiveRequest(m_pMCSSap, CONDUCTOR_TOKEN_ID,
														recipient_user_id);

	return (g_pMCSIntf->TranslateMCSIFErrorToGCCError (mcs_error));
}

/*
 *	GCCError	ConductorTokenGiveResponse ()
 *
 *	Public Function Description:
 *		This routine makes the MCS calls to respond to a conductor give
 *		request.
 */
GCCError	MCSUser::ConductorTokenGiveResponse(Result result)
{
	MCSError	mcs_error;

	mcs_error = g_pMCSIntf->TokenGiveResponse(m_pMCSSap, CONDUCTOR_TOKEN_ID, result);

	return g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
}

/*
 *	GCCError	ConductorTokenTest ()
 *
 *	Public Function Description:
 *		This routine is used to test the current state of the conductor token
 *		(is it grabbed or not).
 */
GCCError	MCSUser::ConductorTokenTest()
{
	MCSError	mcs_error;

	mcs_error = g_pMCSIntf->TokenTestRequest(m_pMCSSap, CONDUCTOR_TOKEN_ID);

	return g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
}


/*
 *	GCCError	SendConductorAssignIndication()
 *
 *	Public Function Description:
 *		This routine sends a conductor assign indication to all the
 *		nodes in the conference.
 */
GCCError	MCSUser::SendConductorAssignIndication(
								UserID			conductor_user_id)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the ConductorAssignIndication pdu structure to be passed in the
 	**	constructor of the packet class.
 	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONDUCTOR_ASSIGN_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conductor_assign_indication.user_id =
															conductor_user_id;

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,					
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, TOP_PRIORITY, TRUE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConductorReleaseIndication()
 *
 *	Public Function Description:
 *		This routine sends a conductor release indication to all the
 *		nodes in the conference.
 */
GCCError	MCSUser::SendConductorReleaseIndication()
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the ConductorAssignIndication pdu structure to be passed in the
 	**	constructor of the packet class.
 	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONDUCTOR_RELEASE_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conductor_release_indication.placeholder = 0;

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,					
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, TOP_PRIORITY, TRUE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}
		
/*
 *	GCCError	SendConductorPermitAsk ()
 *
 *	Public Function Description:
 *		This routine sends a conductor permission ask request directly to the
 *		conductor node.
 */
GCCError	MCSUser::SendConductorPermitAsk (
						BOOL					grant_permission)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the ConductorPermissionAskIndication pdu structure to be passed
	**	in the constructor of the packet class.
	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONDUCTOR_PERMISSION_ASK_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conductor_permission_ask_indication.
								permission_is_granted = (ASN1bool_t)grant_permission;

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,					
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConductorPermitGrant ()
 *
 *	Public Function Description:
 *		This routine sends a conductor permission grant indication to every
 *		node in the conference.  Usually issued when permissions change.
 */
GCCError	MCSUser::SendConductorPermitGrant (
				UINT					number_granted,
				PUserID					granted_node_list,
				UINT					number_waiting,
				PUserID					waiting_node_list)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;
	PPermissionList		permission_list;
	PPermissionList		previous_permission_list;
	PWaitingList			waiting_list;
	PWaitingList			previous_waiting_list;
	UINT					i;
	
	/*
	**	Fill in the ConductorPermissionAskIndication pdu structure to be passed
	**	in the constructor of the packet class.
	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONDUCTOR_PERMISSION_GRANT_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conductor_permission_grant_indication.bit_mask = 0;

	//	First fill in the granted node permission list
	gcc_pdu.u.indication.u.
		conductor_permission_grant_indication.permission_list = NULL;
	previous_permission_list = NULL;
	for (i = 0; i < number_granted; i++)
	{
		DBG_SAVE_FILE_LINE
		permission_list = new PermissionList;
		if (permission_list == NULL)
		{
			rc = GCC_ALLOCATION_FAILURE;
			break;
		}

		if (previous_permission_list == NULL)
		{
			gcc_pdu.u.indication.u.conductor_permission_grant_indication.
											permission_list = permission_list;
		}
		else
			previous_permission_list->next = permission_list;

		previous_permission_list = permission_list;

		permission_list->value = granted_node_list[i];
		permission_list->next = NULL;
	}

	//	If waiting list exists fill it in
	if ((number_waiting != 0) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.indication.u.conductor_permission_grant_indication.bit_mask =
														WAITING_LIST_PRESENT;
		gcc_pdu.u.indication.u.
			conductor_permission_grant_indication.waiting_list = NULL;
		previous_waiting_list = NULL;
		for (i = 0; i < number_waiting; i++)
		{
			DBG_SAVE_FILE_LINE
			waiting_list = new WaitingList;
			if (waiting_list == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}

			if (previous_waiting_list == NULL)
			{
				gcc_pdu.u.indication.u.conductor_permission_grant_indication.
												waiting_list = waiting_list;
			}
			else
				previous_waiting_list->next = waiting_list;

			previous_waiting_list = waiting_list;

			waiting_list->value = waiting_node_list[i];
			waiting_list->next = NULL;
		}
	}

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, TOP_PRIORITY, TRUE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/**********************************************************************/


/*****************	Miscelaneous calls ******************************/
/*
 *	GCCError	TimeRemainingRequest()
 *
 *	Public Function Description:
 *		This routine sends out an indication to every node in the
 *		conference informing how much time is remaining in the conference.
 */
GCCError	MCSUser::TimeRemainingRequest (
						UINT					time_remaining,
						UserID					node_id)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the TimeRemainingRequest pdu structure to be passed in the
 	**	constructor of the packet class.
 	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_TIME_REMAINING_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conference_time_remaining_indication.bit_mask = 0;
	
	gcc_pdu.u.indication.u.conference_time_remaining_indication.time_remaining =
																time_remaining;
	
	if (node_id != 0)
	{
		gcc_pdu.u.indication.u.conference_time_remaining_indication.bit_mask |=
										TIME_REMAINING_NODE_ID_PRESENT;
		gcc_pdu.u.indication.u.conference_time_remaining_indication.
						time_remaining_node_id = node_id;
	}

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,					
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	TimeInquireRequest()
 *
 *	Public Function Description:
 *		This routine sends out a request for a time remaing update.
 */
GCCError	MCSUser::TimeInquireRequest (
						BOOL				time_is_conference_wide)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the TimeInquireRequest pdu structure to be passed in the
 	**	constructor of the packet class.
 	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_TIME_INQUIRE_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conference_time_inquire_indication.
							time_is_node_specific = (ASN1bool_t)time_is_conference_wide;
	
	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,					
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, CONVENER_CHANNEL_ID, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	ConferenceExtendIndication()
 *
 *	Public Function Description:
 *		This routine sends out an indication informing conference participants
 *		of an extension.
 */
GCCError	MCSUser::ConferenceExtendIndication (
						UINT						extension_time,
						BOOL				time_is_conference_wide)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the ConfernceExtendIndication pdu structure to be passed in the
	**	constructor of the packet class.
	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_TIME_EXTEND_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conference_time_extend_indication.
							time_to_extend = extension_time;
	gcc_pdu.u.indication.u.conference_time_extend_indication.
							time_is_node_specific = (ASN1bool_t)time_is_conference_wide;

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, CONVENER_CHANNEL_ID, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	void	ConferenceJoinResponse()
 *
 *	Functional Description:
 * 		This function is called by the conference object of the
 * 		top provider when it wants to send the join response back to the gcc
 * 		provider that made the join request, through the directly connected
 * 		intermediate node. This function does the encoding of the join response
 *		PDU and also adds the sequence number sent in the request.
 */
void	MCSUser::ConferenceJoinResponse(
						UserID					receiver_id,
						BOOL					password_is_in_the_clear,
						BOOL					conference_locked,
						BOOL					conference_listed,
						GCCTerminationMethod	termination_method,
						CPassword               *password_challenge,
						CUserDataListContainer  *user_data_list,
						GCCResult				result)	
{
	GCCError				rc = GCC_NO_ERROR;	 	
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;
	TagNumber				lTagNum;

	if (0 == (lTagNum = m_ConfJoinResponseList2.Find(receiver_id)))
	{
		WARNING_OUT(("MCSUser::ConferenceJoinResponse: Unexpected Join Response"));
		return;
	}

	/*
	**	Encode the conference join response PDU, along with the sequence
	**	number.
	*/
	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = CONFERENCE_JOIN_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.conference_join_response.bit_mask = 0;

	/*
	**	Get the sequence number of the outstanding response from the
	**	list of seq # vs userID using the userID passed from above.
	*/
	gcc_pdu.u.response.u.conference_join_response.tag = lTagNum;
	
	// Remove this entry from the list.
	m_ConfJoinResponseList2.Remove(receiver_id);


	//	Get password challenge PDU
	if ((password_challenge != NULL) && (rc == GCC_NO_ERROR))
	{
		rc = password_challenge->GetPasswordChallengeResponsePDU (
			&gcc_pdu.u.response.u.conference_join_response.cjrs_password);
			
		if (rc == GCC_NO_ERROR)
		{
			gcc_pdu.u.response.u.conference_join_response.bit_mask |=
													CJRS_PASSWORD_PRESENT;
		}
	}
	
	//	Get user data list PDU
	if ((user_data_list != NULL) && (rc == GCC_NO_ERROR))
	{
		rc = user_data_list->GetUserDataPDU (
			&gcc_pdu.u.response.u.conference_join_response.cjrs_user_data);
							
		if (rc == GCC_NO_ERROR)
		{
			gcc_pdu.u.response.u.conference_join_response.bit_mask |=
													CJRS_USER_DATA_PRESENT;
		}
	}

	if (rc == GCC_NO_ERROR)
	{
		gcc_pdu.u.response.u.conference_join_response.
												top_node_id = m_nidTopProvider;
		
		gcc_pdu.u.response.u.conference_join_response.
					clear_password_required = (ASN1bool_t)password_is_in_the_clear;

		gcc_pdu.u.response.u.conference_join_response.
					conference_is_locked = (ASN1bool_t)conference_locked;
		
		gcc_pdu.u.response.u.conference_join_response.
					conference_is_listed = (ASN1bool_t)conference_listed;

		gcc_pdu.u.response.u.conference_join_response.termination_method =
  									(TerminationMethod)termination_method;

		gcc_pdu.u.response.u.conference_join_response.result =
						::TranslateGCCResultToJoinResult(result);

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, receiver_id, TOP_PRIORITY, FALSE);
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
		}
	}

	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	ConferenceTerminateRequest()
 *
 *	Functional Description:
 *		This routine is used by a node subordinate to the top provider to
 *		request that the conference by terminated.
 */
void	MCSUser::ConferenceTerminateRequest(
									GCCReason				reason)
{
	GCCError				error_value = GCC_NO_ERROR;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;

	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = CONFERENCE_TERMINATE_REQUEST_CHOSEN;
	gcc_pdu.u.request.u.conference_terminate_request.reason =
				::TranslateGCCReasonToTerminateRqReason(reason);

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		error_value = GCC_ALLOCATION_FAILURE;
		delete packet;
	}
}

/*
 *	void	ConferenceTerminateResponse ()
 *
 *	Functional Description:
 *		This routine is used by the top provider to respond to a terminate
 *		request issued by a subordinate node.  The result indicates if the
 *		requesting node had the correct privileges.
 */
void	MCSUser::ConferenceTerminateResponse (	
						UserID					requester_id,
						GCCResult				result)
{
	GCCError				error_value = GCC_NO_ERROR;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;

	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = CONFERENCE_TERMINATE_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.conference_terminate_response.result =
					::TranslateGCCResultToTerminateResult(result);

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, requester_id, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		error_value = GCC_ALLOCATION_FAILURE;
		delete packet;
	}
}

/*
 *	GCCError	ConferenceTerminateIndication()
 *
 *	Functional Description:
 *		This routine is used by the top provider to send out a terminate
 *		indication to every node in the conference.
 */
void	MCSUser::ConferenceTerminateIndication (
						GCCReason				reason)
{
	GCCError				error_value = GCC_NO_ERROR;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;

	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_TERMINATE_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conference_terminate_indication.reason =
					::TranslateGCCReasonToTerminateInReason(reason);

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
	}
	else
	{
        ResourceFailureHandler();
		error_value = GCC_ALLOCATION_FAILURE;
		delete packet;
	}
}

/*
 *	void	EjectNodeFromConference()
 *
 *	Functional Description:
 *		This routine is used when attempting to eject a node from the
 *		conference.
 */
GCCError	MCSUser::EjectNodeFromConference (	UserID		ejected_node_id,
			  									GCCReason	reason)
{
	GCCError				rc = GCC_NO_ERROR;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;
	ChannelID				channel_id;
	BOOL					uniform_send;
	Priority				priority;
	PAlarm					alarm;
	
	if (ejected_node_id == m_nidMyself)
	{
		/*
		**	If the ejected node is this node we can immediately initiate the
		**	ejection.  There is no need to request this through the Top
		**	Provider.
		*/
		rc = InitiateEjectionFromConference (reason);
	}
	else
	{
		/*
		**	If the ejected node is a child node to this node we can directly
		**	eject it.  Otherwise the request is forwarded to the Top Provider.
		*/
		if (m_ChildUidConnHdlList2.Find(ejected_node_id) ||
			(m_nidTopProvider == m_nidMyself))
		{
			gcc_pdu.choice = INDICATION_CHOSEN;
			gcc_pdu.u.indication.choice =
										CONFERENCE_EJECT_USER_INDICATION_CHOSEN;
			gcc_pdu.u.indication.u.conference_eject_user_indication.
												node_to_eject = ejected_node_id;
			gcc_pdu.u.indication.u.conference_eject_user_indication.reason =
							::TranslateGCCReasonToEjectInd(reason);

			uniform_send = TRUE;
			channel_id = BROADCAST_CHANNEL_ID;

			//	If this is the top provider send the data at TOP priority
			if (m_nidTopProvider == m_nidMyself)
				priority = TOP_PRIORITY;
			else
				priority = HIGH_PRIORITY;
			
			/*
			**	Set up ejection alarm to automatically eject any misbehaving
			**	nodes.  Note that we only do this if we are directly connected
			**	to the node to be ejected.
			*/
			if (m_ChildUidConnHdlList2.Find(ejected_node_id))
			{
				DBG_SAVE_FILE_LINE
				alarm = new Alarm (EJECTED_NODE_TIMER_DURATION);
				if (alarm != NULL)
				{
					/*
					**	Here we save the alarm in a list of ejected nodes. This
					**	alarm is used to cleanup any misbehaving node.
					*/
					m_EjectedNodeAlarmList2.Append(ejected_node_id, alarm);
				}
				else
                {
					rc = GCC_ALLOCATION_FAILURE;
                }
			}
		}
		else
		{
			gcc_pdu.choice = REQUEST_CHOSEN;
			gcc_pdu.u.request.choice = CONFERENCE_EJECT_USER_REQUEST_CHOSEN;
			gcc_pdu.u.request.u.conference_eject_user_request.node_to_eject =
																ejected_node_id;

			//	The only valid reason is user initiated which is zero
			gcc_pdu.u.request.u.conference_eject_user_request.reason =
	      											CERQ_REASON_USER_INITIATED;
		
			uniform_send = FALSE;
			channel_id = m_nidTopProvider;
			priority = TOP_PRIORITY;
		}
		
		if (rc == GCC_NO_ERROR)
		{
			DBG_SAVE_FILE_LINE
			packet = new Packet((PPacketCoder) g_GCCCoder,
								PACKED_ENCODING_RULES,
								&gcc_pdu,
								GCC_PDU,
								TRUE,
								&packet_error);
			if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
			{
				AddToMCSMessageQueue(packet, channel_id, priority, uniform_send);
			}
			else
            {
				rc = GCC_ALLOCATION_FAILURE;
				delete packet;
            }
		}
	}

	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}

	return rc;
}

/*
 *	void	SendEjectNodeResponse()
 *
 *	Functional Description:
 *		This routine is used by the top provider to respond to an eject
 *		user request.
 */
GCCError	MCSUser::SendEjectNodeResponse (	UserID		requester_id,
												UserID		node_to_eject,
												GCCResult	result)
{
	GCCError				rc = GCC_NO_ERROR;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;

	gcc_pdu.choice = RESPONSE_CHOSEN;
	
	gcc_pdu.u.response.choice = CONFERENCE_EJECT_USER_RESPONSE_CHOSEN;
	
	gcc_pdu.u.response.u.conference_eject_user_response.node_to_eject =
															node_to_eject;
	
	gcc_pdu.u.response.u.conference_eject_user_response.result =
						::TranslateGCCResultToEjectResult(result);

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, requester_id, HIGH_PRIORITY, FALSE);
	}
	else
    {
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
    }

	return rc;
}

/*
 *	void	RosterUpdateIndication()
 *
 *	Functional Description:
 *		This routine is used to forward a roster update indication either
 *		upward to the parent node or downward as a full refresh to all nodes
 *		in the conference.
 */
void	MCSUser::RosterUpdateIndication(PGCCPDU		gcc_pdu,
										BOOL		send_update_upward)
{
	PPacket					packet;
	PacketError				packet_error;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		if (send_update_upward)
		{
			AddToMCSMessageQueue(packet, m_nidParent, HIGH_PRIORITY, FALSE);
		}
		else
		{
			AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
		}
	}
	else
	{
        ResourceFailureHandler();
        delete packet;
	}
}

/*
 *	void	AddToMCSMessageQueue()
 *
 *	Private Function Description:
 * 		This function adds the out bound messages to a queue which is
 *		flushed in the next heartbeat when controller call FlushMessageQueue.
 *		In case memory allocation for messages holding the out bound inform-
 *		ation fails an owner call back is sent to conference object to
 *		indicate insufficient memory.
 *
 *	Formal Parameters:
 *		packet					-	(i)	Pointer to packet to queue up.
 *		send_data_request_info	-	(i)	Structure containing all the info
 *										necessary to deliver the packet.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */	
void MCSUser::
AddToMCSMessageQueue
(
	PPacket                 packet,
	ChannelID				channel_id,
	Priority				priority,
	BOOL    				uniform_send
)
{
	SEND_DATA_REQ_INFO *pReqInfo;

	DBG_SAVE_FILE_LINE
	pReqInfo = new SEND_DATA_REQ_INFO;
	if (pReqInfo != NULL)
	{
		pReqInfo->packet = packet;
		pReqInfo->channel_id = channel_id;
		pReqInfo->priority = priority;
		pReqInfo->uniform_send = uniform_send;

    	/*
    	**	This forces the packet to be encoded.  This must happen here so
    	**	that any memory used by the decoded portion of the packet can
    	**	be freed after returning.
    	*/
    	// packet->Lock();

    	m_OutgoingPDUQueue.Append(pReqInfo);

        if (m_OutgoingPDUQueue.GetCount() == 1)
        {
            if (FlushOutgoingPDU())
            {
        		//	Inform the MCS interface that there are PDUs queued
    			g_pGCCController->SetEventToFlushOutgoingPDU();
    		}
    	}
    	else
    	{
            //	Inform the MCS interface that there are PDUs queued
            g_pGCCController->SetEventToFlushOutgoingPDU();
    	}
	}
	else
    {
        ResourceFailureHandler();
        /*
		**	This just sets a flag in the packet object that allows packet
		**	to commit suicide if lock count on encoded and decoded data is
		**	zero. This will occur once the packet is sent on to MCS.
		*/
		packet->Unlock();
    }
}

/*
 *	BOOL FlushOutgoingPDU()
 *
 *	Public Function Description:
 * 		This function is called by the owner object in every heartbeat. This
 *		function iterates throught the list of pending out bound messages
 *		and sends them down to MCS. Also after a successful send it frees
 *		any resources tied up with the outbound messages. If however a message
 *		can not be sent in this heartbeat, as indicated by MCS, then it
 *		inserts the message back onto the message queue and returns.
 *
 *	Return value:
 *		TRUE, if there remain un-processed msgs in the MCS message queue
 *		FALSE, if all the msgs in the MCS msg queue were processed.
 */	
void MCSUser::
CheckEjectedNodeAlarms ( void )
{
	/*
	**	We first check the eject user list to make sure that no alarms have
	**	expired on any of the ejected nodes.
	*/
	if (m_EjectedNodeAlarmList2.IsEmpty() == FALSE)
	{
		PAlarm				lpAlarm;
		UserID              uid;

		//	We copy the list so that we can remove entries in the iterator
		while (NULL != (lpAlarm = m_EjectedNodeAlarmList2.Get(&uid)))
		{
			//	Has the alarm expired for this node?
			if (lpAlarm->IsExpired())
			{
				ConnectionHandle hConn;

				/*
				**	Tell the owner object to disconnect the misbehaving node
				**	that exists at the connection handle accessed through
				**	the m_ChildUidConnHdlList2.
				*/
				if (NULL != (hConn = m_ChildUidConnHdlList2.Find(uid)))
				{
                    //
                    // This must generate a disconnect provider for eject node to
                    // work properly.
                    //
                    g_pMCSIntf->DisconnectProviderRequest(hConn);

                    //
                    // Since this node will not get a disconnect indication when it
                    // issues a DisconnectProviderRequest we go ahead and call it
                    // from here.
                    //
                    m_pConf->DisconnectProviderIndication(hConn);
				}
			}

    		//	Delete the alarm
			delete lpAlarm;
		}
	}
}

BOOL MCSUser::
FlushOutgoingPDU ( void )
{
	
	DWORD				mcs_message_count;
	DWORD				count;
	UINT				rc;
	SEND_DATA_REQ_INFO  *pReqInfo;

	mcs_message_count = m_OutgoingPDUQueue.GetCount();
	for (count = 0;
	     (count < mcs_message_count) && (m_OutgoingPDUQueue.IsEmpty() == FALSE);
	     count++)
	{
		/*
		**	Get the next message from the queue.
		*/
		pReqInfo = m_OutgoingPDUQueue.Get();

		/*
		 * If MCS takes the request without an error, free information
		 * structure and unlock the encoded information in the packet.
		 * Unlocking the packet before deleting the infomration	structure
		 * ensures that packet object is deleted and not left dangling.
		 * This is true because here only one lock is performed.
		 * If there is an error in the send data request, it means mcs can not
		 * take any more requests, therefore insert the information
		 * structure back in the queue and break out of this loop.
		 */
		if (pReqInfo->uniform_send)
		{
			rc = g_pMCSIntf->UniformSendDataRequest(
						pReqInfo->channel_id,
						m_pMCSSap,
						pReqInfo->priority,
						(LPBYTE) pReqInfo->packet->GetEncodedData(),
						pReqInfo->packet->GetEncodedDataLength());
		}
		else
		{
			rc = g_pMCSIntf->SendDataRequest(
						pReqInfo->channel_id,
						m_pMCSSap,
						pReqInfo->priority,
						(LPBYTE) pReqInfo->packet->GetEncodedData(),
						pReqInfo->packet->GetEncodedDataLength());
		}

		if (rc == MCS_NO_ERROR)
		{
			pReqInfo->packet->Unlock();
			delete pReqInfo;
		}
		else
		{
			TRACE_OUT(("MCSUser::FlushMessageQueue: Could not send queued packet data in this heartbeat"));
			m_OutgoingPDUQueue.Prepend(pReqInfo);
			break;	// breaking out of the for loop
		}
	}

	return (! (m_OutgoingPDUQueue.IsEmpty() && m_EjectedNodeAlarmList2.IsEmpty()));
}

/*
 *	MCSUser::SetChildUserID()
 *
 *	Public Function Description:
 * 		This function is called by the conference object to pass on the user id
 *		of the child node to the user object. The user object inserts this
 *		user id into a user id list of it's children which it maintains.
 */
void		MCSUser::SetChildUserIDAndConnection (
						UserID				child_user_id,
						ConnectionHandle	child_connection_handle)
{
	TRACE_OUT(("MCSUser::SetChildUserID: Adding Child userid=0x%04x to the list", (UINT) child_user_id));
	TRACE_OUT(("MCSUser::SetChildUserID: Adding Child Connection=%d to the list", (UINT) child_connection_handle));

	m_ChildUidConnHdlList2.Append(child_user_id, child_connection_handle);
}

/*
 *	GCCError	InitiateEjectionFromConference()
 *
 *	Private Function Description:
 *		This internal routine kicks of the process of ejecting this node
 *		from the conference.  This includes ejecting all the nodes below
 *		this node and waiting for their disconnect indications to come back
 *		in.
 *
 *	Formal Parameters:
 *		reason	-	(i)	Reason for ejection.
 *
 *	Return Value
 *		GCC_NO_ERROR		  	-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError	MCSUser::InitiateEjectionFromConference (GCCReason		reason)
{
	GCCError				error_value = GCC_NO_ERROR;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;
	PAlarm					alarm = NULL;

	m_fEjectionPending = TRUE;
	m_eEjectReason = reason;

	if (m_ChildUidConnHdlList2.IsEmpty() == FALSE)
	{
	    UserID      uid;

		gcc_pdu.choice = INDICATION_CHOSEN;
		gcc_pdu.u.indication.choice = CONFERENCE_EJECT_USER_INDICATION_CHOSEN;
		
		gcc_pdu.u.indication.u.conference_eject_user_indication.reason =
				::TranslateGCCReasonToEjectInd(
					GCC_REASON_HIGHER_NODE_EJECTED);

		m_ChildUidConnHdlList2.Reset();
	 	while (m_ChildUidConnHdlList2.Iterate(&uid))
	 	{
			//	Get the Node to eject from the list of child nodes
			gcc_pdu.u.indication.u.conference_eject_user_indication.node_to_eject = uid;

			DBG_SAVE_FILE_LINE
			packet = new Packet((PPacketCoder) g_GCCCoder,
								PACKED_ENCODING_RULES,
								&gcc_pdu,
								GCC_PDU,
								TRUE,
								&packet_error);
			if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
			{
				AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);

				DBG_SAVE_FILE_LINE
				alarm = new Alarm (EJECTED_NODE_TIMER_DURATION);
				if (alarm != NULL)
				{
					/*
					**	Here we save the alarm in a list of ejected
					**	nodes. This alarm is used to cleanup any
					**	misbehaving node.
					*/
					m_EjectedNodeAlarmList2.Append(uid, alarm);
				}
				else
				{
					error_value = GCC_ALLOCATION_FAILURE;
					break;
				}
			}
			else
			{
				error_value = GCC_ALLOCATION_FAILURE;
				delete packet;
				break;
			}
		}
	}
	else
	{
		m_pConf->ProcessEjectUserIndication(m_eEjectReason);
	}

	return (error_value);
}

/*
 *	UINT	ProcessSendDataIndication()
 *
 *	Private Function Description:
 * 		This function is called when the user object gets send data indications
 *		from below. It finds out the message type and decodes the pdu in the
 *		user data field of send data indications. Based on the type of decoded
 *		pdu it take the necessary actions.
 *
 *	Formal Parameters:
 *		send_data_info	-	(i)	Send data structure to process.
 *
 *	Return Value
 *		MCS_NO_ERROR is always returned from this routine.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
UINT	MCSUser::ProcessSendDataIndication(PSendData send_data_info)
{
	PPacket					packet;
	PacketError				packet_error;
	PGCCPDU					gcc_pdu;
	GCCError				error_value = GCC_NO_ERROR;
	UserID					initiator;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
			   			PACKED_ENCODING_RULES,
						(LPBYTE)send_data_info->user_data.value,
						send_data_info->user_data.length,
						GCC_PDU,
						TRUE,
						&packet_error);
	if(packet != NULL && packet_error == PACKET_NO_ERROR)
	{
		initiator = send_data_info->initiator;
		gcc_pdu = (PGCCPDU)packet->GetDecodedData();
		switch(gcc_pdu->choice)
		{
			case INDICATION_CHOSEN: // Data PDU
				switch(gcc_pdu->u.indication.choice)
				{
					case USER_ID_INDICATION_CHOSEN:
						{
							/*
							 * Sequence number and User Id sent by the child
							 * node after a successful conference create or
							 * join.
							 */
							m_pConf->ProcessUserIDIndication(
							        gcc_pdu->u.indication.u.user_id_indication.tag,
							        initiator);
						}
						break;

					case ROSTER_UPDATE_INDICATION_CHOSEN:
						if(send_data_info->channel_id == m_nidMyself)
						{
                            //
                            // We only process the roster update if the conference is
                            // established.
                            //
                            if (m_pConf->IsConfEstablished())
                            {
                                m_pConf->ProcessRosterUpdatePDU(gcc_pdu, initiator);
                            }
						}
    					break;

					case CONFERENCE_TIME_INQUIRE_INDICATION_CHOSEN:
                        g_pControlSap->ConfTimeInquireIndication(
                                m_pConf->GetConfID(),
                                gcc_pdu->u.indication.u.conference_time_inquire_indication.time_is_node_specific,
                                initiator);
						break;

					case CONFERENCE_TIME_EXTEND_INDICATION_CHOSEN:
#ifdef JASPER
						ProcessConferenceExtendIndicationPDU(
									&gcc_pdu->u.indication.u.
										conference_time_extend_indication,
									initiator);
#endif // JASPER
						break;

					case APPLICATION_INVOKE_INDICATION_CHOSEN:
						ProcessApplicationInvokeIndication(
									&gcc_pdu->u.indication.u.
										application_invoke_indication,
									initiator);
						break;
							
					case TEXT_MESSAGE_INDICATION_CHOSEN:
#ifdef JASPER
						if (ProcessTextMessageIndication(
									&gcc_pdu->u.indication.u.
									text_message_indication,
									initiator) != GCC_NO_ERROR)
						{
							error_value = GCC_ALLOCATION_FAILURE;
						}
#endif // JASPER
						break;

					case CONFERENCE_LOCK_INDICATION_CHOSEN:
						m_pConf->ProcessConferenceLockIndication(initiator);
						break;

					case CONFERENCE_UNLOCK_INDICATION_CHOSEN:
						m_pConf->ProcessConferenceUnlockIndication(initiator);
    					break;

					default:
						ERROR_OUT(("User::ProcessSendDataIndication Unsupported PDU"));
    					break;
				} // switch(gcc_pdu->u.indication.choice)
                break;

			case REQUEST_CHOSEN:	// Connection(control) PDU
				switch(gcc_pdu->u.request.choice)
				{	
					case CONFERENCE_JOIN_REQUEST_CHOSEN:
						ProcessConferenceJoinRequestPDU(
								&gcc_pdu->u.request.u.conference_join_request,
								send_data_info);
						break;

					case CONFERENCE_TERMINATE_REQUEST_CHOSEN:
						ProcessConferenceTerminateRequestPDU(
								&gcc_pdu->u.request.u.
											conference_terminate_request,
								send_data_info);
						break;
						
					case CONFERENCE_EJECT_USER_REQUEST_CHOSEN:
						ProcessConferenceEjectUserRequestPDU(
								&gcc_pdu->u.request.u.
											conference_eject_user_request,
								send_data_info);
						break;

					case REGISTRY_ALLOCATE_HANDLE_REQUEST_CHOSEN:
						ProcessRegistryAllocateHandleRequestPDU(	
								&gcc_pdu->u.request.u.
										registry_allocate_handle_request,
								send_data_info);
						break;

					case CONFERENCE_LOCK_REQUEST_CHOSEN:
						m_pConf->ProcessConferenceLockRequest(initiator);
						break;

					case CONFERENCE_UNLOCK_REQUEST_CHOSEN:
						m_pConf->ProcessConferenceUnlockRequest(initiator);
						break;

					case CONFERENCE_TRANSFER_REQUEST_CHOSEN:
						ProcessTransferRequestPDU(
								&gcc_pdu->u.request.u.conference_transfer_request,
								send_data_info);
						break;

					case CONFERENCE_ADD_REQUEST_CHOSEN:
						ProcessAddRequestPDU (
								&gcc_pdu->u.request.u.conference_add_request,
								send_data_info);
						break;

					case REGISTRY_REGISTER_CHANNEL_REQUEST_CHOSEN:
					case REGISTRY_ASSIGN_TOKEN_REQUEST_CHOSEN:
					case REGISTRY_SET_PARAMETER_REQUEST_CHOSEN:
					case REGISTRY_DELETE_ENTRY_REQUEST_CHOSEN:
					case REGISTRY_RETRIEVE_ENTRY_REQUEST_CHOSEN:
					case REGISTRY_MONITOR_ENTRY_REQUEST_CHOSEN:
						ProcessRegistryRequestPDU(	gcc_pdu,
														send_data_info);
						break;
	
					default:
							ERROR_OUT(("User::ProcessSendDataIndication this pdu choice is not supported"));
						break;
				} // switch(gcc_pdu->u.request.choice)
				break;

			case RESPONSE_CHOSEN:	// Connection(control) PDU
				switch(gcc_pdu->u.response.choice)
				{	
					case CONFERENCE_JOIN_RESPONSE_CHOSEN:
						/* This comes from top provider to the intermediate
						 * gcc provider which has to pass it on to the node
						 * that made a join request.
				    	 */	
						ProcessConferenceJoinResponsePDU(
								&gcc_pdu->u.response.u.
											conference_join_response);
						break;

					case CONFERENCE_TERMINATE_RESPONSE_CHOSEN:
						ProcessConferenceTerminateResponsePDU(
								&gcc_pdu->u.response.u.
											conference_terminate_response);
						break;

					case CONFERENCE_EJECT_USER_RESPONSE_CHOSEN:
						ProcessConferenceEjectUserResponsePDU(
								&gcc_pdu->u.response.u.
											conference_eject_user_response);
						break;

					case REGISTRY_RESPONSE_CHOSEN:
						ProcessRegistryResponsePDU(
								&gcc_pdu->u.response.u.registry_response);
						break;

					case REGISTRY_ALLOCATE_HANDLE_RESPONSE_CHOSEN:
						ProcessRegistryAllocateHandleResponsePDU(
								&gcc_pdu->u.response.u.
									registry_allocate_handle_response);
						break;

					case CONFERENCE_LOCK_RESPONSE_CHOSEN:
#ifdef JASPER
						{
							GCCResult               result;
                            result = ::TranslateLockResultToGCCResult(gcc_pdu->u.response.u.conference_lock_response.result);
                    		g_pControlSap->ConfLockConfirm(result, m_pConf->GetConfID());
						}
#endif // JASPER
						break;

					case CONFERENCE_UNLOCK_RESPONSE_CHOSEN:
#ifdef JASPER
						{
							GCCResult               result;
                            result = ::TranslateUnlockResultToGCCResult(gcc_pdu->u.response.u.conference_unlock_response.result);
                    		g_pControlSap->ConfUnlockConfirm(result, m_pConf->GetConfID());
						}
#endif // JASPER
						break;

					case CONFERENCE_TRANSFER_RESPONSE_CHOSEN:
#ifdef JASPER
						ProcessTransferResponsePDU(
								&gcc_pdu->u.response.u.conference_transfer_response);
#endif // JASPER
						break;

					case CONFERENCE_ADD_RESPONSE_CHOSEN:
						ProcessAddResponsePDU(
								&gcc_pdu->u.response.u.conference_add_response);
						break;

					case FUNCTION_NOT_SUPPORTED_RESPONSE_CHOSEN:
						ProcessFunctionNotSupported (
								(UINT) gcc_pdu->u.response.u.function_not_supported_response.request.choice);
						break;

					// other cases to be added as we go along.
					default:
						ERROR_OUT(("User::ProcessSendDataIndication this pdu choice is not supported"));
						break;
				} // switch(gcc_pdu->u.response.choice)
				break;

			default:
				ERROR_OUT(("User::ProcessSendDataIndication this pdu type"));
				break;
		} // switch(gcc_pdu->choice)
		packet->Unlock();
	}
	else
	{
		delete packet;
		error_value = GCC_ALLOCATION_FAILURE;
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}

	return(MCS_NO_ERROR);
}

/*
 *	void	ProcessConferenceJoinRequestPDU ()
 *
 *	Private Function Description:
 *		This PDU comes from below (intermediate directly connected node) to the
 *		top gcc provider. Pull out the tag number and user id from the
 *		pdu and store in a list.
 *
 *	Formal Parameters:
 *		join_request	-	(i)	Join request PDU structure to process.
 *		send_data_info	-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceJoinRequestPDU(
								PConferenceJoinRequest	join_request,
								PSendData				send_data_info)
{
	GCCError				rc = GCC_NO_ERROR;
	UserJoinRequestInfo		join_request_info;
	
	/*
	**	Build all the containers to be used in the join request info structure.
	*/
	
	//	Build the convener password container
	if ((join_request->bit_mask & CJRQ_CONVENER_PASSWORD_PRESENT) &&
		(rc == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		join_request_info.convener_password = new CPassword(
										&join_request->cjrq_convener_password,
										&rc);
												
		if (join_request_info.convener_password == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		join_request_info.convener_password = NULL;
    }

	//	Build the password challenge container
	if ((join_request->bit_mask & CJRQ_PASSWORD_PRESENT) &&
		(rc == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		join_request_info.password_challenge = new CPassword(
												&join_request->cjrq_password,
												&rc);
												
		if (join_request_info.password_challenge == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		join_request_info.password_challenge = NULL;
    }
		
	//	Build the caller identifier container
	if ((join_request->bit_mask & CJRQ_CALLER_ID_PRESENT) &&
		(rc == GCC_NO_ERROR))
	{
		if (NULL == (join_request_info.pwszCallerID = ::My_strdupW2(
										join_request->cjrq_caller_id.length,
										join_request->cjrq_caller_id.value)))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
    {
		join_request_info.pwszCallerID = NULL;
    }
	
	//	Build the password challenge container
	if ((join_request->bit_mask & CJRQ_USER_DATA_PRESENT) &&
		(rc == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		join_request_info.user_data_list = new CUserDataListContainer(join_request->cjrq_user_data, &rc);
		if (join_request_info.user_data_list == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		join_request_info.user_data_list = NULL;
    }

	if (rc == GCC_NO_ERROR)
	{
		m_ConfJoinResponseList2.Append(send_data_info->initiator, join_request->tag);

		join_request_info.sender_id = send_data_info->initiator;

		g_pControlSap->ForwardedConfJoinIndication(
							join_request_info.sender_id,
							m_pConf->GetConfID(),
							join_request_info.convener_password,
							join_request_info.password_challenge,
							join_request_info.pwszCallerID,
							join_request_info.user_data_list);
	}

	//	Free up the containers allocated above
	if (join_request_info.convener_password != NULL)
	{
		join_request_info.convener_password->Release();
	}

	if (join_request_info.password_challenge != NULL)
	{
		join_request_info.password_challenge->Release();
	}

	delete join_request_info.pwszCallerID;

	if (join_request_info.user_data_list != NULL)
	{
		join_request_info.user_data_list->Release();
	}

	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	ProcessConferenceJoinResponsePDU ()
 *
 *	Private Function Description:
 *		This comes from top provider to the intermediate gcc provider which has
 *		to pass it on to the node that made a join request.
 *
 *	Formal Parameters:
 *		join_response	-	(i)	Join response PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceJoinResponsePDU(
								PConferenceJoinResponse		join_response)
{
	GCCError				rc = GCC_NO_ERROR;
	UserJoinResponseInfo	join_response_info;

	//	Store the password data in the join response info structure
	if ((join_response->bit_mask & CJRS_PASSWORD_PRESENT) &&
		(rc == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		join_response_info.password_challenge = new CPassword(
												&join_response->cjrs_password,
												&rc);
		if (join_response_info.password_challenge == NULL)
        {
			rc = GCC_NO_ERROR;
        }
	}
	else
    {
		join_response_info.password_challenge = NULL;
    }

	//	Store the user data in the join response info structure	
	if ((join_response->bit_mask & CJRS_USER_DATA_PRESENT) &&
	   	(rc == GCC_NO_ERROR))	
	{
		DBG_SAVE_FILE_LINE
		join_response_info.user_data_list = new CUserDataListContainer(join_response->cjrs_user_data, &rc);		
		if (join_response_info.user_data_list == NULL)
        {
			rc = GCC_NO_ERROR;
        }
	}
	else
    {
		join_response_info.user_data_list = NULL;
    }

	if (rc == GCC_NO_ERROR)
	{
		join_response_info.connection_handle = (ConnectionHandle)join_response->tag;
		join_response_info.result = ::TranslateJoinResultToGCCResult(join_response->result);

		m_pConf->ProcessConfJoinResponse(&join_response_info);
	}

	//	Free up the containers allocated above
	if (join_response_info.password_challenge != NULL)
		join_response_info.password_challenge->Release();

	if (join_response_info.user_data_list != NULL)
		join_response_info.user_data_list->Release();

	//	Cleanup after any allocation failures.
	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	ProcessConferenceTerminateRequestPDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Terminate Request PDU.
 *
 *	Formal Parameters:
 *		terminate_request	-	(i)	Terminate request PDU structure to process.
 *		send_data_info		-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessConferenceTerminateRequestPDU
(
    PConferenceTerminateRequest     terminate_request,
    PSendData                       send_data_info
)
{
    m_pConf->ProcessTerminateRequest(
                send_data_info->initiator,
                ::TranslateTerminateRqReasonToGCCReason(terminate_request->reason));
}

/*
 *	void	ProcessConferenceEjectUserRequestPDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		eject user request PDU.
 *
 *	Formal Parameters:
 *		eject_user_request	-	(i)	Eject user request PDU structure to process.
 *		send_data_info		-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceEjectUserRequestPDU(
							PConferenceEjectUserRequest	eject_user_request,
							PSendData					send_data_info)
{
	UserEjectNodeRequestInfo	eject_node_request;

	eject_node_request.requester_id = send_data_info->initiator;
	eject_node_request.node_to_eject = eject_user_request->node_to_eject;
	eject_node_request.reason = GCC_REASON_NODE_EJECTED;

	m_pConf->ProcessEjectUserRequest(&eject_node_request);
}

/*
 *	void	ProcessConferenceTerminateResponsePDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		terminate response PDU.
 *
 *	Formal Parameters:
 *		terminate_response	-	(i)	Terminate response PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceTerminateResponsePDU(
							PConferenceTerminateResponse	terminate_response)
{
    GCCResult               result = ::TranslateTerminateResultToGCCResult(terminate_response->result);

	//
	// If the terminate was successful, go ahead and set the
	// conference to not established.
	//
	if (result == GCC_RESULT_SUCCESSFUL)
	{
		m_pConf->ConfIsOver();
	}

	g_pControlSap->ConfTerminateConfirm(m_pConf->GetConfID(), result);
}


/*
 *	void	ProcessConferenceEjectUserResponsePDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Eject User response PDU.
 *
 *	Formal Parameters:
 *		eject_user_response	-	(i)	Eject user response PDU structure to
 *									process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceEjectUserResponsePDU(
							PConferenceEjectUserResponse	eject_user_response)
{
	UserEjectNodeResponseInfo	eject_node_response;

	eject_node_response.node_to_eject = eject_user_response->node_to_eject;

	eject_node_response.result = ::TranslateEjectResultToGCCResult(
													eject_user_response->result);

	m_pConf->ProcessEjectUserResponse(&eject_node_response);
}

/*
 *	void	ProcessRegistryRequest()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Registry
 *		request PDU.
 *
 *	Formal Parameters:
 *		gcc_pdu			-	(i)	This is the PDU structure to process.
 *		send_data_info	-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessRegistryRequestPDU
(
    PGCCPDU             gcc_pdu,
    PSendData           send_data_info
)
{
    CRegistry   *pAppReg = m_pConf->GetRegistry();

    if (NULL != pAppReg)
    {
        GCCError            rc = GCC_ALLOCATION_FAILURE;
        CRegKeyContainer    *pRegKey = NULL;

        switch (gcc_pdu->u.request.choice)
        {
        case REGISTRY_REGISTER_CHANNEL_REQUEST_CHOSEN:
            DBG_SAVE_FILE_LINE
            pRegKey = new CRegKeyContainer(
                            &gcc_pdu->u.request.u.registry_register_channel_request.key,
                            &rc);
            if ((pRegKey != NULL) && (rc == GCC_NO_ERROR))
            {
                pAppReg->ProcessRegisterChannelPDU(
                            pRegKey,
                            gcc_pdu->u.request.u.registry_register_channel_request.channel_id,
                            send_data_info->initiator, // Requester node id
                            gcc_pdu->u.request.u.registry_register_channel_request.entity_id);
            }
            else
            {
                // rc = GCC_ALLOCATION_FAILURE;
            }
            break;

        case REGISTRY_ASSIGN_TOKEN_REQUEST_CHOSEN:
            DBG_SAVE_FILE_LINE
            pRegKey = new CRegKeyContainer(
                            &gcc_pdu->u.request.u.registry_assign_token_request.registry_key,
                            &rc);
            if ((pRegKey != NULL) && (rc == GCC_NO_ERROR))
            {
                pAppReg->ProcessAssignTokenPDU(
                            pRegKey,
                            send_data_info->initiator, // Requester node id
                            gcc_pdu->u.request.u.registry_assign_token_request.entity_id);
            }
            else
            {
                // rc = GCC_ALLOCATION_FAILURE;
            }
            break;

        case REGISTRY_SET_PARAMETER_REQUEST_CHOSEN:
            DBG_SAVE_FILE_LINE
            pRegKey = new CRegKeyContainer(
                            &gcc_pdu->u.request.u.registry_set_parameter_request.key,
                            &rc);
            if ((pRegKey != NULL) && (rc == GCC_NO_ERROR))
            {
                OSTR                    oszParamValue;
                LPOSTR                  poszParamValue;
                GCCModificationRights   eRights;

                if (gcc_pdu->u.request.u.registry_set_parameter_request.
                                registry_set_parameter.length != 0)
                {
                    poszParamValue = &oszParamValue;
                    oszParamValue.length = gcc_pdu->u.request.u.registry_set_parameter_request.
                                                    registry_set_parameter.length;
                    oszParamValue.value = gcc_pdu->u.request.u.registry_set_parameter_request.
                                                    registry_set_parameter.value;
                }
                else
                {
                    poszParamValue = NULL;
                }

                if (gcc_pdu->u.request.u.registry_set_parameter_request.
                                bit_mask & PARAMETER_MODIFY_RIGHTS_PRESENT)
                {
                    eRights = (GCCModificationRights)gcc_pdu->u.request.u.
                                    registry_set_parameter_request.parameter_modify_rights;
                }
                else
                {
                    eRights = GCC_NO_MODIFICATION_RIGHTS_SPECIFIED;
                }

                pAppReg->ProcessSetParameterPDU(
                            pRegKey,
                            poszParamValue,
                            eRights,
                            send_data_info->initiator, // Requester node id
                            gcc_pdu->u.request.u.registry_set_parameter_request.entity_id);

            }
            else
            {
                // rc = GCC_ALLOCATION_FAILURE;
            }
            break;

        case REGISTRY_RETRIEVE_ENTRY_REQUEST_CHOSEN:
            DBG_SAVE_FILE_LINE
            pRegKey = new CRegKeyContainer(
                            &gcc_pdu->u.request.u.registry_retrieve_entry_request.key,
                            &rc);
            if ((pRegKey != NULL) && (rc == GCC_NO_ERROR))
            {
                pAppReg->ProcessRetrieveEntryPDU(
                                pRegKey,
                                send_data_info->initiator, // Requester node id
                                gcc_pdu->u.request.u.registry_retrieve_entry_request.entity_id);
            }
            else
            {
                // rc = GCC_ALLOCATION_FAILURE;
            }
            break;

        case REGISTRY_DELETE_ENTRY_REQUEST_CHOSEN:
            DBG_SAVE_FILE_LINE
            pRegKey = new CRegKeyContainer(
                            &gcc_pdu->u.request.u.registry_delete_entry_request.key,
                            &rc);
            if ((pRegKey != NULL) && (rc == GCC_NO_ERROR))
            {
                pAppReg->ProcessDeleteEntryPDU (
                                pRegKey,
                                send_data_info->initiator, // Requester node id
                                gcc_pdu->u.request.u.registry_delete_entry_request.entity_id);
            }
            else
            {
                // rc = GCC_ALLOCATION_FAILURE;
            }
            break;

        case REGISTRY_MONITOR_ENTRY_REQUEST_CHOSEN:
            DBG_SAVE_FILE_LINE
            pRegKey = new CRegKeyContainer(
                            &gcc_pdu->u.request.u.registry_monitor_entry_request.key,
                            &rc);
            if ((pRegKey != NULL) && (rc == GCC_NO_ERROR))
            {
                pAppReg->ProcessMonitorEntryPDU(
                                pRegKey,
                                send_data_info->initiator, // Requester node id
                                gcc_pdu->u.request.u.registry_monitor_entry_request.entity_id);
            }
            else
            {
                // rc = GCC_ALLOCATION_FAILURE;
            }
            break;
        }

        if (NULL != pRegKey)
        {
            pRegKey->Release();
        }

        //	Handle resource errors
        if (rc == GCC_ALLOCATION_FAILURE)
        {
            ResourceFailureHandler();
        }
    } // if pAppReg != NULL
}

/*
 *	void	ProcessRegistryAllocateHandleRequestPDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Allocate
 *		Handle request PDU.
 *
 *	Formal Parameters:
 *		allocate_handle_request	-	(i)	This is the PDU structure to process.
 *		send_data_info			-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessRegistryAllocateHandleRequestPDU
(
    PRegistryAllocateHandleRequest	allocate_handle_request,
    PSendData						send_data_info
)
{
    CRegistry *pAppReg = m_pConf->GetRegistry();

    if (NULL != pAppReg)
    {
        pAppReg->ProcessAllocateHandleRequestPDU(
                        allocate_handle_request->number_of_handles,
                        allocate_handle_request->entity_id,
                        send_data_info->initiator);
    }
}

/*
 *	void	ProcessRegistryResponsePDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Registry
 *		Response PDU.
 *
 *	Formal Parameters:
 *		registry_response	-	(i)	This is the PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessRegistryResponsePDU ( PRegistryResponse registry_response )
{
    CRegistry   *pAppReg = m_pConf->GetRegistry();

    if (NULL != pAppReg)
    {
        GCCError                    rc;
        UserRegistryResponseInfo    urri;

        ::ZeroMemory(&urri, sizeof(urri));
        // urri.registry_key = NULL;
        // urri.registry_item = NULL;

        DBG_SAVE_FILE_LINE
        urri.registry_key = new CRegKeyContainer(&registry_response->key, &rc);
        if ((urri.registry_key != NULL) && (rc == GCC_NO_ERROR))
        {
            DBG_SAVE_FILE_LINE
            urri.registry_item = new CRegItem(&registry_response->item, &rc);
            if ((urri.registry_item != NULL) && (rc == GCC_NO_ERROR))
            {
                //	Set up the original requester entity id
                urri.requester_entity_id = registry_response->entity_id;

                //	Set up the primitive type being responded to
                urri.primitive_type = registry_response->primitive_type;

                //	Set up the owner related variables	
                if (registry_response->owner.choice == OWNED_CHOSEN)
                {
                    urri.owner_node_id = registry_response->owner.u.owned.node_id;
                    urri.owner_entity_id = registry_response->owner.u.owned.entity_id;
                }
                else
                {
                    // urri.owner_node_id = 0;
                    // urri.owner_entity_id = 0;
                }

                //	Set up the modification rights
                if (registry_response->bit_mask & RESPONSE_MODIFY_RIGHTS_PRESENT)
                {
                    urri.modification_rights = (GCCModificationRights)registry_response->response_modify_rights;
                }
                else
                {
                    urri.modification_rights = GCC_NO_MODIFICATION_RIGHTS_SPECIFIED;
                }

                //	Translate the result to a GCC result
                urri.result = ::TranslateRegistryRespToGCCResult(registry_response->result);

                pAppReg->ProcessRegistryResponsePDU(
                                urri.primitive_type,
                                urri.registry_key,
                                urri.registry_item,
                                urri.modification_rights,
                                urri.requester_entity_id,
                                urri.owner_node_id,
                                urri.owner_entity_id,
                                urri.result);
            }
            else
            {
                rc = GCC_ALLOCATION_FAILURE;
            }
        }
        else
        {
            rc = GCC_ALLOCATION_FAILURE;
        }

        if (NULL != urri.registry_key)
        {
            urri.registry_key->Release();
        }
        if (NULL != urri.registry_item)
        {
            urri.registry_item->Release();
        }

        //	Handle any resource errors	
        if (rc == GCC_ALLOCATION_FAILURE)
        {
            ResourceFailureHandler();
        }
    } // if pAppReg != NULL
}

/*
 *	void	ProcessAllocateHandleResponsePDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Allocate
 *		Handle Response PDU.
 *
 *	Formal Parameters:
 *		allocate_handle_response-	(i)	This is the PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessRegistryAllocateHandleResponsePDU
(
    PRegistryAllocateHandleResponse     allocate_handle_response
)
{
    CRegistry   *pAppReg = m_pConf->GetRegistry();

    if (NULL != pAppReg)
    {
        pAppReg->ProcessAllocateHandleResponsePDU(
                    allocate_handle_response->number_of_handles,
                    allocate_handle_response->first_handle,
                    allocate_handle_response->entity_id,
                    (allocate_handle_response->result == RARS_RESULT_SUCCESS) ?
                        GCC_RESULT_SUCCESSFUL :
                        GCC_RESULT_NO_HANDLES_AVAILABLE);
    }
}

/*
 *	void	ProcessTransferRequestPDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Transfer
 *		request PDU.
 *
 *	Formal Parameters:
 *		transfer_request	-	(i)	This is the PDU structure to process.
 *		send_data_info		-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessTransferRequestPDU
(
    PConferenceTransferRequest      transfer_request,
    PSendData                       send_data_info
)
{
	GCCError					rc = GCC_NO_ERROR;
	TransferInfo				transfer_info;
	PSetOfTransferringNodesRq	set_of_nodes;
	LPBYTE						sub_node_list_memory = NULL;
	Int							i;

	//	Make sure that this node is the top provider
	if (GetMyNodeID() != GetTopNodeID())
		return;

    ::ZeroMemory(&transfer_info, sizeof(transfer_info));

	//	First set up the conference name
	if (transfer_request->conference_name.choice ==
												NAME_SELECTOR_NUMERIC_CHOSEN)
	{
		transfer_info.destination_conference_name.numeric_string =
			(LPSTR) transfer_request->conference_name.u.name_selector_numeric;
		// transfer_info.destination_conference_name.text_string = NULL;
	}
	else
	{
		// transfer_info.destination_conference_name.numeric_string = NULL;
		if (NULL == (transfer_info.destination_conference_name.text_string = ::My_strdupW2(
							transfer_request->conference_name.u.name_selector_text.length,
							transfer_request->conference_name.u.name_selector_text.value)))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	

	//	Next set up the conference name modifier
	if (transfer_request->bit_mask & CTRQ_CONFERENCE_MODIFIER_PRESENT)
	{
		transfer_info.destination_conference_modifier =
						(LPSTR) transfer_request->ctrq_conference_modifier;
	}
	else
    {
		// transfer_info.destination_conference_modifier = NULL;
    }
	
	//	Next set up the network address
	if (transfer_request->bit_mask & CTRQ_NETWORK_ADDRESS_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		transfer_info.destination_address_list = new CNetAddrListContainer(
								transfer_request->ctrq_net_address,
								&rc);
		if (transfer_info.destination_address_list == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		// transfer_info.destination_address_list = NULL;
    }
	

	//	Set up the transferring nodes list
	if (transfer_request->bit_mask & CTRQ_TRANSFERRING_NODES_PRESENT)
	{
		//	First determine the number of nodes.
		set_of_nodes = transfer_request->ctrq_transferring_nodes;
		// transfer_info.number_of_destination_nodes = 0;
		while (set_of_nodes != NULL)
		{
			transfer_info.number_of_destination_nodes++;
			set_of_nodes = set_of_nodes->next;		
		}

		//	Next allocate the memory required to hold the sub nodes
		DBG_SAVE_FILE_LINE
		sub_node_list_memory = new BYTE[sizeof(UserID) * transfer_info.number_of_destination_nodes];

		//	Now fill in the permission list
		if (sub_node_list_memory != NULL)
		{
			transfer_info.destination_node_list = (PUserID) sub_node_list_memory;

			set_of_nodes = transfer_request->ctrq_transferring_nodes;
			for (i = 0; i < transfer_info.number_of_destination_nodes; i++)
			{
				transfer_info.destination_node_list[i] = set_of_nodes->value;
				set_of_nodes = set_of_nodes->next;
			}
		}
		else
		{
			ERROR_OUT(("MCSUser: ProcessTransferRequestPDU: Memory Manager Alloc Failure"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		// transfer_info.number_of_destination_nodes = 0;
		// transfer_info.destination_node_list = NULL;
	}

	//	Set up the password
	if (transfer_request->bit_mask & CTRQ_PASSWORD_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		transfer_info.password = new CPassword(&transfer_request->ctrq_password, &rc);
		if (transfer_info.password == NULL)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		// transfer_info.password = NULL;
	}

	//	Save the sender ID	
	transfer_info.requesting_node_id = send_data_info->initiator;

	if (rc == GCC_NO_ERROR)
	{
		m_pConf->ProcessConferenceTransferRequest(
						transfer_info.requesting_node_id,
						&transfer_info.destination_conference_name,
						transfer_info.destination_conference_modifier,
						transfer_info.destination_address_list,
						transfer_info.number_of_destination_nodes,
						transfer_info.destination_node_list,
						transfer_info.password);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessTransferRequestPDU: Allocation Failure"));
		if (GCC_ALLOCATION_FAILURE == rc)
		{
            ResourceFailureHandler();
        }
	}

	//	Now cleanup any allocated memory
	if (transfer_info.destination_address_list != NULL)
	{
		transfer_info.destination_address_list->Release();
	}

	delete [] sub_node_list_memory;

	if (transfer_info.password != NULL)
	{
		transfer_info.password->Release();
	}
}

/*
 *	void	ProcessAddRequestPDU ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference Add
 *		request PDU.
 *
 *	Formal Parameters:
 *		conference_add_request	-	(i)	This is the PDU structure to process.
 *		send_data_info			-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessAddRequestPDU (
								PConferenceAddRequest	conference_add_request,
								PSendData				send_data_info)
{
	GCCError			rc = GCC_NO_ERROR;
	AddRequestInfo		add_request_info;

	/*
	**	Ignore this request if this node is NOT the Top Provider and the request
	**	did not come from the Top Provider.
	*/
	if (m_nidTopProvider != m_nidMyself)
	{
		if (m_nidTopProvider != send_data_info->initiator)
			return;	
	}

    ::ZeroMemory(&add_request_info, sizeof(add_request_info));

	DBG_SAVE_FILE_LINE
	add_request_info.network_address_list = new CNetAddrListContainer(
								conference_add_request->add_request_net_address,
								&rc);
	if (add_request_info.network_address_list == NULL)
	{
		rc = GCC_ALLOCATION_FAILURE;
	}

	if ((rc == GCC_NO_ERROR) &&
		(conference_add_request->bit_mask & CARQ_USER_DATA_PRESENT))
	{
		DBG_SAVE_FILE_LINE
		add_request_info.user_data_list = new CUserDataListContainer(conference_add_request->carq_user_data, &rc);
		if (add_request_info.user_data_list == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		// add_request_info.user_data_list = NULL;
    }

	if (rc == GCC_NO_ERROR)
	{
		add_request_info.adding_node = (conference_add_request->bit_mask & ADDING_MCU_PRESENT) ?
                                            conference_add_request->adding_mcu : 0;
		add_request_info.requesting_node = conference_add_request->requesting_node;
		add_request_info.add_request_tag = (TagNumber)conference_add_request->tag;

		m_pConf->ProcessConferenceAddRequest(
    					add_request_info.network_address_list,
    					add_request_info.user_data_list,
    					add_request_info.adding_node,
    					add_request_info.add_request_tag,
    					add_request_info.requesting_node);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessAddRequestPDU: Allocation Failure"));
		if (GCC_ALLOCATION_FAILURE == rc)
		{
            ResourceFailureHandler();
        }
	}

	if (add_request_info.network_address_list != NULL)
	{
		add_request_info.network_address_list->Release();
	}

	if (add_request_info.user_data_list != NULL)
	{
		add_request_info.user_data_list->Release();
	}
}

/*
 *	void	ProcessTransferResponsePDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Transfer response PDU.
 *
 *	Formal Parameters:
 *		transfer_response	-	(i)	This is the PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
#ifdef JASPER
void	MCSUser::ProcessTransferResponsePDU (
								PConferenceTransferResponse	transfer_response)
{
	GCCError					rc = GCC_NO_ERROR;
	TransferInfo				transfer_info;
	PSetOfTransferringNodesRs	set_of_nodes;
	LPBYTE						sub_node_list_memory = NULL;
	Int							i;

    ::ZeroMemory(&transfer_info, sizeof(transfer_info));

	//	First set up the conference name
	if (transfer_response->conference_name.choice ==
												NAME_SELECTOR_NUMERIC_CHOSEN)
	{
		transfer_info.destination_conference_name.numeric_string =
			(LPSTR) transfer_response->conference_name.u.name_selector_numeric;
		// transfer_info.destination_conference_name.text_string = NULL;
	}
	else
	{
		// transfer_info.destination_conference_name.numeric_string = NULL;
		if (NULL == (transfer_info.destination_conference_name.text_string = ::My_strdupW2(
							transfer_response->conference_name.u.name_selector_text.length,
							transfer_response->conference_name.u.name_selector_text.value)))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	//	Next set up the conference name modifier
	if (transfer_response->bit_mask & CTRS_CONFERENCE_MODIFIER_PRESENT)
	{
		transfer_info.destination_conference_modifier =
						(LPSTR) transfer_response->ctrs_conference_modifier;
	}
	else
	{
		// transfer_info.destination_conference_modifier = NULL;
	}

	//	Set up the transferring nodes list
	if (transfer_response->bit_mask & CTRS_TRANSFERRING_NODES_PRESENT)
	{
		//	First determine the number of nodes.
		set_of_nodes = transfer_response->ctrs_transferring_nodes;
		// transfer_info.number_of_destination_nodes = 0;
		while (set_of_nodes != NULL)
		{
			transfer_info.number_of_destination_nodes++;
			set_of_nodes = set_of_nodes->next;		
		}

		//	Next allocate the memory required to hold the sub nodes
		DBG_SAVE_FILE_LINE
		sub_node_list_memory = new BYTE[sizeof(UserID) * transfer_info.number_of_destination_nodes];

		//	Now fill in the permission list
		if (sub_node_list_memory != NULL)
		{
			transfer_info.destination_node_list = (PUserID) sub_node_list_memory;

			set_of_nodes = transfer_response->ctrs_transferring_nodes;
			for (i = 0; i < transfer_info.number_of_destination_nodes; i++)
			{
				transfer_info.destination_node_list[i] = set_of_nodes->value;
				set_of_nodes = set_of_nodes->next;
			}
		}
		else
		{
			ERROR_OUT(("MCSUser: ProcessTransferResponsePDU: Memory Manager Alloc Failure"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		// transfer_info.number_of_destination_nodes = 0;
		// transfer_info.destination_node_list = NULL;
	}
	

	//	Save the result	
	transfer_info.result = (transfer_response->result == CTRANS_RESULT_SUCCESS) ?
                            GCC_RESULT_SUCCESSFUL :
                            GCC_RESULT_INVALID_REQUESTER;

	if (rc == GCC_NO_ERROR)
	{
		g_pControlSap->ConfTransferConfirm(
    							m_pConf->GetConfID(),
    							&transfer_info.destination_conference_name,
    							transfer_info.destination_conference_modifier,
    							transfer_info.number_of_destination_nodes,
    							transfer_info.destination_node_list,
    							transfer_info.result);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessTransferResponsePDU: Allocation Failure"));
		if (GCC_ALLOCATION_FAILURE == rc)
		{
            ResourceFailureHandler();
        }
	}

	//	Now cleanup any allocated memory
	delete sub_node_list_memory;
}
#endif // JASPER


/*
 *	void	ProcessAddResponsePDU ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Add response PDU.
 *
 *	Formal Parameters:
 *		conference_add_response	-	(i)	This is the PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessAddResponsePDU (
						PConferenceAddResponse		conference_add_response)
{
	GCCError				error_value = GCC_NO_ERROR;
	AddResponseInfo			add_response_info;

	if (conference_add_response->bit_mask &	CARS_USER_DATA_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		add_response_info.user_data_list = new CUserDataListContainer(conference_add_response->cars_user_data, &error_value);
		if (add_response_info.user_data_list == NULL)
        {
			error_value = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		add_response_info.user_data_list = NULL;
    }
	
	if (error_value == GCC_NO_ERROR)
	{
		add_response_info.add_request_tag = (TagNumber)conference_add_response->tag;
		add_response_info.result = ::TranslateAddResultToGCCResult(conference_add_response->result);

        m_pConf->ProcessConfAddResponse(&add_response_info);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessAddResponsePDU: Allocation Failure"));
		if (GCC_ALLOCATION_FAILURE == error_value)
		{
            ResourceFailureHandler();
        }
	}

	if (add_response_info.user_data_list != NULL)
	{
		add_response_info.user_data_list->Release();
	}
}

/*
 *	void	ProcessFunctionNotSupported ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing responses for request that
 *		are not supported at the node that the request was directed toward.
 *
 *	Formal Parameters:
 *		request_choice	-	(i)	This is the request that is not supported.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		The existance of this routine does not mean that this provider does
 *		not support it.  It only means that the node which received the
 *		request does not support it.
 */
void MCSUser::
ProcessFunctionNotSupported ( UINT request_choice )
{
	switch (request_choice)
	{
	case CONFERENCE_LOCK_REQUEST_CHOSEN:
#ifdef JASPER
		g_pControlSap->ConfLockConfirm(GCC_RESULT_LOCKED_NOT_SUPPORTED, m_pConf->GetConfID());
#endif // JASPER
		break;

	case CONFERENCE_UNLOCK_REQUEST_CHOSEN:
#ifdef JASPER
		g_pControlSap->ConfUnlockConfirm(GCC_RESULT_UNLOCK_NOT_SUPPORTED, m_pConf->GetConfID());
#endif // JASPER
		break;

	default:
		ERROR_OUT(("MCSUser: ProcessFunctionNotSupported: "
					"Error: Illegal request is unsupported"));
		break;
	}
}

/*
 *	UINT	ProcessUniformSendDataIndication ()
 *
 *	Private Function Description:
 * 		This function is called when the user object gets send data indications
 *		from below. It finds out the message type and decodes the pdu in the
 *		user data field of send data indications. Based on the type of decoded
 *		pdu it take the necessary actions.
 *		This routine is responsible for processing responses for request that
 *		are not supported at the node that the request was directed toward.
 *
 *	Formal Parameters:
 *		send_data_info	-	(i)	This is the MCS data structure to process.
 *
 *	Return Value
 *		MCS_NO_ERROR is always returned.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
UINT	MCSUser::ProcessUniformSendDataIndication(	
						PSendData		send_data_info)
{
	PPacket					packet;
	PacketError				packet_error;
	PGCCPDU					gcc_pdu;
	GCCError				error_value = GCC_NO_ERROR;
	UserID					initiator;
	
	TRACE_OUT(("User: UniformSendDataInd: length = %d",
				send_data_info->user_data.length));

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPBYTE)send_data_info->user_data.value,
						send_data_info->user_data.length,
						GCC_PDU,
						TRUE,
						&packet_error);
	if((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		initiator = send_data_info->initiator;
		gcc_pdu = (PGCCPDU)packet->GetDecodedData();
		switch (gcc_pdu->choice)
		{
			case INDICATION_CHOSEN: // Data PDU
				switch(gcc_pdu->u.indication.choice)
				{
					case CONFERENCE_TERMINATE_INDICATION_CHOSEN:
						/*
						**	Note that we allow the top provider to process
						**	this message so that it can set up its own
						**	node for termination in a generic way.
						*/
						ProcessConferenceTerminateIndicationPDU (
									&gcc_pdu->u.indication.u.
										conference_terminate_indication,
									initiator);
    					break;

					case CONFERENCE_EJECT_USER_INDICATION_CHOSEN:
						/*
						**	Do not decode a packet that was sent uniformly
						**	from this node.
						*/
						if (initiator != m_nidMyself)
						{
							ProcessConferenceEjectUserIndicationPDU (
									&gcc_pdu->u.indication.u.
										conference_eject_user_indication,
									initiator);
						}
						break;

					case ROSTER_UPDATE_INDICATION_CHOSEN:
						/*
						**	Do not decode a packet that was sent uniformly
						**	from this node.
						*/
						if ((initiator != m_nidMyself) &&
							(send_data_info->channel_id ==
													BROADCAST_CHANNEL_ID))
						{
                            //
                            // We only process the roster update if the conference is
                            // established.
                            //
                            if (m_pConf->IsConfEstablished())
                            {
                                m_pConf->ProcessRosterUpdatePDU(gcc_pdu, initiator);
                            }
						}
						break;

					case CONFERENCE_LOCK_INDICATION_CHOSEN:
						m_pConf->ProcessConferenceLockIndication(initiator);
						break;

					case CONFERENCE_UNLOCK_INDICATION_CHOSEN:
						m_pConf->ProcessConferenceUnlockIndication(initiator);
						break;

					case CONDUCTOR_ASSIGN_INDICATION_CHOSEN:
                        m_pConf->ProcessConductorAssignIndication(
                                    gcc_pdu->u.indication.u.conductor_assign_indication.user_id,
                                    initiator);
                        break;

					case CONDUCTOR_RELEASE_INDICATION_CHOSEN:
						if (initiator != m_nidMyself)
						{
							m_pConf->ProcessConductorReleaseIndication(initiator);
						}
						break;

					case CONDUCTOR_PERMISSION_ASK_INDICATION_CHOSEN:
#ifdef JASPER
						/*
						**	Do not decode a packet that was sent uniformly
						**	from this node.
						*/
						if (initiator != m_nidMyself)
						{
							PermitAskIndicationInfo		indication_info;

							indication_info.sender_id = initiator;
							
							indication_info.permission_is_granted =
										gcc_pdu->u.indication.u.
											conductor_permission_ask_indication.
												permission_is_granted;

							m_pConf->ProcessConductorPermitAskIndication(&indication_info);
						}
#endif // JASPER
						break;

					case CONDUCTOR_PERMISSION_GRANT_INDICATION_CHOSEN:
						ProcessPermissionGrantIndication(
									&(gcc_pdu->u.indication.u.
										conductor_permission_grant_indication),
									initiator);
						break;

					case CONFERENCE_TIME_REMAINING_INDICATION_CHOSEN:
#ifdef JASPER
						ProcessTimeRemainingIndicationPDU (
									&gcc_pdu->u.indication.u.
										conference_time_remaining_indication,
									initiator);
#endif // JASPER
						break;
						
					case APPLICATION_INVOKE_INDICATION_CHOSEN:
						ProcessApplicationInvokeIndication(
									&gcc_pdu->u.indication.u.
										application_invoke_indication,
									initiator);
						break;
					
					case TEXT_MESSAGE_INDICATION_CHOSEN:
#ifdef JASPER
						if (ProcessTextMessageIndication(
									&gcc_pdu->u.indication.u.
										text_message_indication,
									initiator) != GCC_NO_ERROR)
						{
							error_value = GCC_ALLOCATION_FAILURE;
						}
#endif // JASPER
						break;

					case CONFERENCE_ASSISTANCE_INDICATION_CHOSEN:
#ifdef JASPER
						ProcessConferenceAssistanceIndicationPDU(
									&gcc_pdu->u.indication.u.
										conference_assistance_indication,
									initiator);
#endif // JASPER
						break;

					case REGISTRY_MONITOR_ENTRY_INDICATION_CHOSEN:
						/*
						**	Do not decode this packet if it was sent
						**	uniformly from this node.
						*/
						if (initiator != m_nidMyself)
						{
							ProcessRegistryMonitorIndicationPDU (
								&gcc_pdu->u.indication.u.
									registry_monitor_entry_indication,
								initiator);
						}
						break;

					case CONFERENCE_TRANSFER_INDICATION_CHOSEN:
#ifdef JASPER
						/*
						**	Do not decode this packet if it was not sent
						**	from the top provider.
						*/
						if (initiator == m_nidTopProvider)
						{
							ProcessTransferIndicationPDU (
								&gcc_pdu->u.indication.u.
									conference_transfer_indication);
						}
#endif // JASPER
						break;

					default:
						ERROR_OUT(("MCSUser::ProcessSendDataIndication"
										"Unsupported PDU"));
						break;
				} // switch(gcc_pdu->u.indication.choice)
	            break;

			default:
				ERROR_OUT(("MCSUser::ProcessUniformSendDataIndication. wrong pdu type "));
				break;
		}
		packet->Unlock();
	}
	else
	{
		delete packet;
		error_value = GCC_ALLOCATION_FAILURE;
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}

	return (MCS_NO_ERROR);
}

/*
 *	void	ProcessTransferIndicationPDU ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Transfer indication PDU.
 *
 *	Formal Parameters:
 *		transfer_indication	-	(i)	This is the PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
#ifdef JASPER
void MCSUser::
ProcessTransferIndicationPDU
(
    PConferenceTransferIndication       transfer_indication
)
{
	GCCError					rc = GCC_NO_ERROR;
	TransferInfo				transfer_info;
	PSetOfTransferringNodesIn	set_of_nodes;
	LPBYTE						sub_node_list_memory = NULL;
	Int							i;
	BOOL						process_pdu = FALSE;

    ::ZeroMemory(&transfer_info, sizeof(transfer_info));

	/*
	**	If there is a transferring node list we must determine if this node
	**	is in the list.  If it isn't then the request is ignored.
	*/
	if (transfer_indication->bit_mask & CTIN_TRANSFERRING_NODES_PRESENT)
	{
		set_of_nodes = transfer_indication->ctin_transferring_nodes;
		while (set_of_nodes != NULL)
		{
			if (set_of_nodes->value == GetMyNodeID())
			{
				process_pdu = TRUE;
				break;
			}

			set_of_nodes = set_of_nodes->next;
		}

		if (process_pdu == FALSE)
		{
			return;
		}
	}

	//	First set up the conference name
	if (transfer_indication->conference_name.choice == NAME_SELECTOR_NUMERIC_CHOSEN)
	{
		transfer_info.destination_conference_name.numeric_string =
                (LPSTR) transfer_indication->conference_name.u.name_selector_numeric;
		// transfer_info.destination_conference_name.text_string = NULL;
	}
	else
	{
		// transfer_info.destination_conference_name.numeric_string = NULL;
		if (NULL == (transfer_info.destination_conference_name.text_string = ::My_strdupW2(
							transfer_indication->conference_name.u.name_selector_text.length,
							transfer_indication->conference_name.u.name_selector_text.value)))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	//	Next set up the conference name modifier
	if (transfer_indication->bit_mask & CTIN_CONFERENCE_MODIFIER_PRESENT)
	{
		transfer_info.destination_conference_modifier =
						(LPSTR) transfer_indication->ctin_conference_modifier;
	}
	else
    {
		// transfer_info.destination_conference_modifier = NULL;
    }

	//	Next set up the network address
	if (transfer_indication->bit_mask & CTIN_NETWORK_ADDRESS_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		transfer_info.destination_address_list = new CNetAddrListContainer(
								transfer_indication->ctin_net_address,
								&rc);
		if (transfer_info.destination_address_list == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		// transfer_info.destination_address_list = NULL;
    }

	//	Set up the transferring nodes list
	if (transfer_indication->bit_mask & CTIN_TRANSFERRING_NODES_PRESENT)
	{
		//	First determine the number of nodes.
		set_of_nodes = transfer_indication->ctin_transferring_nodes;
		// transfer_info.number_of_destination_nodes = 0;
		while (set_of_nodes != NULL)
		{
			transfer_info.number_of_destination_nodes++;
			set_of_nodes = set_of_nodes->next;
		}

		//	Next allocate the memory required to hold the sub nodes
		DBG_SAVE_FILE_LINE
		sub_node_list_memory = new BYTE[sizeof(UserID) * transfer_info.number_of_destination_nodes];

		//	Now fill in the permission list
		if (sub_node_list_memory != NULL)
		{
			transfer_info.destination_node_list = (PUserID) sub_node_list_memory;

			set_of_nodes = transfer_indication->ctin_transferring_nodes;
			for (i = 0; i < transfer_info.number_of_destination_nodes; i++)
			{
				transfer_info.destination_node_list[i] = set_of_nodes->value;
				set_of_nodes = set_of_nodes->next;
			}
		}
		else
		{
			ERROR_OUT(("MCSUser: ProcessTransferIndicationPDU: Memory Manager Alloc Failure"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		// transfer_info.number_of_destination_nodes = 0;
		// transfer_info.destination_node_list = NULL;
	}
	

	//	Set up the password
	if (transfer_indication->bit_mask & CTIN_PASSWORD_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		transfer_info.password = new CPassword(&transfer_indication->ctin_password, &rc);
		if (transfer_info.password == NULL)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		// transfer_info.password = NULL;
	}

	if (rc == GCC_NO_ERROR)
	{
		g_pControlSap->ConfTransferIndication(
							m_pConf->GetConfID(),
							&transfer_info.destination_conference_name,
							transfer_info.destination_conference_modifier,
							transfer_info.destination_address_list,
							transfer_info.password);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessTransferIndicationPDU: Allocation Failure"));
		if (GCC_ALLOCATION_FAILURE == rc)
		{
            ResourceFailureHandler();
        }
	}

	//	Now cleanup any allocated memory
	if (NULL != transfer_info.destination_address_list)
	{
	    transfer_info.destination_address_list->Release();
	}

	delete sub_node_list_memory;

	if (NULL != transfer_info.password)
	{
	    transfer_info.password->Release();
	}
}
#endif // JASPER

/*
 *	void	ProcessConferenceTerminateIndicationPDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Terminate indication PDU.
 *
 *	Formal Parameters:
 *		terminate_indication	-	(i)	This is the PDU structure to process.
 *		sender_id				-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceTerminateIndicationPDU (
						PConferenceTerminateIndication	terminate_indication,
						UserID							sender_id)
{
	if (sender_id == m_nidTopProvider)
	{
		m_pConf->ProcessTerminateIndication(
			::TranslateTerminateInReasonToGCCReason(terminate_indication->reason));
	}
}

/*
 *	void	ProcessTimeRemainingIndicationPDU ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Time remaining indication PDU.
 *
 *	Formal Parameters:
 *		time_remaining_indication	-	(i)	This is the PDU structure to process
 *		sender_id					-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
#ifdef JASPER
void MCSUser::
ProcessTimeRemainingIndicationPDU
(
    PConferenceTimeRemainingIndication      time_remaining_indication,
    UserID                                  sender_id
)
{
    g_pControlSap->ConfTimeRemainingIndication(
                        m_pConf->GetConfID(),
                        sender_id,
                        (time_remaining_indication->bit_mask & TIME_REMAINING_NODE_ID_PRESENT) ?
                            time_remaining_indication->time_remaining_node_id : 0,
                        time_remaining_indication->time_remaining);
}
#endif // JASPER

/*
 *	void	ProcessConferenceAssistanceIndicationPDU ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		assistance indication PDU.
 *
 *	Formal Parameters:
 *		conf_assistance_indication	-	(i)	This is the PDU structure to process
 *		sender_id					-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
#ifdef JASPER
void MCSUser::
ProcessConferenceAssistanceIndicationPDU
(
    PConferenceAssistanceIndication     conf_assistance_indication,
    UserID                              sender_id
)
{
	GCCError				rc = GCC_NO_ERROR;
	CUserDataListContainer  *user_data_list = NULL;

	DebugEntry(MCSUser::ProcessConferenceAssistanceIndication);

	//	Unpack the user data list if it exists
	if (conf_assistance_indication->bit_mask & CAIN_USER_DATA_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		user_data_list = new CUserDataListContainer(conf_assistance_indication->cain_user_data, &rc);
		if (user_data_list == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}

	if (rc == GCC_NO_ERROR)
	{
        g_pControlSap->ConfAssistanceIndication(
                            m_pConf->GetConfID(),
                            user_data_list,
                            sender_id);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessConferenceAssistanceIndication: can't create CUserDataListContainer"));
		if (GCC_ALLOCATION_FAILURE == rc)
		{
            ResourceFailureHandler();
        }
	}
}
#endif // JASPER


/*
 *	void	ProcessConferenceExtendIndicationPDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		extend indication PDU.
 *
 *	Formal Parameters:
 *		conf_time_extend_indication	-	(i)	This is the PDU structure to process
 *		sender_id					-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
#ifdef JASPER
void MCSUser::
ProcessConferenceExtendIndicationPDU
(
    PConferenceTimeExtendIndication     conf_time_extend_indication,
    UserID                              sender_id
)
{
    g_pControlSap->ConfExtendIndication(
                        m_pConf->GetConfID(),
                        conf_time_extend_indication->time_to_extend,
                        conf_time_extend_indication->time_is_node_specific,
                        sender_id);
}
#endif // JASPER

/*
 *	void	ProcessConferenceEjectUserIndicationPDU ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		eject user indication PDU.
 *
 *	Formal Parameters:
 *		eject_user_indication	-	(i)	This is the PDU structure to process
 *		sender_id			 	-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceEjectUserIndicationPDU (
						PConferenceEjectUserIndication	eject_user_indication,
						UserID							sender_id)
{
	GCCError				error_value = GCC_NO_ERROR;
	PAlarm					alarm = NULL;

	//	First check to make sure that this is the node being ejected
	if (eject_user_indication->node_to_eject == m_nidMyself)
	{
		/*
		**	Next make sure the ejection came from either the Top Provider or
		**	the Parent Node.
		*/
		if ((sender_id == m_nidParent) || (sender_id == m_nidTopProvider))
		{
			TRACE_OUT(("MCSUser:ProcessEjectUserIndication: This node is ejected"));
			error_value = InitiateEjectionFromConference (
							::TranslateEjectIndReasonToGCCReason(
										eject_user_indication->reason));
		}
		else
		{
			ERROR_OUT(("MCSUser: ProcessEjectUserIndication: Received eject from illegal node"));
		}
	}
	else
	{
		TRACE_OUT(("MCSUser: ProcessEjectUserIndication: Received eject for node other than mine"));

		/*
		**	If this node is a directly connected child node we insert an
		**	alarm in the list m_EjectedNodeAlarmList2 to disconnect it if
		**	it misbehaves and does not disconnect itself.  Otherwise,  we save
		**	the ejected user id in the m_EjectedNodeList to inform the local
		**	node of the correct reason for disconnecting (user ejected) when the
		**	detch user indication comes in.
		*/
		if (m_ChildUidConnHdlList2.Find(eject_user_indication->node_to_eject))
		{
			DBG_SAVE_FILE_LINE
			alarm = new Alarm (EJECTED_NODE_TIMER_DURATION);
			if (alarm != NULL)
			{
				m_EjectedNodeAlarmList2.Append(eject_user_indication->node_to_eject, alarm);
			}
			else
				error_value = GCC_ALLOCATION_FAILURE;
		}
		else
		{
			/*
			**	Here we save the alarm in a list of ejected nodes. This
			**	alarm is used to cleanup any misbehaving node.  Note that
			**	if the ejected node is not a child of this node then no
			**	alarm is set up to monitor the ejection.
			*/
			m_EjectedNodeList.Append(eject_user_indication->node_to_eject);
		}
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
		ERROR_OUT(("MCSUser::ProcessEjectUserIndication: Allocation Failure"));
        ResourceFailureHandler();
	}
}

/*
 *	void	ProcessPermissionGrantIndication ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Permission
 *		grant indication PDU.
 *
 *	Formal Parameters:
 *		permission_grant_indication	-	(i)	This is the PDU structure to process
 *		sender_id			 		-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessPermissionGrantIndication(
			PConductorPermissionGrantIndication	permission_grant_indication,
			UserID								sender_id)
{
	GCCError									error_value = GCC_NO_ERROR;
	UserPermissionGrantIndicationInfo			grant_indication_info;
	PPermissionList								permission_list;
	LPBYTE										permission_list_memory = NULL;
	PWaitingList								waiting_list;
	LPBYTE										waiting_list_memory = NULL;
	UINT										i;

	//	First count the number of entries in the permission list
	grant_indication_info.number_granted = 0;
	permission_list = permission_grant_indication->permission_list;
	while (permission_list != NULL)
	{
		permission_list = permission_list->next;
		grant_indication_info.number_granted++;
	}
	
	TRACE_OUT(("MCSUser: ProcessPermissionGrantIndication: number_granted=%d", (UINT) grant_indication_info.number_granted));

	//	If a list exist allocate memory for it and copy it over.
	if (grant_indication_info.number_granted != 0)
	{
		// allocating space to hold permission list.
		DBG_SAVE_FILE_LINE
		permission_list_memory = new BYTE[sizeof(UserID) * grant_indication_info.number_granted];

		//	Now fill in the permission list
		if (permission_list_memory != NULL)
		{
			grant_indication_info.granted_node_list = (PUserID) permission_list_memory;

			permission_list = permission_grant_indication->permission_list;
			for (i = 0; i < grant_indication_info.number_granted; i++)
			{
				grant_indication_info.granted_node_list[i] = permission_list->value;
				permission_list = permission_list->next;
			}
		}
		else
		{
			ERROR_OUT(("MCSUser: ProcessPermissionGrantIndication: Memory Manager Alloc Failure"));
			error_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		grant_indication_info.granted_node_list = NULL;
	}

	//	Now extract the waiting list information if any exist
	if ((error_value == GCC_NO_ERROR) &&
		(permission_grant_indication->bit_mask & WAITING_LIST_PRESENT))
	{
		//	First count the number of entries in the waiting list
		grant_indication_info.number_waiting = 0;
		waiting_list = permission_grant_indication->waiting_list;
		while (waiting_list != NULL)
		{
			waiting_list = waiting_list->next;
			grant_indication_info.number_waiting++;
		}

		TRACE_OUT(("MCSUser: ProcessPermissionGrantIndication: number_waiting=%d", (UINT) grant_indication_info.number_waiting));

		// allocating space to hold waiting list.
		DBG_SAVE_FILE_LINE
		waiting_list_memory = new BYTE[sizeof(UserID) * grant_indication_info.number_waiting];

		//	Now fill in the permission list
		if (waiting_list_memory != NULL)
		{
			grant_indication_info.waiting_node_list = (PUserID) waiting_list_memory;

			waiting_list = permission_grant_indication->waiting_list;
			for (i = 0; i < grant_indication_info.number_waiting; i++)
			{
				grant_indication_info.waiting_node_list[i] = waiting_list->value;
				waiting_list = waiting_list->next;
			}
		}
		else
		{
			error_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		grant_indication_info.number_waiting = 0;
		grant_indication_info.waiting_node_list = NULL;
	}

	/*
	**	If there were no memory errors, send the indication back to the
	**	owner object.
	*/
	if (error_value == GCC_NO_ERROR)
	{
		m_pConf->ProcessConductorPermitGrantInd(&grant_indication_info, sender_id);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessPermissionGrantIndication: Alloc Failed"));
		if (GCC_ALLOCATION_FAILURE == error_value)
		{
            ResourceFailureHandler();
        }
	}

	//	Free up any memory used in this call
	delete [] permission_list_memory;
	delete [] waiting_list_memory;
}

/*
 *	MCSUser::GetUserIDFromConnection()
 *
 *	Public Function Description:
 *		This function returns the Node ID associated with the specified
 *		connection handle.  It returns zero if the connection handle is
 *		not a child connection of this node.
 */
UserID MCSUser::GetUserIDFromConnection(ConnectionHandle connection_handle)
{
	ConnectionHandle        hConn;
	UserID                  uid;

	m_ChildUidConnHdlList2.Reset();
	while (NULL != (hConn = m_ChildUidConnHdlList2.Iterate(&uid)))
	{
		if (hConn == connection_handle)
		{
			return uid;
		}
	}
	return 0;
}



/*
 *	MCSUser::UserDisconnectIndication()
 *
 *	Public Function Description:
 *		This function informs the user object when a Node disconnects from
 *		the conference.  This gives the user object a chance to clean up
 *		its internal information base.
 */
void MCSUser::UserDisconnectIndication(UserID disconnected_user)
{
	PAlarm			lpAlarm;

	/*
	**	If this node has a pending ejection we will go ahead and remove the
	**	ejected node from the list.  Once all child nodes have disconnected
	**	we will inform the owner object of the ejection.
	*/	
	if (m_fEjectionPending)
	{
		// Delete the Alarm if it exists
		if (NULL != (lpAlarm = m_EjectedNodeAlarmList2.Remove(disconnected_user)))
		{
			delete lpAlarm;
			/*
			**	Here we must check to see if there are anymore active alarms
			**	in the list.  If so we wait until that node disconnects before
			**	informing the owner object that this node has been ejected.
			**	Otherwise, we complete the ejection process.
			*/
			if (m_EjectedNodeAlarmList2.IsEmpty())
			{
				m_pConf->ProcessEjectUserIndication(m_eEjectReason);
			}
		}
	}
	// If we are the top provider, just clean the eject alarm list.
	else if (TOP_PROVIDER_AND_CONVENER_NODE == m_pConf->GetConfNodeType() &&
			 NULL != (lpAlarm = m_EjectedNodeAlarmList2.Remove(disconnected_user)))
	{
			delete lpAlarm;
	}
	
	/*
	**	Here we remove the entry from the list of child connections if
	**	it is included in this list.
	*/
	m_ChildUidConnHdlList2.Remove(disconnected_user);
}

/*
 *	void	ProcessApplicationInvokeIndication ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Invoke
 *		indication PDU.
 *
 *	Formal Parameters:
 *		invoke_indication	-	(i)	This is the PDU structure to process
 *		sender_id		 	-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessApplicationInvokeIndication(
							PApplicationInvokeIndication	invoke_indication,
							UserID							sender_id)
{
	GCCError							error_value = GCC_NO_ERROR;
	BOOL								process_pdu = FALSE;
	CInvokeSpecifierListContainer		*invoke_list;
	PSetOfDestinationNodes				set_of_destination_nodes;
	
	if (invoke_indication->bit_mask & DESTINATION_NODES_PRESENT)
	{
		set_of_destination_nodes = invoke_indication->destination_nodes;
		while (set_of_destination_nodes != NULL)
		{
			if (set_of_destination_nodes->value == m_nidMyself)
			{
				process_pdu = TRUE;
				break;
			}
			else
			{
				set_of_destination_nodes = set_of_destination_nodes->next;
			}
		}
	}
	else
	{
		process_pdu = TRUE;
	}

	if (process_pdu)
	{
		TRACE_OUT(("MCSUser: ProcessApplicationInvokeIndication: Process PDU"));
		DBG_SAVE_FILE_LINE
		invoke_list = new CInvokeSpecifierListContainer(
							invoke_indication->application_protocol_entity_list,
							&error_value);
		if ((invoke_list != NULL) && (error_value == GCC_NO_ERROR))
		{
			m_pConf->ProcessAppInvokeIndication(invoke_list, sender_id);
			invoke_list->Release();
		}
		else if (invoke_list == NULL)
		{
			error_value = GCC_ALLOCATION_FAILURE;
		}
		else
		{
			invoke_list->Release();
		}

		if (error_value == GCC_ALLOCATION_FAILURE)
		{
			ERROR_OUT(("MCSUser::ProcessApplicationInvokeIndication: Allocation Failure"));
            ResourceFailureHandler();
		}
	}
	else
	{
		WARNING_OUT(("MCSUser:ProcessApplicationInvokeIndication: Don't Process PDU"));
	}
}

/*
 *	GCCError	ProcessTextMessageIndication ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Text
 *		message indication PDU.
 *
 *	Formal Parameters:
 *		text_message_indication	-	(i)	This is the PDU structure to process
 *		sender_id		 		-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
#ifdef JASPER
GCCError	MCSUser::ProcessTextMessageIndication(
							PTextMessageIndication	text_message_indication,
							UserID					sender_id)
{
	LPWSTR					gcc_unicode_string;
	GCCError				rc;

	if (NULL != (gcc_unicode_string = ::My_strdupW2(
					text_message_indication->message.length,
					text_message_indication->message.value)))
	{
		rc = g_pControlSap->TextMessageIndication(
                                    m_pConf->GetConfID(),
                                    gcc_unicode_string,
                                    sender_id);
	}
	else
    {
		rc = GCC_ALLOCATION_FAILURE;
    }

	return rc;
}
#endif // JASPER

/*
 *	void	ProcessRegistryMonitorIndication ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Registry
 *		monitor indication PDU.
 *
 *	Formal Parameters:
 *		monitor_indication	-	(i)	This is the PDU structure to process
 *		sender_id		  	-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessRegistryMonitorIndicationPDU
(
    PRegistryMonitorEntryIndication     monitor_indication,
    UserID                              sender_id
)
{
    if (sender_id == m_nidTopProvider)
    {
        CRegistry   *pAppReg = m_pConf->GetRegistry();
        if (NULL != pAppReg)
        {
            GCCError                    rc;
            UserRegistryMonitorInfo     urmi;

            ::ZeroMemory(&urmi, sizeof(urmi));
            // urmi.registry_key = NULL;
            // urmi.registry_item = NULL;

            DBG_SAVE_FILE_LINE
            urmi.registry_key = new CRegKeyContainer(&monitor_indication->key, &rc);
            if ((urmi.registry_key != NULL) && (rc == GCC_NO_ERROR))
            {
                DBG_SAVE_FILE_LINE
                urmi.registry_item = new CRegItem(&monitor_indication->item, &rc);
                if ((urmi.registry_item != NULL) && (rc == GCC_NO_ERROR))
                {
                    //	Set up the owner related variables	
                    if (monitor_indication->owner.choice == OWNED_CHOSEN)
                    {
                        urmi.owner_node_id = monitor_indication->owner.u.owned.node_id;
                        urmi.owner_entity_id = monitor_indication->owner.u.owned.entity_id;
                    }
                    else
                    {
                        // urmi.owner_node_id = 0;
                        // urmi.owner_entity_id = 0;
                    }

                    //	Set up the modification rights
                    if (monitor_indication->bit_mask & RESPONSE_MODIFY_RIGHTS_PRESENT)
                    {
                        urmi.modification_rights = (GCCModificationRights)monitor_indication->entry_modify_rights;
                    }
                    else
                    {
                        urmi.modification_rights = GCC_NO_MODIFICATION_RIGHTS_SPECIFIED;
                    }

                    pAppReg->ProcessMonitorIndicationPDU(
                                        urmi.registry_key,
                                        urmi.registry_item,
                                        urmi.modification_rights,
                                        urmi.owner_node_id,
                                        urmi.owner_entity_id);
                }
                else
                {
                    rc = GCC_ALLOCATION_FAILURE;
                }
            }
            else
            {
                rc = GCC_ALLOCATION_FAILURE;
            }

            if (NULL != urmi.registry_key)
            {
                urmi.registry_key->Release();
            }
            if (NULL != urmi.registry_item)
            {
                urmi.registry_item->Release();
            }

            //	Handle any resource errors	
            if (rc == GCC_ALLOCATION_FAILURE)
            {
                ResourceFailureHandler();
            }
        }
        else
        {
            WARNING_OUT(("MCSUser:ProcessRegistryMonitorIndication: invalid app registry"));
        }
    }
    else
    {
        WARNING_OUT(("MCSUser:ProcessRegistryMonitorIndication:"
                        "Monitor Indication received from NON Top Provider"));
    }
}

/*
 *	UINT	ProcessDetachUserIndication()
 *
 *	Private Function Description:
 * 		This function is called when the user object gets detach user
 *		indications from nodes in it's subtree or it's parent node.
 *		Depending upon the reason of the indication it sends to the
 *		conference object the appropriate owner callback.
 * 		If the reason contained in the indication is UserInitiated or
 *		provider initiated a DETACH USER INDICATION is sent to the con-
 *		ference. The MCS reason is converted to GCC reason. If MCS
 *		reason in indication is neither user initiated nor provider initiated
 *		then the above owner callback carries a GCC reason ERROR_TERMINATION
 *		else it carries a GCC reason USER_INITIATED.
 *		If the detach user indication reveals the user id of the sendar as
 *		the parent user id of this node a CONFERENCE_TERMINATE_INDICATION
 *		is sent to the conference object.
 *
 *	Formal Parameters:
 *		mcs_reason	-	(i)	MCS reason for being detached.
 *		sender_id	-	(i)	User ID of user being detached.
 *
 *	Return Value
 *		MCS_NO_ERROR is always returned fro this routine.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
UINT	MCSUser::ProcessDetachUserIndication(	Reason		mcs_reason,
												UserID		detached_user)
{
	GCCReason				gcc_reason;

	if (detached_user == m_nidParent)
	{
		WARNING_OUT(("MCSUser: Fatal Error: Parent User Detached"));
		m_pConf->ProcessTerminateIndication(GCC_REASON_PARENT_DISCONNECTED);
	}
    else
    {
		TRACE_OUT(("MCSUser: User Detached: uid=0x%04x", (UINT) detached_user));

		/*
		**	First, we check to see if the detching node was ejected.
		**	If not, translate the mcs reason to a gcc reason.
		*/
		if (m_EjectedNodeList.Find(detached_user))
		{
			gcc_reason = GCC_REASON_NODE_EJECTED;
			
			//	Remove this entry from the ejected node list.
			m_EjectedNodeList.Remove(detached_user);
		}
		else if (m_EjectedNodeAlarmList2.Find(detached_user))
		{
			//	Here we wait for the disconnect before removing the entry.
			gcc_reason = GCC_REASON_NODE_EJECTED;
		}
		else if ((mcs_reason == REASON_USER_REQUESTED) ||
			(mcs_reason == REASON_PROVIDER_INITIATED))
        {
	    	gcc_reason = GCC_REASON_USER_INITIATED;
		}
        else
        {
			gcc_reason = GCC_REASON_ERROR_TERMINATION;
        }

        m_pConf->ProcessDetachUserIndication(detached_user, gcc_reason);
	}
	return (MCS_NO_ERROR);
}


void MCSUser::
ProcessTokenGrabConfirm
(
    TokenID         tidConductor,
    Result          result
)
{
    if (tidConductor == CONDUCTOR_TOKEN_ID)
    {
        m_pConf->ProcessConductorGrabConfirm(::TranslateMCSResultToGCCResult(result));
    }
    else
    {
        ERROR_OUT(("MCSUser:Assertion Failure: Non Conductor Grab Confirm"));
    }
}


void MCSUser::
ProcessTokenGiveIndication
(
    TokenID         tidConductor,
    UserID          uidRecipient
)
{
    if (tidConductor == CONDUCTOR_TOKEN_ID)
    {
        m_pConf->ProcessConductorGiveIndication(uidRecipient);
    }
    else
    {
        ERROR_OUT(("MCSUser:Assertion Failure: Non Conductor Please Ind"));
    }
}


void MCSUser::
ProcessTokenGiveConfirm
(
    TokenID         tidConductor,
    Result          result
)
{
    if (tidConductor == CONDUCTOR_TOKEN_ID)
    {
        m_pConf->ProcessConductorGiveConfirm(::TranslateMCSResultToGCCResult(result));
    }
    else
    {
        ERROR_OUT(("MCSUser:Assertion Failure: Non Conductor Grab Confirm"));
    }
}


#ifdef JASPER
void MCSUser::
ProcessTokenPleaseIndication
(
    TokenID         tidConductor,
    UserID          uidRequester
)
{
    if (tidConductor == CONDUCTOR_TOKEN_ID)
    {
        if (m_pConf->IsConfConductible())
        {
            //	Inform the control SAP.
            g_pControlSap->ConductorPleaseIndication(
                                        m_pConf->GetConfID(),
                                        uidRequester);
        }
    }
    else
    {
        ERROR_OUT(("MCSUser:Assertion Failure: Non Conductor Please Ind"));
    }
}
#endif // JASPER


#ifdef JASPER
void MCSUser::
ProcessTokenReleaseConfirm
(
    TokenID         tidConductor,
    Result          result
)
{
    if (tidConductor == CONDUCTOR_TOKEN_ID)
    {
        g_pControlSap->ConductorReleaseConfirm(::TranslateMCSResultToGCCResult(result),
                                               m_pConf->GetConfID());
    }
    else
    {
        ERROR_OUT(("MCSUser:Assertion Failure: Non Conductor Release Cfrm"));
    }
}
#endif // JASPER


void MCSUser::
ProcessTokenTestConfirm
(
    TokenID         tidConductor,
    TokenStatus     eStatus
)
{
    if (tidConductor == CONDUCTOR_TOKEN_ID)
    {
        m_pConf->ProcessConductorTestConfirm((eStatus == TOKEN_NOT_IN_USE) ?
                                                GCC_RESULT_NOT_IN_CONDUCTED_MODE :
                                                GCC_RESULT_SUCCESSFUL);
    }
    else
    {
        ERROR_OUT(("MCSUser:Assertion Failure: Non Conductor Release Cfrm"));
    }
}



void MCSUser::ResourceFailureHandler(void)
{
    ERROR_OUT(("MCSUser::ResourceFailureHandler: terminating the conference"));
    m_pConf->InitiateTermination(GCC_REASON_ERROR_LOW_RESOURCES, 0);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\nccglbl.hpp ===
/****************************************************************************/
/*                                                                          */
/* NCCGLBL.HPP                                                              */
/*                                                                          */
/* Global header for NCC.                                                   */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  11Sep95 NFC             Created.                                        */
/*                                                                          */
/****************************************************************************/

#ifndef __NCCGLBL_H_
#define __NCCGLBL_H_

#include "sap.h" // for NCUIMSG_BASE

enum
{
    NCMSG_QUERY_REMOTE_FAILURE  = NCMSG_BASE + 0,
    NCMSG_FIRST_ROSTER_RECVD    = NCMSG_BASE + 1,
};


#ifdef _DEBUG
extern BOOL    g_fInterfaceBreak;
__inline void InterfaceEntry(void) { if (g_fInterfaceBreak) DebugBreak(); }
#else
#define InterfaceEntry()    
#endif // _DEBUG


HRESULT GetGCCRCDetails(GCCError gccRC);

HRESULT GetGCCResultDetails(GCCResult gccRC);

GCCResult MapRCToGCCResult(HRESULT rc);

LPWSTR GetNodeName(void);

#endif /* __NCCGLBL_H_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\ogcccode.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	ogcccode.cpp
 *	
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the CGCCCoder class.  This class
 *		is responsible for encoding and decoding GCC (T.124) PDU's using ASN.1 
 *		encoding rules via the ASN.1 toolkit.  This class is also capable
 *		of determining the size of both the encoded and decoded PDU's. 
 *
 *	Static Variables:
 *
 *	Caveats:
 *		Only one instance of this class should be in existance at any one time
 *		due to the static variable.
 *
 *	Author:
 *		John B. O'Nan
 */

/*
 *	External Interfaces
 */
#include <string.h>
#include "ogcccode.h"

/*
 *	This is a global variable that has a pointer to the one GCC coder that
 *	is instantiated by the GCC Controller.  Most objects know in advance 
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
CGCCCoder	*g_GCCCoder;

/*
 *	CGCCCoder ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the CGCCCoder class.  It initializes
 *		the ASN.1 encoder/decoder and sets the encoding rules to the
 *		Packed-Aligned variant.
 */
CGCCCoder::CGCCCoder ()
:m_pEncInfo(NULL),
 m_pDecInfo(NULL)
{
// lonchanc: We should move Init out of constructor. However,
// to minimize the changes in the GCC/MCS code, we put it here for now.
// Otherwise, we need to change MCS and Packet interfaces.
// We will move it out and call Init() separately.
	Init();
}

BOOL CGCCCoder::Init ( void )
{
	BOOL fRet = FALSE;
	GCCPDU_Module_Startup();
	if (GCCPDU_Module != NULL)
	{
		if (ASN1_CreateEncoder(
                            GCCPDU_Module,	// ptr to mdule
                            &m_pEncInfo,	// ptr to encoder info
                            NULL,			// buffer ptr
                            0,				// buffer size
                            NULL)			// parent ptr
			== ASN1_SUCCESS)
		{
			ASSERT(m_pEncInfo != NULL);
			fRet = (ASN1_CreateDecoder(
                                GCCPDU_Module,	// ptr to mdule
                                &m_pDecInfo,	// ptr to decoder info
                                NULL,			// buffer ptr
                                0,				// buffer size
                                NULL)			// parent ptr
					== ASN1_SUCCESS);
			ASSERT(fRet && m_pDecInfo != NULL);
		}
	}
	ASSERT(fRet);
	return fRet;
}

/*
 *	~CGCCCoder ()
 *
 *	Public Functional Description:
 *		This is a virtual destructor.  It is used to clean up after ASN.1.
 */
CGCCCoder::~CGCCCoder ()
{
	if (GCCPDU_Module != NULL)
	{
	    ASN1_CloseEncoder(m_pEncInfo);
	    ASN1_CloseDecoder(m_pDecInfo);
	    GCCPDU_Module_Cleanup();
	}
}

/*
 *	Encode ()
 *
 *	Public Functional Description:
 *		This function encodes GCC Protocol Data Units (PDU's) into ASN.1 
 *		compliant byte streams using the ASN.1 toolkit.
 *		The coder allocates the buffer space for the encoded data.
 */
BOOL	CGCCCoder::Encode(LPVOID		pdu_structure,
							int			pdu_type,
							UINT		nEncodingRule_not_used,
							LPBYTE		*encoding_buffer,
							UINT		*encoding_buffer_length)
{
	BOOL			fRet = FALSE;
	int				return_value;
	ConnectData		connect_data_structure;

	// clean up local buffer pointer
	connect_data_structure.connect_pdu.value = NULL;

	/*
	 * If the PDU to be encoded is a "ConnectGCC" PDU we must first encode the
	 * "ConnectGCC" PDU.  A "ConnectData" PDU structure is then built which 
	 * contains the encoded "ConnectGCC" PDU along with object identifier key.  
	 * The "ConnectData" PDU is then encoded into the provided buffer.
	 */ 
	if (pdu_type == CONNECT_GCC_PDU)
	{
		return_value = ASN1_Encode(m_pEncInfo,	// ptr to encoder info
									 pdu_structure,	// pdu data structure
									 pdu_type,		// pdu id
									 ASN1ENCODE_ALLOCATEBUFFER, // flags
									 NULL,			// do not provide buffer
									 0);			// buffer size if provided
		if (ASN1_FAILED(return_value))
		{
			ERROR_OUT(("CGCCCoder::Encode: ASN1_Encode failed, err=%d in CONNECT_GCC_PDU.",
						return_value));
			ASSERT(FALSE);
			goto MyExit;
		}
		ASSERT(return_value == ASN1_SUCCESS);
		/*
		 * Fill in the "ConnectData" PDU structure and encode it.
		 */
		connect_data_structure.t124_identifier = t124identifier;

		connect_data_structure.connect_pdu.length = m_pEncInfo->len; // len of encoded data in buffer
		connect_data_structure.connect_pdu.value = m_pEncInfo->buf;  // buffer to encode into

		// Prepare for the encode call
		pdu_structure = (LPVOID) &connect_data_structure;
		pdu_type = CONNECT_DATA_PDU;
	}

	/* 
	 * Encode the Non-Connect PDU into the buffer provided.
	 */
	return_value = ASN1_Encode(m_pEncInfo,		// ptr to encoder info
								pdu_structure,	// pdu data structure
								pdu_type,		// pdu id
								ASN1ENCODE_ALLOCATEBUFFER, // flags
								NULL,			// do not provide buffer
								0);				// buffer size if provided
	if (ASN1_FAILED(return_value))
	{
		ERROR_OUT(("CGCCCoder::Encode: ASN1_Encode failed, err=%d", return_value));
		ASSERT(FALSE);
		goto MyExit;
	}
	ASSERT(return_value == ASN1_SUCCESS);
	*encoding_buffer_length = m_pEncInfo->len;	// len of encoded data in buffer
	*encoding_buffer = m_pEncInfo->buf;			// buffer to encode into
	fRet = TRUE;

MyExit:

	/*
	 *	If this was a CONNECT_DATA_PDU we need to free the buffer that
	 *	was allocated by ASN.1.
	 */
	if (CONNECT_DATA_PDU == pdu_type && connect_data_structure.connect_pdu.value != NULL)
	{
		ASN1_FreeEncoded(m_pEncInfo, connect_data_structure.connect_pdu.value);
	}

	return fRet;
}

/*
 *	Decode ()
 *
 *	Public Functional Description:
 *		This function decodes ASN.1 compliant byte streams into the
 *		appropriate GCC PDU structures using the ASN.1 toolkit.
 */
BOOL	CGCCCoder::Decode(LPBYTE		encoded_buffer,
							UINT		encoded_buffer_length,
							int			pdu_type,
							UINT		nEncodingRule_not_used,
							LPVOID		*pdecoding_buffer,
							UINT		*pdecoding_buffer_length)
{
	BOOL	fRet = FALSE;
	int		return_value;
	LPVOID	connect_data_decoding_buffer = NULL;
	ASN1optionparam_s OptParam;

	/*
	 * If the PDU is a "ConnectGCC" PDU then after it is decoded we must decode
	 * the "ConnectGCC" PDU which is actually contained within a "ConnectData"
	 * PDU.
	 */
	if (pdu_type == CONNECT_GCC_PDU)
	{
		return_value = ASN1_Decode(m_pDecInfo,		// ptr to decoder info
								&connect_data_decoding_buffer,	// destination buffer
								CONNECT_DATA_PDU,				// pdu type
								ASN1DECODE_SETBUFFER,			// flags
								encoded_buffer,					// source buffer
								encoded_buffer_length);			// source buffer size
		if (ASN1_FAILED(return_value))
		{
			ERROR_OUT(("CGCCCoder::Decode: ASN1_Decode failed, err=%d", return_value));
			ASSERT(FALSE);
			goto MyExit;
		}
		ASSERT(return_value == ASN1_SUCCESS);

		/*
		 * If the decoded PDU is a "ConnectData" PDU, then we first must check
		 * to make sure this PDU originated from a T.124-compliant source.
		 * If so we then decode the "ConnectGCC" PDU which is held in the 
		 * "connect_pdu" field.  If the PDU is not T.124-compliant, we will
		 * report an error which will cause the PDU to be rejected.
		 */
		if (IsObjectIDCompliant(&(((PConnectData) connect_data_decoding_buffer)->t124_identifier)) 
																				== FALSE)
		{
			ERROR_OUT(("CGCCCoder::Decode: Non-T.124 objectID"));
			ASSERT (FALSE);
			goto MyExit;
		}
		ASSERT(connect_data_decoding_buffer != NULL);
		encoded_buffer = (PUChar)((PConnectData) connect_data_decoding_buffer)->
							connect_pdu.value;
		encoded_buffer_length = (UINT)((PConnectData) connect_data_decoding_buffer)->
								connect_pdu.length;
	}

	/* 
	 * Decode the Non-Connect PDU into the buffer provided.
	 */
	return_value = ASN1_Decode(m_pDecInfo,	// ptr to decoder info
							pdecoding_buffer,			// destination buffer
							pdu_type,					// pdu type
							ASN1DECODE_SETBUFFER,		// flags
							encoded_buffer,				// source buffer
							encoded_buffer_length);		// source buffer size
	if (ASN1_FAILED(return_value))
	{
		ERROR_OUT(("CCCCoder::Decode: ASN1_Decode failed, err=%d", return_value));
		ASSERT(FALSE);
		goto MyExit;
	}
	ASSERT(return_value == ASN1_SUCCESS);

    OptParam.eOption = ASN1OPT_GET_DECODED_BUFFER_SIZE;
	return_value = ASN1_GetDecoderOption(m_pDecInfo, &OptParam);
	if (ASN1_FAILED(return_value))
	{
		ERROR_OUT(("CGCCCoder::Decode: ASN1_GetDecoderOption failed, err=%d", return_value));
		ASSERT(FALSE);
		goto MyExit;
	}
    *pdecoding_buffer_length = OptParam.cbRequiredDecodedBufSize;

	ASSERT(return_value == ASN1_SUCCESS);
	ASSERT(*pdecoding_buffer_length > 0);

	fRet = TRUE;

MyExit:

	/*
	 * Free the PDU structure allocated by decoder for the Connect-Data PDU.
	 */
	if (connect_data_decoding_buffer != NULL)
	{
		ASSERT (pdu_type == CONNECT_GCC_PDU);
		ASN1_FreeDecoded(m_pDecInfo, connect_data_decoding_buffer, CONNECT_DATA_PDU);
	}

	return fRet;
}

/*
 *	IsObjectIDCompliant ()
 *
 *	Private Functional Description:
 *		This function is used to verify that the object identifier contained
 * 		in a "Connect" PDU is compliant with this version of GCC.
 */
BOOL	CGCCCoder::IsObjectIDCompliant (PKey	t124_identifier)
{
	BOOL				return_value = TRUE;
	PSetOfObjectID		test_object_id_set;
	PSetOfObjectID		valid_object_id_set;

	/*
	 * First check to make sure that the identifier is a standard Object 
	 * Identifier type.
	 */
	if (t124_identifier->choice == OBJECT_CHOSEN)
	{
		/*
		 * Retrieve the object identifier to test and the valid	T.124 
		 * identifier ("t124identifier) to use as a comparison.
		 */
		test_object_id_set = t124_identifier->u.object;
		valid_object_id_set = t124identifier.u.object;

		while ((valid_object_id_set != NULL) && (test_object_id_set != NULL)) 
		{
			if (test_object_id_set->value != valid_object_id_set->value)
			{
				return_value = FALSE;
				break;
			}

			test_object_id_set = test_object_id_set->next;
			valid_object_id_set = valid_object_id_set->next;
		}
	}
	else
		return_value = FALSE;

	return (return_value);
}


void CGCCCoder::FreeEncoded (PUChar encoded_buffer)
{
    ASN1_FreeEncoded(m_pEncInfo, encoded_buffer);
}

void CGCCCoder::FreeDecoded (int pdu_type, LPVOID decoded_buffer)
{
    ASN1_FreeDecoded(m_pDecInfo, decoded_buffer, pdu_type);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\omcscode.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	omcscode.cpp
 *	
 *	Copyright (c) 1993 - 1996 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the CMCSCoder class.  This class
 *		is responsible for encoding and decoding T.125 PDU's using ASN.1 
 *		encoding rules via the ASN.1 toolkit.  This class is also capable
 *		of determining the size of both the encoded and decoded PDU's and is 
 *		capable of making copies of each of the PDU's. 
 *
 *	Private Instance Variables:
 *		Encoding_Rules_Type
 *			This variable holds the type of encoding rules which are currently
 *			being utilized.
 *
 *	Private Member Functions:
 *
 *		Copy***
 *			Private member functions exist which are capable of making complete
 *			copies of the decoded "Send Data" PDU data structures.  These 
 *			routines copy not only the data contained within the structure but 
 *			also any data which is referenced by the pointers held within the 
 *			structure.
 *
 *		SetEncodingRules
 *			This routine is used to switch between using Basic Encoding Rules
 *			(BER) and Packed Encoding Rules (PER).  This routine also updates
 *			the private instance variables used to hold values for the minimum
 *			and maximum amount of overhead associated with the "send data" PDUs.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		John B. O'Nan
 */

#include "omcscode.h"

/*
 * Macros.
 */
#define		BOOLEAN_TAG						0x01
#define		INTEGER_TAG						0x02
#define		BIT_STRING_TAG	   				0x03
#define		OCTET_STRING_TAG	   			0x04
#define		ENUMERATED_TAG	   				0x0a

#define		SEQUENCE						0x30
#define		SETOF							0x31
#define		INDEFINITE_LENGTH				0x80
#define		ONE_BYTE_LENGTH					0x81
#define		TWO_BYTE_LENGTH					0x82
#define		THREE_BYTE_LENGTH				0x83
#define		FOUR_BYTE_LENGTH				0x84
#define		END_OF_CONTENTS					0x00

#define		CONSTRUCTED_TAG_ZERO			0xa0	
#define		CONSTRUCTED_TAG_ONE				0xa1	
#define		CONSTRUCTED_TAG_TWO				0xa2	
#define		CONSTRUCTED_TAG_THREE			0xa3	
#define		CONSTRUCTED_TAG_FOUR			0xa4

/*
 *	This is a global variable that has a pointer to the one MCS coder that
 *	is instantiated by the MCS Controller.  Most objects know in advance 
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
CMCSCoder	*g_MCSCoder;

/*
 *	The following array contains a template for the X.224 data header.
 *	The 5 of the 7 bytes that it initializes are actually sent to the
 *	wire.  Bytes 3 and 4 will be set to contain the size of the PDU.
 *	The array is only used when we encode a data PDU.
 */
UChar g_X224Header[] = { 3, 0, 0, 0, 2, DATA_PACKET, EOT_BIT };

/*
 *	CMCSCoder ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the CMCSCoder class.  It initializes
 *		the ASN.1 encoder/decoder, saves the current encoding rules type,
 *		and sets values for the highest and lowest overhead in the "send data"
 *		PDU's.
 */
CMCSCoder::CMCSCoder ()
:m_pEncInfo(NULL),
 m_pDecInfo(NULL)
{
	Encoding_Rules_Type = BASIC_ENCODING_RULES;
// lonchanc: We should move Init out of constructor. However,
// to minimize the changes in the GCC/MCS code, we put it here for now.
// Otherwise, we need to change MCS and Packet interfaces.
// We will move it out and call Init() separately.
	Init();
}

BOOL CMCSCoder::Init ( void )
{
	BOOL fRet = FALSE;
	MCSPDU_Module_Startup();
	if (MCSPDU_Module != NULL)
	{
		if (ASN1_CreateEncoder(
                            MCSPDU_Module,	// ptr to mdule
                            &m_pEncInfo,	// ptr to encoder info
                            NULL,			// buffer ptr
                            0,				// buffer size
                            NULL)			// parent ptr
			== ASN1_SUCCESS)
		{
			ASSERT(m_pEncInfo != NULL);
			m_pEncInfo->cbExtraHeader = PROTOCOL_OVERHEAD_X224;
			fRet = (ASN1_CreateDecoder(
                                MCSPDU_Module,	// ptr to mdule
                                &m_pDecInfo,	// ptr to decoder info
                                NULL,			// buffer ptr
                                0,				// buffer size
                                NULL)			// parent ptr
					== ASN1_SUCCESS);
			ASSERT(fRet && m_pDecInfo != NULL);
		}
	}
	ASSERT(fRet);
	return fRet;
}

/*
 *	~CMCSCoder ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is a virtual destructor.  It is used to clean up after ASN.1.
 */
CMCSCoder::~CMCSCoder ()
{
	if (MCSPDU_Module != NULL)
	{
		ASN1_CloseEncoder(m_pEncInfo);
		ASN1_CloseDecoder(m_pDecInfo);
	    MCSPDU_Module_Cleanup();
	}
}

/*
 *	void	Encode ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function encodes MCS protocol data units (PDU's) into ASN.1 
 *		compliant byte streams using the ASN.1 toolkit.
 *		The encode happens in a coder-allocated buffer.
 */
BOOL	CMCSCoder::Encode(LPVOID			pdu_structure,
							int				pdu_type,
							UINT			rules_type,
							LPBYTE			*encoding_buffer,
							UINT			*encoding_buffer_length)
{
	BOOL					fRet = TRUE;
	BOOL					send_data_pdu = FALSE;
	int						return_value;

	//UINT					encoding_length;
	UShort					initiator;
	LPBYTE					buffer_pointer;
	PSendDataRequestPDU		send_data;
	UINT					PDUChoice;
	BOOL					bBufferAllocated;
	PMemory					memory;

	/*
	 * Check to make sure the encoding rules type is properly set.
	 */
	ASSERT(rules_type == PACKED_ENCODING_RULES || pdu_type == CONNECT_MCS_PDU);
	if (pdu_type == DOMAIN_MCS_PDU)
	{
		/*
		 *	Set PDUChoice to the type of MCS PDU we need to encode.
		 *	Also, determine if this is a data PDU.
		 */
		PDUChoice = (unsigned int) ((PDomainMCSPDU) pdu_structure)->choice;
		if ((PDUChoice == SEND_DATA_REQUEST_CHOSEN) ||
			(PDUChoice == SEND_DATA_INDICATION_CHOSEN) ||
			(PDUChoice == UNIFORM_SEND_DATA_REQUEST_CHOSEN) ||
			(PDUChoice == UNIFORM_SEND_DATA_INDICATION_CHOSEN)) {
			send_data_pdu = TRUE;
			send_data = &((PDomainMCSPDU) pdu_structure)->u.send_data_request;
			bBufferAllocated = (*encoding_buffer == NULL);
			if (bBufferAllocated) {
				// We have to allocate the encoded buffer.
				DBG_SAVE_FILE_LINE
				memory = AllocateMemory (NULL,
								send_data->user_data.length + MAXIMUM_PROTOCOL_OVERHEAD,
								SEND_PRIORITY);
				if (memory != NULL) {
					buffer_pointer = *encoding_buffer = (LPBYTE) memory->GetPointer();
				}
				else {
					WARNING_OUT (("CMCSCoder::Encode: Failed to allocate space for "
								"encoded data PDU for send."));
					fRet = FALSE;
					ASSERT (*encoding_buffer == NULL);
					goto MyExit;
				}
			}
			else {
				// All the space needed here has been pre-allocated
				buffer_pointer = *encoding_buffer;
			}
		}

		/*
		 *	Check if this is a data PDU
		 */
		if (send_data_pdu)
		{
#ifdef ENABLE_BER
			
			/*
			 * If we are currently using Basic Encoding Rules.
			 */
			if (Encoding_Rules_Type == BASIC_ENCODING_RULES)
			{
				/*
				 * The long variant of length must be used if the octet string
				 * is longer than 127 bytes.  The upper bit of the length byte
				 * is set and the lower bits indicate the number of length bytes 
				 * which will follow.
				 */
				*(buffer_pointer--) = (UChar)send_data->user_data.length;
				if (send_data->user_data.length > 127)
				{
					*(buffer_pointer--) = (UChar)(send_data->user_data.length >> 8);
					*(buffer_pointer--) = TWO_BYTE_LENGTH;
					encoding_length = 3;
				}
				else 
				{
					encoding_length = 1;
				}

				/*
				 * Encode the "user data" octet string.
				 */										
				*(buffer_pointer--) = OCTET_STRING_TAG;

				/*
				 * Encode the "segmentation" bit string field.  The identifier
				 * is followed by a length of 2 and a byte indicating that 6
				 * bits are unused in the actual bit string byte.
				 */
				*(buffer_pointer--) = (UChar) send_data->segmentation;
				*(buffer_pointer--) = 0x06;
				*(buffer_pointer--) = 0x02;
				*(buffer_pointer--) = BIT_STRING_TAG;

				/* 
				 * Encode the enumerated "data priority" field.
				 */
				*(buffer_pointer--) = (UChar)send_data->data_priority;
				*(buffer_pointer--) = 0x01;
				*(buffer_pointer--) = ENUMERATED_TAG;

				/*
				 * Encode the integer "channel ID" field.
				 */
				*(buffer_pointer--) = (UChar)send_data->channel_id;
				if (send_data->channel_id < 128)
				{
					*(buffer_pointer--) = 0x01;
					encoding_length += 10;
				}
				else if (send_data->channel_id < 32768L)
				{
					*(buffer_pointer--) = (UChar)(send_data->channel_id >> 8);
					*(buffer_pointer--) = 0x02;
					encoding_length += 11;
				}
				else
				{
					*(buffer_pointer--) = (UChar)(send_data->channel_id >> 8);
					*(buffer_pointer--) = (UChar)(send_data->channel_id >> 16);
					*(buffer_pointer--) = 0x03;
					encoding_length += 12;
				}
				*(buffer_pointer--) = INTEGER_TAG;

				/*
				 * Encode the integer "initiator" field.
				 */
				*(buffer_pointer--) = (UChar)send_data->initiator;
				*(buffer_pointer--) = (UChar)(send_data->initiator >> 8);
				if (send_data->initiator < 32768L)
				{
					*(buffer_pointer--) = 0x02;
					encoding_length += 4;
				}
				else
				{
					*(buffer_pointer--) = (UChar)(send_data->initiator >> 16);
					*(buffer_pointer--) = 0x03;
					encoding_length += 5;
				}
				*(buffer_pointer--) = INTEGER_TAG;

				*(buffer_pointer--) = INDEFINITE_LENGTH; 
				
				switch (PDUChoice)
				{	
					case SEND_DATA_REQUEST_CHOSEN:
						*buffer_pointer = SEND_DATA_REQUEST;
						break;
					case SEND_DATA_INDICATION_CHOSEN:
						*buffer_pointer = SEND_DATA_INDICATION;
						break;
					case UNIFORM_SEND_DATA_REQUEST_CHOSEN:
						*buffer_pointer = UNIFORM_SEND_DATA_REQUEST;
						break;
					case UNIFORM_SEND_DATA_INDICATION_CHOSEN:
						*buffer_pointer = UNIFORM_SEND_DATA_INDICATION;
						break;
				}

				// Set the returned pointer to the beginning of the encoded packet
				PUChar	temp = *encoding_buffer;
				*encoding_buffer = buffer_pointer;

				/*
				 * Encode the end-of-contents marker for the "Send Data" PDU.
				 * This goes after the data, at the end of the PDU.
				 */
				buffer_pointer = temp + (send_data->user_data.length + 
								(MAXIMUM_PROTOCOL_OVERHEAD_FRONT + 1));
				*(buffer_pointer++) = END_OF_CONTENTS;
				*buffer_pointer = END_OF_CONTENTS;

				// Set the returned length of the encoded packet
				*encoding_buffer_length = 
							encoding_length + send_data->user_data.length + 5;
			}
			/*
			 * If we are currently using Packed Encoding Rules.
			 */
			else
#endif // ENABLE_BER
			{	
				// Move the ptr past the X.224 header.
				buffer_pointer += sizeof(X224_DATA_PACKET);
				
				switch (PDUChoice)
				{
					case SEND_DATA_REQUEST_CHOSEN:
						*buffer_pointer = PER_SEND_DATA_REQUEST;
						break;
					case SEND_DATA_INDICATION_CHOSEN:
						*buffer_pointer = PER_SEND_DATA_INDICATION;
						break;
					case UNIFORM_SEND_DATA_REQUEST_CHOSEN:
						*buffer_pointer = PER_UNIFORM_SEND_DATA_REQUEST;
						break;
					case UNIFORM_SEND_DATA_INDICATION_CHOSEN:
						*buffer_pointer = PER_UNIFORM_SEND_DATA_INDICATION;
						break;
				}
				buffer_pointer++;

				/*
				 * Encode the integer "initiator" field.  The lower bound must
				 * first be subtracted from the value to encode.
				 */
				initiator = send_data->initiator - INITIATOR_LOWER_BOUND;
				*(buffer_pointer++) = (UChar) (initiator >> 8);
				*(buffer_pointer++) = (UChar) initiator;

				/*
				 * Encode the integer "channel ID" field.
				 */
				*(buffer_pointer++) = (UChar)(send_data->channel_id >> 8);
				*(buffer_pointer++) = (UChar)(send_data->channel_id);

				/*
				 * Encode the "priority" and "segmentation" fields.
				 */
				*(buffer_pointer++) = (UChar)((send_data->data_priority << 6) |
										(send_data->segmentation >> 2));
				
				/* 
				 * Encode the "user data" octet string.  The octet strings are
				 * encoded differently depending upon their length.
				 */
				ASSERT (send_data->user_data.length < 16384);

				if (send_data->user_data.length <= 127)
				{
					*encoding_buffer_length = MAXIMUM_PROTOCOL_OVERHEAD - 1;
				}
				else
				{
					*(buffer_pointer++) = (UChar)(send_data->user_data.length >> 8) | 
											INDEFINITE_LENGTH;
					*encoding_buffer_length = MAXIMUM_PROTOCOL_OVERHEAD;
				}
				*buffer_pointer++ = (UChar)send_data->user_data.length;

				initiator = (UShort) (*encoding_buffer_length + send_data->user_data.length);
				
				// Set the returned length of the encoded PDU.
				if (bBufferAllocated || (send_data->segmentation & SEGMENTATION_BEGIN)) {
					/*
					 *	If the Encode operation allocates the space needed, or the space
					 *	was allocated by MCSGetBufferRequest (by a client) and this is
					 *	the 1st segment of the data in the buffer, the whole encoded PDU
					 *	is in contiguous space.  The total PDU size is returned in this
					 *	case.
					 *	However, in the case where the space was allocated by MCSGetBufferRequest,
					 *	the PDUs after the 1st one, will put the X.224 and MCS headers in 
					 *	a separate piece of memory (whose length is returned here), and the
					 *	data is still in the pre-allocated space.
					 */
					*encoding_buffer_length = (UINT) initiator;
				}

				/*
				 *	If the space was not preallocated, we need to copy the data
				 *	into the space allocated by the encoder.
				 */
				if (bBufferAllocated) {
					// We now need to copy the data into the encoded data PDU.
					memcpy (buffer_pointer, send_data->user_data.value,
							send_data->user_data.length);
					// Update the data ptr in the data packet
					send_data->user_data.value = (ASN1octet_t *) buffer_pointer;
				}
			}
		}
	}

	if (send_data_pdu == FALSE)
	{
		SetEncodingRules (rules_type);
		return_value = ASN1_Encode(m_pEncInfo,	// ptr to encoder info
									 pdu_structure,	// pdu data structure
									 pdu_type,		// pdu id
									 ASN1ENCODE_ALLOCATEBUFFER, // flags
									 NULL,			// do not provide buffer
									 0);			// buffer size if provided
		if (ASN1_FAILED(return_value))
		{
			ERROR_OUT(("CMCSCoder::Encode: ASN1_Encode failed, err=%d", return_value));
			ASSERT(FALSE);
			fRet = FALSE;
			goto MyExit;
		}
		ASSERT(return_value == ASN1_SUCCESS);
		/*
		 *	The encoded buffers returned by ASN.1 have preallocated the space
		 *	needed for the X.224 header.
		 */
		// len of encoded data in buffer
		*encoding_buffer_length = m_pEncInfo->len;
		initiator = (UShort) *encoding_buffer_length;
		// buffer to encode into
		*encoding_buffer = m_pEncInfo->buf;
	}

	// Now, add the X.224 header
	buffer_pointer = *encoding_buffer;
	memcpy (buffer_pointer, g_X224Header, PROTOCOL_OVERHEAD_X224);
	AddRFCSize (buffer_pointer, initiator);

MyExit:

	return fRet;
}

/*
 *	void 	Decode ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function decodes ASN.1 compliant byte streams into the
 *		appropriate MCS PDU structures using the ASN.1 toolkit.
 *
 *	NOTE: For data PDUs, do NOT access pdecoding_buffer_length. It's set
 *			to NULL.
 */
BOOL	CMCSCoder::Decode(LPBYTE			encoded_buffer,
							UINT			encoded_buffer_length,
							int				pdu_type,
							UINT			rules_type,
							LPVOID			*pdecoding_buffer,
							UINT			*pdecoding_buffer_length)
{
	BOOL				fRet = TRUE;
	BOOL				send_data_pdu = FALSE;
    ASN1optionparam_s   OptParam;

	/*
	 * Check to make sure the encoding rules type is properly set.
	 */
	ASSERT(rules_type == PACKED_ENCODING_RULES || pdu_type == CONNECT_MCS_PDU);

	if (pdu_type == DOMAIN_MCS_PDU)
	{
			UChar					length;
			unsigned int			short_data;
			PUChar					buffer_pointer;
			PSendDataRequestPDU		send_data;
			PDomainMCSPDU			decoding_pdu;
			ASN1choice_t			choice;
			
		buffer_pointer = encoded_buffer;
		
#ifdef ENABLE_BER
		/*
		 * If we are currently using Basic Encoding Rules.
		 */
		if (Encoding_Rules_Type == BASIC_ENCODING_RULES)
		{
			switch (*(buffer_pointer++))
			{
				case SEND_DATA_REQUEST:
					((PDomainMCSPDU) decoding_buffer)->choice =
							SEND_DATA_REQUEST_CHOSEN;
					send_data_pdu = TRUE;
					break;

				case SEND_DATA_INDICATION:
					((PDomainMCSPDU) decoding_buffer)->choice =
							SEND_DATA_INDICATION_CHOSEN;
					send_data_pdu = TRUE;
					break;

				case UNIFORM_SEND_DATA_REQUEST:
					((PDomainMCSPDU) decoding_buffer)->choice =
							UNIFORM_SEND_DATA_REQUEST_CHOSEN;
					send_data_pdu = TRUE;
					break;

				case UNIFORM_SEND_DATA_INDICATION:
					((PDomainMCSPDU) decoding_buffer)->choice =
							UNIFORM_SEND_DATA_INDICATION_CHOSEN;
					send_data_pdu = TRUE;
					break;
			}

			if (send_data_pdu )
			{
				/*
				 * Get the pointer to the "Send Data" PDU.
				 */
				send_data = &((PDomainMCSPDU) decoding_buffer)->
												u.send_data_request;

				/*
				 * Retrieve one byte for the length and check to see which 
				 * length variant is being used.  If the long variant is being 
				 * used, move the buffer pointer past the length and set the 
				 * flag indicating that the indefinite length is not being used.
				 */
				length = *buffer_pointer;

				switch (length)
				{
					case ONE_BYTE_LENGTH: 
							buffer_pointer += 3;
							break;
					case TWO_BYTE_LENGTH: 
							buffer_pointer += 4;
							break;		
					case THREE_BYTE_LENGTH:
							buffer_pointer += 5;
							break;
					case FOUR_BYTE_LENGTH:
							buffer_pointer += 6;
							break;
					default:
							buffer_pointer += 2;
				}

				/*
				 * Decode the integer "initiator" field.  Increment the data 
				 * pointer past the integer identifier and retrieve the length 
				 * of the integer.
				 */
				length = *(buffer_pointer++);

				ASSERT ((length == 1) || (length == 2));
				if (length == 1)
					send_data->initiator = (UserID) *(buffer_pointer++);
				else if (length == 2)
				{
					send_data->initiator = ((UserID) *(buffer_pointer++)) << 8;
					send_data->initiator |= (UserID) *(buffer_pointer++);
				}
				else 
				{
					TRACE_OUT(("CMCSCoder::Decode: initiator field is longer than 2 bytes (%d bytes) in MCS Data packet.",  (UINT) length));
				}

				/*
				 * Decode the integer "channel ID" field.  Increment the data 
				 * pointer past the integer identifier and retrieve the length 
				 * of the integer.
				 */
				buffer_pointer++;
				length = *(buffer_pointer++);

				ASSERT ((length == 1) || (length == 2));
				if (length == 1)
					send_data->channel_id = (ChannelID) *(buffer_pointer++);
				else if (length == 2)
				{
					send_data->channel_id = ((ChannelID) *buffer_pointer++) << 8;
					send_data->channel_id |= (ChannelID) *(buffer_pointer++);
				}
				else 
				{
					TRACE_OUT(("CMCSCoder::Decode: channel_id field is longer than 2 bytes (%d bytes) in MCS Data packet.", (UINT) length));
				}

				/*
				 * Decode the enumerated "data priority" field.  Increment the
				 * data pointer past the identifier and length.
				 */
				buffer_pointer+=2;
				send_data->data_priority =(PDUPriority)*buffer_pointer;

				/*
				 * Decode the bit string "segmentation" field.  Increment the 
				 * data pointer past the bit string identifier, length, and the 
				 * "unused bits" byte and retrieve the "segmentation" flag.
				 */
				buffer_pointer += 4;
				send_data->segmentation = *buffer_pointer;

				/*
				 * Decode the "user data" octet string.	 Increment the data 
				 * pointer past the identifier.
				 */
				buffer_pointer += 2;

				/*
				 * Check to see which variant of the length is being used and
				 * then retrieve the length.
				 */
				length = *(buffer_pointer++);

				if (length & INDEFINITE_LENGTH)
				{
					if (length == ONE_BYTE_LENGTH)
						send_data->user_data.length = (unsigned int) *(buffer_pointer++);
					/*
					 * A length identifier of 0x82 indicates that two bytes are
					 * being used to hold the actual length so retrieve the two
					 * bytes to form the length.
					 */
					else if (length == TWO_BYTE_LENGTH)
					{
						send_data->user_data.length = 
								((unsigned int) *(buffer_pointer++)) << 8;
						send_data->user_data.length |= 
								(unsigned int) *(buffer_pointer++);
					}
				}
				else
					send_data->user_data.length = (unsigned int) length;

				// buffer_pointer now points to the 1st data byte
				send_data->user_data.value = buffer_pointer;
				*pulDataOffset = buffer_pointer - encoded_buffer;
			}
		}
		/*
		 * If we are currently using Packed Encoding Rules.
		 */
		else
#endif // ENABLE_BER
		{
			switch (*(buffer_pointer++))
			{
				case PER_SEND_DATA_REQUEST:
					choice = SEND_DATA_REQUEST_CHOSEN;
					send_data_pdu = TRUE;
					break;

				case PER_SEND_DATA_INDICATION:
					choice = SEND_DATA_INDICATION_CHOSEN;
					send_data_pdu = TRUE;
					break;

				case PER_UNIFORM_SEND_DATA_REQUEST:
					choice = UNIFORM_SEND_DATA_REQUEST_CHOSEN;
					send_data_pdu = TRUE;
					break;

				case PER_UNIFORM_SEND_DATA_INDICATION:
					choice = UNIFORM_SEND_DATA_INDICATION_CHOSEN;
					send_data_pdu = TRUE;
					break;
			}

			if (send_data_pdu)
			{
				decoding_pdu = (PDomainMCSPDU) pdecoding_buffer; 

				// Store the choice field
				decoding_pdu->choice = choice;
				/*
				 * Get the pointer to the "Send Data" PDU.
				 */
				send_data = &decoding_pdu->u.send_data_request;

				/*
				 * Decode the integer "initiator" field.
				 */
				short_data = ((unsigned int) *(buffer_pointer++)) << 8;
				short_data |= (unsigned int) *(buffer_pointer++);
				send_data->initiator = (UserID) short_data + INITIATOR_LOWER_BOUND;

				/*
				 * Decode the integer "channel ID" field. 
				 */
				send_data->channel_id = ((ChannelID) *(buffer_pointer++)) << 8;
				send_data->channel_id |= (ChannelID) *(buffer_pointer++);

				/*
				 * Decode the enumerated "data priority" field and the
				 * "segmentation" field.
				 */
				send_data->data_priority = 
						(PDUPriority)((*buffer_pointer >> 6) & 0x03);
				send_data->segmentation = (*(buffer_pointer++) << 2) & 0xc0; 

				/*
				 * Decode the "user data" octet string.	 Check to see which 
				 * variant of the length is being used and then retrieve the 
				 * length.
				 */
				length = *(buffer_pointer++);

				if (length & INDEFINITE_LENGTH)
				{
					ASSERT ((length & 0x40) == 0);
					
					/*
					 * If bit 7 is set the length is greater than 127 but
					 * less than 16K.
					 *
					 *	ChristTs: We no longer handle the case where the data length
					 *	was higher than 16K. Our Max PDU size is 4K.
					 */
					short_data = (unsigned int) ((length & 0x3f) << 8);
					send_data->user_data.length = 
								short_data | ((unsigned int) *(buffer_pointer++));
				}
				/*
				 * If bit 7 is not set then the length is less than 128 and is
				 * contained in the retrieved byte.
				 */
				else
				{
					send_data->user_data.length = (UShort) length;
				}

				// buffer_pointer now points to the 1st data byte
				send_data->user_data.value = buffer_pointer;
			}
		}
	}
	
	if (send_data_pdu == FALSE)
	{
		int 	return_value;
		//void	*pDecodedData;

		SetEncodingRules (rules_type);

		return_value = ASN1_Decode(m_pDecInfo,// ptr to decoder info
							pdecoding_buffer,		// destination buffer
							pdu_type,				// pdu type
							ASN1DECODE_SETBUFFER,	// flags
							encoded_buffer,			// source buffer
							encoded_buffer_length);	// source buffer size
		if (ASN1_FAILED(return_value))
		{
			ERROR_OUT(("CMCSCoder::Decode: ASN1_Decode failed, err=%d", return_value));
			ASSERT(FALSE);
			fRet = FALSE;
			goto MyExit;
		}

        OptParam.eOption = ASN1OPT_GET_DECODED_BUFFER_SIZE;
		return_value = ASN1_GetDecoderOption(m_pDecInfo, &OptParam);
		if (ASN1_FAILED(return_value))
		{
			ERROR_OUT(("CMCSCoder::Decode: ASN1_GetDecoderOption failed, err=%d", return_value));
			ASSERT(FALSE);
			fRet = FALSE;
			goto MyExit;
		}
        *pdecoding_buffer_length = OptParam.cbRequiredDecodedBufSize;

		ASSERT((return_value == ASN1_SUCCESS) && (*pdecoding_buffer_length > 0));
	}

MyExit:

	return fRet;
}

/*
 *	PacketCoderError	ReverseDirection ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is used to convert data request PDU's into data indication
 *		PDU's and vice versa.
 */
Void CMCSCoder::ReverseDirection (LPBYTE	encoded_buffer)
{
	encoded_buffer += PROTOCOL_OVERHEAD_X224;
	switch (*encoded_buffer)
	{
		case PER_SEND_DATA_REQUEST:
			*encoded_buffer = PER_SEND_DATA_INDICATION;
			break;

		case PER_SEND_DATA_INDICATION:
			*encoded_buffer = PER_SEND_DATA_REQUEST;
			break;

		case PER_UNIFORM_SEND_DATA_REQUEST:
			*encoded_buffer = PER_UNIFORM_SEND_DATA_INDICATION;
			break;

		case PER_UNIFORM_SEND_DATA_INDICATION:
			*encoded_buffer = PER_UNIFORM_SEND_DATA_REQUEST;
			break;
		default:
			ASSERT (FALSE);
			break;
	}
}

/*
 *	void	SetEncodingRules ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to set the type (basic or packed) of encoding
 *		rules to be used.
 */
void CMCSCoder::SetEncodingRules (UINT	rules_type)
{
	/*
	 * If the rules type is changing, set our rules instance variable and reset
	 * the variables which hold the amount of overhead associated with the
	 * "SendData" PDU's.
	 */
	Encoding_Rules_Type = rules_type;
}

/*
 *	BOOL	IsMCSDataPacket ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function determines whether the encoded packet is an MCS Data packet
 *		or not.
 *
 *	Return value:
 *		TRUE, if the packet is an MCS Data packet. FALSE, otherwise.
 */
BOOL CMCSCoder::IsMCSDataPacket(LPBYTE encoded_buffer, UINT rules_type)
{
	UChar		identifier;

	/*
	 * Retrieve the identifier from the encoded data.
	 */
	identifier = *encoded_buffer;

	if (rules_type == BASIC_ENCODING_RULES)
	{
		if (	(identifier == SEND_DATA_REQUEST) || 
				(identifier == SEND_DATA_INDICATION) || 
				(identifier == UNIFORM_SEND_DATA_REQUEST) || 
				(identifier == UNIFORM_SEND_DATA_INDICATION))
		{
			return TRUE;
		}
	}
	else
	{
		if (	(identifier == PER_SEND_DATA_REQUEST) || 
				(identifier == PER_SEND_DATA_INDICATION) || 
				(identifier == PER_UNIFORM_SEND_DATA_REQUEST) || 
				(identifier == PER_UNIFORM_SEND_DATA_INDICATION))
		{
			return TRUE;
		}
	}

	return FALSE;
}


void CMCSCoder::FreeEncoded(LPBYTE encoded_buffer)
{
    ASN1_FreeEncoded(m_pEncInfo, encoded_buffer);
}

void CMCSCoder::FreeDecoded (int pdu_type, LPVOID decoded_buffer)
{
    ASN1_FreeDecoded(m_pDecInfo, decoded_buffer, pdu_type);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\packet.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC | ZONE_T120_GCCNC);
/*
 * packet.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 * Abstract:
 *		This is the implementation file for the MCS packet class.  The packet
 *		class is responsible for encoding and decoding the PDUs, as well as
 *		maintaining the necessary pointers to the encoded and decoded data.
 *		Instances of this class will be created both by User and Connection
 *		objects as PDUs flow through MCS.
 *
 * Private Instance Variables:
 *		Packet_Coder
 *			A pointer to the packet coder object.  
 *		Encoded_Lock_Count
 *			A counter indicating the number of locks currently existing on the
 *			encoded data.
 *		Decoded_Lock_Count
 *			A counter indicating the number of locks currently existing on the
 *			decoded data.
 *		Free_State
 *			A boolean value indicating whether the object can be freed when all
 *			lock counts fall to zero.
 *		m_EncodedPDU
 *			This is a pointer to the encoded PDU contained in the internal
 *			buffer.  Note that the reason for keeping this separate is that
 *			the encoded PDU may not start at the beginning of the encoded data
 *			memory block identified above.  Some encoders actually encode the
 *			PDUs backward, or back justified.
 *		Encoded_Data_Length
 *			Indicates the length of the encoded data.  If zero, the packet coder
 *			must be consulted to obtain the length which is subsequently saved.
 *		Decoded_Data_Length     
 *			Indicates the length of the decoded data.  If zero, the packet coder
 *			must be consulted to obtain the length which is subsequently saved.
 *		PDU_Type
 *			Indicates the type of PDU contained in the packet.  Valid values
 *			are DOMAIN_MCS_PDU or CONNECT_MCS_PDU.
 *		Packet_Direction_Up
 *			A boolean indicating whether the direction of travel for the PDU
 *			is upward.
 *
 * Private Member Functions:
 *		PacketSuicideCheck
 *			This function is called by Unlock() as well as any Unlock call
 *			(ie. UnlockUncoded()) when it's associated lock	count falls to
 *			zero.
 *
 * Caveats:
 *		None.
 *
 * Author:
 *		James J. Johnstone IV
 */ 

/*
 *	Packet ()
 *
 *	Public
 *
 *	Functional Description:
 *		This version of the constructor is used to create a Packet object
 *		for outgoing PDUs when the packet is to be created from a structure
 *		containing the PDU data to be encoded.
 */
// outgoing packets
Packet::Packet(PPacketCoder	pPacketCoder,
				UINT			nEncodingRules,
				LPVOID			pInputPduStructure,
				int				nPduType,
				BOOL			fPacketDirectionUp,
				PPacketError	pePktErr,
				BOOL			fLockEncodedData)
:
	SimplePacket(fPacketDirectionUp),
	Packet_Coder(pPacketCoder),
	PDU_Type(nPduType),
	m_Decoded_Data (NULL),
	Decoded_Data_Length (0)
{
	/*
	 *	Encode the PDU using the externally provided decoded data. The encoded
	 *	buffer will be allocated by the encoder. The buffer needs to be freed later.
	 */
	if (Packet_Coder->Encode (pInputPduStructure, PDU_Type, nEncodingRules, 
							&m_EncodedPDU, &Encoded_Data_Length))
	{
		ASSERT (m_EncodedPDU);
		/*
		 *	Encoding was successful.
		 */
		*pePktErr = PACKET_NO_ERROR;

		// should we lock encoded data?
		if (fLockEncodedData)
			lLock = 2;
	}
	else
	{
		/*
		 *	Encoding failed.
		 */
		m_EncodedPDU = NULL;
		ERROR_OUT(("Packet::Packet: encoding failed"));
		*pePktErr = PACKET_MALLOC_FAILURE;
	}
}  

/*
 *	Packet ()
 *
 *	Public
 *
 *	Functional Description:
 *		This version of the constructor is used to create a Packet object
 *		for incomming PDUs when the packet is to be created from an encoded
 *		data stream containing the PDU data to be decoded.
 */
// incoming packets
Packet::Packet(PPacketCoder		pPacketCoder,
				UINT			nEncodingRules,
				LPBYTE			pEncodedData,
				UINT			cbEncodedDataSize,
				int				nPduType,
				BOOL			fPacketDirectionUp,
				PPacketError	pePktErr)
:
	SimplePacket(fPacketDirectionUp),
	Packet_Coder(pPacketCoder),
	PDU_Type(nPduType)
{
		//PacketCoderError		coder_error;

	m_EncodedPDU = NULL;
	
	/*
	 *	Decode the provided encoded buffer.  Note that the decoder will
	 *	allocate the space needed.  The buffer needs to be freed later.
	 */
	if (Packet_Coder->Decode (pEncodedData, cbEncodedDataSize, PDU_Type,
								nEncodingRules, &m_Decoded_Data, 
								&Decoded_Data_Length) == FALSE)
	{
		ERROR_OUT(("Packet::Packet: Decode call failed."));
		m_Decoded_Data = NULL;
		*pePktErr = PACKET_INCOMPATIBLE_PROTOCOL;
	}
	else
	{ 
		ASSERT (m_Decoded_Data != NULL);
		/*
		 * The decode was successful.
		 */
		*pePktErr = PACKET_NO_ERROR;
	}
}                                             

/*
 *	~Packet ()
 *
 *	Public
 *
 *	Functional Description:
 *		Destructor for the Packet class.  The destructor ensures that all 
 *		resources that have been allocated are freed.
 */
Packet::~Packet(void)
{
	/*
	 *	If there is memory allocated for encoded data, then free it.
	 */
	if (m_EncodedPDU != NULL) {
		// the encoded memory was allocated by the ASN.1 coder.
		Packet_Coder->FreeEncoded (m_EncodedPDU);
	}

	/*
	 *	If there is memory allocated for decoded data, then free it.
	 */
	if (m_Decoded_Data != NULL) {
		// the decoded memory was allocated by the ASN.1 decoder
		Packet_Coder->FreeDecoded (PDU_Type, m_Decoded_Data);
	}
		
}

/*
 *	IsDataPacket ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function returns whether this is a data packet (it's not).
 */
BOOL Packet::IsDataPacket(void)
{
	return (FALSE);
}                        

/*
 *	GetDecodedData ()
 *
 *	Public
 *
 *	Functional Description:
 *		The GetDecodedData method returns a pointer to the decoded data
 *		buffer.  If the packet does not have decoded data the Decode method is
 *		called.  If decode is unable to provide decoded data then NULL is
 *		returned.
 */
PVoid	Packet::GetDecodedData ()
{		
	ASSERT (m_Decoded_Data != NULL);
	return (m_Decoded_Data);
}                          

/*
 *	GetPDUType ()
 *
 *	Public
 *
 *	Functional Description:
 *		The GetPDUType method returns the PDU type for the packet.
 */
int	Packet::GetPDUType ()
{		
	return (PDU_Type);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\memmgr.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MEMORY);
/*
 *	memmgr.cpp
 *
 *	Copyright (c) 1998 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the implementation file for the T.120 memory allocation mechanism.  This
 *		file contains the code necessary to allocate and distribute memory
 *		in the form of Memory objects.
 *
 *	This implementation defines priorities of memory allocations.  A lower
 *	priority number implies higher priority.  Priority-0 allocations will be
 *	satisfied, unless the system is out of memory.  Priorities 1 and 2
 *	limit the amount of total memory that can be allocated, but priority 1 (recv priority)
 *	has higher water mark limits than priority 2 (send priority).
 *
 *	Protected Member Functions:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		Christos Tsollis
 */
static int						s_anCurrentSize[MEMORY_PRIORITIES] = { 0, 0, 0 };
static const int				sc_iLimit[MEMORY_PRIORITIES] = {
										0x7FFFFFFF,
										0x100000,
										0xE0000
								};

#ifdef DEBUG
static int						s_TotalSize = 0;
#endif // DEBUG

/*
 *	PMemory		AllocateMemory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to allocate a buffer together with a
 *		Memory (buffer header) object
 */
PMemory	AllocateMemory (
					PUChar				reference_ptr,
					UINT				length,
					MemoryPriority		priority)
{

	PUChar				copy_ptr;
	PMemory				memory;
						
	ASSERT (length > 0);

	if (s_anCurrentSize[priority] < sc_iLimit[priority]) {
		/*
		 *	We attempt to allocate enough space for the buffer and the
		 *	Memory object.
		 */
#ifdef DEBUG
		memory = (PMemory) new BYTE[length + sizeof (Memory)];
#else // DEBUG
		memory = (PMemory) LocalAlloc (LMEM_FIXED, length + sizeof (Memory));
#endif // DEBUG
	}
	else {
		/*
		 *	The application has attempted to allocate past its limit
		 *	It is necessary to fail the request.
		 */
		memory = NULL;
		WARNING_OUT (("AllocateMemory: attempt to allocate past the allowable limit. "
					  "Request: %d. Currently allocated: %d. Priority: %d",
					  length, s_anCurrentSize[priority], priority));
	}

	/*
	 *	Check to see whether the allocation was successful.
	 */
	if (memory != NULL) {
#ifdef DEBUG
		s_TotalSize += (int) length;
#endif // DEBUG
		/*
		 * Update the currently allocated size. Notice that we only
		 * do this for buffers used in the send/recv code path in
		 * MCS.  Since this is only one thread, we do not have to
		 * use a critical section to protect the size variable.
		 */
		ASSERT (s_anCurrentSize[priority] >= 0);
		s_anCurrentSize[priority] += (int) length;

		copy_ptr = (PUChar) memory + sizeof(Memory);
		memory->Init (reference_ptr, length, priority, copy_ptr);

		TRACE_OUT (("Allocate: successful request. "
						"Request: %d. Currently allocated: %d. Total: %d. Priority: %d",
					  	length, s_anCurrentSize[priority], s_TotalSize, priority));
		TRACE_OUT (("AllocateMemory: buffer at address %p; memory segment at address %p",
					copy_ptr, memory));
	}
	else {
		/*
		 *	We failed to allocate the requested size
		 *	It is necessary to fail the request.
		 */
		WARNING_OUT (("AllocateMemory: failed to allocated buffer.  We are out of system memory. "
					 "Request: %d. Last error: %d",
					 length, GetLastError()));
	}
	return (memory);
}

/*
 *	PUChar		ReAllocate ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to re-allocate a buffer with a Memory
 *		(buffer header) object. The buffer must have been allocated by
 *		a call to AllocateMemory.  This call assumes RECV_PRIORITY.  However,
 *		it's not restricted in allocations, because, if it did, this might
 *		cause deadlocks (some memory has already been allocated for the
 *		new arriving data).
 */
BOOL ReAllocateMemory (PMemory		*pmemory,
						UINT		length)
{

	PUChar				copy_ptr = NULL;
	UINT				new_length;
	MemoryPriority		priority;
						
	ASSERT (length > 0);
	ASSERT (pmemory != NULL);
	ASSERT (*pmemory != NULL);
	ASSERT ((*pmemory)->GetPointer());

	new_length = length + (*pmemory)->GetLength();
	priority = (*pmemory)->GetMemoryPriority();

	ASSERT (priority == RECV_PRIORITY);
	
	// We attempt to allocate enough space for the buffer.
#ifdef DEBUG
	copy_ptr = (PUChar) new BYTE[new_length + sizeof(Memory)];
	if (copy_ptr != NULL) {
		memcpy (copy_ptr, *pmemory, (*pmemory)->GetLength() + sizeof(Memory));
		delete [] (BYTE *) *pmemory;
	}
#else // DEBUG
	copy_ptr = (PUChar) LocalReAlloc ((HLOCAL) *pmemory,
										new_length + sizeof(Memory),
										LMEM_MOVEABLE);
#endif // DEBUG

	/*
	 *	Check to see whether the allocation was successful.
	 */
	if (copy_ptr != NULL) {

#ifdef DEBUG
		s_TotalSize += (int) length;
#endif // DEBUG
		/*
		 * Update the currently allocated size.
		 */
		ASSERT (s_anCurrentSize[priority] >= 0);
		s_anCurrentSize[priority] += (int) length;
		*pmemory = (PMemory) copy_ptr;
		copy_ptr += sizeof (Memory);
		(*pmemory)->Init (NULL, new_length, priority, copy_ptr);

		TRACE_OUT (("ReAllocate: successful request. "
					"Request: %d. Currently allocated: %d. Total: %d",
				  	length, s_anCurrentSize[priority], s_TotalSize));
		TRACE_OUT (("ReAllocate: buffer at address %p; memory segment at address %p",
					copy_ptr, *pmemory));
	}
	else {
		/*
		 *	We failed to allocate the requested size
		 *	It is necessary to fail the request.
		 */
		WARNING_OUT (("ReAllocate: failed to allocated buffer.  We are out of system memory. "
					 "Request: %d. Currently allocated: %d. Last error: %d",
					 length, s_anCurrentSize[priority], GetLastError()));
	}

	return (copy_ptr != NULL);
}

/*
 *	Void	FreeMemory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to release a previously allocated Memory object.
 */
void FreeMemory (PMemory	memory)
{
	if (memory != NULL) {

		ASSERT (SIGNATURE_MATCH(memory, MemorySignature));
		ASSERT (memory->GetPointer() == (PUChar) memory + sizeof(Memory));
		
		if (memory->Unlock() == 0) {

    	    MemoryPriority		priority = memory->GetMemoryPriority();

			TRACE_OUT (("FreeMemory: buffer at address %p (memory segment at address %p) freed. Size: %d. ",
						memory->GetPointer(), memory, memory->GetLength()));

			// We may need to adjust the variable tracking the allocated amount of mem.
			ASSERT (s_anCurrentSize[priority] >= (int) memory->GetLength());
			s_anCurrentSize[priority] -= memory->GetLength();
			ASSERT(s_anCurrentSize[priority] >= 0);
#ifdef DEBUG
			s_TotalSize -= memory->GetLength();
#endif // DEBUG
			TRACE_OUT(("FreeMemory: Currently allocated: %d. Total: %d.",
						s_anCurrentSize[priority], s_TotalSize));
			
			// free the buffer, and the memory
#ifdef DEBUG
			delete [] (BYTE *) memory;
#else // DEBUG
			LocalFree ((HLOCAL) memory);
#endif // DEBUG
		}
	}
}

#ifdef DEBUG
/*
 *	PUChar		Allocate ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to allocate a buffer without a Memory
 *		(buffer header) object.
 */
PUChar	Allocate (UINT	length)
{

	PUChar		copy_ptr;
						
	ASSERT (length > 0);

	// We attempt to allocate enough space for the buffer.
	copy_ptr = (PUChar) new BYTE[length];

	/*
	 *	Check to see whether the allocation was successful.
	 */
	if (copy_ptr == NULL) {
		/*
		 *	We failed to allocate the requested size
		 *	It is necessary to fail the request.
		 */
		ERROR_OUT (("Allocate: failed to allocated buffer.  We are out of system memory. "
					 "Request: %d. Last error: %d",
					 length, GetLastError()));
	}
		
	return (copy_ptr);
}
#endif // DEBUG

/*
 *	UINT	GetFreeMemory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function returns the amount of space that can still be
 *		allocated at the given priority level.  The function should be
 *		called only when send/recv space is allocated.
 */

UINT GetFreeMemory (MemoryPriority		priority)
{
		int		idiff;
	
	ASSERT (priority != HIGHEST_PRIORITY);

	idiff = sc_iLimit[priority] - s_anCurrentSize[priority];
	return ((idiff > 0) ? (UINT) idiff : 0);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\password.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/* 
 *	password.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CPassword.  This class
 *		manages the data associated with a Password.  Passwords are used to 
 *		restrict access to conferences.  A password can be one of two basic
 *		types.  The simple type consists of either a simple numeric password or
 *		a simple textual password, or both.  The "PDU" type "Password" is a
 *		structure which must contain the numeric form of the password and may
 *		optionally contain the textual part as well.  The "PDU" type
 *		"PasswordSelector" is a union of the numeric and textual forms of a
 *		password and is therefore always one or the other but not both.  When
 *		the password is not the simple type it assumes the form of a
 *		"PasswordChallengeRequestResponse".  This complex structure allows a
 *		challenge-response scheme to be used to control access to conferences.
 *
 *	Protected Instance Variables:
 *		m_fSimplePassword
 *			Flag indicating this password does not contain "challenge" data.
 *		m_fClearPassword
 *			Flag used when the password assumes the "challenge" form indicating
 *			that this password is "in the clear" meaning no true challenge
 *			data is present.
 *		m_pszNumeric
 *			String holding the numeric portion of the simple password.
 *		Text_String_Ptr
 *			String holding the textual portion of the simple password.
 *		m_pInternalRequest
 *			Structure holding the data associated with a password challenge
 *			request.
 *		m_pInternalResponse
 *			Structure holding the data associated with a password challenge
 *			response.
 *		m_pChallengeResponse
 *			Structure holding the "API" form of a challenge password.
 *		m_pPassword
 *			Structure holding the "API" form of a simple password.
 *		m_pUserDataMemory
 *			Memory container holding the user data associated with a
 *			challenge password.
 *		m_pChallengeItemListMemory
 *			Memory container holding the list of pointers to challenge items
 *			associated with a password challenge request.
 *		m_pObjectKeyMemory
 *			Memory container holding the object key data associated with the
 *			non-standard challenge response algorithm.
 *		m_ChallengeItemMemoryList 
 *			Memory container holding the data for the challenge items
 *			associated with a password challenge request.
 *		m_ChallengeResponsePDU
 *			Storage for the "PDU" form of the challenge password.
 *		m_fValidChallengeResponsePDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" password.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */

#include "password.h"
#include "userdata.h"

/*
 *	CPassword()
 *
 *	Public Function Description:
 *		This constructor for the CPassword class is used when creating a 
 *		CPassword object with an "API" GCCPassword structure.  It saves the
 *		password data in the internal structures.
 */
CPassword::CPassword(PGCCPassword			password,
					PGCCError				return_value)
:
    CRefCount(MAKE_STAMP_ID('P','a','s','w')),
    m_fValidChallengeResponsePDU(FALSE),
    m_pInternalRequest(NULL),
    m_pInternalResponse(NULL),
    m_pChallengeResponse(NULL),
    m_pPassword(NULL),
    m_pChallengeItemListMemory(NULL),
    m_pUserDataMemory(NULL),
    m_pObjectKeyMemory(NULL),
    m_pszNumeric(NULL),
    m_pwszText(NULL)
{
	*return_value = GCC_NO_ERROR;

	/*
	 * Set the flag indicating that this is a "simple" password, without the 
	 * challenge request-response information.  The "clear" flag is also 
	 * initialized here but should only be needed when the password is not
	 * "simple".
	 */
	m_fSimplePassword = TRUE;
	m_fClearPassword = TRUE;

	/*
	 * Save the numeric part of the password in the internal numeric string.
	 */
	if (password->numeric_string != NULL)
	{
		if (NULL == (m_pszNumeric = ::My_strdupA(password->numeric_string)))
		{
			ERROR_OUT(("CPassword::CPassword: can't create numeric string"));
			*return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		ERROR_OUT(("CPassword::CPassword: No valid numeric password"));
		*return_value = GCC_INVALID_PASSWORD;
	}

	/*
	 * Check to see if the textual part of the password is present.  If so,
	 * save it in the internal UnicodeString.  If not, set the text pointer
	 * to NULL.
	 */
	if ((password->text_string != NULL) && (*return_value == GCC_NO_ERROR))
	{
		if (NULL == (m_pwszText = ::My_strdupW(password->text_string)))
		{
			ERROR_OUT(("CPassword::CPassword: Error creating text string"));
			*return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
		m_pwszText = NULL;
}

/*
 *	CPassword()
 *
 *	Public Function Description:
 *		This constructor is used when a CPassword object is being created
 *		with a "ChallengeRequestResponse" "API" structure.  The password data 
 *		is saved in the internal structures.
 */
CPassword::CPassword(PGCCChallengeRequestResponse		challenge_response_data,
					PGCCError							return_value)
:
    CRefCount(MAKE_STAMP_ID('P','a','s','w')),
    m_fValidChallengeResponsePDU(FALSE),
    m_pInternalRequest(NULL),
    m_pInternalResponse(NULL),
    m_pChallengeResponse(NULL),
    m_pPassword(NULL),
    m_pChallengeItemListMemory(NULL),
    m_pUserDataMemory(NULL),
    m_pObjectKeyMemory(NULL),
    m_pszNumeric(NULL),
    m_pwszText(NULL)
{
	*return_value = GCC_NO_ERROR;

	/*
	 * Set the flag indicating that this is not a "simple" password, meaning 
	 * that it contains challenge request-response information.  If the password
	 * is "clear" there is no need to create the internal "Challenge" structure
	 * used to hold the challenge request-response information.
	 */
	m_fSimplePassword = FALSE;
	
	/*
	 * Check to see if a "clear" challenge password exists or if this is a 
	 * true challenge request-response password.
	 */
	if (challenge_response_data->password_challenge_type == 
													GCC_PASSWORD_IN_THE_CLEAR)
	{
		/*
		 * A "clear" password is being sent so set the flag indicating so.  
		 * Also set the password type and save the numeric part of the password,
		 * if it exists.  Note that since the "clear" password contained in the
		 * challenge is a PasswordSelector type, either the numeric or the text
		 * form of the password should exist, but not both.
		 */
		m_fClearPassword = TRUE;

		if (challenge_response_data->u.password_in_the_clear.
				numeric_string != NULL)
		{
			if (NULL == (m_pszNumeric = ::My_strdupA(
							challenge_response_data->u.password_in_the_clear.numeric_string)))
			{
				ERROR_OUT(("CPassword::CPassword: can't create numeric string"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			m_pszNumeric = NULL;
		}

		/*
		 * Check to see if the textual part of the password is present.  If it
		 * is, save it in the internal UnicodeString.
		 */
		if ((challenge_response_data->u.password_in_the_clear.
				text_string != NULL) && (*return_value == GCC_NO_ERROR))
		{
			if (NULL == (m_pwszText = ::My_strdupW(
							challenge_response_data->u.password_in_the_clear.text_string)))
			{
				ERROR_OUT(("CPassword::CPassword: Error creating text string"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			m_pwszText = NULL;
		}

		/*
		 * Check to make sure at least one form (text or numeric) of the 
		 * "clear" password was saved.  Report an error if neither was created.
		 */
		if ((*return_value == GCC_NO_ERROR) && (m_pszNumeric == NULL) 
				&& (m_pwszText == NULL))
		{
			ERROR_OUT(("CPassword::CPassword: Error creating password"));
			*return_value = GCC_INVALID_PASSWORD;
		}
	}
	else
	{
		/*
		 * This is a true challenge request-response password.  Set the flag
		 * indicating that the password is not "clear" and create the 
		 * "challenge" data structures to hold the password data internally.
		 */
		m_fClearPassword = FALSE;

		/*
		 * Check to see if a challenge request is present.
		 */
		if (challenge_response_data->u.challenge_request_response.
				challenge_request != NULL)
		{
			/*
			 * Create a RequestInfo stucture to hold the request data
			 * and copy the challenge request structure internally.
			 */
			DBG_SAVE_FILE_LINE
			m_pInternalRequest = new RequestInfo;
			if (m_pInternalRequest != NULL)
			{
				*return_value = ConvertAPIChallengeRequest (
						challenge_response_data->u.
						challenge_request_response.challenge_request);
			}
			else
			{
				ERROR_OUT(("CPassword::CPassword: Error creating new RequestInfo"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}

		/*
		 * Check to see if a challenge response is present.
		 */
		if ((challenge_response_data->u.challenge_request_response.
				challenge_response != NULL) && 
				(*return_value == GCC_NO_ERROR))
		{
			/*
			 * Create a ResponseInfo stucture to hold the response data
			 * and copy the challenge response structure internally.
			 */
			DBG_SAVE_FILE_LINE
			m_pInternalResponse = new ResponseInfo;
			if (m_pInternalResponse != NULL)
			{
				*return_value = ConvertAPIChallengeResponse (
						challenge_response_data->u.
						challenge_request_response.challenge_response);
			}
			else
			{
				ERROR_OUT(("CPassword::CPassword: Error creating new ResponseInfo"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}
	} 
}

/*
 *	CPassword()
 *
 *	Public Function Description
 *		This constructor for the CPassword class is used when creating a 
 *		CPassword object with a "PDU" Password structure.  It saves the
 *		password data in the internal structures.
 */
CPassword::CPassword(PPassword				password_pdu,
					PGCCError				return_value)
:
    CRefCount(MAKE_STAMP_ID('P','a','s','w')),
    m_fValidChallengeResponsePDU(FALSE),
    m_pInternalRequest(NULL),
    m_pInternalResponse(NULL),
    m_pChallengeResponse(NULL),
    m_pPassword(NULL),
    m_pChallengeItemListMemory(NULL),
    m_pUserDataMemory(NULL),
    m_pObjectKeyMemory(NULL),
    m_pszNumeric(NULL),
    m_pwszText(NULL)
{
	*return_value = GCC_NO_ERROR;

	/*
	 * Set the flag indicating that this is a "simple" password, without the 
	 * challenge request-response information.  The "clear" flag is also 
	 * initialized here but should only be needed when the password is not
	 * "simple".
	 */
	m_fSimplePassword = TRUE;
	m_fClearPassword = TRUE;
	
	/*
	 * Save the numeric part of the password. The numeric portion of the
	 * password is required to be present so report an error if it is not.
	 */
	if (password_pdu->numeric != NULL)
	{
		if (NULL == (m_pszNumeric = ::My_strdupA(password_pdu->numeric)))
		{
			ERROR_OUT(("CPassword::CPassword: can't create numeric string"));
			*return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		ERROR_OUT(("CPassword::CPassword: Error no valid numeric password in PDU"));
		*return_value = GCC_INVALID_PASSWORD;
		m_pszNumeric = NULL;
	}

	/*
	 * Check to see if the textual part of the password is present.
	 */
	if ((password_pdu->bit_mask & PASSWORD_TEXT_PRESENT) &&
			(*return_value == GCC_NO_ERROR))
	{
		if (NULL == (m_pwszText = ::My_strdupW2(
							password_pdu->password_text.length,
							password_pdu->password_text.value)))
		{
			ERROR_OUT(("CPassword::CPassword: Error creating password text"));
			*return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
		m_pwszText = NULL;
}

/*
 *	CPassword()
 *
 *	Public Function Description:
 *		This constructor for the CPassword class is used when creating a 
 *		CPassword object with a "PDU" PasswordSelector structure.  It saves
 *		the password data in it's internal structures but does not require
 *		saving any "challenge request-response" data.
 */
CPassword::CPassword(PPasswordSelector			password_selector_pdu,
					PGCCError					return_value)
:
    CRefCount(MAKE_STAMP_ID('P','a','s','w')),
    m_fValidChallengeResponsePDU(FALSE),
    m_pInternalRequest(NULL),
    m_pInternalResponse(NULL),
    m_pChallengeResponse(NULL),
    m_pPassword(NULL),
    m_pChallengeItemListMemory(NULL),
    m_pUserDataMemory(NULL),
    m_pObjectKeyMemory(NULL),
    m_pszNumeric(NULL),
    m_pwszText(NULL)
{
	*return_value = GCC_NO_ERROR;

	/*
	 * Set the flag indicating that this is a "simple" password, without the 
	 * challenge request-response information.
	 */
	m_fSimplePassword = TRUE;
	m_fClearPassword = TRUE;
	
	/*
	 * The password selector contains either the numeric password or the 
	 * textual password but not both.  Check to see if the textual password 
	 * is chosen.
	 */
	if (password_selector_pdu->choice == PASSWORD_SELECTOR_TEXT_CHOSEN)
	{
		if (NULL == (m_pwszText = ::My_strdupW2(
							password_selector_pdu->u.password_selector_text.length,
							password_selector_pdu->u.password_selector_text.value)))
		{
			ERROR_OUT(("CPassword::CPassword: Error creating password selector text"));
			*return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
		m_pwszText = NULL;

	/*
	 * Check to see if the numeric password is chosen.
	 */
	if (password_selector_pdu->choice == PASSWORD_SELECTOR_NUMERIC_CHOSEN)
	{
		if (NULL == (m_pszNumeric = ::My_strdupA(
							password_selector_pdu->u.password_selector_numeric)))
		{
			ERROR_OUT(("CPassword::CPassword: can't create numeric string"));
			*return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
		m_pszNumeric = NULL;

	/*
	 * Check to make sure at least one form (text or numeric) of the 
	 * password was saved.  Report an error if neither was created.
	 */
	if ((*return_value == GCC_NO_ERROR) && (m_pszNumeric == NULL) 
			&& (m_pwszText == NULL))
	{
		ERROR_OUT(("CPassword::CPassword: Error creating password selector"));
		*return_value = GCC_INVALID_PASSWORD;
	}
}

/*
 *	CPassword()
 *
 *	Public Function Description:
 *		This constructor for the CPassword class is used when creating a
 *		CPassword object with a "PDU" Challenge Request-Response structure.
 *		The password data is saved in the internal structures.
 */
CPassword::CPassword(PPasswordChallengeRequestResponse	pdu_challenge_data,
					PGCCError							return_value)
:
    CRefCount(MAKE_STAMP_ID('P','a','s','w')),
    m_fValidChallengeResponsePDU(FALSE),
    m_pInternalRequest(NULL),
    m_pInternalResponse(NULL),
    m_pChallengeResponse(NULL),
    m_pPassword(NULL),
    m_pChallengeItemListMemory(NULL),
    m_pUserDataMemory(NULL),
    m_pObjectKeyMemory(NULL),
    m_pszNumeric(NULL),
    m_pwszText(NULL)
{
	*return_value = GCC_NO_ERROR;

	/*
	 * Set the flag indicating that this is not "simple" password, meaning that 
	 * it contains challenge request-response information.  If the password is
	 * "clear" there is no need to create the internal "Challenge" structure
	 * used to hold the challenge request-response information.
	 */
	m_fSimplePassword = FALSE;
	
	/*
	 * Check to see if a "clear" challenge password exists or if this is a 
	 * true challenge request-response password.
	 */
	if (pdu_challenge_data->choice == CHALLENGE_CLEAR_PASSWORD_CHOSEN)
	{
		/*
		 * A "clear" password is being sent so set the flag indicating so.  
		 * Also set the password type and save the numeric part of the password,
		 * if it is present.
		 */
		m_fClearPassword = TRUE;

		if (pdu_challenge_data->u.challenge_clear_password.choice ==
											PASSWORD_SELECTOR_NUMERIC_CHOSEN)
		{
			if (NULL == (m_pszNumeric = ::My_strdupA(
							pdu_challenge_data->u.challenge_clear_password.u.password_selector_numeric)))
			{
				ERROR_OUT(("CPassword::CPassword: can't create numeric string"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			m_pszNumeric = NULL;
		}

		/*
		 * Check to see if the textual part of the password is present.  If it
		 * is, save it in the internal structure.
		 */
		if (pdu_challenge_data->u.challenge_clear_password.choice ==
											PASSWORD_SELECTOR_TEXT_CHOSEN)
		{
			if (NULL == (m_pwszText = ::My_strdupW2(
								pdu_challenge_data->u.challenge_clear_password.
										u.password_selector_text.length,
								pdu_challenge_data->u.challenge_clear_password.
										u.password_selector_text.value)))
			{
				ERROR_OUT(("CPassword::CPassword: Error creating password selector text"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			m_pwszText = NULL;
		}

		/*
		 * Check to make sure at least one form (text or numeric) of the 
		 * "clear" password was saved.  Report an error if neither was created.
		 */
		if ((*return_value == GCC_NO_ERROR) && (m_pszNumeric == NULL) 
				&& (m_pwszText == NULL))
		{
			ERROR_OUT(("CPassword::CPassword: Error creating password"));
			*return_value = GCC_INVALID_PASSWORD;
		}
	}
	else
	{
		/*
		 * This is a true challenge request-response password.  Set the flag
		 * indicating that the password is not "clear" and create a 
		 * "challenge data" structure to hold the password data internally.
		 */
		m_fClearPassword = FALSE;

		/*
		 * Check to see if a challenge request is present.
		 */
		if (pdu_challenge_data->u.challenge_request_response.
				bit_mask & CHALLENGE_REQUEST_PRESENT)
		{
			/*
			 * Create a RequestInfo stucture to hold the request data
			 * and copy the challenge request structure internally.
			 */
			DBG_SAVE_FILE_LINE
			m_pInternalRequest = new RequestInfo;
			if (m_pInternalRequest != NULL)
			{
				*return_value = ConvertPDUChallengeRequest (
						&pdu_challenge_data->u.challenge_request_response.
						challenge_request);
			}
			else
			{
				ERROR_OUT(("CPassword::CPassword: Error creating new RequestInfo"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}

		/*
		 * Check to see if a challenge response is present.
		 */
		if ((pdu_challenge_data->u.challenge_request_response.
				bit_mask & CHALLENGE_RESPONSE_PRESENT) &&
				(*return_value == GCC_NO_ERROR))
		{
			/*
			 * Create a ResponseInfo stucture to hold the response data
			 * and copy the challenge response structure internally.
			 */
			DBG_SAVE_FILE_LINE
			m_pInternalResponse = new ResponseInfo;
			if (m_pInternalResponse != NULL)
			{
				*return_value = ConvertPDUChallengeResponse (
						&pdu_challenge_data->u.challenge_request_response.
						challenge_response);
			}
			else
			{
				ERROR_OUT(("CPassword::CPassword: Error creating new ResponseInfo"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		} 
	}
}

/*
 *	~CPassword()
 *
 *	Public Function Description:
 *		This is the destructor for the CPassword class.  It will free up
 *		any memory allocated during the life of this object.
 */
CPassword::~CPassword(void)
{
	PChallengeItemInfo			challenge_item_info_ptr;

	delete m_pszNumeric;
	delete m_pwszText;

	/*
	 * If "PDU" data has been allocated for this object, free it now.
	 */
	if (m_fValidChallengeResponsePDU)
	{
		FreePasswordChallengeResponsePDU();
	}

	/*
	 * Delete the memory associated with the "API" "simple" password 
	 * data structure.
	 */
	delete m_pPassword;

	/*
	 * Free any data allocated for the "API" challenge password.  This would be
	 * left around if "UnLock" was not called.  Note that if the "challenge" 
	 * password is "clear", the numeric and text pointers above would contain
	 *  the "API" data so now we just need to delete the "challenge" password 
	 * structure.
	 */
	if (m_pChallengeResponse != NULL)
	{
		if (m_fClearPassword == FALSE)
		{
			FreeAPIPasswordData();
		}
		else
		{
			delete m_pChallengeResponse;
		}
	}

	/*
	 * Free any internal memory allocated for the challenge request information.
	 * Iterate through the list of challenge items associated with the 
	 * challenge request, if it exists.
	 */
	if (m_pInternalRequest != NULL)
	{
		m_pInternalRequest->ChallengeItemList.Reset();
		while (NULL != (challenge_item_info_ptr = m_pInternalRequest->ChallengeItemList.Iterate()))
		{
			/*
			 * Delete any memory being referenced in the ChallengeItemInfo 
			 * structure.
			 */
			if (NULL != challenge_item_info_ptr->algorithm.object_key)
			{
			    challenge_item_info_ptr->algorithm.object_key->Release();
			}
			delete challenge_item_info_ptr->algorithm.poszOctetString;
			if (NULL!= challenge_item_info_ptr->challenge_data_list)
			{
			    challenge_item_info_ptr->challenge_data_list->Release();
			}

			/*
			 * Delete the challenge item contained in the list.
			 */
			delete challenge_item_info_ptr;
		}
		
		/*
		 * Delete the request structure.
		 */
		delete m_pInternalRequest;
	}

	/*
	 * Delete any memory allocated for the challenge response information.
	 */
	if (m_pInternalResponse != NULL)
	{
		if (NULL != m_pInternalResponse->algorithm.object_key)
		{
		    m_pInternalResponse->algorithm.object_key->Release();
		}
		delete m_pInternalResponse->algorithm.poszOctetString;
		if (NULL != m_pInternalResponse->challenge_response_item.password)
		{
		    m_pInternalResponse->challenge_response_item.password->Release();
		}
		if (NULL != m_pInternalResponse->challenge_response_item.response_data_list)
		{
		    m_pInternalResponse->challenge_response_item.response_data_list->Release();
		}
		delete m_pInternalResponse;
	}
}


/*
 *	LockPasswordData ()
 *
 *	Public Function Description:
 *		This routine is called to "Lock" the password data.  The first time this
 *		routine is called, the lock count will be zero and this will result
 *		in the password data being copied from the internal structures into an 
 *		"API" structure of the proper form.  Subsequent calls to this routine 
 *		will result in the lock count being incremented. 
 */
GCCError CPassword::LockPasswordData(void)
{
	GCCError rc;

	if (Lock() == 1)
	{
	    rc = GCC_ALLOCATION_FAILURE;
		/*
		 * Check to see whether or not the password contains "challenge"
		 * information.  Fill in the appropriate internal structure.
		 */
		if (m_fSimplePassword)
		{
			if (m_pszNumeric == NULL)
			{
				ERROR_OUT(("CPassword::LockPasswordData: No valid numeric password data exists"));
				goto MyExit;
			}

			DBG_SAVE_FILE_LINE
			if (NULL == (m_pPassword = new GCCPassword))
			{
				ERROR_OUT(("CPassword::LockPasswordData: can't create GCCPassword"));
				goto MyExit;
			}

    		/*
    		 * Fill in the numeric password string which must exist.
    		 */
			m_pPassword->numeric_string = (GCCNumericString) m_pszNumeric;

			/*
			 * Fill in the textual password string.
			 */
			m_pPassword->text_string = m_pwszText;
		}
		else
		{
			/*
			 * The password contains challenge information so create the 
			 * structure to pass back the necessary information.
			 */
			DBG_SAVE_FILE_LINE
			m_pChallengeResponse = new GCCChallengeRequestResponse;
			if (m_pChallengeResponse == NULL)
			{
				ERROR_OUT(("CPassword::LockPasswordData: can't create GCCChallengeRequestResponse"));
				goto MyExit;
			}
			::ZeroMemory(m_pChallengeResponse, sizeof(GCCChallengeRequestResponse));

			/*
			 * Fill in the "API" password challenge structure after 
			 * determining what type exists.
			 */
			if (m_fClearPassword)
			{
				/*
				 * This password contains no "challenge" information.
				 */
				m_pChallengeResponse->password_challenge_type = GCC_PASSWORD_IN_THE_CLEAR;

				/*
				 * This "clear" part of the	password is a "selector" which 
				 * means the form is either	numeric or text.  The check to
				 * verify that at least one form exists was done on
				 * construction.
				 */
				m_pChallengeResponse->u.password_in_the_clear.numeric_string = m_pszNumeric;
				m_pChallengeResponse->u.password_in_the_clear.text_string = m_pwszText;
			}
			else
			{
				/*
				 * This password contains real "challenge" information.
				 */
				m_pChallengeResponse->password_challenge_type = GCC_PASSWORD_CHALLENGE;

				/*
				 * Check to see if a challenge request exists.  If so,
				 * create a GCCChallengeRequest to hold the "API" data and 
				 * fill in that structure.
				 */
				if (m_pInternalRequest != NULL)
				{
					DBG_SAVE_FILE_LINE
					m_pChallengeResponse->u.challenge_request_response.
							challenge_request = new GCCChallengeRequest;
					if (m_pChallengeResponse->u.challenge_request_response.
							challenge_request == NULL)
					{
						ERROR_OUT(("CPassword::LockPasswordData: can't create GCCChallengeRequest"));
						goto MyExit;
					}

					if (GetGCCChallengeRequest(m_pChallengeResponse->u.
							challenge_request_response.challenge_request) != GCC_NO_ERROR)
					{
						ERROR_OUT(("CPassword::LockPasswordData: can't gett GCCChallengeRequest"));
						goto MyExit;
					}
				}
				else
				{
					m_pChallengeResponse->u.challenge_request_response.challenge_request = NULL;
				}

				/*
				 * Check to see if a challenge response exists.  If so,
				 * create a GCCChallengeResponse to hold the "API" data and 
				 * fill in that structure.
				 */
				if (m_pInternalResponse != NULL)
				{
					DBG_SAVE_FILE_LINE
					m_pChallengeResponse->u.challenge_request_response.
							challenge_response = new GCCChallengeResponse;
					if (m_pChallengeResponse->u.challenge_request_response.
							challenge_response == NULL)
					{
						ERROR_OUT(("CPassword::LockPasswordData: can't create new GCCChallengeResponse"));
						goto MyExit;
					}

					if (GetGCCChallengeResponse(m_pChallengeResponse->u.
					        challenge_request_response.challenge_response) != GCC_NO_ERROR)
					{
						ERROR_OUT(("CPassword::LockPasswordData: can't get GCCChallengeResponse"));
						goto MyExit;
					}
				}
				else
				{
					m_pChallengeResponse->u.challenge_request_response.
							challenge_response = NULL;
				}
			}
		}
	}

	rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        if (! m_fSimplePassword)
        {
            if (NULL != m_pChallengeResponse)
            {
                delete m_pChallengeResponse->u.challenge_request_response.challenge_request;
                delete m_pChallengeResponse->u.challenge_request_response.challenge_response;
                delete m_pChallengeResponse;
                m_pChallengeResponse = NULL;
            }
        }
    }

	return rc;
}


/*
 *	GetPasswordData ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the password data in the form of 
 *		the "API" structure "GCCPassword".  No "challenge" information is
 *		returned.
 */
GCCError CPassword::GetPasswordData(PGCCPassword *gcc_password)
{
	GCCError	return_value = GCC_NO_ERROR;
	
	/*
	 * If the pointer to the "API" password data is valid, set the output
	 * parameter to return a pointer to the "API" password data.  Otherwise, 
	 * report that the password data has yet to be locked into the "API" form.
	 */ 
	if (m_pPassword != NULL)
	{
		*gcc_password = m_pPassword;
	}
	else
	{
    	*gcc_password = NULL;
		return_value = GCC_ALLOCATION_FAILURE;
		ERROR_OUT(("CPassword::GetPasswordData: Error Data Not Locked"));
	}
	
	return (return_value);
}

/*
 *	GetPasswordChallengeData ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the password data in the form of 
 *		the "API" structure "GCCChallengeRequestResponse".
 */
GCCError CPassword::GetPasswordChallengeData(PGCCChallengeRequestResponse *gcc_challenge_password)
{
	GCCError	return_value = GCC_NO_ERROR;

	/*
	 * If the pointer to the "API" password challenge data is valid, set the
	 * output parameter to return a pointer to the "API" password challenge
	 * data.  Otherwise, report that the password data has yet to be locked 
	 * into the "API" form.
	 */ 
	if (m_pChallengeResponse != NULL)
	{
		*gcc_challenge_password = m_pChallengeResponse;
	}
	else
	{
    	*gcc_challenge_password = NULL;
		return_value = GCC_ALLOCATION_FAILURE;
		ERROR_OUT(("CPassword::GetPasswordData: Error Data Not Locked"));
	}
	
	return (return_value);
}

/*
 *	UnLockPasswordData ()
 *
 *	Public Function Description
 *		This routine decrements the lock count and frees the memory associated 
 *		with "API" password data when the lock count reaches zero.
 */
void CPassword::UnLockPasswordData(void)
{
	if (Unlock(FALSE) == 0)
	{
		/*
		 * Delete the memory associated with the "API" "simple" password 
		 * data structure.
		 */
		delete m_pPassword;
		m_pPassword = NULL;

		/*
		 * Delete the memory associated with the "API" "challenge" password 
		 * data structure.
		 */
		if (m_pChallengeResponse != NULL)
		{
			if (m_fClearPassword == FALSE)
			{
				FreeAPIPasswordData();
			}
			else
			{
				delete m_pChallengeResponse;
				m_pChallengeResponse = NULL;
			}
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}

/*
 *	GetPasswordPDU ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the password data in the "PDU" form
 *		of a "Password" structure.
 */
GCCError CPassword::GetPasswordPDU(PPassword pdu_password)
{
	GCCError			return_value = GCC_NO_ERROR;
	
	pdu_password->bit_mask = 0;

	/*
	 * Fill in the numeric portion of the password which must always exist.
	 */	
	if (m_pszNumeric != NULL)
	{
		::lstrcpyA(pdu_password->numeric, m_pszNumeric);
	}
	else
		return_value = GCC_ALLOCATION_FAILURE;
	
	/*
	 * Fill in the optional textual portion of the password if it is present.
	 * Set the bitmask in the PDU structure to indicate that the text exists.
	 */		
	if (m_pwszText != NULL)
	{
		pdu_password->bit_mask |= PASSWORD_TEXT_PRESENT;
		
		pdu_password->password_text.value = m_pwszText; 
		pdu_password->password_text.length= ::lstrlenW(m_pwszText);
	}
	
	return (return_value);
}

/*
 *	GetPasswordSelectorPDU ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the password data in the "PDU" form
 *		of a "PasswordSelector" structure.  In a "PasswordSelector" either the
 *		numeric or the text version of the password exists, but not both.
 */
GCCError CPassword::GetPasswordSelectorPDU(PPasswordSelector password_selector_pdu)
{
	GCCError		return_value = GCC_NO_ERROR;
	
	/*
	 * Fill in the version of the password which exists and set
	 * the "choice" to indicate what type of password this is.
	 */
	if (m_pszNumeric != NULL)
	{
		password_selector_pdu->choice = PASSWORD_SELECTOR_NUMERIC_CHOSEN;
		
		::lstrcpyA(password_selector_pdu->u.password_selector_numeric, m_pszNumeric);
	}
	else if (m_pwszText != NULL)
	{
		password_selector_pdu->choice = PASSWORD_SELECTOR_TEXT_CHOSEN;
		password_selector_pdu->u.password_selector_text.value = m_pwszText; 
		password_selector_pdu->u.password_selector_text.length = ::lstrlenW(m_pwszText);
	}
	else
	{
		ERROR_OUT(("CPassword::GetPasswordSelectorPDU: No valid data"));
		return_value = GCC_INVALID_PASSWORD;
	}
	
   return (return_value);
}

/*
 *	GetPasswordChallengeResponsePDU	()
 *
 *	Public Function Description:
 *		This routine fills in a password challenge request-response "PDU"
 *		structure with the password data.
 */
GCCError CPassword::GetPasswordChallengeResponsePDU(PPasswordChallengeRequestResponse challenge_pdu)
{
	GCCError			return_value = GCC_NO_ERROR;
	
	/*
	 * Check to see if this is a "simple" password.  If it is, then this routine
	 * has been called in error.
	 */
	if ((challenge_pdu == NULL) || m_fSimplePassword)
	{
		ERROR_OUT(("CPassword::GetPasswordChallengeResponsePDU: no challenge data"));
		return (GCC_INVALID_PARAMETER);
	}

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidChallengeResponsePDU == FALSE)
	{
		m_fValidChallengeResponsePDU = TRUE;

		/*
		 * Fill in the password challenge PDU structure.
		 */
		if (m_fClearPassword)
		{
			/*
			 * If this is a clear password then fill in the text or
			 * numeric string as well as the choice.  Only one form of the
			 * password exists for PasswordSelectors such as this.
			 */
			m_ChallengeResponsePDU.choice = CHALLENGE_CLEAR_PASSWORD_CHOSEN;

			if (m_pszNumeric != NULL)
			{
				m_ChallengeResponsePDU.u.challenge_clear_password.choice =
											PASSWORD_SELECTOR_NUMERIC_CHOSEN;
				
				::lstrcpyA(m_ChallengeResponsePDU.u.challenge_clear_password.u.password_selector_numeric,
						m_pszNumeric);
			}
			else if (m_pwszText != NULL)
			{
				m_ChallengeResponsePDU.u.challenge_clear_password.choice =
												PASSWORD_SELECTOR_TEXT_CHOSEN;

				m_ChallengeResponsePDU.u.challenge_clear_password.u.
						password_selector_text.value = m_pwszText;
 
				m_ChallengeResponsePDU.u.challenge_clear_password.u.
						password_selector_text.length = ::lstrlenW(m_pwszText);
			}
			else
			{
				ERROR_OUT(("CPassword::GetPwordChallengeResPDU: No valid data"));
				return_value = GCC_INVALID_PASSWORD;
			}
		}
		else
		{
			/*
			 * The challenge password contains challenge information.  Fill in
			 * the request and response structures if they exist.
			 */
			m_ChallengeResponsePDU.choice = CHALLENGE_REQUEST_RESPONSE_CHOSEN; 
			m_ChallengeResponsePDU.u.challenge_request_response.bit_mask = 0;

			/*
			 * Check to see if a "request" exists.
			 */
			if (m_pInternalRequest != NULL)
			{
				m_ChallengeResponsePDU.u.challenge_request_response.bit_mask |=
												CHALLENGE_REQUEST_PRESENT;

				/*
				 * Call the routine which fills in the PDU form of the
				 * request structure.
				 */
				return_value = GetChallengeRequestPDU (&m_ChallengeResponsePDU.
						u.challenge_request_response.challenge_request);
			}

			/*
			 * Check to see if a "response" exists.
			 */
			if ((m_pInternalResponse != NULL) && (return_value == GCC_NO_ERROR))
			{
				m_ChallengeResponsePDU.u.challenge_request_response.bit_mask |=
												CHALLENGE_RESPONSE_PRESENT;

				/*
				 * Call the routine which fills in the PDU form of the
				 * response structure.
				 */
				return_value = GetChallengeResponsePDU (&m_ChallengeResponsePDU.
						u.challenge_request_response.challenge_response);
			}
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*challenge_pdu = m_ChallengeResponsePDU;
		
	return (return_value);
}
									

/*
 *	FreePasswordChallengeResponsePDU ()
 *
 *	Public Function Description:
 *		This routine is used to free any memory allocated to hold "PDU" data
 * 		associated with the PasswordChallengeRequestResponse.
 */
void CPassword::FreePasswordChallengeResponsePDU(void)
{
	/*
	 * Check to see if there has been any "PDU" memory allocated which now
	 * needs to be freed.
	 */
	if (m_fValidChallengeResponsePDU)
	{
		/*
		 * Set the flag indicating that PDU password data is no longer
		 * allocated.
		 */
		m_fValidChallengeResponsePDU = FALSE;

		/*
		 * Check to see what type of password PDU is to be freed.  If this is a
		 * clear password then no data was allocated which now must be freed.
		 */
		if (m_ChallengeResponsePDU.choice == CHALLENGE_REQUEST_RESPONSE_CHOSEN)
		{
			/*
			 * This is a challenge password so free any data which was allocated
			 * to hold the challenge information.  Check the PDU structure 
			 * bitmask which indicates what form of challenge exists.
			 */
			if (m_ChallengeResponsePDU.u.challenge_request_response.bit_mask & 
													CHALLENGE_REQUEST_PRESENT)
			{
				FreeChallengeRequestPDU ();
			}
			
			if (m_ChallengeResponsePDU.u.challenge_request_response.
					bit_mask & CHALLENGE_RESPONSE_PRESENT)
			{
				FreeChallengeResponsePDU ();
			}
		}
	}
}
									

/*
 *	GCCError	ConvertAPIChallengeRequest(
 *							PGCCChallengeRequest		challenge_request)
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to copy an "API" challenge request structure into
 *		the internal structure.
 *
 *	Formal Parameters:
 *		challenge_request		(i)	The API structure to copy internally.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertAPIChallengeRequest(PGCCChallengeRequest challenge_request)
{
	GCCError				return_value = GCC_NO_ERROR;
	GCCError				error_value;
	Int						i;
	PGCCChallengeItem		challenge_item_ptr;
	PChallengeItemInfo		challenge_item_info_ptr;

	/*
	 * Save the challenge tag and number of challenge items in the internal
	 * structure.
	 */
	m_pInternalRequest->challenge_tag = challenge_request->challenge_tag;

	/*
	 * Save the list of challenge items in the internal Rogue Wave List.
	 */
	for (i = 0; i < challenge_request->number_of_challenge_items; i++)
	{
		DBG_SAVE_FILE_LINE
		challenge_item_info_ptr = new ChallengeItemInfo;
		if (challenge_item_info_ptr != NULL)
		{
			/*
			 * Initialize the pointers in the challenge item info structure
			 * to NULL.
			 */
			challenge_item_info_ptr->algorithm.object_key = NULL;
			challenge_item_info_ptr->algorithm.poszOctetString = NULL;
			challenge_item_info_ptr->challenge_data_list = NULL;

			/*
			 * Insert the pointer to the new challenge item structure into the 
			 * internal list.
			 */
			m_pInternalRequest->ChallengeItemList.Append(challenge_item_info_ptr);

			/*
			 * Retrieve the pointer to the challenge item from the input list.
			 */
			challenge_item_ptr = challenge_request->challenge_item_list[i];

			/*
			 * Copy the challenge response algorithm to the internal structure.
			 */
			return_value = CopyResponseAlgorithm (
					&(challenge_item_ptr->response_algorithm),
					&(challenge_item_info_ptr->algorithm));

			if (return_value != GCC_NO_ERROR)
			{
				ERROR_OUT(("Password::ConvertAPIChallengeRequest: Error copying Response Algorithm."));
				break;
			}

			/*
			 * Copy the challenge data.
			 */
			if ((challenge_item_ptr->number_of_challenge_data_members != 0) && 
					(challenge_item_ptr->challenge_data_list != NULL))
			{
				DBG_SAVE_FILE_LINE
				challenge_item_info_ptr->challenge_data_list = new CUserDataListContainer(
						challenge_item_ptr->number_of_challenge_data_members,
						challenge_item_ptr->challenge_data_list,
						&error_value);
				if ((challenge_item_info_ptr == NULL) || 
						(error_value != GCC_NO_ERROR))
				{
					ERROR_OUT(("Password::ConvertAPIChallengeRequest: can't create CUserDataListContainer."));
					return_value = GCC_ALLOCATION_FAILURE;
					break;
				}
			}
			else
			{
				challenge_item_info_ptr->challenge_data_list = NULL;
				ERROR_OUT(("Password::ConvertAPIChallengeRequest: Error no valid user data."));
				return_value = GCC_INVALID_PASSWORD;
				break;
			}
		}
		else
		{
			ERROR_OUT(("Password::ConvertAPIChallengeRequest: Error creating "
					"new ChallengeItemInfo."));
			return_value = GCC_ALLOCATION_FAILURE;
			break;
		}
	}
	
	return (return_value);
}

/*
 *	GCCError	ConvertAPIChallengeResponse(
 *							PGCCChallengeResponse		challenge_response)
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to copy an "API" challenge response structure into
 *		the internal structure.
 *
 *	Formal Parameters:
 *		challenge_response		(i)	The API structure to copy internally.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertAPIChallengeResponse(PGCCChallengeResponse challenge_response)
{
	GCCError			return_value = GCC_NO_ERROR;
	GCCError			error_value;
			
	/*
	 * Initialize the challenge response info structure pointers to NULL.
	 */
	m_pInternalResponse->challenge_response_item.password = NULL;
	m_pInternalResponse->challenge_response_item.response_data_list = NULL;

	/*
	 * Save the challenge tag in the internal structure.
	 */
	m_pInternalResponse->challenge_tag = challenge_response->challenge_tag;

	/*
	 * Copy the challenge response algorithm to the internal structure.
	 */
	return_value = CopyResponseAlgorithm (
			&(challenge_response->response_algorithm),
			&(m_pInternalResponse->algorithm));
	if (return_value != GCC_NO_ERROR)
	{
		ERROR_OUT(("Password::ConvertAPIChallengeResponse: Error copying Response Algorithm."));
	}

	/*
	 * Copy the challenge response item into the internal info structure.
	 * The challenge response item will consist of either a password string
	 * or else a response user data list.
	 */
	if (return_value == GCC_NO_ERROR)
	{
		if (challenge_response->response_algorithm.password_algorithm_type ==
												GCC_IN_THE_CLEAR_ALGORITHM)
		{
			if (challenge_response->response_item.password_string != NULL)
			{
				DBG_SAVE_FILE_LINE
				m_pInternalResponse->challenge_response_item.password = new 
						CPassword(challenge_response->response_item.password_string, &error_value);
				if ((m_pInternalResponse->challenge_response_item.password == 
						NULL)||	(error_value != GCC_NO_ERROR))
				{
					ERROR_OUT(("Password::ConvertAPIChallengeResp: Error creating new CPassword."));
					return_value = GCC_ALLOCATION_FAILURE;
				}
			}
			else
				return_value = GCC_INVALID_PASSWORD;
		}
		else
		{
			if ((challenge_response->response_item.
				number_of_response_data_members != 0) && 
				(challenge_response->response_item.response_data_list != NULL))
			{
				/* 
				 * Save the response data list in a CUserDataListContainer object.
				 */
				DBG_SAVE_FILE_LINE
				m_pInternalResponse->challenge_response_item.response_data_list = 
					new CUserDataListContainer(challenge_response->response_item.number_of_response_data_members,
						        challenge_response->response_item.response_data_list,
						        &error_value);
				if ((m_pInternalResponse->challenge_response_item.response_data_list == NULL) || 
					(error_value != GCC_NO_ERROR))
				{
					ERROR_OUT(("Password::ConvertAPIChallengeResponse: can't create CUserDataListContainer."));
					return_value = GCC_ALLOCATION_FAILURE;
				}
			}
			else
				return_value = GCC_INVALID_PASSWORD;
		}
	}

	/*
	 * Check to make sure one type of response item was saved.
	 */
	if ((return_value == GCC_NO_ERROR) && 
			(m_pInternalResponse->challenge_response_item.password == NULL) && 
			(m_pInternalResponse->challenge_response_item.response_data_list == 
			NULL))
	{
		ERROR_OUT(("Password::ConvertAPIChallengeResponse: Error no valid response item saved."));
		return_value = GCC_ALLOCATION_FAILURE;
	}

	return (return_value);
}

/*
 *	GCCError	CopyResponseAlgorithm(
 *					PGCCChallengeResponseAlgorithm		source_algorithm,
 *					PResponseAlgorithmInfo				destination_algorithm)
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to copy an "API" response algorithm into the
 *		internal storage structure.
 *
 *	Formal Parameters:
 *		source_algorithm		(i)	The API algorithm structure to copy 
 *										internally.
 *		destination_algorithm	(o)	Pointer to the internal algorithm structure
 *										which will hold the converted item.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::CopyResponseAlgorithm(
					PGCCChallengeResponseAlgorithm		source_algorithm,
					PResponseAlgorithmInfo				destination_algorithm)
{
	GCCError			return_value = GCC_NO_ERROR;
	GCCError			error_value;

	/*
	 * Copy the challenge response algorithm.
	 */
	destination_algorithm->algorithm_type = source_algorithm->
													password_algorithm_type;

	if (destination_algorithm->algorithm_type == GCC_NON_STANDARD_ALGORITHM)
	{
		/* 
		 * Create a new CObjectKeyContainer object to hold the algorithm's object key
		 * internally.
		 */
		DBG_SAVE_FILE_LINE
		destination_algorithm->object_key = new CObjectKeyContainer(
							&source_algorithm->non_standard_algorithm->object_key,
							&error_value);
		if (destination_algorithm->object_key == NULL)
		{
			ERROR_OUT(("CPassword::CopyResponseAlgorithm: Error creating new CObjectKeyContainer"));
			return_value = GCC_ALLOCATION_FAILURE;
		}
		else if (error_value != GCC_NO_ERROR)
		{
			ERROR_OUT(("CPassword::CopyResponseAlgorithm: Error creating new CObjectKeyContainer"));
			return_value = GCC_INVALID_PASSWORD;
		}

		if (return_value == GCC_NO_ERROR)
		{
			/* 
			 * Create a new Rogue Wave string to hold the algorithm's octet 
			 * string internally.
			 */
			if (NULL == (destination_algorithm->poszOctetString = ::My_strdupO2(
						source_algorithm->non_standard_algorithm->parameter_data.value,
						source_algorithm->non_standard_algorithm->parameter_data.length)))
			{	
				ERROR_OUT(("CPassword::CopyResponseAlgorithm: can't create octet string in algorithm"));
				return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
			destination_algorithm->poszOctetString = NULL;
	}
	else
	{
		/*
		 * The algorithm is a standard type so initialize to NULL the pointers
		 * used to hold the data associated with a non-standard algorithm.
		 */
		destination_algorithm->object_key = NULL;
		destination_algorithm->poszOctetString = NULL;
	}

	return (return_value);
}

/*
 *	GCCError	ConvertPDUChallengeRequest (
 *					PChallengeRequest					challenge_request);
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to copy a "PDU" challenge request structure into
 *		the internal storage structure.
 *
 *	Formal Parameters:
 *		challenge_request		(i)	The API structure to copy internally.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertPDUChallengeRequest(PChallengeRequest challenge_request)
{
	GCCError				return_value = GCC_NO_ERROR;
	PSetOfChallengeItems	current_challenge_item_set;
	PSetOfChallengeItems	next_challenge_item_set;

	/*
	 * Save the challenge tag in the internal structure.
	 */
	m_pInternalRequest->challenge_tag = challenge_request->challenge_tag;

	if (challenge_request->set_of_challenge_items != NULL)
	{
		/*
		 * Loop through the PDU set of challenge items, converting each into
		 * the internal form.
		 */
		current_challenge_item_set = challenge_request->set_of_challenge_items;
		while (1)
		{
			next_challenge_item_set = current_challenge_item_set->next;

			/*
			 * The routine which converts the challenge items saves the internal
			 * form in a Rogue Wave list.
			 */
			if (ConvertPDUChallengeItem (&current_challenge_item_set->value) !=
					GCC_NO_ERROR)
			{
				return_value = GCC_ALLOCATION_FAILURE;
				break;
			}

			if (next_challenge_item_set != NULL)
				current_challenge_item_set = next_challenge_item_set;
			else
				break;	
		}
	}

	return (return_value);
}


/*
 *	GCCError	ConvertPDUChallengeItem (
 *					PChallengeItem						challenge_item_ptr);
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to copy a "PDU" ChallengeItem structure into
 *		the internal ChallengeItemInfo storage structure.
 *
 *	Formal Parameters:
 *		challenge_item_ptr		(i)	The PDU structure to copy internally.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertPDUChallengeItem(PChallengeItem challenge_item_ptr)
{
	PChallengeItemInfo		challenge_item_info_ptr;
	GCCError				return_value = GCC_NO_ERROR;
	GCCError				error_value = GCC_NO_ERROR;

	/*
	 * Create a new challenge item and save it in the internal Rogue Wave List.
	 */
	DBG_SAVE_FILE_LINE
	challenge_item_info_ptr = new ChallengeItemInfo;
	if (challenge_item_info_ptr != NULL)
	{
		/*
		 * Insert the pointer to the new challenge item structure into the 
		 * internal Rogue Wave list.
		 */
		challenge_item_info_ptr->challenge_data_list = NULL;
	
		m_pInternalRequest->ChallengeItemList.Append(challenge_item_info_ptr);

		/*
		 * Convert the challenge response algorithm to the internal structure.
		 */
		if (ConvertPDUResponseAlgorithm(
				&(challenge_item_ptr->response_algorithm),
				&(challenge_item_info_ptr->algorithm)) != GCC_NO_ERROR)
		{
			ERROR_OUT(("Password::ConvertAPIChallengeItem: Error converting Response Algorithm."));
			return_value = GCC_ALLOCATION_FAILURE;
		}

		/*
		 * Convert the challenge data to internal form.
		 */
		if ((return_value == GCC_NO_ERROR) &&
				(challenge_item_ptr->set_of_challenge_data != NULL))
		{
			DBG_SAVE_FILE_LINE
			challenge_item_info_ptr->challenge_data_list = new CUserDataListContainer(
					challenge_item_ptr->set_of_challenge_data,
					&error_value);
			if ((challenge_item_info_ptr->challenge_data_list == NULL) || 
					(error_value != GCC_NO_ERROR))
			{
				ERROR_OUT(("Password::ConvertAPIChallengeItem: can't create CUserDataListContainer."));
				return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ERROR_OUT(("Password::ConvertAPIChallengeItem: Error no valid user data"));
			return_value = GCC_INVALID_PASSWORD;
		}
	}
	else
	{
		ERROR_OUT(("Password::ConvertAPIChallengeItem: Error creating "
				"new ChallengeItemInfo."));
		return_value = GCC_ALLOCATION_FAILURE;
	}
	
	return (return_value);
}

/*
 *	GCCError	ConvertPDUChallengeResponse (
 *							PChallengeResponse			challenge_response)
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to copy a "PDU" challenge response structure into
 *		the internal structure.
 *
 *	Formal Parameters:
 *		challenge_response		(i)	The API structure to copy internally.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertPDUChallengeResponse(PChallengeResponse challenge_response)
{
	GCCError				return_value = GCC_NO_ERROR;
	GCCError				error_value = GCC_NO_ERROR;

	/*
	 * Save the challenge tag in the internal structure.
	 */
	m_pInternalResponse->challenge_tag = challenge_response->challenge_tag;

	/*
	 * Convert the challenge response algorithm to the internal structure.
	 */
	if (ConvertPDUResponseAlgorithm(
			&(challenge_response->response_algorithm),
			&(m_pInternalResponse->algorithm)) != GCC_NO_ERROR)
	{
		ERROR_OUT(("Password::ConvertPDUChallengeResponse: Error converting Response Algorithm."));
		return_value = GCC_ALLOCATION_FAILURE;
	}

	/*
	 * Check to see what form the challenge response item has taken.  Create
	 * the necessary object to hold the item internally.
	 */
	if ((challenge_response->response_item.choice == PASSWORD_STRING_CHOSEN) &&
			(return_value == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		m_pInternalResponse->challenge_response_item.password = new CPassword(
			&challenge_response->response_item.u.password_string,
			&error_value);
		if ((m_pInternalResponse->challenge_response_item.password == NULL) || 
				(error_value != GCC_NO_ERROR))
		{
			ERROR_OUT(("Password::ConvertPDUChallengeResponse: Error creating new CPassword."));
			return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
		m_pInternalResponse->challenge_response_item.password = NULL;

	if ((challenge_response->response_item.choice == 
			SET_OF_RESPONSE_DATA_CHOSEN) && (return_value == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		m_pInternalResponse->challenge_response_item.response_data_list = 
				new CUserDataListContainer(challenge_response->response_item.u.set_of_response_data,
				            &error_value);
		if ((m_pInternalResponse->challenge_response_item.
				response_data_list == NULL) || (error_value != GCC_NO_ERROR))
		{
			ERROR_OUT(("Password::ConvertPDUChallengeResponse: can't create CUserDataListContainer."));
			return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
    {
		m_pInternalResponse->challenge_response_item.response_data_list = NULL;
    }

	return (return_value);
}

/*
 *	GCCError	ConvertPDUResponseAlgorithm (
 *					PChallengeResponseAlgorithm			source_algorithm,
 *					PResponseAlgorithmInfo				destination_algorithm);
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to convert a "PDU" response algorithm 
 * 		structure into the internal form.
 *
 *	Formal Parameters:
 *		source_algorithm		(i)	The PDU algorithm structure to copy 
 *										internally.
 *		destination_algorithm	(o) Pointer to the internal structure which will
 *										hold the converted item.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PARAMETER			-	A NULL pointer was passed in or
 *												the algorithm has invalid type.
 *		GCC_INVALID_PASSWORD			-	An invalid password was passed in. 
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertPDUResponseAlgorithm(
					PChallengeResponseAlgorithm			source_algorithm,
					PResponseAlgorithmInfo				destination_algorithm)
{
	GCCError			return_value = GCC_NO_ERROR;
	GCCError			error_value;;

	if (source_algorithm != NULL)
	{
		/*
		 * Convert the challenge response algorithm type.
		 */
		if (source_algorithm->choice == ALGORITHM_CLEAR_PASSWORD_CHOSEN)
			destination_algorithm->algorithm_type = GCC_IN_THE_CLEAR_ALGORITHM;
		else if (source_algorithm->choice == NON_STANDARD_ALGORITHM_CHOSEN)
			destination_algorithm->algorithm_type = GCC_NON_STANDARD_ALGORITHM;
		else
		{
			ERROR_OUT(("CPassword::ConvertPDUResponseAlgorithm: Error: invalid password type"));
			return_value = GCC_INVALID_PARAMETER;
		}
	}
	else
	{
		ERROR_OUT(("CPassword::ConvertPDUResponseAlgorithm: Error: NULL source pointer."));
		return_value = GCC_INVALID_PARAMETER;
	}
	
	if ((return_value == GCC_NO_ERROR) && 
			(source_algorithm->choice == NON_STANDARD_ALGORITHM_CHOSEN))
	{
		/* 
		 * Create a new CObjectKeyContainer object to hold the algorithm's object key
		 * internally.
		 */
		DBG_SAVE_FILE_LINE
		destination_algorithm->object_key = new CObjectKeyContainer(
							&source_algorithm->u.non_standard_algorithm.key,
							&error_value);
		if (destination_algorithm->object_key == NULL)
		{
			ERROR_OUT(("CPassword::ConvertPDUResponseAlgorithm: Error creating new CObjectKeyContainer"));
			return_value = GCC_ALLOCATION_FAILURE;
		}
		else if (error_value != GCC_NO_ERROR)
		{
			ERROR_OUT(("CPassword::ConvertPDUResponseAlgorithm: Error creating new CObjectKeyContainer"));
			return_value = GCC_INVALID_PASSWORD;
		}
		else
		{
			/* 
			 * Create a new Rogue Wave string to hold the algorithm's octet
			 * string internally.
			 */
			if (NULL == (destination_algorithm->poszOctetString = ::My_strdupO2(
					source_algorithm->u.non_standard_algorithm.data.value,
					source_algorithm->u.non_standard_algorithm.data.length)))
			{	
				ERROR_OUT(("CPassword::ConvertPDUResponseAlgorithm: can't create octet string in algorithm"));
				return_value = GCC_ALLOCATION_FAILURE;
			}
		}
	}
	else
	{
		/*
		 * The algorithm is a standard type so initialize to NULL the pointers
		 * used to hold the data associated with a non-standard algorithm.
		 */
		destination_algorithm->poszOctetString = NULL;
		destination_algorithm->object_key = NULL;
	}

	return (return_value);
}


/*
 *	GCCError	GetGCCChallengeRequest (
 *					PGCCChallengeRequest				challenge_request)
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to fill in the internal "API" challenge request
 *		structure from the internal storage structures.  This is done on a 
 *		"lock" in order to make data available which is suitable for being
 *		passed back up through the API.  
 *
 *	Formal Parameters:
 *		challenge_request		(i)	The API structure to fill in with the "API"
 *										challenge request data.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::GetGCCChallengeRequest(PGCCChallengeRequest challenge_request)
{
	GCCError					return_value = GCC_NO_ERROR;
	UInt						i = 0;
	Int							j = 0;
	PGCCChallengeItem			api_challenge_item_ptr;
	PChallengeItemInfo			internal_challenge_item_ptr;
	PChallengeItemMemoryInfo	internal_challenge_item_memory_ptr;		
	UINT						object_key_length;
	UINT						user_data_length;

	/*
	 * Save the challenge tag and retrieve the number of challenge items.
	 */
	challenge_request->challenge_tag = m_pInternalRequest->challenge_tag;

	challenge_request->number_of_challenge_items = 
							(USHORT) m_pInternalRequest->ChallengeItemList.GetCount();

	if (m_pInternalRequest->ChallengeItemList.GetCount() != 0)
	{
		/*
		 * Allocate the space needed for the list of pointers to GCC challenge 
		 * items.
		 */
		DBG_SAVE_FILE_LINE
		m_pChallengeItemListMemory = new BYTE[sizeof(PGCCChallengeItem) * m_pInternalRequest->ChallengeItemList.GetCount()];
		if (m_pChallengeItemListMemory != NULL)
		{
			PChallengeItemInfo lpChItmInfo;

			/*
			 * Retrieve the actual pointer to memory from the Memory object
			 * and save it in the internal API Challenge Item list.
			 */
			challenge_request->challenge_item_list = (GCCChallengeItem **)
										m_pChallengeItemListMemory;

			/*
			 * Initialize the pointers in the list to NULL.
			 */						
			for (i=0; i < m_pInternalRequest->ChallengeItemList.GetCount(); i++)
				challenge_request->challenge_item_list[i] = NULL;
			
			/*
			 * Copy the data from the internal list of "ChallengeItemInfo" 
			 * structures into the "API" form which is a list of pointers
			 * to GCCChallengeItem structures.
			 */
			m_pInternalRequest->ChallengeItemList.Reset();
			while (NULL != (lpChItmInfo = m_pInternalRequest->ChallengeItemList.Iterate()))
			{
				/* 
				 * Get a pointer to a new GCCChallengeItem structure.
				 */
				DBG_SAVE_FILE_LINE
				api_challenge_item_ptr = new GCCChallengeItem;
				if (api_challenge_item_ptr != NULL)
				{
					/*
					 * Go ahead and put the pointer in the list and 
					 * post-increment the loop counter.
					 */
					challenge_request->challenge_item_list[j++] =
							api_challenge_item_ptr;
			
					/*
					 * Retrieve the ChallengeItemInfo structure from the Rogue 
					 * Wave list.
					 */
					internal_challenge_item_ptr = lpChItmInfo;

					/*
					 * Fill in the algorithm type for the challenge response
					 * algorithm.
					 */
					api_challenge_item_ptr->response_algorithm.
							password_algorithm_type = 
							internal_challenge_item_ptr->
									algorithm.algorithm_type;

					/*
					 * The memory for the response algorithm's object key data 
					 * and the challenge item's used data are stored in
					 * a ChallengeItemMemoryInfo structure so create one
					 * here.  If the response algorithm is "clear" then the
					 * object key data element will not be used.  The challenge
					 * item user data should always exist.
					 */
					DBG_SAVE_FILE_LINE
					internal_challenge_item_memory_ptr = new ChallengeItemMemoryInfo;
					if (internal_challenge_item_memory_ptr != NULL)
					{
						/*
						 * Initialize the pointers in the challenge item 
						 * memory info structure to NULL.
						 */
						internal_challenge_item_memory_ptr->user_data_list_memory = NULL;
						internal_challenge_item_memory_ptr->object_key_memory = NULL;

						/*
						 * Insert the pointer to the new challenge item 
						 * memory structure into the internal Rogue Wave 
						 * list.
						 */
						m_ChallengeItemMemoryList.Append(internal_challenge_item_memory_ptr);
					}
					else
					{
						ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error creating new ChallengeItemMemoryInfo"));
						return_value = GCC_ALLOCATION_FAILURE;
						break;
					}

					if (api_challenge_item_ptr->response_algorithm.password_algorithm_type == 
							GCC_NON_STANDARD_ALGORITHM)
					{
						/*
						 * Create a new GCCNonStandardParameter to put in the
						 * ResponseAlgorithm structure.
						 */
						DBG_SAVE_FILE_LINE
						api_challenge_item_ptr->response_algorithm.non_standard_algorithm = 
								new GCCNonStandardParameter;

						if (api_challenge_item_ptr->response_algorithm.non_standard_algorithm	== NULL)
						{
							ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error creating new GCCNonStdParameter"));
							return_value = GCC_ALLOCATION_FAILURE;
							break;
						}

						/*
						 * Retrieve the API object key from the CObjectKeyContainer
						 * object in the ResponseAlgorithmInfo structure and
						 * fill in the GCCObjectKey in the non-standard 
						 * algorithm.  The CObjectKeyContainer object must be locked 
						 * before getting the data.
						 */
						object_key_length = internal_challenge_item_ptr->
								algorithm.object_key->LockObjectKeyData ();

						DBG_SAVE_FILE_LINE
						internal_challenge_item_memory_ptr->object_key_memory =
						        new BYTE[object_key_length];
						if (internal_challenge_item_memory_ptr->object_key_memory != NULL)
						{
							internal_challenge_item_ptr->algorithm.object_key->GetGCCObjectKeyData(
									&(api_challenge_item_ptr->response_algorithm.non_standard_algorithm->object_key),
									internal_challenge_item_memory_ptr->object_key_memory);
						}
						else
						{
							ERROR_OUT(("CPassword::GetGCCChallengeReq: Error Allocating Memory"));
							return_value = GCC_ALLOCATION_FAILURE;
						 	break;
						}

						/*
						 * Fill in the parameter data for the non-standard
						 * algorithm.  This includes the octet string pointer 
						 * and length.
						 */
						api_challenge_item_ptr->response_algorithm.non_standard_algorithm->
								parameter_data.value = 
								internal_challenge_item_ptr->algorithm.poszOctetString->value;

						api_challenge_item_ptr->response_algorithm.non_standard_algorithm->
								parameter_data.length =
								internal_challenge_item_ptr->algorithm.poszOctetString->length;
					}
					else
					{
						/*
						 * The algorithm is not a non-standard type so set the 
						 * non-standard pointer to NULL.
						 */
						api_challenge_item_ptr->response_algorithm.non_standard_algorithm = NULL;
					}

					/*
					 * Retrieve the API challenge data from the CUserDataListContainer 
					 * object.  The	call to GetUserDataList also returns the 
					 * number of user data members.  The CUserDataListContainer object
					 * must be locked before getting the data in order to 
					 * determine how much memory to allocate to hold the data.
					 */
					if (internal_challenge_item_ptr->challenge_data_list != NULL)
					{
						user_data_length = internal_challenge_item_ptr->
								challenge_data_list->LockUserDataList ();

						/*
						 * The memory for the user data is stored in the
						 * ChallengeItemMemoryInfo structure created above.
						 */
						DBG_SAVE_FILE_LINE
						internal_challenge_item_memory_ptr->user_data_list_memory =
						        new BYTE[user_data_length];
						if (internal_challenge_item_memory_ptr->user_data_list_memory != NULL)
						{
							/*
							 * Retrieve the actual pointer to memory from the 
							 * Memory object and save it in the internal user 
							 * data memory.
							 */
							internal_challenge_item_ptr->challenge_data_list->GetUserDataList(
										&api_challenge_item_ptr->number_of_challenge_data_members,
										&api_challenge_item_ptr->challenge_data_list,
										internal_challenge_item_memory_ptr->user_data_list_memory);
						}
						else
						{
							ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error Allocating Memory"));
							return_value = GCC_ALLOCATION_FAILURE;
						 	break;
						}
					}
					else
					{
						ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error no valid user data"));
						return_value = GCC_ALLOCATION_FAILURE;
					 	break;
					}
				}
				else
				{
					ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error creating new GCCChallengeItem"));
					return_value = GCC_ALLOCATION_FAILURE;
				 	break;
				}
			/*
			 * This is the end of the challenge item iterator loop.
			 */
			}
		}
		else
		{
			ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error Allocating Memory"));
			return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		/*
		 * There are no challenge items in the list so set the list pointer
		 * to NULL.
		 */
		challenge_request->challenge_item_list = NULL;
	}

	return (return_value);
}

/*
 *	GCCError	GetGCCChallengeResponse (
 *					PGCCChallengeResponse				challenge_response);
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to fill in the internal "API" challenge response
 *		structure from the internal storage structures.  This is done on a 
 *		"lock" in order to make data available which is suitable for being
 *		passed back up through the API.  
 *
 *	Formal Parameters:
 *		challenge_response		(i)	The API structure to fill in with the "API"
 *										challenge response data.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::GetGCCChallengeResponse(PGCCChallengeResponse challenge_response)
{
	GCCError		return_value = GCC_NO_ERROR;
	UINT			object_key_length;
	UINT			user_data_length;

	challenge_response->challenge_tag = m_pInternalResponse->challenge_tag;

	/*
	 * Fill in the algorithm type for the challenge response algorithm.
	 */
	challenge_response->response_algorithm.password_algorithm_type = 
			m_pInternalResponse->algorithm.algorithm_type;

	/*
	 * If the response algorithm is of non-standard type, create a new 
	 * GCCNonStandardParameter to put in the ResponseAlgorithm structure.
	 */
	if (challenge_response->response_algorithm.password_algorithm_type ==
			GCC_NON_STANDARD_ALGORITHM)
	{
		DBG_SAVE_FILE_LINE
		challenge_response->response_algorithm.non_standard_algorithm =
				new GCCNonStandardParameter;
		if (challenge_response->response_algorithm.non_standard_algorithm == 
				NULL)
		{
			ERROR_OUT(("CPassword::GetGCCChallengeResponse: Error creating new GCCNonStandardParameter"));
			return_value = GCC_ALLOCATION_FAILURE;
		}
		else
		{
			/*
			 * Retrieve the API object key from the CObjectKeyContainer object in the 
			 * ResponseAlgorithmInfo structure and fill	in the GCCObjectKey in  
			 * the non-standard algorithm.  The CObjectKeyContainer object must be 
			 * locked before getting the data.
			 */
			object_key_length = m_pInternalResponse->algorithm.object_key->
					LockObjectKeyData ();

    		DBG_SAVE_FILE_LINE
			m_pObjectKeyMemory = new BYTE[object_key_length];
			if (m_pObjectKeyMemory != NULL)
			{
				m_pInternalResponse->algorithm.object_key->
						GetGCCObjectKeyData (&(challenge_response->
								response_algorithm.non_standard_algorithm->
										object_key),
								m_pObjectKeyMemory);
			}
			else
			{
				ERROR_OUT(("CPassword::GetGCCChallengeResponse: Error Allocating Memory"));
				return_value = GCC_ALLOCATION_FAILURE;
			}

			/*
			 * Fill in the parameter data for the non-standard algorithm.
			 */
			if (return_value == GCC_NO_ERROR)
			{
				/*
				 * Fill in the octet string pointer and length.
				 */
				challenge_response->response_algorithm.non_standard_algorithm->
						parameter_data.value = 
						m_pInternalResponse->algorithm.poszOctetString->value;

				challenge_response->response_algorithm.non_standard_algorithm->
						parameter_data.length = 
						m_pInternalResponse->algorithm.poszOctetString->length;
			}
			else
			{
				ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error getting GCCObjectKeyData"));
				return_value = GCC_ALLOCATION_FAILURE;
			} 
		}
	}
	else
	{
		/*
		 * The algorithm in not non-standard so set the non-standard algorithm
		 * pointer to NULL.
		 */
		challenge_response->response_algorithm.non_standard_algorithm = NULL;
	}
	
	/*
	 * Now fill in the challenge response item in the challenge response
	 * structure.
	 */
	if (return_value == GCC_NO_ERROR)
	{
		/*
		 * Check to see whether the challenge response item consists of a 
		 * password string or a set of user data.  Fill in the appropriate
		 * part.
		 */
		if (m_pInternalResponse->challenge_response_item.password != NULL)
		{
			/*
			 * Set the number of user data members to zero to avoid any 
			 * confusion at the application.  This should match up with the 
			 * algorithm being set to "in the clear".
			 */
			challenge_response->response_item.
							number_of_response_data_members = 0;
			challenge_response->response_item.
							response_data_list = NULL;
		
			/* 
			 * Retrieve the API GCCPassword from the CPassword object.  The
			 * CPassword object must be locked before getting the data.
			 */
			if (m_pInternalResponse->challenge_response_item.
					password->LockPasswordData () == GCC_NO_ERROR)
			{
				return_value = m_pInternalResponse->challenge_response_item.
						password->GetPasswordData (&(challenge_response->
						response_item.password_string));
			}
			else
			{
				ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error locking CPassword"));
				return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else if (m_pInternalResponse->challenge_response_item.response_data_list != NULL)
		{
			/*
			 * Set the password string to NULL to avoid any confusion at the 
			 * application.  This should match up with the algorithm set to
			 * non-standard.
			 */
			challenge_response->response_item.password_string = NULL;
			
			/*
			 * Retrieve the API challenge data from the CUserDataListContainer 
			 * object.  The	call to GetUserDataList also returns the 
			 * number of user data members.  The CUserDataListContainer object
			 * must be locked before getting the data in order to 
			 * determine how much memory to allocate to hold the data.
			 */
			user_data_length = m_pInternalResponse->challenge_response_item.
					response_data_list->LockUserDataList ();

    		DBG_SAVE_FILE_LINE
			m_pUserDataMemory = new BYTE[user_data_length];
			if (m_pUserDataMemory != NULL)
			{
				/*
				 * Retrieve the actual pointer to memory from the Memory
				 * object and save it in the internal user data memory.
				 */
				m_pInternalResponse->challenge_response_item.response_data_list->
						GetUserDataList (
								&challenge_response->response_item.
										number_of_response_data_members,
								&challenge_response->response_item.
										response_data_list,
								m_pUserDataMemory);
			}
			else
			{
				ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error allocating memory"));
				return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error saving response item"));
			return_value = GCC_ALLOCATION_FAILURE;
		}
	}

	return (return_value);
}

/*
 *	GCCError	GetChallengeRequestPDU (
 *					PChallengeRequest					challenge_request);
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine converts internal challenge request data to "PDU" form.
 *
 *	Formal Parameters:
 *		challenge_request		(i)	The PDU structure to fill in with the
 *										challenge request data.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PARAMETER			-	The algorithm type was not set
 *												properly.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::GetChallengeRequestPDU(PChallengeRequest challenge_request)
{
	GCCError					return_value = GCC_NO_ERROR;
	PSetOfChallengeItems		new_set_of_challenge_items;
	PSetOfChallengeItems		old_set_of_challenge_items;
	DWORD						number_of_items;
	PChallengeItemInfo			internal_challenge_item_ptr;

	/*
	 * Fill in the challenge tag.
	 */
	challenge_request->challenge_tag = m_pInternalRequest->challenge_tag;

	/*
	 * Initialize the set pointers to NULL in order to detect the first time
	 * through the iterator loop.
	 */
	challenge_request->set_of_challenge_items = NULL;
    old_set_of_challenge_items = NULL;

	/*
	 * Retrieve the number of challenge items in the internal list.
	 */
	number_of_items = m_pInternalRequest->ChallengeItemList.GetCount();

	if (number_of_items > 0)
	{
		PChallengeItemInfo		lpChItmInfo;
		/*
		 * Iterate through the internal list of challenge items, creating a
		 * new "PDU" SetOfChallengeItems for each and filling it in.
		 */
		m_pInternalRequest->ChallengeItemList.Reset();
		while (NULL != (lpChItmInfo = m_pInternalRequest->ChallengeItemList.Iterate()))
		{
			DBG_SAVE_FILE_LINE
			new_set_of_challenge_items = new SetOfChallengeItems;

			/*
			 * If an allocation failure occurs, call the routine which will
			 * iterate through the list freeing any data which had been
			 * allocated.
			 */
			if (new_set_of_challenge_items == NULL)
			{
				ERROR_OUT(("CPassword::GetChallengeRequestPDU: Allocation error, cleaning up"));
				return_value = GCC_ALLOCATION_FAILURE;
				FreeChallengeRequestPDU ();
				break;
			}

			/*
			 * The first time through, set the PDU structure pointer equal
			 * to the first SetOfChallengeItems created.  On subsequent loops,
			 * set the structure's "next" pointer equal to the new structure.
			 */
			if (challenge_request->set_of_challenge_items == NULL)
			{
				challenge_request->set_of_challenge_items = 
						new_set_of_challenge_items;
			}
			else
			{
				if(old_set_of_challenge_items != NULL)
				{
					old_set_of_challenge_items->next = new_set_of_challenge_items;
				}
			}
	
			/*
			 * Save the newly created set and initialize the new "next" 
			 * pointer to NULL in case this is the last time through the loop.
			 */
			old_set_of_challenge_items = new_set_of_challenge_items;
			new_set_of_challenge_items->next = NULL;

			/*
			 * Retrieve the ChallengeItemInfo structure from the Rogue 
			 * Wave list and fill in the "PDU" challenge item structure from 
			 * the internal	challenge item structure.
			 */
			internal_challenge_item_ptr = lpChItmInfo;

			return_value = ConvertInternalChallengeItemToPDU (
										internal_challenge_item_ptr,
										&new_set_of_challenge_items->value);
			 
			/*
			 * Cleanup if an error has occurred.
			 */
			if (return_value != GCC_NO_ERROR)
			{
				FreeChallengeRequestPDU ();
			}
		}
	}
	else
	{
		ERROR_OUT(("CPassword::GetChallengeRequestPDU: Error no items"));
	}
		
	return (return_value);
}

/*
 *	GCCError	ConvertInternalChallengeItemToPDU(
 *					PChallengeItemInfo				internal_challenge_item,
 *					PChallengeItem					pdu_challenge_item)
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine converts an internal ChallengeItemInfo structure into
 *		the "PDU" form of a ChallengeItem structure.
 *
 *	Formal Parameters:
 *		internal_challenge_item		(i)	The internal challenge item to convert.
 *		pdu_challenge_item			(o) The	output PDU form of the challenge
 *											item.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PARAMETER			-	The algorithm type was not set
 *												properly.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertInternalChallengeItemToPDU(
					PChallengeItemInfo				internal_challenge_item,
					PChallengeItem					pdu_challenge_item)
{
	GCCError		return_value = GCC_NO_ERROR;

	/*
	 * First convert the algorithm.
	 */
	if (internal_challenge_item->algorithm.algorithm_type == 
												GCC_IN_THE_CLEAR_ALGORITHM)
	{
		pdu_challenge_item->response_algorithm.choice = 
				ALGORITHM_CLEAR_PASSWORD_CHOSEN;
	}
	else if (internal_challenge_item->algorithm.algorithm_type == 
												GCC_NON_STANDARD_ALGORITHM)
	{
		pdu_challenge_item->response_algorithm.choice = 
				NON_STANDARD_ALGORITHM_CHOSEN;

		/*
		 * Retrieve the "PDU" object key data from the internal CObjectKeyContainer
		 * object.
		 */
		if (internal_challenge_item->algorithm.object_key->
				GetObjectKeyDataPDU (
						&pdu_challenge_item->response_algorithm.u.
						non_standard_algorithm.key) == GCC_NO_ERROR)
		{
			/*
			 * Retrieve the non-standard parameter data from the internal
			 * algorithm octet string.
			 */
			pdu_challenge_item->response_algorithm.u.non_standard_algorithm.data.value = 
						internal_challenge_item->algorithm.poszOctetString->value;

			pdu_challenge_item->response_algorithm.u.non_standard_algorithm.data.length = 
						internal_challenge_item->algorithm.poszOctetString->length;
		}
		else
		{
			ERROR_OUT(("CPassword::ConvertInternalChallengeItemToPDU: Error getting ObjKeyData"));
			return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		ERROR_OUT(("CPassword::ConvertInternalChallengeItemToPDU: Error bad algorithm type"));
		return_value = GCC_INVALID_PARAMETER;
	}

	/*
	 * Now retrieve the set of user data.
	 */
	if (return_value == GCC_NO_ERROR)
	{
		return_value = internal_challenge_item->challenge_data_list->
				GetUserDataPDU (&pdu_challenge_item->set_of_challenge_data);
	}
		
	return (return_value);
}

/*
 *	GCCError	GetChallengeResponsePDU (
 *					PChallengeResponse					challenge_response);
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine converts internal challenge response data to "PDU" form.
 *
 *	Formal Parameters:
 *		challenge_response		(i)	The PDU structure to fill in with the
 *										challenge response data.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			- 	The form of the password is not 
 *												valid.
 *		GCC_INVALID_PARAMETER			-	The algorithm type was not set
 *												properly.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::GetChallengeResponsePDU(PChallengeResponse challenge_response)
{
	GCCError	return_value = GCC_NO_ERROR;

	/*
	 * Fill in the challenge tag.
	 */
	challenge_response->challenge_tag = m_pInternalResponse->challenge_tag;

	/*
	 * Fill in the response algorithm.
	 */
	if (m_pInternalResponse->algorithm.algorithm_type ==
													GCC_IN_THE_CLEAR_ALGORITHM)
	{
		challenge_response->response_algorithm.choice = 
				ALGORITHM_CLEAR_PASSWORD_CHOSEN;
	
		/*
		 * Now convert the challenge response item.  The challenge response item
		 * will consist of either a password string or a set of user data.
		 */
		if (m_pInternalResponse->challenge_response_item.password != NULL)
		{
			/*
			 * If the password string exists, set the "PDU" choice and retrieve
			 * the password selector data from the internal CPassword object.
			 */
			challenge_response->response_item.choice = PASSWORD_STRING_CHOSEN;

			return_value= m_pInternalResponse->challenge_response_item.password->
					GetPasswordSelectorPDU (&challenge_response->response_item.
					u.password_string);
		}
		else
			return_value = GCC_INVALID_PASSWORD;
	}
	else if (m_pInternalResponse->algorithm.algorithm_type ==
													GCC_NON_STANDARD_ALGORITHM)
	{
		challenge_response->response_algorithm.choice = 
				NON_STANDARD_ALGORITHM_CHOSEN;
		
		/*
		 * Retrieve the "PDU" object key data from the internal CObjectKeyContainer
		 * object.
		 */
		if (m_pInternalResponse->algorithm.object_key->
				GetObjectKeyDataPDU (
						&challenge_response->response_algorithm.u.
						non_standard_algorithm.key) == GCC_NO_ERROR)
		{
			/*
			 * Retrieve the non-standard parameter data from the internal
			 * algorithm octet string.
			 */
			challenge_response->response_algorithm.u.non_standard_algorithm.data.value = 
						m_pInternalResponse->algorithm.poszOctetString->value;

			challenge_response->response_algorithm.u.non_standard_algorithm.data.length = 
						m_pInternalResponse->algorithm.poszOctetString->length;

			if (m_pInternalResponse->challenge_response_item.response_data_list != NULL)
			{
				/*
				 * If the response data list exists, set the "PDU" choice and
				 * retrieve the response data from the internal 
				 * CUserDataListContainer object.
				 */
				challenge_response->response_item.choice = 
						SET_OF_RESPONSE_DATA_CHOSEN;

				return_value = m_pInternalResponse->challenge_response_item.
						response_data_list->GetUserDataPDU (
								&challenge_response->response_item.u.
								set_of_response_data);
			}
			else
				return_value = GCC_INVALID_PASSWORD;
		}
		else
		{
			return_value = GCC_ALLOCATION_FAILURE;
			ERROR_OUT(("CPassword::GetChallengeResponsePDU: Error getting ObjKeyData"));
		}
	}
	else
	{
		ERROR_OUT(("CPassword::GetChallengeResponsePDU: Error bad algorithm type"));
		return_value = GCC_INVALID_PARAMETER;
	}

	return (return_value);
}

/*
 *	void	FreeChallengeRequestPDU ();
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to free any "PDU" data allocated for the
 *		challenge request structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CPassword::FreeChallengeRequestPDU(void)
{
	PSetOfChallengeItems	set_of_challenge_items;
	PSetOfChallengeItems	next_set_of_challenge_items;
	PChallengeItemInfo		challenge_item_ptr;
	PChallengeRequest		challenge_request;

	/*
	 * Retrieve the challenge request pointer from the internally maintained
	 * PasswordChallengeRequestResponse structure and delete each set of
	 * challenge items which was created.
	 */
	challenge_request = &m_ChallengeResponsePDU.u.challenge_request_response.
			challenge_request;

	if (challenge_request != NULL)
	{
		if (challenge_request->set_of_challenge_items == NULL)
		{
			ERROR_OUT(("CPassword::FreeChallengeRequestPDU: NULL ptr passed"));
		}
		else
		{
			set_of_challenge_items = challenge_request->set_of_challenge_items;

			while (1)
			{
				if (set_of_challenge_items == NULL)
					break;

				next_set_of_challenge_items = set_of_challenge_items->next;

				delete set_of_challenge_items;

				set_of_challenge_items = next_set_of_challenge_items;
			}
		}
	}
	else
	{
		WARNING_OUT(("CPassword::FreeChallengeRequestPDU: NULL pointer passed"));
	}

	/*
	 * Loop through the internal list of challenge items, freeing the data 
	 * associated with each challenge item structure contained in the list.
	 */
	m_pInternalRequest->ChallengeItemList.Reset();
	while (NULL != (challenge_item_ptr = m_pInternalRequest->ChallengeItemList.Iterate()))
	{
		/*
		 * Retrieve the ChallengeItemInfo structure from the Rogue 
		 * Wave list and use the CUserDataListContainer object contained in the
		 * structure to free the PDU user data.  Also use the CObjectKeyContainer
		 * object contained in the algorithm structure to free the PDU
		 * data associated with the object key.
		 */
		if (challenge_item_ptr != NULL)
		{
			if (challenge_item_ptr->algorithm.object_key != NULL)
			{
				challenge_item_ptr->algorithm.object_key->FreeObjectKeyDataPDU();
			}
			if (challenge_item_ptr->challenge_data_list != NULL)
			{
				challenge_item_ptr->challenge_data_list->FreeUserDataListPDU();
			}
		}
	}
}

/*
 *	void	FreeChallengeResponsePDU ();
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to free any "PDU" data allocated for the
 *		challenge response structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CPassword::FreeChallengeResponsePDU(void)
{
	PChallengeResponse		challenge_response;

	/*
	 * Retrieve the challenge response pointer from the internally maintained
	 * PasswordChallengeRequestResponse structure.  If it is not equal to NULL
	 * then we know PDU response data has been allocated which must be freed.
	 */
	challenge_response = &m_ChallengeResponsePDU.u.challenge_request_response.
			challenge_response;

	if ((challenge_response != NULL) && (m_pInternalResponse != NULL))
	{
		if (m_pInternalResponse->algorithm.object_key != NULL)
			m_pInternalResponse->algorithm.object_key->FreeObjectKeyDataPDU ();

		if (m_pInternalResponse->challenge_response_item.password != NULL)
		{
			m_pInternalResponse->challenge_response_item.
					password->FreePasswordChallengeResponsePDU ();
		}
			
		if (m_pInternalResponse->challenge_response_item.
				response_data_list != NULL)
		{
			m_pInternalResponse->challenge_response_item.
					response_data_list->FreeUserDataListPDU ();
		}	
	}
}

/*
 *	void	FreeAPIPasswordData ();
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to free any data allocated by this container to
 * 		hold "API" data.  
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CPassword::FreeAPIPasswordData(void)
{
	PGCCChallengeItem			challenge_item_ptr;
	PChallengeItemInfo			challenge_item_info_ptr;
	PChallengeItemMemoryInfo	challenge_item_memory_info;
	USHORT						i;

	/*
	 * Delete any "API" memory associated with the challenge request if
	 * it exists.
	 */
	if (m_pChallengeResponse->u.challenge_request_response.
			challenge_request != NULL)
	{
		for (i=0; i<m_pChallengeResponse->u.
				challenge_request_response.challenge_request->
				number_of_challenge_items; i++)
		{
			challenge_item_ptr = m_pChallengeResponse->u.
					challenge_request_response.challenge_request->
					challenge_item_list[i];

			if (challenge_item_ptr != NULL)
			{
				/*
				 * Delete the non-standard algorithm memory.
				 */
				delete challenge_item_ptr->response_algorithm.non_standard_algorithm;
				delete challenge_item_ptr;
			}	
		}

		delete m_pChallengeResponse->u.challenge_request_response.
				challenge_request;
	}
		
	/*
	 * Unlock any memory locked for the challenge request information.
	 */
	if (m_pInternalRequest != NULL)
	{
		/*
		 * Set up an iterator in order to loop through the list of challenge
		 * items, freeing up any allocated memory.
		 */
		m_pInternalRequest->ChallengeItemList.Reset();
		while (NULL != (challenge_item_info_ptr = m_pInternalRequest->ChallengeItemList.Iterate()))
		{
			/*
			 * Unlock any memory being referenced in the ChallengeItemInfo 
			 * structure.
			 */
			if (challenge_item_info_ptr->algorithm.object_key != NULL)
			{
				challenge_item_info_ptr->algorithm.object_key->
						UnLockObjectKeyData ();
			}

			if (challenge_item_info_ptr->challenge_data_list != NULL)
			{
				challenge_item_info_ptr->challenge_data_list->
						UnLockUserDataList ();
			}
		}
	}

	/*
	 * Call the Memory Manager to free the memory allocated to hold the 
	 * challenge request data.
	 */
	while (NULL != (challenge_item_memory_info = m_ChallengeItemMemoryList.Get()))
	{
		delete challenge_item_memory_info->user_data_list_memory;
		delete challenge_item_memory_info->object_key_memory;
		delete challenge_item_memory_info;
	}

	/*
	 * Delete any memory associated with the challenge response if
	 * it exists.
	 */
	if (m_pChallengeResponse->u.challenge_request_response.
			challenge_response != NULL)
	{
		/*
		 * Delete any memory associated with the non-standard algorithm and
		 * then delete the challenge response structure.
		 */
		delete m_pChallengeResponse->u.challenge_request_response.
					challenge_response->response_algorithm.non_standard_algorithm;

		delete m_pChallengeResponse->u.challenge_request_response.
				challenge_response;	
	}

	/*
	 * Unlock any memory allocated for the challenge response information.
	 */
	if (m_pInternalResponse != NULL)
	{
		if (m_pInternalResponse->algorithm.object_key != NULL)
		{
			m_pInternalResponse->algorithm.object_key->UnLockObjectKeyData();
		}

		if (m_pInternalResponse->challenge_response_item.password != NULL)
		{
			m_pInternalResponse->challenge_response_item.password->
					UnLockPasswordData ();
		}

		if (m_pInternalResponse->challenge_response_item.
				response_data_list != NULL)
		{
			m_pInternalResponse->challenge_response_item.response_data_list->
					UnLockUserDataList ();
		}
	}

	/*
	 * Call the Memory Manager to free the memory allocated to hold the 
	 * challenge response data.
	 */
	delete m_pUserDataMemory;
	m_pUserDataMemory = NULL;

	delete m_pObjectKeyMemory;
	m_pObjectKeyMemory = NULL;

	/*
	 * Call the Memory Manager to free the memory allocated to hold the 
	 * challenge request challenge item pointers.
	 */
	delete m_pChallengeItemListMemory;
	m_pChallengeItemListMemory = NULL;

	/*
	 * Delete the challenge password structure and set the pointer to NULL.
	 */
	delete m_pChallengeResponse;
	m_pChallengeResponse = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\netaddr.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	netaddr.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the CNetAddrListContainer Class.  This
 *		class manages the data associated with a network address.  Network
 *		addresses can be one of three types: aggregated channel, transport
 *		connection, or non-standard.  A variety of structures, objects, and
 *		Rogue Wave containers are used to buffer the network address data
 *		internally.
 *
 *	Protected Instance Variables:
 *		m_NetAddrItemList
 *			List of structures used to hold the network address data internally.
 *		m_pSetOfNetAddrPDU
 *			Storage for the "PDU" form of the network address list.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" network address structures.
 *		m_fValidNetAddrPDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" network address list.
 *
 *	Private Member Functions:
 *		StoreNetworkAddressList
 *			This routine is used to store the network address data passed in as
 *			"API" data in the internal structures.
 *		ConvertPDUDataToInternal	
 *			This routine is used to store the network address data passed in as
 *			"PDU" data in the internal structures.
 * 		ConvertNetworkAddressInfoToPDU
 *			This routine is used to convert the network address info structures
 *			maintained internally into the "PDU" form which is a 
 *			SetOfNetworkAddresses.
 *		ConvertTransferModesToInternal
 *			This routine is used to convert the PDU network address transfer 
 *			modes structure into the internal form where the structure is saved
 *			as a GCCTranferModes structure.
 *		ConvertHighLayerCompatibilityToInternal
 *			This routine is used to convert the PDU network address high layer
 *			compatibility structure into the internal form where the structure
 *			is saved as a GCCHighLayerCompatibility structure.
 *		ConvertTransferModesToPDU
 *			This routine is used to convert the API network address transfer
 *			modes structure into the PDU form which is a TranferModes structure.
 *		ConvertHighLayerCompatibilityToPDU
 *			This routine is used to convert the API network address high layer
 *			compatibility structure into the PDU form which is a 
 *			HighLayerCompatibility structure.
 *		IsDialingStringValid
 *			This routine is used to ensure that the values held within a
 *			dialing string do not violate the imposed ASN.1 constraints.
 *		IsCharacterStringValid
 *			This routine is used to ensure that the values held within a
 *			character string do not violate the imposed ASN.1 constraints.
 *		IsExtraDialingStringValid
 *			This routine is used to ensure that the values held within an
 *			extra dialing string do not violate the imposed ASN.1 constraints.
 *
 *	Caveats:
 *		This container stores much of the network address information internally
 *		using an "API" GCCNetworkAddress structure.  Any data referenced by
 *		pointers in this structure is stored in some other container.
 *		Therefore, the pointers held within the internal "API" structure are
 *		not valid and must not be accessed.
 *
 *	Author:
 *		blp/jbo
 */
#include <stdio.h>

#include "ms_util.h"
#include "netaddr.h"

/*
 * These macros are used to define the size constraints of an "nsap" address.
 */
#define		MINIMUM_NSAP_ADDRESS_SIZE		1
#define		MAXIMUM_NSAP_ADDRESS_SIZE		20

/*
 * These macros are used to verify that a network address has a valid number
 * of network address entities.
 */
#define		MINIMUM_NUMBER_OF_ADDRESSES		1
#define		MAXIMUM_NUMBER_OF_ADDRESSES		64

/*
 * These macros are used to define the size constraints of an extra dialing
 * string.
 */
#define		MINIMUM_EXTRA_DIALING_STRING_SIZE		1
#define		MAXIMUM_EXTRA_DIALING_STRING_SIZE		255



NET_ADDR::NET_ADDR(void)
:
    pszSubAddress(NULL),
    pwszExtraDialing(NULL),
    high_layer_compatibility(NULL),
    poszTransportSelector(NULL),
    poszNonStandardParam(NULL),
	object_key(NULL)
{
}


NET_ADDR::~NET_ADDR(void)
{
    switch (network_address.network_address_type)
    {
    case GCC_AGGREGATED_CHANNEL_ADDRESS:
		delete pszSubAddress;
		delete pwszExtraDialing;
		delete high_layer_compatibility;
        break;
    case GCC_TRANSPORT_CONNECTION_ADDRESS:
		delete poszTransportSelector;
        break;
    case GCC_NONSTANDARD_NETWORK_ADDRESS:
		delete poszNonStandardParam;
		if (NULL != object_key)
        {
            object_key->Release();
        }
        break;
    default:
        ERROR_OUT(("NET_ADDR::~NET_ADDR: unknown addr type=%u", (UINT) network_address.network_address_type));
        break;
	}
}


/*
 *	CNetAddrListContainer()
 *
 *	Public Function Description:
 * 		This constructor is used when creating a CNetAddrListContainer object with
 *		the "API" form of network address, GCCNetworkAddress.
 */
CNetAddrListContainer::
CNetAddrListContainer(UINT                 number_of_network_addresses,
                      PGCCNetworkAddress    *network_address_list,
                      PGCCError             return_value )  
:
    CRefCount(MAKE_STAMP_ID('N','t','A','L')),
    m_pSetOfNetAddrPDU(NULL),
    m_fValidNetAddrPDU(FALSE),
    m_cbDataSize(0)
{
	/*
	 * Initialize the instance variables.  The m_NetAddrItemList which
	 * will hold the network address data internally will be filled in by the
	 * call to StoreNetworkAddressList.
	 */

	/*
	 * Check to make sure a valid number of network addresses exist.
	 */
	if ((number_of_network_addresses < MINIMUM_NUMBER_OF_ADDRESSES)
			|| (number_of_network_addresses > MAXIMUM_NUMBER_OF_ADDRESSES))
	{
		ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: ERROR Invalid number of network addresses, %u", (UINT) number_of_network_addresses));
		*return_value = GCC_BAD_NETWORK_ADDRESS;
	}
	/*
	 * Check to make sure that the list pointer is valid.
	 */
	else if (network_address_list == NULL)
	{
		ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: ERROR NULL address list"));
		*return_value = GCC_BAD_NETWORK_ADDRESS;
	}
	/*
	 * Save the network address(es) in the internal structures.
	 */
	else
	{
		*return_value = StoreNetworkAddressList(number_of_network_addresses,
												network_address_list);
	}
}

/*
 *	CNetAddrListContainer()
 *
 *	Public Function Description:
 * 		This constructor is used when creating a CNetAddrListContainer object with
 *		the "PDU" form of network address, SetOfNetworkAddresses.
 */
CNetAddrListContainer::
CNetAddrListContainer(PSetOfNetworkAddresses    network_address_list, 
                      PGCCError                 return_value )
:
    CRefCount(MAKE_STAMP_ID('N','t','A','L')),
    m_pSetOfNetAddrPDU(NULL),
    m_fValidNetAddrPDU(FALSE),
    m_cbDataSize(0)
{
	PSetOfNetworkAddresses		network_address_ptr;

	/*
	 * Initialize the instance variables.  The m_NetAddrItemList which
	 * will hold the network address data internally will be filled in by the
	 * calls to ConvertPDUDataToInternal.
	 */

	*return_value = GCC_NO_ERROR;
	network_address_ptr = network_address_list;

	/*
	 * Loop through the set of network addresses, saving each in an internal
	 * NET_ADDR structure and saving those structures in the internal
	 * list.
	 */
	if (network_address_list != NULL)
	{
		while (1)
		{
			/*
			 * Convert each "PDU" network address into the internal form.  Note
			 * that object ID validation is not performed on data received as
			 * a PDU.  If a bad object ID comes in on the wire, this will be
			 * flagged as an allocation failure.
			 */
			if (ConvertPDUDataToInternal (network_address_ptr) != GCC_NO_ERROR)
			{
				ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: Error converting PDU data to internal"));
				*return_value = GCC_ALLOCATION_FAILURE;
				break;
			}
			else
            {
				network_address_ptr = network_address_ptr->next;
            }

			if (network_address_ptr == NULL)
				break;
		}
	}
}

/*
 *	CNetAddrListContainer()
 *
 *	Public Function Description:
 *		This is the copy constructor used to create a new CNetAddrListContainer
 *		object from an existing CNetAddrListContainer object. 
 */
CNetAddrListContainer::
CNetAddrListContainer(CNetAddrListContainer *address_list,
                      PGCCError		        pRetCode)
:
    CRefCount(MAKE_STAMP_ID('N','t','A','L')),
    m_pSetOfNetAddrPDU(NULL),
    m_fValidNetAddrPDU(FALSE),
    m_cbDataSize(0)
{
	NET_ADDR    				    *network_address_info;
	NET_ADDR	    			    *lpNetAddrInfo;
	GCCNetworkAddressType			network_address_type;
	GCCError						rc;

	/*
	 * Set up an iterator for the internal list of network addresses.
	 */
	address_list->m_NetAddrItemList.Reset();

    /*
	 * Copy each NET_ADDR structure contained in the 
	 * CNetAddrListContainer object to	be copied.
	 */
	while (NULL != (lpNetAddrInfo = address_list->m_NetAddrItemList.Iterate()))
	{
		/*
		 * Create a new NET_ADDR structure to hold each element of the
		 * new CNetAddrListContainer object.  Report an error if creation of this 
		 * structure fails.
		 */
		DBG_SAVE_FILE_LINE
		if (NULL == (network_address_info = new NET_ADDR))
		{
			ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: can't create NET_ADDR"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}

        /*
		 * First copy the GCCNetworkAddress structure contained in the
		 * internal NET_ADDR structure.  This copies all data
		 * except that referenced by pointers in the structure.
		 */
		network_address_info->network_address = lpNetAddrInfo->network_address;

		/*
		 * Next copy any data embedded in the network address that would 
		 * not have been copied in the above operation (typically pointers 
		 * to strings).
		 */

		/*
		 * This variable is used for abbreviation.
		 */
		network_address_type = lpNetAddrInfo->network_address.network_address_type;

		/*
		 * The network address is the "Aggregated" type.
		 */
        switch (network_address_type)
        {
        case GCC_AGGREGATED_CHANNEL_ADDRESS:
			/*
			 * If a sub-address string exists, store it in a Rogue Wave
			 * container.  Set the  structure pointer to NULL if one does 
			 * not exist.
			 */
			if (lpNetAddrInfo->pszSubAddress != NULL)
			{
				if (NULL == (network_address_info->pszSubAddress =
									::My_strdupA(lpNetAddrInfo->pszSubAddress)))
				{
					ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: can't create sub address"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
            {
				network_address_info->pszSubAddress = NULL;
            }
					
			/*
			 * If an extra dialing string exists, store it in a Unicode
			 * String object.  Set the  structure pointer to NULL if one 
			 * does not exist.
			 */
			if (lpNetAddrInfo->pwszExtraDialing != NULL)
			{
				if (NULL == (network_address_info->pwszExtraDialing =
									::My_strdupW(lpNetAddrInfo->pwszExtraDialing)))
				{
					ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: can't creating extra dialing string"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
            {
				network_address_info->pwszExtraDialing = NULL;
            }

			/*
			 * If a higher layer compatibility structure exists, store it 
			 * in a GCCHighLayerCompatibility structure.  Set the structure
			 * pointer to NULL if one does not exist.
			 */
			if (lpNetAddrInfo->high_layer_compatibility != NULL)
			{
				DBG_SAVE_FILE_LINE
				network_address_info->high_layer_compatibility = new GCCHighLayerCompatibility;
				if (network_address_info->high_layer_compatibility != NULL)
				{
					/*
					 * Copy the high layer compatibility data to the
					 * new structure.
					 */
					*network_address_info->high_layer_compatibility =  
							*(lpNetAddrInfo->high_layer_compatibility);
				}
				else
				{
					ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: Error creating new GCCHighLayerCompat"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
            {
				network_address_info->high_layer_compatibility = NULL;
            }
            break;

		/*
		 * The network address is the "Transport Connection" type.
		 */
        case GCC_TRANSPORT_CONNECTION_ADDRESS:
			/*
			 * If a transport selector exists, store it in a Rogue Wave 
			 * container.  Otherwise, set the structure pointer to NULL.
			 */
			if (lpNetAddrInfo->poszTransportSelector != NULL)
			{
				if (NULL == (network_address_info->poszTransportSelector =
									::My_strdupO(lpNetAddrInfo->poszTransportSelector)))
				{
					ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: can't create transport selector"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
            {
				network_address_info->poszTransportSelector = NULL;
            }
            break;

		/*
		 * The network address is the "Non-Standard" type.
		 */
        case GCC_NONSTANDARD_NETWORK_ADDRESS:
			/*
			 * First store the non-standard parameter data in a Rogue Wave
			 * container.
			 */
			if (NULL == (network_address_info->poszNonStandardParam =
								::My_strdupO(lpNetAddrInfo->poszNonStandardParam)))
			{
				ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: can't create non-standard param"));
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}

			/*
			 * Next store the object key internally in an CObjectKeyContainer
			 * object.  Note that there is no need to report the error
			 * "BAD_NETWORK_ADDRESS" here since the object key data 
			 * would have been validated when the original network address
			 * was created.
			 */
			DBG_SAVE_FILE_LINE
			network_address_info->object_key = new CObjectKeyContainer(lpNetAddrInfo->object_key, &rc);
			if ((network_address_info->object_key == NULL) || (rc != GCC_NO_ERROR))
			{
				ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: Error creating new CObjectKeyContainer"));
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
            break;

		/*
		 * The network address is of unknown type.  This should never be
		 * encountered so flag it as an allocation failure.
		 */
        default:
			ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: Invalid type received as PDU"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}

		/*
		 * Go ahead and insert the pointer to the NET_ADDR
		 * structure into the internal Rogue Wave list.
		 */
		m_NetAddrItemList.Append(network_address_info);
	}

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete network_address_info;
    }

    *pRetCode = rc;
}


/*
 *	~CNetAddrListContainer()
 *
 *	Public Function Description:
 *		The destructor is used to free up any memory allocated during the life
 * 		of the object.
 */
CNetAddrListContainer::
~CNetAddrListContainer(void)
{
	
	/*
	 * Free any data allocated to hold "PDU" information.
	 */
	if (m_fValidNetAddrPDU)
    {
		FreeNetworkAddressListPDU();
    }

	/*
	 * Free any data allocated for the internal list of "info" structures.
	 */
	NET_ADDR *pNetAddrInfo;
	m_NetAddrItemList.Reset();
	while (NULL != (pNetAddrInfo = m_NetAddrItemList.Iterate()))
	{
		delete pNetAddrInfo;
	}
}


/*
 *	LockNetworkAddressList ()
 *
 *	Public Function Description:
 *		This routine is called to "Lock" the network address data in "API" form.
 *		The amount of memory required to hold the "API" data which is referenced
 *		by, but not included in the GCCNetworkAddress structure, will be
 *		returned. 
 *
 */
UINT CNetAddrListContainer::
LockNetworkAddressList(void)
{  
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data.  Otherwise, just increment the 
	 * lock count.
	 */
	if (Lock() == 1)
	{
    	PGCCNetworkAddress		network_address;
	    NET_ADDR    		    *lpNetAddrInfo;

		/*
		 * Set aside memory to hold the pointers to the GCCNetworkAddress
		 * structures as well as the structures themselves.  The "sizeof" the 
		 * structure must be rounded to an even four-byte boundary.
		 */
		m_cbDataSize = m_NetAddrItemList.GetCount() * 
				( sizeof(PGCCNetworkAddress) + ROUNDTOBOUNDARY(sizeof(GCCNetworkAddress)) );

		/*
		 * Loop through the list of network addresses, adding up the space
		 * requirements of each address.
		 */
		m_NetAddrItemList.Reset();
	 	while (NULL != (lpNetAddrInfo = m_NetAddrItemList.Iterate()))
		{
			/*
			 * Use a local variable to keep from having to access the Rogue Wave
			 * iterator repeatedly.
			 */
			network_address = &lpNetAddrInfo->network_address;

			/*
			 * Check to see what type of network address exists.
			 */
			switch (network_address->network_address_type)
            {
            case GCC_AGGREGATED_CHANNEL_ADDRESS:
				/*
				 * Add the length of the sub address string if it exists.
				 */
				if (lpNetAddrInfo->pszSubAddress != NULL)
				{
					m_cbDataSize += ROUNDTOBOUNDARY(::lstrlenA(lpNetAddrInfo->pszSubAddress) + 1);
				}

				/*
				 * Add the size of the GCCExtraDialingString structure as well
				 * as the length of the extra dialing string if it exists.
				 */
				if (lpNetAddrInfo->pwszExtraDialing != NULL)
				{
					m_cbDataSize += ROUNDTOBOUNDARY(sizeof(GCCExtraDialingString)) +
                                    ROUNDTOBOUNDARY((::lstrlenW(lpNetAddrInfo->pwszExtraDialing) + 1) * sizeof(WCHAR));
				}

				/*
				 * Add the size of the high layer compatibility structure if
				 * it exists.
				 */
				if (lpNetAddrInfo->high_layer_compatibility != NULL)
				{
					m_cbDataSize += ROUNDTOBOUNDARY(sizeof(GCCHighLayerCompatibility));
				}
                break;

            case GCC_TRANSPORT_CONNECTION_ADDRESS:
				/*
				 * Add the size of the OSTR structure as well as the
				 * length of the octet string if it exists.
				 */
				if (lpNetAddrInfo->poszTransportSelector != NULL)
				{
					m_cbDataSize += ROUNDTOBOUNDARY(sizeof(OSTR)) +
					                ROUNDTOBOUNDARY(lpNetAddrInfo->poszTransportSelector->length); 
				}
                break;

            case GCC_NONSTANDARD_NETWORK_ADDRESS:
				/*
				 * Lock the object key in the non-standard parameter in order to
				 * determine the amount of memory needed to hold its data.
				 */
				m_cbDataSize += lpNetAddrInfo->object_key->LockObjectKeyData ();

				/*
				 * Add the space needed to hold the octet string data for the 
				 * non-standard parameter.
				 */
				m_cbDataSize += ROUNDTOBOUNDARY(lpNetAddrInfo->poszNonStandardParam->length);
                break;
			}
		}
	}

	return m_cbDataSize;
} 


/*
 *	GetNetworkAddressListAPI ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the list of network addresses in "API"
 *		form.
 */
UINT CNetAddrListContainer::
GetNetworkAddressListAPI(UINT				*	number_of_network_addresses,
                         PGCCNetworkAddress	**	network_address_list,
                         LPBYTE					memory)
{
	UINT					cbDataSizeToRet = 0;
	UINT					data_length = 0;
	UINT					network_address_counter = 0;
	PGCCNetworkAddress		network_address_ptr;
	NET_ADDR    		    *address_info;
	PGCCNetworkAddress		*address_array;

	/*
	 * If the user data has been locked, fill in the output parameters and
	 * the data referenced by the pointers.  Otherwise, report that the object
	 * has yet to be locked into the "API" form.
	 */ 
	if (GetLockCount() > 0)
	{
		// NET_ADDR	*lpNetAddrInfo;

		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.
		 */
		cbDataSizeToRet = m_cbDataSize;

		/*
		 * Fill in the number of network address entities and save a pointer to 
		 * the memory location passed in.  This is where the pointers to the 
		 * GCCNetworkAddress structures will be written.  The actual structures 
		 * will be written into memory immediately following the list of 
		 * pointers.
		 */
		*number_of_network_addresses = (UINT) m_NetAddrItemList.GetCount();

		*network_address_list = (PGCCNetworkAddress *)memory;
		address_array = *network_address_list;

		/*
		 * Save the amount of memory needed to hold the list of pointers as
		 * well as the actual network address structures.
		 */
		data_length = m_NetAddrItemList.GetCount() * sizeof(PGCCNetworkAddress);

		/*
		 * Move the memory pointer past the list of network address pointers.  
		 * This is where the first network address structure will be written.
		 */
		memory += data_length;

		/*
		 * Iterate through the internal list of NET_ADDR structures,
		 * building "API" GCCNetworkAddress structures in memory.
		 */
		m_NetAddrItemList.Reset();
		while (NULL != (address_info = m_NetAddrItemList.Iterate()))
		{
			/*
			 * Save the pointer to the network address structure in the list 
			 * of pointers.
			 */
			network_address_ptr = (PGCCNetworkAddress)memory;
			address_array[network_address_counter++] = network_address_ptr;

			/*
			 * Move the memory pointer past the network address structure.  
			 * This is where the network address data will be written.
			 */
			memory += ROUNDTOBOUNDARY(sizeof(GCCNetworkAddress));

			/*
			 * Check to see what type of network address this is and fill in 
			 * the user data structure.  Here the address is the aggregated
			 * channel type.
			 */
			switch (address_info->network_address.network_address_type)
            {
            case GCC_AGGREGATED_CHANNEL_ADDRESS:
				network_address_ptr->network_address_type =	GCC_AGGREGATED_CHANNEL_ADDRESS;

				/*
				 * Copy the transfer modes.
				 */
				network_address_ptr->u.aggregated_channel_address.transfer_modes = 
					address_info->network_address.u.aggregated_channel_address.transfer_modes;

				/*
				 * Copy the international number.
				 */
                ::lstrcpyA(network_address_ptr->u.aggregated_channel_address.international_number,
						   address_info->network_address.u.aggregated_channel_address.international_number);

				/*
				 * If the sub address string exists, set the sub address string
				 * pointer and write the data into memory.  Otherwise, set the
				 * "API" pointer to NULL.
				 */
				if (address_info->pszSubAddress != NULL)
				{
					network_address_ptr->u.aggregated_channel_address.sub_address_string = 
																(GCCCharacterString)memory;

					/*
					 * Now copy the sub-address string data from the internal 
					 * Rogue Wave string into memory.
					 */		
                    ::lstrcpyA((LPSTR) memory, address_info->pszSubAddress);

					/*
					 * Move the memory pointer past the sub-address string data.
					 * This is where the GCCExtraDialingString structure will be
					 * written.
					 */
					memory += ROUNDTOBOUNDARY(::lstrlenA(address_info->pszSubAddress) + 1);
				}
				else
				{
					/*
					 * No sub-address was present so set the pointer to NULL.
					 */
					network_address_ptr->u.aggregated_channel_address.sub_address_string = NULL;
				}

				/*
				 * If the extra dialing string exists, set the extra dialing
				 * string pointer and write the data into memory.  Otherwise,
				 * set the "API" pointer to NULL.
				 */
				if (address_info->pwszExtraDialing != NULL)
				{
					network_address_ptr->u.aggregated_channel_address.extra_dialing_string = 
							(PGCCExtraDialingString)memory;

					/*
					 * Move the memory pointer past the GCCExtraDialingString
					 * structure.  This is where the extra dialing string data 
					 * will	be written.
					 */
					memory += ROUNDTOBOUNDARY(sizeof(GCCExtraDialingString));

					UINT cchExtraDialing = ::lstrlenW(address_info->pwszExtraDialing);
					network_address_ptr->u.aggregated_channel_address.extra_dialing_string->length = 
							(USHORT) cchExtraDialing;

					network_address_ptr->u.aggregated_channel_address.extra_dialing_string->value = 
																		(LPWSTR)memory;

					/*
					 * Now copy the hex string data from the internal Unicode 
					 * String into the allocated memory.
					 */
					//
					// LONCHANC: The size does not include null terminator in the original code.
					// could this be a bug???
					//
					::CopyMemory(memory, address_info->pwszExtraDialing, cchExtraDialing * sizeof(WCHAR));

					/*
					 * Move the memory pointer past the extra dialing string 
					 * data.  This is where the high layer compatibility 
					 * structure will be written.
					 */
					memory += ROUNDTOBOUNDARY(cchExtraDialing * sizeof(WCHAR));
				}
				else
				{
					/*
					 * No extra dialing string was present so set the pointer
					 * to NULL.
					 */
					network_address_ptr->u.aggregated_channel_address.extra_dialing_string = NULL;
				}

				/*
				 * If the high layer compatibility structure exists, set the 
				 * pointer and write the data into memory.  Otherwise, set
				 * the "API" pointer to NULL.
				 */
				if (address_info->high_layer_compatibility != NULL)
				{
					network_address_ptr->u.aggregated_channel_address.high_layer_compatibility = 
							(PGCCHighLayerCompatibility)memory;

					*network_address_ptr->u.aggregated_channel_address.high_layer_compatibility =
                            *(address_info->high_layer_compatibility);

					/*
					 * Move the memory pointer past the high layer 
					 * compatibility structure.
					 */
					memory += ROUNDTOBOUNDARY(sizeof(GCCHighLayerCompatibility));
				}
				else
				{
					/*
					 * No high layer compatibility structure was present so 
					 * set the pointer to NULL.
					 */
					network_address_ptr->u.aggregated_channel_address.
							high_layer_compatibility = NULL;
				}
                break;

			/*
			 * The network address is a transport connection type.
			 */
            case GCC_TRANSPORT_CONNECTION_ADDRESS:
				network_address_ptr->network_address_type = GCC_TRANSPORT_CONNECTION_ADDRESS;

				/*
				 * Now copy the nsap address.
				 */		
                ::CopyMemory(network_address_ptr->u.transport_connection_address.nsap_address.value, 
							address_info->network_address.u.transport_connection_address.nsap_address.value, 
							address_info->network_address.u.transport_connection_address.nsap_address.length);

                network_address_ptr->u.transport_connection_address.nsap_address.length =
                            address_info->network_address.u.transport_connection_address.nsap_address.length; 

				/*
				 * If a transport selector exists, set the transport selector 
				 * pointer and write the data into memory.  Otherwise, set the
				 * "API" pointer to NULL.
				 */
				if (address_info->poszTransportSelector != NULL)
				{
					network_address_ptr->u.transport_connection_address.transport_selector = (LPOSTR) memory;

					/*
					 * Move the memory pointer past the OSTR 
					 * structure.  This is where the actual string data will 
					 * be written.
					 */
					memory += ROUNDTOBOUNDARY(sizeof(OSTR));

					network_address_ptr->u.transport_connection_address.
							transport_selector->value = (LPBYTE)memory;

					network_address_ptr->u.transport_connection_address.
							transport_selector->length =
								address_info->poszTransportSelector->length;

					/*
					 * Now copy the transport selector string data from the 
					 * internal Rogue Wave string into memory.
					 */		
					::CopyMemory(memory, address_info->poszTransportSelector->value,
								address_info->poszTransportSelector->length);

					/*
					 * Move the memory pointer past the transport selector
					 * string data.
					 */
					memory += ROUNDTOBOUNDARY(address_info->poszTransportSelector->length);
				}
				else
				{
					network_address_ptr->u.transport_connection_address.transport_selector = NULL;
				}
                break;

			/*
			 * The network address is a non-standard type.
			 */
            case GCC_NONSTANDARD_NETWORK_ADDRESS:
				network_address_ptr->network_address_type = GCC_NONSTANDARD_NETWORK_ADDRESS;

				/*
				 * Check to make sure both elements of the non-standard address
				 * exist in the internal structure.
				 */
				if ((address_info->poszNonStandardParam == NULL) ||
						(address_info->object_key == NULL))
				{
					ERROR_OUT(("CNetAddrListContainer::GetNetworkAddressListAPI: Bad internal pointer"));
					cbDataSizeToRet = 0;
				}
				else
				{
					data_length = address_info->object_key->
							GetGCCObjectKeyData( &network_address_ptr->u.
							non_standard_network_address.object_key, 
							memory);

					/*
					 * Move the memory pointer past the object key data.  This 
					 * is where the octet string data will be written.
					 */
					memory += data_length;

					network_address_ptr->u.non_standard_network_address.parameter_data.value = 
							memory;

					/*
					 * Write the octet string data into memory and set the octet 
					 * string structure pointer and length.
					 */
					network_address_ptr->u.non_standard_network_address.parameter_data.length = 
								(USHORT) address_info->poszNonStandardParam->length;

					/*
					 * Now copy the octet string data from the internal Rogue 
					 * Wave string into the object key structure held in memory.
					 */		
					::CopyMemory(memory, address_info->poszNonStandardParam->value,
								address_info->poszNonStandardParam->length);

					/*
					 * Move the memory pointer past the octet string data.
					 */
					memory += ROUNDTOBOUNDARY(address_info->poszNonStandardParam->length);
				}
                break;

            default:
                ERROR_OUT(("CNetAddrListContainer::GetNetworkAddressListAPI: Error Bad type."));
                break;
            } // switch
        } // while
	}
	else
	{
    	*network_address_list = NULL;
		*number_of_network_addresses = 0;
		ERROR_OUT(("CNetAddrListContainer::GetNetworkAddressListAPI: Error Data Not Locked"));
	}

	return cbDataSizeToRet;
}

/*
 *	UnLockNetworkAddressList ()
 *
 *	Public Function Description:
 *		This routine unlocks any memory which has been locked for the "API" 
 *		form of the network address list.  If the "Free" flag has been set then
 * 		the CNetAddrListContainer object will be destroyed.
 *
 */
void CNetAddrListContainer::
UnLockNetworkAddressList(void)
{
	/*
	 * If the lock count has reached zero, this object is "unlocked" so do
	 * some cleanup.
	 */
	if (Unlock(FALSE) == 0)
	{
		/*
		 * Unlock any memory locked for the CObjectKeyContainer objects in the
		 * internal NET_ADDR structures.
		 */
		NET_ADDR *pNetAddrInfo;
		m_NetAddrItemList.Reset();
		while (NULL != (pNetAddrInfo = m_NetAddrItemList.Iterate()))
		{
			if (pNetAddrInfo->object_key != NULL)
			{
				pNetAddrInfo->object_key->UnLockObjectKeyData();
			}
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}
   

/*
 *	GetNetworkAddressListPDU ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the network address list in "PDU" form.
 */
GCCError CNetAddrListContainer::
GetNetworkAddressListPDU(PSetOfNetworkAddresses *set_of_network_addresses)
{
	GCCError					rc = GCC_NO_ERROR;
	PSetOfNetworkAddresses		new_pdu_network_address_ptr;
	PSetOfNetworkAddresses		old_pdu_network_address_ptr = NULL;

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidNetAddrPDU == FALSE)
	{
		m_fValidNetAddrPDU = TRUE;

		/*
		 * Initialize the output parameter to NULL so that the first time
		 * through it will be set equal to the first new set of network address
		 * data created in the iterator loop.
		 */
		m_pSetOfNetAddrPDU = NULL;
		
		/*
		 * Iterate through the list of NET_ADDR structures, 
		 * converting each into "PDU" form and saving the pointers in the 
		 * linked list of "SetsOfNetworkAddresses".
		 */
		NET_ADDR *pNetAddrInfo;
		m_NetAddrItemList.Reset();
		while (NULL != (pNetAddrInfo = m_NetAddrItemList.Iterate()))
		{
			/*
			 * If an allocation failure occurs, call the routine which will
			 * iterate through the list freeing any data which had been
			 * allocated.
			 */
			DBG_SAVE_FILE_LINE
			new_pdu_network_address_ptr = new SetOfNetworkAddresses;
			if (new_pdu_network_address_ptr == NULL)
			{
				ERROR_OUT(("CNetAddrListContainer::GetNetworkAddressListPDU: Allocation error, cleaning up"));
				rc = GCC_ALLOCATION_FAILURE;
				FreeNetworkAddressListPDU ();
				break;
			}

			/*
			 * The first time through, set the PDU structure pointer equal
			 * to the first SetOfNetworkAddresses created.  On subsequent loops,
			 * set the structure's "next" pointer equal to the new structure.
			 */
			if (m_pSetOfNetAddrPDU == NULL)
            {
				m_pSetOfNetAddrPDU = new_pdu_network_address_ptr;
            }
			else
            {
				old_pdu_network_address_ptr->next = new_pdu_network_address_ptr;
            }

			old_pdu_network_address_ptr = new_pdu_network_address_ptr;

			/*
			 * Initialize the new "next" pointer to NULL.
			 */
			new_pdu_network_address_ptr->next = NULL;

			/*
			 * Call the routine to actually convert the network address.
			 */
			if (ConvertNetworkAddressInfoToPDU(pNetAddrInfo, new_pdu_network_address_ptr) != GCC_NO_ERROR)
			{
				ERROR_OUT(("CNetAddrListContainer::GetNetworkAddressListPDU: can't create NET_ADDR to PDU"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*set_of_network_addresses = m_pSetOfNetAddrPDU;

	return rc;
}


/*
 *	FreeNetworkAddressListPDU ()
 *
 *	Public Function Description:
 *		This routine is used to free the memory allocated for the "PDU" form
 *		of the network address list.
 */
GCCError CNetAddrListContainer::
FreeNetworkAddressListPDU(void)
{
	GCCError						rc = GCC_NO_ERROR;
	PSetOfNetworkAddresses			pdu_network_address_set;
	PSetOfNetworkAddresses			next_pdu_network_address_set;

	if (m_fValidNetAddrPDU)
	{
		m_fValidNetAddrPDU = FALSE;

		pdu_network_address_set = m_pSetOfNetAddrPDU;

		/*
		 * Loop through the list, freeing the network address data associated 
		 * with each structure contained in the list. The only data allocated
		 * for the PDU which is not held in the internal info structure list
		 * is done by the CObjectKeyContainer object.  Those objects are told to free
		 * that data in the iterator loop below.
		 */
		while (pdu_network_address_set != NULL)
		{
			next_pdu_network_address_set = pdu_network_address_set->next;
			delete pdu_network_address_set;
			pdu_network_address_set = next_pdu_network_address_set;
		}

		/*
		 * Free any PDU memory allocated by the internal CObjectKeyContainer object.
		 */
		NET_ADDR *pNetAddrInfo;
		m_NetAddrItemList.Reset();
		while (NULL != (pNetAddrInfo = m_NetAddrItemList.Iterate()))
		{
			if (pNetAddrInfo->object_key != NULL)
            {
				pNetAddrInfo->object_key->FreeObjectKeyDataPDU();
            }
		}
	}
	else
	{
		ERROR_OUT(("NetAddressList::FreeUserDataListPDU: PDU Data not allocated"));
		rc = GCC_BAD_NETWORK_ADDRESS;
	}

	return (rc);
}

/*
 *	GCCError	StoreNetworkAddressList (	
 *						UINT					number_of_network_addresses,
 *						PGCCNetworkAddress 	*	local_network_address_list);
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to store the network address data passed in as
 *		"API" data in the internal structures.
 *
 *	Formal Parameters:
 *		number_of_network_addresses	(i)	Number of addresses in "API" list.
 *		local_network_address_list	(i) List of "API" addresses.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_NETWORK_ADDRESS			-	Invalid network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad "choice" field for address
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CNetAddrListContainer::
StoreNetworkAddressList(UINT					number_of_network_addresses,
						PGCCNetworkAddress 	*	local_network_address_list)
{
	GCCError						rc;
	NET_ADDR				        *network_address_info;
	PGCCNetworkAddress				network_address;
	UINT							i;
	
	/*
	 * For each network address in the list, create a new "info" structure to 
	 * buffer the data internally.  Fill in the structure and save it in the
	 * Rogue Wave list.
	 */
	for (i = 0; i < number_of_network_addresses; i++)
	{
		DBG_SAVE_FILE_LINE
		if (NULL == (network_address_info = new NET_ADDR))
		{
            ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: can't create NET_ADDR"));
			rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
        }

		/*
		 * This variable is used for abbreviation.
		 */
		network_address = &network_address_info->network_address;
		
		/*
		 * Copy all the network address data into the network address
		 * structure that is part of the network address info structure.
		 */									
		*network_address = *local_network_address_list[i];
		
		/*
		 * This section of the code deals with any data embedded in the
		 * network address that would not have been copied in the above
		 * operation (typically pointers to strings).
		 */
		switch (network_address->network_address_type)
        {
        case GCC_AGGREGATED_CHANNEL_ADDRESS:
			/*
			 * Check to make sure the international number dialing string
			 * does not violate the imposed ASN.1 constraints.
			 */
			if (! IsDialingStringValid(local_network_address_list[i]->u.aggregated_channel_address.international_number))
			{
				ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: Invalid international number"));
				rc = GCC_BAD_NETWORK_ADDRESS;
				goto MyExit;
			}

			/*
			 * If a sub-address string exists, store it in a Rogue Wave
			 * container.  Set the  structure pointer to NULL if one does 
			 * not exist.
			 */
			if (local_network_address_list[i]->u.aggregated_channel_address.sub_address_string != NULL)
			{
				/*
				 * Check to make sure the sub address string does not 
				 * violate the imposed ASN.1 constraints.
				 */
				if (! IsCharacterStringValid(local_network_address_list[i]->u.aggregated_channel_address.sub_address_string))
				{
					ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: Invalid sub address string"));
					rc = GCC_BAD_NETWORK_ADDRESS;
					goto MyExit;
				}

				/*			
				 * Create a  string to hold the sub address.
				 */
				if (NULL == (network_address_info->pszSubAddress = ::My_strdupA(
								(LPSTR) local_network_address_list[i]->u.aggregated_channel_address.sub_address_string)))
				{
					ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: can't creating new sub address string"));
					rc = GCC_ALLOCATION_FAILURE;
                    goto MyExit;
				}
			}
			else
            {
				network_address_info->pszSubAddress = NULL;
            }

            /*
			 * If an extra dialing string exists, store it in a Unicode
			 * String object.  Set the  structure pointer to NULL if one 
			 * does not exist.
			 */
			if (local_network_address_list[i]->u.aggregated_channel_address.extra_dialing_string != NULL)
			{
				/*
				 * Check to make sure the extra dialing string does not 
				 * violate the imposed ASN.1 constraints.
				 */
				if (! IsExtraDialingStringValid(local_network_address_list[i]->u.aggregated_channel_address.extra_dialing_string))
				{
					ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: Invalid extra dialing string"));
					rc = GCC_BAD_NETWORK_ADDRESS;
					goto MyExit;
				}

				if (NULL == (network_address_info->pwszExtraDialing = ::My_strdupW2(
								local_network_address_list[i]->u.aggregated_channel_address.extra_dialing_string->length,
								local_network_address_list[i]->u.aggregated_channel_address.extra_dialing_string->value)))
				{
					ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: Error creating extra dialing string"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
            {
				network_address_info->pwszExtraDialing = NULL;
            }

			/*
			 * If a higher layer compatibility structure exists, store it 
			 * in a GCCHighLayerCompatibility structure.  Set the structure
			 * pointer to NULL if one does not exist.
			 */
			if (local_network_address_list[i]->u.aggregated_channel_address.high_layer_compatibility != NULL)
			{
				DBG_SAVE_FILE_LINE
				network_address_info->high_layer_compatibility = new GCCHighLayerCompatibility;
				if (network_address_info->high_layer_compatibility != NULL)
				{
					/*
					 * Copy the high layer compatibility data to the
					 * new structure.
					 */
					*network_address_info->high_layer_compatibility =  
							*(local_network_address_list[i]->u.aggregated_channel_address.high_layer_compatibility);
				}
				else
				{
					ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: Error creating new GCCHighLayerCompatibility"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
            {
				network_address_info->high_layer_compatibility = NULL;
            }
            break;

        case GCC_TRANSPORT_CONNECTION_ADDRESS:
			/*
			 * Check to make sure the length of the nsap address is within
			 * the allowable range.
			 */
			if ((local_network_address_list[i]->u.transport_connection_address.nsap_address.length < MINIMUM_NSAP_ADDRESS_SIZE)
                ||
				(local_network_address_list[i]->u.transport_connection_address.nsap_address.length > MAXIMUM_NSAP_ADDRESS_SIZE))
			{
				ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: Invalid nsap address"));
				rc = GCC_BAD_NETWORK_ADDRESS;
				goto MyExit;
			}

			/*
			 * If a transport selector exists, store it in a Rogue Wave 
			 * string.  Otherwise, set the structure pointer to NULL.
			 */
			if (local_network_address_list[i]->u.transport_connection_address.transport_selector != NULL)
			{
				/*			
				 * Create a Rogue Wave string to hold the transport
				 * selector string.
				 */
				if (NULL == (network_address_info->poszTransportSelector = ::My_strdupO2(
								local_network_address_list[i]->u.transport_connection_address.transport_selector->value,
						 		local_network_address_list[i]->u.transport_connection_address.transport_selector->length)))
				{
					ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: can't create transport selector"));
					rc = GCC_ALLOCATION_FAILURE;
                    goto MyExit;
				}
			}
			else
            {
				network_address_info->poszTransportSelector = NULL;
            }
            break;

        case GCC_NONSTANDARD_NETWORK_ADDRESS:
			/*			
			 * Create a Rogue Wave string to hold the non-standard
			 * parameter octet string.
			 */
			if (NULL == (network_address_info->poszNonStandardParam = ::My_strdupO2(
								local_network_address_list[i]->u.non_standard_network_address.parameter_data.value,
					 			local_network_address_list[i]->u.non_standard_network_address.parameter_data.length)))
			{
				ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: can't create non-standard param"));
				rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
			}
		
			/*
			 * Next store the object key internally in an CObjectKeyContainer
			 * object.
			 */
			DBG_SAVE_FILE_LINE
			network_address_info->object_key = new CObjectKeyContainer(
					&local_network_address_list[i]->u.non_standard_network_address.object_key,
					&rc);
			if (network_address_info->object_key == NULL || rc != GCC_NO_ERROR)
			{
				ERROR_OUT(("CNetAddrListContainer::StoreNetAddrList: Error creating new CObjectKeyContainer"));
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
            break;

        default:
			ERROR_OUT(("CNetAddrListContainer::StoreNetAddrList: bad network address type=%u", (UINT) network_address->network_address_type));
			rc = GCC_BAD_NETWORK_ADDRESS_TYPE;
			goto MyExit;
		}

		/*
		 * If all data was properly saved, insert the "info" structure
		 * pointer into the Rogue Wave list.
		 */
		m_NetAddrItemList.Append(network_address_info);
	} // for

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete network_address_info;
    }

    return rc;
}

/*
 *	GCCError	ConvertPDUDataToInternal (	
 *						PSetOfNetworkAddresses			network_address_ptr)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to store the network address data passed in as
 *		"PDU" data in the internal structures.
 *
 *	Formal Parameters:
 *		network_address_ptr	(i) 	"PDU" address list structure.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CNetAddrListContainer::
ConvertPDUDataToInternal(PSetOfNetworkAddresses network_address_ptr)
{
	GCCError					rc;
	GCCError					error_value;
	NET_ADDR    			    *network_address_info_ptr;
	PGCCNetworkAddress			copy_network_address;
	PNetworkAddress				pdu_network_address;

	/*
	 * Create a new info structure to hold the data internally.
	 */
	DBG_SAVE_FILE_LINE
	if (NULL == (network_address_info_ptr = new NET_ADDR))
	{
		ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: can't create NET_ADDR"));
		rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
	}

    /*
	 * Use these variables for clarity and brevity.
	 */
	copy_network_address = &network_address_info_ptr->network_address;
	pdu_network_address = &network_address_ptr->value; 

	/*
	 * Check to see what type of network address exists and save the data
	 * in the internal structures.
	 */
	switch (pdu_network_address->choice)
    {
    case AGGREGATED_CHANNEL_CHOSEN:
		copy_network_address->network_address_type = GCC_AGGREGATED_CHANNEL_ADDRESS;

		/*
		 * Save the tranfer modes structure.
		 */
		ConvertTransferModesToInternal(
				&pdu_network_address->u.aggregated_channel.transfer_modes,
				&copy_network_address->u.aggregated_channel_address.transfer_modes);
						
		/*
		 * Save the international number.
		 */
        ::lstrcpyA(copy_network_address->u.aggregated_channel_address.international_number,
					pdu_network_address->u.aggregated_channel.international_number);
						
		/*
		 * Save the sub address string (if it exists) in the Rogue Wave
		 * buffer contained in the network info structure.  Otherwise, set
		 * the structure pointer to NULL.
		 */
		if (pdu_network_address->u.aggregated_channel.bit_mask & SUB_ADDRESS_PRESENT)
		{
			/*			
			 * Create a Rogue Wave string to hold the sub address string.
			 */
			if (NULL == (network_address_info_ptr->pszSubAddress = ::My_strdupA(
								pdu_network_address->u.aggregated_channel.sub_address)))
			{
				ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: can't create sub address string"));
				rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
			}
		}
		else
		{
			/*
			 * The sub address string is not present so set the internal
			 * info structure pointer to NULL.
			 */
			network_address_info_ptr->pszSubAddress = NULL;
		}

		/*
		 * Next save the extra dialing string if one exists.
		 */
		if (pdu_network_address->u.aggregated_channel.bit_mask & EXTRA_DIALING_STRING_PRESENT)
		{
			if (NULL == (network_address_info_ptr->pwszExtraDialing = ::My_strdupW2(
							pdu_network_address->u.aggregated_channel.extra_dialing_string.length,
							pdu_network_address->u.aggregated_channel.extra_dialing_string.value)))
			{
				ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: Error creating extra dialing string"));
				rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
			}
		}
		else
		{
			/*
			 * The extra dialing string is not present so set the internal
			 * info structure pointer to NULL.
			 */
			network_address_info_ptr->pwszExtraDialing = NULL;
		}

		/*
		 * Save the high layer compatibility structure if it is present.
		 */
		if (pdu_network_address->u.aggregated_channel.bit_mask & HIGH_LAYER_COMPATIBILITY_PRESENT)
		{
			DBG_SAVE_FILE_LINE
			network_address_info_ptr->high_layer_compatibility = new GCCHighLayerCompatibility;
			if (network_address_info_ptr->high_layer_compatibility != NULL)
			{
				/*
				 * Copy the high layer compatibility data to the
				 * new structure.
				 */
				ConvertHighLayerCompatibilityToInternal(
						&pdu_network_address->u.aggregated_channel.high_layer_compatibility,
						network_address_info_ptr->high_layer_compatibility);
			}
			else
			{
				ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: Error creating new GCCHighLayerCompatibility"));
				rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
			}
		}
		else
		{
			/*
			 * The high layer compatibility structure is not present so set
			 * the internal	info structure pointer to NULL.
			 */
			network_address_info_ptr->high_layer_compatibility = NULL;
		}
        break;

    /*
     * Save the transport connection address.
     */
    case TRANSPORT_CONNECTION_CHOSEN:
	    copy_network_address->network_address_type = GCC_TRANSPORT_CONNECTION_ADDRESS;

	    /*
	     * Save the nsap address by copying the length and then the string.
	     */
	    copy_network_address->u.transport_connection_address.nsap_address.length =
                pdu_network_address->u.transport_connection.nsap_address.length;

        ::lstrcpyA((LPSTR)copy_network_address->u.transport_connection_address.nsap_address.value,
				    (LPSTR)pdu_network_address->u.transport_connection.nsap_address.value);
	    /*
	     * Save the transport selector if one exists.
	     */
	    if (pdu_network_address->u.transport_connection.bit_mask & TRANSPORT_SELECTOR_PRESENT)
	    {
		    /*			
		     * Create a Rogue Wave string to hold the transport
		     * selector string.
		     */
		    if (NULL == (network_address_info_ptr->poszTransportSelector = ::My_strdupO2(
						    pdu_network_address->u.transport_connection.transport_selector.value,
					 	    pdu_network_address->u.transport_connection.transport_selector.length)))
		    {
			    ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: can't create transport selector"));
			    rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
		    }
	    }
	    else
	    {
		    /*
		     * The transport selector is not present so set the internal
		     * info structure pointer to NULL.
		     */
		    network_address_info_ptr->poszTransportSelector = NULL;
	    }
        break;

    /*
     * Save the non standard address.
     */
    case ADDRESS_NON_STANDARD_CHOSEN:
	    copy_network_address->network_address_type = GCC_NONSTANDARD_NETWORK_ADDRESS;

	    /*			
	     * Create a Rogue Wave string to hold the non-standard
	     * parameter octet string.
	     */
	    if (NULL == (network_address_info_ptr->poszNonStandardParam = ::My_strdupO2(
						    pdu_network_address->u.address_non_standard.data.value,
				 		    pdu_network_address->u.address_non_standard.data.length)))
	    {
		    ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: can't create non-standard param"));
		    rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
	    }

	    /*
	     * Next store the object key internally in an CObjectKeyContainer
	     * object.
	     */
	    DBG_SAVE_FILE_LINE
	    network_address_info_ptr->object_key = new CObjectKeyContainer(
			    &pdu_network_address->u.address_non_standard.key,
			    &error_value);
	    if ((network_address_info_ptr->object_key == NULL) ||
			    (error_value != GCC_NO_ERROR))
	    {
		    ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: Error creating new CObjectKeyContainer"));
		    rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
	    }
        break;

    default:
        ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: Error bad network address type"));
        rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
    } // switch

    /*
	 * Go ahead and save the pointer to the info structure in the 
	 * internal Rogue Wave list.
	 */
	m_NetAddrItemList.Append(network_address_info_ptr);

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete network_address_info_ptr;
    }

	return rc;
}

/*
 * GCCError		ConvertNetworkAddressInfoToPDU (
 *						NET_ADDR    			    *network_address_info_ptr,
 *						PSetOfNetworkAddresses		network_address_pdu_ptr)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to convert the network address info structures
 *		maintained internally into the "PDU" form which is a 
 *		SetOfNetworkAddresses.
 *
 *	Formal Parameters:
 *		network_address_info_ptr	(i) Internal network address structure.
 *		network_address_pdu_ptr		(o) PDU network address structure to fill in
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error converting the network address
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CNetAddrListContainer::
ConvertNetworkAddressInfoToPDU(NET_ADDR    			    *network_address_info_ptr,
                               PSetOfNetworkAddresses   network_address_pdu_ptr)
{
	GCCError				rc = GCC_NO_ERROR;
	PGCCNetworkAddress		api_ptr;
	PNetworkAddress			pdu_ptr;

	/*
	 * This variable will point to the "API" network address structure held in 
	 * the internal info structure.  It is used for brevity.
	 */
	api_ptr = &network_address_info_ptr->network_address;

	/*
	 * This variable will point to the "PDU" network address structure held in 
	 * the "SetOfNetworkAddresses" structure.  It is used for brevity.
	 */
	pdu_ptr = &network_address_pdu_ptr->value;

	/*
	 * Check to see what type of network address exists.  Fill in the
	 * appropriate form of the network address PDU structure.
	 */
	switch (api_ptr->network_address_type)
    {
    case GCC_AGGREGATED_CHANNEL_ADDRESS:
		/*
		 * Fill in the aggregated channel address PDU structure.
		 */
		pdu_ptr->choice = AGGREGATED_CHANNEL_CHOSEN;

		pdu_ptr->u.aggregated_channel.bit_mask = 0;

		/*
		 * Convert the structure holding the transfer modes into PDU form.
		 */
		ConvertTransferModesToPDU(&api_ptr->u.aggregated_channel_address.transfer_modes,
								  &pdu_ptr->u.aggregated_channel.transfer_modes);
		/*
		 * Copy the international number string.
		 */
        ::lstrcpyA(pdu_ptr->u.aggregated_channel.international_number,
				   api_ptr->u.aggregated_channel_address.international_number);

		/*
		 * Copy the sub-address string if it is present.  Set the bit mask in
		 * the PDU structure indicating that a sub-address string is present.
		 */
		if (network_address_info_ptr->pszSubAddress != NULL)
		{
			pdu_ptr->u.aggregated_channel.bit_mask |= SUB_ADDRESS_PRESENT;
            ::lstrcpyA((LPSTR) pdu_ptr->u.aggregated_channel.sub_address, 
					   network_address_info_ptr->pszSubAddress);
		}

		/* 
		 * Copy the extra dialing string if it is present.  Set the bit mask in
		 * the PDU structure indicating that an extra dialing string is present.
		 */
		if (network_address_info_ptr->pwszExtraDialing != NULL)
		{
			pdu_ptr->u.aggregated_channel.bit_mask |= EXTRA_DIALING_STRING_PRESENT;

			pdu_ptr->u.aggregated_channel.extra_dialing_string.value = 
					network_address_info_ptr->pwszExtraDialing;

			pdu_ptr->u.aggregated_channel.extra_dialing_string.length = 
					::lstrlenW(network_address_info_ptr->pwszExtraDialing);
		}

		/*
		 * Convert the structure holding the high layer compatibilities into 
		 * PDU form, if it is present.  Set the bit mask in	the PDU structure 
		 * indicating that a high layer compatibility structure is present.
		 */
		if (network_address_info_ptr->high_layer_compatibility != NULL)
		{
			pdu_ptr->u.aggregated_channel.bit_mask |= HIGH_LAYER_COMPATIBILITY_PRESENT;

			ConvertHighLayerCompatibilityToPDU(
					network_address_info_ptr->high_layer_compatibility,
					&pdu_ptr->u.aggregated_channel.high_layer_compatibility);
		}
        break;

    case GCC_TRANSPORT_CONNECTION_ADDRESS:
		/*
		 * Fill in the transport connection address PDU structure.
		 */
		pdu_ptr->choice = TRANSPORT_CONNECTION_CHOSEN;

		/*
		 * Copy the nsap_address.
		 */
		pdu_ptr->u.transport_connection.nsap_address.length = 
				api_ptr->u.transport_connection_address.nsap_address.length;
				
        ::lstrcpyA((LPSTR)pdu_ptr->u.transport_connection.nsap_address.value,
				   (LPSTR)api_ptr->u.transport_connection_address.nsap_address.value);
				
		/*
		 * Copy the transport selector if it is present.  Set the bit mask in
		 * the PDU structure indicating that a transport selector is present.
		 */
		if (network_address_info_ptr->poszTransportSelector != NULL)
		{
			pdu_ptr->u.transport_connection.bit_mask |= TRANSPORT_SELECTOR_PRESENT;

			pdu_ptr->u.transport_connection.transport_selector.length =
					network_address_info_ptr->poszTransportSelector->length;

			pdu_ptr->u.transport_connection.transport_selector.value = 
					(LPBYTE) network_address_info_ptr->poszTransportSelector->value;
		}
        break;

    case GCC_NONSTANDARD_NETWORK_ADDRESS:
		/*
		 * Fill in the non-standard network address PDU structure.
		 */
		pdu_ptr->choice = ADDRESS_NON_STANDARD_CHOSEN;

		/*
		 * Fill in the data portion of the non-standard parameter.
		 */
		pdu_ptr->u.address_non_standard.data.length = 
				network_address_info_ptr->poszNonStandardParam->length;

        pdu_ptr->u.address_non_standard.data.value = 
				network_address_info_ptr->poszNonStandardParam->value;

		/*
		 * Now fill in the object key portion of the non-standard parameter
		 * using the CObjectKeyContainer object stored internally in the network
		 * address info structure.
		 */
		rc = network_address_info_ptr->object_key->GetObjectKeyDataPDU(&pdu_ptr->u.address_non_standard.key);
		if (rc != GCC_NO_ERROR)
		{
			ERROR_OUT(("CNetAddrListContainer::ConvertNetworkAddressInfoToPDU: Error getting object key data PDU"));
		}
        break;

    default:
        /*
		 * The constructors will check to make sure a valid network address
		 * type exists so this should never be encountered.
		 */
		ERROR_OUT(("CNetAddrListContainer::ConvertNetworkAddressInfoToPDU: Error bad network address type"));
		rc = GCC_ALLOCATION_FAILURE;
	}

	return rc;
}

/*
 *	void		ConvertTransferModesToInternal (
 *						PTransferModes				source_transfer_modes,
 *						PGCCTransferModes			copy_transfer_modes)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to convert the PDU network address transfer modes
 *		structure into the internal form where the structure is saved as a
 *		GCCTranferModes structure.
 *
 *	Formal Parameters:
 *		source_transfer_modes	(i)	Structure holding "PDU" transfer modes.
 *		copy_transfer_modes		(o) Structure to hold "API" transfer modes.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CNetAddrListContainer::
ConvertTransferModesToInternal(PTransferModes       source_transfer_modes,
                               PGCCTransferModes    copy_transfer_modes)
{
	copy_transfer_modes->speech = (BOOL) source_transfer_modes->speech;
	copy_transfer_modes->voice_band = (BOOL) source_transfer_modes->voice_band;
	copy_transfer_modes->digital_56k = (BOOL) source_transfer_modes->digital_56k;
	copy_transfer_modes->digital_64k = (BOOL) source_transfer_modes->digital_64k;
	copy_transfer_modes->digital_128k = (BOOL) source_transfer_modes->digital_128k;
	copy_transfer_modes->digital_192k = (BOOL) source_transfer_modes->digital_192k;
	copy_transfer_modes->digital_256k = (BOOL) source_transfer_modes->digital_256k;
	copy_transfer_modes->digital_320k = (BOOL) source_transfer_modes->digital_320k;
	copy_transfer_modes->digital_384k = (BOOL) source_transfer_modes->digital_384k;
	copy_transfer_modes->digital_512k = (BOOL) source_transfer_modes->digital_512k;
	copy_transfer_modes->digital_768k = (BOOL) source_transfer_modes->digital_768k;
	copy_transfer_modes->digital_1152k = (BOOL) source_transfer_modes->digital_1152k;
	copy_transfer_modes->digital_1472k = (BOOL) source_transfer_modes->digital_1472k;
	copy_transfer_modes->digital_1536k = (BOOL) source_transfer_modes->digital_1536k;
	copy_transfer_modes->digital_1920k = (BOOL) source_transfer_modes->digital_1920k;
	copy_transfer_modes->packet_mode = (BOOL) source_transfer_modes->packet_mode;
	copy_transfer_modes->frame_mode = (BOOL) source_transfer_modes->frame_mode;
	copy_transfer_modes->atm = (BOOL) source_transfer_modes->atm;
}

/*
 *	void		ConvertHighLayerCompatibilityToInternal (
 *					PHighLayerCompatibility				source_structure,
 *					PGCCHighLayerCompatibility			copy_structure)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to convert the PDU network address high layer
 *		compatibility structure into the internal form where the structure is 
 *		saved as a GCCHighLayerCompatibility structure.
 *
 *	Formal Parameters:
 *		source_structure		(i)	Structure holding "PDU" high layer 
 *										compatibilities.
 *		copy_structure			(o) Structure to hold "API" high layer 
 *										compatibilities.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CNetAddrListContainer::
ConvertHighLayerCompatibilityToInternal(PHighLayerCompatibility     source_structure,
                                        PGCCHighLayerCompatibility  copy_structure)
{
	copy_structure->telephony3kHz = (BOOL) source_structure->telephony3kHz;
	copy_structure->telephony7kHz = (BOOL) source_structure->telephony7kHz;
	copy_structure->videotelephony = (BOOL) source_structure->videotelephony;
	copy_structure->videoconference = (BOOL) source_structure->videoconference;
	copy_structure->audiographic = (BOOL) source_structure->audiographic;
	copy_structure->audiovisual = (BOOL) source_structure->audiovisual;
	copy_structure->multimedia = (BOOL) source_structure->multimedia;
}

/*
 *	void		ConvertTransferModesToPDU (
 *					PGCCTransferModes					source_transfer_modes,
 *					PTransferModes						copy_transfer_modes)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to convert the API network address transfer modes
 *		structure into the PDU form which is a TranferModes structure.
 *
 *	Formal Parameters:
 *		source_transfer_modes	(i)	Structure holding "API" transfer modes.
 *		copy_transfer_modes		(i) Structure holding "PDU" transfer modes.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CNetAddrListContainer::
ConvertTransferModesToPDU(PGCCTransferModes     source_transfer_modes,
                          PTransferModes        copy_transfer_modes)
{
	copy_transfer_modes->speech = (ASN1bool_t) source_transfer_modes->speech;
	copy_transfer_modes->voice_band = (ASN1bool_t) source_transfer_modes->voice_band;
	copy_transfer_modes->digital_56k = (ASN1bool_t) source_transfer_modes->digital_56k;
	copy_transfer_modes->digital_64k = (ASN1bool_t) source_transfer_modes->digital_64k;
	copy_transfer_modes->digital_128k = (ASN1bool_t) source_transfer_modes->digital_128k;
	copy_transfer_modes->digital_192k = (ASN1bool_t) source_transfer_modes->digital_192k;
	copy_transfer_modes->digital_256k = (ASN1bool_t) source_transfer_modes->digital_256k;
	copy_transfer_modes->digital_320k = (ASN1bool_t) source_transfer_modes->digital_320k;
	copy_transfer_modes->digital_384k = (ASN1bool_t) source_transfer_modes->digital_384k;
	copy_transfer_modes->digital_512k = (ASN1bool_t) source_transfer_modes->digital_512k;
	copy_transfer_modes->digital_768k = (ASN1bool_t) source_transfer_modes->digital_768k;
	copy_transfer_modes->digital_1152k = (ASN1bool_t) source_transfer_modes->digital_1152k;
	copy_transfer_modes->digital_1472k = (ASN1bool_t) source_transfer_modes->digital_1472k;
	copy_transfer_modes->digital_1536k = (ASN1bool_t) source_transfer_modes->digital_1536k;
	copy_transfer_modes->digital_1920k = (ASN1bool_t) source_transfer_modes->digital_1920k;
	copy_transfer_modes->packet_mode = (ASN1bool_t) source_transfer_modes->packet_mode;
	copy_transfer_modes->frame_mode = (ASN1bool_t) source_transfer_modes->frame_mode;
	copy_transfer_modes->atm = (ASN1bool_t) source_transfer_modes->atm;
}

/*
 *	void		ConvertHighLayerCompatibilityToPDU (
 *					PGCCHighLayerCompatibility				source_structure,
 *					PHighLayerCompatibility					copy_structure)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to convert the API network address high layer
 *		compatibility structure into the PDU form which is a 
 *		HighLayerCompatibility structure.
 *
 *	Formal Parameters:
 *		source_structure		(i)	Structure holding "API" high layer 
 *										compatibilities.
 *		copy_structure			(o) Structure to hold "PDU" high layer 
 *										compatibilities.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CNetAddrListContainer::
ConvertHighLayerCompatibilityToPDU(PGCCHighLayerCompatibility   source_structure,
                                   PHighLayerCompatibility      copy_structure)
{
	copy_structure->telephony3kHz = (ASN1bool_t) source_structure->telephony3kHz;
	copy_structure->telephony7kHz = (ASN1bool_t) source_structure->telephony7kHz;
	copy_structure->videotelephony = (ASN1bool_t) source_structure->videotelephony;
	copy_structure->videoconference = (ASN1bool_t) source_structure->videoconference;
	copy_structure->audiographic = (ASN1bool_t) source_structure->audiographic;
	copy_structure->audiovisual = (ASN1bool_t) source_structure->audiovisual;
	copy_structure->multimedia = (ASN1bool_t) source_structure->multimedia;
}

/*
 *	BOOL    	IsDialingStringValid ( GCCDialingString		dialing_string)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to ensure that the values held within a
 *		dialing string do not violate the imposed ASN.1 constraints.  The
 *		dialing string is constrained to be digits between 0 and 9, inclusive.
 *
 *	Formal Parameters:
 *		dialing_string		(i)	Dialing string to validate. 
 *
 *	Return Value:
 *		TRUE				- The string is valid.
 *		FALSE				- The string violates the ASN.1 constraints.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
BOOL CNetAddrListContainer::
IsDialingStringValid(GCCDialingString dialing_string)
{
	BOOL fRet = TRUE;
	
	while (*dialing_string != 0)
	{
		if ((*dialing_string < '0') || (*dialing_string > '9'))
		{
			fRet = FALSE;
			break;
		}
		dialing_string++;
	}

	return fRet;
}

/*
 *	BOOL    	IsCharacterStringValid (
 *								GCCCharacterString			character_string)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to ensure that the values held within a
 *		character string do not violate the imposed ASN.1 constraints.  The
 *		character string is constrained to be digits between 0 and 9, inclusive.
 *
 *	Formal Parameters:
 *		character_string		(i)	Character string to validate. 
 *
 *	Return Value:
 *		TRUE				- The string is valid.
 *		FALSE				- The string violates the ASN.1 constraints.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
BOOL CNetAddrListContainer::
IsCharacterStringValid(GCCCharacterString character_string)
{
	BOOL fRet = TRUE;
	
	while (*character_string != 0)
	{
		if ((*character_string < '0') || (*character_string > '9'))
		{
			fRet = FALSE;
			break;
		}
	
		character_string++;
	}
	
	return fRet;
}

/*
 *	BOOL    	IsExtraDialingStringValid (
 *							PGCCExtraDialingString		extra_dialing_string)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to ensure that the values held within an
 *		extra dialing string do not violate the imposed ASN.1 constraints.
 *
 *	Formal Parameters:
 *		extra_dialing_string		(i)	Dialing string to validate. 
 *
 *	Return Value:
 *		TRUE				- The string is valid.
 *		FALSE				- The string violates the ASN.1 constraints.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
BOOL CNetAddrListContainer::
IsExtraDialingStringValid(PGCCExtraDialingString extra_dialing_string)
{
	BOOL fRet = TRUE;

	/*
	 * Check to make sure the length of the string is within the
	 * allowable range.
	 */
	if ((extra_dialing_string->length < MINIMUM_EXTRA_DIALING_STRING_SIZE) || 
		(extra_dialing_string->length > MAXIMUM_EXTRA_DIALING_STRING_SIZE))
	{
		fRet = FALSE;
	}
    else
    {
	    /*
	     * If the length is valid, check the string values.
	     */
    	LPWSTR pwsz = extra_dialing_string->value;
		for (USHORT i = 0; i < extra_dialing_string->length; i++)
		{
			if ((*pwsz != '#') && (*pwsz != '*') && (*pwsz != ','))
			{
				if ((*pwsz < '0') || (*pwsz > '9'))
				{
					fRet = FALSE;
					break;
				}
			}
		
			pwsz++;
		}
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\pktcoder.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC | ZONE_T120_GCCNC);
/*
 *	pktcoder.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the PacketCoder class.
 *
 *	Private Instance Variables:
 *		None.
 *
 *	Private Member Functions:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		John B. O'Nan
 */

/*
 *	External Interfaces
 */

#include "pktcoder.h"


/*
 *	~PacketCoder ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is virtual destructor that does not do anything at this time.
 */
PacketCoder::~PacketCoder ()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\plgxprt.cpp ===
#include "precomp.h"
#include "plgxprt.h"

// #undef TRACE_OUT
// #define TRACE_OUT   WARNING_OUT

#define XPRT_CONN_ID_PREFIX         "XPRT"
#define XPRT_CONN_ID_PREFIX_LEN     4

static UINT s_nConnID = 0;

CPluggableTransport *g_pPluggableTransport = NULL;
BOOL                g_fWinsockDisabled = FALSE;
BOOL                g_fPluggableTransportInitialized = FALSE;
DWORD               g_dwPluggableTransportThreadID = 0;
HANDLE              g_hevtUpdatePluggableTransport = FALSE;
CRITICAL_SECTION    g_csTransport;
ILegacyTransport   *g_pLegacyTransport = NULL;
HINSTANCE           g_hlibMST123 = NULL;

BOOL EnsurePluggableTransportThread(void);


extern HWND     TCP_Window_Handle;
extern SOCKET   Listen_Socket;
extern SOCKET   Listen_Socket_Secure;
extern PTransportInterface	g_Transport;
extern UChar g_X224Header[];

extern void CloseListenSocket(void);


T120Error WINAPI T120_CreatePluggableTransport(IT120PluggableTransport **ppTransport)
{
    if (NULL != ppTransport)
    {
        *ppTransport = NULL;
        if (NULL == g_pPluggableTransport)
        {
            if (g_fPluggableTransportInitialized)
            {
                DBG_SAVE_FILE_LINE
                *ppTransport = (CPluggableTransport *) new CPluggableTransport;
                if (NULL != *ppTransport)
                {
                    if (EnsurePluggableTransportThread())
                    {
                        return T120_NO_ERROR;
                    }
                    else
                    {
                        (*ppTransport)->ReleaseInterface();
                        *ppTransport = NULL;
                    }
                }

                return T120_ALLOCATION_FAILURE;
            }

            return T120_NOT_INITIALIZED;
        }

        return T120_ALREADY_INITIALIZED;
    }

    return T120_INVALID_PARAMETER;
}



CPluggableConnection::CPluggableConnection
(
    PLUGXPRT_CALL_TYPE  eCaller,
    HANDLE              hCommLink,
    HANDLE              hevtRead,
    HANDLE              hevtWrite,
    HANDLE              hevtClose,
    PLUGXPRT_FRAMING    eFraming,
    PLUGXPRT_PARAMETERS *pParams,
    T120Error          *pRC
)
:
    CRefCount(MAKE_STAMP_ID('P','X','P','C')),
    m_eState(PLUGXPRT_UNKNOWN_STATE),
    m_eCaller(eCaller),
    m_hCommLink(hCommLink),
    m_hevtRead(hevtRead),
    m_hevtWrite(hevtWrite),
    m_hevtClose(hevtClose),
    m_eType(TRANSPORT_TYPE_PLUGGABLE_X224),
    m_pSocket(NULL),
    // Legacy tranport
    m_nLegacyLogicalHandle(0),
    // IO queue management for X.224 framing
    m_hevtPendingRead(NULL),
    m_hevtPendingWrite(NULL),
    m_fPendingReadDone(FALSE),
    m_cbPendingRead(0),
    m_pbPendingRead(NULL),
    m_cbPendingWrite(0),
    m_pbPendingWrite(NULL),
    m_OutBufQueue2(MAX_PLUGGABLE_OUT_BUF_SIZE)
{
    TransportError err;
    BOOL fCaller = (PLUGXPRT_CALLER == eCaller);

    // X.224 only
    ::ZeroMemory(&m_OverlappedRead, sizeof(m_OverlappedRead));
    ::ZeroMemory(&m_OverlappedWrite, sizeof(m_OverlappedWrite));

    // assign connection ID
    ::EnterCriticalSection(&g_csTransport);
    if (s_nConnID > 0x7FFF)
    {
        s_nConnID = 0;
    }
    m_nConnID = ++s_nConnID;
    ::LeaveCriticalSection(&g_csTransport);

    // create connection ID string
    ::CreateConnString(GetConnID(), m_szConnID);

    // do framing specific initialization
    switch (eFraming)
    {
    case FRAMING_X224:
        m_eType = TRANSPORT_TYPE_PLUGGABLE_X224;

        m_hevtPendingRead  = ::CreateEvent(NULL, TRUE, FALSE, NULL); /* manual reset */
        m_hevtPendingWrite = ::CreateEvent(NULL, TRUE, FALSE, NULL); /* manual reset */
        ASSERT(NULL != m_hevtPendingRead && NULL != m_hevtPendingWrite);
        *pRC = (NULL != m_hevtPendingRead && NULL != m_hevtPendingWrite)
                ? T120_NO_ERROR : T120_ALLOCATION_FAILURE;
        break;

    case FRAMING_LEGACY_PSTN:
        m_eType = TRANSPORT_TYPE_PLUGGABLE_PSTN;
        ASSERT(NULL != g_pLegacyTransport);

        err = g_pLegacyTransport->TCreateTransportStack(fCaller, m_hCommLink, m_hevtClose, pParams);
        ASSERT(TRANSPORT_NO_ERROR == err);

        *pRC = (TRANSPORT_NO_ERROR == err) ? T120_NO_ERROR : T120_NO_TRANSPORT_STACKS;
        break;

    default:
        ERROR_OUT(("CPluggableConnection: unknown framing %d", eFraming));
        *pRC = T120_INVALID_PARAMETER;
        break;
    }
}


CPluggableConnection::~CPluggableConnection(void)
{
    if (NULL != m_pSocket)
    {
        ::freePluggableSocket(m_pSocket);
        m_pSocket = NULL;
    }

    Shutdown();

    if (TRANSPORT_TYPE_PLUGGABLE_PSTN == m_eType)
    {
        if (NULL != g_pLegacyTransport && NULL != m_hCommLink)
        {
            g_pLegacyTransport->TCloseTransportStack(m_hCommLink);
        }
    }

    if (NULL != m_hCommLink)
    {
        ::CloseHandle(m_hCommLink);
    }

    if (NULL != m_hevtRead)
    {
        ::CloseHandle(m_hevtRead);
    }

    if (NULL != m_hevtWrite)
    {
        ::CloseHandle(m_hevtWrite);
    }

    if (NULL != m_hevtClose)
    {
        ::CloseHandle(m_hevtClose);
    }

    if (NULL != m_hevtPendingRead)
    {
        ::CloseHandle(m_hevtPendingRead);
    }

    if (NULL != m_hevtPendingWrite)
    {
        ::CloseHandle(m_hevtPendingWrite);
    }
}


ULONG CreateConnString(int nConnID, char szConnID[])
{
    return ::wsprintfA(szConnID, "%s: %u", XPRT_CONN_ID_PREFIX, nConnID);
}


UINT GetPluggableTransportConnID(LPCSTR pcszNodeAddress)
{
    UINT nConnID = 0;
    char szName[T120_CONNECTION_ID_LENGTH];

    // make sure we have a clean buffer to start with
    ::ZeroMemory(szName, sizeof(szName));

    // copy the address string
    ::lstrcpynA(szName, pcszNodeAddress, T120_CONNECTION_ID_LENGTH);

    // make sure we have the semi-colon in place
    if (':' == szName[XPRT_CONN_ID_PREFIX_LEN])
    {
        // compare the prefix string
        szName[XPRT_CONN_ID_PREFIX_LEN] = '\0';
        if (! lstrcmpA(szName, XPRT_CONN_ID_PREFIX))
        {
            LPSTR psz = &szName[XPRT_CONN_ID_PREFIX_LEN+1];

            // get a space?
            if (' ' == *psz++)
            {
                // now, have a number
                if ('0' <= *psz && *psz <= '9')
                {
                    while ('0' <= *psz && *psz <= '9')
                    {
                        nConnID = nConnID * 10 + (*psz++ - '0');
                    }
                }
            }
        }
    }

    return nConnID;
}


BOOL IsValidPluggableTransportName(LPCSTR pcszNodeAddress)
{
    return GetPluggableTransportConnID(pcszNodeAddress);
}


typedef BOOL (WINAPI *LPFN_CANCEL_IO) (HANDLE);
void CPluggableConnection::Shutdown(void)
{
    TRACE_OUT(("CPluggableConnection::Shutdown"));

    if (NULL != m_OverlappedRead.hEvent || NULL != m_OverlappedWrite.hEvent)
    {
        HINSTANCE hLib = NmLoadLibrary("kernel32.dll",TRUE);
        if (NULL != hLib)
        {
            LPFN_CANCEL_IO pfnCancelIo = (LPFN_CANCEL_IO) ::GetProcAddress(hLib, "CancelIo");
            if (NULL != pfnCancelIo)
            {
                (*pfnCancelIo)(m_hCommLink);
            }
            ::FreeLibrary(hLib);
        }

        m_OverlappedRead.hEvent = NULL;
        m_OverlappedWrite.hEvent = NULL;
    }

    delete [] m_pbPendingRead;
    m_pbPendingRead = NULL;

    LPBYTE buffer;
    while (NULL != (buffer = m_OutBufQueue2.Get()))
    {
        delete [] buffer;
    }
}


T120Error CPluggableConnection::UpdateCommLink(HANDLE hCommLink)
{
    T120Error rc;

    ::EnterCriticalSection(&g_csTransport);

    switch (m_eState)
    {
    case PLUGXPRT_UNKNOWN_STATE:
    case PLUGXPRT_DISCONNECTED:
        Shutdown();
        m_hCommLink = hCommLink;
        rc = T120_NO_ERROR;
        break;

    default:
        rc = T120_TRANSPORT_NOT_READY;
        break;
    }

    ::LeaveCriticalSection(&g_csTransport);

    return rc;
}


CPluggableTransport::CPluggableTransport(void)
:
    CRefCount(MAKE_STAMP_ID('X','P','R','T')),
    m_pfnNotify(NULL),
    m_pContext(NULL)
{
    g_pPluggableTransport = this;
    g_pLegacyTransport = NULL;
}


CPluggableTransport::~CPluggableTransport(void)
{
    ::PostThreadMessage(g_dwPluggableTransportThreadID, WM_QUIT, 0, 0);

    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    while (NULL != (p = m_PluggableConnectionList.Get()))
    {
        p->Release();
    }
    ::LeaveCriticalSection(&g_csTransport);

    if (NULL != g_pLegacyTransport)
    {
        g_pLegacyTransport->TCleanup();
        g_pLegacyTransport->ReleaseInterface();
        g_pLegacyTransport = NULL;
    }

    if (NULL != g_hlibMST123)
    {
        ::FreeLibrary(g_hlibMST123);
        g_hlibMST123 = NULL;
    }

    g_pPluggableTransport = NULL;
}


void CPluggableTransport::ReleaseInterface(void)
{
    UnAdvise();
    CRefCount::Release();
}


T120Error CPluggableTransport::CreateConnection
(
    char                szConnID[], /* out */
    PLUGXPRT_CALL_TYPE  eCaller,
    HANDLE              hCommLink,
    HANDLE              hevtRead,
    HANDLE              hevtWrite,
    HANDLE              hevtClose,
    PLUGXPRT_FRAMING    eFraming,
    PLUGXPRT_PARAMETERS *pParams
)
{
    T120Error rc;

    if (FRAMING_LEGACY_PSTN == eFraming)
    {
        if (! EnsureLegacyTransportLoaded())
        {
            return T120_NO_TRANSPORT_STACKS;
        }
    }

    if (NULL != pParams)
    {
        if (sizeof(PLUGXPRT_PARAMETERS) != pParams->cbStructSize)
        {
            return T120_INVALID_PARAMETER;
        }
    }

    DBG_SAVE_FILE_LINE
    CPluggableConnection *p;
    p = new CPluggableConnection(eCaller, hCommLink, hevtRead, hevtWrite, hevtClose,
                                 eFraming, pParams, &rc);
    if (NULL != p && T120_NO_ERROR == rc)
    {
        ::lstrcpyA(szConnID, p->GetConnString());

        ::EnterCriticalSection(&g_csTransport);
        m_PluggableConnectionList.Append(p);
        ::LeaveCriticalSection(&g_csTransport);

        TransportConnection XprtConn;
        XprtConn.eType = p->GetType();
        XprtConn.nLogicalHandle = p->GetConnID();
        PSocket pSocket = ::newPluggableSocket(XprtConn);
        p->SetSocket(pSocket);
        ASSERT(NULL != pSocket);

        // update the events list to wait for in the plugable transport thread
        ::SetEvent(g_hevtUpdatePluggableTransport);

        return T120_NO_ERROR;
    }

    if (NULL != p)
    {
        p->Release();
    }
    else
    {
        rc = T120_ALLOCATION_FAILURE;
    }

    return rc;
}


T120Error CPluggableTransport::UpdateConnection
(
    LPSTR       pszConnID,
    HANDLE      hCommLink
)
{
    BOOL fFound = FALSE;
    CPluggableConnection *p;
    T120Error rc = GCC_INVALID_TRANSPORT;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (! ::lstrcmpA(p->GetConnString(), pszConnID))
        {
            rc = p->UpdateCommLink(hCommLink);
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    // update the events list to wait for in the plugable transport thread
    ::SetEvent(g_hevtUpdatePluggableTransport);

    return rc;
}


T120Error CPluggableTransport::CloseConnection
(
    LPSTR       pszConnID
)
{
    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (! ::lstrcmpA(p->GetConnString(), pszConnID))
        {
            m_PluggableConnectionList.Remove(p);
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    // update the events list to wait for in the plugable transport thread
    ::SetEvent(g_hevtUpdatePluggableTransport);

    if (NULL != p)
    {
        //
        // do real work here
        //
        p->Release();

        return T120_NO_ERROR;
    }

    return GCC_INVALID_TRANSPORT;
}


T120Error CPluggableTransport::EnableWinsock(void)
{
    if (g_fWinsockDisabled)
    {
        g_fWinsockDisabled = FALSE;

        //
        // LONCHANC: create Listen_Socket if not done so...
        //
        if (INVALID_SOCKET == Listen_Socket)
        {
            Listen_Socket = ::CreateAndConfigureListenSocket();
        }
    }

    return T120_NO_ERROR;
}


T120Error CPluggableTransport::DisableWinsock(void)
{
    if (! g_fWinsockDisabled)
    {
        g_fWinsockDisabled = TRUE;

        // close Listen_Socket...
        ::CloseListenSocket();
    }

    return T120_NO_ERROR;
}


void CPluggableTransport::Advise(LPFN_PLUGXPRT_CB pNotify, LPVOID pContext)
{
    m_pfnNotify = pNotify;
    m_pContext = pContext;
}


void CPluggableTransport::UnAdvise(void)
{
    m_pfnNotify = NULL;
    m_pContext = NULL;
}


void CPluggableTransport::ResetConnCounter(void)
{
    s_nConnID = 0;
}


void CPluggableTransport::OnProtocolControl
(
    TransportConnection     XprtConn,
    PLUGXPRT_STATE          eState,
    PLUGXPRT_RESULT         eResult
)
{
    if (IS_PLUGGABLE(XprtConn))
    {
        WARNING_OUT(("CPluggableTransport::OnProtocolControl: socket (%d, %d) is doing %d with result %d",
                        XprtConn.eType, XprtConn.nLogicalHandle, eState, eResult));

        if (NULL != m_pfnNotify)
        {
            CPluggableConnection *p = GetPluggableConnection(XprtConn.nLogicalHandle);
            if (NULL != p)
            {
                PLUGXPRT_MESSAGE Msg;
                Msg.eState = eState;
                Msg.pContext = m_pContext;
                Msg.pszConnID = p->GetConnString();
                // we only support X.224 level notifications
                Msg.eProtocol = PLUGXPRT_PROTOCOL_X224;
                Msg.eResult = eResult;

                (*m_pfnNotify)(&Msg);
            }
        }
    }
}


void OnProtocolControl
(
    TransportConnection     XprtConn,
    PLUGXPRT_STATE          eState,
    PLUGXPRT_RESULT         eResult
)
{
    if (NULL != g_pPluggableTransport)
    {
        g_pPluggableTransport->OnProtocolControl(XprtConn, eState, eResult);
    }
}


// called only in the plugable transport thread
// already in the critical section
ULONG CPluggableTransport::UpdateEvents(HANDLE *aHandles)
{
    ULONG cHandles = 0;
    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (TRANSPORT_TYPE_PLUGGABLE_X224 == p->GetType())
        {
            aHandles[cHandles++] = p->GetReadEvent();
            aHandles[cHandles++] = p->GetWriteEvent();
            aHandles[cHandles++] = p->GetCloseEvent();
            aHandles[cHandles++] = p->GetPendingReadEvent();
            aHandles[cHandles++] = p->GetPendingWriteEvent();
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    return cHandles;
}


// called only in the plugable transport thread
// already in the critical section
void CPluggableTransport::OnEventSignaled(HANDLE hevtSignaled)
{
    CPluggableConnection *p;
    BOOL fPostMessage, fFound;
    WPARAM wParam;
    LPARAM lParam;

    ::EnterCriticalSection(&g_csTransport);

    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        fFound = TRUE;
        fPostMessage = FALSE;
        wParam = MAKE_PLUGXPRT_WPARAM(p->GetConnID(), p->GetType());
        if (hevtSignaled == p->GetReadEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_READ, PLUGXPRT_RESULT_SUCCESSFUL);
            fPostMessage = TRUE;
        }
        else
        if (hevtSignaled == p->GetWriteEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_WRITE, PLUGXPRT_RESULT_SUCCESSFUL);
            fPostMessage = TRUE;
        }
        else
        if (hevtSignaled == p->GetCloseEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_CLOSE, PLUGXPRT_RESULT_SUCCESSFUL);
            fPostMessage = TRUE;
        }
        else
        {
            TransportConnection XprtConn;
            XprtConn.eType = p->GetType();
            XprtConn.nLogicalHandle = p->GetConnID();
            if (hevtSignaled == p->GetPendingReadEvent())
            {
                TRACE_OUT(("OnEventSignaled: PendingREAD(%d, %d)", p->GetType(), p->GetConnID()));
                if (p->OnPendingRead())
                {
                    ::ResetEvent(hevtSignaled);
                    // start next high-level read
                    p->NotifyHighLevelRead();
                }
            }
            else
            if (hevtSignaled == p->GetPendingWriteEvent())
            {
                TRACE_OUT(("OnEventSignaled: PendingWRITE(%d, %d)", p->GetType(), p->GetConnID()));
                if (p->OnPendingWrite())
                {
                    ::ResetEvent(hevtSignaled);
                    // start next low-level write
                    p->NotifyWriteEvent();
                }
            }
            else
            {
                fFound = FALSE;
            }
        }

        if (fPostMessage)
        {
            BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
            ASSERT(fRet);
        }

        if (fFound)
        {
            break;
        }
    } // while

    ::LeaveCriticalSection(&g_csTransport);

//    ASSERT(NULL != p);
}


// called only in the plugable transport thread
// already in the critical section
void CPluggableTransport::OnEventAbandoned(HANDLE hevtSignaled)
{
    CPluggableConnection *p;
    BOOL fFound;
    WPARAM wParam;
    LPARAM lParam;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        fFound = TRUE;
        wParam = MAKE_PLUGXPRT_WPARAM(p->GetConnID(), p->GetType());
        if (hevtSignaled == p->GetReadEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_READ, PLUGXPRT_RESULT_ABANDONED);
        }
        else
        if (hevtSignaled == p->GetWriteEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_WRITE, PLUGXPRT_RESULT_ABANDONED);
        }
        else
        if (hevtSignaled == p->GetCloseEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_CLOSE, PLUGXPRT_RESULT_ABANDONED);
        }
        else
        if (hevtSignaled == p->GetPendingReadEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_PENDING_EVENT, PLUGXPRT_RESULT_ABANDONED);
        }
        else
        if (hevtSignaled == p->GetPendingWriteEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_PENDING_EVENT, PLUGXPRT_RESULT_ABANDONED);
        }
        else
        {
            fFound = FALSE;
        }

        if (fFound)
        {
            m_PluggableConnectionList.Remove(p);

            // update the events list to wait for in the plugable transport thread
            ::SetEvent(g_hevtUpdatePluggableTransport);

            BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
            ASSERT(fRet);
            break;
        }
    } // while
    ::LeaveCriticalSection(&g_csTransport);

    ASSERT(NULL != p);
}


CPluggableConnection * CPluggableTransport::GetPluggableConnection(PSocket pSocket)
{
    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (p->GetType()   == pSocket->XprtConn.eType &&
            p->GetConnID() == pSocket->XprtConn.nLogicalHandle)
        {
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    return p;
}


CPluggableConnection * GetPluggableConnection(PSocket pSocket)
{
    return (NULL != g_pPluggableTransport) ?
         g_pPluggableTransport->GetPluggableConnection(pSocket) :
        NULL;
}


CPluggableConnection * CPluggableTransport::GetPluggableConnection(UINT_PTR nConnID)
{
    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (p->GetConnID() == nConnID)
        {
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    return p;
}


CPluggableConnection * GetPluggableConnection(UINT_PTR nConnID)
{
    return (NULL != g_pPluggableTransport) ?
         g_pPluggableTransport->GetPluggableConnection(nConnID) :
        NULL;
}


CPluggableConnection * CPluggableTransport::GetPluggableConnection(HANDLE hCommLink)
{
    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (p->GetCommLink() == hCommLink)
        {
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    return p;
}


CPluggableConnection * GetPluggableConnection(HANDLE hCommLink)
{
    return (NULL != g_pPluggableTransport) ?
         g_pPluggableTransport->GetPluggableConnection(hCommLink) :
        NULL;
}


CPluggableConnection * CPluggableTransport::GetPluggableConnectionByLegacyHandle(LEGACY_HANDLE logical_handle)
{
    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (p->GetLegacyHandle() == logical_handle)
        {
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    return p;
}


CPluggableConnection * GetPluggableConnectionByLegacyHandle(LEGACY_HANDLE logical_handle)
{
    return (NULL != g_pPluggableTransport) ?
         g_pPluggableTransport->GetPluggableConnectionByLegacyHandle(logical_handle) :
        NULL;
}


// called in ERNC ConfMgr's constructor
BOOL InitializePluggableTransport(void)
{
    if (! g_fPluggableTransportInitialized)
    {
        g_fWinsockDisabled = FALSE;
        g_hevtUpdatePluggableTransport = ::CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL != g_hevtUpdatePluggableTransport)
        {
            g_fPluggableTransportInitialized = TRUE;
        }
    }
    return g_fPluggableTransportInitialized;
}


// called in ERNC ConfMgr's destructor
void CleanupPluggableTransport(void)
{
    if (g_fPluggableTransportInitialized)
    {
        g_fPluggableTransportInitialized = FALSE;

        if (g_dwPluggableTransportThreadID)
        {
            ::PostThreadMessage(g_dwPluggableTransportThreadID, WM_QUIT, 0, 0);
        }

        ::EnterCriticalSection(&g_csTransport);
        if (NULL != g_hevtUpdatePluggableTransport)
        {
            ::CloseHandle(g_hevtUpdatePluggableTransport);
        }
        ::LeaveCriticalSection(&g_csTransport);
    }
}




DWORD __stdcall PluggableTransportThreadProc(LPVOID lpv)
{
    MSG msg;
    BOOL fContinueMainLoop = TRUE;
    DWORD nEventSignaled;
    ULONG cEvents;
    HANDLE aEvents[MAX_PLUGXPRT_CONNECTIONS * MAX_PLUGXPRT_EVENTS + 1];

    // signaling that the work hread has been started.
    ::SetEvent((HANDLE) lpv);

    // set up initial event list, the first entry always for update event
    cEvents = 1;
    aEvents[0] = g_hevtUpdatePluggableTransport;
    ::SetEvent(g_hevtUpdatePluggableTransport);

    // main loop
	while (fContinueMainLoop)
	{
		// process any possible window and thread messages
		while (::PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (WM_QUIT != msg.message)
            {
			    ::DispatchMessage(&msg);
            }
            else
            {
                fContinueMainLoop = FALSE;
                break;
            }
		}

        if (fContinueMainLoop)
        {
		    nEventSignaled = ::MsgWaitForMultipleObjects(cEvents, aEvents, FALSE, INFINITE, QS_ALLINPUT);
            ::EnterCriticalSection(&g_csTransport);
            if (NULL != g_pPluggableTransport)
            {
                switch (nEventSignaled)
                {
		        case WAIT_OBJECT_0:
                    // update the event list
                    cEvents = 1 + g_pPluggableTransport->UpdateEvents(&aEvents[1]);
                    break;
                case WAIT_TIMEOUT:
                    // impossible, do nothing
                    break;
                default:
                    if (WAIT_OBJECT_0 + 1 <= nEventSignaled && nEventSignaled < WAIT_OBJECT_0 + cEvents)
                    {
                        g_pPluggableTransport->OnEventSignaled(aEvents[nEventSignaled - WAIT_OBJECT_0]);
                    }
                    else
                    if (WAIT_ABANDONED_0 + 1 <= nEventSignaled && nEventSignaled < WAIT_ABANDONED_0 + cEvents)
                    {
                        g_pPluggableTransport->OnEventAbandoned(aEvents[nEventSignaled - WAIT_OBJECT_0]);
                    }
                    break;
                }
            }
            else
            {
                fContinueMainLoop = FALSE;
            }
            ::LeaveCriticalSection(&g_csTransport);
        }
    } // while

    g_dwPluggableTransportThreadID = 0;

    return 0;
}

BOOL EnsurePluggableTransportThread(void)
{
    BOOL fRet = TRUE;
    if (! g_dwPluggableTransportThreadID)
    {
        fRet = FALSE;
        HANDLE hSync = ::CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL != hSync)
        {
            HANDLE hThread = ::CreateThread(NULL, 0, PluggableTransportThreadProc, hSync, 0,
                                            &g_dwPluggableTransportThreadID);
            if (NULL != hThread)
            {
                ::WaitForSingleObject(hSync, 5000); // 5 second
                ::CloseHandle(hThread);
                fRet = TRUE;
            }
            ::CloseHandle(hSync);
        }
    }
    return fRet;
}


#if defined(TEST_PLUGGABLE) && defined(_DEBUG)
LPCSTR FakeNodeAddress(LPCSTR pcszNodeAddress)
{
    char szAddr[64];
    ::lstrcpyA(szAddr, pcszNodeAddress);
    for (LPSTR psz = &szAddr[0]; *psz; psz++)
    {
        if (*psz == ':')
        {
            *psz = '\0';
            break;
        }
    }
    if (! ::lstrcmp(szAddr, "157.59.12.93"))
    {
        pcszNodeAddress = "XPRT: 1";
    }
    else
    if (! ::lstrcmp(szAddr, "157.59.13.194"))
    {
        pcszNodeAddress = "XPRT: 2";
    }
    else
    if (! ::lstrcmp(szAddr, "157.59.10.198"))
    {
        pcszNodeAddress = "XPRT: 1";
    }
    else
    {
        ASSERT(0);
    }
    return pcszNodeAddress;
}
#endif


int SubmitPluggableRead(PSocket pSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *plug_rc)
{
    TRACE_OUT(("SubmitPluggableRead"));

    int nRet = SOCKET_ERROR;
    *plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

    CPluggableConnection *p = ::GetPluggableConnection(pSocket);
    if (NULL != p)
    {
        nRet = p->Read(buffer, length, plug_rc);
    }
    else
    {
        WARNING_OUT(("SubmitPluggableRead: no such conn ID=%d", pSocket->XprtConn.nLogicalHandle));
    }
    return nRet;
}


int CPluggableConnection::Read(LPBYTE buffer, int length, PLUGXPRT_RESULT *plug_rc)
{
    int cbRecv = SOCKET_ERROR;
    *plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

    ::EnterCriticalSection(&g_csTransport);

    if (NULL != m_OverlappedRead.hEvent)
    {
        // handle low-level pending read first
        if (m_fPendingReadDone)
        {
            // copy the data from internal buffer to external buffer
            if (length <= m_cbPendingRead)
            {
                // get as requested
                cbRecv = length;
                ::CopyMemory(buffer, m_pbPendingRead, length);
                m_cbPendingRead -= length;
                if (m_cbPendingRead <= 0)
                {
                    CleanupReadState();
                }
                else
                {
                    // move the memory, do not use copymemory due to overlap
                    int cb = m_cbPendingRead;
                    LPBYTE pbDst = m_pbPendingRead;
                    LPBYTE pbSrc = &m_pbPendingRead[length];
                    while (cb--)
                    {
                        *pbDst++ = *pbSrc++;
                    }
                }
            }
            else
            {
                // only get partial data
                cbRecv = m_cbPendingRead;
                ::CopyMemory(buffer, m_pbPendingRead, m_cbPendingRead);
                CleanupReadState();
            }

            // start next high-level read
            NotifyHighLevelRead();
        }
    }
    else
    {
        if (SetupReadState(length))
        {
            TRACE_OUT(("CPluggableConnection::Read: ReadFile(%d)", m_cbPendingRead));

            DWORD dwRead = 0;
            if (! ::ReadFile(m_hCommLink,
                             m_pbPendingRead,
                             m_cbPendingRead,
                             &dwRead,
                             &m_OverlappedRead))
            {
                DWORD dwErr = ::GetLastError();
                if (ERROR_HANDLE_EOF != dwErr && ERROR_IO_PENDING != dwErr)
                {
                    WARNING_OUT(("CPluggableConnection::Read: ReadFile failed, err=%d", dwErr));

                    CleanupReadState();

                    // disconnect at next tick
                    NotifyReadFailure();
                    *plug_rc = PLUGXPRT_RESULT_READ_FAILED;
                }
            }
            else
            {
                // do nothing, treat it as WSAEWOULDBLOCK
            }
        }
        else
        {
            ERROR_OUT(("CPluggableConnection::Read: failed to allocate memory (%d)", length));
            // out of memory, try later
            // do nothing, treat it as WSAEWOULDBLOCK
        }
    }

    ::LeaveCriticalSection(&g_csTransport);

    return cbRecv;
}


BOOL CPluggableConnection::OnPendingRead(void)
{
    TRACE_OUT(("CPluggableConnection::OnPendingRead"));

    BOOL fRet = FALSE;

    ::EnterCriticalSection(&g_csTransport);

    if (NULL != m_OverlappedRead.hEvent)
    {
        DWORD cbRead = 0;

        if (::GetOverlappedResult(m_hCommLink, &m_OverlappedRead, &cbRead, FALSE))
        {
            if ((int) cbRead == m_cbPendingRead)
            {
                TRACE_OUT(("CPluggableConnection::OnPendingRead: Received %d bytes (required %d bytes) on socket (%d, %d).",
                            cbRead, m_cbPendingRead, m_eType, m_nConnID));
            }
            else
            {
                WARNING_OUT(("CPluggableConnection::OnPendingRead: Received %d bytes (required %d bytes) on socket (%d, %d).",
                            cbRead, m_cbPendingRead, m_eType, m_nConnID));
            }
            m_cbPendingRead = cbRead; // in case cbRead is smaller
            m_fPendingReadDone = TRUE;
            fRet = TRUE; // turn off event
        }
        else
        {
            DWORD dwErr = ::GetLastError();
            if (ERROR_IO_INCOMPLETE == dwErr)
            {
                ASSERT(! cbRead);
            }
            else
            {
                TRACE_OUT(("CPluggableConnection::OnPendingRead: read failed %d", dwErr));
                fRet = TRUE; // turn off event

                // disconnect at next tick
                NotifyReadFailure();
            }
        }
    }
    else
    {
        ERROR_OUT(("CPluggableConnection::OnPendingRead: no pending read event handle."));
        fRet = TRUE; // turn off event
    }

    ::LeaveCriticalSection(&g_csTransport);

    return fRet;
}


void CPluggableConnection::NotifyHighLevelRead(void)
{
    WPARAM wParam = MAKE_PLUGXPRT_WPARAM(m_nConnID, m_eType);
    LPARAM lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_HIGH_LEVEL_READ, PLUGXPRT_RESULT_SUCCESSFUL);
    BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
    ASSERT(fRet);
}


void CPluggableConnection::NotifyReadFailure(void)
{
    WPARAM wParam = MAKE_PLUGXPRT_WPARAM(m_nConnID, m_eType);
    LPARAM lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_READ, PLUGXPRT_RESULT_READ_FAILED);
    BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
    ASSERT(fRet);
}


void CPluggableConnection::NotifyWriteEvent(void)
{
    WPARAM wParam = MAKE_PLUGXPRT_WPARAM(m_nConnID, m_eType);
    LPARAM lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_WRITE, PLUGXPRT_RESULT_SUCCESSFUL);
    BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
    ASSERT(fRet);
}


void CPluggableConnection::NotifyHighLevelWrite(void)
{
    WPARAM wParam = MAKE_PLUGXPRT_WPARAM(m_nConnID, m_eType);
    LPARAM lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_HIGH_LEVEL_WRITE, PLUGXPRT_RESULT_SUCCESSFUL);
    BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
    ASSERT(fRet);
}


void CPluggableConnection::NotifyWriteFailure(void)
{
    WPARAM wParam = MAKE_PLUGXPRT_WPARAM(m_nConnID, m_eType);
    LPARAM lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_WRITE, PLUGXPRT_RESULT_WRITE_FAILED);
    BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
    ASSERT(fRet);
}




LPBYTE DuplicateBuffer(LPBYTE buffer, UINT length)
{
    // DBG_SAVE_FILE_LINE
    LPBYTE new_buffer = new BYTE[length];
    if (NULL != new_buffer)
    {
        ::CopyMemory(new_buffer, buffer, length);
    }
    return new_buffer;
}


int SubmitPluggableWrite(PSocket pSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *plug_rc)
{
    TRACE_OUT(("SubmitPluggableWrite"));

    int nRet = SOCKET_ERROR;
    *plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

    CPluggableConnection *p = ::GetPluggableConnection(pSocket);
    if (NULL != p)
    {
        nRet = p->Write(buffer, length, plug_rc);
    }
    else
    {
        WARNING_OUT(("SubmitPluggableWrite: no such conn ID=%d", pSocket->XprtConn.nLogicalHandle));
    }
    return nRet;
}


int CPluggableConnection::Write(LPBYTE buffer, int length, PLUGXPRT_RESULT *plug_rc)
{
    TRACE_OUT(("CPluggableConnection::Write"));

    int cbSent = SOCKET_ERROR;
    *plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

    ::EnterCriticalSection(&g_csTransport);

    if (m_OutBufQueue2.GetCount() < MAX_PLUGGABLE_OUT_BUF_SIZE) // x4K
    {
        DBG_SAVE_FILE_LINE
        buffer = ::DuplicateBuffer(buffer, length);
        if (NULL != buffer)
        {
            cbSent = length;
            m_OutBufQueue2.Append(length, buffer);
            if (1 == m_OutBufQueue2.GetCount())
            {
                TRACE_OUT(("CPluggableConnection::Write: the only item in the queue"));
                WriteTheFirst();
                #if 0 // avoid another tick
                // start next low-level write
                WPARAM wParam = MAKE_PLUGXPRT_WPARAM(m_nConnID, m_eType);
                LPARAM lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_WRITE, PLUGXPRT_RESULT_SUCCESSFUL);
                BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
                ASSERT(fRet);
                #endif
            }
            else
            {
                TRACE_OUT(("CPluggableConnection::Write: more items in the queue"));
            }
        }
        else
        {
            ERROR_OUT(("CPluggableConnection::Write: failed to allocate memory (%d)", length));
            // out of memory, try later
            // do nothing, treat it as WSAEWOULDBLOCK
        }
    }

    ::LeaveCriticalSection(&g_csTransport);

    return cbSent;
}


void CPluggableConnection::WriteTheFirst(void)
{
    int length;
    LPBYTE buffer;

    TRACE_OUT(("CPluggableConnection::WriteTheFirst"));

    ::EnterCriticalSection(&g_csTransport);

    if (NULL == m_OverlappedWrite.hEvent)
    {
        length = 0;
        buffer = m_OutBufQueue2.PeekHead(&length);
        if (NULL != buffer)
        {
            ::ZeroMemory(&m_OverlappedWrite, sizeof(m_OverlappedWrite));
            m_OverlappedWrite.hEvent = m_hevtPendingWrite;

            m_pbPendingWrite = buffer;
            m_cbPendingWrite = length;

            TRACE_OUT(("CPluggableConnection::WriteTheFirst: WriteFile(%d)", length));

            DWORD cbWritten = 0;
            if (! ::WriteFile(m_hCommLink, buffer, length, &cbWritten, &m_OverlappedWrite))
            {
                DWORD dwErr = ::GetLastError();
                if (ERROR_IO_PENDING != dwErr)
                {
                    ERROR_OUT(("CPluggableConnection::WriteTheFirst: WriteFile failed, err=%d", dwErr));
                    CleanupWriteState();
                    m_OutBufQueue2.Get(); // dequeue the buffer which cannot be sent

                    NotifyWriteFailure();
                }
                else
                {
                    // we are still in pending
                    // repeat the write event
                    NotifyWriteEvent();
                }
            }
        }
        else
        {
            TRACE_OUT(("CPluggableConnection::WriteTheFirst: queue is empty"));

            // no more low-level write
            m_pbPendingWrite = NULL;
            CleanupWriteState();

            // start next high-level write
            NotifyHighLevelWrite();
        }
    }
    else
    {
        TRACE_OUT(("CPluggableConnection::WriteTheFirst: still pending"));
        // we are still in write pending, wake up the pending write
        OnPendingWrite(); // check for pending write result
        NotifyWriteEvent();
    }

    ::LeaveCriticalSection(&g_csTransport);
}


void PluggableWriteTheFirst(TransportConnection XprtConn)
{
    if (IS_PLUGGABLE(XprtConn))
    {
        CPluggableConnection *p = ::GetPluggableConnection(XprtConn.nLogicalHandle);
        if (NULL != p)
        {
            p->WriteTheFirst();
        }
        else
        {
            ERROR_OUT(("PluggableWriteTheFirst: no such conn ID=%d", XprtConn.nLogicalHandle));
        }
    }
    else
    {
        ERROR_OUT(("PluggableWriteTheFirst: not plugable connection"));
    }
}


void PluggableShutdown(TransportConnection XprtConn)
{
    if (IS_PLUGGABLE(XprtConn))
    {
        CPluggableConnection *p = ::GetPluggableConnection(XprtConn.nLogicalHandle);
        if (NULL != p)
        {
            p->Shutdown();
        }
        else
        {
            ERROR_OUT(("PluggableShutdown: no such conn ID=%d", XprtConn.nLogicalHandle));
        }
    }
    else
    {
        ERROR_OUT(("PluggableShutdown: not plugable connection"));
    }
}


BOOL CPluggableConnection::OnPendingWrite(void)
{
    TRACE_OUT(("CPluggableConnection::OnPendingWrite"));

    BOOL fRet = FALSE;
	BOOL fStartNextWrite = FALSE;

    ::EnterCriticalSection(&g_csTransport);

    if (NULL != m_OverlappedWrite.hEvent)
    {
        DWORD cbWritten = 0;
        if (::GetOverlappedResult(m_hCommLink, &m_OverlappedWrite, &cbWritten, TRUE))
        {
            TRACE_OUT(("CPluggableConnection::OnPendingWrite: Sent %d bytes (required %d bytes) on socket (%d, %d).",
                            cbWritten, m_cbPendingWrite, m_eType, m_nConnID));
            if (cbWritten >= (DWORD) m_cbPendingWrite)
            {
                ASSERT(cbWritten == (DWORD) m_cbPendingWrite);

                // remove the item from the queue
                int length = 0;
                LPBYTE buffer = m_OutBufQueue2.Get(&length);
                ASSERT(length == m_cbPendingWrite);
                ASSERT(buffer == m_pbPendingWrite);

                CleanupWriteState();

                fRet = TRUE; // turn off event
            }
            else
            {
                ERROR_OUT(("CPluggableConnection::OnPendingWrite: unexpected error, less data written %d (required %d)",
                            cbWritten, m_cbPendingWrite));
                NotifyWriteFailure();
                fRet = TRUE; // turn off event
            }
        }
        else
        {
            DWORD dwErr = ::GetLastError();
            if (ERROR_IO_INCOMPLETE == dwErr)
            {
                ASSERT(! cbWritten);
            }
            else
            {
                ERROR_OUT(("CPluggableConnection::OnPendingWrite: failed to write, err=%d", dwErr));
                NotifyWriteFailure();
                fRet = TRUE; // turn off event
            }
        }
    }
    else
    {
        // it is very possible that we hit this many times
        fRet = TRUE;
    }

    ::LeaveCriticalSection(&g_csTransport);

    return fRet;
}



BOOL CPluggableConnection::SetupReadState(int length)
{
    DBG_SAVE_FILE_LINE
    LPBYTE buffer = new BYTE[length];
    if (NULL != buffer)
    {
        m_pbPendingRead = buffer;
        m_cbPendingRead = length;
        m_fPendingReadDone = FALSE;

        ::ZeroMemory(&m_OverlappedRead, sizeof(m_OverlappedRead));
        m_OverlappedRead.hEvent = m_hevtPendingRead;
    }
    else
    {
        CleanupReadState();
    }
    return (NULL != buffer);
}


void CPluggableConnection::CleanupReadState(void)
{
    delete [] m_pbPendingRead;
    m_pbPendingRead = NULL;
    m_cbPendingRead = 0;
    m_fPendingReadDone = FALSE;

    ::ZeroMemory(&m_OverlappedRead, sizeof(m_OverlappedRead));
}


void CPluggableConnection::CleanupWriteState(void)
{
    delete [] m_pbPendingWrite;
    m_pbPendingWrite = NULL;
    m_cbPendingWrite = 0;

    ::ZeroMemory(&m_OverlappedWrite, sizeof(m_OverlappedWrite));
}



TransportError CALLBACK LegacyTransportCallback(ULONG nMsg, void *Param1, void *Param2)
{
    if (Param2 == g_pPluggableTransport)
    {
        BOOL fPostMsg = FALSE;
        WPARAM wParam = 0;
        CPluggableConnection *p;

        switch (nMsg)
        {
        case TRANSPORT_CONNECT_INDICATION:
            TRACE_OUT(("LegacyTransportCallback::TRANSPORT_CONNECT_INDICATION"));
            {
                LegacyTransportID *pID = (LegacyTransportID *) Param1;
                p = ::GetPluggableConnection(pID->hCommLink);
                if (NULL != p)
                {
                    p->SetLegacyHandle(pID->logical_handle);

                    {
                        PSocket pSocket = p->GetSocket();
                        ASSERT(NULL != pSocket);
                        if (NULL != pSocket)
                        {
                            pSocket->State = SOCKET_CONNECTED;
                            wParam = MAKE_PLUGXPRT_WPARAM(p->GetConnID(), TRANSPORT_TYPE_PLUGGABLE_PSTN);
                            fPostMsg = TRUE;
                        }
                    }
                }
            }
            break;

        case TRANSPORT_CONNECT_CONFIRM:
            TRACE_OUT(("LegacyTransportCallback::TRANSPORT_CONNECT_CONFIRM"));
            {
                LegacyTransportID *pID = (LegacyTransportID *) Param1;
                p = ::GetPluggableConnection(pID->hCommLink);
                if (NULL != p)
                {
                    ASSERT(p->GetLegacyHandle() == pID->logical_handle);

                    {
                        PSocket pSocket = p->GetSocket();
                        ASSERT(NULL != pSocket);
                        if (NULL != pSocket)
                        {
                            pSocket->State = X224_CONNECTED;
                            wParam = MAKE_PLUGXPRT_WPARAM(p->GetConnID(), TRANSPORT_TYPE_PLUGGABLE_PSTN);
                            fPostMsg = TRUE;
                        }
                    }
                }
            }
            break;

        case TRANSPORT_DISCONNECT_INDICATION:
            TRACE_OUT(("LegacyTransportCallback::TRANSPORT_DISCONNECT_INDICATION"));
            {
                LegacyTransportID *pID = (LegacyTransportID *) Param1;
                TransportConnection XprtConn;
                XprtConn.eType = TRANSPORT_TYPE_PLUGGABLE_PSTN;
                p = ::GetPluggableConnectionByLegacyHandle(pID->logical_handle);
                if (NULL != p)
                {
                    XprtConn.nLogicalHandle = p->GetConnID();
                }
                ::OnProtocolControl(XprtConn, PLUGXPRT_DISCONNECTED);
                fPostMsg = FALSE;
            }
            break;

        case TRANSPORT_DATA_INDICATION:
            TRACE_OUT(("LegacyTransportCallback::TRANSPORT_DATA_INDICATION"));
            {
                //
                // This piece of data does not have X.224 framing
                //
                LegacyTransportData *pData = (LegacyTransportData *) Param1;
                TRACE_OUT(("LegacyTransportCallback::pbData=0x%x, cbDataSize=%d", pData->pbData, pData->cbDataSize));

                if (NULL != g_Transport)
                {
                    DBG_SAVE_FILE_LINE
                    TransportData *td = new TransportData;
                    if (NULL != td)
                    {
                        td->transport_connection.eType = TRANSPORT_TYPE_PLUGGABLE_PSTN;
                        p = ::GetPluggableConnectionByLegacyHandle(pData->logical_handle);
                        if (NULL != p)
                        {
                            ULONG cbTotalSize = PROTOCOL_OVERHEAD_X224 + pData->cbDataSize;
                            td->transport_connection.nLogicalHandle = p->GetConnID();
                            DBG_SAVE_FILE_LINE
                            td->memory = ::AllocateMemory(NULL, cbTotalSize, RECV_PRIORITY);
                            if (NULL != td->memory)
                            {
                                td->user_data = td->memory->GetPointer();
                                td->user_data_length = cbTotalSize;

                                // take care of the X.224 header
                                ::CopyMemory(td->user_data, g_X224Header, PROTOCOL_OVERHEAD_X224);
                                AddRFCSize(td->user_data, cbTotalSize);
                                // take care of the data
                                ::CopyMemory(td->user_data + PROTOCOL_OVERHEAD_X224, pData->pbData, pData->cbDataSize);

                                wParam = (WPARAM) td;
                                fPostMsg = TRUE;
                            }
                            else
                            {
                                ERROR_OUT(("LegacyTransportCallback: failed to allocate memory, size=%d", cbTotalSize));
                            }
                        }
                        else
                        {
                            ERROR_OUT(("LegacyTransportCallback: GetPluggableConnectionByLegacyHandle failed" ));
                            delete td;
                        }
                    }
                    else
                    {
                        ERROR_OUT(("LegacyTransportCallback: failed to allocate TransportData"));
                    }
                }
            }
            break;

        default:
            wParam = (WPARAM) Param1;
            fPostMsg = TRUE;
            break;
        }

        if (fPostMsg)
        {
            BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_PSTN, wParam, nMsg);
            ASSERT(fRet);
        }
    }

    return TRANSPORT_NO_ERROR;
}


void HandlePSTNCallback(WPARAM wParam, LPARAM lParam)
{
    if (NULL != g_pPluggableTransport)
    {
        CPluggableConnection *p;

        switch (lParam)
        {
        case TRANSPORT_CONNECT_INDICATION:
            TRACE_OUT(("HandlePSTNCallback::TRANSPORT_CONNECT_INDICATION"));
            if (NULL != g_Transport)
            {
                TransportConnection XprtConn;
                XprtConn.nLogicalHandle = PLUGXPRT_WPARAM_TO_ID(wParam);
                XprtConn.eType = (TransportType) PLUGXPRT_WPARAM_TO_TYPE(wParam);
                ::OnProtocolControl(XprtConn, PLUGXPRT_CONNECTED);
                g_Transport->ConnectIndication(XprtConn);
            }
            break;

        case TRANSPORT_CONNECT_CONFIRM:
            TRACE_OUT(("HandlePSTNCallback::TRANSPORT_CONNECT_CONFIRM"));
            if (NULL != g_Transport)
            {
                TransportConnection XprtConn;
                XprtConn.nLogicalHandle = PLUGXPRT_WPARAM_TO_ID(wParam);
                XprtConn.eType = (TransportType) PLUGXPRT_WPARAM_TO_TYPE(wParam);
                ::OnProtocolControl(XprtConn, PLUGXPRT_CONNECTED);
                g_Transport->ConnectConfirm(XprtConn);
            }
            break;

        case TRANSPORT_DATA_INDICATION:
            TRACE_OUT(("HandlePSTNCallback::TRANSPORT_DATA_INDICATION"));
            {
                TransportData *td = (TransportData *) wParam;
                if (NULL != g_Transport)
                {
                    g_Transport->DataIndication(td);
                }
                delete td;
            }
            break;

        case TRANSPORT_BUFFER_EMPTY_INDICATION:
            TRACE_OUT(("HandlePSTNCallback::TRANSPORT_BUFFER_EMPTY_INDICATION"));
            {
                LEGACY_HANDLE logical_handle = (LEGACY_HANDLE) wParam;
                TransportConnection XprtConn;
                XprtConn.eType = TRANSPORT_TYPE_PLUGGABLE_PSTN;
                p = ::GetPluggableConnectionByLegacyHandle(logical_handle);
                if (NULL != p)
                {
                    XprtConn.nLogicalHandle = p->GetConnID();
                    g_Transport->BufferEmptyIndication(XprtConn);
                }
            }
            break;

        default:
            ERROR_OUT(("HandlePSTNCallback: unknown message=%d", lParam));
            break;
        }
    }
}


BOOL CPluggableTransport::EnsureLegacyTransportLoaded(void)
{
    if (NULL == g_pLegacyTransport)
    {
        g_hlibMST123 = NmLoadLibrary("MST123.DLL",FALSE);
        if (NULL != g_hlibMST123)
        {
            LPFN_T123_CreateTransportInterface pfn = (LPFN_T123_CreateTransportInterface)
                    ::GetProcAddress(g_hlibMST123, LPSTR_T123_CreateTransportInterface);
            if (NULL != pfn)
            {
                TransportError rc = (*pfn)(&g_pLegacyTransport);
                if (TRANSPORT_NO_ERROR == rc)
                {
                    ASSERT(NULL != g_pLegacyTransport);

                    // start to call initialize
                    rc = g_pLegacyTransport->TInitialize(LegacyTransportCallback, this);
                    ASSERT(TRANSPORT_NO_ERROR == rc);

                    if (TRANSPORT_NO_ERROR == rc)
                    {
                        return TRUE;
                    }

                    g_pLegacyTransport->TCleanup();
                    g_pLegacyTransport->ReleaseInterface();
                    g_pLegacyTransport = NULL;
                }
            }

            ::FreeLibrary(g_hlibMST123);
            g_hlibMST123 = NULL;
        }

        return FALSE;
    }

    return TRUE;
}


TransportError CPluggableConnection::TConnectRequest(void)
{
    TRACE_OUT(("CPluggableConnection::TConnectRequest"));
    TransportError rc = TRANSPORT_NO_PLUGGABLE_CONNECTION;
    if (NULL != g_pLegacyTransport)
    {
        TransportConnection XprtConn;
        XprtConn.eType = m_eType;
        XprtConn.nLogicalHandle = m_nConnID;
        ::OnProtocolControl(XprtConn, PLUGXPRT_CONNECTING);

        rc = g_pLegacyTransport->TConnectRequest(&m_nLegacyLogicalHandle, m_hCommLink);
    }
    return rc;
}


TransportError CPluggableConnection::TDisconnectRequest(void)
{
    TRACE_OUT(("CPluggableConnection::TDisconnectRequest"));
    TransportError rc = TRANSPORT_NO_PLUGGABLE_CONNECTION;
    if (NULL != g_pLegacyTransport)
    {
        TransportConnection XprtConn;
        XprtConn.eType = m_eType;
        XprtConn.nLogicalHandle = m_nConnID;
        ::OnProtocolControl(XprtConn, PLUGXPRT_DISCONNECTING);

        ::Sleep(600);
        rc = g_pLegacyTransport->TDisconnectRequest(m_nLegacyLogicalHandle, TRUE);
    }
    return rc;
}


int CPluggableConnection::TDataRequest(LPBYTE pbData, ULONG cbDataSize, PLUGXPRT_RESULT *plug_rc)
{
    TRACE_OUT(("CPluggableConnection::TDataRequest, pbData=0x%x, cbDataSize=%d", pbData, cbDataSize));
    if (NULL != g_pLegacyTransport)
    {
        *plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

        // skip X.224 framing
        ASSERT(cbDataSize > PROTOCOL_OVERHEAD_X224);

        TransportError rc;
        rc = g_pLegacyTransport->TDataRequest(m_nLegacyLogicalHandle,
                                              pbData + PROTOCOL_OVERHEAD_X224,
                                              cbDataSize - PROTOCOL_OVERHEAD_X224);
        if (TRANSPORT_NO_ERROR == rc)
        {
            TRACE_OUT(("CPluggableConnection::TDataRequest: sent data size=%d", cbDataSize));
            return cbDataSize;
        }
    }
    else
    {
        *plug_rc = PLUGXPRT_RESULT_WRITE_FAILED;
    }
    return SOCKET_ERROR;
}


TransportError TReceiveBufferAvailable(void)
{
    TRACE_OUT(("CPluggableConnection::TReceiveBufferAvailable"));
    TransportError rc = TRANSPORT_NO_PLUGGABLE_CONNECTION;
    if (NULL != g_pLegacyTransport)
    {
        rc = g_pLegacyTransport->TReceiveBufferAvailable();
    }
    return rc;
}


TransportError CPluggableConnection::TPurgeRequest(void)
{
    TRACE_OUT(("CPluggableConnection::TPurgeRequest"));
    TransportError rc = TRANSPORT_NO_PLUGGABLE_CONNECTION;
    if (NULL != g_pLegacyTransport)
    {
        rc = g_pLegacyTransport->TPurgeRequest(m_nLegacyLogicalHandle);
    }
    return rc;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\precomp.h ===
#define INC_OLE2
#define IDS_NULL_STRING			(0)
#include <windows.h>
#include <tchar.h>

// MCSNC includes
#include <databeam.h>

#include <oprahcom.h>
#include <confdbg.h>
// end MCSNC includes

extern "C"
{
#include <t120.h>
}
#include <memmgr.h>
#include <mcattprt.h>
#include <ncmcs.h>
#include <debspew.h>
#include <RegEntry.h>
#include <ConfReg.h>
#include <it120nc.h>
#include <dllutil.h>


#include "fclasses.h"

#include "cntlist.h"
#include "clists.h"
#include "ms_util.h"
#include <fsdiag.h>

#include <spacket.h>
#include <packet.h>
#include <datapkt.h>
#include <cmdtar.h>
#include <attmnt.h>
#include <channel.h>
#include <tptif.h>
#include <domain.h>
#include <connect.h>
#include <tprtctrl.h>
#include <user.h>
#include <control.h>
#include <evtlog.h>
#include <nmevtmsg.h>

#include "pdutypes.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\randchnl.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	randchnl.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the RandomChannelGenerator class,
 *		which inherits from the RandomNumberGenerator class.  On instantiation,
 *		instances of this class will internally generate a random number which
 *		falls within the allowable range of dynamic channels values.  Channel
 *		assignments are then generated by incrementing this value each time a
 *		new assignment is requested.  Once the maximum allowable value has been
 *		assigned, the next value to be generated "wraps around" to the minimum
 *		allowable value.
 *
 *		Obviously, this class does not generate completely random channel
 *		values for each request.  With a completely random generator, it is
 *		possible to delete a channel in MCS, and then have the random number
 *		generator assign the same value as the deleted channel before all
 *		components of the system even know that the channel was deleted to
 *		start with, thus causing erratic behavior in the system.  In this
 *		class, no channel can be reassigned until all other possible channels
 *		have been assigned.
 *
 *		This class can be modifed in the future to incorporate additional
 *		"randomness" into the algorithm and still not reassign any channel
 *		numbers before all other possible values are used.  This, however,
 *		would be at the expense of performance and/or memory resources.
 *                  
 *	Caveats:
 *		None.
 *
 *	Author:
 *		Alan D. May
 */
#include "randchnl.h"

/*
 *	These macros define the mimimum and maximum allowable dynamic channel
 *	values.
 */
#define MINIMUM_DYNAMIC_CHANNEL		1001
#define MAXIMUM_DYNAMIC_CHANNEL		65535

/*
 *	RandomChannelGenerator ()
 *
 *	Public
 *
 *	Functional Description:
 *		This version of the constructor is used to create a random channel
 *		generator object that has been automatically seeded with the current
 *		time.
 */
RandomChannelGenerator::RandomChannelGenerator()
{
	Current_Channel = (GetTickCount() % (MAXIMUM_DYNAMIC_CHANNEL + 1 - MINIMUM_DYNAMIC_CHANNEL)) + MINIMUM_DYNAMIC_CHANNEL;
}

/*
 *	~RandomChannelGenerator ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the RandomChannelGenerator class.
 */
RandomChannelGenerator::~RandomChannelGenerator ()
{
}

/*
 *	GetRandomChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This method returns a valid dynamic channel number.
 */
RandomValue		RandomChannelGenerator::GetRandomChannel (Void)
{
	/*
	 *	Increment the current channel value.
	 */
	++Current_Channel;

	/*
	 *	Determine if the current channel value needs to wrap around.
	 */	if (Current_Channel > MAXIMUM_DYNAMIC_CHANNEL)
	{
		Current_Channel = MINIMUM_DYNAMIC_CHANNEL;
	}

	/*
	 *	Return the current channel value.
	 */
	return (Current_Channel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\privlist.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/* 
 *	privlist.cpp
 *
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the imlpementation file for the class PrivilegeListData. 
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */


#include "privlist.h"



/*
 *	PrivilegeListData ()
 *
 *	Public Function Description
 */
PrivilegeListData::PrivilegeListData(	
								PGCCConferencePrivileges	privilege_list)
{
	Privilege_List = *privilege_list;
}


/*
 *	GetPrivilegeListPDU ()
 *
 *	Public Function Description
 */
PrivilegeListData::PrivilegeListData(	PSetOfPrivileges	set_of_privileges)
{
	PSetOfPrivileges 	privilege_set;
	Privilege			privilege_value;

	Privilege_List.terminate_is_allowed = FALSE;
	Privilege_List.eject_user_is_allowed = FALSE;
	Privilege_List.add_is_allowed = FALSE;
	Privilege_List.lock_unlock_is_allowed = FALSE;
	Privilege_List.transfer_is_allowed = FALSE;

	privilege_set = set_of_privileges;

	while (privilege_set != NULL)
	{
		privilege_value = privilege_set->value;
			
		switch (privilege_value)
		{
			case TERMINATE:
				Privilege_List.terminate_is_allowed = TRUE;
				break;
	
			case EJECT_USER:
				Privilege_List.eject_user_is_allowed = TRUE;
				break;
	
			case ADD:
				Privilege_List.add_is_allowed = TRUE;
				break;
	
			case LOCK_UNLOCK:
				Privilege_List.lock_unlock_is_allowed = TRUE;
				break;
	
			case TRANSFER:
				Privilege_List.transfer_is_allowed = TRUE;
				break;

			default:
				ERROR_OUT(("PrivilegeListData::PrivilegeListData: Bad privilege value=%d", (UINT) privilege_value));
				break;
		}

		privilege_set = privilege_set->next;
	}
}


/*
 *	~PrivilegeListData	()
 *
 *	Public Function Description
 */
PrivilegeListData::~PrivilegeListData()
{
}


/*
 *	GetPrivilegeListData ()
 *
 *	Public Function Description
 */


/*
 *	GetPrivilegeListPDU ()
 *
 *	Public Function Description
 */
GCCError	PrivilegeListData::GetPrivilegeListPDU(
						PSetOfPrivileges		*	set_of_privileges)
{
	GCCError			return_value = GCC_NO_ERROR;
	PSetOfPrivileges	current_privilege = NULL;
	PSetOfPrivileges	next_privilege = NULL;
	Privilege			privilege_value;
	Int					i;
	
	*set_of_privileges = NULL;
	
	for (i = 0; i < NUMBER_OF_PRIVILEGES; i++)
	{
		privilege_value = (Privilege)NUMBER_OF_PRIVILEGES;
	
		switch (i)
		{
			case TERMINATE_IS_ALLOWED:
				if (Privilege_List.terminate_is_allowed )
					privilege_value = TERMINATE;
				break;
	
			case EJECT_USER_IS_ALLOWED:
				if (Privilege_List.eject_user_is_allowed )
					privilege_value = EJECT_USER;
				break;
	
			case ADD_IS_ALLOWED:
				if (Privilege_List.add_is_allowed )
					privilege_value = ADD;
				break;
	
			case LOCK_UNLOCK_IS_ALLOWED:
				if (Privilege_List.lock_unlock_is_allowed )
					privilege_value = LOCK_UNLOCK;
				break;
	
			case TRANSFER_IS_ALLOWED:
				if (Privilege_List.transfer_is_allowed )
					privilege_value = TRANSFER;
				break;

			default:
				ERROR_OUT(("PrivilegeListData::GetPrivilegeListPDU: Bad value"));
				break;
		}
		
		if (privilege_value != NUMBER_OF_PRIVILEGES)
		{
  	  		DBG_SAVE_FILE_LINE
			next_privilege = new SetOfPrivileges;

			if (next_privilege != NULL)
			{
				next_privilege->value = privilege_value; 
				next_privilege->next = NULL;

				if (*set_of_privileges == NULL)
				{
					*set_of_privileges = next_privilege;
					current_privilege = next_privilege;
				}
				else
				{
					if(current_privilege != NULL)
					{
        					current_privilege->next = next_privilege;
	        				current_privilege = next_privilege;
					}
					else
					{
					    delete next_privilege;
					    return_value = GCC_ALLOCATION_FAILURE;
					    break;
					}
					   
					
				}
					 
			}
			else
			{
				return_value = GCC_ALLOCATION_FAILURE;
				break;
			}
		}
	}

	return (return_value);
}


/*
 *	FreePrivilegeListPDU ()
 *
 *	Public Function Description
 */
Void	PrivilegeListData::FreePrivilegeListPDU(
						PSetOfPrivileges			set_of_privileges)
{
	PSetOfPrivileges	current_privilege = NULL;
	PSetOfPrivileges	next_privilege = NULL;
	
	current_privilege = set_of_privileges;
	while (current_privilege != NULL)
	{
		next_privilege = current_privilege->next;
		
		delete current_privilege;
		current_privilege = next_privilege;	
	}
}


/*
 *	IsPrivilegeAvailable ()
 *
 *	Public Function Description
 */
BOOL    PrivilegeListData::IsPrivilegeAvailable (
							ConferencePrivilegeType			privilege_type)
{
	BOOL    return_value = FALSE;
	
	switch (privilege_type)
	{
		case TERMINATE_PRIVILEGE:
			if (Privilege_List.terminate_is_allowed )
				return_value = TRUE;
			break;
			
		case EJECT_USER_PRIVILEGE:
			if (Privilege_List.eject_user_is_allowed )
				return_value = TRUE;
			break;
			
		case ADD_PRIVILEGE:
			if (Privilege_List.add_is_allowed )
				return_value = TRUE;
			break;
			
		case LOCK_UNLOCK_PRIVILEGE:
			if (Privilege_List.lock_unlock_is_allowed )
				return_value = TRUE;
			break;
			
		case TRANSFER_PRIVILEGE:
			if (Privilege_List.transfer_is_allowed )
				return_value = TRUE;
			break;
	}
	
	return (return_value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\plgxprt.h ===
#ifndef _T120_TRANSPORT_H_
#define _T120_TRANSPORT_H_

#include "iplgxprt.h"
#include "it120xprt.h"
#include "socket.h"
#include "mcattprt.h"
#include "imst123.h"

#define MAX_PLUGGABLE_OUT_BUF_SIZE        32

#define MAX_PLUGXPRT_CONNECTIONS          16
#define MAX_PLUGXPRT_EVENTS               5 // read, write, close, pending read, and pending write

#define MAKE_PLUGXPRT_WPARAM(id,type)     (MAKELONG(id,type))
#define PLUGXPRT_WPARAM_TO_ID(wParam)     (LOWORD(wParam))
#define PLUGXPRT_WPARAM_TO_TYPE(wParam)   (HIWORD(wParam))

#define MAKE_PLUGXPRT_LPARAM(evt,err)     (MAKELONG(evt,err))
#define PLUGXPRT_LPARAM_TO_EVENT(lParam)  (LOWORD(lParam))
#define PLUGXPRT_LPARAM_TO_ERROR(lParam)  (HIWORD(lParam))


enum
{
    PLUGXPRT_PENDING_EVENT          = 0,
    PLUGXPRT_EVENT_READ             = 1,
    PLUGXPRT_EVENT_WRITE            = 2,
    PLUGXPRT_EVENT_CLOSE            = 3,
    PLUGXPRT_EVENT_ACCEPT           = 4,
    PLUGXPRT_EVENT_CONNECT          = 5,
    PLUGXPRT_HIGH_LEVEL_READ        = 6,
    PLUGXPRT_HIGH_LEVEL_WRITE       = 7,
};


class CPluggableOutBufQueue2 : public CQueue2
{
    DEFINE_CQUEUE2(CPluggableOutBufQueue2, LPBYTE, int)
};


class CPluggableConnection : public CRefCount
{
public:

    CPluggableConnection(PLUGXPRT_CALL_TYPE eCaller, HANDLE hCommLink,
                        HANDLE hevtRead, HANDLE hevtWrite, HANDLE hevtClose,
                        PLUGXPRT_FRAMING eFraming, PLUGXPRT_PARAMETERS *pParams,
                        T120Error *);
    ~CPluggableConnection(void);

    LPSTR   GetConnString(void) { return &m_szConnID[0]; }
    UINT    GetConnID(void) { return m_nConnID; }
    HANDLE  GetCommLink(void) { return m_hCommLink; }
    HANDLE  GetReadEvent(void) { return m_hevtRead; }
    HANDLE  GetWriteEvent(void) { return m_hevtWrite; }
    HANDLE  GetCloseEvent(void) { return m_hevtClose; }

    void SetSocket(PSocket pSocket) { m_pSocket = pSocket; }
    PSocket GetSocket(void) { return m_pSocket; }

    TransportType GetType(void) { return m_eType; }

    BOOL IsCaller(void) { return (PLUGXPRT_CALLER == m_eCaller); }
    BOOL IsCallee(void) { return (PLUGXPRT_CALLEE == m_eCaller); }

    HANDLE  GetPendingReadEvent(void) { return m_hevtPendingRead; }
    HANDLE  GetPendingWriteEvent(void) { return m_hevtPendingWrite; }

    T120Error UpdateCommLink(HANDLE hCommLink);


    int Read(LPBYTE buffer, int length, PLUGXPRT_RESULT *);
    BOOL OnPendingRead(void);

    int Write(LPBYTE buffer, int length, PLUGXPRT_RESULT *);
    BOOL OnPendingWrite(void);
    void WriteTheFirst(void);

    void NotifyHighLevelRead(void);
    void NotifyReadFailure(void);

    void NotifyHighLevelWrite(void);
    void NotifyWriteFailure(void);
    void NotifyWriteEvent(void);

    BOOL SetupReadState(int length);
    void CleanupReadState(void);
    void CleanupWriteState(void);

    void Shutdown(void);


    //
    // Legacy PSTN transport
    //
    LEGACY_HANDLE GetLegacyHandle(void) { return m_nLegacyLogicalHandle; }
    void SetLegacyHandle(LEGACY_HANDLE logical_handle) { m_nLegacyLogicalHandle = logical_handle; }
    TransportError TConnectRequest(void);
    TransportError TDisconnectRequest(void);
    int TDataRequest(LPBYTE pbData, ULONG cbDataSize, PLUGXPRT_RESULT *);
    TransportError TPurgeRequest(void);

private:

    PLUGXPRT_STATE      m_eState;
    PLUGXPRT_CALL_TYPE  m_eCaller;

    HANDLE              m_hCommLink;
    HANDLE              m_hevtRead;
    HANDLE              m_hevtWrite;
    HANDLE              m_hevtClose;
    TransportType       m_eType;

    PSocket             m_pSocket;

    UINT                m_nConnID;
    char                m_szConnID[T120_CONNECTION_ID_LENGTH];

    //
    // Legacy PSTN transport
    //
    LEGACY_HANDLE           m_nLegacyLogicalHandle;

    //
    // X.224 framing
    //
    HANDLE              m_hevtPendingRead;  // for asynchronous ReadFile()
    HANDLE              m_hevtPendingWrite; // for asynchronous WriteFile()
    // IO queue management for X.224
    BOOL                    m_fPendingReadDone;
    int                     m_cbPendingRead;
    LPBYTE                  m_pbPendingRead;
    OVERLAPPED              m_OverlappedRead;
    int                     m_cbPendingWrite;
    LPBYTE                  m_pbPendingWrite;
    OVERLAPPED              m_OverlappedWrite;
    CPluggableOutBufQueue2  m_OutBufQueue2;
};




class CPluggableConnectionList : public CList
{
    DEFINE_CLIST(CPluggableConnectionList, CPluggableConnection *)
};


class CPluggableTransport : public IT120PluggableTransport,
                            public CRefCount
{
public:

    CPluggableTransport(void);
    ~CPluggableTransport(void);

    STDMETHOD_(void, ReleaseInterface) (THIS);

    STDMETHOD_(T120Error, CreateConnection) (THIS_
                    char                szConnID[],
                    PLUGXPRT_CALL_TYPE  eCaller,
                    HANDLE              hCommLink,
                    HANDLE              hevtRead,
                    HANDLE              hevtWrite,
                    HANDLE              hevtClose,
                    PLUGXPRT_FRAMING    eFraming,
                    PLUGXPRT_PARAMETERS *pParams);

    STDMETHOD_(T120Error, UpdateConnection) (THIS_
                    LPSTR               pszConnID,
                    HANDLE              hCommLink);

    STDMETHOD_(T120Error, CloseConnection) (THIS_ LPSTR pszConnID);

    STDMETHOD_(T120Error, EnableWinsock) (THIS);

    STDMETHOD_(T120Error, DisableWinsock) (THIS);

    STDMETHOD_(void, Advise) (THIS_ LPFN_PLUGXPRT_CB, LPVOID pContext);

    STDMETHOD_(void, UnAdvise) (THIS);

    STDMETHOD_(void, ResetConnCounter) (THIS);

    void OnProtocolControl(TransportConnection, PLUGXPRT_STATE, PLUGXPRT_RESULT);

    ULONG UpdateEvents(HANDLE *aHandles);
    void OnEventSignaled(HANDLE hevtSignaled);
    void OnEventAbandoned(HANDLE hevtSignaled);

    CPluggableConnection * GetPluggableConnection(PSocket pSocket);
    CPluggableConnection * GetPluggableConnection(UINT_PTR nConnID);
    CPluggableConnection * GetPluggableConnection(HANDLE hCommLink);
    CPluggableConnection * GetPluggableConnectionByLegacyHandle(LEGACY_HANDLE);

    //
    // legacy tranport
    //
    BOOL EnsureLegacyTransportLoaded(void);

private:

    LPFN_PLUGXPRT_CB            m_pfnNotify;
    LPVOID                      m_pContext;
    CPluggableConnectionList    m_PluggableConnectionList;
};

void OnProtocolControl(TransportConnection, PLUGXPRT_STATE,
                       PLUGXPRT_RESULT eResult = PLUGXPRT_RESULT_SUCCESSFUL);

ULONG CreateConnString(int nConnID, char szConnID[]);
BOOL IsValidPluggableTransportName(LPCSTR pcszNodeAddress);
UINT GetPluggableTransportConnID(LPCSTR pcszNodeAddress);
CPluggableConnection * GetPluggableConnection(PSocket pSocket);
CPluggableConnection * GetPluggableConnection(UINT_PTR nConnID);
CPluggableConnection * GetPluggableConnection(HANDLE hCommLink);
CPluggableConnection * GetPluggableConnectionByLegacyHandle(LEGACY_HANDLE);

int SubmitPluggableRead(PSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *);
int SubmitPluggableWrite(PSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *);
void PluggableWriteTheFirst(TransportConnection);
void PluggableShutdown(TransportConnection);


//
// PSTN framing
//
TransportError TReceiveBufferAvailable(void);
extern ILegacyTransport *g_pLegacyTransport;


extern BOOL g_fWinsockDisabled;
extern CRITICAL_SECTION g_csTransport;

#if defined(TEST_PLUGGABLE) && defined(_DEBUG)
LPCSTR FakeNodeAddress(LPCSTR pcszNodeAddress);
#endif

#endif // _T120_TRANSPORT_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\registry.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	registry.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the registry class implementation file. All registry operations
 *		at both the Top Provider and subordinate nodes.  It is responsible for
 *		queing registry request, maintaining the registry, sending confirms to
 *		the application SAP, etc.  Registry objects at sub-ordinate nodes are
 *		responsible for queuing up the registry request to be sent on to the
 *		Top Provider.  On of these classes should be created per node.  This
 *		class handles request from all existing application SAPs.
 *
 *		FOR A MORE DETAILED EXPLANATION OF THIS CLASS SEE THE INTERFACE FILE
 *
 *	Private Instance Variables:
 *  	m_pMCSUserObject
 *			Pointer to the User Attachment object used to deliver all registry
 *			request and responses to remote nodes.
 *		m_RegEntryList
 *			This is the list that holds all the registry entries associated 
 *			with this conference.
 *	 	m_fTopProvider
 *			This flag specifies if this is the top provider node (TRUE means
 *			this is the top provider node). 
 *		m_nCurrentTokenID
 *			This is a counter that is used to generate the token IDs by the 
 *			registry object at the top provider.
 *		m_nConfID
 *			Conference ID assocaited with this conference.
 *		m_pEmptyRegItem
 *			This is a pointer to an empty registry item that is used to generate
 *			empty items for PDUs that don't contain a registry item.
 *		m_AppSapEidList2
 *			This list contains pointers to the command target objects associated
 *			with each of the enrolled APEs
 *		m_nRegHandle
 *			This is a counter that is used to generate the handles allocated
 *			by the registry object at the top provider.
 *		m_pAppRosterMgrList
 *			This list hold all the current application roster managers and
 *			is used to verify that a requesting APE is actually enrolled with
 *			the conference.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */

#include "registry.h"
#include "appsap.h"

#define		FIRST_DYNAMIC_TOKEN_ID				16384
#define		MAXIMUM_ALLOWABLE_ALLOCATED_HANDLES	(16 * 1024) // for T.126


/*
 *	CRegistry()
 *
 *	Public Function Description
 *		This is the registry constructor.  It is responsible for initializing
 *		instance variables.
 *
 */
CRegistry::CRegistry(PMCSUser						user_object,
					BOOL    						top_provider,
					GCCConfID   					conference_id,
					CAppRosterMgrList				*app_roster_manager_list,
					PGCCError						pRetCode)
:
    CRefCount(MAKE_STAMP_ID('A','R','e','g')),
	m_AppSapEidList2(DESIRED_MAX_APP_SAP_ITEMS),
	m_pMCSUserObject(user_object),
	m_fTopProvider(top_provider),
	m_nCurrentTokenID(FIRST_DYNAMIC_TOKEN_ID),
	m_nConfID(conference_id),
	m_nRegHandle(0),
	m_pAppRosterMgrList(app_roster_manager_list)
{
	GCCRegistryItem		registry_item;

	*pRetCode = GCC_NO_ERROR;

	/*
	**	If this is the Top Provider we now build a vacant registry item to
	**	be used when an entry in the registry is being accessed that does not
	**	exists.
	*/
	if (m_fTopProvider)
	{
		registry_item.item_type = GCC_REGISTRY_NONE;
		DBG_SAVE_FILE_LINE
		m_pEmptyRegItem = new CRegItem(&registry_item, pRetCode);
		if (m_pEmptyRegItem == NULL || GCC_NO_ERROR != *pRetCode)
        {
			*pRetCode = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		m_pEmptyRegItem = NULL;
    }
}
        
/*
 *	~CRegistry()
 *
 *	Public Function Description
 *		This is the registry destructor. It is responsible for freeing any
 *		outstanding memory associated with the application registry.
 */
CRegistry::~CRegistry(void)
{
	REG_ENTRY *pRegEntry;

	m_RegEntryList.Reset();

	//	Free up any registry entries
	while (NULL != (pRegEntry = m_RegEntryList.Iterate()))
	{
		if (NULL != pRegEntry->registry_key)
		{
		    pRegEntry->registry_key->Release();
		}
		if (NULL != pRegEntry->entry_item)
		{
		    pRegEntry->entry_item->Release();
		}
		delete pRegEntry;
	}

	if (NULL != m_pEmptyRegItem)
	{
        m_pEmptyRegItem->Release();
	}
}

/*
 *	void	EnrollAPE ()
 *
 *	Public Function Description
 *		This routine is used to inform the application registry of a newly
 *		enrolling APE and its corresponding command target interface.
 */
void CRegistry::EnrollAPE(EntityID eid, CAppSap *pAppSap)
{
    m_AppSapEidList2.Append(eid, pAppSap);
}

/*
 *	void	UnEnrollApplicationSAP ()
 *
 *	Public Function Description
 *		This routine is used to inform the application registry of an 
 *		APE that is unerolling from the conference.
 *
 *	Caveats
 *		This routine removes ownership from all the entries currently owned by 
 *		the passed in application entity.  It will also remove any outstanding
 *		request for the SAP that unenrolled.
 */
void	CRegistry::UnEnrollAPE (	EntityID	entity_id )
{
	REG_ENTRY       *lpRegEntry;
	UserID			my_user_id = m_pMCSUserObject->GetMyNodeID();

	m_RegEntryList.Reset();
	while (NULL != (lpRegEntry = m_RegEntryList.Iterate()))
	{
		/*
		**	First we remove this APE from the list of nodes that are
		**	monitoring this entry.
		*/
		lpRegEntry->monitoring_list.Remove(entity_id);

		/*
		**	Next, if this is the top provider, we clean up the the 
		**	ownership properties of this entry and issue any PDUs and/or
		**	messages that are necessary.
		*/
		if (m_fTopProvider)
		{
			if ((lpRegEntry->owner_id == my_user_id) &&
				(lpRegEntry->entity_id == entity_id))
			{
				/*
				**	Ownership is removed from any registry entries this 
				**	entity owned.
				*/
				lpRegEntry->owner_id = 0;
				lpRegEntry->entity_id = 0;
		
				//	Send Monitor Indication if necessary
				if (lpRegEntry->monitoring_state == ON)
				{
					/*
					**	Deliver the monitor indication to the Top
					**	Provider's Node Controller if necessary.
					*/
					SendMonitorEntryIndicationMessage (lpRegEntry);
				
					m_pMCSUserObject->RegistryMonitorEntryIndication(
							lpRegEntry->registry_key,
							lpRegEntry->entry_item,
							lpRegEntry->owner_id,
							lpRegEntry->entity_id,
							lpRegEntry->modification_rights);
				}
			}
		}
	}

	//	Remove this enity from the command target list if it exists.	
	m_AppSapEidList2.Remove(entity_id);
}

/*
 *	GCCError	RegisterChannel ()
 *
 *	Public Function Description
 *		This routine is responsible for registering a specified channel.
 *		It has two different paths of execution based on whether this is
 *		a Top Provider registry or a subordinate node registry object.
 */
GCCError	CRegistry::RegisterChannel (
										PGCCRegistryKey		registry_key,
										ChannelID			channel_id,
										EntityID			entity_id)
{
	GCCError			rc = GCC_NO_ERROR;
	REG_ENTRY           *registry_entry = NULL; // a must
	CRegKeyContainer    *registry_key_data = NULL; // a must
	CRegItem            *registry_item_data = NULL; // a must
	GCCRegistryItem		registry_item;
	CAppSap	            *requester_sap;
	
	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
		return (GCC_APP_NOT_ENROLLED);

	/*
	**	Next set up the Registry Key and Registry Item. Return immediately if
	**	a resource failure occurs.
	*/
	DBG_SAVE_FILE_LINE
	registry_key_data = new CRegKeyContainer(registry_key, &rc);
	if (NULL == registry_key_data || GCC_NO_ERROR != rc)
	{
	    ERROR_OUT(("CRegistry::RegisterChannel: can't create regitry key"));
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	if (m_fTopProvider == FALSE)
	{
		m_pMCSUserObject->RegistryRegisterChannelRequest(registry_key_data, channel_id, entity_id);

		//	The registry key data object is no longer needed here
		registry_key_data->Release();
        rc = GCC_NO_ERROR;
        goto MyExit;
	}

    // no PDU is sent when request occurs at the top provider

	/*
	**	First check to see if the registry entry exists and if it 
	**	does check the ownership to make sure this node has 
	**	permission to change the entry.
	*/
	registry_entry = GetRegistryEntry(registry_key_data);
	if (registry_entry != NULL)
	{
		//	Entry already exists, send back negative result
		requester_sap->RegistryConfirm(
								m_nConfID,
								GCC_REGISTER_CHANNEL_CONFIRM,
								registry_entry->registry_key,
								registry_entry->entry_item,
								registry_entry->modification_rights,
								registry_entry->owner_id,
								registry_entry->entity_id,
								FALSE,
								GCC_RESULT_ENTRY_ALREADY_EXISTS);

		//	The registry key data object is no longer needed
		registry_key_data->Release();
		rc = GCC_NO_ERROR;
		goto MyExit;
	}

	//	Set up the registry item here
	registry_item.item_type = GCC_REGISTRY_CHANNEL_ID;
	registry_item.channel_id = channel_id;

	DBG_SAVE_FILE_LINE
	registry_item_data = new CRegItem(&registry_item, &rc);
	if (registry_item_data == NULL || GCC_NO_ERROR != rc)
	{
	    ERROR_OUT(("CRegistry::RegisterChannel: can't create regitry item"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	//	Since entry does not exists create it here
	DBG_SAVE_FILE_LINE
	registry_entry = new REG_ENTRY;
	if (registry_entry == NULL)
	{
	    ERROR_OUT(("CRegistry::RegisterChannel: can't create regitry entry"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	//	Fill in the new entry
	registry_entry->registry_key = registry_key_data;
	registry_entry->entry_item = registry_item_data;
	registry_entry->monitoring_state = OFF;
	registry_entry->owner_id = m_pMCSUserObject->GetMyNodeID();
	registry_entry->entity_id = entity_id;

	/*
	**	Initialize to public incase entry is switched to
	**	a parameter.  Note that as long as the entry is
	**	not a PARAMETER modification rights will not be
	**	used.
	*/
	registry_entry->modification_rights = GCC_PUBLIC_RIGHTS;

	//	Add registry entry to registry list
	m_RegEntryList.Append(registry_entry);

	//	Send success for the result
	requester_sap->RegistryConfirm (
						m_nConfID,
						GCC_REGISTER_CHANNEL_CONFIRM,
						registry_entry->registry_key,
						registry_entry->entry_item,
						registry_entry->modification_rights,
						registry_entry->owner_id,
						registry_entry->entity_id,
						FALSE,
						GCC_RESULT_SUCCESSFUL);

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        if (NULL != registry_key_data)
        {
            registry_key_data->Release();
        }
        if (NULL != registry_item_data)
        {
            registry_item_data->Release();
        }
        if(registry_entry)
        {
	        delete  registry_entry;
        } 
    }

	return (rc);
}

/*
 *	GCCError	AssignToken ()
 *
 *	Public Function Description
 *		This routine is responsible for generating and registering a new token.
 *		It has two different paths of execution based on whether this is
 *		a Top Provider registry or a subordinate node registry object.
 */
GCCError	CRegistry::AssignToken (
										PGCCRegistryKey		registry_key,
										EntityID			entity_id )
{
	GCCError			rc = GCC_NO_ERROR;
	REG_ENTRY           *registry_entry = NULL; // a must
	CRegKeyContainer    *registry_key_data = NULL; // a must
	CRegItem            *registry_item_data = NULL; // a must
	GCCRegistryItem		registry_item;
	CAppSap              *requester_sap;
	
	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
		return (GCC_APP_NOT_ENROLLED);

	DBG_SAVE_FILE_LINE
	registry_key_data = new CRegKeyContainer(registry_key, &rc);
	if ((registry_key_data == NULL) || (rc != GCC_NO_ERROR))
	{
	    ERROR_OUT(("CRegistry::AssignToken: can't create regitry key"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	if (m_fTopProvider == FALSE)
	{
		m_pMCSUserObject->RegistryAssignTokenRequest(registry_key_data, entity_id);

		//	The registry key data object is no longer needed here
		registry_key_data->Release();
        rc = GCC_NO_ERROR;
        goto MyExit;
	}

    // no PDU is sent when request occurs at the top provider

	/*
	**	First check to see if the registry entry exists and if it 
	**	does check the ownership to make sure this node has 
	**	permission to change the entry.
	*/
	registry_entry = GetRegistryEntry(registry_key_data);
	if (registry_entry != NULL)
	{
		//	Entry already exists, send back negative result
		requester_sap->RegistryConfirm(
								m_nConfID,
								GCC_ASSIGN_TOKEN_CONFIRM,
								registry_entry->registry_key,
								registry_entry->entry_item,
								registry_entry->modification_rights,
								registry_entry->owner_id,
								registry_entry->entity_id,
								FALSE,
								GCC_RESULT_ENTRY_ALREADY_EXISTS);

		//	The registry key data object is no longer needed
		registry_key_data->Release();
        rc = GCC_NO_ERROR;
        goto MyExit;
	}

	//	Set up the registry item here
	registry_item.item_type = GCC_REGISTRY_TOKEN_ID;
	registry_item.token_id = GetUnusedToken();

	DBG_SAVE_FILE_LINE
	registry_item_data = new CRegItem(&registry_item, &rc);
	if ((registry_item_data == NULL) || (rc != GCC_NO_ERROR))
	{
	    ERROR_OUT(("CRegistry::AssignToken: can't create regitry item"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	DBG_SAVE_FILE_LINE
	registry_entry = new REG_ENTRY;
	if (registry_entry == NULL)
	{
	    ERROR_OUT(("CRegistry::AssignToken: can't create regitry entry"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	//	Fill in the new entry
	registry_entry->registry_key = registry_key_data;
	registry_entry->entry_item = registry_item_data;
	registry_entry->monitoring_state = OFF;
	registry_entry->owner_id = m_pMCSUserObject->GetMyNodeID();
	registry_entry->entity_id = entity_id;

	/*
	**	Initialize to public incase entry is switched to
	**	a parameter.  Note that as long as the entry is
	**	not a PARAMETER modification rights will not be
	**	used.
	*/
	registry_entry->modification_rights = GCC_PUBLIC_RIGHTS;

	//	Add registry entry to registry list
	m_RegEntryList.Append(registry_entry);

	//	Send success for the result
	requester_sap->RegistryConfirm (
						m_nConfID,
						GCC_ASSIGN_TOKEN_CONFIRM,
						registry_entry->registry_key,
						registry_entry->entry_item,
             			registry_entry->modification_rights,
						registry_entry->owner_id,
						registry_entry->entity_id,
						FALSE,
						GCC_RESULT_SUCCESSFUL);

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        if (NULL != registry_key_data)
        {
            registry_key_data->Release();
        }
        if (NULL != registry_item_data)
        {
            registry_item_data->Release();
        }
        delete registry_entry;
    }

	return (rc);
}

/*
 *	GCCError	SetParameter ()
 *
 *	Public Function Description
 *		This routine is responsible for generating and registering a new token.
 *		It has two different paths of execution based on whether this is
 *		a Top Provider registry or a subordinate node registry object.
 */
GCCError	CRegistry::SetParameter (
								PGCCRegistryKey			registry_key,
								LPOSTR			        parameter_value,
								GCCModificationRights	modification_rights,
								EntityID				entity_id )
{
	GCCError			rc = GCC_NO_ERROR;
	REG_ENTRY           *registry_entry = NULL; // a must
	CRegKeyContainer    *registry_key_data = NULL; // a must
	CRegItem            *registry_item_data = NULL; // a must
	GCCResult			result;
	GCCRegistryItem		registry_item;
	BOOL    			application_is_enrolled = FALSE;
	CAppSap              *requester_sap;
	
	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
		return (GCC_APP_NOT_ENROLLED);

	DBG_SAVE_FILE_LINE
	registry_key_data = new CRegKeyContainer(registry_key, &rc);
	if ((registry_key_data == NULL) || (rc != GCC_NO_ERROR))
	{
	    ERROR_OUT(("CRegistry::SetParameter: can't create regitry key"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	if (m_fTopProvider == FALSE)
	{
		m_pMCSUserObject->RegistrySetParameterRequest(registry_key_data,
												parameter_value,
												modification_rights,
												entity_id);

		//	The registry key data object is no longer needed here
		registry_key_data->Release();
        rc = GCC_NO_ERROR;
        goto MyExit;
	}

    // no PDU is sent when request occurs at the top provider

	//	Set up the registry item here
	if (parameter_value != NULL)
	{
		registry_item.item_type = GCC_REGISTRY_PARAMETER;
		registry_item.parameter = *parameter_value;
	}
	else
	{
		registry_item.item_type = GCC_REGISTRY_NONE;
	}

	DBG_SAVE_FILE_LINE
	registry_item_data = new CRegItem(&registry_item, &rc);
	if ((registry_item_data == NULL) || (rc != GCC_NO_ERROR))
	{
	    ERROR_OUT(("CRegistry::SetParameter: can't create regitry item"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	/*
	**	First check to see if the registry entry exists and if it 
	**	does check the ownership and modification rights to make 
	**	sure this node has permission to change the entry.
	*/
	registry_entry = GetRegistryEntry(registry_key_data);
	if (registry_entry != NULL)
	{
		/*
		**	Here we make sure that this request is comming from an 
		**	APE that previously enrolled.  
		*/
		CAppRosterMgr				*lpAppRosterMgr;

		m_pAppRosterMgrList->Reset();
		while (NULL != (lpAppRosterMgr = m_pAppRosterMgrList->Iterate()))
		{
			if (lpAppRosterMgr->IsAPEEnrolled(registry_key_data->GetSessionKey(),
								            m_pMCSUserObject->GetMyNodeID(),
								            entity_id))
			{
				application_is_enrolled = TRUE;
				break;
			}
		}

		/*
		**	Check ownership rights here: First check is to make
		**	sure that this is the owner if Owner rights is 
		**	specified.  Next check is to make sure that
		*/ 
		if (((registry_entry->modification_rights == GCC_OWNER_RIGHTS) && 
			(registry_entry->owner_id == m_pMCSUserObject->GetMyNodeID()) &&
			 (registry_entry->entity_id == entity_id)) ||
			((registry_entry->modification_rights == GCC_SESSION_RIGHTS) && 
			(application_is_enrolled)) ||
			(registry_entry->modification_rights == GCC_PUBLIC_RIGHTS) ||
			(registry_entry->owner_id == 0))
		{
			/*
			**	Monitoring state should not be affected by 
			**	this request.
			*/
			*registry_entry->entry_item = *registry_item_data;
			
			/*
			**	Only the owner is allowed to change the modification
			**	rights of a registry entry (unless the entry is
			**	unowned). Also if there is no owner, we set up the
			**	new owner here.
			*/
			if (((registry_entry->owner_id == m_pMCSUserObject->GetMyNodeID()) &&
				(registry_entry->entity_id == entity_id)) ||
				(registry_entry->owner_id == 0))
			{
				registry_entry->owner_id = m_pMCSUserObject->GetMyNodeID();
				registry_entry->entity_id = entity_id;
				/*
				**	If no modification rights are specified we must
				**	set the modification rights to be public.
				*/
				if (modification_rights != GCC_NO_MODIFICATION_RIGHTS_SPECIFIED)
				{
					registry_entry->modification_rights = modification_rights;
				}
			}

			//	Send Monitor Indication if necessary
			if (registry_entry->monitoring_state == ON)
			{
				/*
				**	Deliver the monitor indication to the Top
				**	Provider's Node Controller if necessary.
				*/
				SendMonitorEntryIndicationMessage(registry_entry);

				/*
				**	Broadcast a monitor entry indication to all
				**	nodes in the conference.
				*/
				m_pMCSUserObject->RegistryMonitorEntryIndication(
						registry_entry->registry_key,
						registry_entry->entry_item,
						registry_entry->owner_id,
						registry_entry->entity_id,
						registry_entry->modification_rights);
			}

			//	Send success for the result
			result = GCC_RESULT_SUCCESSFUL;
		}
		else
		{
			result = GCC_RESULT_INDEX_ALREADY_OWNED;
		}

		requester_sap->RegistryConfirm(
								m_nConfID,
								GCC_SET_PARAMETER_CONFIRM,
								registry_entry->registry_key,
								registry_entry->entry_item,
                     			registry_entry->modification_rights,
								registry_entry->owner_id,
								registry_entry->entity_id,
								FALSE,
								result);

		//	The registry key data object is no longer needed
		registry_key_data->Release();

		//	The registry item data object is no longer needed
		registry_item_data->Release();

		rc = GCC_NO_ERROR;
		goto MyExit;
	}

    // registry entry does not exist, create one.
	DBG_SAVE_FILE_LINE
	registry_entry = new REG_ENTRY;
	if (registry_entry == NULL)
	{
	    ERROR_OUT(("CRegistry::SetParameter: can't create regitry entry"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	//	Fill in the new entry
	registry_entry->registry_key = registry_key_data;
	registry_entry->entry_item = registry_item_data;
	registry_entry->monitoring_state = OFF;
	registry_entry->owner_id = m_pMCSUserObject->GetMyNodeID();
	registry_entry->entity_id = entity_id;

	/*
	**	If no modification rights are specified we must
	**	initialize the modification rights to be public.
	**	Note that modification rights are only specified
	**	for the SetParameter call.
	*/
	registry_entry->modification_rights =
	        (modification_rights == GCC_NO_MODIFICATION_RIGHTS_SPECIFIED) ?
                GCC_PUBLIC_RIGHTS :
				modification_rights;

	//	Add registry entry to registry list
	m_RegEntryList.Append(registry_entry);

	//	Send success for the result
	requester_sap->RegistryConfirm(
						m_nConfID,
						GCC_SET_PARAMETER_CONFIRM,
						registry_entry->registry_key,
						registry_entry->entry_item,
             			registry_entry->modification_rights,
						registry_entry->owner_id,
						registry_entry->entity_id,
						FALSE,
						GCC_RESULT_SUCCESSFUL);

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        if (NULL != registry_key_data)
        {
            registry_key_data->Release();
        }
        if (NULL != registry_item_data)
        {
            registry_item_data->Release();
        }
        delete registry_entry;
    }

	return (rc);
}

/*
 *	GCCError	RetrieveEntry ()
 *
 *	Public Function Description
 *		This routine is used by a local APE to obtain an item that was 
 *		registered with GCC.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 */
GCCError	CRegistry::RetrieveEntry (
										PGCCRegistryKey		registry_key,
										EntityID			entity_id )
{
	GCCError					rc;
	REG_ENTRY                   *registry_entry;
	CRegKeyContainer       		*registry_key_data = NULL; // a must
	CAppSap                     *requester_sap;
	
	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
	{
		return GCC_APP_NOT_ENROLLED;
	}

	DBG_SAVE_FILE_LINE
	registry_key_data = new CRegKeyContainer(registry_key, &rc);
	if ((registry_key_data == NULL) || (rc != GCC_NO_ERROR))
	{
	    ERROR_OUT(("CRegistry::RetrieveEntry: can't create regitry key"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	if (m_fTopProvider == FALSE)
	{
		m_pMCSUserObject->RegistryRetrieveEntryRequest(registry_key_data, entity_id);
		rc = GCC_NO_ERROR;
		goto MyExit;
	}

    // no PDU is sent when request occurs at the top provider

	registry_entry = GetRegistryEntry(registry_key_data);
	if (registry_entry != NULL)
	{
		//	Send back a positive result with the entry item
		requester_sap->RegistryConfirm(
								m_nConfID,
								GCC_RETRIEVE_ENTRY_CONFIRM,
								registry_entry->registry_key,
								registry_entry->entry_item,
								registry_entry->modification_rights,
								registry_entry->owner_id,
								registry_entry->entity_id,
								FALSE,
								GCC_RESULT_SUCCESSFUL);
	}
	else
	{
		//	Send back a negative result
		requester_sap->RegistryConfirm(
								m_nConfID,
								GCC_RETRIEVE_ENTRY_CONFIRM,
								registry_key_data,
								m_pEmptyRegItem,
								GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
								0,	//	No owner id
								0,	//	No entity id
								FALSE,
								GCC_RESULT_ENTRY_DOES_NOT_EXIST);
	}

    rc = GCC_NO_ERROR;

MyExit:

    if (NULL != registry_key_data)
    {
        registry_key_data->Release();
    }

	return (rc);
}

/*
 *	GCCError	DeleteEntry ()
 *
 *	Public Function Description
 *		This routine is used by a local APE to delete an item that was 
 *		registered with GCC.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 */
GCCError	CRegistry::DeleteEntry (
										PGCCRegistryKey		registry_key,
										EntityID			entity_id )
{
	GCCError			rc;
	REG_ENTRY           *registry_entry;
	CRegKeyContainer    *registry_key_data = NULL; // a must
	CAppSap             *requester_sap;

	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
	{
		return GCC_APP_NOT_ENROLLED;
	}

	DBG_SAVE_FILE_LINE
	registry_key_data = new CRegKeyContainer(registry_key, &rc);
	if ((registry_key_data == NULL) || (rc != GCC_NO_ERROR))
	{
	    ERROR_OUT(("CRegistry::DeleteEntry: can't create regitry key"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	if (m_fTopProvider == FALSE)
	{
		m_pMCSUserObject->RegistryDeleteEntryRequest(registry_key_data, entity_id);
        rc = GCC_NO_ERROR;
        goto MyExit;
	}

    // no PDU is sent when request occurs at the top provider

	/*
	**	First check to see if the registry entry exists and if it does
	**	check the ownership to make sure this node has permission to
	**	change the entry.
	*/
	registry_entry = GetRegistryEntry(registry_key_data);
	if (registry_entry != NULL)
	{
		if (((registry_entry->owner_id == m_pMCSUserObject->GetMyNodeID()) &&
			 (registry_entry->entity_id == entity_id)) ||
			(registry_entry->owner_id == 0))
		{
			/*
			**	First convert this to a non-entry incase it needs to
			**	be included in a monitor indication. We first delete
			**	the old entry item and replace it with an Emtpy item.
			*/
			registry_entry->entry_item->Release();
			registry_entry->entry_item = m_pEmptyRegItem;

			registry_entry->owner_id = 0;
			registry_entry->entity_id = 0;
			registry_entry->modification_rights = GCC_NO_MODIFICATION_RIGHTS_SPECIFIED;

			//	Send Monitor Indication if necessary
			if (registry_entry->monitoring_state == ON)
			{
				/*
				**	Deliver the monitor indication to the Top
				**	Provider's Node Controller if necessary.
				*/
				SendMonitorEntryIndicationMessage(registry_entry);

				/*
				**	Broadcast a monitor entry indication to all
				**	nodes in the conference.
				*/
				m_pMCSUserObject->RegistryMonitorEntryIndication(
							registry_entry->registry_key,
							registry_entry->entry_item,
							registry_entry->owner_id,
							registry_entry->entity_id,
							registry_entry->modification_rights);
			}

			m_RegEntryList.Remove(registry_entry);

			if (NULL != registry_entry->registry_key)
			{
			    registry_entry->registry_key->Release();
			}
			delete registry_entry;

			//	Send success for the result
			requester_sap->RegistryConfirm(
								m_nConfID,
								GCC_DELETE_ENTRY_CONFIRM,
								registry_key_data,
								NULL,
								GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
								0,
								0,
								FALSE,
								GCC_RESULT_SUCCESSFUL);
		}
		else
		{
			//	No ownership rights send back negative result
			requester_sap->RegistryConfirm (
									m_nConfID,
									GCC_DELETE_ENTRY_CONFIRM,
									registry_entry->registry_key,
									registry_entry->entry_item,
									registry_entry->modification_rights,
									registry_entry->owner_id,
									registry_entry->entity_id,
									FALSE,
									GCC_RESULT_INDEX_ALREADY_OWNED);
		}
	}
	else
	{
		//	Send failure for the result. Entry does not exist
		requester_sap->RegistryConfirm (
								m_nConfID,
								GCC_DELETE_ENTRY_CONFIRM,
								registry_key_data,
								NULL,
								GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
								0,
								0,
								FALSE,
								GCC_RESULT_ENTRY_DOES_NOT_EXIST);
	}

    rc = GCC_NO_ERROR;

MyExit:

	//	The registry key data object is no longer needed here
	if (NULL != registry_key_data)
	{
	    registry_key_data->Release();
	}

	return (rc);
}

/*
 *	GCCError	MonitorRequest ()
 *
 *	Public Function Description
 *		This routine is used by a local APE to monitor an item that was 
 *		registered with GCC.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 */
GCCError	CRegistry::MonitorRequest (
							PGCCRegistryKey			registry_key,
							BOOL    				enable_delivery,
							EntityID				entity_id )
{
	GCCError			rc = GCC_NO_ERROR;
	REG_ENTRY           *registry_entry;
	CRegKeyContainer    *registry_key_data;
	GCCResult			result = GCC_RESULT_SUCCESSFUL;
	CAppSap	            *requester_sap;
    BOOL                fToConfirm = FALSE;

	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
	{
		return GCC_APP_NOT_ENROLLED;
    }

	/*
	**	First set up the Registry Key. Return immediately if a resource 
	**	failure occurs.
	*/
	DBG_SAVE_FILE_LINE
	registry_key_data = new CRegKeyContainer(registry_key, &rc);
	if ((registry_key_data != NULL) && (rc == GCC_NO_ERROR))
	{
		/*
		**	If the request is recieved at a node that is not the top 
		**	provider we must send the request on to the top provider.
		*/
		if (m_fTopProvider == FALSE)
		{
			if (enable_delivery)
			{
				/*
				**	Here we first go ahead and add the requesting APE to the
				**	list of applications wishing to monitor this particular 
				**	entry.  Note that if this entry does not exists at the top 
				**	provider, this entry will be removed during the confirm.
				*/
				rc = AddAPEToMonitoringList(registry_key_data, entity_id, requester_sap);
				if (rc == GCC_NO_ERROR)
				{
					/*
					**	Wait for the response before sending the confirm
					**	if we get this far.
					*/
					m_pMCSUserObject->RegistryMonitorRequest(registry_key_data, entity_id);
				}
				else
				{
					result = GCC_RESULT_RESOURCES_UNAVAILABLE;
					fToConfirm = TRUE;
				}
			}
			else
			{
				RemoveAPEFromMonitoringList(registry_key_data, entity_id);
                result = GCC_RESULT_SUCCESSFUL;
				fToConfirm = TRUE;
			}
		}
		else	//	No PDU is sent when request occurs at the top provider
		{
			if (enable_delivery)
			{
				/*
				**	First check to see if the registry entry exists.  If it does
				**	not we go ahead and create an empty entry so that we can
				**	add the monitoring APE to that entries list of monitoring 
				**	APEs.
				*/
				registry_entry = GetRegistryEntry(registry_key_data);
				if (registry_entry != NULL)
				{
					/*
					**	Here we go ahead and add the requesting APE to the
					**	list of applications wishing to monitor this entry.
					*/
					rc = AddAPEToMonitoringList(registry_key_data, entity_id, requester_sap);
					if (rc == GCC_NO_ERROR)
					{
						//	Set the monitoring state to ON
						registry_entry->monitoring_state = ON;
					}
					else
                    {
						result = GCC_RESULT_RESOURCES_UNAVAILABLE;
                    }
				}
				else
                {
					result = GCC_RESULT_ENTRY_DOES_NOT_EXIST;
                }
			}
			else
			{
				RemoveAPEFromMonitoringList(registry_key_data, entity_id);
			}
			fToConfirm = TRUE;
		}
	}
	else
    {
        ERROR_OUT(("CRegistry::MonitorRequest: can't create registry key"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    if (fToConfirm)
    {
        ASSERT(NULL != registry_key_data);
        requester_sap->RegistryConfirm(
                            m_nConfID,
                            GCC_MONITOR_CONFIRM,
                            registry_key_data,
                            NULL,
                            GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
                            0,
                            0,
                            enable_delivery,
                            result);
    }

	//	The registry key data object is no longer needed
    if (NULL != registry_key_data)
    {
        registry_key_data->Release();
    }

    return (rc);
}

/*
 *	GCCError	AllocateHandleRequest ()
 *
 *	Public Function Description
 *		This routine is used by a local APE to allocate a specified number of
 *		handles from the application registry.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 */
GCCError CRegistry::AllocateHandleRequest(
							UINT					number_of_handles,
							EntityID				entity_id )
{
	UINT				temp_registry_handle;
	CAppSap              *requester_sap;
	
	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
	{
		return GCC_APP_NOT_ENROLLED;
	}

	if (m_fTopProvider == FALSE)
	{
		m_pMCSUserObject->RegistryAllocateHandleRequest(number_of_handles, entity_id);
	}
	else	//	No PDU is sent when request occurs at the top provider
	{
	    UINT nFirstHandle = 0;
	    GCCResult nResult;
		if ((number_of_handles > 0) &&
			(number_of_handles <= MAXIMUM_ALLOWABLE_ALLOCATED_HANDLES))
		{
			temp_registry_handle = m_nRegHandle + number_of_handles;
			if (temp_registry_handle > m_nRegHandle)
			{
			    nFirstHandle = m_nRegHandle;
			    nResult = GCC_RESULT_SUCCESSFUL;

				m_nRegHandle = temp_registry_handle;
			}
			else
			{
			    ASSERT(0 == nFirstHandle);
			    nResult = GCC_RESULT_NO_HANDLES_AVAILABLE;
			}
		}
		else
		{
		    ASSERT(0 == nFirstHandle);
		    nResult = GCC_RESULT_INVALID_NUMBER_OF_HANDLES;
		}

		requester_sap->RegistryAllocateHandleConfirm (
								m_nConfID,
								number_of_handles,
								nFirstHandle,
								nResult);
	}

	return (GCC_NO_ERROR);
}

/*
 *	GCCError	ProcessRegisterChannelPDU ()
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process incomming
 *		register channel PDUs.  It is responsible for returning any
 *		necessary responses that must be sent back to the requesting node.
 */
GCCError	CRegistry::ProcessRegisterChannelPDU (
									CRegKeyContainer    *registry_key_data,
									ChannelID			channel_id,
									UserID				requester_node_id,
									EntityID			requester_entity_id )
{
	GCCError					rc = GCC_NO_ERROR;
	REG_ENTRY                   *registry_entry;
	CRegItem                    *registry_item_data;
	GCCRegistryItem				registry_item;
	BOOL    					application_is_enrolled = FALSE;
	CAppRosterMgr				*lpAppRosterMgr;
	
	/*
	**	We first make sure that this request is comming from an APE that
	**	previously enrolled.  Here we are not worried about a specific
	**	session, only that the APE is enrolled.  
	*/
	m_pAppRosterMgrList->Reset();
	while (NULL != (lpAppRosterMgr = m_pAppRosterMgrList->Iterate()))
	{
		if (lpAppRosterMgr->IsAPEEnrolled (requester_node_id, requester_entity_id))
		{
			application_is_enrolled = TRUE;
			break;
		}
	}

	if (application_is_enrolled)
	{
		/*
		**	Next check to see if the registry entry exists and if it does
		**	check the ownership to make sure this node has permission to
		**	change the entry.
		*/
		registry_entry = GetRegistryEntry (	registry_key_data );
		if (registry_entry != NULL)
		{
			//	Entry already exists, send back negative result
			m_pMCSUserObject->RegistryResponse(
								  	REGISTER_CHANNEL,	
									requester_node_id,
									requester_entity_id,
								   	registry_key_data,
								   	registry_entry->entry_item,
								   	registry_entry->modification_rights,
									registry_entry->owner_id,
									registry_entry->entity_id,
							    	GCC_RESULT_ENTRY_ALREADY_EXISTS);
		}
		else
		{
			registry_item.item_type = GCC_REGISTRY_CHANNEL_ID;
			registry_item.channel_id = channel_id;

			DBG_SAVE_FILE_LINE
			registry_item_data = new CRegItem(&registry_item, &rc);
			if ((registry_item_data != NULL) && (rc == GCC_NO_ERROR))
			{
				DBG_SAVE_FILE_LINE
				registry_entry = new REG_ENTRY;
				if (registry_entry != NULL)
				{
					//	Fill in the new entry
					DBG_SAVE_FILE_LINE
					registry_entry->registry_key = new CRegKeyContainer(registry_key_data, &rc);
					if ((registry_entry->registry_key != NULL) && (rc == GCC_NO_ERROR))
					{
						registry_entry->entry_item = registry_item_data;
						registry_entry->monitoring_state = OFF;
						registry_entry->owner_id = requester_node_id;
						registry_entry->entity_id = requester_entity_id;
					
						/*
						**	Initialize to public incase entry is switched to
						**	a parameter.  Note that as long as the entry is
						**	not a PARAMETER modification rights will not be
						**	used.
						*/
						registry_entry->modification_rights = GCC_PUBLIC_RIGHTS;
					
						m_RegEntryList.Append(registry_entry);
					
						//	Send success for the result
						m_pMCSUserObject->RegistryResponse(
											REGISTER_CHANNEL,	
											requester_node_id,
											requester_entity_id,
										   	registry_entry->registry_key,
										   	registry_entry->entry_item,
										   	registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
									    	GCC_RESULT_SUCCESSFUL);
					}
					else if (registry_entry->registry_key == NULL)
					{
						delete registry_entry;
						registry_item_data->Release();
						rc = GCC_ALLOCATION_FAILURE;
					}
					else
					{
						registry_entry->registry_key->Release();
						delete registry_entry;
						registry_item_data->Release();
					}
				}
				else
                {
					rc = GCC_ALLOCATION_FAILURE;
                }
			}
			else if (registry_item_data == NULL)
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
			else
            {
				registry_item_data->Release();
            }
		}
	}
	else
	{
		//	Send back negative result stating invalid requester
		m_pMCSUserObject->RegistryResponse(
								REGISTER_CHANNEL,	
								requester_node_id,
								requester_entity_id,
						   		registry_key_data,
						   		NULL,
						   		GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
								0,
								0,
					    		GCC_RESULT_INVALID_REQUESTER);
	}

	return (rc);
}

/*
 *	GCCError	ProcessAssignTokenPDU ()			    
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process incomming
 *		register token PDUs.  It is responsible for returning any
 *		necessary responses that must be sent back to the requesting node.
 */
GCCError	CRegistry::ProcessAssignTokenPDU (
									CRegKeyContainer    *registry_key_data,
									UserID				requester_node_id,
									EntityID			requester_entity_id )
{
	GCCError					rc = GCC_NO_ERROR;
	REG_ENTRY                   *registry_entry;
	CRegItem                    *registry_item_data;
	GCCRegistryItem				registry_item;
	BOOL    					application_is_enrolled = FALSE;
	CAppRosterMgr				*lpAppRosterMgr;

	/*
	**	We first make sure that this request is comming from an APE that
	**	previously enrolled.  Here we are not worried about a specific
	**	session, only that the APE is enrolled.  
	*/
	m_pAppRosterMgrList->Reset();
	while (NULL != (lpAppRosterMgr = m_pAppRosterMgrList->Iterate()))
	{
		if (lpAppRosterMgr->IsAPEEnrolled (requester_node_id, requester_entity_id))
		{
			application_is_enrolled = TRUE;
			break;
		}
	}
	
	if (application_is_enrolled)
	{
		/*
		**	First check to see if the registry entry exists and if it does
		**	check the ownership to make sure this node has permission to
		**	change the entry.
		*/
		registry_entry = GetRegistryEntry (	registry_key_data );
		if (registry_entry != NULL)
		{
			//	Entry already exists, send back negative result
			m_pMCSUserObject->RegistryResponse(ASSIGN_TOKEN,
											requester_node_id,
											requester_entity_id,
										   	registry_key_data,
											registry_entry->entry_item,
									   		registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
									  		GCC_RESULT_ENTRY_ALREADY_EXISTS);
		}
		else
		{
			DBG_SAVE_FILE_LINE
			registry_entry = new REG_ENTRY;
			if (registry_entry != NULL)
			{
				registry_item.item_type = GCC_REGISTRY_TOKEN_ID;
				registry_item.token_id = GetUnusedToken();

				DBG_SAVE_FILE_LINE
				registry_item_data = new CRegItem(&registry_item, &rc);
				if ((registry_item_data != NULL) && (rc == GCC_NO_ERROR))
				{
					//	Fill in the new entry
					DBG_SAVE_FILE_LINE
					registry_entry->registry_key = new CRegKeyContainer(registry_key_data, &rc);
					if ((registry_entry->registry_key != NULL) && (rc == GCC_NO_ERROR))
					{
						registry_entry->entry_item = registry_item_data;
						registry_entry->monitoring_state = OFF;
						registry_entry->owner_id = requester_node_id;
						registry_entry->entity_id = requester_entity_id;
					
						/*
						**	Initialize to public incase entry is switched to
						**	a parameter.  Note that as long as the entry is
						**	not a PARAMETER modification rights will not be
						**	used.
						*/
						registry_entry->modification_rights = GCC_PUBLIC_RIGHTS;
					
						//	Add registry entry to registry list
						m_RegEntryList.Append(registry_entry);
						
						//	Send success for the result
						m_pMCSUserObject->RegistryResponse(
											ASSIGN_TOKEN,
											requester_node_id,
											requester_entity_id,
									   		registry_key_data,
									   		registry_entry->entry_item,
						   					registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
								    		GCC_RESULT_SUCCESSFUL);
					}
					else  if (registry_entry->registry_key == NULL)
					{
						registry_item_data->Release();
						delete registry_entry;
						rc = GCC_ALLOCATION_FAILURE;
					}
					else
					{
						registry_entry->registry_key->Release();
						registry_item_data->Release();
						delete registry_entry;
					}
				}
				else
				{
					if (registry_item_data == NULL)
                    {
						rc = GCC_ALLOCATION_FAILURE;
                    }
					else
                    {
						registry_item_data->Release();
                    }
						
					delete registry_entry;
				}
			}
			else
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
		}
	}
	else
	{
		m_pMCSUserObject->RegistryResponse(
								ASSIGN_TOKEN,	
								requester_node_id,
								requester_entity_id,
						   		registry_key_data,
						   		NULL,
						   		GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
								0,
								0,
					    		GCC_RESULT_INVALID_REQUESTER);
	}
	
	return (rc);
}

/*
 *	GCCError	ProcessSetParameterPDU ()			    
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process incomming
 *		register parameter PDUs.  It is responsible for returning any
 *		necessary responses that must be sent back to the requesting node.
 */
GCCError	CRegistry::ProcessSetParameterPDU (
								CRegKeyContainer        *registry_key_data,
								LPOSTR                  parameter_value,
								GCCModificationRights	modification_rights,
								UserID					requester_node_id,
								EntityID				requester_entity_id )
{
	GCCError					rc = GCC_NO_ERROR;
	REG_ENTRY                   *registry_entry;
	CRegItem                    *registry_item_data;
	GCCResult					result;
	GCCRegistryItem				registry_item;
	BOOL    					application_is_enrolled = FALSE;
	CAppRosterMgr				*lpAppRosterMgr;
	
	/*
	**	We first make sure that this request is comming from an APE that
	**	previously enrolled.  Here we are not worried about a specific
	**	session, only that the APE is enrolled.  
	*/
	m_pAppRosterMgrList->Reset();
	while (NULL != (lpAppRosterMgr = m_pAppRosterMgrList->Iterate()))
	{
		if (lpAppRosterMgr->IsAPEEnrolled (requester_node_id, requester_entity_id))
		{
			application_is_enrolled = TRUE;
			break;
		}
	}
	
	if (application_is_enrolled)
	{
		//	Set up the registry item 
		if (parameter_value != NULL)
		{
			registry_item.item_type = GCC_REGISTRY_PARAMETER;
			registry_item.parameter = *parameter_value;
		}
		else
			registry_item.item_type = GCC_REGISTRY_NONE;
			
		/*
		**	Check to see if the registry entry exists and if it does
		**	check the ownership to make sure this node has permission to
		**	change the entry.
		*/
		registry_entry = GetRegistryEntry (	registry_key_data );
		
		if (registry_entry != NULL)
		{
			/*
			**	Here we make sure that this request is comming from an 
			**	APE that previously enrolled in the appropriate session.  
			*/
			m_pAppRosterMgrList->Reset();
			while (NULL != (lpAppRosterMgr = m_pAppRosterMgrList->Iterate()))
			{
				if (lpAppRosterMgr->IsAPEEnrolled (registry_key_data->GetSessionKey (),
													requester_node_id,
													requester_entity_id))
				{
					application_is_enrolled = TRUE;
					break;
				}
			}

			/*
			**	Check ownership rights here: First check is to make
			**	sure that this is the owner if Owner rights is 
			**	specified.  Next check is to make sure that
			*/ 
			if (((registry_entry->modification_rights == GCC_OWNER_RIGHTS) && 
					(registry_entry->owner_id == requester_node_id) &&
				 	(registry_entry->entity_id == requester_entity_id)) ||
				((registry_entry->modification_rights == GCC_SESSION_RIGHTS) && 
					(application_is_enrolled)) ||
				(registry_entry->modification_rights == GCC_PUBLIC_RIGHTS) ||
				(registry_entry->owner_id == 0))
			{
				DBG_SAVE_FILE_LINE
				registry_item_data = new CRegItem(&registry_item, &rc);
				if ((registry_item_data != NULL) && (rc == GCC_NO_ERROR))
				{
					//	Monitoring state should not be affected by this request
					*registry_entry->entry_item = *registry_item_data;

					/*
					**	Only the owner is allowed to change the modification
					**	rights of a registry entry (unless the entry is
					**	unowned). Also if there is no owner, we set up the
					**	new owner here.
					*/
					if (((registry_entry->owner_id == requester_node_id) &&
						(registry_entry->entity_id == requester_entity_id)) ||
						(registry_entry->owner_id == 0))
					{
						/*
						**	This will take care of setting up the new owner if 
						**	one exists.
						*/
						registry_entry->owner_id = requester_node_id;
						registry_entry->entity_id = requester_entity_id;

						/*
						**	If no modification rights are specified we must
						**	set the modification rights to be public.
						*/
						if (modification_rights != 
									GCC_NO_MODIFICATION_RIGHTS_SPECIFIED)
						{
							registry_entry->modification_rights = modification_rights;
						}
					}

					//	Send Monitor Indication if necessary
					if (registry_entry->monitoring_state == ON)
					{
						/*
						**	Deliver the monitor indication to the Top
						**	Provider's Node Controller if necessary.
						*/
						SendMonitorEntryIndicationMessage(registry_entry);
						
						/*
						**	Broadcast a monitor entry indication to all
						**	nodes in the conference.
						*/
						m_pMCSUserObject->RegistryMonitorEntryIndication(
								registry_entry->registry_key,
								registry_entry->entry_item,
								registry_entry->owner_id,
								registry_entry->entity_id,
								registry_entry->modification_rights);
					}

    			    registry_item_data->Release();

					//	Send success for the result
					result = GCC_RESULT_SUCCESSFUL;
				}
				else if (registry_item_data == NULL)
				{
					rc = GCC_ALLOCATION_FAILURE;
					result = GCC_RESULT_RESOURCES_UNAVAILABLE;
				}
				else
				{
					registry_item_data->Release();
					result = GCC_RESULT_RESOURCES_UNAVAILABLE;
				}
			}
			else
				result = GCC_RESULT_INDEX_ALREADY_OWNED;

			//	No ownership rights send back negative result
			m_pMCSUserObject->RegistryResponse(SET_PARAMETER,
											requester_node_id,
											requester_entity_id,
										   	registry_key_data,
											registry_entry->entry_item,
									   		registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
									  		result);
		}
		else
		{
			DBG_SAVE_FILE_LINE
			registry_entry = new REG_ENTRY;
			if (registry_entry != NULL)
			{
				DBG_SAVE_FILE_LINE
				registry_item_data = new CRegItem(&registry_item, &rc);
				if ((registry_item_data != NULL) && (rc == GCC_NO_ERROR))
				{
					//	Fill in the new entry
					DBG_SAVE_FILE_LINE
					registry_entry->registry_key = new CRegKeyContainer(registry_key_data, &rc);
					if ((registry_entry->registry_key != NULL) && (rc == GCC_NO_ERROR))
					{
						registry_entry->entry_item = registry_item_data;
						registry_entry->monitoring_state = OFF;
						registry_entry->owner_id = requester_node_id;
						registry_entry->entity_id = requester_entity_id;

						/*
						**	If no modification rights are specified we must
						**	initialize the modification rights to be public.
						**	Note that modification rights are only specified
						**	for the SetParameter call.
						*/
						if (modification_rights == GCC_NO_MODIFICATION_RIGHTS_SPECIFIED)
						{
							registry_entry->modification_rights = GCC_PUBLIC_RIGHTS;
						}
						else
						{
							registry_entry->modification_rights = modification_rights;
						}

						//	Add registry entry to registry list
						m_RegEntryList.Append(registry_entry);

						//	Send success for the result
						m_pMCSUserObject->RegistryResponse(
											SET_PARAMETER,
											requester_node_id,
											requester_entity_id,
									   		registry_key_data,
									   		registry_entry->entry_item,
						   					registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
								    		GCC_RESULT_SUCCESSFUL);
					}
					else  if (registry_entry->registry_key == NULL)
					{
						registry_item_data->Release();
						delete registry_entry;
						rc = GCC_ALLOCATION_FAILURE;
					}
					else
					{
						registry_entry->registry_key->Release();
						registry_item_data->Release();
						delete registry_entry;
					}
				}
				else if (registry_item_data == NULL)
				{
					delete registry_entry;
					rc = GCC_ALLOCATION_FAILURE;
				}
			}
			else
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
		}
	}
	else
	{
		m_pMCSUserObject->RegistryResponse(
								SET_PARAMETER,	
								requester_node_id,
								requester_entity_id,
						   		registry_key_data,
						   		NULL,
						   		GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
								0,
								0,
					    		GCC_RESULT_INVALID_REQUESTER);
	}
	
	return (rc);
}

/*
 *	void	ProcessRetrieveEntryPDU ()
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to retrieve a registry entry.  It is responsible for returning 
 *		any necessary responses that must be sent back to the requesting node.
 */
void	CRegistry::ProcessRetrieveEntryPDU (
										CRegKeyContainer    *registry_key_data,
										UserID				requester_node_id,
										EntityID			requester_entity_id)
{
	REG_ENTRY   *registry_entry;

	registry_entry = GetRegistryEntry (	registry_key_data );

	if (registry_entry != NULL)
	{
		//	Send back a positive result with the entry item
		m_pMCSUserObject->RegistryResponse(RETRIEVE_ENTRY,
										requester_node_id,
										requester_entity_id,
									   	registry_key_data,
									   	registry_entry->entry_item,
					   					registry_entry->modification_rights,
										registry_entry->owner_id,
										registry_entry->entity_id,
								    	GCC_RESULT_SUCCESSFUL);
	}
	else
	{
		//	Send back a negative result
		m_pMCSUserObject->RegistryResponse(RETRIEVE_ENTRY,
										requester_node_id,
										requester_entity_id,
									   	registry_key_data,
										m_pEmptyRegItem,
										GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
										0,
										0,
										GCC_RESULT_ENTRY_DOES_NOT_EXIST);
	}
}

/*
 *	void	ProcessDeleteEntryPDU ()
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to delete a registry entry.  It is responsible for returning 
 *		any necessary responses that must be sent back to the requesting node.
 */
void	CRegistry::ProcessDeleteEntryPDU (
										CRegKeyContainer    *registry_key_data,
										UserID				requester_node_id,
										EntityID			requester_entity_id)
{
	REG_ENTRY                   *registry_entry;
	BOOL    					application_is_enrolled = FALSE;
	CAppRosterMgr				*lpAppRosterMgr;

	/*
	**	We first make sure that this request is comming from an APE that
	**	previously enrolled.  Here we are not worried about a specific
	**	session, only that the APE is enrolled.  
	*/
	m_pAppRosterMgrList->Reset();
	while (NULL != (lpAppRosterMgr = m_pAppRosterMgrList->Iterate()))
	{
		if (lpAppRosterMgr->IsAPEEnrolled (requester_node_id, requester_entity_id))
		{
			application_is_enrolled = TRUE;
			break;
		}
	}

	if (application_is_enrolled)
	{
		/*
		**	First check to see if the registry entry exists and if it does
		**	check the ownership to make sure this node has permission to
		**	change the entry.
		*/
		registry_entry = GetRegistryEntry (	registry_key_data );
		if (registry_entry != NULL)
		{
			if (((registry_entry->owner_id == requester_node_id) &&
				 (registry_entry->entity_id == requester_entity_id)) ||
				(registry_entry->owner_id == NULL))
			{
				m_pMCSUserObject->RegistryResponse(
											DELETE_ENTRY,
											requester_node_id,
											requester_entity_id,
										   	registry_key_data,
										   	registry_entry->entry_item,
						   					registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
									    	GCC_RESULT_SUCCESSFUL);

				/*
				**	First convert this to a non-entry incase it needs to
				**	be included in a monitor indication. We first delete
				**	the old entry item and replace it with an Emtpy item.
				*/
				if (NULL != registry_entry->entry_item)
				{
				    registry_entry->entry_item->Release();
				}
				registry_entry->entry_item = m_pEmptyRegItem;

				registry_entry->owner_id = 0;
				registry_entry->entity_id = 0;
				registry_entry->modification_rights = GCC_NO_MODIFICATION_RIGHTS_SPECIFIED;

				//	Send Monitor Indication if necessary
				if (registry_entry->monitoring_state == ON)
				{
					/*
					**	Deliver the monitor indication to the Top
					**	Provider's Node Controller if necessary.
					*/
					SendMonitorEntryIndicationMessage(registry_entry);
					
					/*
					**	Broadcast a monitor entry indication to all
					**	nodes in the conference.
					*/
					m_pMCSUserObject->RegistryMonitorEntryIndication(
									registry_entry->registry_key,
									registry_entry->entry_item,
									registry_entry->owner_id,
									registry_entry->entity_id,
									registry_entry->modification_rights);
				}
			
				//	Remove the entry from the list
				m_RegEntryList.Remove(registry_entry);

				if (NULL != registry_entry->registry_key)
				{
				    registry_entry->registry_key->Release();
				}
				delete registry_entry;
			}
			else
			{
				//	No ownership rights send back negative result
				m_pMCSUserObject->RegistryResponse(
											DELETE_ENTRY,
											requester_node_id,
											requester_entity_id,
										   	registry_key_data,
										   	registry_entry->entry_item,
						   					registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
									    	GCC_RESULT_INDEX_ALREADY_OWNED);
			}
		}
		else
		{
			//	Send failure for the result. Entry does not exist
			m_pMCSUserObject->RegistryResponse(
										DELETE_ENTRY,
										requester_node_id,
										requester_entity_id,
									   	registry_key_data,
										m_pEmptyRegItem,
										GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
										0,
										0,
										GCC_RESULT_ENTRY_DOES_NOT_EXIST);
		}
	}
	else
	{
		m_pMCSUserObject->RegistryResponse(
									DELETE_ENTRY,	
									requester_node_id,
									requester_entity_id,
							   		registry_key_data,
							   		NULL,
							   		GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
									0,
									0,
						    		GCC_RESULT_INVALID_REQUESTER);
	}
}

/*
 *	void	ProcessMonitorEntryPDU ()
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to monitor a registry entry.  It is responsible for returning 
 *		any necessary responses that must be sent back to the requesting node.
 */
void	CRegistry::ProcessMonitorEntryPDU (
							CRegKeyContainer        *registry_key_data,
							UserID					requester_node_id,
							EntityID				requester_entity_id )
{
	REG_ENTRY   *registry_entry;

	/*
	**	First check to see if the registry entry exists and if it does
	**	check the ownership to make sure this node has permission to
	**	change the entry.
	*/
	registry_entry = GetRegistryEntry (	registry_key_data );
	
	if (registry_entry != NULL)
	{
		//	Set the monitoring state to on for the life of this entry.
		registry_entry->monitoring_state = ON;
	
		//	No ownership rights send back negative result
		m_pMCSUserObject->RegistryResponse(MONITOR_ENTRY,
										requester_node_id,
										requester_entity_id,
									   	registry_key_data,
									   	registry_entry->entry_item,
					   					registry_entry->modification_rights,
										registry_entry->owner_id,
										registry_entry->entity_id,
								    	GCC_RESULT_SUCCESSFUL);
	}
	else
	{
		//	Send failure for the result. Entry does not exist
		m_pMCSUserObject->RegistryResponse(MONITOR_ENTRY,
										requester_node_id,
										requester_entity_id,
									   	registry_key_data,
										m_pEmptyRegItem,
										GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
										0,
										0,
										GCC_RESULT_ENTRY_DOES_NOT_EXIST);
	}
}

/*
 *	void	ProcessRegistryResponsePDU ()
 *
 *	Public Function Description
 *		This routine is used by nodes other than the top provider node to 
 *		process registry responses from the top provider.  It is responsible for 
 *		generating any local messages associated with this response.
 */
void	CRegistry::ProcessRegistryResponsePDU (
							RegistryResponsePrimitiveType	primitive_type,
							CRegKeyContainer                *registry_key_data,
							CRegItem                        *registry_item_data,
							GCCModificationRights			modification_rights,
							EntityID						requester_entity_id,
							UserID							owner_node_id,
							EntityID						owner_entity_id,
							GCCResult						result)
{
	GCCError			error_value = GCC_NO_ERROR;
	GCCMessageType  	message_type;
	CAppSap             *pAppSap;

	//	Pop the next outstanding request off the queue
	if (NULL != (pAppSap = m_AppSapEidList2.Find(requester_entity_id)))
	{
		switch (primitive_type)
		{
			case REGISTER_CHANNEL:
				message_type = GCC_REGISTER_CHANNEL_CONFIRM;
				break;
				
			case ASSIGN_TOKEN:
				message_type = GCC_ASSIGN_TOKEN_CONFIRM;
				break;
				
			case SET_PARAMETER:
				message_type = GCC_SET_PARAMETER_CONFIRM;
				break;
		
			case RETRIEVE_ENTRY:
				message_type = GCC_RETRIEVE_ENTRY_CONFIRM;
				break;
				
			case DELETE_ENTRY:
				message_type = GCC_DELETE_ENTRY_CONFIRM;
				break;
				
			case MONITOR_ENTRY:
				message_type = GCC_MONITOR_CONFIRM;

				/*
				**	Here we must check the result.  If the result failed
				**	we pull the monitoring SAP from the monitor list.
				*/
				if (result != GCC_RESULT_SUCCESSFUL)
				{
					RemoveAPEFromMonitoringList (	registry_key_data,
													requester_entity_id);
				}
				break;

			default:
				error_value = GCC_INVALID_PARAMETER;
				ERROR_OUT(("CRegistry::ProcessRegistryResponsePDU: Bad request type, primitive_type=%d", (UINT) primitive_type));
				break;
		}
		
		if (error_value == GCC_NO_ERROR)
		{
			/*
			**	Note the the monitor enable variable is always set to TRUE
			**	when a monitor response is received from the Top Provider.
			**	Otherwise, this is not even used.
			*/
			pAppSap->RegistryConfirm(m_nConfID,
									message_type,
									registry_key_data,
									registry_item_data,
									modification_rights,
									owner_node_id,
									owner_entity_id,
									TRUE,
									result);
		}
	}
	else
	{
		WARNING_OUT(("CRegistry::ProcessRegistryResponsePDU: no such app sap"));
	}
}

/*
 *	void	ProcessMonitorIndicationPDU ()
 *
 *	Public Function Description
 *		This routine is used by nodes other than the top provider node to 
 *		process registry monitor indications from the top provider.  It is 
 *		responsible for generating any local messages associated with this 
 *		response.
 */
void	CRegistry::ProcessMonitorIndicationPDU (
								CRegKeyContainer        *registry_key_data,
								CRegItem                *registry_item_data,
								GCCModificationRights	modification_rights,
								UserID					owner_node_id,
								EntityID				owner_entity_id)
{
	REG_ENTRY           *lpRegEntry;
	EntityID			eid;
	CAppSap             *pAppSap;

	m_RegEntryList.Reset();
	while (NULL != (lpRegEntry = m_RegEntryList.Iterate()))
	{
		if (*registry_key_data == *lpRegEntry->registry_key)
		{
			lpRegEntry->monitoring_list.Reset();
			while (GCC_INVALID_EID != (eid = lpRegEntry->monitoring_list.Iterate()))
			{
				if (NULL != (pAppSap = m_AppSapEidList2.Find(eid)))
				{
					pAppSap->RegistryMonitorIndication(m_nConfID,
														registry_key_data,
														registry_item_data,
														modification_rights,
														owner_node_id,
														owner_entity_id);
				}
			}
		}
	}
}

/*
 *	void	ProcessAllocateHandleRequestPDU ()
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to allocate a number of handles.  It is responsible for 
 *		returning any necessary responses that must be sent back to the 
 *		requesting node.
 */
void	CRegistry::ProcessAllocateHandleRequestPDU (
							UINT					number_of_handles,
							EntityID				requester_entity_id,
							UserID					requester_node_id)
{
	UINT		temp_registry_handle;

	if (m_fTopProvider)
	{
		if ((number_of_handles > 0) &&
			(number_of_handles <= MAXIMUM_ALLOWABLE_ALLOCATED_HANDLES))
		{
			temp_registry_handle = m_nRegHandle + number_of_handles;
			
			if (temp_registry_handle > m_nRegHandle)
			{
				m_pMCSUserObject->RegistryAllocateHandleResponse(
										number_of_handles,
										m_nRegHandle,
										requester_entity_id,
										requester_node_id,
										GCC_RESULT_SUCCESSFUL);
										
				m_nRegHandle = temp_registry_handle;
			}
			else
			{
				m_pMCSUserObject->RegistryAllocateHandleResponse(
										number_of_handles,
										0,
										requester_entity_id,
										requester_node_id,
										GCC_RESULT_NO_HANDLES_AVAILABLE);
			}
		}
		else
		{
			m_pMCSUserObject->RegistryAllocateHandleResponse(
										number_of_handles,
										0,
										requester_entity_id,
										requester_node_id,
										GCC_RESULT_INVALID_NUMBER_OF_HANDLES);
		}
	}
}

/*
 *	void	ProcessAllocateHandleResponsePDU ()
 *
 *	Public Function Description
 *		This routine is used by a node other than the top provider node to 
 *		process an allocate handle response.  It is responsible for generating 
 *		any local messages associated with this response.
 */
void	CRegistry::ProcessAllocateHandleResponsePDU (
							UINT					number_of_handles,
							UINT					first_handle,
							EntityID				eidRequester,
							GCCResult				result)
{
	CAppSap *pAppSap;

	if (NULL != (pAppSap = m_AppSapEidList2.Find(eidRequester)))
	{
		pAppSap->RegistryAllocateHandleConfirm(m_nConfID,
												number_of_handles,
												first_handle,
												result);
	}
}

/*
 *	void	RemoveNodeOwnership ()
 *
 *	Public Function Description
 *		This routine removes ownership of all the registry entries associated 
 *		with the specified node ID.  These entries become unowned. This request 
 *		should only be made from the top provider node.  This is a local 
 *		operation.
 */
void	CRegistry::RemoveNodeOwnership (
										UserID				node_id )
{
	if (m_fTopProvider)
	{
		REG_ENTRY   *lpRegEntry;

		m_RegEntryList.Reset();
		while (NULL != (lpRegEntry = m_RegEntryList.Iterate()))
		{
			if (lpRegEntry->owner_id == node_id)
			{
				lpRegEntry->owner_id = 0;
				lpRegEntry->entity_id = 0;
			
				//	Send Monitor Indication if necessary
				if (lpRegEntry->monitoring_state == ON)
				{
					/*
					**	Deliver the monitor indication to the Top
					**	Provider's Node Controller if necessary.
					*/
					SendMonitorEntryIndicationMessage (lpRegEntry);
				
					m_pMCSUserObject->RegistryMonitorEntryIndication(
							lpRegEntry->registry_key,
							lpRegEntry->entry_item,
							lpRegEntry->owner_id,
							lpRegEntry->entity_id,
							lpRegEntry->modification_rights);
				}
			}
		}
	}
}

/*
 *	void	RemoveEntityOwnership ()
 *
 *	Public Function Description
 *		This routine removes ownership of all the registry entries associated 
 *		with the specified APE.  These entries become unowned. This request 
 *		should only be made from the top provider node.  This is a local 
 *		operation.
 */
void	CRegistry::RemoveEntityOwnership (
										UserID				node_id,
										EntityID			entity_id )
{
	if (m_fTopProvider)
	{
		REG_ENTRY   *lpRegEntry;

		m_RegEntryList.Reset();
		while (NULL != (lpRegEntry = m_RegEntryList.Iterate()))
		{
			if ((lpRegEntry->owner_id == node_id) &&
				(lpRegEntry->entity_id == entity_id))
			{
				lpRegEntry->owner_id = 0;
				lpRegEntry->entity_id = 0;
			
				//	Send Monitor Indication if necessary
				if (lpRegEntry->monitoring_state == ON)
				{
					/*
					**	Deliver the monitor indication to the Top
					**	Provider's Node Controller if necessary.
					*/
					SendMonitorEntryIndicationMessage(lpRegEntry);
				
					m_pMCSUserObject->RegistryMonitorEntryIndication(
							lpRegEntry->registry_key,
							lpRegEntry->entry_item,
							lpRegEntry->owner_id,
							lpRegEntry->entity_id,
							lpRegEntry->modification_rights);
				}
			}
		}
	}
}

/*
 *	void	RemoveSessionKeyReference ()
 *
 *	Public Function Description
 *		This routine removes all registry entries associated with the
 *		specified session.  This is a local operation.
 */
void	CRegistry::RemoveSessionKeyReference(CSessKeyContainer *session_key)
{
	BOOL    		keys_match;
    CRegKeyContainer *registry_key_data;
	
	if (m_fTopProvider)
	{
		/*
		**	This outer loop is to handle resetting the rogue wave iterator.
		**	You can not delete a list entry while in the iterator with out
		**	resetting it.
		*/
		while (1)
		{
			REG_ENTRY   *lpRegEntry;

			keys_match = FALSE;
			m_RegEntryList.Reset();
			while (NULL != (lpRegEntry= m_RegEntryList.Iterate()))
			{
				registry_key_data = lpRegEntry->registry_key;

				if (registry_key_data->IsThisYourSessionKey (session_key))
					keys_match = TRUE;

				if (keys_match)
				{
					/*
					**	First convert this to a non-entry incase it needs to
					**	be included in a monitor indication. We first delete
					**	the old entry item and replace it with an Emtpy item.
					*/
					if (NULL != lpRegEntry->entry_item)
					{
					    lpRegEntry->entry_item->Release();
					}
					lpRegEntry->entry_item = m_pEmptyRegItem;
					lpRegEntry->owner_id = 0;
					lpRegEntry->entity_id = 0;
					lpRegEntry->modification_rights = GCC_NO_MODIFICATION_RIGHTS_SPECIFIED;

					//	Send Monitor Indication if necessary
					if (lpRegEntry->monitoring_state == ON)
					{
						/*
						**	Deliver the monitor indication to the Top
						**	Provider's Node Controller if necessary.
						*/
						SendMonitorEntryIndicationMessage(lpRegEntry);
						
						/*
						**	Broadcast a monitor entry indication to all
						**	nodes in the conference.
						*/
						m_pMCSUserObject->RegistryMonitorEntryIndication(
									lpRegEntry->registry_key,
									lpRegEntry->entry_item,
									lpRegEntry->owner_id,
									lpRegEntry->entity_id,
									lpRegEntry->modification_rights);
					}
		
					if (NULL != lpRegEntry->registry_key)
					{
					    lpRegEntry->registry_key->Release();
					}
					m_RegEntryList.Remove(lpRegEntry);
					delete lpRegEntry;
					break;
				}
			}
			
			if (keys_match == FALSE)
				break;
		}
	}
}

/*
 *	REG_ENTRY *GetRegistryEntry ()
 *
 *	Private Function Description
 *		This routine is responsible for searching the registry list for
 *		the registry entry specified by the passed in registry key.  NULL
 *		is returned if the entry can not be found.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i) Registry key associated with entry to get.
 *
 *	Return Value
 *		Pointer to the registry item assoicated with the specified registry
 *		key.  NULL if it does not exists.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
REG_ENTRY *CRegistry::GetRegistryEntry(CRegKeyContainer *registry_key_data)
{
	REG_ENTRY           *registry_entry = NULL;
	REG_ENTRY           *lpRegEntry;

	m_RegEntryList.Reset();
	while (NULL != (lpRegEntry = m_RegEntryList.Iterate()))
	{
		if (*lpRegEntry->registry_key == *registry_key_data)
		{
			registry_entry = lpRegEntry;
			break;
		}
	}

	return (registry_entry);
}

/*
 *	TokenID GetUnusedToken ()
 *
 *	Private Function Description
 *		This routine is responsible for generating an unused token.  The routine
 *		will return a token ID of zero if all are used up (this is very
 *		unlikely).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		The generated token ID.  Zero if no token IDs are available.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
TokenID		CRegistry::GetUnusedToken ()
{
	TokenID				token_id = 0;
	CRegItem            *registry_item_data;
	REG_ENTRY           *lpRegEntry;
	
	while (token_id == 0)
	{
		token_id = m_nCurrentTokenID;
		m_nCurrentTokenID++;
		
		if (m_nCurrentTokenID == (TokenID)0xffff)
        {
			m_nCurrentTokenID = (TokenID)16384;
        }

		m_RegEntryList.Reset();
		while (NULL != (lpRegEntry = m_RegEntryList.Iterate()))
		{
			registry_item_data = lpRegEntry->entry_item;
		
			if (registry_item_data->IsThisYourTokenID(token_id))	
			{
				token_id = 0;
				break;
			}
		}
	}
	
	return (token_id);
}

/*
 *	GCCError	AddAPEToMonitoringList ()
 *
 *	Private Function Description
 *		This routine is used to add a new APE to the monitoring list.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with entry being
 *									monitored.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									doing the monitoring.
 *		requester_sap		-	(i)	Pointer to the command target associated 
 *									with APE making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError	CRegistry::AddAPEToMonitoringList(	
									CRegKeyContainer *registry_key_data,
									EntityID		entity_id,
									CAppSap         *requester_sap)
{
	GCCError			rc = GCC_NO_ERROR;
	REG_ENTRY           *registry_entry;
	BOOL    			entry_does_exists;
	GCCRegistryItem		registry_item;
	
	registry_entry = GetRegistryEntry (registry_key_data);
	
	/*
	**	If the registry does not exists we go ahead and create an empty
	**	entry here.
	*/
	if (registry_entry == NULL)
	{
		DBG_SAVE_FILE_LINE
		registry_entry = new REG_ENTRY;
		if (registry_entry != NULL)
		{
			//	First allocate an empty registry item
			registry_item.item_type = GCC_REGISTRY_NONE;
			DBG_SAVE_FILE_LINE
			registry_entry->entry_item = new CRegItem(&registry_item, &rc);
			if ((registry_entry->entry_item != NULL) && (rc == GCC_NO_ERROR))
			{
				//	Next allocate the registry key
				DBG_SAVE_FILE_LINE
				registry_entry->registry_key = new CRegKeyContainer(registry_key_data, &rc);
				if ((registry_entry->registry_key != NULL) && (rc == GCC_NO_ERROR))
				{
					/*
					**	If everything is OK up to here we go ahead and add the
					**	registry entry to the local entry list.
					*/
					m_RegEntryList.Append(registry_entry);
				}
				else if (registry_entry->registry_key == NULL)
				{
					rc = GCC_ALLOCATION_FAILURE;
					registry_entry->entry_item->Release();
				}
				else
				{
					registry_entry->registry_key->Release();
					registry_entry->entry_item->Release();
				}
			}
			else if (registry_entry->entry_item == NULL)
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
			else
            {
				registry_entry->entry_item->Release();
            }
			
			if (rc != GCC_NO_ERROR)
            {
				delete registry_entry;
            }
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	
	if (rc == GCC_NO_ERROR)
	{
		m_AppSapEidList2.Append(entity_id, requester_sap);

		/*
		**	Make sure that this entry does not already exists in the
		**	monitoring list.
		*/
		EntityID eid;
		registry_entry->monitoring_list.Reset();
		entry_does_exists = FALSE;
		while (GCC_INVALID_EID != (eid = registry_entry->monitoring_list.Iterate()))
		{
			if (eid == entity_id)
			{
				entry_does_exists = TRUE;
				break;
			}
		}
		
		if (entry_does_exists == FALSE)
		{
			registry_entry->monitoring_list.Append(entity_id);
		}
	}

	return rc;
}

/*
 *	void	RemoveAPEFromMonitoringList ()
 *
 *	Private Function Description
 *		This routine is used to remove an APE from the monitoring list.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with entry being
 *									monitored.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									being removed from the monitoring list.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CRegistry::RemoveAPEFromMonitoringList(	
									CRegKeyContainer        *registry_key_data,
									EntityID				entity_id)
{
	REG_ENTRY   *registry_entry;

	registry_entry = GetRegistryEntry (registry_key_data);
	if (registry_entry != NULL)
	{
		/*
		**	Make sure that this entry does not already exists in the
		**	monitoring list.
		*/
		registry_entry->monitoring_list.Remove(entity_id);
	}
}

/*
 *	void	SendMonitorEntryIndicationMessage ()
 *
 *	Private Function Description
 *		This routine is used to generate a monitor indication to all the
 *		APEs that are currently monitoring the specified registry entry.
 *
 *	Formal Parameters:
 *		registry_entry	-	(i)	Pointer to the registry entry being monitored.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CRegistry::SendMonitorEntryIndicationMessage(REG_ENTRY *registry_entry)
{
    EntityID    eid;
    CAppSap      *pAppSap;

	registry_entry->monitoring_list.Reset();
	while (GCC_INVALID_EID != (eid = registry_entry->monitoring_list.Iterate()))
	{
		if (NULL != (pAppSap = m_AppSapEidList2.Find(eid)))
		{
			pAppSap->RegistryMonitorIndication(
									m_nConfID,
									registry_entry->registry_key,
									registry_entry->entry_item,
									registry_entry->modification_rights,
									registry_entry->owner_id,
									registry_entry->entity_id);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\privchnl.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	privchnl.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the PrivateChannel class.  It
 *		contains the code that distinguishes this class from that of its parent,
 *		Channel.
 *
 *		This class maintains an authorized user list, and includes the code
 *		necessary to use that list.  No user will be allowed to join or send
 *		data on a private channel unless they are either the channel manager
 *		or an admitted user.
 *
 *	Private Instance Variables:
 *		m_uidChannelManager
 *			This is the User ID of the user that convened the private channel.
 *			Only this user is allowed to manipulate the authorized user list.
 *			When a private channel becomes invalid (as the result of a channel
 *			disband request or indication), this value will be set to 0.
 *		m_AuthorizedUserList
 *			This is a collection containing the user IDs of those users that
 *			have been admitted to the private channel by the channel manager.
 *			Other than the manager, these are the only users that are allowed
 *			to join or send data on the channel.  When a private channel becomes
 *			invalid (as the result of a channel disband request or indication),
 *			this list will be cleared.
 *		m_fDisbandRequestPending
 *			This is a boolean flag that gets set when a disband request is
 *			forwarded upward to the top provider.  This prevents this channel
 *			from issuing a disband indication to the channel manager when it
 *			comes back down the tree from the top provider.
 *
 *	Private Member Functions:
 *		ValidateUserID
 *			This member function is called to verify that a specified user ID
 *			corresponds to a valid user in the sub-tree of the local provider.
 *		BuildAttachmentLists
 *			This member function is called to build two lists of attachments
 *			from a master user ID list.  The first list contains all local
 *			attachments whose user ID is in the specified list.  The second
 *			list contains all remote attachments whose user ID is in the
 *			specified list.  These lists are used to issue various indications
 *			to specified users without sending any to the same attachment.
 *		BuildUserIDList
 *			This member function is called to build a list of users that lie
 *			in the direction of a specified attachment.  These lists are
 *			sent along with PDUs that require them.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

/*
 *	External Interfaces
 */

#include "privchnl.h"


/*
 *	PrivateChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the primary constructor for PrivateChannel objects.  It creates
 *		an object with all instance variable initialized, but with no
 *		attachments (i.e. no users are joined to the channel automatically).
 *
 *		Note that most instance variable initialization is done by invoking the
 *		equivalent constructor in the base class.
 *
 *		Upon successful completion, a  channel convene confirm is automatically
 *		issued to the channel manager, if the channel manager is in the sub-tree
 *		of this provider.  Note that if the channel manager is NOT in this
 *		sub-tree, then this private channel object was probably created as the
 *		result of a channel admit indication, and no channel convene confirm
 *		will be issued.
 */
PrivateChannel::PrivateChannel (
		ChannelID			channel_id,
		UserID				channel_manager,
		PDomain             local_provider,
		PConnection         top_provider,
		CChannelList2      *channel_list,
		CAttachmentList    *attachment_list)
:
	Channel(channel_id, local_provider, top_provider, channel_list, attachment_list),
	m_AuthorizedUserList(),
	m_uidChannelManager(channel_manager),
	m_fDisbandRequestPending(FALSE)
{
	/*
	 *	Check to see if the channel manager lies in the sub-tree of this
	 *	provider.  If so, then this object was created as the result of a
	 *	channel convene request or confirm, and it is necessary to issue the
	 *	confirm toward that user.  If not, then this object was created as the
	 *	result of a channel admit indication, and it is not necessary to send
	 *	the channel convene confirm.
	 */
	if (ValidateUserID(m_uidChannelManager))
	{
		PChannel	lpChannel;
		/*
		 *	Determine which attachment leads to the channel manager by asking
		 *	the channel object corresponding to it.  Then issue the confirm
		 *	to that attachment.
		 */
		if (NULL != (lpChannel = m_pChannelList2->Find(m_uidChannelManager)))
		{
		    CAttachment *pAtt = lpChannel->GetAttachment();
		    if (pAtt)
		    {
    		    pAtt->ChannelConveneConfirm(RESULT_SUCCESSFUL,
    		                                m_uidChannelManager, channel_id);
            }
            else
            {
                ERROR_OUT(("PrivateChannel::PrivateChannel: null attachment"));
            }
		}
	}
}

/*
 *	PrivateChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is a secondary constructor that is only used during merge
 *		operations.  The intent of this constructor is to create an equivalent
 *		object without issuing any of the confirms.
 *
 *		Note that the additional constructor allows for the creator to specify
 *		that there is an attachment already joined to the channel upon creation.
 */
PrivateChannel::PrivateChannel (
		ChannelID			channel_id,
		UserID				channel_manager,
		PDomain             local_provider,
		PConnection         top_provider,
		CChannelList2      *channel_list,
		CAttachmentList    *attachment_list,
		CUidList           *admitted_list,
		PConnection         pConn)
:
	Channel(channel_id, local_provider, top_provider, channel_list, attachment_list, pConn),
	m_AuthorizedUserList(),
	m_uidChannelManager(channel_manager),
	m_fDisbandRequestPending(FALSE)
{
	UserID		uid;

	/*
	 *	Copy the initial contents of the admitted list into the authorized
	 *	user list.
	 */
	admitted_list->Reset();
	while (NULL != (uid = admitted_list->Iterate()))
	{
		m_AuthorizedUserList.Append(uid);
	}
}

/*
 *	~PrivateChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This destructor walks through the admitted list, sending expel
 *		indications to any admitted users that are locally attached.  If the
 *		channel manager is locally attached, and this channel is being deleted
 *		a reason other than a previous disband request, then a disband
 *		indication will be sent to the channel manager.
 */
PrivateChannel::~PrivateChannel ()
{
	CAttachmentList         local_attachment_list;
	CAttachmentList         remote_attachment_list;
	CAttachment            *pAtt;
	CUidList                user_id_list;

	/*
	 *	Assemble lists of the attachments that lead to authorized users in
	 *	the sub-tree of this provider.
	 */
	BuildAttachmentLists (&m_AuthorizedUserList, &local_attachment_list,
			&remote_attachment_list);

	/*
	 *	For each local attachment, issue a channel expel indication letting the
	 *	user know that the channel is no longer valid.
	 */
	local_attachment_list.Reset();
	while (NULL != (pAtt = local_attachment_list.Iterate()))
	{
		/*
		 *	Get the next attachment from the list and build a list of the users
		 *	that lie in the direction of that attachment.
		 */
		BuildUserIDList(&m_AuthorizedUserList, pAtt, &user_id_list);

		/*
		 *	Send the indication.
		 */
		pAtt->ChannelExpelIndication(Channel_ID, &user_id_list);
	}

	/*
	 *	If the channel manager is a locally attached user, then send it a
	 *	ChannelDisbandIndication informing it that the channel is no longer
	 *	valid.
	 */
	if ((m_fDisbandRequestPending == FALSE) && ValidateUserID(m_uidChannelManager))
	{
		PChannel		lpChannel;

		if (NULL != (lpChannel = m_pChannelList2->Find(m_uidChannelManager)))
		{
    		CAttachment *pAtt1 = lpChannel->GetAttachment();
    		if (m_pAttachmentList->Find(pAtt1) && pAtt1->IsUserAttachment())
    		{
    		    PUser pUser = (PUser) pAtt1;
    			pUser->ChannelDisbandIndication(Channel_ID);
    	    }
    	}
	}

	/*
	 *	Clear the lists associated with this object.  Note that this also
	 *	prevents the base class destructor from issuing ChannelLeaveIndications
	 *	to any local attachments in the joined attachment list (which would be
	 *	inappropriate).
	 */
	m_AuthorizedUserList.Clear();
	m_JoinedAttachmentList.Clear();
}

/*
 *	Channel_Type		GetChannelType ()
 *
 *	Public
 *
 *	Functional Description:
 *		Objects of this class are always private channels, so simply return
 *		PRIVATE_CHANNEL.
 */
Channel_Type		PrivateChannel::GetChannelType ()
{
	return (PRIVATE_CHANNEL);
}

/*
 *	BOOL    IsValid ()
 *
 *	Public
 *
 *	Functional Description:
 *		By convention, if the m_uidChannelManager is in the sub-tree of this
 *		provider OR if there are any users in the authorized user list, then
 *		the private channel is valid.  Otherwise it is not, and can be deleted
 *		by the domain object.
 */
BOOL    PrivateChannel::IsValid ()
{
	UserID			uid;
	CUidList		deletion_list;

	/*
	 *	Loop through the authorized user list making a list of those entries
	 *	that are no longer valid.
	 */
	m_AuthorizedUserList.Reset();
	while (NULL != (uid = m_AuthorizedUserList.Iterate()))
	{
		if (ValidateUserID(uid) == FALSE)
			deletion_list.Append(uid);
	}

	/*
	 *	Loop through the deletion list created above, deleting those user IDs
	 *	that are no longer valid.
	 */
	deletion_list.Reset();
	while (NULL != (uid = deletion_list.Iterate()))
	{
		m_AuthorizedUserList.Remove(uid);
	}

	/*
	 *	If this is the Top Provider, then the channel manager should ALWAYS be
	 *	in the sub-tree.  If it is not, then this indicates that the channel
	 *	manager has detached (willingly or otherwise).  When this happens it
	 *	is necessary to simulate a channel disband request (only if there are
	 *	other admitted users who need to receive a channel expel indication).
	 */
	if ((m_pConnToTopProvider == NULL) &&
			(ValidateUserID(m_uidChannelManager) == FALSE) &&
			(m_AuthorizedUserList.IsEmpty() == FALSE))
	{
		TRACE_OUT (("PrivateChannel::IsValid: "
				"simulating ChannelDisbandRequest"));
		ChannelDisbandRequest(NULL, m_uidChannelManager, Channel_ID);
	}

	/*
	 *	Check to see if the channel manager is in the sub-tree of this provider
	 *	or if the authorized user list is not empty.  If either is TRUE, then
	 *	then the channel is still valid.
	 */
	return (ValidateUserID(m_uidChannelManager) || (m_AuthorizedUserList.IsEmpty() == FALSE));
}

/*
 *	CAttachment *GetAttachment ()
 *
 *	Public
 *
 *	Functional Description:
 *		Return a pointer to the attachment leading to the channel manager.
 */
CAttachment *PrivateChannel::GetAttachment(void)
{
	if (ValidateUserID(m_uidChannelManager))
    {
		PChannel	lpChannel;
		if (NULL != (lpChannel = m_pChannelList2->Find(m_uidChannelManager)))
		{
            return lpChannel->GetAttachment();
        }
	}
	return NULL;
}

/*
 *	Void	IssueMergeRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		Issue a merge request for the information contained in this
 *		PrivateChannel object.
 */
Void	PrivateChannel::IssueMergeRequest ()
{
	ChannelAttributes		channel_attributes;
	CChannelAttributesList	merge_channel_list;
	CChannelIDList			purge_channel_list;

	if (m_pConnToTopProvider != NULL)
	{
		/*
		 *	Fill in the fields of the channel attributes structure so that it
		 *	accurately describes this channel.  Then put the structure into the
		 *	merge channel list.
		 */
		channel_attributes.channel_type = PRIVATE_CHANNEL;
		if (m_JoinedAttachmentList.IsEmpty() )
			channel_attributes.u.private_channel_attributes.joined = FALSE;
		else
			channel_attributes.u.private_channel_attributes.joined = TRUE;
		channel_attributes.u.private_channel_attributes.channel_id = Channel_ID;
		channel_attributes.u.private_channel_attributes.channel_manager = m_uidChannelManager;
		channel_attributes.u.private_channel_attributes.admitted_list =	&m_AuthorizedUserList;

		merge_channel_list.Append(&channel_attributes);

		/*
		 *	Send the merge request to the indicated provider.
		 */
		m_pConnToTopProvider->MergeChannelsRequest(&merge_channel_list, &purge_channel_list);
	}
}

/*
 *	Void	ChannelJoinRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function overrides the base class implementation.  The main
 *		difference is that this implementation only allows a user to join
 *		the private channel if it is either the channel manager or in the
 *		authorized user list.
 */
Void	PrivateChannel::ChannelJoinRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	/*
	 *	See if the requesting user is either the channel manager or in the
	 *	authorized user list.
	 */
	if ((uidInitiator == m_uidChannelManager) || m_AuthorizedUserList.Find(uidInitiator))
	{
		/*
		 *	See if anyone is currently joined to the channel in this sub-tree
		 */
		if (m_JoinedAttachmentList.IsEmpty())
		{
			/*
			 *	If this is the Top Provider, then this request can be handled
			 *	locally.
			 */
			if (IsTopProvider())
			{
				/*
				 *	There is no one in this sub-tree joined to the channel.  It
				 *	will therefore be necessary to add the originator to the
				 *	attachment list.
				 */
				TRACE_OUT (("PrivateChannel::ChannelJoinRequest: "
						"user %04X joining private channel = %04X",
						(UINT) uidInitiator, (UINT) Channel_ID));
				m_JoinedAttachmentList.Append(pOrigAtt);

				/*
				 *	Send a ChannelJoinConfirm downward to the originator.
				 */
				pOrigAtt->ChannelJoinConfirm(RESULT_SUCCESSFUL, uidInitiator, channel_id, Channel_ID);
			}
			else
			{
				/*
				 *	This is not the Top Provider.  Forward the join request
				 *	upward to the Top Provider.
				 */
				TRACE_OUT (("PrivateChannel::ChannelJoinRequest: "
						"forwarding join request to Top Provider"));
				m_pConnToTopProvider->ChannelJoinRequest(uidInitiator, Channel_ID);
			}
		}

		/*
		 *	There is at least one attachment joined to the channel, which means
		 *	that we do not have to forward the join request upward (even if
		 *	this is not the Top Provider).  Now check to see if the requesting
		 *	originator is already joined to the channel.
		 */
		else if (m_JoinedAttachmentList.Find(pOrigAtt) == FALSE)
		{
			/*
			 *	The originator is not yet joined to the channel, so add it to
			 *	the channel.
			 */
			TRACE_OUT (("PrivateChannel::ChannelJoinRequest: "
					"user %04X joining private channel = %04X",
					(UINT) uidInitiator, (UINT) Channel_ID));
			m_JoinedAttachmentList.Append(pOrigAtt);

			/*
			 *	Send a ChannelJoinConfirm downward to the originator.
			 */
			pOrigAtt->ChannelJoinConfirm(RESULT_SUCCESSFUL, uidInitiator, channel_id, Channel_ID);
		}

		else
		{
			/*
			 *	The originator is already joined to the channel.  Go ahead and
			 *	issue a successful channel join confirm.
			 */
			WARNING_OUT (("PrivateCh